[
    {
        "ins1CurCode":"} mserver.registerMBean(mbean, oname); return mbean; ",
        "ins1PreCode":"} mserver.registerMBean(mbean, oname); return (mbean); ",
        "ins2PreCode":"} mserver.registerMBean(mbean, oname); return (mbean); ",
        "label":1
    },
    {
        "ins1CurCode":"void sslNeedsClientAuthenticationFailsWithoutClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void sslNeedsClientAuthenticationFailsWithoutClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void sslWantsClientAuthenticationSucceedsWithoutClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory();",
        "label":1
    },
    {
        "ins1CurCode":"private void setUpNonLogin() throws Exception {   nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); nonloginContext.setSessionTimeout(LONG_SESSION_TIMEOUT_MINS);   Tomcat.addServlet(nonloginContext, \"TesterServlet1\", new TesterServletEncodeUrl()); nonloginContext.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); nonloginContext.addConstraint(sc1);   Tomcat.addServlet(nonloginContext, \"TesterServlet2\", new TesterServletEncodeUrl()); nonloginContext.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); nonloginContext.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); nonloginContext.setLoginConfig(lc); AuthenticatorBase nonloginAuthenticator = new NonLoginAuthenticator(); nonloginContext.getPipeline().addValve(nonloginAuthenticator);",
        "ins1PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "ins2PreCode":"private void setUpNonLogin() throws Exception {   nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); nonloginContext.setSessionTimeout(LONG_SESSION_TIMEOUT_MINS);   Tomcat.addServlet(nonloginContext, \"TesterServlet1\", new TesterServlet()); nonloginContext.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); nonloginContext.addConstraint(sc1);   Tomcat.addServlet(nonloginContext, \"TesterServlet2\", new TesterServlet()); nonloginContext.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); nonloginContext.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); nonloginContext.setLoginConfig(lc); AuthenticatorBase nonloginAuthenticator = new NonLoginAuthenticator(); nonloginContext.getPipeline().addValve(nonloginAuthenticator);",
        "label":0
    },
    {
        "ins1CurCode":"StringBuilder sql = new StringBuilder(500); sql .append(\"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \"\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.SEARCH_CONDITION,\" +",
        "ins1PreCode":"StringBuilder sql = new StringBuilder(500); sql .append(\"SELECT /*+RULE*/\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.SEARCH_CONDITION,\" +",
        "ins2PreCode":"StringBuilder sql = new StringBuilder(500); sql.append( \"SELECT /*+RULE*/ \\r\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,ref.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" +",
        "label":1
    },
    {
        "ins1CurCode":"public void testAdditionOfDuplicateXValues() { XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 1.0);",
        "ins1PreCode":"public void testAdditionOfDuplicateXValues() { XIntervalSeries s1 = new XIntervalSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 1.0);",
        "ins2PreCode":"public void testAdditionOfDuplicateXValues() { VectorSeries s1 = new VectorSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 1.0);",
        "label":1
    },
    {
        "ins1CurCode":"classpath.addJavaRuntime();  cmdl.setClassname(JavaCC.getMainClass(classpath, JavaCC.TASKDEF_TYPE_JJTREE));",
        "ins1PreCode":"cmdl.createArgument().setValue(target.getAbsolutePath());  cmdl.setClassname(JavaCC.getMainClass(javaccHome, JavaCC.TASKDEF_TYPE_JJTREE));",
        "ins2PreCode":"cmdl.createArgument().setValue(target.getAbsolutePath());  cmdl.setClassname(JavaCC.getMainClass(javaccHome, JavaCC.TASKDEF_TYPE_JJDOC));",
        "label":1
    },
    {
        "ins1CurCode":".to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(ExceptionHelper.nullWarning(\"The collectionSupplier returned a null Collection.\"));",
        "ins1PreCode":".to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins2PreCode":".to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "label":1
    },
    {
        "ins1CurCode":"}  Map<String, Object> options = new LinkedHashMap<>(command.getOptions()); DBUtils.fireObjectUpdate(command.getObject(), options, DBPEvent.RENAME); }",
        "ins1PreCode":"}  DBUtils.fireObjectUpdate(command.getObject()); }",
        "ins2PreCode":"}  Map<String, Object> options = new LinkedHashMap<>(); options.put(DBEObjectRenamer.PROP_OLD_NAME, command.getOldName()); options.put(DBEObjectRenamer.PROP_NEW_NAME, command.getNewName());  DBUtils.fireObjectUpdate(command.getObject(), options, null); }",
        "label":0
    },
    {
        "ins1CurCode":"void propertySourceAnnotationWithName() { SpringApplication application = new SpringApplication(WithPropertySourceAndName.class);",
        "ins1PreCode":"public void propertySourceAnnotationWithName() { SpringApplication application = new SpringApplication(WithPropertySourceAndName.class);",
        "ins2PreCode":"public void propertySourceAnnotationMultipleLocations() { SpringApplication application = new SpringApplication(WithPropertySourceMultipleLocations.class);",
        "label":1
    },
    {
        "ins1CurCode":"inputFilter); } else { result.add(org.apache.hadoop.mapreduce.lib.input. FileInputFormat.shrinkStatus(stat)); }",
        "ins1PreCode":"inputFilter); } else { result.add(stat); }",
        "ins2PreCode":"inputFilter); } else { result.add(stat); }",
        "label":0
    },
    {
        "ins1CurCode":" TestHelper.checkDisposed(Observable.range(1, 2) .concatMapDelayError(Functions.justFunction(Observable.just(1)), true, 2, ImmediateThinScheduler.INSTANCE));",
        "ins1PreCode":" TestHelper.checkDisposed(Observable.range(1, 2) .concatMapDelayError(Functions.justFunction(Observable.just(1)), 2, true, ImmediateThinScheduler.INSTANCE));",
        "ins2PreCode":" TestHelper.checkDisposed(Flowable.range(1, 2) .concatMapDelayError(Functions.justFunction(Flowable.just(1)), 2, true, ImmediateThinScheduler.INSTANCE));",
        "label":1
    },
    {
        "ins1CurCode":"DefaultCategoryDataset d = new DefaultCategoryDataset(); d.addValue(1.0, \"R1\", \"C1\"); assertEquals(1.0, d.getValue(\"R1\", \"C1\")); boolean pass = false;",
        "ins1PreCode":"DefaultCategoryDataset d = new DefaultCategoryDataset(); d.addValue(1.0, \"R1\", \"C1\"); assertEquals(new Double(1.0), d.getValue(\"R1\", \"C1\")); boolean pass = false;",
        "ins2PreCode":"public void testGetValue() { DefaultKeyedValues2D d = new DefaultKeyedValues2D(); d.addValue(1.0, \"R1\", \"C1\"); assertEquals(1.0, d.getValue(\"R1\", \"C1\")); boolean pass = false; try { d.getValue(\"XX\", \"C1\"); } catch (UnknownKeyException e) { pass = true; } assertTrue(pass);  pass = false; try { d.getValue(\"R1\", \"XX\"); } catch (UnknownKeyException e) { pass = true; } assertTrue(pass);",
        "label":0
    },
    {
        "ins1CurCode":"void shouldResolveBothSimpleNameAndFullyQualifiedName() { Configuration c = new Configuration();",
        "ins1PreCode":"public void shouldResolveBothSimpleNameAndFullyQualifiedName() { Configuration c = new Configuration();",
        "ins2PreCode":"public void shouldFailOverToMostApplicableSimpleName() { Configuration c = new Configuration(); final String fullName = \"com.mycache.MyCache\"; final String invalidName = \"unknown.namespace.MyCache\"; final PerpetualCache cache = new PerpetualCache(fullName); c.addCache(cache); assertEquals(cache, c.getCache(fullName)); Assertions.assertThrows(IllegalArgumentException.class, () -> { c.getCache(invalidName); });",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"private void validate() throws BuildException { if (null == libraryFile && libraryFileSets.isEmpty()) { final String message = \"File attribute not specified.\"; throw new BuildException(message); } if (null != libraryFile && !libraryFile.exists()) { final String message = \"File '\" + libraryFile + \"' does not exist.\"; throw new BuildException(message); } if (null != libraryFile && !libraryFile.isFile()) { final String message = \"\\'\" + libraryFile + \"\\' is not a file.\"; throw new BuildException(message); }",
        "ins1PreCode":"private void validate() throws BuildException { if( null == m_file && m_filesets.isEmpty() ) { final String message = \"File attribute not specified.\"; throw new BuildException( message ); } if( null != m_file && !m_file.exists() ) { final String message = \"File '\" + m_file + \"' does not exist.\"; throw new BuildException( message ); } if( null != m_file && !m_file.isFile() ) { final String message = \"\\'\" + m_file + \"\\' is not a file.\"; throw new BuildException( message ); }",
        "ins2PreCode":"private void validate() throws BuildException { if( null == m_extension ) { final String message = \"Extension element must be specified.\"; throw new BuildException( message ); }  if( null == m_file && m_extensionSets.isEmpty() ) { final String message = \"File attribute not specified.\"; throw new BuildException( message ); } if( null != m_file && !m_file.exists() ) { final String message = \"File '\" + m_file + \"' does not exist.\"; throw new BuildException( message ); } if( null != m_file && !m_file.isFile() ) { final String message = \"\\'\" + m_file + \"\\' is not a file.\"; throw new BuildException( message ); }",
        "label":0
    },
    {
        "ins1CurCode":"assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port, 100, InetAddress.getByName(\"localhost\")); }",
        "ins1PreCode":"assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); }",
        "ins2PreCode":"assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); }",
        "label":1
    },
    {
        "ins1CurCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildSiteUrlInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins1PreCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins2PreCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "label":0
    },
    {
        "ins1CurCode":"public JDBCStatement prepareLookupStatement(@NotNull JDBCSession session, @NotNull VerticaSchema schema, @Nullable VerticaProjection object, @Nullable String objectName) throws SQLException { final JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT p.*,c.comment FROM v_catalog.projections p\\n\" + \"LEFT OUTER JOIN v_catalog.comments c ON c.object_type = 'PROJECTION' AND c.object_schema = p.projection_schema AND c.object_name = p.projection_name\\n\" + \"WHERE p.projection_schema=?\" + (object == null && objectName == null ? \"\" : \" AND projection_name=?\")",
        "ins1PreCode":"public JDBCStatement prepareLookupStatement(@NotNull JDBCSession session, @NotNull VerticaSchema schema, @Nullable VerticaProjection object, @Nullable String objectName) throws SQLException { final JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT * FROM v_catalog.projections WHERE projection_schema=?\" + (object == null && objectName == null ? \"\" : \" AND projection_name=?\")",
        "ins2PreCode":"public JDBCStatement prepareLookupStatement(@NotNull JDBCSession session, @NotNull VerticaSchema schema, @Nullable VerticaUDF object, @Nullable String objectName) throws SQLException { final JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT * FROM v_catalog.user_functions WHERE schema_schema=?\" + (object == null && objectName == null ? \"\" : \" AND function_name=?\") ); dbStat.setString(1, schema.getName()); if (object != null || objectName != null) dbStat.setString(2, object != null ? object.getName() : objectName); return dbStat;",
        "label":0
    },
    {
        "ins1CurCode":"public void testCcOnly() throws InterruptedException { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.cc(\"cc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"Cc: cc@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); assertFalse(testMailClient.getFailMessage(), testMailClient.isFailed());",
        "ins1PreCode":"public void testCcOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.cc(\"cc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"Cc: cc@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins2PreCode":"public void testBccOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals( expectedResult.length(), result.length() ); assertEquals( expectedResult, result ); if ( testMailClient.isFailed() ) { fail( testMailClient.getFailMessage() ); }",
        "label":1
    },
    {
        "ins1CurCode":"XContentParseException exception = expectThrows(XContentParseException.class, () -> DiscountedCumulativeGain.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[dcg] unknown field\")); }",
        "ins1PreCode":"XContentParseException exception = expectThrows(XContentParseException.class, () -> DiscountedCumulativeGain.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[dcg_at] unknown field\")); }",
        "ins2PreCode":"public void testXContentParsingIsNotLenient() throws IOException { MeanReciprocalRank testItem = createTestItem(); XContentType xContentType = randomFrom(XContentType.values()); BytesReference originalBytes = toShuffledXContent(testItem, xContentType, ToXContent.EMPTY_PARAMS, randomBoolean()); BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, null, random()); try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { parser.nextToken(); parser.nextToken(); XContentParseException exception = expectThrows(XContentParseException.class, () -> MeanReciprocalRank.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[reciprocal_rank] unknown field\")); }",
        "label":0
    },
    {
        "ins1CurCode":"new TestMemoryManager( new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins1PreCode":"new TestMemoryManager( new SparkConf() .set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeapSize\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins2PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); sparkConf = new SparkConf(); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments();  return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "label":0
    },
    {
        "ins1CurCode":"public void testNotNullColumnWithoutChildrenNoFid() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);",
        "ins1PreCode":"public void testNotNullColumnWithoutChildrenNoFid() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);  Father test = fatherMapper.selectByIdNoFid(2); assertNotNull(test); assertNotNull(test.getChildren()); assertTrue(test.getChildren().isEmpty()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testNotNullColumnWithoutChildrenFid() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);  Father test = fatherMapper.selectByIdFid(2); assertNotNull(test); assertNotNull(test.getChildren()); assertTrue(test.getChildren().isEmpty()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"}  BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8)); Writer writer = new OutputStreamWriter(os, StandardCharsets.UTF_8); ",
        "ins1PreCode":"}  BufferedReader reader = new BufferedReader(new InputStreamReader(is)); Writer writer = new OutputStreamWriter(os); ",
        "ins2PreCode":"}  BufferedReader reader = new BufferedReader(new InputStreamReader(is)); Writer writer = new OutputStreamWriter(os); ",
        "label":1
    },
    {
        "ins1CurCode":"PublishProcessor<Integer> until = PublishProcessor.create();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"PublishProcessor<Integer> until = PublishProcessor.create();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"PublishProcessor<Integer> until = PublishProcessor.create();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"fail(\"Should have throw IAE\"); } catch (IllegalArgumentException expected) { assertThat(expected).hasCauseThat().isSameInstanceAs(cause); }",
        "ins1PreCode":"fail(\"Should have throw IAE\"); } catch (IllegalArgumentException expected) { assertThat(expected).hasCauseThat().isSameAs(cause); }",
        "ins2PreCode":"fail(\"Should have throw IAE\"); } catch (IllegalArgumentException expected) { assertThat(expected).hasCauseThat().isSameAs(cause); }",
        "label":1
    },
    {
        "ins1CurCode":"{ List<String> tgt = target.getFilters(); Set<String> excludes = new LinkedHashSet<>( tgt ); List<String> merged = new ArrayList<>( tgt.size() + src.size() ); merged.addAll( tgt );",
        "ins1PreCode":"{ List<String> tgt = target.getFilters(); Set<String> excludes = new LinkedHashSet<String>( tgt ); List<String> merged = new ArrayList<String>( tgt.size() + src.size() ); merged.addAll( tgt );",
        "ins2PreCode":"{ List<String> tgt = target.getGoals(); Set<String> excludes = new LinkedHashSet<String>( tgt ); List<String> merged = new ArrayList<String>( tgt.size() + src.size() ); merged.addAll( tgt );",
        "label":1
    },
    {
        "ins1CurCode":"&& !m.signature.contains(\"Observable\") && !m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Subscriber\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") && !m.signature.contains(\"TestSubscriber\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Subscription\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\") && !m.signature.contains(\"Publisher\") ) { e.append(\"java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observer\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"TestObserver\")) {  if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(\"SingleObserver\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observer but not using Observable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Publisher\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\")) { if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(\"(Publisher\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Maybe\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Maybe\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" MaybeSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"MaybeSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" ObservableSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Single.method(Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }",
        "ins1PreCode":"&& !m.signature.contains(\"Observable\") && !m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Subscriber\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") && !m.signature.contains(\"TestSubscriber\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Subscription\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\") && !m.signature.contains(\"Publisher\") ) { e.append(\"java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observer\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"TestObserver\")) {  if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(\"SingleObserver\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observer but not using Observable\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Publisher\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\")) { if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(\"(Publisher\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Maybe\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Maybe\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Maybe but not in the signature\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" MaybeSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"MaybeSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observable but not in the signature\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" ObservableSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Single (Single.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }",
        "ins2PreCode":"&& !m.signature.contains(\"Observable\") && !m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Completable doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Subscriber\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") && !m.signature.contains(\"TestSubscriber\")) { e.append(\"java.lang.RuntimeException: Completable doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Subscription\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\") && !m.signature.contains(\"Publisher\") ) { e.append(\"java.lang.RuntimeException: Completable doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observer\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"TestObserver\")) {  if (idx < 11 || !m.javadoc.substring(idx - 11, idx + 8).equals(\"CompletableObserver\")) { e.append(\"java.lang.RuntimeException: Completable doc mentions Observer but not using Observable\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Publisher\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\")) { if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(\"(Publisher\")) { e.append(\"java.lang.RuntimeException: Completable doc mentions Publisher but not in the signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Flowable\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Completable doc mentions Flowable but not in the signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Single\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Single\")) { Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Single\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Completable doc mentions Single but not in the signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"SingleSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"SingleSource\")) { Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*SingleSource\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Completable doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Observable\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Completable doc mentions Observable but not in the signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"ObservableSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\")) { Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*ObservableSource\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Completable doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Completable (Completable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }",
        "label":1
    },
    {
        "ins1CurCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { Jenkins.get().checkPermission(Jenkins.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication());",
        "ins1PreCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication()); if(!Lifecycle.get().canRewriteHudsonWar()) {",
        "ins2PreCode":"public void doRestart(StaplerResponse rsp) throws IOException, ServletException { Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Jenkins.getAuthentication());",
        "label":0
    },
    {
        "ins1CurCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, null, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), null, new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins2PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), null, new Double(0.0), new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "label":0
    },
    {
        "ins1CurCode":"public void testLangRaw() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins1PreCode":"public void testLangRaw() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); List<Name> answer = sqlSession.selectList(\"selectRaw\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testLangXmlTags() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); List<Name> answer = sqlSession.selectList(\"selectXml\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(basicContext, \"TesterServlet3\", new TesterServlet()); basicContext.addServletMappingDecoded(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPatternDecoded(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); basicContext.addConstraint(sc);   Tomcat.addServlet(basicContext, \"TesterServlet4\", new TesterServlet()); basicContext.addServletMappingDecoded(URI_PUBLIC, \"TesterServlet4\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPatternDecoded(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();",
        "ins1PreCode":" Tomcat.addServlet(basicContext, \"TesterServlet3\", new TesterServlet()); basicContext.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); basicContext.addConstraint(sc);   Tomcat.addServlet(basicContext, \"TesterServlet4\", new TesterServlet()); basicContext.addServletMapping(URI_PUBLIC, \"TesterServlet4\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();",
        "ins2PreCode":"Tomcat.addServlet(basicContext, \"TesterServlet3\", new TesterServletEncodeUrl()); basicContext.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); basicContext.addConstraint(sc);   Tomcat.addServlet(basicContext, \"TesterServlet4\", new TesterServletEncodeUrl()); basicContext.addServletMapping(URI_PUBLIC, \"TesterServlet4\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();",
        "label":1
    },
    {
        "ins1CurCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);",
        "ins1PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); ",
        "ins2PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, EINSTEIN_B); expectedCrossingResult.insertEntry(database, EINSTEIN_A); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.insertEntry(database, EINSTEIN_C); expectedCrossingResult.addUnresolvedKey(EINSTEIN_21); expectedCrossingResult.addUnresolvedKey(UNRESOLVED); expectedCrossingResult.increaseCrossRefsCount(); ",
        "label":0
    },
    {
        "ins1CurCode":"void autoTimeRequestsCanBeConfigured() { this.contextRunner.withPropertyValues(\"management.metrics.web.client.request.autotime.enabled=true\",",
        "ins1PreCode":"public void autoTimeRequestsCanBeConfigured() { this.contextRunner.withPropertyValues(\"management.metrics.web.client.request.autotime.enabled=true\",",
        "ins2PreCode":"public void autoTimeRequestsCanBeConfigured() { this.contextRunner.withUserConfiguration(TestController.class)",
        "label":1
    },
    {
        "ins1CurCode":"public void testIndexOf() { DefaultIntervalXYDataset<String> d = createSampleDataset1(); assertEquals(0, d.indexOf(\"S1\"));",
        "ins1PreCode":"public void testIndexOf() { DefaultIntervalXYDataset d = createSampleDataset1(); assertEquals(0, d.indexOf(\"S1\"));",
        "ins2PreCode":"public void testIndexOf() { DefaultXYZDataset d = createSampleDataset1(); assertEquals(0, d.indexOf(\"S1\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testPathAsResource() { buildRule.executeTarget(\"testPathAsResource\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists());",
        "ins1PreCode":"public void testPathAsResource() { executeTarget(\"testPathAsResource\"); File file1 = new File(getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists());",
        "ins2PreCode":"public void testZipfileset() { executeTarget(\"testZipfileset\"); File file1 = new File(getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists());",
        "label":1
    },
    {
        "ins1CurCode":"public void testDateConstructor1() { TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Locale locale = Locale.getDefault(); Minute m1 = new Minute(new Date(1016729699999L), zone, locale); Minute m2 = new Minute(new Date(1016729700000L), zone, locale);  assertEquals(54, m1.getMinute()); assertEquals(1016729699999L, m1.getLastMillisecond(cal));  assertEquals(55, m2.getMinute()); assertEquals(1016729700000L, m2.getFirstMillisecond(cal));",
        "ins1PreCode":" assertEquals(54, m1.getMinute()); assertEquals(1016729699999L, m1.getLastMillisecond(zone));  assertEquals(55, m2.getMinute()); assertEquals(1016729700000L, m2.getFirstMillisecond(zone));",
        "ins2PreCode":" assertEquals(54, m1.getMinute()); assertEquals(1016700899999L, m1.getLastMillisecond(zone));  assertEquals(55, m2.getMinute()); assertEquals(1016700900000L, m2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1CurCode":"for(ExasolViewGrant grant: this.dataSource.getViewGrants(monitor)) { if (grant.getGrantee().equals(this.getName())) {",
        "ins1PreCode":"for(ExasolViewGrant grant: this.dataSource.getViewGrants(monitor)) { if (grant.getName().equals(this.getName())) {",
        "ins2PreCode":"for(ExasolScriptGrant grant: this.dataSource.getScriptGrants(monitor)) { if (grant.getName().equals(this.getName())) {",
        "label":1
    },
    {
        "ins1CurCode":"}  return new EAssignment(nextIdentifier(), location(ctx), expression, new EConstant(nextIdentifier(), location(ctx), 1), false, operation);",
        "ins1PreCode":"}  return new EAssignment(location(ctx), expression, new EConstant(location(ctx), 1), false, operation);",
        "ins2PreCode":"}  return new EAssignment(location(ctx), expression, new EConstant(location(ctx), 1), true, operation);",
        "label":1
    },
    {
        "ins1CurCode":"public void adjacentEdges_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addEdge(N1, N2, E12);",
        "ins1PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try {",
        "ins2PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try { adjacentEdges.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N2, N3, E23); assertThat(network.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges); }",
        "label":0
    },
    {
        "ins1CurCode":"void shouldHashCodeTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false);",
        "ins1PreCode":"public void shouldHashCodeTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false);",
        "ins2PreCode":"public void shouldEqualsTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false);",
        "label":1
    },
    {
        "ins1CurCode":"} }) .doOnNext(new Consumer<Observable<Integer>>() { @Override public void accept(Observable<Integer> w) throws Throwable { w.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer()); }",
        "ins1PreCode":"} }) .test() .assertValueCount(1) .assertNoErrors() .assertNotComplete(); ",
        "ins2PreCode":"} }) .test() .assertValueCount(1) .assertNoErrors() .assertNotComplete(); ",
        "label":1
    },
    {
        "ins1CurCode":"public Set<String> setInitParameters(Map<String, String> initParameters) {  Set<String> conflicts = new HashSet<>(); ",
        "ins1PreCode":"public Set<String> setInitParameters(Map<String, String> initParameters) {  Set<String> conflicts = new HashSet<String>(); ",
        "ins2PreCode":"public Set<String> setInitParameters(Map<String, String> initParameters) {  Set<String> conflicts = new HashSet<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void updateTimestampEnabled() { final boolean includeTimestamp = true;  when(timestampPreferencesMock.now()).thenReturn(newDate);",
        "ins1PreCode":"void updateTimestampEnabled() { final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\"; ",
        "ins2PreCode":"void updateTimestampDisabled() { final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\"; ",
        "label":1
    },
    {
        "ins1CurCode":"try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assert.assertTrue(blog instanceof Factory); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins1PreCode":"try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assert.assertTrue(blog.getClass().getName().contains(\"CGLIB\")); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins2PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingSubSelects() throws Exception { SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelect\", 1); assertEquals(\"Jim Business\", blog.getTitle()); assertEquals(2, blog.getPosts().size()); assertEquals(\"Corn nuts\", blog.getPosts().get(0).getSubject()); assertEquals(101, blog.getAuthor().getId()); assertEquals(\"jim\", blog.getAuthor().getUsername()); } finally { session.close(); }",
        "label":0
    },
    {
        "ins1CurCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses()); assertEquals(expected, getClasses(fullTextFetchers));",
        "ins1PreCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(fullTextFetchers));",
        "ins2PreCode":"void getIdFetchersReturnsAllFetcherDerivingFromIdFetcher() throws Exception { Set<IdFetcher> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(IdFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); ",
        "label":0
    },
    {
        "ins1CurCode":"public void bindToClassWhenHasNoSetterShouldBindToSet() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToClassWhenHasNoSetterShouldBindToSet() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToClassWhenHasNoSetterShouldBindToCollection() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual( SingleObserver<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); obs.set(observer);",
        "ins1PreCode":"protected void subscribeActual( SingleObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); obs.set(observer);",
        "ins2PreCode":"protected void subscribeActual( MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); obs.set(observer);",
        "label":1
    },
    {
        "ins1CurCode":"DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES); String resource = \"org/apache/ibatis/jdbc/ScriptMissingEOLTerminator.sql\"; try (Connection conn = ds.getConnection(); Reader reader = Resources.getResourceAsReader(resource)) { ScriptRunner runner = new ScriptRunner(conn);",
        "ins1PreCode":"public void shouldReturnWarningIfEndOfLineTerminatorNotFound() throws Exception { DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES); Connection conn = ds.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setAutoCommit(true); runner.setStopOnError(false); runner.setErrorLogWriter(null); runner.setLogWriter(null);  String resource = \"org/apache/ibatis/jdbc/ScriptMissingEOLTerminator.sql\"; Reader reader = Resources.getResourceAsReader(resource);  try { runner.runScript(reader); fail(\"Expected script runner to fail due to missing end of line terminator.\"); } catch (Exception e) { assertTrue(e.getMessage().contains(\"end-of-line terminator\")); } reader.close(); conn.close();",
        "ins2PreCode":"public void shouldReturnWarningIfNotTheCurrentDelimiterUsed() throws Exception { DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES); Connection conn = ds.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setAutoCommit(false); runner.setStopOnError(true); runner.setErrorLogWriter(null); runner.setLogWriter(null);  String resource = \"org/apache/ibatis/jdbc/ScriptChangingDelimiterMissingDelimiter.sql\"; Reader reader = Resources.getResourceAsReader(resource);  try { runner.runScript(reader); fail(\"Expected script runner to fail due to the usage of invalid delimiter.\"); } catch (Exception e) { assertTrue(e.getMessage().contains(\"end-of-line terminator\")); } reader.close(); conn.close();",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"void constructorParameterPropertyWithPrimitiveTypesAndDefaultValues() throws IOException { process(ImmutablePrimitiveWithDefaultsProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void constructorParameterPropertyWithPrimitiveTypesAndDefaultValues() throws IOException { process(ImmutablePrimitiveWithDefaultsProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void constructorParameterPropertyWithPrimitiveWrapperTypesAndDefaultValues() throws IOException { process(ImmutablePrimitiveWrapperWithDefaultsProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; final UnsafeMapData map = new UnsafeMapData();",
        "ins1PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) (offsetAndSize & ((1L << 32) - 1)); final UnsafeMapData map = new UnsafeMapData();",
        "ins2PreCode":"public UnsafeMapData getMap(int ordinal) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeMapData map = new UnsafeMapData(); map.pointTo(baseObject, baseOffset + offset, size); return map;",
        "label":0
    },
    {
        "ins1CurCode":"filterDef.addInitParameter(\"internalProxies\", \"127\\\\.0\\\\.0\\\\.1, 192\\\\.168\\\\..*, another-internal-proxy\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIpHeader\", \"x-forwarded-for\"); filterDef.addInitParameter(\"proxiesHeader\", \"x-forwarded-by\");",
        "ins1PreCode":"filterDef.addInitParameter(\"internalProxies\", \"127\\\\.0\\\\.0\\\\.1, 192\\\\.168\\\\..*, another-internal-proxy\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIPHeader\", \"x-forwarded-for\"); filterDef.addInitParameter(\"proxiesHeader\", \"x-forwarded-by\");",
        "ins2PreCode":"filterDef.addInitParameter(\"internalProxies\", \"192\\\\.168\\\\.0\\\\.10, 192\\\\.168\\\\.0\\\\.11\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIPHeader\", \"x-forwarded-for\"); filterDef.addInitParameter(\"proxiesHeader\", \"x-forwarded-by\");",
        "label":1
    },
    {
        "ins1CurCode":"} else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null); removeObject(oldObject, false); if (newObject != null) {",
        "ins1PreCode":"} else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null); removeObject(oldObject); if (newObject != null) {",
        "ins2PreCode":"clearChildrenCache(oldObject); } removeObject(oldObject); if (newObject != null) {",
        "label":1
    },
    {
        "ins1CurCode":"} catch (Throwable t) { ExceptionUtils.handleThrowable(t); manager.getContext().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t);",
        "ins1PreCode":"} catch (Throwable t) { ExceptionUtils.handleThrowable(t); manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t);",
        "ins2PreCode":"} catch (Throwable t) { ExceptionUtils.handleThrowable(t); manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t);",
        "label":1
    },
    {
        "ins1CurCode":"return Unpooled.EMPTY_BUFFER; } final BytesRefIterator iterator = reference.iterator();  final List<ByteBuf> buffers = new ArrayList<>(3);",
        "ins1PreCode":"return Unpooled.EMPTY_BUFFER; } if (reference instanceof ByteBufBytesReference) { return ((ByteBufBytesReference) reference).toByteBuf(); } else {",
        "ins2PreCode":"return Unpooled.EMPTY_BUFFER; } if (reference instanceof ByteBufBytesReference) { return ((ByteBufBytesReference) reference).toByteBuf(); } else {",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "label":1
    },
    {
        "ins1CurCode":" int nRead = fillReadBuffer(block); lastRead = System.currentTimeMillis(); ",
        "ins1PreCode":" int nRead = fillReadBuffer(block);  ",
        "ins2PreCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {  socketBufferHandler.configureReadBufferForRead(); ByteBuffer readBuffer = socketBufferHandler.getReadBuffer(); int remaining = readBuffer.remaining();   if (remaining >= len) { readBuffer.get(b, off, len); return len; }   if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining;        }   int nRead = fillReadBuffer(block);    if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead; }",
        "label":0
    },
    {
        "ins1CurCode":"try { SafeObserver<String> safeObserver = new SafeObserver<String>(OBSERVER_ONNEXT_FAIL(onError)); safeObserver.onSubscribe(Disposable.empty()); safeObserver.onNext(\"one\");",
        "ins1PreCode":"try { SafeObserver<String> safeObserver = new SafeObserver<String>(OBSERVER_ONNEXT_FAIL(onError)); safeObserver.onSubscribe(Disposables.empty()); safeObserver.onNext(\"one\");",
        "ins2PreCode":"public void onNextFailureSafe() { AtomicReference<Throwable> onError = new AtomicReference<Throwable>(); try { SafeSubscriber<String> safeObserver = new SafeSubscriber<String>(OBSERVER_ONNEXT_FAIL(onError)); safeObserver.onSubscribe(new BooleanSubscription()); safeObserver.onNext(\"one\"); assertNotNull(onError.get()); assertTrue(onError.get() instanceof SafeSubscriberTestException); assertEquals(\"onNextFail\", onError.get().getMessage()); } catch (Exception e) { fail(\"expects exception to be passed to onError\"); }",
        "label":0
    },
    {
        "ins1CurCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), new Double(4.0), new Double(0.5), null, new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins2PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), new Double(4.0), null, new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "label":0
    },
    {
        "ins1CurCode":"protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws Exception { doWithBlockedPort((port) -> {",
        "ins1PreCode":"protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "ins2PreCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "label":1
    },
    {
        "ins1CurCode":" for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue();",
        "ins1PreCode":" for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue();",
        "ins2PreCode":"} for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue();",
        "label":1
    },
    {
        "ins1CurCode":"try { rc = SSLConf.check(cctx, name, value); } catch (Exception e) { log.error(sm.getString(\"opensslconf.checkFailed\"));",
        "ins1PreCode":"try { rc = SSLConf.check(cctx, name, value); } catch (UnsatisfiedLinkError e) { log.warn(sm.getString(\"opensslconf.missingOpenSSLConfSupport\"), e); log.error(sm.getString(\"opensslconf.checkFailed\"));",
        "ins2PreCode":"try { SSLConf.assign(cctx, ctx); } catch (UnsatisfiedLinkError e) { log.warn(sm.getString(\"opensslconf.missingOpenSSLConfSupport\"), e); log.error(sm.getString(\"opensslconf.applyFailed\")); return false; } OpenSSLConfCmd cmd; String name; String value; int rc; for (int i = 0; i < commands.size(); i++) { cmd = commands.get(i); name = cmd.getName(); value = cmd.getValue(); if (name == null) { log.error(sm.getString(\"opensslconf.noCommandName\", value)); result = false; continue; } if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.applyCommand\", name, value)); } try { rc = SSLConf.apply(cctx, name, value); } catch (UnsatisfiedLinkError e) { log.warn(sm.getString(\"opensslconf.missingOpenSSLConfSupport\"), e); log.error(sm.getString(\"opensslconf.applyFailed\")); return false; } if (rc <= 0) { log.error(sm.getString(\"opensslconf.failedCommand\", name, value, Integer.toString(rc))); result = false; } else if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, Integer.toString(rc))); } } try { rc = SSLConf.finish(cctx); } catch (UnsatisfiedLinkError e) { log.warn(sm.getString(\"opensslconf.missingOpenSSLConfSupport\"), e); log.error(sm.getString(\"opensslconf.applyFailed\"));",
        "label":0
    },
    {
        "ins1CurCode":"void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void tomcatConnectorCustomizers() { TomcatServletWebServerFactory factory = getFactory();",
        "label":1
    },
    {
        "ins1CurCode":"Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>07-hello world</p>\") > 0);",
        "ins1PreCode":"Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"public void testTldVersions40() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-4.0\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/tld-versions.jsp\");  String result = res.toString();  Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "label":0
    },
    {
        "ins1CurCode":" int i = 0; while (i < WAIT_LOOPS) { if (server.received.size() > 0 && client.received.size() > 0) { break; } i++; Thread.sleep(WAIT_DELAY); }   Assert.assertEquals(1, server.received.size()); Assert.assertEquals(2, client.received.size()); ",
        "ins1PreCode":" int i = 0; while (i < 20) { if (server.received.size() > 0 && client.received.size() > 0) { break; } i++; Thread.sleep(100); }   Assert.assertEquals(1, server.received.size()); Assert.assertEquals(1, client.received.size()); ",
        "ins2PreCode":" int i = 0; while (i++ < 20) { if (server.received.size() > 0 && client.received.size() > 0) { break; } i++; Thread.sleep(100); }",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsSpace() { CLICommandInvoker.Result result = command",
        "ins1PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsSpace() throws Exception { CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsComma() throws Exception { CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"if (adapter == DBSStructureAssistant.class) { return adapter.cast(new SQLServerStructureAssistant(this)); } else if (adapter == DBAServerSessionManager.class) { return adapter.cast(new SQLServerSessionManager(this)); } else if (adapter == DBCQueryPlanner.class) { return adapter.cast(new SQLServerQueryPlanner(this)); }",
        "ins1PreCode":"if (adapter == DBSStructureAssistant.class) { return adapter.cast(new SQLServerStructureAssistant(this)); } else if (adapter == DBAServerSessionManager .class) { return adapter.cast(new SQLServerSessionManager(this));",
        "ins2PreCode":"} else if (adapter == DBAServerSessionManager.class) { return adapter.cast(new ExasolServerSessionManager(this)); } return super.getAdapter(adapter);",
        "label":1
    },
    {
        "ins1CurCode":"responseLatch.await(5, TimeUnit.SECONDS); this.webServer.stop(); Throwable error = await().atMost(Duration.ofSeconds(30)).until(errorReference::get, (ex) -> ex != null); assertThat(error).isInstanceOf(IOException.class);",
        "ins1PreCode":"responseLatch.await(5, TimeUnit.SECONDS); this.webServer.stop(); Throwable error = await().atMost(Duration.ofSeconds(5)).until(errorReference::get, (ex) -> ex != null); assertThat(error).isInstanceOf(IOException.class);",
        "ins2PreCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { NettyReactiveWebServerFactory factory = getFactory(); Shutdown shutdown = new Shutdown(); shutdown.setGracePeriod(Duration.ofSeconds(5)); factory.setShutdown(shutdown); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient().build(); webClient.get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown(); AtomicReference<Throwable> errorReference = new AtomicReference<>(); webClient.get().retrieve().toBodilessEntity().doOnError(errorReference::set).subscribe(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); this.webServer.stop(); assertThat(errorReference.get()).hasCauseInstanceOf(ConnectException.class);",
        "label":0
    },
    {
        "ins1CurCode":" case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(sidWait)); break;  case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(sidHold)); break;",
        "ins1PreCode":" case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(OracleLockEditor.sidWait)); break;  case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(OracleLockEditor.sidHold)); break;",
        "ins2PreCode":"switch(otype) { case LockGraphManager.typeWait: dbStat.setBigDecimal(1, new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidWait))); break; case LockGraphManager.typeHold: dbStat.setBigDecimal(1,  new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidHold))); break;",
        "label":1
    },
    {
        "ins1CurCode":"series.add(data[i][0], data[i][1]); } XYDataset<String> ds = new XYSeriesCollection<>(series); double[] result = Regression.getOLSRegression(ds, 0);",
        "ins1PreCode":"series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection<String>(series); double[] result = Regression.getOLSRegression(ds, 0);",
        "ins2PreCode":"series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection<String>(series); double[] result = Regression.getPowerRegression(ds, 0);",
        "label":1
    },
    {
        "ins1CurCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = Character.valueOf((char)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = Character.valueOf((char)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = null; String n = (String)o;\"));",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = Character.valueOf((char)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = Short.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = null; String n = (String)o;\"));",
        "ins2PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = (String)o;\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void runPrefixSpanSaveLoad() { JavaRDD<List<List<Integer>>> sequences = jsc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences);  File tempDir = Utils.createTempDir( System.getProperty(\"java.io.tmpdir\"), \"JavaPrefixSpanSuite\"); String outputPath = tempDir.getPath();  try { model.save(spark.sparkContext(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(spark.sparkContext(), outputPath); JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size());  for (PrefixSpan.FreqSequence<Integer> freqSeq : localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence();",
        "ins1PreCode":"public void runPrefixSpanSaveLoad() { JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences);  File tempDir = Utils.createTempDir( System.getProperty(\"java.io.tmpdir\"), \"JavaPrefixSpanSuite\"); String outputPath = tempDir.getPath();  try { model.save(sc.sc(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(sc.sc(), outputPath); JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size());  for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence();",
        "ins2PreCode":"public void runPrefixSpan() { JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences); JavaRDD<FreqSequence<Integer>> freqSeqs = model.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size());  for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence();",
        "label":0
    },
    {
        "ins1CurCode":"Observer<Object> observerC = TestHelper.mockObserver(); Observer<Object> observerD = TestHelper.mockObserver(); TestObserver<Object> to = new TestObserver<>(observerA); ",
        "ins1PreCode":"Observer<Object> observerC = TestHelper.mockObserver(); Observer<Object> observerD = TestHelper.mockObserver(); TestObserver<Object> to = new TestObserver<Object>(observerA); ",
        "ins2PreCode":"Subscriber<Object> observerC = TestHelper.mockSubscriber(); Subscriber<Object> observerD = TestHelper.mockSubscriber(); TestSubscriber<Object> ts = new TestSubscriber<Object>(observerA); ",
        "label":1
    },
    {
        "ins1CurCode":"void loadWhenHasConfigurationPropertiesValidatorShouldApplyValidator() { assertThatExceptionOfType(Exception.class).isThrownBy(() -> load(WithCustomValidatorConfiguration.class))",
        "ins1PreCode":"public void loadWhenHasConfigurationPropertiesValidatorShouldApplyValidator() { assertThatExceptionOfType(Exception.class).isThrownBy(() -> load(WithCustomValidatorConfiguration.class))",
        "ins2PreCode":"public void loadWhenBindingToConstructorParametersShouldValidate() { assertThatExceptionOfType(Exception.class)",
        "label":1
    },
    {
        "ins1CurCode":".put(URLRepository.REPOSITORIES_URL_SETTING.getKey(), repoPath) .build(); RepositoryMetadata repositoryMetadata = new RepositoryMetadata(\"url\", URLRepository.TYPE, baseSettings); final URLRepository repository = createRepository(baseSettings, repositoryMetadata); repository.start();",
        "ins1PreCode":".put(URLRepository.REPOSITORIES_URL_SETTING.getKey(), repoPath) .build(); RepositoryMetaData repositoryMetaData = new RepositoryMetaData(\"url\", URLRepository.TYPE, baseSettings); final URLRepository repository = createRepository(baseSettings, repositoryMetaData); repository.start();",
        "ins2PreCode":".put(URLRepository.REPOSITORIES_URL_SETTING.getKey(), repoPath) .build(); RepositoryMetaData repositoryMetaData = new RepositoryMetaData(\"url\", URLRepository.TYPE, baseSettings); final URLRepository repository = createRepository(baseSettings, repositoryMetaData); repository.start();",
        "label":1
    },
    {
        "ins1CurCode":"when(Stapler.getCurrentRequest()).thenReturn(req); View view = mock(View.class); when(view.getOwner().getItemGroup()).thenReturn(parent); createMockAncestors(req, createAncestor(j, \"../..\"), createAncestor(view, \".\"));",
        "ins1PreCode":"when(Stapler.getCurrentRequest()).thenReturn(req); View view = mock(View.class); when(view.getOwnerItemGroup()).thenReturn(parent); createMockAncestors(req, createAncestor(j, \"../..\"), createAncestor(view, \".\"));",
        "ins2PreCode":"when(Stapler.getCurrentRequest()).thenReturn(req); View view = mock(View.class); when(view.getOwnerItemGroup()).thenReturn(parent); createMockAncestors(req, createAncestor(view, \".\"), createAncestor(j, \"../..\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void assertNeverAtNotMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts);",
        "ins1PreCode":"public void assertNeverAtNotMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "ins2PreCode":"public void assertNeverAtMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"void defaultServletConfiguration() throws IOException { AnnotatedBeanDefinition servletDefinition = createBeanDefinition(DefaultConfigurationServlet.class); this.handler.handle(servletDefinition, this.registry); BeanDefinition servletRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationServlet.class.getName()); MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((Integer) propertyValues.get(\"loadOnStartup\")).isEqualTo(-1); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationServlet.class.getName()); assertThat((String[]) propertyValues.get(\"urlMappings\")).isEmpty(); assertThat(propertyValues.get(\"servlet\")).isEqualTo(servletDefinition);",
        "ins1PreCode":"void defaultServletConfiguration() throws IOException { AnnotatedBeanDefinition servletdefinition = createBeanDefinition(DefaultConfigurationServlet.class); this.handler.handle(servletdefinition, this.registry); BeanDefinition servletRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationServlet.class.getName()); MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((Integer) propertyValues.get(\"loadOnStartup\")).isEqualTo(-1); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationServlet.class.getName()); assertThat((String[]) propertyValues.get(\"urlMappings\")).isEmpty(); assertThat(propertyValues.get(\"servlet\")).isEqualTo(servletdefinition);",
        "ins2PreCode":"void defaultFilterConfiguration() throws IOException { AnnotatedBeanDefinition definition = createBeanDefinition(DefaultConfigurationFilter.class); this.handler.handle(definition, this.registry); BeanDefinition filterRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationFilter.class.getName()); MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat((EnumSet<DispatcherType>) propertyValues.get(\"dispatcherTypes\")) .containsExactly(DispatcherType.REQUEST); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((String[]) propertyValues.get(\"servletNames\")).isEmpty(); assertThat((String[]) propertyValues.get(\"urlPatterns\")).isEmpty(); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationFilter.class.getName()); assertThat(propertyValues.get(\"filter\")).isEqualTo(definition);",
        "label":0
    },
    {
        "ins1CurCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty()); ",
        "label":0
    },
    {
        "ins1CurCode":"void processAndApplyAddsImportedSourceToEnvironment(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply();",
        "ins1PreCode":"void processAndApplyAddsImportedSourceToEnvironment(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply();",
        "ins2PreCode":"void processAndApplyOnlyAddsActiveContributors(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply();",
        "label":1
    },
    {
        "ins1CurCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent, StandardCharsets.UTF_8); ",
        "ins1PreCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent); ",
        "ins2PreCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent); ",
        "label":1
    },
    {
        "ins1CurCode":"assertFalse(ro.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertFalse(ro.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertFalse(ro.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public String getLastAccessedTime( String sessionId ) { Session s=sessions.get(sessionId); if( s==null ) {",
        "ins1PreCode":"public String getLastAccessedTime( String sessionId ) { Session s=(Session)sessions.get(sessionId); if( s==null ) {",
        "ins2PreCode":"public String getCreationTime( String sessionId ) { Session s=(Session)sessions.get(sessionId); if( s==null ) {",
        "label":1
    },
    {
        "ins1CurCode":"throws IOException { Objects.requireNonNull( input, \"input cannot be null\" ); ",
        "ins1PreCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "ins2PreCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "label":1
    },
    {
        "ins1CurCode":" User user = iterator.next(); Assertions.assertEquals(\"User2\", user.getName()); Assertions.assertEquals(1, usersCursor.getCurrentIndex());  Assertions.assertFalse(iterator.hasNext()); iterator.next(); Assertions.fail(\"We should have failed since we call next() when hasNext() returned false\"); } catch (NoSuchElementException e) { Assertions.assertFalse(usersCursor.isOpen()); Assertions.assertTrue(usersCursor.isConsumed()); }",
        "ins1PreCode":" User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex());  Assert.assertFalse(iterator.hasNext()); iterator.next(); Assert.fail(\"We should have failed since we call next() when hasNext() returned false\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); }",
        "ins2PreCode":"Iterator<User> iterator = usersCursor.iterator(); User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex());   iterator.next(); Assert.fail(\"We should have failed since we call next() when is no more items\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void setPackagenames(String packages) { StringTokenizer tok = new StringTokenizer(packages, \",\"); while (tok.hasMoreTokens()) {",
        "ins1PreCode":"public void setPackagenames(String src) { StringTokenizer tok = new StringTokenizer(src, \",\"); while (tok.hasMoreTokens()) {",
        "ins2PreCode":"public void setExcludePackageNames(String src) { StringTokenizer tok = new StringTokenizer(src, \",\"); while (tok.hasMoreTokens()) {",
        "label":1
    },
    {
        "ins1CurCode":"void parseReallyUnknownType() throws Exception { String bibtexEntry = \"@ReallyUnknownType{test,\" + OS.NEWLINE +",
        "ins1PreCode":"public void parseReallyUnknownType() throws Exception { String bibtexEntry = \"@ReallyUnknownType{test,\" + OS.NEWLINE +",
        "ins2PreCode":"public void parseOtherTypeTest() throws Exception { String bibtexEntry = \"@Other{test,\" + OS.NEWLINE +",
        "label":1
    },
    {
        "ins1CurCode":"configuration.addMapper(Mapper.class); sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);  BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/type/BlobInputStreamTypeHandlerTest.sql\");",
        "ins1PreCode":"public static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\"); BaseDataTest.runScript(dataSource, \"org/apache/ibatis/type/BlobInputStreamTypeHandlerTest.sql\"); TransactionFactory transactionFactory = new JdbcTransactionFactory();",
        "ins2PreCode":"public static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\"); BaseDataTest.runScript(dataSource, \"org/apache/ibatis/type/ClobReaderTypeHandlerTest.sql\"); TransactionFactory transactionFactory = new JdbcTransactionFactory();",
        "label":1
    },
    {
        "ins1CurCode":"double[][] data = createSampleData2();  XYSeries<String> series = new XYSeries<>(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection<String>(series); double[] result = Regression.getOLSRegression(ds, 0);",
        "ins1PreCode":"double[][] data = createSampleData2();  XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getOLSRegression(ds, 0);",
        "ins2PreCode":"double[][] data = createSampleData2();  XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getPowerRegression(ds, 0);",
        "label":1
    },
    {
        "ins1CurCode":" @Override public AnalysisMode getAnalysisMode() { return updateable ? AnalysisMode.SEARCH_TIME : AnalysisMode.ALL; }",
        "ins1PreCode":"};",
        "ins2PreCode":"};",
        "label":1
    },
    {
        "ins1CurCode":"void resolveTypeDescriptorOnConcreteClass() throws IOException { process(SimpleGenericProperties.class, (roundEnv, typeUtils) -> {",
        "ins1PreCode":"public void resolveTypeDescriptorOnConcreteClass() throws IOException { process(SimpleGenericProperties.class, (roundEnv, typeUtils) -> {",
        "ins2PreCode":"public void resolveTypeDescriptorOnIntermediateClass() throws IOException { process(AbstractIntermediateGenericProperties.class, (roundEnv, typeUtils) -> {",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void createWhenMapHasEntriesShouldAdaptMap() { Map<Object, Object> map = new LinkedHashMap<>();",
        "ins1PreCode":"public void createWhenMapHasEntriesShouldAdaptMap() throws Exception { Map<Object, Object> map = new LinkedHashMap<>();",
        "ins2PreCode":"public void putAllShouldPutEntries() throws Exception { Map<Object, Object> map = new LinkedHashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(new UnknownField(\"a\")));",
        "ins1PreCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins2PreCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "label":1
    },
    {
        "ins1CurCode":"tmp = new char[newSize];  System.arraycopy(buff, start, tmp, 0, end - start); buff = tmp; tmp = null; end = end - start; start = 0;",
        "ins1PreCode":"tmp = new char[newSize];  System.arraycopy(buff, 0, tmp, 0, end); buff = tmp;",
        "ins2PreCode":"public void makeSpace(int count) { byte[] tmp = null;  int newSize; int desiredSize=end + count;   if( limit > 0 && desiredSize > limit) { desiredSize=limit; }  if( buff==null ) { if( desiredSize < 256 ) { desiredSize=256; } buff=new byte[desiredSize]; }    if( desiredSize <= buff.length ) { return; }  if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; } else { newSize= buff.length * 2 + count ; }  if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new byte[newSize];  System.arraycopy(buff, start, tmp, 0, end-start); buff = tmp; tmp = null; end=end-start; start=0;",
        "label":0
    },
    {
        "ins1CurCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundDomainMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundDomainMarkers.get(index); }",
        "ins1PreCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); }",
        "ins2PreCode":"boolean notify) { Args.nullNotPermitted(marker, \"marker\"); ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundRangeMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundRangeMarkers.get(new Integer( index)); }",
        "label":1
    },
    {
        "ins1CurCode":"if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); DiagramSettings settings = p.getProjectSettings().getDefaultDiagramSettings(); ArgoDiagram diagram = createDiagram(ns, settings); assert (diagram != null)",
        "ins1PreCode":" if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns, p.getProjectSettings().getDefaultDiagramSettings()); assert (diagram != null)",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) {  Project p = ProjectManager.getManager().getCurrentProject(); Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); DiagramSettings settings = p.getProjectSettings().getDefaultDiagramSettings();   ArgoDiagram diagram = createDiagram(ns, settings);  p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded(ns); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "label":0
    },
    {
        "ins1CurCode":"} } hits[i] = new SearchHit(i, Integer.toString(i), new Text(MapperService.SINGLE_MAPPING_NAME), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null, OriginalIndices.NONE));",
        "ins1PreCode":"} } hits[i] = new SearchHit(i, Integer.toString(i), new Text(\"type\"), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null, OriginalIndices.NONE));",
        "ins2PreCode":"SearchHit[] hits = new SearchHit[4]; for (int i = 0; i < 4; i++) { hits[i] = new SearchHit(i, Integer.toString(i), new Text(\"type\"), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null, OriginalIndices.NONE));",
        "label":1
    },
    {
        "ins1CurCode":"  Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers);",
        "ins1PreCode":"  Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers);",
        "ins2PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "label":0
    },
    {
        "ins1CurCode":"void javaBeanMetadataSimpleProperty() throws IOException { process(SimpleTypeProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanMetadataSimpleProperty() throws IOException { process(SimpleTypeProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokMetadataSimpleProperty() throws IOException { process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0, 1.9, 2.1); assertEquals(Double.valueOf(1.0), item1.getX()); assertEquals(0.5, item1.getXLowValue(), EPSILON);",
        "ins1PreCode":"XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0, 1.9, 2.1); assertEquals(new Double(1.0), item1.getX()); assertEquals(0.5, item1.getXLowValue(), EPSILON);",
        "ins2PreCode":"public void testConstructor1() { OHLCItem item1 = new OHLCItem(new Year(2006), 2.0, 4.0, 1.0, 3.0); assertEquals(new Year(2006), item1.getPeriod()); assertEquals(2.0, item1.getOpenValue(), EPSILON); assertEquals(4.0, item1.getHighValue(), EPSILON); assertEquals(1.0, item1.getLowValue(), EPSILON); assertEquals(3.0, item1.getCloseValue(), EPSILON);",
        "label":0
    },
    {
        "ins1CurCode":"public void merge2000AsyncStreamOf100() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(ts);",
        "ins1PreCode":"public void merge2000AsyncStreamOf100() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(ts);",
        "ins2PreCode":"public void merge100AsyncStreamOf1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(100, 1).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"public static void main(String[] args) { SparkSession spark = SparkSession.builder().appName(\"JavaStopWordsRemoverExample\").getOrCreate();   StopWordsRemover remover = new StopWordsRemover() .setInputCol(\"raw\") .setOutputCol(\"filtered\");  List<Row> data = Arrays.asList( RowFactory.create(Arrays.asList(\"I\", \"saw\", \"the\", \"red\", \"baloon\")), RowFactory.create(Arrays.asList(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")) );  StructType schema = new StructType(new StructField[]{ new StructField( \"raw\", DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty()) });  Dataset<Row> dataset = spark.createDataFrame(data, schema); remover.transform(dataset).show();  spark.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaStopWordsRemoverExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   StopWordsRemover remover = new StopWordsRemover() .setInputCol(\"raw\") .setOutputCol(\"filtered\");  JavaRDD<Row> rdd = jsc.parallelize(Arrays.asList( RowFactory.create(Arrays.asList(\"I\", \"saw\", \"the\", \"red\", \"baloon\")), RowFactory.create(Arrays.asList(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")) ));  StructType schema = new StructType(new StructField[]{ new StructField( \"raw\", DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty()) });  Dataset<Row> dataset = jsql.createDataFrame(rdd, schema); remover.transform(dataset).show();  jsc.stop();",
        "ins2PreCode":"public void javaCompatibilityTest() { StopWordsRemover remover = new StopWordsRemover() .setInputCol(\"raw\") .setOutputCol(\"filtered\");  List<Row> data = Arrays.asList( RowFactory.create(Arrays.asList(\"I\", \"saw\", \"the\", \"red\", \"baloon\")), RowFactory.create(Arrays.asList(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")) ); StructType schema = new StructType(new StructField[] { new StructField(\"raw\", DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty()) }); Dataset<Row> dataset = jsql.createDataFrame(data, schema);  remover.transform(dataset).collect();",
        "label":0
    },
    {
        "ins1CurCode":".endObject() .endObject() .startObject(TEXT_FIELD_NAME) .field(\"type\", \"text\") .endObject() .startObject(KEYWORD_FIELD_NAME) .field(\"type\", \"keyword\")",
        "ins1PreCode":".endObject() .endObject() .startObject(STRING_FIELD_NAME) .field(\"type\", \"text\") .endObject() .startObject(STRING_FIELD_NAME_2) .field(\"type\", \"keyword\")",
        "ins2PreCode":".endObject() .endObject() .startObject(STRING_FIELD_NAME) .field(\"type\", \"text\") .endObject() .startObject(STRING_FIELD_NAME_2) .field(\"type\", \"keyword\")",
        "label":1
    },
    {
        "ins1CurCode":"public void normal() { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<>(); ",
        "ins1PreCode":"public void normal() { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>(); ",
        "ins2PreCode":"public void normal() { TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"  assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins1PreCode":"  Assert.assertEquals(1, db.getEntryCount()); Assert.assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins2PreCode":"  Assert.assertEquals(1, db.getEntryCount()); Assert.assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "label":1
    },
    {
        "ins1CurCode":"AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\", null, new String[] { \"TLSv1.2\" }, null)); this.webServer = factory.getWebServer();",
        "ins1PreCode":"AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\")); this.webServer = factory.getWebServer();",
        "ins2PreCode":"public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(ClientAuth.NEED, \"password\", \"classpath:test.jks\", \"classpath:test.jks\", null, null)); this.webServer = factory.getWebServer(); this.webServer.start(); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(new FileInputStream(new File(\"src/test/resources/test.jks\")), \"secret\".toCharArray()); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory) .build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); assertThat(getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory)) .isEqualTo(\"test\");",
        "label":0
    },
    {
        "ins1CurCode":"while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins1PreCode":"while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins2PreCode":"while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1CurCode":"public void hasCycle_threeCyclicEdges() { for (MutableBasicGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "ins1PreCode":"public void hasCycle_threeCyclicEdges() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "ins2PreCode":"public void hasCycle_multipleCycles() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetFollowSymlinksTrue() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject());",
        "ins1PreCode":"public void testGetFollowSymlinksTrue() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject());",
        "ins2PreCode":"public void testGetFollowSymlinksFalse() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject()); dsDestination.scan(); compareFiles(dsDestination, new String[] {}, new String[] {});",
        "label":0
    },
    {
        "ins1CurCode":"Observable<Integer> result = source.withLatestFrom(other, COMBINER);  TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"Observable<Integer> result = source.withLatestFrom(other, COMBINER);  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"Observable<Integer> result = source.withLatestFrom(other, COMBINER);  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"{ case 110: return jjMoveStringLiteralDfa6_1(active0, 0x40000000000L); default :",
        "ins1PreCode":"{ case 110: return jjMoveStringLiteralDfa6_1(active0, 0x80000000000L); default :",
        "ins2PreCode":"{ case 99: return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, xAxis, yAxis, renderer); assertEquals(xAxis, plot.getDomainAxisForDataset(0));",
        "ins1PreCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); assertEquals(xAxis, plot.getDomainAxisForDataset(0));",
        "ins2PreCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new DefaultCategoryItemRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); assertEquals(yAxis, plot.getRangeAxisForDataset(0));",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"  Args.nullNotPermitted(state, \"state\"); ",
        "ins1PreCode":"  ParamChecks.nullNotPermitted(state, \"state\"); ",
        "ins2PreCode":"  ParamChecks.nullNotPermitted(state, \"state\"); ",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void run() { ps.onNext(1); }",
        "ins1PreCode":"@Override public void run() { ps.onComplete(); }",
        "ins2PreCode":"public void cancelCompleteRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final PublishSubject<Integer> ps = PublishSubject.create();  final TestObserver<Integer> to = ps.takeLast(1, TimeUnit.DAYS).test();  Runnable r1 = new Runnable() { @Override public void run() { ps.onComplete(); } };  Runnable r2 = new Runnable() { @Override public void run() { to.dispose(); } };  TestHelper.race(r1, r2); }",
        "label":0
    },
    {
        "ins1CurCode":"}  try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher)) { transport.start();",
        "ins1PreCode":"}  try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) { transport.start();",
        "ins2PreCode":"public void testBadRequest() throws InterruptedException { final AtomicReference<Throwable> causeReference = new AtomicReference<>(); final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {  @Override public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) { throw new AssertionError(); }  @Override public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) { causeReference.set(cause); try { final ElasticsearchException e = new ElasticsearchException(\"you sent a bad request and you should feel bad\"); channel.sendResponse(new BytesRestResponse(channel, BAD_REQUEST, e)); } catch (final IOException e) { throw new AssertionError(e); } }  };  final Settings settings; final int maxInitialLineLength; final Setting<ByteSizeValue> httpMaxInitialLineLengthSetting = HttpTransportSettings.SETTING_HTTP_MAX_INITIAL_LINE_LENGTH; if (randomBoolean()) { maxInitialLineLength = httpMaxInitialLineLengthSetting.getDefault(Settings.EMPTY).bytesAsInt(); settings = Settings.EMPTY; } else { maxInitialLineLength = randomIntBetween(1, 8192); settings = Settings.builder().put(httpMaxInitialLineLengthSetting.getKey(), maxInitialLineLength + \"b\").build(); }  try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) { transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());  try (Netty4HttpClient client = new Netty4HttpClient()) { final String url = \"/\" + new String(new byte[maxInitialLineLength], Charset.forName(\"UTF-8\")); final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url);  final FullHttpResponse response = client.post(remoteAddress.address(), request); assertThat(response.status(), equalTo(HttpResponseStatus.BAD_REQUEST)); assertThat( new String(response.content().array(), Charset.forName(\"UTF-8\")), containsString(\"you sent a bad request and you should feel bad\")); } }  assertNotNull(causeReference.get()); assertThat(causeReference.get(), instanceOf(TooLongFrameException.class));",
        "label":0
    },
    {
        "ins1CurCode":"void testEmptyMapIsNotAdded() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class);",
        "ins1PreCode":"public void testEmptyMapIsNotAdded() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class);",
        "ins2PreCode":"public void testList() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(ListConfig.class)",
        "label":1
    },
    {
        "ins1CurCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.path=target/foo/\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins1PreCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.path=target/foo/\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins2PreCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file=target/foo.log\"); this.initializer.initialize(this.context.getEnvironment(),",
        "label":0
    },
    {
        "ins1CurCode":"if (prop.hasNext()) { if (reflector.hasGetter(prop.getName())) { MetaClass metaProp = metaClassForProperty(prop); return metaProp.hasGetter(prop.getChildren());",
        "ins1PreCode":"if (prop.hasNext()) { if (reflector.hasGetter(prop.getName())) { MetaClass metaProp = metaClassForProperty(prop.getName()); return metaProp.hasGetter(prop.getChildren());",
        "ins2PreCode":"public boolean hasSetter(String name) { PropertyTokenizer prop = new PropertyTokenizer(name); if (prop.hasNext()) { if (reflector.hasSetter(prop.getName())) { MetaClass metaProp = metaClassForProperty(prop.getName()); return metaProp.hasSetter(prop.getChildren()); } else { return false; } } else { return reflector.hasSetter(prop.getName()); }",
        "label":0
    },
    {
        "ins1CurCode":"public synchronized StaticRoutingDecisionProvider addBlacklistSignature(@NonNull String signature) { if (this.blacklistSignaturesFromUserControlledList.add(signature)) {",
        "ins1PreCode":"public synchronized StaticRoutingDecisionProvider addBlacklistSignature(@Nonnull String signature) { if (this.blacklistSignaturesFromUserControlledList.add(signature)) {",
        "ins2PreCode":"public synchronized StaticRoutingDecisionProvider remove(@Nonnull String signature) { if (this.whitelistSignaturesFromUserControlledList.remove(signature)) {",
        "label":1
    },
    {
        "ins1CurCode":"public Map<String, Object> getPluginComponents( Plugin plugin, String role ) throws ComponentLookupException, PluginManagerException",
        "ins1PreCode":"public Map getPluginComponents( Plugin plugin, String role ) throws ComponentLookupException, PluginManagerException",
        "ins2PreCode":"public Object getPluginComponent( Plugin plugin, String role, String roleHint ) throws PluginManagerException, ComponentLookupException { MavenSession session = legacySupport.getSession();  PluginDescriptor pluginDescriptor; try { pluginDescriptor = pluginManager.getPluginDescriptor( plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession() );  pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null ); } catch ( Exception e ) { throw new PluginManagerException( plugin, e.getMessage(), e ); }  ClassLoader oldClassLoader = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader( pluginDescriptor.getClassRealm() );  return container.lookup( role, roleHint ); } finally { Thread.currentThread().setContextClassLoader( oldClassLoader ); }",
        "label":0
    },
    {
        "ins1CurCode":"StringBuilder buffer = new StringBuilder( 128 );  buffer.append( '[' ).append( getSeverity() ).append( \"] \" ); buffer.append( getMessage() );",
        "ins1PreCode":"StringBuilder buffer = new StringBuilder( 128 );  buffer.append( \"[\" ).append( getSeverity() ).append( \"] \" ); buffer.append( getMessage() );",
        "ins2PreCode":"StringBuilder buffer = new StringBuilder( 128 );  buffer.append( \"[\" ).append( getSeverity() ).append( \"] \" ); buffer.append( getMessage() );",
        "label":1
    },
    {
        "ins1CurCode":"public void predecessors_selfLoop() { assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void predecessors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(tc.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertTrue(tc.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertTrue(tc.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"Object item = readItem(reader, context, items); items.add(item); } catch (CriticalXStreamException e) { throw e; } catch (XStreamException e) {",
        "ins1PreCode":"Object item = readItem(reader, context, items); items.add(item); } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) {",
        "ins2PreCode":"Object item = readItem(reader, context, collection); collection.add(item); } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XYDotRenderer r1 = new XYDotRenderer(); XYDotRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYDotRenderer r1 = new XYDotRenderer(); XYDotRenderer r2 = (XYDotRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYAreaRenderer2 r1 = new StackedXYAreaRenderer2(); StackedXYAreaRenderer2 r2 = (StackedXYAreaRenderer2) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"void shouldRemoveItemVariableInTheContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldRemoveItemVariableInTheContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldRemoveIndexVariableInTheContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void dispose() { TestDisposableObserver<Integer> tc = new TestDisposableObserver<>(); ",
        "ins1PreCode":"public void dispose() { TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>(); ",
        "ins2PreCode":"public void dispose() { TestCompletable tc = new TestCompletable(); tc.dispose();  assertTrue(tc.isDisposed());  Disposable d = Disposable.empty();  tc.onSubscribe(d);  assertTrue(d.isDisposed());  assertEquals(0, tc.start);",
        "label":0
    },
    {
        "ins1CurCode":"  Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();",
        "ins1PreCode":"  DataFrame dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   DataFrame scaledData = scalerModel.transform(dataFrame); scaledData.show();",
        "ins2PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JaveMinMaxScalerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MinMaxScaler scaler = new MinMaxScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MinMaxScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  jsc.stop();",
        "label":0
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void testFullpathDiffersInCaseScanningSensitive() { assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins1PreCode":"public void testFullpathDiffersInCaseScanningSensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void testFullpathDiffersInCaseScanningInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1CurCode":"public static <T, R> Flowable<R> combineLatestArray(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } Objects.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } ObjectHelper.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"return empty(); } ObjectHelper.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":0
    },
    {
        "ins1CurCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createTimeSeriesChart(\"XY Line Chart\", \"Domain\", \"Range\", dataset, true, true, true);",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createTimeSeriesChart( \"XY Line Chart\", \"Domain\", \"Range\", dataset, true, true, true ); ",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"public void removeEdge_oneOfMany() { assume().that(graphIsMutable()).isTrue();  addEdge(N1, N2, E12); addEdge(N1, N3, E13); addEdge(N1, N4, E14); assertThat(networkAsMutableNetwork.edges()).containsExactly(E12, E13, E14); assertTrue(networkAsMutableNetwork.removeEdge(E13)); assertThat(networkAsMutableNetwork.edges()).containsExactly(E12, E14);",
        "ins1PreCode":"addEdge(N1, N3, E13); addEdge(N1, N4, E14); assertThat(network.edges()).containsExactly(E12, E13, E14); assertTrue(network.removeEdge(E13)); assertThat(network.edges()).containsExactly(E12, E14);",
        "ins2PreCode":"addEdge(N1, N3, E13); addEdge(N1, N4, E14); assertThat(network.edges()).containsExactly(E12, E13, E14); assertTrue(network.removeEdge(E13)); assertThat(network.edges()).containsExactly(E12, E14);",
        "label":1
    },
    {
        "ins1CurCode":"  getCredentialHandler().mutate(credentials); ",
        "ins1PreCode":"  if (containerLog.isTraceEnabled()) containerLog.trace(sm.getString(\"dataSourceRealm.authenticateFailure\",",
        "ins2PreCode":"  if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateFailure\",",
        "label":1
    },
    {
        "ins1CurCode":"public void setLanguage(String lang) {  Object expression = getExpression(); boolean mustChange = true;",
        "ins1PreCode":"public void setLanguage(String lang) {  boolean mustChange = true; if (expression != null) {",
        "ins2PreCode":"public void setLanguage(String lang) {  boolean mustChange = true; if (expression != null) { String oldValue = Model.getDataTypesHelper().getLanguage(expression); if (oldValue != null && oldValue.equals(lang)) { mustChange = false; } } if (mustChange) { String body = EMPTYSTRING; if (expression != null && Model.getDataTypesHelper().getBody(expression) != null) { body = Model.getDataTypesHelper().getBody(expression); }  setExpression(lang, body); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testFileList() { FileList f = new FileList(); f.setProject(project);",
        "ins1PreCode":"public void testFileList() { Path p = new Path(project); FileList f = new FileList();",
        "ins2PreCode":"public void testFileSet() { Path p = new Path(project); FileSet f = new FileSet();",
        "label":1
    },
    {
        "ins1CurCode":"  long targetSize = maxSize * (100 - TARGET_FREE_PERCENT_GET) / 100; long newSize = evict(targetSize, resourceCache.values().iterator()); if (newSize > maxSize) {   removeCacheEntry(path); log.warn(sm.getString(\"cache.addFail\", path, root.getContext().getName())); }",
        "ins1PreCode":"  long targetSize = maxSize * (100 - TARGET_FREE_PERCENT_GET) / 100; long newSize = evict( targetSize, resourceCache.values().iterator()); if (newSize > maxSize) {   removeCacheEntry(path); log.warn(sm.getString(\"cache.addFail\", path)); }",
        "ins2PreCode":"protected WebResource[] getResources(String path, boolean useClassLoaderResources) { lookupCount.incrementAndGet();     CachedResource cacheEntry = resourceCache.get(path);  if (cacheEntry != null && !cacheEntry.validateResources(useClassLoaderResources)) { removeCacheEntry(path); cacheEntry = null; }  if (cacheEntry == null) {  int objectMaxSizeBytes = getObjectMaxSizeBytes(); CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);    cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);  if (cacheEntry == null) {  cacheEntry = newCacheEntry; cacheEntry.validateResources(useClassLoaderResources);   long delta = cacheEntry.getSize(); size.addAndGet(delta);  if (size.get() > maxSize) {     long targetSize = maxSize * (100 - TARGET_FREE_PERCENT_GET) / 100; long newSize = evict( targetSize, resourceCache.values().iterator()); if (newSize > maxSize) {   removeCacheEntry(path); log.warn(sm.getString(\"cache.addFail\", path)); } } } else {   cacheEntry.validateResources(useClassLoaderResources); } } else { hitCount.incrementAndGet(); }  return cacheEntry.getWebResources();",
        "label":0
    },
    {
        "ins1CurCode":"void testLangRawWithInclude() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testLangRawWithInclude() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testLangRawWithIncludeAndCData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, NestedObjectCommand<ExasolFunction, PropertyHandler> command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, SQLObjectEditor.NestedObjectCommand<ExasolFunction, SQLObjectEditor<ExasolFunction, ExasolSchema>.PropertyHandler> command) {",
        "ins2PreCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolScript, SQLObjectEditor<ExasolScript, ExasolSchema>.PropertyHandler> command) {",
        "label":0
    },
    {
        "ins1CurCode":"public void setUp() throws Exception { ",
        "ins1PreCode":"public static void setUp() throws Exception {  Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/typehandler/mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(StringTrimmingTypeHandler.class); sqlSessionFactory.getConfiguration().addMapper(Mapper.class); ",
        "ins2PreCode":"public static void initDatabase() throws Exception { Connection conn = null;  try { Class.forName(\"org.hsqldb.jdbcDriver\"); conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:enumtypehandler_on_annotation\", \"sa\", \"\");  Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/enumtypehandler_on_annotation/CreateDB.sql\");  ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); runner.runScript(reader); conn.commit(); reader.close();  reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/enumtypehandler_on_annotation/mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); sqlSessionFactory.getConfiguration().getMapperRegistry().addMapper(PersonMapper.class); reader.close(); } finally { if (conn != null) { conn.close(); } }",
        "label":0
    },
    {
        "ins1CurCode":"public synchronized void storeConfig() throws Exception { try { ObjectName sname = new ObjectName(getDomain() + \":type=StoreConfig\"); if (mserver.isRegistered(sname)) { mserver.invoke(sname, \"storeConfig\", null, null); } else { log.error(sm.getString(\"standardServer.storeConfig.notAvailable\", sname)); }",
        "ins1PreCode":"public synchronized void storeConfig() throws Exception {  ObjectName sname = null; try { sname = new ObjectName(\"Catalina:type=StoreConfig\"); if(mserver.isRegistered(sname)) { mserver.invoke(sname, \"storeConfig\", null, null); } else log.error(\"StoreConfig mbean not registered\" + sname); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); } ",
        "ins2PreCode":"public synchronized void storeContext(Context context) throws Exception {  ObjectName sname = null; try { sname = new ObjectName(getDomain() + \":type=StoreConfig\"); if(mserver.isRegistered(sname)) { mserver.invoke(sname, \"store\", new Object[] {context}, new String [] { \"java.lang.String\"}); } else log.error(\"StoreConfig mbean not registered\" + sname); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); } ",
        "label":0
    },
    {
        "ins1CurCode":"public final PostdotContext postdot() throws RecognitionException { PostdotContext _localctx = new PostdotContext(_ctx, getState()); enterRule(_localctx, 52, RULE_postdot); try { setState(424); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(422); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(423); fieldaccess();",
        "ins1PreCode":"public final PostdotContext postdot() throws RecognitionException { PostdotContext _localctx = new PostdotContext(_ctx, getState()); enterRule(_localctx, 42, RULE_postdot); try { setState(363); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,31,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(361); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(362); fieldaccess();",
        "ins2PreCode":"public final PostfixContext postfix() throws RecognitionException { PostfixContext _localctx = new PostfixContext(_ctx, getState()); enterRule(_localctx, 40, RULE_postfix); try { setState(359); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(356); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(357); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(358); braceaccess();",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); t = new Thread(new Runnable() {",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); t = new Thread(new Runnable() {",
        "ins2PreCode":"public void subscribe(final Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); t = new Thread(new Runnable() {  @Override public void run() { for (String s : valuesToReturn) { if (s == null) { System.out.println(\"throwing exception\"); try { Thread.sleep(100); } catch (Throwable e) {  } subscriber.onError(new NullPointerException()); return; } else { subscriber.onNext(s); } } System.out.println(\"subscription complete\"); subscriber.onComplete(); }  }); t.start();",
        "label":0
    },
    {
        "ins1CurCode":"new Object[]{c}); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); if (t instanceof ServletException) {",
        "ins1PreCode":"new Object[]{c}); } catch (Throwable t) { if (t instanceof ServletException) { throw (ServletException) t;",
        "ins2PreCode":"new Object[]{c}); } catch (Throwable t) { if (t instanceof ServletException) { throw (ServletException) t;",
        "label":1
    },
    {
        "ins1CurCode":"void wrap() { XAConnectionFactory connectionFactory = mock(XAConnectionFactory.class);",
        "ins1PreCode":"public void wrap() { XAConnectionFactory connectionFactory = mock(XAConnectionFactory.class);",
        "ins2PreCode":"public void wrap() { XAConnectionFactory connectionFactory = mock(XAConnectionFactory.class);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"};  Disposable sub1 = Disposable.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposable.empty(); ",
        "ins1PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "ins2PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",this.tDatasource.getNumActive(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "ins1PreCode":"long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",this.tDatasource.getNumActive(),10); tearDown();",
        "ins2PreCode":"long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",this.datasource.getSize(),10); tearDown(); ",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, EnumSet.noneOf(SearchFlags.class)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false); ",
        "ins2PreCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true); ",
        "label":0
    },
    {
        "ins1CurCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsEmptyNumber() { CLICommandInvoker.Result result = command",
        "ins1PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsEmptyNumber() throws Exception { CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsHyphen() throws Exception { CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click(); submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\"));",
        "ins1PreCode":"f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click(); submit(f); assertEquals(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\").toString());",
        "ins2PreCode":"f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click(); submit(f); assertEquals(\"[{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"1\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"2\\\"},\" + \"{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"three\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt 4\\\"}]\", formData.get(\"foos\").toString());",
        "label":1
    },
    {
        "ins1CurCode":"ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return concatArray(source1, source2, source3, source4);",
        "ins1PreCode":"ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return concatArray(source1, source2, source3, source4);",
        "ins2PreCode":"ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);",
        "label":1
    },
    {
        "ins1CurCode":"void concurrentModificationExceptionInvalidatesCache() { ",
        "ins1PreCode":"public void concurrentModificationExceptionInvalidatesCache() { ",
        "ins2PreCode":"public void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() { ",
        "label":1
    },
    {
        "ins1CurCode":"public void outputFusedReject() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.SYNC); ",
        "ins1PreCode":"public void outputFusedReject() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC); ",
        "ins2PreCode":"public void outputFused() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.ANY);  Flowable.range(1, 5).hide() .observeOn(Schedulers.single()) .subscribe(ts);  ts.assertFusionMode(QueueFuseable.ASYNC) .awaitDone(5, TimeUnit.SECONDS) .assertResult(1, 2, 3, 4, 5);",
        "label":0
    },
    {
        "ins1CurCode":"\"#{beanA.getBean().name}\", java.lang.String.class); String actual = (String) ve.getValue(context); Assert.assertEquals(BUG53792, actual);",
        "ins1PreCode":"\"#{beanA.getBean().name}\", java.lang.String.class); String actual = (String) ve.getValue(context); assertEquals(BUG53792, actual);",
        "ins2PreCode":"\"#{beanA.getBean().name.length()}\", java.lang.Integer.class); Integer actual = (Integer) ve.getValue(context); assertEquals(Integer.valueOf(BUG53792.length()), actual);",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public static void main(String[] args) { SparkSession spark = SparkSession .builder().appName(\"JavaDecisionTreeClassificationExample\").getOrCreate();    Dataset<Row> data = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\");    StringIndexerModel labelIndexer = new StringIndexer() .setInputCol(\"label\") .setOutputCol(\"indexedLabel\") .fit(data);   VectorIndexerModel featureIndexer = new VectorIndexer() .setInputCol(\"features\") .setOutputCol(\"indexedFeatures\") .setMaxCategories(4) .fit(data);   Dataset<Row>[] splits = data.randomSplit(new double[]{0.7, 0.3}); Dataset<Row> trainingData = splits[0]; Dataset<Row> testData = splits[1];   DecisionTreeClassifier dt = new DecisionTreeClassifier() .setLabelCol(\"indexedLabel\") .setFeaturesCol(\"indexedFeatures\");   IndexToString labelConverter = new IndexToString() .setInputCol(\"prediction\") .setOutputCol(\"predictedLabel\") .setLabels(labelIndexer.labels());   Pipeline pipeline = new Pipeline() .setStages(new PipelineStage[]{labelIndexer, featureIndexer, dt, labelConverter});   PipelineModel model = pipeline.fit(trainingData);   Dataset<Row> predictions = model.transform(testData);   predictions.select(\"predictedLabel\", \"label\", \"features\").show(5);   MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));  DecisionTreeClassificationModel treeModel = (DecisionTreeClassificationModel) (model.stages()[2]); System.out.println(\"Learned classification tree model:\\n\" + treeModel.toDebugString());   spark.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaDecisionTreeClassificationExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc);    Dataset<Row> data = sqlContext .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\");    StringIndexerModel labelIndexer = new StringIndexer() .setInputCol(\"label\") .setOutputCol(\"indexedLabel\") .fit(data);   VectorIndexerModel featureIndexer = new VectorIndexer() .setInputCol(\"features\") .setOutputCol(\"indexedFeatures\") .setMaxCategories(4) .fit(data);   Dataset<Row>[] splits = data.randomSplit(new double[]{0.7, 0.3}); Dataset<Row> trainingData = splits[0]; Dataset<Row> testData = splits[1];   DecisionTreeClassifier dt = new DecisionTreeClassifier() .setLabelCol(\"indexedLabel\") .setFeaturesCol(\"indexedFeatures\");   IndexToString labelConverter = new IndexToString() .setInputCol(\"prediction\") .setOutputCol(\"predictedLabel\") .setLabels(labelIndexer.labels());   Pipeline pipeline = new Pipeline() .setStages(new PipelineStage[]{labelIndexer, featureIndexer, dt, labelConverter});   PipelineModel model = pipeline.fit(trainingData);   Dataset<Row> predictions = model.transform(testData);   predictions.select(\"predictedLabel\", \"label\", \"features\").show(5);   MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));  DecisionTreeClassificationModel treeModel = (DecisionTreeClassificationModel) (model.stages()[2]); System.out.println(\"Learned classification tree model:\\n\" + treeModel.toDebugString());   jsc.stop();",
        "ins2PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaRandomForestClassifierExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc);    Dataset<Row> data = sqlContext.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");    StringIndexerModel labelIndexer = new StringIndexer() .setInputCol(\"label\") .setOutputCol(\"indexedLabel\") .fit(data);   VectorIndexerModel featureIndexer = new VectorIndexer() .setInputCol(\"features\") .setOutputCol(\"indexedFeatures\") .setMaxCategories(4) .fit(data);   Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3}); Dataset<Row> trainingData = splits[0]; Dataset<Row> testData = splits[1];   RandomForestClassifier rf = new RandomForestClassifier() .setLabelCol(\"indexedLabel\") .setFeaturesCol(\"indexedFeatures\");   IndexToString labelConverter = new IndexToString() .setInputCol(\"prediction\") .setOutputCol(\"predictedLabel\") .setLabels(labelIndexer.labels());   Pipeline pipeline = new Pipeline() .setStages(new PipelineStage[] {labelIndexer, featureIndexer, rf, labelConverter});   PipelineModel model = pipeline.fit(trainingData);   Dataset<Row> predictions = model.transform(testData);   predictions.select(\"predictedLabel\", \"label\", \"features\").show(5);   MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));  RandomForestClassificationModel rfModel = (RandomForestClassificationModel)(model.stages()[2]); System.out.println(\"Learned classification forest model:\\n\" + rfModel.toDebugString());   jsc.stop();",
        "label":1
    },
    {
        "ins1CurCode":"String processorTag = randomAlphaOfLength(10);  UserAgentProcessor processor = factory.create(null, processorTag, null, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins1PreCode":"String processorTag = randomAlphaOfLength(10);  UserAgentProcessor processor = factory.create(null, processorTag, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins2PreCode":"String processorTag = randomAlphaOfLength(10);  UserAgentProcessor processor = factory.create(null, processorTag, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"public void operationCompleted(BasePanel panel) { if (couldNotConnect) {  dialogService.showErrorDialogAndWait(Localization.lang(\"Error pushing entries\"), Localization.lang(\"Could not connect to a running gnuserv process. Make sure that \" + \"Emacs or XEmacs is running, and that the server has been started \" + \"(by running the command 'server-start'/'gnuserv-start').\"));  } else if (couldNotCall) { dialogService.showErrorDialogAndWait(Localization.lang(\"Error pushing entries\"), Localization.lang(\"Could not run the gnuclient/emacsclient program. Make sure you have \" + \"the emacsclient/gnuclient program installed and available in the PATH.\"));  } else {",
        "ins1PreCode":"public void operationCompleted(BasePanel panel) { if (couldNotConnect) { JOptionPane.showMessageDialog(panel.frame(), \"<HTML>\" + Localization.lang(\"Could not connect to a running gnuserv process. Make sure that \" + \"Emacs or XEmacs is running,<BR>and that the server has been started \" + \"(by running the command 'server-start'/'gnuserv-start').\") + \"</HTML>\", Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else if (couldNotCall) { JOptionPane.showMessageDialog(panel.frame(), Localization.lang(\"Could not run the gnuclient/emacsclient program. Make sure you have \" + \"the emacsclient/gnuclient program installed and available in the PATH.\"), Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else {",
        "ins2PreCode":"public void operationCompleted(BasePanel panel) { if (couldNotConnect) { JOptionPane.showMessageDialog( panel.frame(), \"<HTML>\" + Localization.lang(\"Could not connect to Vim server. Make sure that \" + \"Vim is running<BR>with correct server name.\") + \"</HTML>\", Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else if (couldNotCall) { JOptionPane.showMessageDialog( panel.frame(), Localization.lang(\"Could not run the 'vim' program.\"), Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else {",
        "label":0
    },
    {
        "ins1CurCode":"if (missed == 0) { break; } }",
        "ins1PreCode":"}  if (index.get() != null) { continue; }",
        "ins2PreCode":"public void replay(ReplayDisposable<T> rs) { if (rs.getAndIncrement() != 0) { return; }  int missed = 1; final Observer<? super T> a = rs.downstream;  Node<Object> index = (Node<Object>)rs.index; if (index == null) { index = head; }  for (;;) {  for (;;) { if (rs.cancelled) { rs.index = null; return; }  Node<Object> n = index.get();  if (n == null) { break; }  Object o = n.value;  if (done) { if (n.get() == null) {  if (NotificationLite.isComplete(o)) { a.onComplete(); } else { a.onError(NotificationLite.getError(o)); } rs.index = null; rs.cancelled = true; return; } }  a.onNext((T)o);  index = n; }  if (index.get() != null) { continue; }  rs.index = index;  missed = rs.addAndGet(-missed); if (missed == 0) { break; } }",
        "label":0
    },
    {
        "ins1CurCode":"final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposable.fromRunnable(new Runnable() {  @Override public void run() { counter.incrementAndGet(); }  }));  cd.add(Disposable.fromRunnable(new Runnable() { ",
        "ins1PreCode":"final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposables.fromRunnable(new Runnable() {  @Override public void run() { counter.incrementAndGet(); }  }));  cd.add(Disposables.fromRunnable(new Runnable() { ",
        "ins2PreCode":"final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposables.fromRunnable(new Runnable() { ",
        "label":0
    },
    {
        "ins1CurCode":" assertThat(transpose.edgesConnecting(N1, N2)).isEmpty(); assertThat(transpose.edgeConnectingOrNull(N1, N2)).isNull();  directedGraph.addEdge(N2, N1, E21);  assertThat(transpose.edgesConnecting(N1, N2)).containsExactly(E21); assertThat(transpose.edgeConnectingOrNull(N1, N2)).isEqualTo(E21); ",
        "ins1PreCode":" assertThat(transpose.edgesConnecting(N1, N2)).isEmpty(); directedGraph.addEdge(N2, N1, E21);  assertThat(transpose.edgesConnecting(N1, N2)).containsExactly(E21); AbstractNetworkTest.validateNetwork(transpose);",
        "ins2PreCode":" assertThat(transpose.edgesConnecting(N1, N2)).isEmpty(); directedGraph.addEdge(N2, N1, E21);  assertThat(transpose.edgesConnecting(N1, N2)).containsExactly(E21); AbstractNetworkTest.validateNetwork(transpose);",
        "label":0
    },
    {
        "ins1CurCode":"} catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile);",
        "ins1PreCode":"} } catch (SQLException e) { throw new DBCException(e, dataSource); } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (SQLException e) { ContentUtils.deleteTempFile(tempFile);",
        "ins2PreCode":"public DBDContentStorage getContents(DBRProgressMonitor monitor) throws DBCException { if (storage == null && bfile != null) { try { openFile(); long contentLength = getContentLength(); DBPPlatform platform = dataSource.getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = getInputStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, platform.getPreferenceStore().getString(ModelPreferences.CONTENT_HEX_ENCODING)); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + bfile.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = getInputStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); } this.storage = new TemporaryContentStorage(platform, tempFile); }  releaseBlob(); } finally { closeFile(); } } return storage;",
        "label":0
    },
    {
        "ins1CurCode":"SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2 = (SlidingCategoryDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2 = (SlidingCategoryDataset) TestUtilities.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryDataset u1 = new DefaultCategoryDataset(); u1.addValue(1.0, \"R1\", \"C1\"); u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2; d2 = (SlidingCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\"); assertTrue(d1.equals(d2));",
        "label":0
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":"public void completeDelegateThrows() { TestObserver<Integer> to = new TestObserver<>(new Observer<Integer>() { ",
        "ins1PreCode":"public void completeDelegateThrows() { TestObserver<Integer> to = new TestObserver<Integer>(new Observer<Integer>() { ",
        "ins2PreCode":"public void errorDelegateThrows() { TestObserver<Integer> to = new TestObserver<Integer>(new Observer<Integer>() { ",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"2005\"), entry.getField(StandardField.YEAR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"2005\"), entry.getField(\"year\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"WebServiceTemplate template = this.builder.customizers(customizer1) .customizers(Collections.singleton(customizer2)).build(); verifyNoInteractions(customizer1); verify(customizer2).customize(template);",
        "ins1PreCode":"WebServiceTemplate template = this.builder.customizers(customizer1) .customizers(Collections.singleton(customizer2)).build(); verifyZeroInteractions(customizer1); verify(customizer2).customize(template);",
        "ins2PreCode":"RestTemplate template = this.builder.customizers(customizer1).customizers(Collections.singleton(customizer2)) .build(); verifyZeroInteractions(customizer1); verify(customizer2).customize(template);",
        "label":1
    },
    {
        "ins1CurCode":"f.getInputsByName(\"bool\").get(2).click(); submit(f); assertEqualsJsonArray(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" + \"{\\\"bool\\\":false,\\\"txt\\\":\\\"value two\\\"},{\\\"bool\\\":true,\\\"txt\\\":\\\"value three\\\"}]\", formData.get(\"foos\"));",
        "ins1PreCode":"f.getInputsByName(\"bool\").get(2).click(); submit(f); assertEquals(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" + \"{\\\"bool\\\":false,\\\"txt\\\":\\\"value two\\\"},{\\\"bool\\\":true,\\\"txt\\\":\\\"value three\\\"}]\", formData.get(\"foos\").toString());",
        "ins2PreCode":"f.getInputsByName(\"bool\").get(1).click(); submit(f); assertEquals(\"[{\\\"bool\\\":true,\\\"txt\\\":\\\"existing one\\\"},\" + \"{\\\"bool\\\":true,\\\"txt\\\":\\\"existing two\\\"},{\\\"bool\\\":false,\\\"txt\\\":\\\"new one\\\"}]\", formData.get(\"foos\").toString());",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsANegativeNumber() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-1-1\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-1\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-1-+1\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-+1\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-1-2\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-2\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-1-+2\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-+2\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1--1\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1--1', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"+1--1\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '+1--1', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1--2\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1--2', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"+1--2\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '+1--2', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-1--1\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1--1\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-2--1\");",
        "ins1PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsANegativeNumber() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-1-1\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-1\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-1-+1\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-+1\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-1-2\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-2\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-1-+2\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1-+2\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1--1\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1--1', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"+1--1\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '+1--1', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1--2\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1--2', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"+1--2\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '+1--2', expected correct notation M,N or M-N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-1--1\"); assertThat(result, failedWith(2)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: \\\"-1--1\\\" is not a valid option\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-2--1\");",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeIsInverse() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"2-1\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '2-1', expected string with a range M-N where M<N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"10-1\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '10-1', expected string with a range M-N where M<N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-1--2\");",
        "label":0
    },
    {
        "ins1CurCode":"IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = (IntervalCategoryToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CustomXYToolTipGenerator g1 = new CustomXYToolTipGenerator(); CustomXYToolTipGenerator g2 = (CustomXYToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(EnumSet.noneOf(SearchFlags.class), query).getDescription(); ",
        "ins1PreCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, false, query).getDescription(); ",
        "ins2PreCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription(); ",
        "label":0
    },
    {
        "ins1CurCode":"this.environment.getPropertySources().addLast(propertySource2); this.environment.getPropertySources().addLast(propertySource3); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles); List<ConfigDataEnvironmentContributor> children = configDataEnvironment.getContributors().getRoot()",
        "ins1PreCode":"this.environment.getPropertySources().addLast(propertySource2); this.environment.getPropertySources().addLast(propertySource3); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles); List<ConfigDataEnvironmentContributor> children = configDataEnvironment.getContributors().getRoot()",
        "ins2PreCode":"this.environment.getPropertySources().addLast(propertySource1); this.environment.getPropertySources().addLast(propertySource2); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles); List<ConfigDataEnvironmentContributor> children = configDataEnvironment.getContributors().getRoot()",
        "label":1
    },
    {
        "ins1CurCode":"series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1); ",
        "ins1PreCode":"series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); ",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"public void zipIterableObject() { final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3)); Observable.zip(observables, new Function<Object[], Object>() {",
        "ins1PreCode":"public void zipIterableObject() { @SuppressWarnings(\"unchecked\") final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3));",
        "ins2PreCode":"public void zipIterableObject() { @SuppressWarnings(\"unchecked\") final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3));",
        "label":1
    },
    {
        "ins1CurCode":"public void testInvalidJoinFieldInsideObject() throws Exception { MapperParsingException exc = expectThrows(MapperParsingException.class, () -> createMapperService(mapping(b -> { b.startObject(\"object\"); { b.startObject(\"properties\"); { b.startObject(\"join_field\"); b.field(\"type\", \"join\").startObject(\"relations\").field(\"parent\", \"child\").endObject(); b.endObject(); } b.endObject(); } b.endObject(); }))); assertThat(exc.getRootCause().getMessage(),",
        "ins1PreCode":"public void testInvalidJoinFieldInsideObject() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"properties\") .startObject(\"object\") .startObject(\"properties\") .startObject(\"join_field\") .field(\"type\", \"join\") .startObject(\"relations\") .field(\"parent\", \"child\") .endObject() .endObject() .endObject() .endObject() .endObject().endObject()); IndexService indexService = createIndex(\"test\"); MapperParsingException exc = expectThrows(MapperParsingException.class, () -> indexService.mapperService().merge(\"type\", new CompressedXContent(mapping), MapperService.MergeReason.MAPPING_UPDATE)); assertThat(exc.getRootCause().getMessage(),",
        "ins2PreCode":"public void testInvalidJoinFieldInsideMultiFields() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"properties\") .startObject(\"number\") .field(\"type\", \"integer\") .startObject(\"fields\") .startObject(\"join_field\") .field(\"type\", \"join\") .startObject(\"relations\") .field(\"parent\", \"child\") .endObject() .endObject() .endObject() .endObject() .endObject().endObject()); IndexService indexService = createIndex(\"test\"); MapperParsingException exc = expectThrows(MapperParsingException.class, () -> indexService.mapperService().merge(\"type\", new CompressedXContent(mapping), MapperService.MergeReason.MAPPING_UPDATE)); assertThat(exc.getRootCause().getMessage(), containsString(\"join field [number.join_field] cannot be added inside an object or in a multi-field\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void unorderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<>(1); Disposable d = Disposable.empty();",
        "ins1PreCode":"public void unorderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "ins2PreCode":"public void orderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1CurCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(\",\") .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace()))",
        "ins1PreCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace()))",
        "ins2PreCode":"public void testCharacterSplitWithTrim() { String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = COMMA_SPLITTER .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace())) .split(jacksons); assertThat(family) .containsExactly(\"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\") .inOrder();",
        "label":0
    },
    {
        "ins1CurCode":"public void nodeOrder_insertion() { MutableGraph<Integer> graph = GraphBuilder .directed()",
        "ins1PreCode":"public void nodeOrder_insertion() { MutableBasicGraph<Integer> graph = BasicGraphBuilder .directed()",
        "ins2PreCode":"public void nodeOrder_default() { MutableBasicGraph<Integer> graph = BasicGraphBuilder .directed()",
        "label":1
    },
    {
        "ins1CurCode":"public void testSingleFile() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);  LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult); ",
        "ins1PreCode":"public void testSingleFile() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); ",
        "ins2PreCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); ",
        "label":1
    },
    {
        "ins1CurCode":"for (int i = 0; i < 1000; i++) { for (int j = 1; j < 6; j++) { List<TestSubscriberEx<Integer>> tss = new ArrayList<>(); for (int k = 1; k < j; k++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); tss.add(ts);",
        "ins1PreCode":"for (int i = 0; i < 1000; i++) { for (int j = 1; j < 6; j++) { List<TestSubscriberEx<Integer>> tss = new ArrayList<TestSubscriberEx<Integer>>(); for (int k = 1; k < j; k++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); tss.add(ts);",
        "ins2PreCode":"for (int i = 0; i < 1000; i++) { for (int j = 1; j < 6; j++) { List<TestSubscriberEx<Integer>> tss = new ArrayList<TestSubscriberEx<Integer>>(); for (int k = 1; k < j; k++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); tss.add(ts);",
        "label":1
    },
    {
        "ins1CurCode":"AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrNull(N1, N2)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrNull(N1, N2)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "ins1PreCode":"AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "ins2PreCode":"AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "label":1
    },
    {
        "ins1CurCode":"void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); factory.setRegisterDefaultServlet(true); addTestTxtFile(factory);",
        "ins1PreCode":"void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(ClientAuth.NEED, \"password\", \"classpath:test.jks\", \"classpath:test.jks\", null, null));",
        "ins2PreCode":"void sslWantsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl( getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\", null, new String[] { \"TLSv1.2\" }, null)); this.webServer = factory.getWebServer(); this.webServer.start(); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(new FileInputStream(new File(\"src/test/resources/test.jks\")), \"secret\".toCharArray()); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = this.httpClientBuilder.get().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); assertThat(getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory)).isEqualTo(\"test\");",
        "label":0
    },
    {
        "ins1CurCode":"protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p) throws BuildException { if (isChecked()) { return; } if (isReference()) { super.dieOnCircularReference(stk, p); } else { for (FileSelector fileSelector : selectorsList) { if (fileSelector instanceof DataType) { pushAndInvokeCircularReferenceCheck((DataType) fileSelector, stk, p); }",
        "ins1PreCode":"protected synchronized void dieOnCircularReference(Stack stk, Project p) throws BuildException { if (isChecked()) { return; } if (isReference()) { super.dieOnCircularReference(stk, p); } else { for (Iterator i = selectorsList.iterator(); i.hasNext();) { Object o = i.next(); if (o instanceof DataType) { pushAndInvokeCircularReferenceCheck((DataType) o, stk, p); }",
        "ins2PreCode":"protected synchronized void dieOnCircularReference(Stack stk, Project p) { if (isChecked()) { return; } if (isReference()) { super.dieOnCircularReference(stk, p); } else { for (Iterator i = selectorsList.iterator(); i.hasNext(); ) { Object o = i.next(); if (o instanceof DataType) { pushAndInvokeCircularReferenceCheck((DataType) o, stk, p); }",
        "label":1
    },
    {
        "ins1CurCode":"return; } context.start(); if (context.getAvailable())",
        "ins1PreCode":"return; } ((Lifecycle) context).start(); if (context.getAvailable())",
        "ins2PreCode":"return; } ((Lifecycle) context).stop(); writer.println(sm.getString(\"managerServlet.stopped\", displayPath));",
        "label":1
    },
    {
        "ins1CurCode":"void matchWithExcludeFilter() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithExcludeFilter.class);",
        "ins1PreCode":"public void matchWithExcludeFilter() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithExcludeFilter.class);",
        "ins2PreCode":"public void matchWhenHasNoControllers() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithNoControllers.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void createDirected_expectedEdgeCount() { MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed() .expectedEdgeCount(EDGE_COUNT)",
        "ins1PreCode":"public void createDirected_expectedEdgeCount() { Graph<Integer, String> directedGraph = GraphBuilder.directed() .expectedEdgeCount(EDGE_COUNT)",
        "ins2PreCode":"public void createUndirected_expectedEdgeCount() { Graph<Integer, String> undirectedGraph = GraphBuilder.undirected() .expectedEdgeCount(EDGE_COUNT)",
        "label":1
    },
    {
        "ins1CurCode":"WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() { EndpointMediaTypes endpointMediaTypes = EndpointMediaTypes.DEFAULT; WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(this.applicationContext,",
        "ins1PreCode":"WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() { List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, ActuatorMediaType.V2_JSON); EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, mediaTypes); WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(this.applicationContext,",
        "ins2PreCode":"WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping() { List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, ActuatorMediaType.V2_JSON); EndpointMediaTypes endpointMediaTypes = new EndpointMediaTypes(mediaTypes, mediaTypes); WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(this.applicationContext,",
        "label":1
    },
    {
        "ins1CurCode":"addFig(getNameFig()); addFig(getStereotypeFig()); createCompartments(); ",
        "ins1PreCode":"addFig(getNameFig()); addFig(getStereotypeFig()); addExtraCompartments(); addFig(getOperationsFig()); ",
        "ins2PreCode":"  if (Model.getUmlFactory().isContainmentValid( Model.getMetaTypes().getAttribute(), getOwner())) { addFig(new FigAttributesCompartment( getOwner(), DEFAULT_COMPARTMENT_BOUNDS, getSettings())); } addFig(getOperationsFig()); ",
        "label":0
    },
    {
        "ins1CurCode":"entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\");",
        "ins1PreCode":"entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\");",
        "ins2PreCode":"entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Massachusetts Institute of Technology}\");",
        "label":1
    },
    {
        "ins1CurCode":"void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class,",
        "ins1PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class,",
        "ins2PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class,",
        "label":1
    },
    {
        "ins1CurCode":"void testList() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(ListConfig.class)",
        "ins1PreCode":"public void testList() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(ListConfig.class)",
        "ins2PreCode":"public void testInetAddress() { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "label":1
    },
    {
        "ins1CurCode":"static final QueueDrainSubscriber<Integer, Integer, Integer> createUnorderedReject(TestSubscriber<Integer> ts, final Disposable d) { return new QueueDrainSubscriber<Integer, Integer, Integer>(ts, new SpscArrayQueue<>(4)) { @Override",
        "ins1PreCode":"static final QueueDrainSubscriber<Integer, Integer, Integer> createUnorderedReject(TestSubscriber<Integer> ts, final Disposable d) { return new QueueDrainSubscriber<Integer, Integer, Integer>(ts, new SpscArrayQueue<Integer>(4)) { @Override",
        "ins2PreCode":"static final QueueDrainSubscriber<Integer, Integer, Integer> createOrderedReject(TestSubscriber<Integer> ts, final Disposable d) { return new QueueDrainSubscriber<Integer, Integer, Integer>(ts, new SpscArrayQueue<Integer>(4)) { @Override",
        "label":1
    },
    {
        "ins1CurCode":"void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment();",
        "ins1PreCode":"public void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment();",
        "ins2PreCode":"private void testMaxFileSizeProperty(String sizeValue, String expectedFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-size\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext( environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\"); assertThat(ReflectionTestUtils.getField(getRollingPolicy(), \"maxFileSize\") .toString()).isEqualTo(expectedFileSize);",
        "label":0
    },
    {
        "ins1CurCode":"public void observerCheckTerminatedDelayErrorEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposables.empty(); ",
        "label":0
    },
    {
        "ins1CurCode":"}; SerializedObserver<Integer> sobs = new SerializedObserver<Integer>(to); sobs.onSubscribe(Disposable.empty()); serial.set(sobs);",
        "ins1PreCode":"}; SerializedObserver<Integer> sobs = new SerializedObserver<Integer>(to); sobs.onSubscribe(Disposables.empty()); serial.set(sobs);",
        "ins2PreCode":"public void errorReentry() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<Integer>> serial = new AtomicReference<Subscriber<Integer>>();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>() { @Override public void onNext(Integer v) { serial.get().onError(new TestException()); serial.get().onError(new TestException()); super.onNext(v); } }; SerializedSubscriber<Integer> sobs = new SerializedSubscriber<Integer>(ts); sobs.onSubscribe(new BooleanSubscription()); serial.set(sobs);  sobs.onNext(1);  ts.assertValue(1); ts.assertError(TestException.class);  TestHelper.assertUndeliverable(errors, 0, TestException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void assertNeverAtNotMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber);",
        "ins1PreCode":"public void assertNeverAtNotMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>(); oi.subscribe(subscriber);",
        "ins2PreCode":"public void assertNeverAtMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1CurCode":"super.translate(dx, dy); Editor ce = Globals.curEditor(); if (ce != null) { Selection sel = ce.getSelectionManager().findSelectionFor(this);",
        "ins1PreCode":"super.translate(dx, dy); Editor ce = Globals.curEditor(); Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) {",
        "ins2PreCode":"super.translate(dx, dy); Editor ce = Globals.curEditor(); Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) {",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(true); buf.addLast(new Node(1, 0)); buf.addLast(new Node(2, 1)); buf.addLast(new Node(3, 2)); buf.addLast(new Node(4, 3)); buf.addLast(new Node(5, 4));  List<Integer> values = new ArrayList<>(); buf.collect(values);",
        "ins1PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>(true); buf.addLast(new Node(1, 0)); buf.addLast(new Node(2, 1)); buf.addLast(new Node(3, 2)); buf.addLast(new Node(4, 3)); buf.addLast(new Node(5, 4));  List<Integer> values = new ArrayList<Integer>(); buf.collect(values);",
        "ins2PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>(false); buf.addLast(new Node(1, 0)); buf.addLast(new Node(2, 1)); buf.addLast(new Node(3, 2)); buf.addLast(new Node(4, 3)); buf.addLast(new Node(5, 4));  List<Integer> values = new ArrayList<Integer>(); buf.collect(values);",
        "label":1
    },
    {
        "ins1CurCode":"void applyPropertyValueOnXmlMapper() throws IOException { ",
        "ins1PreCode":"public void applyPropertyValueOnXmlMapper() throws IOException { ",
        "ins2PreCode":"public void applyPropertyValueOnAnnotationMapper() throws IOException { ",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtPredicateNoMatch() { assertThrowsWithMessage(\"Value 3 (class: Integer) at position 2 did not pass the predicate (latch = 0, values = 3, errors = 0, completions = 1)\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1PreCode":"public void assertValueAtPredicateNoMatch() { assertThrows(\"Value not present\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins2PreCode":"public void assertValueAtPredicateNoMatch() { assertThrows(\"Value not present\", AssertionError.class, () -> { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();  Flowable.just(1, 2, 3).subscribe(ts);  ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o != 3; } }); });",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(CompletableObserver observer) { try { Disposable d1 = Disposable.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposable.empty(); ",
        "ins1PreCode":"protected void subscribeActual(CompletableObserver observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "ins2PreCode":"protected void subscribeActual(CompletableObserver observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"private IoBuffer putInt(Pointer pointer, int value) { if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 4) { throw new BufferUnderflowException(); } for (int i = 0; i < 32; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 24 - i : i))); }",
        "ins1PreCode":"public IoBuffer putInt(int value) { if (remaining() < 4) { throw new BufferUnderflowException(); }  for (int i = 0; i < 32; i += 8) { put((byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 24 - i : i))); }",
        "ins2PreCode":"public IoBuffer putShort(short value) { if (remaining() < 2) { throw new BufferUnderflowException(); }  for (int i = 0; i < 16; i += 8) { put((byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 8 - i : i))); }",
        "label":0
    },
    {
        "ins1CurCode":"void roundTripWithModification() throws IOException { ",
        "ins1PreCode":"public void roundTripWithModification() throws IOException { ",
        "ins2PreCode":"public void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException { ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { TextTitle t1 = new TextTitle(); TextTitle t2 = CloneUtils.clone(t1); assertTrue(t1 != t2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { TextTitle t1 = new TextTitle(); TextTitle t2 = (TextTitle) t1.clone(); assertTrue(t1 != t2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { ShortTextTitle t1 = new ShortTextTitle(\"ABC\"); ShortTextTitle t2 = (ShortTextTitle) t1.clone(); assertTrue(t1 != t2);",
        "label":1
    },
    {
        "ins1CurCode":"private static void checkUserIsConnected(WebClient wc, String username) throws Exception { XmlPage xmlPage = wc.goToXml(\"whoAmI/api/xml\");",
        "ins1PreCode":"private void checkUserIsConnected(WebClient wc, String username) throws Exception { XmlPage xmlPage = wc.goToXml(\"whoAmI/api/xml\");",
        "ins2PreCode":"private void checkUserIsConnected(WebClient wc) throws Exception { XmlPage xmlPage = wc.goToXml(\"whoAmI/api/xml\"); assertThat(xmlPage, hasXPath(\"//name\", is(\"admin\"))); assertThat(xmlPage, hasXPath(\"//anonymous\", is(\"false\"))); assertThat(xmlPage, hasXPath(\"//authenticated\", is(\"true\"))); assertThat(xmlPage, hasXPath(\"//authority\", is(\"authenticated\")));",
        "label":0
    },
    {
        "ins1CurCode":"  final Map<ByteBuffer, byte[]> expected = new HashMap<>(); final BytesToBytesMap map = new BytesToBytesMap(taskMemoryManager, size, PAGE_SIZE_BYTES);",
        "ins1PreCode":"  final Map<ByteBuffer, byte[]> expected = new HashMap<ByteBuffer, byte[]>(); final BytesToBytesMap map = new BytesToBytesMap(taskMemoryManager, size, PAGE_SIZE_BYTES);",
        "ins2PreCode":"  final Map<ByteBuffer, byte[]> expected = new HashMap<ByteBuffer, byte[]>(); try {",
        "label":1
    },
    {
        "ins1CurCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot<String> subplot1 = plot.getSubplots().get(0); NumberAxis xAxis = (NumberAxis) subplot1.getDomainAxis();",
        "ins1PreCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = plot.getSubplots().get(0); NumberAxis xAxis = (NumberAxis) subplot1.getDomainAxis();",
        "ins2PreCode":"public void testNotification() { CombinedRangeCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero()); assertEquals(1, this.events.size());   BufferedImage image = new BufferedImage(200, 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.events.clear(); chart.draw(g2, new Rectangle2D.Double(0.0, 0.0, 200.0, 100.0)); assertTrue(this.events.isEmpty());",
        "label":0
    },
    {
        "ins1CurCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<User> users = sqlSession.selectList(\"select\"); Assertions.assertTrue(users.size() == 2); }",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<User> users = sqlSession.selectList(\"selectIdentity\"); Assert.assertTrue(users.size() == 2); }",
        "label":1
    },
    {
        "ins1CurCode":"public void autoConfiguredExternalDataSourceIsNotShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext( \"org.postgresql.Driver\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class)); Statement statement = configureDataSourceBehavior(",
        "ins1PreCode":"public void autoConfiguredExternalDataSourceIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.postgresql.Driver\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior(",
        "ins2PreCode":"public void h2ServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior(",
        "label":1
    },
    {
        "ins1CurCode":"public String extendedToString() { StringBuilder buffer = new StringBuilder( 256 ); ",
        "ins1PreCode":"public String extendedToString() { StringBuilder buffer = new StringBuilder(); ",
        "ins2PreCode":"public String extendedToString() { StringBuilder buffer = new StringBuilder(); ",
        "label":1
    },
    {
        "ins1CurCode":"private void createHandlerTab(final NetworkHandlerDescriptor descriptor) { IObjectPropertyConfigurator<DBWHandlerConfiguration> configurator; try { String implName = descriptor.getHandlerType().getImplName(); UIPropertyConfiguratorDescriptor configDescriptor = UIPropertyConfiguratorRegistry.getInstance().getDescriptor(implName); if (configDescriptor == null) { return; } configurator = configDescriptor.createConfigurator(); } catch (DBException e) { log.error(\"Can't create network configurator '\" + descriptor.getId() + \"'\", e); return; } allHandlers.add(descriptor);  TabItem tabItem = new TabItem(handlersFolder, SWT.NONE); tabItem.setText(descriptor.getLabel()); tabItem.setToolTipText(descriptor.getDescription()); tabItem.setData(descriptor);  Composite composite = new Composite(handlersFolder, SWT.NONE); tabItem.setControl(composite); composite.setLayout(new GridLayout(1, false)); composite.setLayoutData(new GridData(GridData.FILL_BOTH));  final Button useHandlerCheck = UIUtils.createCheckbox(composite, NLS.bind(CoreMessages.dialog_tunnel_checkbox_use_handler, descriptor.getLabel()), false); useHandlerCheck.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { if (selectedProfile == null) { useHandlerCheck.setSelection(false); UIUtils.showMessageBox(getShell(), \"No profile\", \"Select existing profile or create a new one\", SWT.ICON_INFORMATION); return; } HandlerBlock handlerBlock = configurations.get(descriptor); DBWHandlerConfiguration handlerConfiguration = handlerBlock.loadedConfigs.get(selectedProfile); if (handlerConfiguration == null) { handlerConfiguration = new DBWHandlerConfiguration(descriptor, null); handlerBlock.loadedConfigs.put(selectedProfile, handlerConfiguration); } handlerConfiguration.setEnabled(useHandlerCheck.getSelection()); enableHandlerContent(descriptor); } }); Composite handlerComposite = UIUtils.createPlaceholder(composite, 1); configurations.put(descriptor, new HandlerBlock(configurator, handlerComposite, useHandlerCheck, tabItem));  handlerComposite.setLayoutData(new GridData(GridData.FILL_BOTH));  configurator.createControl(handlerComposite);  enableHandlerContent(descriptor);",
        "ins1PreCode":"private void createHandlerTab(final NetworkHandlerDescriptor descriptor) { IObjectPropertyConfigurator<DBWHandlerConfiguration> configurator; try { String implName = descriptor.getHandlerType().getImplName(); UIPropertyConfiguratorDescriptor configDescriptor = UIPropertyConfiguratorRegistry.getInstance().getDescriptor(implName); if (configDescriptor == null) { return; } configurator = configDescriptor.createConfigurator(); } catch (DBException e) { log.error(\"Can't create network configurator '\" + descriptor.getId() + \"'\", e); return; } allHandlers.add(descriptor);  TabItem tabItem = new TabItem(handlersFolder, SWT.NONE); tabItem.setText(descriptor.getLabel()); tabItem.setToolTipText(descriptor.getDescription()); tabItem.setData(descriptor);  Composite composite = new Composite(handlersFolder, SWT.NONE); tabItem.setControl(composite); composite.setLayout(new GridLayout(1, false)); composite.setLayoutData(new GridData(GridData.FILL_BOTH));  final Button useHandlerCheck = UIUtils.createCheckbox(composite, NLS.bind(CoreMessages.dialog_tunnel_checkbox_use_handler, descriptor.getLabel()), false); useHandlerCheck.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { if (selectedProfile == null) { useHandlerCheck.setSelection(false); UIUtils.showMessageBox(getShell(), \"No profile\", \"Select existing profile or create a new one\", SWT.ICON_INFORMATION); return; } HandlerBlock handlerBlock = configurations.get(descriptor); DBWHandlerConfiguration handlerConfiguration = handlerBlock.loadedConfigs.get(selectedProfile); if (handlerConfiguration == null) { handlerConfiguration = new DBWHandlerConfiguration(descriptor, null); handlerBlock.loadedConfigs.put(selectedProfile, handlerConfiguration); } handlerConfiguration.setEnabled(useHandlerCheck.getSelection()); enableHandlerContent(descriptor); } }); Composite handlerComposite = UIUtils.createPlaceholder(composite, 1); configurations.put(descriptor, new HandlerBlock(configurator, handlerComposite, useHandlerCheck, tabItem));  handlerComposite.setLayoutData(new GridData(GridData.FILL_BOTH));  enableHandlerContent(descriptor);  configurator.createControl(handlerComposite);",
        "ins2PreCode":"private void createHandlerTab(final NetworkHandlerDescriptor descriptor) throws DBException { IObjectPropertyConfigurator<DBWHandlerConfiguration> configurator; try { String implName = descriptor.getHandlerType().getImplName(); UIPropertyConfiguratorDescriptor configDescriptor = UIPropertyConfiguratorRegistry.getInstance().getDescriptor(implName); if (configDescriptor == null) { return; } configurator = configDescriptor.createConfigurator(); } catch (DBException e) { log.error(\"Can't create network configurator '\" + descriptor.getId() + \"'\", e); return; }  TabItem tabItem = new TabItem(handlersFolder, SWT.NONE); tabItem.setText(descriptor.getLabel()); tabItem.setToolTipText(descriptor.getDescription());  Composite composite = new Composite(handlersFolder, SWT.NONE); tabItem.setControl(composite); composite.setLayout(new GridLayout(1, false)); composite.setLayoutData(new GridData(GridData.FILL_BOTH));  final Button useHandlerCheck = UIUtils.createCheckbox(composite, NLS.bind(CoreMessages.dialog_tunnel_checkbox_use_handler, descriptor.getLabel()), false); useHandlerCheck.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { HandlerBlock handlerBlock = configurations.get(descriptor); DBWHandlerConfiguration handlerConfiguration = handlerBlock.loadedConfigs.get(wizard.getPageSettings().getActiveDataSource().getId()); handlerConfiguration.setEnabled(useHandlerCheck.getSelection()); enableHandlerContent(descriptor); } }); Composite handlerComposite = UIUtils.createPlaceholder(composite, 1); configurations.put(descriptor, new HandlerBlock(configurator, handlerComposite, useHandlerCheck, tabItem));  handlerComposite.setLayoutData(new GridData(GridData.FILL_BOTH));  configurator.createControl(handlerComposite);",
        "label":0
    },
    {
        "ins1CurCode":"public boolean removeFirstOccurrence(final Object o) { if (o == null) {",
        "ins1PreCode":"public boolean removeFirstOccurrence(Object o) { if (o == null) {",
        "ins2PreCode":"public boolean removeLastOccurrence(Object o) { if (o == null) {",
        "label":1
    },
    {
        "ins1CurCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1,",
        "ins1PreCode":"public void heap() { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1,",
        "ins2PreCode":"public void offHeap() { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1,",
        "label":1
    },
    {
        "ins1CurCode":"void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "ins1PreCode":"public void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "ins2PreCode":"public void shutdownWhenShutdownOperationIsNoneDoesNothing() { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "label":1
    },
    {
        "ins1CurCode":"void shouldSelectOneAuthor() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1PreCode":"public void shouldSelectOneAuthor() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins2PreCode":"public void shouldSelectOneImmutableAuthor() { try (SqlSession session = sqlMapper.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testRemoveAtFrontWhenSizeEqualsCapacity() { v = new VectorSet<>(3, 1); v.add(O);",
        "ins1PreCode":"public void testRemoveAtFrontWhenSizeEqualsCapacity() { v = new VectorSet(3, 1); v.add(O);",
        "ins2PreCode":"public void testRemoveInMiddleWhenSizeEqualsCapacity() { v = new VectorSet(3, 1); Object a = new Object();",
        "label":1
    },
    {
        "ins1CurCode":" try { it = Objects.requireNonNull(other.iterator(), \"The iterator returned by other is null\"); } catch (Throwable e) {",
        "ins1PreCode":" try { it = ObjectHelper.requireNonNull(other.iterator(), \"The iterator returned by other is null\"); } catch (Throwable e) {",
        "ins2PreCode":" try { it = ObjectHelper.requireNonNull(other.iterator(), \"The iterator returned by other is null\"); } catch (Throwable e) {",
        "label":1
    },
    {
        "ins1CurCode":"public void addNode(Object node) { LOG.log(Level.FINE, \"adding class node!!\"); if (!canAddNode(node)) {",
        "ins1PreCode":"public void addNode(Object node) { LOG.debug(\"adding class node!!\"); if (!canAddNode(node)) {",
        "ins2PreCode":"public void addNode(Object node) { LOG.debug(\"adding MClassifierRole node!!\"); if (!canAddNode(node)) {",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Item.READ, Item.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"never_created\", \"aProject1\", \"aProject2\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"never_created\", \"aProject1\", \"aProject2\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"aProject1\", \"never_created\", \"aProject2\");",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerEmitterNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"void completeBeginningOfFirstNameReturnsNameWithVon() { BibEntry entry = new BibEntry(); entry.setField(StandardField.AUTHOR, \"Eric von Hippel\"); database.insertEntry(entry); Author author = new Author(\"Eric\", \"E.\", \"von\", \"Hippel\", \"\");  Collection<Author> result = autoCompleter.provideSuggestions(getRequest((\"Eric\"))); assertEquals(Collections.singletonList(author), result);",
        "ins1PreCode":"public void completeBeginningOfFirstNameReturnsNameWithVon() { BibEntry entry = new BibEntry(); entry.setField(StandardField.AUTHOR, \"Eric von Hippel\"); autoCompleter.indexEntry(entry); Author author = new Author(\"Eric\", \"E.\", \"von\", \"Hippel\", \"\");  Collection<Author> result = autoCompleter.call(getRequest((\"Eric\"))); assertEquals(Collections.singletonList(author), result);",
        "ins2PreCode":"public void completeVonReturnsName() { BibEntry entry = new BibEntry(); entry.setField(StandardField.AUTHOR, \"Eric von Hippel\"); autoCompleter.indexEntry(entry); Author author = new Author(\"Eric\", \"E.\", \"von\", \"Hippel\", \"\");  Collection<Author> result = autoCompleter.call(getRequest((\"von\"))); assertEquals(Collections.singletonList(author), result);",
        "label":1
    },
    {
        "ins1CurCode":"Dataset<Row> output = vectorSlicer.transform(dataset);  for (Row r : output.select(\"userFeatures\", \"features\").takeAsList(2)) { Vector features = r.getAs(1);",
        "ins1PreCode":"Dataset<Row> output = vectorSlicer.transform(dataset);  for (Row r : output.select(\"userFeatures\", \"features\").takeRows(2)) { Vector features = r.getAs(1);",
        "ins2PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaVectorSlicerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Attribute[] attrs = new Attribute[]{ NumericAttribute.defaultAttr().withName(\"f1\"), NumericAttribute.defaultAttr().withName(\"f2\"), NumericAttribute.defaultAttr().withName(\"f3\") }; AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);  JavaRDD<Row> jrdd = jsc.parallelize(Lists.newArrayList( RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})), RowFactory.create(Vectors.dense(-2.0, 2.3, 0.0)) ));  Dataset<Row> dataset = jsql.createDataFrame(jrdd, (new StructType()).add(group.toStructField()));  VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\");  vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});   Dataset<Row> output = vectorSlicer.transform(dataset);  System.out.println(output.select(\"userFeatures\", \"features\").first());  jsc.stop();",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(@NonNull Subscriber<@NonNull ? super T> s) { AsyncSubscription<T> as = new AsyncSubscription<>(s, this);",
        "ins1PreCode":"protected void subscribeActual(Subscriber<? super T> s) { AsyncSubscription<T> as = new AsyncSubscription<>(s, this);",
        "ins2PreCode":"protected void subscribeActual(Observer<? super T> observer) { AsyncDisposable<T> as = new AsyncDisposable<>(observer, this); observer.onSubscribe(as); if (add(as)) { if (as.isDisposed()) { remove(as); } } else { Throwable ex = error; if (ex != null) { observer.onError(ex); } else { T v = value; if (v != null) { as.complete(v); } else { as.onComplete(); } } }",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = d;\"));",
        "ins1PreCode":"assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = BigInteger.valueOf(0); double b = d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = d;\"));",
        "ins2PreCode":"public void testdefTodoubleExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; double b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; double b = (double)d;\")); assertEquals((double)0, exec(\"def d = (byte)0; double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = (short)0; double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = (char)0; double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = 0; double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = (long)0; double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = (float)0; double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = (double)0; double b = (double)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Boolean.valueOf(true); double b = d;\")); assertEquals((double)0, exec(\"def d = Byte.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Short.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Character.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Integer.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Long.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = (double)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = (double)d;\"));",
        "label":0
    },
    {
        "ins1CurCode":" HudsonPrivateSecurityRealm realm = new HudsonPrivateSecurityRealm(false, false, null); TokenBasedRememberMeServices2 tokenService = (TokenBasedRememberMeServices2) realm.getSecurityComponents().rememberMe2; j.jenkins.setSecurityRealm(realm);",
        "ins1PreCode":" HudsonPrivateSecurityRealm realm = new HudsonPrivateSecurityRealm(false, false, null); TokenBasedRememberMeServices2 tokenService = (TokenBasedRememberMeServices2) realm.getSecurityComponents().rememberMe; j.jenkins.setSecurityRealm(realm);",
        "ins2PreCode":" HudsonPrivateSecurityRealm realm = new HudsonPrivateSecurityRealm(false, false, null); TokenBasedRememberMeServices2 tokenService = (TokenBasedRememberMeServices2) realm.getSecurityComponents().rememberMe; j.jenkins.setSecurityRealm(realm);",
        "label":1
    },
    {
        "ins1CurCode":"{ Page page = wc.goTo(p.getUrl() + \"ws/to_secrets1/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_NOT_FOUND)); } { Page page = wc.goTo(p.getUrl() + \"ws/to_secrets_goal1/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_NOT_FOUND)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); String workspaceContent = page.getWebResponse().getContentAsString(); assertThat(workspaceContent, allOf( not(containsString(\"to_secrets1\")), not(containsString(\"to_secrets_goal1\")), not(containsString(\"to_secrets2\")), not(containsString(\"to_secrets_goal2\")) )); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_NOT_FOUND)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2/master.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_NOT_FOUND)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets_goal2/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_NOT_FOUND)); }   {  Page page = wc.goTo(p.getUrl() + \"ws/**/*.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); String workspaceContent = page.getWebResponse().getContentAsString(); assertThat(workspaceContent, allOf( not(containsString(\"master.key\")), containsString(\"public1.key\"), containsString(\"public2.key\") )); }   { Page zipPage = wc.goTo(p.getUrl() + \"ws/*zip*/ws.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( \"intermediateFolder/public2.key\", \"public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"public2.key\")); }",
        "ins1PreCode":"containsString(\"public1.key\"), containsString(\"intermediateFolder\"), containsString(\"to_secrets1\"), containsString(\"to_secrets_goal1\"), not(containsString(\"to_secrets2\")), not(containsString(\"to_secrets_goal2\")) )); } { Page page = wc.goTo(p.getUrl() + \"ws/to_secrets1/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/to_secrets_goal1/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); String workspaceContent = page.getWebResponse().getContentAsString(); assertThat(workspaceContent, allOf( not(containsString(\"to_secrets1\")), not(containsString(\"to_secrets_goal1\")), containsString(\"to_secrets2\"), containsString(\"to_secrets_goal2\") )); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2/master.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets_goal2/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); }   {  Page page = wc.goTo(p.getUrl() + \"ws/**/*.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); String workspaceContent = page.getWebResponse().getContentAsString(); assertThat(workspaceContent, allOf( not(containsString(\"master.key\")), containsString(\"public1.key\"), containsString(\"public2.key\") )); }   { Page zipPage = wc.goTo(p.getUrl() + \"ws/*zip*/ws.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( p.getName() + \"/intermediateFolder/public2.key\", p.getName() + \"/public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"intermediateFolder/public2.key\")); }",
        "ins2PreCode":"containsString(\"public1.key\"), containsString(\"intermediateFolder\"), containsString(\"to_secrets1j\"), containsString(\"to_secrets1s\"), containsString(\"to_secrets_goal1\"), not(containsString(\"to_secrets2\")), not(containsString(\"to_secrets_goal2\")) )); } { Page page = wc.goTo(p.getUrl() + \"ws/to_secrets1s/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/to_secrets1j/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/to_secrets_goal1/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); String workspaceContent = page.getWebResponse().getContentAsString(); assertThat(workspaceContent, allOf( not(containsString(\"to_secrets1\")), not(containsString(\"to_secrets_goal1\")), containsString(\"to_secrets2s\"), containsString(\"to_secrets2j\"), containsString(\"to_secrets_goal2\") )); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2s/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2j/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2s/master.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets2j/master.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); } { Page page = wc.goTo(p.getUrl() + \"ws/intermediateFolder/to_secrets_goal2/\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_FORBIDDEN)); }   {  Page page = wc.goTo(p.getUrl() + \"ws/**/*.key\", null); assertThat(page.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); String workspaceContent = page.getWebResponse().getContentAsString(); assertThat(workspaceContent, allOf( not(containsString(\"master.key\")), containsString(\"public1.key\"), containsString(\"public2.key\"), containsString(\"intermediateFolder\"), not(containsString(\"otherFolder\")), not(containsString(\"to_secrets3j\")), not(containsString(\"to_secrets3s\")), not(containsString(\"to_secrets2j\")), not(containsString(\"to_secrets2s\")), not(containsString(\"to_secrets1j\")), not(containsString(\"to_secrets1s\")) )); }   { Page zipPage = wc.goTo(p.getUrl() + \"ws/*zip*/ws.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( p.getName() + \"/intermediateFolder/public2.key\", p.getName() + \"/public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"intermediateFolder/public2.key\")); }",
        "label":0
    },
    {
        "ins1CurCode":"wlJar = new JarFile(weblogicJarFile);  Map<String, JarEntry> replaceEntries = new HashMap<>();   Map<String, JarEntry> genericEntries = genericJar.stream() .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b));  Map<String, JarEntry> wlEntries = wlJar.stream().collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b));   genericLoader = getClassLoaderFromJar(genericJarFile);  for (String filepath : genericEntries.keySet()) { if (!wlEntries.containsKey(filepath)) {  log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; }   JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath);  if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) { ",
        "ins1PreCode":"wlJar = new JarFile(weblogicJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath);  if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) { ",
        "ins2PreCode":"  Hashtable<String, JarEntry> genericEntries = StreamUtils.enumerationAsStream(genericJar.entries()) .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b, Hashtable::new));   Hashtable<String, JarEntry> wasEntries = StreamUtils.enumerationAsStream(wasJar.entries()) .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));   genericLoader = getClassLoaderFromJar(genericJarFile);  Hashtable<String, JarEntry> replaceEntries = new Hashtable<>(); for (String filepath : genericEntries.keySet()) {",
        "label":0
    },
    {
        "ins1CurCode":"6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtilities.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   d1.add(new Date(2L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertFalse(d1.equals(d2));",
        "label":0
    },
    {
        "ins1CurCode":" File appDir = new File(\"test/webapp-3.0\"); ",
        "ins1PreCode":" File appDir = new File(\"test/webapp\"); ",
        "ins2PreCode":"public void testServlet25NoEL() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-2.5\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/el-as-literal.jsp\");  String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "label":0
    },
    {
        "ins1CurCode":"while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(QUARTER_SECOND); }",
        "ins1PreCode":"while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(250); }",
        "ins2PreCode":"public void waitForString(String s, Integer timeout) { InputStream is = this.getInputStream(); try { StringBuffer sb = new StringBuffer(); if (timeout == null || timeout.intValue() == 0) { while (sb.toString().indexOf(s) == -1) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (sb.toString().indexOf(s) == -1) { while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(250); } if (is.available() == 0) { throw new BuildException( \"Response timed-out waiting for \\\"\" + s + '\\\"', getLocation()); } sb.append((char) is.read()); } } log(sb.toString(), Project.MSG_INFO); } catch (BuildException be) { throw be; } catch (Exception e) { throw new BuildException(e, getLocation()); }",
        "label":0
    },
    {
        "ins1CurCode":" when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.shouldAddModificationDate()).thenReturn(includeTimestamp);  bibEntry.setField(StandardField.MODIFICATIONDATE, baseDate);  assertEquals(Optional.of(baseDate), bibEntry.getField(StandardField.MODIFICATIONDATE), \"Initial timestamp not set correctly\");  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(new UnknownField(\"test\"), \"some value\");  assertEquals(Optional.of(newDate), bibEntry.getField(StandardField.MODIFICATIONDATE), \"Timestamp not set correctly after entry changed\");",
        "ins1PreCode":"void updateTimestampEnabled() { final Field timestampField = StandardField.TIMESTAMP; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = true;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.shouldIncludeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\");  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(new UnknownField(\"test\"), \"some value\");  assertEquals(Optional.of(newDate), bibEntry.getField(timestampField), \"Timestamp not set correctly after entry changed\");",
        "ins2PreCode":"void updateTimestampDisabled() { final Field timestampField = StandardField.TIMESTAMP; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = false;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.shouldIncludeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\");  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(new UnknownField(\"test\"), \"some value\");  assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"New timestamp set after entry changed even though updates were disabled\");",
        "label":1
    },
    {
        "ins1CurCode":"assertSame(sepLoader, sepFrqUserC.getClassLoader());  Callable<?> sepFrqUser = (Callable<?>) sepFrqUserC.getDeclaredConstructor().newInstance(); WeakReference<?> finalizableWeakReference = (WeakReference<?>) sepFrqUser.call();",
        "ins1PreCode":"assertSame(sepLoader, sepFrqUserC.getClassLoader());  Callable<?> sepFrqUser = (Callable<?>) sepFrqUserC.newInstance(); WeakReference<?> finalizableWeakReference = (WeakReference<?>) sepFrqUser.call();",
        "ins2PreCode":"assertSame(sepLoader, sepFrqUserC.getClassLoader());  Callable<?> sepFrqUser = (Callable<?>) sepFrqUserC.newInstance(); WeakReference<?> finalizableWeakReference = (WeakReference<?>) sepFrqUser.call();",
        "label":1
    },
    {
        "ins1CurCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); ",
        "ins2PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); set.add(new Medra()); return set;",
        "ins1PreCode":"set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); return set;",
        "ins2PreCode":"public static SortedSet<EntryBasedFetcher> getEntryBasedFetchers(ImportFormatPreferences importFormatPreferences) { SortedSet<EntryBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new DoiFetcher(importFormatPreferences)); set.add(new IsbnFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); return set;",
        "label":0
    },
    {
        "ins1CurCode":"private XYDataset createDataset2() {  XYSeries<String> series2 = new XYSeries<>(\"Series 3\");  series2.add(10.0, 16853.2); series2.add(20.0, 19642.3); series2.add(30.0, 18253.5); series2.add(40.0, 15352.3); series2.add(50.0, 13532.0); series2.add(100.0, 12635.3); series2.add(110.0, 13998.2); series2.add(120.0, 11943.2); series2.add(130.0, 16943.9); series2.add(140.0, 17843.2); series2.add(150.0, 16495.3); series2.add(160.0, 17943.6); series2.add(170.0, 18500.7); series2.add(180.0, 19595.9);  return new XYSeriesCollection<>(series2); ",
        "ins1PreCode":"private XYDataset createDataset2() {  XYSeries series2 = new XYSeries(\"Series 3\");  series2.add(10.0, 16853.2); series2.add(20.0, 19642.3); series2.add(30.0, 18253.5); series2.add(40.0, 15352.3); series2.add(50.0, 13532.0); series2.add(100.0, 12635.3); series2.add(110.0, 13998.2); series2.add(120.0, 11943.2); series2.add(130.0, 16943.9); series2.add(140.0, 17843.2); series2.add(150.0, 16495.3); series2.add(160.0, 17943.6); series2.add(170.0, 18500.7); series2.add(180.0, 19595.9);  return new XYSeriesCollection(series2); ",
        "ins2PreCode":"  XYSeries series2 = new XYSeries(\"Series 3\");  series2.add(10.0, 16853.2); series2.add(20.0, 19642.3); series2.add(30.0, 18253.5); series2.add(40.0, 15352.3); series2.add(50.0, 13532.0); series2.add(100.0, 12635.3); series2.add(110.0, 13998.2); series2.add(120.0, 11943.2); series2.add(130.0, 16943.9); series2.add(140.0, 17843.2); series2.add(150.0, 16495.3); series2.add(160.0, 17943.6); series2.add(170.0, 18500.7); series2.add(180.0, 19595.9);  return new XYSeriesCollection(series2); ",
        "label":1
    },
    {
        "ins1CurCode":"flowablePlain = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) { return Flowable.just(v); } });  flowableConvert = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) { return Single.just(v).toFlowable(); } });  flowableDedicated = source.flatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) { return Single.just(v);",
        "ins1PreCode":"flowablePlain = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.just(v); } });  flowableConvert = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toFlowable(); } });  flowableDedicated = source.flatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v);",
        "ins2PreCode":"flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.just(v); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toFlowable(); } });  flowableDedicated = source.switchMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v);",
        "label":1
    },
    {
        "ins1CurCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis();",
        "ins1PreCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = (XYPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis();",
        "ins2PreCode":"public void testNotification() { CombinedDomainCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero()); assertEquals(1, this.events.size());   BufferedImage image = new BufferedImage(200, 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.events.clear(); chart.draw(g2, new Rectangle2D.Double(0.0, 0.0, 200.0, 100.0)); assertTrue(this.events.isEmpty());",
        "label":0
    },
    {
        "ins1CurCode":"+ \"  booktitle = {Hawaii International Conference On System Sciences (HICSS)},\" + \"\\n\" + \"  year = {2005},\" + \"\\n\" + \"  owner = {oezbek},\" + \"\\n\" + \"  timestamp = {2006.05.29},\" + \"\\n\" + \"  url = {http://james.howison.name/publications.html}\" + \"\\n\" + \"}))\")); ",
        "ins1PreCode":"+ \"  booktitle = {Hawaii International Conference On System Sciences (HICSS)},\" + \"\\n\" + \"  year = {2005},\" + \"\\n\" + \"  owner = {oezbek},\" + \"\\n\" + \"  timestamp = {2006.05.29},\" + \"\\n\" + \"  url = {http://james.howison.name/publications.html}\" + \"\\n\" + \"}))\"), importFormatPreferences, fileMonitor); ",
        "ins2PreCode":"+ \"  booktitle = {Hawaii International Conference On System Sciences (HICSS)},\" + \"\\n\" + \"  year = {2005},\" + \"\\n\" + \"  owner = {oezbek},\" + \"\\n\" + \"  timestamp = {2006.05.29},\" + \"\\n\" + \"  url = {http://james.howison.name/publications.html}\" + \"\\n\" + \"}))\"), importFormatPreferences, fileMonitor); ",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final GenericTableColumn column = command.getObject();  String prefix = \"ALTER TABLE \" + DBUtils.getObjectFullName(column.getTable(), DBPEvaluationContext.DDL) + \" ALTER COLUMN \" + DBUtils.getQuotedIdentifier(column) + \" \"; String typeClause = column.getFullTypeName(); if (command.getProperty(DBConstants.PROP_ID_TYPE_NAME) != null || command.getProperty(\"maxLength\") != null || command.getProperty(\"precision\") != null || command.getProperty(\"scale\") != null) { actionList.add(new SQLDatabasePersistAction(\"Set column type\", prefix + \"SET DATA TYPE \" + typeClause)); } if (command.getProperty(DBConstants.PROP_ID_REQUIRED) != null) { actionList.add(new SQLDatabasePersistAction(\"Set column nullability\", prefix + (column.isRequired() ? \"SET\" : \"DROP\") + \" NOT NULL\")); } if (command.getProperty(DBConstants.PROP_ID_DEFAULT_VALUE) != null) { if (CommonUtils.isEmpty(column.getDefaultValue())) { actionList.add(new SQLDatabasePersistAction(\"Drop column default\", prefix + \"DROP DEFAULT\")); } else { actionList.add(new SQLDatabasePersistAction(\"Set column default\", prefix + \"SET DEFAULT \" + column.getDefaultValue())); } } super.addObjectModifyActions(monitor, actionList, command, options);",
        "label":0
    },
    {
        "ins1CurCode":"public void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception { Map<String, String> KEYS = Collections.singletonMap(\"valid-key\", INVALID_KEY); given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(KEYS)); given(this.securityService.getUaaUrl()) .willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\",\\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier .create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .consumeErrorWith((ex) -> { assertThat(ex).isExactlyInstanceOf( CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) ex).getReason()) .isEqualTo(Reason.INVALID_SIGNATURE); }).verify();",
        "ins1PreCode":"public void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception { Map<String, String> KEYS = Collections .singletonMap(\"valid-key\", INVALID_KEY); given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\",\\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier.create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))).consumeErrorWith(throwable -> { assertThat(throwable).isExactlyInstanceOf(CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) throwable) .getReason()).isEqualTo(Reason.INVALID_SIGNATURE); }).verify();",
        "ins2PreCode":"throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"HS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier.create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))).consumeErrorWith(throwable -> { assertThat(throwable).isExactlyInstanceOf(CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) throwable) .getReason()).isEqualTo(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM); }).verify();",
        "label":1
    },
    {
        "ins1CurCode":"boolean result = Os.isVersion( test );  return reverse ? !result : result;",
        "ins1PreCode":"boolean result = Os.isVersion( test );  if ( reverse ) { return !result; } else { return result; }",
        "ins2PreCode":"boolean result = Os.isArch( test );  if ( reverse ) { return !result; } else { return result; }",
        "label":1
    },
    {
        "ins1CurCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>(); ",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\")); ",
        "ins1PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "ins2PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"FileOutputStream fos1 = new FileOutputStream(file1);  try (FileChannel channel1 = fos1.getChannel()) { ByteBuffer bbuf = ByteBuffer.wrap(content1);",
        "ins1PreCode":"FileOutputStream fos1 = new FileOutputStream(file1);  FileChannel channel1 = fos1.getChannel(); ByteBuffer bbuf = ByteBuffer.wrap(content1); channel1.write(bbuf); channel1.close(); JavaPairRDD<String, PortableDataStream> readRDD = sc.binaryFiles(tempDirName, 3);",
        "ins2PreCode":"FileOutputStream fos1 = new FileOutputStream(file1);  FileChannel channel1 = fos1.getChannel(); ByteBuffer bbuf = ByteBuffer.wrap(content1); channel1.write(bbuf); channel1.close(); ",
        "label":1
    },
    {
        "ins1CurCode":"@Override public Maybe<Integer> apply(Maybe<Integer> m) throws Exception { return m.flatMapSingle(new Function<Integer, SingleSource<Integer>>() { @Override",
        "ins1PreCode":"@Override public Maybe<Integer> apply(Maybe<Integer> m) throws Exception { return m.flatMapSingleElement(new Function<Integer, SingleSource<Integer>>() { @Override",
        "ins2PreCode":"public void doubleOnSubscribe() { TestHelper.checkDoubleOnSubscribeMaybe(new Function<Maybe<Integer>, Maybe<Integer>>() { @Override public Maybe<Integer> apply(Maybe<Integer> m) throws Exception { return m.concatMapSingle(new Function<Integer, SingleSource<Integer>>() { @Override public SingleSource<Integer> apply(final Integer integer) throws Exception { return Single.just(2); } }); } });",
        "label":0
    },
    {
        "ins1CurCode":"public void parse(Object modelElement, String text) { try { parseAssociationName(modelElement, text); } catch (ParseException pe) {",
        "ins1PreCode":"public void parse(Object modelElement, String text) { try { NotationUtilityUml.parseModelElement(modelElement, text); } catch (ParseException pe) {",
        "ins2PreCode":"public void parse(Object modelElement, String text) { try { parseClassifierRole(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.classifierrole\"; Object[] args = {pe.getLocalizedMessage(), Integer.valueOf(pe.getErrorOffset()), }; ArgoEventPump.fireEvent(new ArgoHelpEvent( ArgoEventTypes.HELP_CHANGED, this, Translator.messageFormat(msg, args))); }",
        "label":0
    },
    {
        "ins1CurCode":"public void windowUnsubscribeNonOverlapping() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"public void windowUnsubscribeNonOverlapping() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"public void windowUnsubscribeOverlapping() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final AtomicInteger count = new AtomicInteger();",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, true); ",
        "ins2PreCode":"TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true); ",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetFollowSymlinksFalse() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject()); dsDestination.scan(); compareFiles(dsDestination, new String[] {}, new String[] {});",
        "ins1PreCode":"public void testGetFollowSymlinksFalse() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject()); dsDestination.scan(); compareFiles(dsDestination, new String[] {}, new String[] {});",
        "ins2PreCode":"public void testGetFollowSymlinksTrue() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject());",
        "label":0
    },
    {
        "ins1CurCode":"void pomDependencyResolutionViaExt() { Map<String, Object> args = new HashMap<>();",
        "ins1PreCode":"public void pomDependencyResolutionViaExt() { Map<String, Object> args = new HashMap<>();",
        "ins2PreCode":"public void resolutionWithClassifier() { Map<String, Object> args = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"Author updated; try { original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(\"jim@ibatis.apache.org\", updated.getEmail());",
        "ins1PreCode":"Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(\"jim@ibatis.apache.org\", updated.getEmail());",
        "ins2PreCode":"Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "label":1
    },
    {
        "ins1CurCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; }",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders();",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; } ListSet offs = i.getOffenders(); UMLDeploymentDiagram dd = (UMLDeploymentDiagram) offs.get(0);  ListSet newOffs = computeOffenders(dd); boolean res = offs.equals(newOffs); return res;",
        "label":0
    },
    {
        "ins1CurCode":"throws IOException { doWithBlockedPort((port) -> { assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> { AbstractServletWebServerFactory factory = getFactory(); factory.setPort(port); AbstractServletWebServerFactoryTests.this.webServer = factory .getWebServer(); AbstractServletWebServerFactoryTests.this.webServer.start(); }).satisfies((ex) -> handleExceptionCausedByBlockedPort(ex, port)); });",
        "ins1PreCode":"throws IOException { doWithBlockedPort((port) -> { try { AbstractServletWebServerFactory factory = getFactory(); factory.setPort(port); AbstractServletWebServerFactoryTests.this.webServer = factory .getWebServer(); AbstractServletWebServerFactoryTests.this.webServer.start(); fail(); } catch (RuntimeException ex) { handleExceptionCausedByBlockedPort(ex, port); }",
        "ins2PreCode":"throws IOException { doWithBlockedPort((port) -> { try { AbstractServletWebServerFactory factory = getFactory(); addConnector(port, factory); AbstractServletWebServerFactoryTests.this.webServer = factory .getWebServer(); AbstractServletWebServerFactoryTests.this.webServer.start(); fail(); } catch (RuntimeException ex) { handleExceptionCausedByBlockedPort(ex, port); }",
        "label":1
    },
    {
        "ins1CurCode":"public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { Objects.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) {",
        "ins1PreCode":"public static boolean setOnce(AtomicReference<Disposable> upstream, Disposable next, Class<?> observer) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) {",
        "ins2PreCode":"public static boolean setOnce(AtomicReference<Subscription> upstream, Subscription next, Class<?> subscriber) { ObjectHelper.requireNonNull(next, \"next is null\"); if (!upstream.compareAndSet(null, next)) {",
        "label":1
    },
    {
        "ins1CurCode":"public void setUp() throws Exception { for (int i = 0; i < channels.length; i++) {",
        "ins1PreCode":"protected void setUp() throws Exception { super.setUp(); for (int i = 0; i < channels.length; i++) {",
        "ins2PreCode":"protected void setUp() throws Exception { super.setUp(); for (int i = 0; i < channels.length; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isTrue(); assertThat(excludes(filter, ExampleModule.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = (String)o;\"));",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = (String)o;\"));",
        "ins2PreCode":"public void testByteCasts() { exec(\"Byte o = Byte.valueOf((byte)0); Object n = o;\"); exec(\"Byte o = null; Object n = o;\"); exec(\"Byte o = Byte.valueOf((byte)0); Object n = (Object)o;\"); exec(\"Byte o = null; Object n = (Object)o;\");  exec(\"Byte o = Byte.valueOf((byte)0); Number n = o;\"); exec(\"Byte o = null; Number n = o;\"); exec(\"Byte o = Byte.valueOf((byte)0); Number n = (Number)o;\"); exec(\"Byte o = null; Number n = (Number)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; String n = (String)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); boolean b = (boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; boolean b = (boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); byte b = (byte)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; byte b = (byte)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = (short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); char b = (char)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = (char)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); int b = (int)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = (int)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); long b = (long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = (long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); float b = (float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = (float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); double b = (double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = (double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Boolean b = (Boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Boolean b = (Boolean)o;\"));  exec(\"Byte o = Byte.valueOf((byte)0); Byte b = o;\"); exec(\"Byte o = null; Byte b = o;\"); exec(\"Byte o = Byte.valueOf((byte)0); Byte b = (Byte)o;\"); exec(\"Byte o = null; Byte b = (Byte)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Short b = (Short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Short b = (Short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Character b = (Character)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Character b = (Character)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Integer b = (Integer)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Integer b = (Integer)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Long b = (Long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Long b = (Long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Float b = (Float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Float b = (Float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Double b = (Double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); ArrayList b = (ArrayList)o;\"));",
        "label":0
    },
    {
        "ins1CurCode":"boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metadata) throws IOException {  if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metadata); } else {",
        "ins1PreCode":"boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {  if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData); } else {",
        "ins2PreCode":"boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {  if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ChildrenToParentAggregator(name, factories, searchContext, children, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData); } else {",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":"Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins2PreCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(ObservableEmitter<Object> e) throws Exception { Disposable d = Disposable.empty(); e.setDisposable(d);",
        "ins1PreCode":"@Override public void subscribe(ObservableEmitter<Object> e) throws Exception { Disposable d = Disposables.empty(); e.setDisposable(d);",
        "ins2PreCode":"@Override public void subscribe(ObservableEmitter<Object> e) throws Exception { Disposable d = Disposables.empty(); e.setDisposable(d);",
        "label":1
    },
    {
        "ins1CurCode":"}  if (!isDisposed()) { o.subscribe(this);",
        "ins1PreCode":"}  o.subscribe(this);",
        "ins2PreCode":"}  o.subscribe(this);",
        "label":1
    },
    {
        "ins1CurCode":"public void testTarFileSet() throws IOException { buildRule.executeTarget(\"testTarFileSet\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"asf-logo.gif\");",
        "ins1PreCode":"public void testTarFileSet() throws IOException { executeTarget(\"testTarFileSet\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"asf-logo.gif\");",
        "ins2PreCode":"public void testRewriteZeroPermissions() throws IOException { executeTarget(\"rewriteZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(throwable).isInstanceOf(clazz); if (params.length == 1) { assertThat(throwable).hasMessageThat().isNull(); } else if (params.length == 2) { assertThat(throwable).hasMessageThat().isEmpty(); } else { assertThat(throwable) .hasMessageThat() .isEqualTo(Strings.lenientFormat(\"\", Arrays.copyOfRange(params, 2, params.length))); }",
        "ins1PreCode":"assertThat(throwable).isInstanceOf(clazz); if (params.length == 1) { assertThat(throwable).hasMessage(null); } else if (params.length == 2) { assertThat(throwable).hasMessage(\"\"); } else { assertThat(throwable) .hasMessage(Strings.lenientFormat(\"\", Arrays.copyOfRange(params, 2, params.length))); }",
        "ins2PreCode":"assertThat(throwable).isInstanceOf(clazz); if (params.length == 1) { assertThat(throwable).hasMessage(null); } else if (params.length == 2) { assertThat(throwable).hasMessage(\"\"); } else { assertThat(throwable) .hasMessage(Strings.lenientFormat(\"\", Arrays.copyOfRange(params, 2, params.length))); }",
        "label":1
    },
    {
        "ins1CurCode":"@Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), true, 2, ImmediateThinScheduler.INSTANCE); }",
        "ins1PreCode":"@Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE); }",
        "ins2PreCode":"public void badSourceDelayError() { TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() { @Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide())); } }, true, 1, 1, 1);",
        "label":0
    },
    {
        "ins1CurCode":"ByteChunk res = getUrl(\"http://localhost:\" + getPort());  Assert.assertTrue(res.toString().contains(\"<p><b>message</b> <u>\" + ErrorServlet.ERROR_TEXT + \"</u></p>\"));",
        "ins1PreCode":"ByteChunk res = getUrl(\"http://localhost:\" + getPort());  Assert.assertTrue(res.toString().contains(ErrorServlet.ERROR_TEXT));",
        "ins2PreCode":"private void pathParamTest(String path, String expected) throws Exception {  Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));  Tomcat.addServlet(ctx, \"servlet\", new PathParamServlet()); ctx.addServletMapping(\"/\", \"servlet\");  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + path); assertEquals(expected, res.toString());",
        "label":0
    },
    {
        "ins1CurCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer); ",
        "ins1PreCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer); ",
        "ins2PreCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer); ",
        "label":1
    },
    {
        "ins1CurCode":"public void multipleTerminals() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"public void multipleTerminals() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"public void multipleTerminals() { TestSubscriber<Integer> ts = TestSubscriber.create();  ts.onSubscribe(new BooleanSubscription());  ts.assertNotComplete();  ts.onComplete();  try { ts.assertNotComplete(); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  ts.assertComplete();  ts.onComplete();  try { ts.assertComplete(); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  try { ts.assertComplete(); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  try { ts.assertNotComplete(); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }",
        "label":0
    },
    {
        "ins1CurCode":"DataUtils.createNumberArray2D(starts), DataUtils.createNumberArray2D(ends)); d1.setStartValue(0, \"Category 2\", 99.9); assertEquals(99.9, d1.getStartValue(\"Series 1\", \"Category 2\"));  boolean pass = false; try { d1.setStartValue(-1, \"Category 2\", 99.9); } catch (IllegalArgumentException e) { pass = true; } assertTrue(pass);  pass = false; try { d1.setStartValue(2, \"Category 2\", 99.9); }",
        "ins1PreCode":"DataUtils.createNumberArray2D(starts), DataUtils.createNumberArray2D(ends)); d1.setStartValue(0, \"Category 2\", new Double(99.9)); assertEquals(new Double(99.9), d1.getStartValue(\"Series 1\", \"Category 2\"));  boolean pass = false; try { d1.setStartValue(-1, \"Category 2\", new Double(99.9)); } catch (IllegalArgumentException e) { pass = true; } assertTrue(pass);  pass = false; try { d1.setStartValue(2, \"Category 2\", new Double(99.9)); }",
        "ins2PreCode":"DataUtils.createNumberArray2D(starts), DataUtils.createNumberArray2D(ends)); d1.setEndValue(0, \"Category 2\", new Double(99.9)); assertEquals(new Double(99.9), d1.getEndValue(\"Series 1\", \"Category 2\"));  boolean pass = false; try { d1.setEndValue(-1, \"Category 2\", new Double(99.9)); } catch (IllegalArgumentException e) { pass = true; } assertTrue(pass);  pass = false; try { d1.setEndValue(2, \"Category 2\", new Double(99.9)); }",
        "label":1
    },
    {
        "ins1CurCode":"private List<XYDataset> getDatasetsMappedToDomainAxis(Integer axisIndex) { Objects.requireNonNull(axisIndex, \"axisIndex\"); List<XYDataset> result = new ArrayList<>(); for (Entry<Integer, XYDataset> entry : this.datasets.entrySet()) {",
        "ins1PreCode":"private List<XYDataset> getDatasetsMappedToDomainAxis(Integer axisIndex) { Args.nullNotPermitted(axisIndex, \"axisIndex\"); List<XYDataset> result = new ArrayList<XYDataset>(); for (Entry<Integer, XYDataset> entry : this.datasets.entrySet()) {",
        "ins2PreCode":"private List<XYDataset> getDatasetsMappedToRangeAxis(Integer axisIndex) { Args.nullNotPermitted(axisIndex, \"axisIndex\"); List<XYDataset> result = new ArrayList<XYDataset>(); for (Entry<Integer, XYDataset> entry : this.datasets.entrySet()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void propertiesAsMap() { SpringApplicationBuilder application = new SpringApplicationBuilder()",
        "ins1PreCode":"public void propertiesAsMap() throws Exception { SpringApplicationBuilder application = new SpringApplicationBuilder()",
        "ins2PreCode":"public void propertiesAsProperties() throws Exception { SpringApplicationBuilder application = new SpringApplicationBuilder()",
        "label":1
    },
    {
        "ins1CurCode":"private boolean compareFiles(String name1, String name2) throws IOException { File file1 = buildRule.getProject().resolveFile(name1); File file2 = buildRule.getProject().resolveFile(name2); ",
        "ins1PreCode":"private boolean compareFiles(String name1, String name2) throws IOException { File file1 = new File(System.getProperty(\"root\"), name1); File file2 = new File(System.getProperty(\"root\"), name2); ",
        "ins2PreCode":"private boolean compareFiles(File file1, File file2) throws IOException { if (!file1.exists() || !file2.exists()) { return false; }  if (file1.length() != file2.length()) { return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  try (FileInputStream fis1 = new FileInputStream(file1)) { try (FileInputStream fis2 = new FileInputStream(file2)) { int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } } } return true;",
        "label":0
    },
    {
        "ins1CurCode":" JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1)); JavaPairRDD<Integer, int[]> pairRDD = rdd.mapToPair(x -> new Tuple2<>(x, new int[]{x})); pairRDD.collect();",
        "ins1PreCode":" JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1)); JavaPairRDD<Integer, int[]> pairRDD = rdd.mapToPair( new PairFunction<Integer, Integer, int[]>() { @Override public Tuple2<Integer, int[]> call(Integer x) { return new Tuple2<>(x, new int[]{x}); } }); pairRDD.collect();",
        "ins2PreCode":"public void collectAsMapWithIntArrayValues() {  JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1)); JavaPairRDD<Integer, int[]> pairRDD = rdd.mapToPair(x -> new Tuple2<>(x, new int[]{x})); pairRDD.collect(); pairRDD.collectAsMap();",
        "label":0
    },
    {
        "ins1CurCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"true\") .set(\"spark.memory.offHeap.size\", \"10000\"); final TaskMemoryManager memoryManager =",
        "ins1PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager =",
        "ins2PreCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager =",
        "label":0
    },
    {
        "ins1CurCode":"void shouldLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1PreCode":"public void shouldLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins2PreCode":"public void shouldOffsetAndLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":" List<ArrayRecord> records = dataset.collectAsList(); Assert.assertEquals(ARRAY_RECORDS, records);",
        "ins1PreCode":" List<ArrayRecord> records = dataset.collectAsList(); Assert.assertEquals(records, ARRAY_RECORDS);",
        "ins2PreCode":"List<MapRecord> records = dataset.collectAsList();  Assert.assertEquals(records, MAP_RECORDS);",
        "label":1
    },
    {
        "ins1CurCode":"  if (host.getState().isAvailable()) { writer.println (sm.getString(\"hostManagerServlet.alreadyStarted\", name)); return;",
        "ins1PreCode":"  try { host.start(); writer.println (sm.getString(\"hostManagerServlet.started\", name));",
        "ins2PreCode":"  try { host.stop(); writer.println (sm.getString(\"hostManagerServlet.stopped\", name));",
        "label":1
    },
    {
        "ins1CurCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>(true) { private static final long serialVersionUID = -9081211580719235896L;  @Override void truncate() { } }; ",
        "ins1PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(true); buf.addLast(new Node(1, 0));",
        "ins2PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(false); buf.addLast(new Node(1, 0));",
        "label":0
    },
    {
        "ins1CurCode":"public static <@NonNull T> Observable<T> mergeDelayError( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "ins1PreCode":"public static <T> Observable<T> mergeDelayError( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "ins2PreCode":"public static <T> Flowable<T> concat( @NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":0
    },
    {
        "ins1CurCode":"public static <@NonNull T> Single<Boolean> sequenceEqual(@NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull BiPredicate<? super T, ? super T> isEqual, int bufferSize) {",
        "ins1PreCode":"public static <T> Single<Boolean> sequenceEqual(@NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull BiPredicate<? super T, ? super T> isEqual, int bufferSize) {",
        "ins2PreCode":"public static <T> Single<Boolean> sequenceEqual( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "label":0
    },
    {
        "ins1CurCode":"StandardManager mgr = new StandardManager(); mgr.generateSessionId(); while (mgr.sessionCreationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionCreationTiming.add(null); } while (mgr.sessionExpirationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionExpirationTiming.add(null); }   Thread[] threads = new Thread[threadCount];  for (int i = 0; i < threadCount; i++) { threads[i] = new Thread( new TestThreadGenerateSessionId(mgr, iterCount)); }  long start = System.currentTimeMillis();  for (int i = 0; i < threadCount; i++) { threads[i].start(); } for (int i = 0; i < threadCount; i++) { try { threads[i].join(); } catch (InterruptedException e) { e.printStackTrace(); fail(e.getMessage()); } } long end = System.currentTimeMillis();  StringBuilder result = new StringBuilder(); result.append(\"Threads: \"); result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); System.out.println(result.toString());",
        "ins1PreCode":"StandardManager mgr = new StandardManager();  mgr.randomFileCurrent = mgr.randomFile; mgr.createRandomInputStream(); mgr.generateSessionId(); while (mgr.sessionCreationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionCreationTiming.add(null); } while (mgr.sessionExpirationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionExpirationTiming.add(null); }   Thread[] threads = new Thread[threadCount];  for (int i = 0; i < threadCount; i++) { threads[i] = new Thread( new TestThreadGenerateSessionId(mgr, iterCount)); }  long start = System.currentTimeMillis();  for (int i = 0; i < threadCount; i++) { threads[i].start(); } for (int i = 0; i < threadCount; i++) { try { threads[i].join(); } catch (InterruptedException e) { e.printStackTrace(); fail(e.getMessage()); } } long end = System.currentTimeMillis();  StringBuilder result = new StringBuilder(); result.append(\"Threads: \"); result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); result.append(\", RandomInputStreams: \"); result.append(mgr.randomInputStreams.size()); System.out.println(result.toString());",
        "ins2PreCode":"mgr.setContainer(new StandardContext());  mgr.randomFileCurrent = mgr.randomFile; mgr.createRandomInputStream(); mgr.generateSessionId(); while (mgr.sessionCreationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionCreationTiming.add(null); } while (mgr.sessionExpirationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionExpirationTiming.add(null); }  Thread[] threads = new Thread[threadCount];  for (int i = 0; i < threadCount; i++) { threads[i] = new Thread( new TestThreadCreateSession(mgr, iterCount)); }  long start = System.currentTimeMillis();  for (int i = 0; i < threadCount; i++) { threads[i].start(); } for (int i = 0; i < threadCount; i++) { try { threads[i].join(); } catch (InterruptedException e) { e.printStackTrace(); fail(e.getMessage()); } } long end = System.currentTimeMillis();  StringBuilder result = new StringBuilder(); result.append(\"Threads: \"); result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); result.append(\", RandomInputStreams: \"); result.append(mgr.randomInputStreams.size()); System.out.println(result.toString());",
        "label":1
    },
    {
        "ins1CurCode":" try { ms = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { ms = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { ss = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null SingleSource\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; } ListSet offs = i.getOffenders(); Object dm =  offs.get(0); if (!predicate(dm, dsgr)) { return false; }",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders(); Object dm =  offs.get(0); if (!predicate(dm, dsgr)) return false; ListSet newOffs = computeOffenders(dm);",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; } ListSet offs = i.getOffenders(); Object dm = offs.get(0); if (!predicate(dm, dsgr)) { return false; } ListSet newOffs = computeOffenders(dm); boolean res = offs.equals(newOffs); return res;",
        "label":0
    },
    {
        "ins1CurCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32); ",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); ",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorNonEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); ",
        "label":1
    },
    {
        "ins1CurCode":"SearchHit[] hits = new SearchHit[rated.size()]; for (int i = 0; i < rated.size(); i++) { hits[i] = new SearchHit(i, i + \"\", Collections.emptyMap(), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(index, \"uuid\", 0), null, OriginalIndices.NONE));",
        "ins1PreCode":"SearchHit[] hits = new SearchHit[rated.size()]; for (int i = 0; i < rated.size(); i++) { hits[i] = new SearchHit(i, i + \"\", Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(index, \"uuid\", 0), null, OriginalIndices.NONE));",
        "ins2PreCode":"SearchHit[] hits = new SearchHit[rated.size()]; for (int i = 0; i < rated.size(); i++) { hits[i] = new SearchHit(i, i + \"\", Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(index, \"uuid\", 0), null, OriginalIndices.NONE));",
        "label":1
    },
    {
        "ins1CurCode":"}  Reporting reporting = model.getReporting();  if ( reporting != null ) { reporting.setOutputDirectory( alignToBaseDirectory( reporting.getOutputDirectory(), basedir ) ); }",
        "ins1PreCode":"}",
        "ins2PreCode":"}",
        "label":1
    },
    {
        "ins1CurCode":"if ( tgt == null ) { tgt = new IssueManagement(); target.setIssueManagement( tgt ); mergeIssueManagement( tgt, src, sourceDominant, context );",
        "ins1PreCode":"if ( tgt == null ) { target.setIssueManagement( tgt = new IssueManagement() ); mergeIssueManagement( tgt, src, sourceDominant, context );",
        "ins2PreCode":"if ( tgt == null ) { target.setCiManagement( tgt = new CiManagement() ); mergeCiManagement( tgt, src, sourceDominant, context );",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"collection.add(item); } catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); }",
        "ins1PreCode":"collection.add(item); } catch (CannotResolveClassException e) { System.err.println(\"failed to locate class: \"+e); }",
        "ins2PreCode":"items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(Level.WARNING,\"Failed to resolve class\",e); }",
        "label":0
    },
    {
        "ins1CurCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\");",
        "ins1PreCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\");",
        "ins2PreCode":"public void testDataSendNO_ACK() throws Exception { System.err.println(\"Starting NO_ACK\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(),0); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "label":0
    },
    {
        "ins1CurCode":"DefaultTableXYDataset d1 = new DefaultTableXYDataset(); d1.setAutoWidth(true); XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); s1.add(3.0, 1.1); s1.add(7.0, 2.2); d1.addSeries(s1); assertEquals(3.0, d1.getXValue(0, 0), EPSILON); assertEquals(7.0, d1.getXValue(0, 1), EPSILON); assertEquals(1.0, d1.getStartXValue(0, 0), EPSILON); assertEquals(5.0, d1.getStartXValue(0, 1), EPSILON); assertEquals(5.0, d1.getEndXValue(0, 0), EPSILON); assertEquals(9.0, d1.getEndXValue(0, 1), EPSILON);   XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false); s2.add(7.5, 1.1);",
        "ins1PreCode":"DefaultTableXYDataset d1 = new DefaultTableXYDataset(); d1.setAutoWidth(true); XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(3.0, 1.1); s1.add(7.0, 2.2); d1.addSeries(s1); assertEquals(3.0, d1.getXValue(0, 0), EPSILON); assertEquals(7.0, d1.getXValue(0, 1), EPSILON); assertEquals(1.0, d1.getStartXValue(0, 0), EPSILON); assertEquals(5.0, d1.getStartXValue(0, 1), EPSILON); assertEquals(5.0, d1.getEndXValue(0, 0), EPSILON); assertEquals(9.0, d1.getEndXValue(0, 1), EPSILON);   XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(7.5, 1.1);",
        "ins2PreCode":"public void testAddSeries() { CategoryTableXYDataset d1 = new CategoryTableXYDataset(); d1.setAutoWidth(true); d1.add(3.0, 1.1, \"Series 1\"); d1.add(7.0, 2.2, \"Series 1\"); assertEquals(3.0, d1.getXValue(0, 0), EPSILON); assertEquals(7.0, d1.getXValue(0, 1), EPSILON); assertEquals(1.0, d1.getStartXValue(0, 0), EPSILON); assertEquals(5.0, d1.getStartXValue(0, 1), EPSILON); assertEquals(5.0, d1.getEndXValue(0, 0), EPSILON); assertEquals(9.0, d1.getEndXValue(0, 1), EPSILON);   d1.add(7.5, 1.1, \"Series 2\"); d1.add(9.0, 2.2, \"Series 2\");  assertEquals(3.0, d1.getXValue(1, 0), EPSILON); assertEquals(7.0, d1.getXValue(1, 1), EPSILON); assertEquals(7.5, d1.getXValue(1, 2), EPSILON); assertEquals(9.0, d1.getXValue(1, 3), EPSILON);  assertEquals(7.25, d1.getStartXValue(1, 2), EPSILON); assertEquals(8.75, d1.getStartXValue(1, 3), EPSILON); assertEquals(7.75, d1.getEndXValue(1, 2), EPSILON); assertEquals(9.25, d1.getEndXValue(1, 3), EPSILON);   assertEquals(2.75, d1.getStartXValue(0, 0), EPSILON); assertEquals(6.75, d1.getStartXValue(0, 1), EPSILON); assertEquals(3.25, d1.getEndXValue(0, 0), EPSILON); assertEquals(7.25, d1.getEndXValue(0, 1), EPSILON);",
        "label":0
    },
    {
        "ins1CurCode":"createMockAncestors(req, createAncestor(j, \"../..\"), createAncestor(view, \".\")); TopLevelItem i = createMockItem(parent, \"job/i/\"); when(view.getItems()).thenReturn(Collections.emptyList()); String result = Functions.getRelativeLinkTo(i);",
        "ins1PreCode":"createMockAncestors(req, createAncestor(j, \"../..\"), createAncestor(view, \".\")); TopLevelItem i = createMockItem(parent, \"job/i/\"); when(view.getItems()).thenReturn(Collections.<TopLevelItem>emptyList()); String result = Functions.getRelativeLinkTo(i);",
        "ins2PreCode":"createMockAncestors(req, createAncestor(view, \".\"), createAncestor(j, \"../..\")); TopLevelItem i = createMockItem(parent, \"job/i/\"); when(view.getItems()).thenReturn(Arrays.asList(i)); String result = Functions.getRelativeLinkTo(i);",
        "label":0
    },
    {
        "ins1CurCode":"public void nodes_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  Set<Integer> nodes = network.nodes();",
        "ins1PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2);",
        "ins2PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addNode(N1); assertThat(network.nodes()).containsExactlyElementsIn(nodes); }",
        "label":0
    },
    {
        "ins1CurCode":" getCommentCommand(cmd); } else if (getCommentFile() != null) { ",
        "ins1PreCode":"getCommentCommand(cmd); } else { if (getCommentFile() != null) { ",
        "ins2PreCode":"getCommentCommand(cmd); } else { if (getCommentFile() != null) { ",
        "label":1
    },
    {
        "ins1CurCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @NotNull OWNER owner, @NotNull OBJECT oldObject) throws DBException { String objectName = oldObject.getName(); if (!isFullyCached()) { this.loadObjects(monitor, owner); } else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null); removeObject(oldObject);",
        "ins1PreCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @Nullable OWNER owner, @NotNull OBJECT oldObject) throws DBException { String objectName = oldObject.getName(); if (!isFullyCached()) { this.loadObjects(monitor, owner); } else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject); removeObject(oldObject);",
        "ins2PreCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @Nullable OWNER owner, @NotNull OBJECT oldObject) throws DBException { String objectName = oldObject.getName(); if (!isFullyCached()) { this.loadObjects(monitor, owner); } else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject); if (isChildrenCached(oldObject)) {",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3); assertThat(network.edges()).containsExactly(E15, E41, E23); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);",
        "ins1PreCode":"assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder(); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);",
        "ins2PreCode":"assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder(); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15);",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerSingleError() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerSingleError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerCompletableObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"public void testdefTocharExplicit() { assertEquals('s', exec(\"def d = 's'; char b = (char)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = (char)d;\"));",
        "ins1PreCode":"public void testdefTocharExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = (char)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; char b = (char)d;\"));",
        "ins2PreCode":"public void testdefToCharacterExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Character b = (Character)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; Character b = (Character)d;\"));",
        "label":0
    },
    {
        "ins1CurCode":"void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins1PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOffFromSpecificLocation() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1CurCode":"void bindShouldNotValidateIfOtherHandlersInChainThrowError() { this.sources.add(new MockConfigurationPropertySource(\"foo\", \"hello\"));",
        "ins1PreCode":"public void bindShouldNotValidateIfOtherHandlersInChainThrowError() { this.sources.add(new MockConfigurationPropertySource(\"foo\", \"hello\"));",
        "ins2PreCode":"public void bindShouldValidateIfOtherHandlersInChainIgnoreError() { TestHandler testHandler = new TestHandler();",
        "label":1
    },
    {
        "ins1CurCode":"if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ValuesSourceAggregationBuilder<?> other = (ValuesSourceAggregationBuilder<?>) obj; return Objects.equals(field, other.field) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(script, other.script) && Objects.equals(timeZone, other.timeZone) && Objects.equals(userValueTypeHint, other.userValueTypeHint);",
        "ins1PreCode":"if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ValuesSourceAggregationBuilder<?, ?> other = (ValuesSourceAggregationBuilder<?, ?>) obj; return Objects.equals(valuesSourceType, other.valuesSourceType) && Objects.equals(field, other.field) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(script, other.script) && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(timeZone, other.timeZone) && Objects.equals(valueType, other.valueType);",
        "ins2PreCode":"if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ArrayValuesSourceAggregationBuilder<?, ?> other = (ArrayValuesSourceAggregationBuilder<?, ?>) obj; return Objects.equals(fields, other.fields) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(valueType, other.valueType) && Objects.equals(valuesSourceType, other.valuesSourceType);",
        "label":0
    },
    {
        "ins1CurCode":"public void globalError() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new TestFilterChain( (request, response, chain) -> response.sendError(400, \"BAD\")); this.filter.doFilter(this.request, this.response, this.chain);",
        "ins1PreCode":"public void globalError() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { ((HttpServletResponse) response).sendError(400, \"BAD\"); super.doFilter(request, response); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "ins2PreCode":"public void statusError() throws Exception { this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, \"/400\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { ((HttpServletResponse) response).sendError(400, \"BAD\"); super.doFilter(request, response); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "label":1
    },
    {
        "ins1CurCode":"void matchWhenHasNoControllers() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithNoControllers.class);",
        "ins1PreCode":"public void matchWhenHasNoControllers() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithNoControllers.class);",
        "ins2PreCode":"public void matchWhenHasController() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithController.class);",
        "label":1
    },
    {
        "ins1CurCode":"public static final Number add(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); }",
        "ins1PreCode":"public static final Number add(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return new Long(0); }",
        "ins2PreCode":"public static final Number subtract(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return new Long(0); }",
        "label":1
    },
    {
        "ins1CurCode":"protected void fireToDoItemsAdded(List<ToDoItem> theItems) {  Object[] listeners = listenerList.getListenerList(); ToDoListEvent e = null;",
        "ins1PreCode":"protected void fireToDoItemsAdded(List<ToDoItem> theItems) { if (theItems.isEmpty()) { return; }",
        "ins2PreCode":"protected void fireToDoItemsRemoved(List<ToDoItem> theItems) { if (theItems.isEmpty()) { return; }",
        "label":1
    },
    {
        "ins1CurCode":"}  Collection<Marker> markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { Iterator<Marker> iterator = markers.iterator(); while (iterator.hasNext()) {",
        "ins1PreCode":"}  Collection markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) {",
        "ins2PreCode":"protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {  XYItemRenderer r = getRenderer(index); if (r == null) { return; }   if (index >= getDatasetCount()) { return; } Collection markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next(); r.drawRangeMarker(g2, this, axis, marker, dataArea); } }",
        "label":0
    },
    {
        "ins1CurCode":"renderer); p1.setOrientation(PlotOrientation.HORIZONTAL); CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1); assertTrue(p1.equals(p2));",
        "ins1PreCode":"renderer); p1.setOrientation(PlotOrientation.HORIZONTAL); CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1); assertTrue(p1.equals(p2));",
        "ins2PreCode":"renderer); p1.setOrientation(PlotOrientation.VERTICAL); CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1CurCode":"} if (seriesPaint == null) { seriesPaint = this.defaultPaint; }",
        "ins1PreCode":"} if (seriesPaint == null) { seriesPaint = this.basePaint; }",
        "ins2PreCode":"} if (seriesFillPaint == null) { seriesFillPaint = this.baseFillPaint; }",
        "label":1
    },
    {
        "ins1CurCode":"int result = run(commandLine); if (Execute.isFailure(result)) { throw new BuildException(\"Failed executing: \" + commandLine, getLocation()); }",
        "ins1PreCode":"int result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "ins2PreCode":"public void execute() throws BuildException { Commandline commandLine = new Commandline(); int result = 0;    commandLine.setExecutable(getCcmCommand()); commandLine.createArgument().setValue(getCcmAction());  checkOptions(commandLine);  result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "label":0
    },
    {
        "ins1CurCode":" r.setAutoPopulateSeriesFillPaint(true); CategoryPlot<String, String> plot = new CategoryPlot<>(null, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), r); assertEquals(DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE[0],",
        "ins1PreCode":" r.setAutoPopulateSeriesFillPaint(true); new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r); assertEquals(DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE[0],",
        "ins2PreCode":" r.setAutoPopulateSeriesPaint(true); CategoryPlot plot = new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r);",
        "label":0
    },
    {
        "ins1CurCode":"public void testThreadCount() {  Project p = buildRule.getProject(); p.setUserProperty(\"test.direct\", DIRECT_MESSAGE); p.setUserProperty(\"test.delayed\", DELAYED_MESSAGE); buildRule.executeTarget(\"testThreadCount\"); assertEquals(\"\", buildRule.getOutput()); assertEquals(\"\", buildRule.getError()); String log = buildRule.getLog(); int pos = 0;",
        "ins1PreCode":"public void testThreadCount() {  Project p = getProject(); p.setUserProperty(\"test.direct\", DIRECT_MESSAGE); p.setUserProperty(\"test.delayed\", DELAYED_MESSAGE); expectOutputAndError(\"testThreadCount\", \"\", \"\"); String log = getLog(); int pos = 0;",
        "ins2PreCode":"public void testBasic() {  Project p = getProject(); p.setUserProperty(\"test.direct\", DIRECT_MESSAGE); p.setUserProperty(\"test.delayed\", DELAYED_MESSAGE); expectOutputAndError(\"testBasic\", \"\", \"\"); String log = getLog(); assertEquals(\"parallel tasks didn't output correct data\", log,",
        "label":0
    },
    {
        "ins1CurCode":"OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null); if (newObject != null) { deepCopyCachedObject(newObject, oldObject);  } else { removeObject(oldObject, false); } return oldObject; }",
        "ins1PreCode":"removeObject(oldObject, false); if (newObject != null) { cacheObject(newObject); } return newObject; }",
        "ins2PreCode":"removeObject(oldObject, false); if (newObject != null) { cacheObject(newObject); } return newObject; }",
        "label":1
    },
    {
        "ins1CurCode":"public void setShowProperties(final boolean showem) { if (diaDefault.isShowProperties() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES;  public void redo() { diaDefault.setShowProperties(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { diaDefault.setShowProperties(!showem); fireNotationEvent(key, showem, !showem); } }; doUndoable(memento);",
        "ins1PreCode":"public void setShowProperties(final boolean showem) { if (showProperties == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES;  public void redo() { showProperties = showem; fireNotationEvent(key, !showem, showem); }  public void undo() { showProperties = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "ins2PreCode":"public void setShowTypes(final boolean showem) { if (showTypes == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_TYPES;  public void redo() { showTypes = showem; fireNotationEvent(key, !showem, showem); }  public void undo() { showTypes = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerEmitterNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@unknown{test,author={Ed von Test}}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"unknown\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":".parse(new StringReader(\"@unknown{test,author={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"unknown\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"new StringReader(\"@thisIsALongStringToTestMaybeItIsToLongWhoKnowsNOTme{test,author={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"thisisalongstringtotestmaybeitistolongwhoknowsnotme\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); Assert.assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); Assert.assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result); ",
        "ins1PreCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result); ",
        "ins2PreCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result); ",
        "label":1
    },
    {
        "ins1CurCode":"void profilesAddedToEnvironmentViaActiveAndIncludeProperty(CapturedOutput output) {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev\", \"spring.profiles.include=other\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).containsExactly(\"other\", \"dev\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromdevpropertiesfile\"); validateProfilePreference(output, null, \"other\", \"dev\");",
        "ins1PreCode":"void profilesAddedToEnvironmentViaActiveAndIncludeProperty(CapturedOutput capturedOutput) {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev\", \"spring.profiles.include=other\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).containsExactly(\"other\", \"dev\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromdevpropertiesfile\"); validateProfilePreference(capturedOutput, null, \"other\", \"dev\");",
        "ins2PreCode":"void profilesAddedToEnvironmentAndViaPropertyDuplicate(CapturedOutput capturedOutput) { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev,other\"); this.environment.addActiveProfile(\"dev\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).contains(\"dev\", \"other\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromotherpropertiesfile\"); validateProfilePreference(capturedOutput, null, \"dev\", \"other\");",
        "label":1
    },
    {
        "ins1CurCode":"if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseInsensitive(this.curpwd, currentPathElement);",
        "ins1PreCode":"if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement);",
        "ins2PreCode":"|| !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement);",
        "label":1
    },
    {
        "ins1CurCode":"public String getObjectNameKeyProperties() {  StringBuilder name = new StringBuilder(\"type=Manager\");  name.append(\",host=\"); name.append(context.getParent().getName());  name.append(\",context=\"); String contextName = context.getName(); if (!contextName.startsWith(\"/\")) { name.append('/'); } name.append(contextName);  return name.toString();",
        "ins1PreCode":"public String getObjectNameKeyProperties() {  StringBuilder name = new StringBuilder(\"type=Manager\");  name.append(\",context=\"); String contextName = context.getName(); if (!contextName.startsWith(\"/\")) { name.append('/'); } name.append(contextName);  name.append(\",host=\"); name.append(context.getParent().getName());  return name.toString();",
        "ins2PreCode":"protected String getObjectNameKeyProperties() {  StringBuilder name = new StringBuilder(\"type=Loader\");  name.append(\",context=\");  String contextName = context.getName(); if (!contextName.startsWith(\"/\")) { name.append(\"/\"); } name.append(contextName);  name.append(\",host=\"); name.append(context.getParent().getName());  return name.toString();",
        "label":1
    },
    {
        "ins1CurCode":"public void ofTypeWithPolymorphism() { ArrayList<Integer> l1 = new ArrayList<>(); l1.add(1); LinkedList<Integer> l2 = new LinkedList<>(); l2.add(2);",
        "ins1PreCode":"public void ofTypeWithPolymorphism() { ArrayList<Integer> l1 = new ArrayList<Integer>(); l1.add(1); LinkedList<Integer> l2 = new LinkedList<Integer>(); l2.add(2);",
        "ins2PreCode":"public void ofTypeWithPolymorphism() { ArrayList<Integer> l1 = new ArrayList<Integer>(); l1.add(1); LinkedList<Integer> l2 = new LinkedList<Integer>(); l2.add(2);",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtInvalidIndex() { assertThrowsWithMessage(\"Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestObserver<Integer> to = new TestObserver<>();",
        "ins1PreCode":"public void assertValueAtInvalidIndex() { assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestObserver<Integer> to = new TestObserver<>();",
        "ins2PreCode":"public void assertValueAtPredicateMatch() { TestObserver<Integer> to = new TestObserver<>();  Observable.just(1, 2).subscribe(to);  to.assertValueAt(1, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 2; } });",
        "label":0
    },
    {
        "ins1CurCode":"\"                       ROW_NUMBER() OVER (PARTITION BY col.CONSTRAINT_NAME ORDER BY col.POSITION) -1 AS prev\\r\\n\" + \"                FROM   \"+ OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONS_COLUMNS\") +\" col \\r\\n\" + \"                WHERE  col.OWNER =? AND col.TABLE_NAME = ? \\r\\n\" + \"                ) WHERE cn = c.CONSTRAINT_NAME  GROUP BY cn CONNECT BY prev = PRIOR curr AND cn = PRIOR cn START WITH curr = 1      \\r\\n\" + \"        ) COLUMN_NAMES_NUMS\\r\\n\" +",
        "ins1PreCode":"\"                       ROW_NUMBER() OVER (PARTITION BY col.CONSTRAINT_NAME ORDER BY col.POSITION) -1 AS prev\\r\\n\" + \"                FROM   \"+ OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONS_COLUMNS\") +\" col \\r\\n\" + \"                WHERE  col.OWNER =? AND col.TABLE_NAME = ? AND col.CONSTRAINT_NAME = c.CONSTRAINT_NAME \\r\\n\" + \"                )   GROUP BY cn CONNECT BY prev = PRIOR curr AND cn = PRIOR cn START WITH curr = 1      \\r\\n\" + \"        ) COLUMN_NAMES_NUMS\\r\\n\" +",
        "ins2PreCode":"+ OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONS_COLUMNS\") + \" col \\r\\n\" + \"                WHERE  col.OWNER =? AND col.TABLE_NAME = ? AND col.CONSTRAINT_NAME = c.CONSTRAINT_NAME \\r\\n\" + \"                )   GROUP BY cn CONNECT BY prev = PRIOR curr AND cn = PRIOR cn START WITH curr = 1      \\r\\n\" + \"        ) COLUMN_NAMES_NUMS\\r\\n\" + \"FROM\\r\\n\" + \"    \"",
        "label":1
    },
    {
        "ins1CurCode":"public static void execute(Shell shell, @NotNull final DBCExecutionContext context) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try {",
        "ins1PreCode":"public static void execute(Shell shell, @NotNull final DBSDataSourceContainer dataSourceContainer) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBPDataSource dataSource = dataSourceContainer.getDataSource(); if (dataSource != null) { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSource); if (txnManager != null) { DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try {",
        "ins2PreCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBPDataSource dataSource = dataSourceContainer.getDataSource(); if (dataSource != null) { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSource); if (txnManager != null) { DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\"); try {",
        "label":1
    },
    {
        "ins1CurCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasBinaryContent(new byte[] { 3 }); }",
        "ins1PreCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "ins2PreCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "label":1
    },
    {
        "ins1CurCode":" result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString();",
        "ins1PreCode":" result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString();",
        "ins2PreCode":" result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString();",
        "label":1
    },
    {
        "ins1CurCode":"public final <@NonNull U extends Collection<? super T>> Flowable<U> buffer( long timespan, @NonNull TimeUnit unit,",
        "ins1PreCode":"public final <U extends Collection<? super T>> Flowable<U> buffer( long timespan, @NonNull TimeUnit unit,",
        "ins2PreCode":"public final Observable<Observable<T>> window( long timespan, @NonNull TimeUnit unit, @NonNull Scheduler scheduler, long count, boolean restart, int bufferSize) { ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); Objects.requireNonNull(scheduler, \"scheduler is null\"); Objects.requireNonNull(unit, \"unit is null\"); ObjectHelper.verifyPositive(count, \"count\"); return RxJavaPlugins.onAssembly(new ObservableWindowTimed<>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));",
        "label":0
    },
    {
        "ins1CurCode":"final List<Range> ranges = getRanges(); return new Iterable<Integer>() { @Override public Iterator<Integer> iterator() { return new Iterators.FlattenIterator<Integer,Range>(ranges) { @Override protected Iterator<Integer> expand(Range range) {",
        "ins1PreCode":"final List<Range> ranges = getRanges(); return new Iterable<Integer>() { public Iterator<Integer> iterator() { return new Iterators.FlattenIterator<Integer,Range>(ranges) { protected Iterator<Integer> expand(Range range) { return Iterators.sequence(range.start,range.end).iterator(); }",
        "ins2PreCode":"final List<Range> ranges = getRanges(); return new Iterable<Integer>() { public Iterator<Integer> iterator() { return new Iterators.FlattenIterator<Integer,Range>(Iterators.reverse(ranges)) { protected Iterator<Integer> expand(Range range) { return Iterators.reverseSequence(range.start,range.end).iterator(); }",
        "label":1
    },
    {
        "ins1CurCode":"void testcrossrefSchool() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry() .withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingCE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"[auth]\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins1PreCode":"void testcrossrefSchool() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingCE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins2PreCode":"void testcrossrefInstituteOfTechnology() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Massachusetts Institute of Technology}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"MIT\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "label":1
    },
    {
        "ins1CurCode":"while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry.isPrimary() ) set.add(entry.getValue()); }",
        "ins1PreCode":"while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); MapEntry entry = (MapEntry)e.getValue(); if ( entry.isPrimary() ) set.add(entry); }",
        "ins2PreCode":"while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); MapEntry entry = (MapEntry)e.getValue(); if ( entry.isPrimary() ) set.add(entry.getKey()); }",
        "label":0
    },
    {
        "ins1CurCode":" buffer.append( art ); if ( StringUtils.isNotEmpty( dep.getScope() ) ) { buffer.append( ':' ).append( dep.getScope() ); }  if ( dep.isOptional() ) { buffer.append( \" (optional)\" ); }     if ( ( node.getManagedBits() & DependencyNode.MANAGED_SCOPE ) == DependencyNode.MANAGED_SCOPE ) { final String premanagedScope = DependencyManagerUtils.getPremanagedScope( node ); buffer.append( \" (scope managed from \" ); buffer.append( StringUtils.defaultString( premanagedScope, \"default\" ) ); buffer.append( ')' ); }  if ( ( node.getManagedBits() & DependencyNode.MANAGED_VERSION ) == DependencyNode.MANAGED_VERSION ) { final String premanagedVersion = DependencyManagerUtils.getPremanagedVersion( node ); buffer.append( \" (version managed from \" ); buffer.append( StringUtils.defaultString( premanagedVersion, \"default\" ) ); buffer.append( ')' ); }  if ( ( node.getManagedBits() & DependencyNode.MANAGED_OPTIONAL ) == DependencyNode.MANAGED_OPTIONAL ) { final Boolean premanagedOptional = DependencyManagerUtils.getPremanagedOptional( node ); buffer.append( \" (optionality managed from \" ); buffer.append( StringUtils.defaultString( premanagedOptional, \"default\" ) ); buffer.append( ')' ); }  if ( ( node.getManagedBits() & DependencyNode.MANAGED_EXCLUSIONS ) == DependencyNode.MANAGED_EXCLUSIONS ) { final Collection<org.eclipse.aether.graph.Exclusion> premanagedExclusions = DependencyManagerUtils.getPremanagedExclusions( node );  buffer.append( \" (exclusions managed from \" ); buffer.append( StringUtils.defaultString( premanagedExclusions, \"default\" ) ); buffer.append( ')' ); }  if ( ( node.getManagedBits() & DependencyNode.MANAGED_PROPERTIES ) == DependencyNode.MANAGED_PROPERTIES ) { final Map<String, String> premanagedProperties = DependencyManagerUtils.getPremanagedProperties( node );  buffer.append( \" (properties managed from \" ); buffer.append( StringUtils.defaultString( premanagedProperties, \"default\" ) ); buffer.append( ')' );",
        "ins1PreCode":"  buffer.append( \" (exclusions managed)\" ); }  if ( ( node.getManagedBits() & DependencyNode.MANAGED_PROPERTIES ) == DependencyNode.MANAGED_PROPERTIES ) {   buffer.append( \" (properties managed)\" ); }",
        "ins2PreCode":"if ( dep != null ) { Artifact art = dep.getArtifact(); ",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StackedBarRenderer r1 = new StackedBarRenderer(); StackedBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StackedBarRenderer r1 = new StackedBarRenderer(); StackedBarRenderer r2 = (StackedBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatServletWebServerFactory factory = getFactory(); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); factory.setTomcatProtocolHandlerCustomizers( Arrays.asList(customizers[0], customizers[1])); factory.addProtocolHandlerCustomizers(customizers[2], customizers[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) customizers); for (TomcatProtocolHandlerCustomizer customizer : customizers) { ordered.verify(customizer).customize(any(ProtocolHandler.class)); }",
        "ins1PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatServletWebServerFactory factory = getFactory(); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] listeners = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); factory.setTomcatProtocolHandlerCustomizers( Arrays.asList(listeners[0], listeners[1])); factory.addProtocolHandlerCustomizers(listeners[2], listeners[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) listeners); for (TomcatProtocolHandlerCustomizer listener : listeners) { ordered.verify(listener).customize(any(ProtocolHandler.class)); }",
        "ins2PreCode":"public void builderCustomizers() { UndertowServletWebServerFactory factory = getFactory(); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class)); factory.setBuilderCustomizers(Arrays.asList(customizers[0], customizers[1])); factory.addBuilderCustomizers(customizers[2], customizers[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) customizers); for (UndertowBuilderCustomizer customizer : customizers) { ordered.verify(customizer).customize(any(Builder.class)); }",
        "label":0
    },
    {
        "ins1CurCode":"WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() { List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, ActuatorMediaType.V2_JSON);",
        "ins1PreCode":"public WebFluxEndpointHandlerMapping webEndpointReactiveHandlerMapping() { List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, ActuatorMediaType.V2_JSON);",
        "ins2PreCode":"public WebMvcEndpointHandlerMapping webEndpointServletHandlerMapping() { List<String> mediaTypes = Arrays.asList(MediaType.APPLICATION_JSON_VALUE, ActuatorMediaType.V2_JSON);",
        "label":1
    },
    {
        "ins1CurCode":"public String getTriggerDDL(@NotNull DBRProgressMonitor monitor, @NotNull GenericTrigger sourceObject) throws DBException { if (sourceObject instanceof HANATrigger) { return ((HANATrigger) sourceObject).getDefinition(); }",
        "ins1PreCode":"public String getTriggerDDL(DBRProgressMonitor monitor, GenericTrigger sourceObject) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource();",
        "ins2PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericView sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, sourceObject, \"Read HANA view source\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT DEFINITION\\n\" + \"FROM SYS.VIEWS\\n\" + \"WHERE SCHEMA_NAME=? and VIEW_NAME=?\")) { dbStat.setString(1, sourceObject.getContainer().getName()); dbStat.setString(2, sourceObject.getName()); try (JDBCResultSet dbResult = dbStat.executeQuery()) { if (dbResult.nextRow()) { return \"CREATE VIEW \" + sourceObject.getFullyQualifiedName(DBPEvaluationContext.DDL) + \" AS\\n\" + dbResult.getString(1); } return \"-- HANA view definition not found\"; } } } catch (SQLException e) { throw new DBException(e, dataSource); }",
        "label":0
    },
    {
        "ins1CurCode":"expectedParserResult.getFileList().add(texFile);  expectedParserResult .addKey(\"anykey\", texFile, 1, 32, 45, \"Danach wir anschlie\ufffdend mittels \\\\cite{anykey}.\"); ",
        "ins1PreCode":" expectedParserResult.getFileList().add(texFile); expectedParserResult.addKey(\"anykey\", texFile, 1, 32, 45, \"Danach wir anschlie\u00dfend mittels \\\\cite{anykey}.\"); ",
        "ins2PreCode":"public void testFileEncodingUtf8() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI());  TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexParserResult expectedParserResult = new TexParserResult();  expectedParserResult.getFileList().add(texFile); expectedParserResult.addKey(\"anykey\", texFile, 1, 32, 45, \"Danach wir anschlie\u00dfend mittels \\\\cite{anykey}.\");  assertEquals(expectedParserResult, parserResult);",
        "label":0
    },
    {
        "ins1CurCode":"public void hasCycle_threeCyclicEdges() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "ins1PreCode":"public void hasCycle_threeCyclicEdges() { for (MutableBasicGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "ins2PreCode":"public void hasCycle_multipleCycles() { for (MutableBasicGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "label":1
    },
    {
        "ins1CurCode":"private void initialize() { Parameter[] params = getParameters();",
        "ins1PreCode":"private final void initialize() { Parameter[] params = getParameters();",
        "ins2PreCode":"private final void initialize() { Parameter[] params = getParameters();",
        "label":1
    },
    {
        "ins1CurCode":"public void testInterpolateObjectWithStringListField() { Model model = new Model();",
        "ins1PreCode":"public void testInterpolateObjectWithStringListField() throws Exception {",
        "ins2PreCode":"public void testInterpolateObjectWithStringListFieldAndOneLiteralValue() throws Exception {",
        "label":1
    },
    {
        "ins1CurCode":" try { Path tempDir = Files.createTempDirectory(\"jabref-journal\"); Path tempJournalList = tempDir.resolve(\"journalList.mv\"); Files.copy(JournalAbbreviationRepository.class.getResourceAsStream(\"/journals/journalList.mv\"), tempJournalList); repository = new JournalAbbreviationRepository(tempJournalList); tempDir.toFile().deleteOnExit(); tempJournalList.toFile().deleteOnExit(); } catch (IOException e) {",
        "ins1PreCode":" try { Path tempJournalList = Files.createTempDirectory(\"journal\").resolve(\"journalList.mv\"); Files.copy(JournalAbbreviationRepository.class.getResourceAsStream(\"/journals/journalList.mv\"), tempJournalList);",
        "ins2PreCode":" try { Path tempJournalList = Files.createTempDirectory(\"journal\").resolve(\"journalList.mv\"); Files.copy(JournalAbbreviationRepository.class.getResourceAsStream(\"/journals/journalList.mv\"), tempJournalList);",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION), query).getDescription(); ",
        "ins1PreCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription(); ",
        "ins2PreCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription(); ",
        "label":0
    },
    {
        "ins1CurCode":" Tomcat tomcat = getTomcatInstance(); Assert.assertTrue(tomcat.getConnector().setProperty(\"useAsyncIO\", \"true\")); ",
        "ins1PreCode":" Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setProperty(\"useAsyncIO\", \"true\"); ",
        "ins2PreCode":"private UpgradeConnection doUpgrade( Class<? extends HttpUpgradeHandler> upgradeHandlerClass) throws Exception {  Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(\"\", null);  UpgradeServlet servlet = new UpgradeServlet(upgradeHandlerClass); Tomcat.addServlet(ctx, \"servlet\", servlet); ctx.addServletMappingDecoded(\"/\", \"servlet\");  tomcat.start();    Socket socket = SocketFactory.getDefault().createSocket(\"localhost\", getPort());  socket.setSoTimeout(5000);  UpgradeConnection uc = new UpgradeConnection(socket);  uc.getWriter().write(\"GET / HTTP/1.1\" + CRLF); uc.getWriter().write(\"Host: whatever\" + CRLF); uc.getWriter().write(CRLF); uc.getWriter().flush();  String status = uc.getReader().readLine();  Assert.assertNotNull(status); Assert.assertEquals(\"101\", getStatusCode(status));   String line = uc.getReader().readLine(); while (line != null && line.length() > 0) {  line = uc.getReader().readLine(); }  return uc;",
        "label":0
    },
    {
        "ins1CurCode":"Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject());",
        "ins1PreCode":"Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject());",
        "ins2PreCode":"public void testGetFollowSymlinksTrue() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject()); dsDestination.scan(); compareFiles(dsDestination, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"});",
        "label":0
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,author=\\\"author {missing bracket\\\"}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries();  assertEquals(0, parsed.size()); assertTrue(result.hasWarnings());",
        "ins1PreCode":"assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "ins2PreCode":"assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "label":1
    },
    {
        "ins1CurCode":"public static synchronized void setDefaultSearchPath(String[] domains) throws TextParseException { if (domains == null) { defaultSearchPath = null; return; } Name[] newdomains = new Name[domains.length]; for (int i = 0; i < domains.length; i++) { newdomains[i] = Name.fromString(domains[i], Name.root);",
        "ins1PreCode":"public static synchronized void setDefaultSearchPath(String [] domains) throws TextParseException { if (domains == null) { defaultSearchPath = null; return; } Name [] newdomains = new Name[domains.length]; for (int i = 0; i < domains.length; i++) newdomains[i] = Name.fromString(domains[i], Name.root);",
        "ins2PreCode":"public void setSearchPath(String [] domains) throws TextParseException { if (domains == null) { this.searchPath = null; return; } Name [] newdomains = new Name[domains.length]; for (int i = 0; i < domains.length; i++) newdomains[i] = Name.fromString(domains[i], Name.root);",
        "label":1
    },
    {
        "ins1CurCode":"writer.write(formatSize(size, configSizeFmt)); } else { ssiMediator.log(sm.getString(\"ssiCommand.invalidAttribute\", paramName)); writer.write(configErrMsg); } } catch (IOException e) { ssiMediator.log(sm.getString(\"ssiFsize.noSize\", substitutedValue), e); writer.write(configErrMsg);",
        "ins1PreCode":"writer.write(formatSize(size, configSizeFmt)); } else { ssiMediator.log(\"#fsize--Invalid attribute: \" + paramName); writer.write(configErrMsg); } } catch (IOException e) { ssiMediator.log(\"#fsize--Couldn't get size for file: \" + substitutedValue, e); writer.write(configErrMsg);",
        "ins2PreCode":"writer.write(formatDate(date, configTimeFmt)); } else { ssiMediator.log(\"#flastmod--Invalid attribute: \" + paramName); writer.write(configErrMsg); } } catch (IOException e) { ssiMediator.log( \"#flastmod--Couldn't get last modified for file: \" + substitutedValue, e); writer.write(configErrMsg);",
        "label":0
    },
    {
        "ins1CurCode":"void testLangRaw() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testLangRaw() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testLangXmlTags() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testMinimum() throws Exception { rootAction.minimum = 3; HtmlPage p = j.createWebClient().goTo(\"self/testSimple\"); HtmlForm f = p.getFormByName(\"config\"); f.getInputByValue(\"\").setValueAttribute(\"value one\"); f.getInputByValue(\"\").setValueAttribute(\"value two\"); f.getInputByValue(\"\").setValueAttribute(\"value three\"); assertThrows(ElementNotFoundException.class, () -> f.getInputByValue(\"\")); f.getInputsByName(\"bool\").get(2).click(); j.submit(f); assertEqualsJsonArray(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" + \"{\\\"bool\\\":false,\\\"txt\\\":\\\"value two\\\"},{\\\"bool\\\":true,\\\"txt\\\":\\\"value three\\\"}]\", rootAction.formData.get(\"foos\"));",
        "ins1PreCode":"public void testMinimum() throws Exception { minimum = 3; HtmlPage p = createWebClient().goTo(\"self/testSimple\"); HtmlForm f = p.getFormByName(\"config\"); f.getInputByValue(\"\").setValueAttribute(\"value one\"); f.getInputByValue(\"\").setValueAttribute(\"value two\"); f.getInputByValue(\"\").setValueAttribute(\"value three\"); assertThrows(ElementNotFoundException.class, () -> f.getInputByValue(\"\")); f.getInputsByName(\"bool\").get(2).click(); submit(f); assertEqualsJsonArray(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" + \"{\\\"bool\\\":false,\\\"txt\\\":\\\"value two\\\"},{\\\"bool\\\":true,\\\"txt\\\":\\\"value three\\\"}]\", formData.get(\"foos\"));",
        "ins2PreCode":"public void testMinimum_ExistingData() throws Exception { addData(); minimum = 3; HtmlPage p = createWebClient().goTo(\"self/testSimple\"); HtmlForm f = p.getFormByName(\"config\"); f.getInputByValue(\"\").setValueAttribute(\"new one\"); assertThrows(ElementNotFoundException.class, () -> f.getInputByValue(\"\")); f.getInputsByName(\"bool\").get(1).click(); submit(f); assertEqualsJsonArray(\"[{\\\"bool\\\":true,\\\"txt\\\":\\\"existing one\\\"},\" + \"{\\\"bool\\\":true,\\\"txt\\\":\\\"existing two\\\"},{\\\"bool\\\":false,\\\"txt\\\":\\\"new one\\\"}]\", formData.get(\"foos\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testLangVelocityWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins1PreCode":"public void testLangVelocityWithMapper() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); Mapper m = sqlSession.getMapper(Mapper.class); List<Name> answer = m.selectVelocityWithMapper(p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testLangXmlWithMapper() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); Mapper m = sqlSession.getMapper(Mapper.class); List<Name> answer = m.selectXmlWithMapper(p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void reverseMatrixAfterNewBuilds() throws Exception { assumeFalse(\"Symlinks don't work well on Windows\", Functions.isWindows()); File root = dir;",
        "ins1PreCode":"@Test public void reverseMatrixAfterNewBuilds() throws Exception { File root = dir; dir = new File(dir, \"jobs/someproject/Environment=prod/builds\");",
        "ins2PreCode":"@Test public void reverseMavenAfterNewBuilds() throws Exception { File root = dir; dir = new File(dir, \"jobs/someproject/test$test/builds\");",
        "label":1
    },
    {
        "ins1CurCode":" AppExecId appExecId = (AppExecId) o; return Objects.equals(appId, appExecId.appId) && Objects.equals(execId, appExecId.execId);",
        "ins1PreCode":" AppExecId appExecId = (AppExecId) o; return Objects.equal(appId, appExecId.appId) && Objects.equal(execId, appExecId.execId);",
        "ins2PreCode":" AppId appExecId = (AppId) o; return Objects.equal(appId, appExecId.appId);",
        "label":0
    },
    {
        "ins1CurCode":"Author updated; try { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(\"jim@ibatis.apache.org\", updated.getEmail());",
        "ins1PreCode":"Author updated; try { original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(\"jim@ibatis.apache.org\", updated.getEmail());",
        "ins2PreCode":"Author updated; try { original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "label":1
    },
    {
        "ins1CurCode":"openFile(); long contentLength = getContentLength(); DBPPlatform platform = executionContext.getDataSource().getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = getInputStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + bfile.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = getInputStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, executionContext); }",
        "ins1PreCode":"openFile(); long contentLength = getContentLength(); DBPPlatform platform = dataSource.getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = getInputStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + bfile.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = getInputStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); }",
        "ins2PreCode":"if (storage == null && blob != null) { long contentLength = getContentLength(); DBPPlatform platform = dataSource.getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = blob.getBinaryStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); }",
        "label":0
    },
    {
        "ins1CurCode":"config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, null, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\"));",
        "ins1PreCode":"config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\"));",
        "ins2PreCode":"config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\"));",
        "label":1
    },
    {
        "ins1CurCode":"dependency.setVersion( versionRangeResult.getHighestVersion().toString() );  if ( modelPool != null ) { Model model = modelPool.get( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );  if ( model != null ) { return new FileModelSource( model.getPomFile() ); }",
        "ins1PreCode":"dependency.setVersion( versionRangeResult.getHighestVersion().toString() );  return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() ); } catch ( VersionRangeResolutionException e ) { throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(), e );  }",
        "ins2PreCode":"public ModelSource resolveModel( final Dependency dependency ) throws UnresolvableModelException { try { final Artifact artifact = new DefaultArtifact( dependency.getGroupId(), dependency.getArtifactId(), \"\", \"pom\", dependency.getVersion() );  final VersionRangeRequest versionRangeRequest = new VersionRangeRequest( artifact, repositories, context ); versionRangeRequest.setTrace( trace );  final VersionRangeResult versionRangeResult = versionRangeResolver.resolveVersionRange( session, versionRangeRequest );  if ( versionRangeResult.getHighestVersion() == null ) { throw new UnresolvableModelException( String.format( \"No versions matched the requested dependency version range '%s'\", dependency.getVersion() ), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );  }  if ( versionRangeResult.getVersionConstraint() != null && versionRangeResult.getVersionConstraint().getRange() != null && versionRangeResult.getVersionConstraint().getRange().getUpperBound() == null ) {  throw new UnresolvableModelException( String.format( \"The requested dependency version range '%s' does not specify an upper bound\", dependency.getVersion() ), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() );  }  dependency.setVersion( versionRangeResult.getHighestVersion().toString() );  return resolveModel( dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion() ); } catch ( VersionRangeResolutionException e ) { throw new UnresolvableModelException( e.getMessage(), dependency.getGroupId(), dependency.getArtifactId(), dependency.getVersion(), e );  }",
        "label":0
    },
    {
        "ins1CurCode":"public void adjacentNodes_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N1);",
        "ins1PreCode":"public void adjacentNodes_checkReturnedSetMutability() { addNode(N1); Set<Integer> adjacentNodes = network.adjacentNodes(N1); try {",
        "ins2PreCode":"public void adjacentNodes_checkReturnedSetMutability() { addNode(N1); Set<Integer> adjacentNodes = network.adjacentNodes(N1); try { adjacentNodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testSerialization() { DefaultXYZDataset d1 = new DefaultXYZDataset(); DefaultXYZDataset d2 = TestUtils.serialised(d1); assertEquals(d1, d2);   double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[] z1 = new double[] {7.0, 8.0, 9.0}; double[][] data1 = new double[][] {x1, y1, z1}; d1.addSeries(\"S1\", data1); d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"public void testSerialization() { DefaultXYZDataset d1 = new DefaultXYZDataset(); DefaultXYZDataset d2 = (DefaultXYZDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[] z1 = new double[] {7.0, 8.0, 9.0}; double[][] data1 = new double[][] {x1, y1, z1}; d1.addSeries(\"S1\", data1); d2 = (DefaultXYZDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":" DefaultXYDataset d1 = new DefaultXYDataset(); DefaultXYDataset d2 = (DefaultXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[][] data1 = new double[][] {x1, y1}; d1.addSeries(\"S1\", data1); d2 = (DefaultXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, SecurityFilterChain.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins2PreCode":"void matchWithExcludeFilter() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithExcludeFilter.class); assertThat(excludes(filter, Controller1.class)).isTrue(); assertThat(excludes(filter, Controller2.class)).isFalse(); assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = this.httpClientBuilder.get().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "ins1PreCode":"new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "ins2PreCode":"new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "label":1
    },
    {
        "ins1CurCode":"Supplier<U> bufferSupplier, long timespan, long timeskip, TimeUnit unit, Worker w) { super(actual, new MpscLinkedQueue<>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan; this.timeskip = timeskip; this.unit = unit; this.w = w; this.buffers = new LinkedList<>();",
        "ins1PreCode":"Supplier<U> bufferSupplier, long timespan, long timeskip, TimeUnit unit, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan; this.timeskip = timeskip; this.unit = unit; this.w = w; this.buffers = new LinkedList<U>();",
        "ins2PreCode":"Supplier<U> bufferSupplier, long timespan, long timeskip, TimeUnit unit, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan; this.timeskip = timeskip; this.unit = unit; this.w = w; this.buffers = new LinkedList<U>();",
        "label":1
    },
    {
        "ins1CurCode":"return Observable.just(1); } }, true, 16, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"return Observable.just(1); } }, 16, true, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"return Flowable.just(1); } }, 16, true, ImmediateThinScheduler.INSTANCE) .test()",
        "label":1
    },
    {
        "ins1CurCode":"public R poll() { Iterator<? extends R> iterator = it;",
        "ins1PreCode":"public R poll() throws Exception { Iterator<? extends R> iterator = it;",
        "ins2PreCode":"public R poll() throws Exception { Iterator<? extends R> iterator = it;",
        "label":1
    },
    {
        "ins1CurCode":"int count = 128 * 1024;  resp.setContentLengthLong(count * 2L); ",
        "ins1PreCode":"int count = 128 * 1024;  resp.setContentLengthLong(count * 2); ",
        "ins2PreCode":"protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {  resp.setContentType(\"application/octet-stream\");  int count = 4 * 1024;  resp.setContentLengthLong(count * 2);  OutputStream os = resp.getOutputStream(); byte[] data = new byte[2]; for (int i = 0; i < count; i++) { data[0] = (byte) (i & 0xFF); data[1] = (byte) ((i >> 8) & 0xFF); os.write(data); }",
        "label":0
    },
    {
        "ins1CurCode":"public Collection<Feature> allAvailableFeatures(Object arole) { LOG.log(Level.INFO, \"allAvailableFeatures start\");  if (arole instanceof ClassifierRole) { try { List<Feature> returnList = new ArrayList<Feature>(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableFeatures(genElem)); } } for (Classifier classifier : role.getBase()) { returnList.addAll(classifier.getFeature()); } LOG.log(Level.INFO, \"allAvailableFeatures {0}\", returnList.size()); return returnList;",
        "ins1PreCode":"public Collection<Feature> allAvailableFeatures(Object arole) { LOG.info(\"allAvailableFeatures start\");  if (arole instanceof ClassifierRole) { try { List<Feature> returnList = new ArrayList<Feature>(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableFeatures(genElem)); } } for (Classifier classifier : role.getBase()) { returnList.addAll(classifier.getFeature()); } LOG.info(\"allAvailableFeatures \" + returnList.size()); return returnList;",
        "ins2PreCode":"public Collection allAvailableContents(Object arole) { LOG.info(\"allAvailableContents start\"); try { if (arole instanceof ClassifierRole) { List returnList = new ArrayList(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableContents(genElem)); } } for (Classifier baseClassifier : role.getBase()) { returnList.addAll(baseClassifier.getOwnedElement()); } LOG.info(\"allAvailableContents \" + returnList.size()); return returnList;",
        "label":0
    },
    {
        "ins1CurCode":"} catch (InvocationTargetException ex) { DBWorkbench.getPlatformUI().showError( \"Import error\",",
        "ins1PreCode":"} catch (InvocationTargetException ex) { DBUserInterface.getInstance().showError( \"Import error\",",
        "ins2PreCode":"} catch (InvocationTargetException ex) { DBUserInterface.getInstance().showError( \"Export error\",",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtPredicateMatch() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void assertValueAtPredicateMatch() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void assertValueAtInvalidIndex() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CustomXYToolTipGenerator g1 = new CustomXYToolTipGenerator(); CustomXYToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CustomXYToolTipGenerator g1 = new CustomXYToolTipGenerator(); CustomXYToolTipGenerator g2 = (CustomXYToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowItemLabelGenerator g1 = new HighLowItemLabelGenerator(); HighLowItemLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":" try { v = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);  ParallelFailureHandling h;  try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "ins1PreCode":" try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);  ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "ins2PreCode":" try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "label":0
    },
    {
        "ins1CurCode":"Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "ins1PreCode":"Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "ins2PreCode":"Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicate).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\"));",
        "label":1
    },
    {
        "ins1CurCode":"User user = database.findUser(username); if (user == null) { return null; } try { ObjectName oname = MBeanUtils.createObjectName(managedUser.getDomain(), user); return oname.toString(); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException( \"Cannot create object name for user [\" + username + \"]\"); iae.initCause(e);",
        "ins1PreCode":"public String findUser(String username) {  UserDatabase database = (UserDatabase) this.resource; User user = database.findUser(username); if (user == null) { return (null); } try { ObjectName oname = MBeanUtils.createObjectName(managedUser.getDomain(), user); return (oname.toString()); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for user [\" + username + \"]\"); iae.initCause(e); throw iae; } ",
        "ins2PreCode":"public void removeUser(String username) {  UserDatabase database = (UserDatabase) this.resource; User user = database.findUser(username); if (user == null) { return; } try { MBeanUtils.destroyMBean(user); database.removeUser(user); } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying user [\" + username + \"] MBean\"); iae.initCause(e); throw iae; } ",
        "label":0
    },
    {
        "ins1CurCode":"g2.setFont(getFont()); FontMetrics fm = g2.getFontMetrics(getFont()); Rectangle2D bounds = TextUtils.getTextBounds(getText(), g2, fm); if (bounds.getWidth() <= w) {",
        "ins1PreCode":"g2.setFont(getFont()); FontMetrics fm = g2.getFontMetrics(getFont()); Rectangle2D bounds = TextUtilities.getTextBounds(getText(), g2, fm); if (bounds.getWidth() <= w) {",
        "ins2PreCode":"g2.setFont(getFont()); FontMetrics fm = g2.getFontMetrics(getFont()); Rectangle2D bounds = TextUtilities.getTextBounds(getText(), g2, fm); if (bounds.getWidth() <= widthRange.getUpperBound()",
        "label":1
    },
    {
        "ins1CurCode":"Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = MoreObjects.toStringHelper(o10).toString(); assertEquals(\"{}\", toTest);",
        "ins1PreCode":"Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = Objects.toStringHelper(o10).toString(); assertEquals(\"{}\", toTest);",
        "ins2PreCode":"Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = Objects.toStringHelper(o10).toString(); assertTrue(toTest, toTest.matches(\".*\\\\{\\\\}\"));",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "ins1PreCode":"org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(getProject() .resolveFile(\"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "ins2PreCode":"org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(getProject() .resolveFile(\"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testLessFieldsThanHeaders() { int numItems = randomIntBetween(4, 10);",
        "ins1PreCode":"public void testLessFieldsThanHeaders() throws Exception { int numItems = randomIntBetween(4, 10);",
        "ins2PreCode":"public void testEmptyFields() throws Exception { int numItems = randomIntBetween(5, 10);",
        "label":1
    },
    {
        "ins1CurCode":"void servletPropertySourcesAreNotCopiedOverIfNotWebEnvironment() { StandardServletEnvironment standardServletEnvironment = new StandardServletEnvironment();",
        "ins1PreCode":"public void servletPropertySourcesAreNotCopiedOverIfNotWebEnvironment() { StandardServletEnvironment standardServletEnvironment = new StandardServletEnvironment();",
        "ins2PreCode":"public void servletPropertySourcesArePresentWhenTypeToConvertIsWeb() { StandardEnvironment standardEnvironment = new StandardEnvironment();",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CandlestickRenderer r1 = new CandlestickRenderer(); CandlestickRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CandlestickRenderer r1 = new CandlestickRenderer(); CandlestickRenderer r2 = (CandlestickRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { XYDotRenderer r1 = new XYDotRenderer(); XYDotRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"patternBank.put(\"TWO\", \"2\"); patternBank.put(\"THREE\", \"3\"); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), null, patternBank, Arrays.asList(\"%{ONE:one}\", \"%{TWO:two}\", \"%{THREE:three}\"), fieldName, false, false, MatcherWatchdog.noop());",
        "ins1PreCode":"patternBank.put(\"TWO\", \"2\"); patternBank.put(\"THREE\", \"3\"); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), patternBank, Arrays.asList(\"%{ONE:one}\", \"%{TWO:two}\", \"%{THREE:three}\"), fieldName, false, false, MatcherWatchdog.noop());",
        "ins2PreCode":"patternBank.put(\"TWO\", \"2\"); patternBank.put(\"THREE\", \"3\"); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), patternBank, Arrays.asList(\"%{ONE:one}\", \"%{TWO:two}\", \"%{THREE:three}\"), fieldName, true, false, MatcherWatchdog.noop());",
        "label":1
    },
    {
        "ins1CurCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPhoneNumber(1); Assertions.assertEquals(\"User1\", user.getName()); Assertions.assertEquals(Long.valueOf(12345678901L), user.getPhone()); }",
        "ins1PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPhoneNumber(1); Assert.assertEquals(\"User1\", user.getName()); Assert.assertEquals(Long.valueOf(12345678901L), user.getPhone()); }",
        "ins2PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); Assert.assertEquals(\"User1\", user.getName()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testParseTld21() throws Exception { TaglibXml xml = parse(\"test/webapp-3.1/WEB-INF/tags21.tld\"); Assert.assertEquals(\"1.0\", xml.getTlibVersion());",
        "ins1PreCode":"public void testParseTld21() throws Exception { try (FileInputStream is = new FileInputStream(WEBAPP + \"tags21.tld\")) { InputSource source = new InputSource(is); TaglibXml xml = parser.parse(source); Assert.assertEquals(\"1.0\", xml.getTlibVersion());",
        "ins2PreCode":"public void testParseTld11() throws Exception { try (FileInputStream is = new FileInputStream(WEBAPP + \"tags11.tld\")) { InputSource source = new InputSource(is); TaglibXml xml = parser.parse(source); Assert.assertEquals(\"1.0\", xml.getTlibVersion());",
        "label":1
    },
    {
        "ins1CurCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); }",
        "ins1PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getPercentComplete(r,",
        "ins2PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getPercentComplete(r,",
        "label":0
    },
    {
        "ins1CurCode":"byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); }",
        "ins1PreCode":" Assert.assertEquals( HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));  hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); }",
        "ins2PreCode":" Assert.assertEquals( hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));  hashcodes.add(hasher.hashUnsafeWords( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); }",
        "label":1
    },
    {
        "ins1CurCode":"void gitFullDetailsAlwaysPresent() { this.contextRunner.run((context) -> { CloudFoundryInfoEndpointWebExtension extension = context",
        "ins1PreCode":"void gitFullDetailsAlwaysPresent() { this.contextRunner.withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO)) .run((context) -> { CloudFoundryInfoEndpointWebExtension extension = context",
        "ins2PreCode":"void gitFullDetailsAlwaysPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\").run((context) -> { CloudFoundryInfoEndpointWebExtension extension = context .getBean(CloudFoundryInfoEndpointWebExtension.class); Map<String, Object> git = (Map<String, Object>) extension.info().get(\"git\"); Map<String, Object> commit = (Map<String, Object>) git.get(\"commit\"); assertThat(commit).hasSize(4); });",
        "label":0
    },
    {
        "ins1CurCode":"}  DBeaverNotifications.showNotification( context.getDataSource(),",
        "ins1PreCode":"}  NotificationUtils.sendNotification( context.getDataSource(),",
        "ins2PreCode":"DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { try (DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\")) { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } } } });",
        "label":0
    },
    {
        "ins1CurCode":"void imageBannerAndTextBanner(CapturedOutput output) { SpringApplication application = new SpringApplication(ExampleConfig.class); MockResourceLoader resourceLoader = new MockResourceLoader(); resourceLoader.addResource(\"banner.gif\", \"black-and-white.gif\"); resourceLoader.addResource(\"banner.txt\", \"foobar.txt\"); application.setWebApplicationType(WebApplicationType.NONE); application.setResourceLoader(resourceLoader); application.run(); assertThat(output).contains(\"@@@@\").contains(\"Foo Bar\");",
        "ins1PreCode":"void imageBannerAndTextBanner(CapturedOutput capturedOutput) { SpringApplication application = new SpringApplication(ExampleConfig.class); MockResourceLoader resourceLoader = new MockResourceLoader(); resourceLoader.addResource(\"banner.gif\", \"black-and-white.gif\"); resourceLoader.addResource(\"banner.txt\", \"foobar.txt\"); application.setWebApplicationType(WebApplicationType.NONE); application.setResourceLoader(resourceLoader); application.run(); assertThat(capturedOutput).contains(\"@@@@\").contains(\"Foo Bar\");",
        "ins2PreCode":"void imageBannerLoads(CapturedOutput capturedOutput) { SpringApplication application = new SpringApplication(ExampleConfig.class); MockResourceLoader resourceLoader = new MockResourceLoader(); resourceLoader.addResource(\"banner.gif\", \"black-and-white.gif\"); application.setWebApplicationType(WebApplicationType.NONE); application.setResourceLoader(resourceLoader); application.run(); assertThat(capturedOutput).contains(\"@@@@@@\");",
        "label":1
    },
    {
        "ins1CurCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins1PreCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); author2.getId();",
        "ins2PreCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); author2.getId();",
        "label":1
    },
    {
        "ins1CurCode":"}); } }, true, 2, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"}); } }, 2, true, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"}); } }, 2, false, ImmediateThinScheduler.INSTANCE) .test()",
        "label":1
    },
    {
        "ins1CurCode":"final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();  final TestObserver<Integer> to1 = new TestObserver<>(); final TestObserver<Integer> to2 = new TestObserver<>(); ",
        "ins1PreCode":"final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>(); final TestObserver<Integer> to2 = new TestObserver<Integer>(); ",
        "ins2PreCode":"final ConnectableObservable<Integer> co = Observable.range(1, 3).replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>(); final TestObserver<Integer> to2 = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void visitWhile(SWhile userWhileNode, ScriptScope scriptScope) { WhileLoopNode irWhileLoopNode = new WhileLoopNode(userWhileNode.getLocation()); irWhileLoopNode.setConditionNode(injectCast(userWhileNode.getConditionNode(), scriptScope));",
        "ins1PreCode":"public void visitWhile(SWhile userWhileNode, ScriptScope scriptScope) { WhileLoopNode irWhileLoopNode = new WhileLoopNode(); irWhileLoopNode.setConditionNode(injectCast(userWhileNode.getConditionNode(), scriptScope)); irWhileLoopNode.setBlockNode((BlockNode)visit(userWhileNode.getBlockNode(), scriptScope)); irWhileLoopNode.setLocation(userWhileNode.getLocation()); irWhileLoopNode.setContinuous(scriptScope.getCondition(userWhileNode, ContinuousLoop.class));",
        "ins2PreCode":"public void visitDo(SDo userDoNode, ScriptScope scriptScope) { DoWhileLoopNode irDoWhileLoopNode = new DoWhileLoopNode(); irDoWhileLoopNode.setConditionNode(injectCast(userDoNode.getConditionNode(), scriptScope)); irDoWhileLoopNode.setBlockNode((BlockNode)visit(userDoNode.getBlockNode(), scriptScope)); irDoWhileLoopNode.setLocation(userDoNode.getLocation()); irDoWhileLoopNode.setContinuous(scriptScope.getCondition(userDoNode, ContinuousLoop.class));",
        "label":1
    },
    {
        "ins1CurCode":"});  final ArrayList<String> list = new ArrayList<>(); os.subscribe(new Consumer<String>() {",
        "ins1PreCode":"});  final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new Consumer<String>() {",
        "ins2PreCode":"});  final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new Consumer<String>() {",
        "label":1
    },
    {
        "ins1CurCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<>(subscriber, 0L); ",
        "ins1PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber, 0L); ",
        "ins2PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber, 0L);  @SuppressWarnings(\"unchecked\") TestObservable<Flowable<String>> observableOfObservables = new TestObservable<Flowable<String>>(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2)); Flowable<String> concatF = Flowable.concat(Flowable.unsafeCreate(observableOfObservables));",
        "label":1
    },
    {
        "ins1CurCode":"}  if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new byte[newSize]; ",
        "ins1PreCode":"if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit >0 && newSize > limit ) { newSize=limit; } tmp=new byte[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) { newSize=limit; } tmp=new byte[newSize]; }",
        "ins2PreCode":"if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit >0 && newSize > limit ) { newSize=limit; } tmp=new char[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) { newSize=limit; } tmp=new char[newSize]; }",
        "label":1
    },
    {
        "ins1CurCode":"public final MapinitializerContext mapinitializer() throws RecognitionException { MapinitializerContext _localctx = new MapinitializerContext(_ctx, getState()); enterRule(_localctx, 64, RULE_mapinitializer); int _la; try { setState(509); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,50,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(495); match(LBRACE); setState(496); maptoken(); setState(501); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(497); match(COMMA); setState(498); maptoken(); } } setState(503); _errHandler.sync(this); _la = _input.LA(1); } setState(504); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(506); match(LBRACE); setState(507); match(COLON); setState(508); match(RBRACE);",
        "ins1PreCode":"public final MapinitializerContext mapinitializer() throws RecognitionException { MapinitializerContext _localctx = new MapinitializerContext(_ctx, getState()); enterRule(_localctx, 54, RULE_mapinitializer); int _la; try { setState(448); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,42,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(434); match(LBRACE); setState(435); maptoken(); setState(440); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(436); match(COMMA); setState(437); maptoken(); } } setState(442); _errHandler.sync(this); _la = _input.LA(1); } setState(443); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(445); match(LBRACE); setState(446); match(COLON); setState(447); match(RBRACE);",
        "ins2PreCode":"public final ListinitializerContext listinitializer() throws RecognitionException { ListinitializerContext _localctx = new ListinitializerContext(_ctx, getState()); enterRule(_localctx, 52, RULE_listinitializer); int _la; try { setState(432); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(419); match(LBRACE); setState(420); expression(); setState(425); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(421); match(COMMA); setState(422); expression(); } } setState(427); _errHandler.sync(this); _la = _input.LA(1); } setState(428); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(430); match(LBRACE); setState(431); match(RBRACE);",
        "label":0
    },
    {
        "ins1CurCode":"public void errorDetaches() throws Exception { Disposable d = Disposable.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "ins1PreCode":"public void errorDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "ins2PreCode":"public void errorDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "label":1
    },
    {
        "ins1CurCode":"public void cancelNoConcurrentClean() { TestObserver<Integer> to = new TestObserver<>(); ConcatMapSingleMainObserver<Integer, Integer> operator = new ConcatMapSingleMainObserver<>( to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);",
        "ins1PreCode":"public void cancelNoConcurrentClean() { TestObserver<Integer> to = new TestObserver<Integer>(); ConcatMapSingleMainObserver<Integer, Integer> operator = new ConcatMapSingleMainObserver<Integer, Integer>( to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);",
        "ins2PreCode":"public void cancelNoConcurrentClean() { TestObserver<Integer> to = new TestObserver<Integer>(); ConcatMapMaybeMainObserver<Integer, Integer> operator = new ConcatMapMaybeMainObserver<Integer, Integer>( to, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput capturedOutput) { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\") .run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(capturedOutput).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins1PreCode":"public void shouldNotDenyNorLogIfMaxUrisIsNotReached() { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\") .run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.output.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins2PreCode":"public void shouldNotDenyNorLogIfMaxUrisIsNotReached() { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\") .run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.output.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "label":1
    },
    {
        "ins1CurCode":"context.getBean(DataSource.class)); context.close(); verify(statement, never()).execute(\"SHUTDOWN\");",
        "ins1PreCode":"context.getBean(DataSource.class)); context.close(); verify(statement, times(0)).execute(\"SHUTDOWN\");",
        "ins2PreCode":"public void inMemoryHsqlIsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class)); context.close(); verify(statement, times(1)).execute(\"SHUTDOWN\");",
        "label":0
    },
    {
        "ins1CurCode":"this.chart.addChangeListener(l);  @SuppressWarnings(\"unchecked\") XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "ins2PreCode":"public void testReplaceDataset() {   XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1);  LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "label":0
    },
    {
        "ins1CurCode":"MavenProject projectA = createSucceededMavenProject( \"A\" ); MavenProject projectB = createFailedMavenProject( \"B\" ); MavenProject projectC = createSkippedMavenProject( \"C\" ); projectC.setDependencies( singletonList( toDependency( projectB ) ) ); executionResult.setTopologicallySortedProjects( asList( projectA, projectB, projectC ) );  Optional<BuildResumptionData> result = analyzer.determineBuildResumptionData( executionResult );  assertThat( result.isPresent(), is( true ) ); assertThat( result.get().getRemainingProjects(), is( asList( \"test:B\", \"test:C\" ) ) );",
        "ins1PreCode":"MavenProject projectA = createSucceededMavenProject( \"A\" ); MavenProject projectB = createFailedMavenProject( \"B\" ); MavenProject projectC = createSucceededMavenProject( \"C\" ); projectC.setDependencies( singletonList( toDependency( projectB ) ) ); executionResult.setTopologicallySortedProjects( asList( projectA, projectB, projectC ) );  Optional<BuildResumptionData> result = analyzer.determineBuildResumptionData( executionResult );  assertThat( result.isPresent(), is( true ) ); assertThat( result.get().getProjectsToSkip().isEmpty(), is( true ) );",
        "ins2PreCode":" assertThat( result.isPresent(), is( true ) ); assertThat( result.get().getResumeFrom(), is( Optional.of ( \"test:B\" ) ) ); assertThat( result.get().getProjectsToSkip(), contains( \"test:C\" ) ); assertThat( result.get().getProjectsToSkip(), not( contains( \"test:D\" ) ) );",
        "label":0
    },
    {
        "ins1CurCode":"protected void doAssertLuceneQuery(HasChildQueryBuilder queryBuilder, Query query, QueryShardContext context) throws IOException { assertThat(query, instanceOf(LateParsingQuery.class)); LateParsingQuery lpq = (LateParsingQuery) query; assertEquals(queryBuilder.minChildren(), lpq.getMinChildren());",
        "ins1PreCode":"protected void doAssertLuceneQuery(HasChildQueryBuilder queryBuilder, Query query, QueryShardContext context) throws IOException { assertThat(query, instanceOf(HasChildQueryBuilder.LateParsingQuery.class)); HasChildQueryBuilder.LateParsingQuery lpq = (HasChildQueryBuilder.LateParsingQuery) query; assertEquals(queryBuilder.minChildren(), lpq.getMinChildren());",
        "ins2PreCode":"protected void doAssertLuceneQuery(HasParentQueryBuilder queryBuilder, Query query, QueryShardContext context) throws IOException { assertThat(query, instanceOf(HasChildQueryBuilder.LateParsingQuery.class)); HasChildQueryBuilder.LateParsingQuery lpq = (HasChildQueryBuilder.LateParsingQuery) query; assertEquals(queryBuilder.score() ? ScoreMode.Max : ScoreMode.None, lpq.getScoreMode());",
        "label":1
    },
    {
        "ins1CurCode":"Name.root);  RRset set = new RRset(); set.addRR(txt);",
        "ins1PreCode":"Name.root);  RRset<TXTRecord> set = new RRset<>(); set.addRR(txt);",
        "ins2PreCode":"Name.root);  RRset<TXTRecord> set = new RRset<>(); set.addRR(txt);",
        "label":1
    },
    {
        "ins1CurCode":"public void ignoresUnmappedUrl() throws Exception { this.context = getContext( () -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins1PreCode":"public void ignoresUnmappedUrl() throws Exception { loadContext(\"spring.devtools.remote.secret:supersecret\"); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins2PreCode":"public void ignoresIfMissingSecretFromRequest() throws Exception { loadContext(\"spring.devtools.remote.secret:supersecret\"); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "label":1
    },
    {
        "ins1CurCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtils.writePaint(this.paint, stream); SerialUtils.writePaint(this.backgroundPaint, stream); SerialUtils.writePaint(this.outlinePaint, stream); SerialUtils.writeStroke(this.outlineStroke, stream);",
        "ins1PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.paint, stream); SerialUtilities.writePaint(this.backgroundPaint, stream); SerialUtilities.writePaint(this.outlinePaint, stream); SerialUtilities.writeStroke(this.outlineStroke, stream);",
        "ins2PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.paint, stream); SerialUtilities.writePaint(this.backgroundPaint, stream); SerialUtilities.writePaint(this.outlinePaint, stream); SerialUtilities.writeStroke(this.outlineStroke, stream);",
        "label":1
    },
    {
        "ins1CurCode":"return m; } Class<?>[] interfaces = type.getInterfaces(); Method mp = null; for (Class<?> iface : interfaces) { try { mp = iface.getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp);",
        "ins1PreCode":"return m; } Class<?>[] inf = type.getInterfaces(); Method mp = null; for (Class<?> aClass : inf) { try { mp = aClass.getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp);",
        "ins2PreCode":"return m; } Class<?>[] inf = type.getInterfaces(); Method mp = null; for (Class<?> aClass : inf) { try { mp = aClass.getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp);",
        "label":1
    },
    {
        "ins1CurCode":"public void removeNode_existingNodeWithSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void removeNode_existingNodeWithSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void removeNode_existingNodeWithSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"PublishProcessor<Integer> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"PublishProcessor<Integer> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"PublishProcessor<Integer> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":" replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) { ",
        "ins1PreCode":" replaceEntries.put(filepath, genericEntry); } else if (!genericEntry.getName() .equals(\"META-INF/MANIFEST.MF\")) { ",
        "ins2PreCode":"protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) { boolean rebuild = false;  JarFile genericJar = null; JarFile wasJar = null; File newwasJarFile = null; JarOutputStream newJarStream = null; ClassLoader genericLoader = null;  try { log(\"Checking if websphere Jar needs to be rebuilt for jar \" + websphereJarFile.getName(), Project.MSG_VERBOSE);  if (genericJarFile.exists() && genericJarFile.isFile() && websphereJarFile.exists() && websphereJarFile.isFile()) {  genericJar = new JarFile(genericJarFile); wasJar = new JarFile(websphereJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wasEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wasEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wasEntries.containsKey(filepath)) {   JarEntry genericEntry = genericEntries.get(filepath); JarEntry wasEntry = wasEntries.get(filepath);  if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; } break; } } } else {   log(\"File \" + filepath + \" not present in websphere jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newwasJarFile = new File(websphereJarFile.getAbsolutePath() + \".temp\"); if (newwasJarFile.exists()) { newwasJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newwasJarFile.toPath())); newJarStream.setLevel(0);   for (Enumeration<JarEntry> e = wasEntries.elements(); e.hasMoreElements();) { JarEntry je = e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }  InputStream is;  if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wasJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"websphere Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { throw new BuildException( \"ClassNotFoundException while processing ejb-jar file. Details: \" + cnfe.getMessage(), cnfe); } catch (IOException ioe) { throw new BuildException( \"IOException while processing ejb-jar file . Details: \" + ioe.getMessage(), ioe); } finally {  FileUtils.close(genericJar); FileUtils.close(wasJar); FileUtils.close(newJarStream);  if (newJarStream != null) { try { FILE_UTILS.rename(newwasJarFile, websphereJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true; } } if (genericLoader != null && genericLoader instanceof AntClassLoader) { @SuppressWarnings(\"resource\") AntClassLoader loader = (AntClassLoader) genericLoader; loader.cleanup(); } } return rebuild;",
        "label":0
    },
    {
        "ins1CurCode":"protected String expireSessions(String path, HttpServletRequest req, StringManager smClient) { int idle = -1; String idleParam = req.getParameter(\"idle\"); if (idleParam != null) { try { idle = Integer.parseInt(idleParam); } catch (NumberFormatException e) { log(\"Could not parse idle parameter to an int: \" + idleParam); } } return sessions(path, idle, smClient);",
        "ins1PreCode":"protected String expireSessions(String path, HttpServletRequest req) { int idle = -1; String idleParam = req.getParameter(\"idle\"); if (idleParam != null) { try { idle = Integer.parseInt(idleParam); } catch (NumberFormatException e) { log(\"Could not parse idle parameter to an int: \" + idleParam); } } return sessions(path, idle);",
        "ins2PreCode":"protected void expireSessions(PrintWriter writer, String path, HttpServletRequest req) { int idle = -1; String idleParam = req.getParameter(\"idle\"); if (idleParam != null) { try { idle = Integer.parseInt(idleParam); } catch (NumberFormatException e) { log(\"Could not parse idle parameter to an int: \" + idleParam); } } sessions(writer, path, idle);",
        "label":1
    },
    {
        "ins1CurCode":" JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> mapped = stream.mapPartitions(in -> { StringBuilder out = new StringBuilder();",
        "ins1PreCode":" JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> mapped = stream.mapPartitions( new FlatMapFunction<Iterator<String>, String>() { @Override public Iterator<String> call(Iterator<String> in) { StringBuilder out = new StringBuilder();",
        "ins2PreCode":"out = out + in.next().toUpperCase(); } return Lists.newArrayList(out).iterator(); });",
        "label":0
    },
    {
        "ins1CurCode":"protected void applyToCategoryItemRenderer(CategoryItemRenderer renderer) { Args.nullNotPermitted(renderer, \"renderer\"); ",
        "ins1PreCode":"protected void applyToCategoryItemRenderer(CategoryItemRenderer renderer) { ParamChecks.nullNotPermitted(renderer, \"renderer\"); ",
        "ins2PreCode":"protected void applyToXYItemRenderer(XYItemRenderer renderer) { ParamChecks.nullNotPermitted(renderer, \"renderer\"); if (renderer instanceof AbstractRenderer) {",
        "label":1
    },
    {
        "ins1CurCode":"public void producerRequestThroughTake() { TestSubscriber<Integer> ts = new TestSubscriber<>(3); final AtomicLong requested = new AtomicLong();",
        "ins1PreCode":"public void producerRequestThroughTake() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(3); final AtomicLong requested = new AtomicLong();",
        "ins2PreCode":"public void producerRequestThroughTakeIsModified() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(3); final AtomicLong requested = new AtomicLong();",
        "label":1
    },
    {
        "ins1CurCode":"public void doOnError() { final AtomicReference<Throwable> r = new AtomicReference<>(); Throwable t = null;",
        "ins1PreCode":"public void doOnError() { final AtomicReference<Throwable> r = new AtomicReference<Throwable>(); Throwable t = null;",
        "ins2PreCode":"public void doOnError() { final AtomicReference<Throwable> r = new AtomicReference<Throwable>(); Throwable t = null;",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final ExasolTableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1CurCode":"Method[] methods = getClassMethods(cls); for (Method method : methods) { if (method.getParameterTypes().length > 0) { continue; } String name = method.getName(); if ((name.startsWith(\"get\") && name.length() > 3) || (name.startsWith(\"is\") && name.length() > 2)) { name = PropertyNamer.methodToProperty(name);",
        "ins1PreCode":"for (Method method : methods) { String name = method.getName(); if (name.startsWith(\"get\") && name.length() > 3) { if (method.getParameterTypes().length == 0) { name = PropertyNamer.methodToProperty(name); addMethodConflict(conflictingGetters, name, method); } } else if (name.startsWith(\"is\") && name.length() > 2) { if (method.getParameterTypes().length == 0) { name = PropertyNamer.methodToProperty(name);",
        "ins2PreCode":"private void addSetMethods(Class<?> cls) { Map<String, List<Method>> conflictingSetters = new HashMap<String, List<Method>>(); Method[] methods = getClassMethods(cls); for (Method method : methods) { String name = method.getName(); if (name.startsWith(\"set\") && name.length() > 3) { if (method.getParameterTypes().length == 1) { name = PropertyNamer.methodToProperty(name); addMethodConflict(conflictingSetters, name, method); } } } resolveSetterConflicts(conflictingSetters);",
        "label":0
    },
    {
        "ins1CurCode":"void testGetNamesWithArray() throws SQLException { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testGetNamesWithArray() throws SQLException { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testGetNamesWithArray_a2() throws SQLException { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); skipTokens(st, 3); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins1PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins2PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "label":1
    },
    {
        "ins1CurCode":"URL url = new URL(null, \"jar:\" + testJar.toURI().toURL() + \"!/nested.jar!/3.dat\", this.handler); JarURLConnection connection = (JarURLConnection) url.openConnection(); JarFile jarFile = JarFileWrapper.unwrap(connection.getJarFile()); try { assertThat(jarFile.getRootJarFile().getFile()).isEqualTo(testJar); } finally { jarFile.close(); }",
        "ins1PreCode":"JarURLConnection connection = (JarURLConnection) url.openConnection(); try { assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); } finally { connection.getJarFile().close(); }",
        "ins2PreCode":"JarURLConnection connection = (JarURLConnection) url.openConnection(); try { assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); } finally { connection.getJarFile().close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testPoolThreads20Connections10() throws Exception { System.out.println(\"[testPoolThreads20Connections10] Starting fairness - Tomcat JDBC - Non Fair\"); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(false); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",this.datasource.getSize(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\");",
        "ins1PreCode":"public void testPoolThreads20Connections10() throws Exception { System.out.println(\"[testPoolThreads20Connections10] Starting fairness - Tomcat JDBC - Non Fair\"); init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(false); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",this.datasource.getSize(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "ins2PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { System.out.println(\"[testPoolThreads20Connections10Fair] Starting fairness - Tomcat JDBC - Fair\"); init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10Fair\",this.datasource.getSize(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); TestUtils.checkIndependence(r1, r2);",
        "ins1PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowRenderer r1 = new HighLowRenderer(); r1.setCloseTickPaint(Color.green); HighLowRenderer r2 = CloneUtils.clone(r1);",
        "label":0
    },
    {
        "ins1CurCode":"public void testList() { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "ins1PreCode":"public void testList() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "ins2PreCode":"public void testInetAddress() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "label":1
    },
    {
        "ins1CurCode":"void testApplicationProperties() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins1PreCode":"public void testApplicationProperties() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins2PreCode":"public void testNullApplicationProperties() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "label":1
    },
    {
        "ins1CurCode":"} catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(sm.getString(\"standardServer.storeConfig.contextError\", context.getName()), t); }",
        "ins1PreCode":"} catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); }",
        "ins2PreCode":"} catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); }",
        "label":0
    },
    {
        "ins1CurCode":"\"/test/script-expr.jsp\"); String result = res.toString(); assertTrue(result.indexOf(\"00-hello world\") > 0); assertTrue(result.indexOf(\"01-hello \\\"world\") > 0);",
        "ins1PreCode":"\"/test/script-expr.jsp\"); String result = res.toString(); System.out.println(result); assertTrue(result.indexOf(\"00-hello world\") > 0);",
        "ins2PreCode":"public void testBug45427() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/bug45427.jsp\");  String result = res.toString();  assertTrue(result.indexOf(\"00-hello world\") > 0); assertTrue(result.indexOf(\"01-hello 'world\") > 0); assertTrue(result.indexOf(\"02-hello \\\"world\") > 0); assertTrue(result.indexOf(\"03-hello world\") > 0); assertTrue(result.indexOf(\"04-hello 'world\") > 0); assertTrue(result.indexOf(\"05-hello \\\"world\") > 0); assertTrue(result.indexOf(\"06-hello world\") > 0); assertTrue(result.indexOf(\"07-hello 'world\") > 0); assertTrue(result.indexOf(\"08-hello \\\"world\") > 0); assertTrue(result.indexOf(\"09-hello world\") > 0); assertTrue(result.indexOf(\"10-hello 'world\") > 0); assertTrue(result.indexOf(\"11-hello \\\"world\") > 0); assertTrue(result.indexOf(\"12-hello world\") > 0); assertTrue(result.indexOf(\"13-hello 'world\") > 0); assertTrue(result.indexOf(\"14-hello \\\"world\") > 0); assertTrue(result.indexOf(\"15-hello world\") > 0); assertTrue(result.indexOf(\"16-hello 'world\") > 0); assertTrue(result.indexOf(\"17-hello \\\"world\") > 0);",
        "label":0
    },
    {
        "ins1CurCode":"ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297MultipleImport2.jsp\", res, null); ",
        "ins1PreCode":"ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297MultipleImport2.jsp\", res, new HashMap<String,List<String>>()); ",
        "ins2PreCode":"ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297Tag.jsp\", res, new HashMap<String,List<String>>()); ",
        "label":1
    },
    {
        "ins1CurCode":"theFile = chooser.getSelectedFile(); if (theFile != null) { Model.getExtensionMechanismsHelper().makeProfileApplicable( undeployedProfile); String name = theFile.getName();",
        "ins1PreCode":"theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name);",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { PersistenceManager pm = PersistenceManager.getInstance();  JFileChooser chooser = new JFileChooser(); chooser.setDialogTitle(Translator.localize( \"action.export-project-as-xmi\")); chooser.setFileView(ProjectFileView.getInstance()); chooser.setApproveButtonText(Translator.localize( \"filechooser.export\")); chooser.setAcceptAllFileFilterUsed(true); pm.setXmiFileChooserFilter(chooser);  String fn = Configuration.getString( PersistenceManager.KEY_PROJECT_NAME_PATH); if (fn.length() > 0) { fn = PersistenceManager.getInstance().getBaseName(fn); chooser.setSelectedFile(new File(fn)); }  int result = chooser.showSaveDialog(ArgoFrame.getFrame()); if (result == JFileChooser.APPROVE_OPTION) { File theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); Configuration.setString( PersistenceManager.KEY_PROJECT_NAME_PATH, PersistenceManager.getInstance().getBaseName( theFile.getPath())); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name); ProjectBrowser.getInstance().trySaveWithProgressMonitor( false, theFile, false); } }",
        "label":0
    },
    {
        "ins1CurCode":"+ \"supported was found in the environment:%n%n\")); append(report, content, (metadata) -> \"Reason: \" + (StringUtils.hasText(metadata.getDeprecation().getReason())",
        "ins1PreCode":"+ \"supported was found in the environment:%n%n\")); append(report, content, metadata -> \"Reason: \" + (StringUtils.hasText(metadata.getDeprecation().getReason())",
        "ins2PreCode":"public String getWarningReport() { Map<String, List<PropertyMigration>> content = getContent( LegacyProperties::getRenamed); if (content.isEmpty()) { return null; } StringBuilder report = new StringBuilder(); report.append(String.format(\"%nThe use of configuration keys that have been \" + \"renamed was found in the environment:%n%n\")); append(report, content, (metadata) -> \"Replacement: \" + metadata.getDeprecation().getReplacement()); report.append(String.format(\"%n\")); report.append(\"Each configuration key has been temporarily mapped to its \" + \"replacement for your convenience. To silence this warning, please \" + \"update your configuration to use the new keys.\"); report.append(String.format(\"%n\")); return report.toString();",
        "label":0
    },
    {
        "ins1CurCode":"long t1 = System.currentTimeMillis();  TreeMap<Integer,ArrayList<ByteEntry>> tempMap = new TreeMap<Integer,ArrayList<ByteEntry>>(); Iterator<ByteEntry> entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = entries.next(); int[] countA = bcStats.get(entry); Integer count = new Integer(countA[0]);  ArrayList<ByteEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<ByteEntry>(); tempMap.put(count, list); } list.add(entry); }  int size = bcStats.size(); if (size > cacheSize) { size = cacheSize; } ByteEntry[] tempbcCache = new ByteEntry[size];   ByteChunk tempChunk = new ByteChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList<ByteEntry> list = tempMap.get(key); for (int i = 0; i < list.size() && n < size; i++) { ByteEntry entry = list.get(i); tempChunk.setBytes(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempbcCache, n); if (insertPos == n) { tempbcCache[n + 1] = entry; } else { System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, insertPos + 2, n - insertPos - 1); tempbcCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } bcCount = 0; bcStats.clear(); bcCache = tempbcCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug(\"ByteCache generation time: \" + (t2 - t1) + \"ms\"); } } else { bcCount++;  ByteEntry entry = new ByteEntry(); entry.value = value; int[] count = bcStats.get(entry); if (count == null) {",
        "ins1PreCode":"long t1 = System.currentTimeMillis();  TreeMap tempMap = new TreeMap(); Iterator entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = (ByteEntry) entries.next(); int[] countA = (int[]) bcStats.get(entry); Integer count = new Integer(countA[0]);  ArrayList list = (ArrayList) tempMap.get(count); if (list == null) {  list = new ArrayList(); tempMap.put(count, list); } list.add(entry); }  int size = bcStats.size(); if (size > cacheSize) { size = cacheSize; } ByteEntry[] tempbcCache = new ByteEntry[size];   ByteChunk tempChunk = new ByteChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList list = (ArrayList) tempMap.get(key); ByteEntry[] list2 = (ByteEntry[]) list.toArray(new ByteEntry[list.size()]); for (int i = 0; i < list.size() && n < size; i++) { ByteEntry entry = (ByteEntry) list.get(i); tempChunk.setBytes(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempbcCache, n); if (insertPos == n) { tempbcCache[n + 1] = entry; } else { System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, insertPos + 2, n - insertPos - 1); tempbcCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } bcCount = 0; bcStats.clear(); bcCache = tempbcCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug(\"ByteCache generation time: \" + (t2 - t1) + \"ms\"); } } else { bcCount++;  ByteEntry entry = new ByteEntry(); entry.value = value; int[] count = (int[]) bcStats.get(entry); if (count == null) {",
        "ins2PreCode":"long t1 = System.currentTimeMillis();  TreeMap tempMap = new TreeMap(); Iterator entries = ccStats.keySet().iterator(); while (entries.hasNext()) { CharEntry entry = (CharEntry) entries.next(); int[] countA = (int[]) ccStats.get(entry); Integer count = new Integer(countA[0]);  ArrayList list = (ArrayList) tempMap.get(count); if (list == null) {  list = new ArrayList(); tempMap.put(count, list); } list.add(entry); }  int size = ccStats.size(); if (size > cacheSize) { size = cacheSize; } CharEntry[] tempccCache = new CharEntry[size];   CharChunk tempChunk = new CharChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList list = (ArrayList) tempMap.get(key); CharEntry[] list2 = (CharEntry[]) list.toArray(new CharEntry[list.size()]); for (int i = 0; i < list.size() && n < size; i++) { CharEntry entry = (CharEntry) list.get(i); tempChunk.setChars(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempccCache, n); if (insertPos == n) { tempccCache[n + 1] = entry; } else { System.arraycopy(tempccCache, insertPos + 1, tempccCache, insertPos + 2, n - insertPos - 1); tempccCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } ccCount = 0; ccStats.clear(); ccCache = tempccCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug(\"CharCache generation time: \" + (t2 - t1) + \"ms\"); } } else { ccCount++;  CharEntry entry = new CharEntry(); entry.value = value; int[] count = (int[]) ccStats.get(entry); if (count == null) {",
        "label":1
    },
    {
        "ins1CurCode":"BibEntry bibtex = new BibEntry(StandardEntryType.Article); BibEntry biblatex = new BibEntry(StandardEntryType.Article); List<BibEntry> entries = Arrays.asList(custom, bibtex, biblatex);  assertEquals(BibDatabaseMode.BIBTEX, BibDatabaseModeDetection.inferMode(new BibDatabase(entries)));",
        "ins1PreCode":"BibEntry bibtex = new BibEntry(StandardEntryType.Article); BibEntry biblatex = new BibEntry(StandardEntryType.Article); Collection<BibEntry> entries = Arrays.asList(custom, bibtex, biblatex);  assertEquals(BibDatabaseMode.BIBTEX, BibDatabaseModeDetection.inferMode(BibDatabases.createDatabase(entries)));",
        "ins2PreCode":"BibEntry bibtex = new BibEntry(StandardEntryType.Article); BibEntry biblatex = new BibEntry(StandardEntryType.MvBook); Collection<BibEntry> entries = Arrays.asList(custom, bibtex, biblatex);  assertEquals(BibDatabaseMode.BIBLATEX, BibDatabaseModeDetection.inferMode(BibDatabases.createDatabase(entries)));",
        "label":1
    },
    {
        "ins1CurCode":"void getEndpointsWhenHasCacheWithTtlShouldCacheReadOperationWithTtlValue() { load(TestEndpoint.class, (id) -> 500L, (discoverer) -> {",
        "ins1PreCode":"public void getEndpointsWhenHasCacheWithTtlShouldCacheReadOperationWithTtlValue() { load(TestEndpoint.class, (id) -> 500L, (discoverer) -> {",
        "ins2PreCode":"public void getEndpointsShouldCacheReadOperations() { load(AdditionalOperationJmxEndpointConfiguration.class, (id) -> 500L, (discoverer) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); assertMatcher(matcher, \"/actuator\").matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator\"); assertMatcher(matcher, \"/actuator\").doesNotMatch(\"/actuator/baz\");",
        "ins1PreCode":"public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator\"); assertMatcher(matcher, \"/actuator\", null).doesNotMatch(\"/actuator/baz\");",
        "ins2PreCode":"public void toAnyEndpointShouldMatchEndpointPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/foo/zoo/\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/bar/baz\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator\");",
        "label":0
    },
    {
        "ins1CurCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(HistoryPageEntry.getEntryId(7), historyPageFilter.newestOnPage); Assert.assertEquals(HistoryPageEntry.getEntryId(3), historyPageFilter.oldestOnPage);",
        "ins1PreCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(7, historyPageFilter.newestOnPage); Assert.assertEquals(3, historyPageFilter.oldestOnPage);",
        "ins2PreCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(8, historyPageFilter.newestOnPage); Assert.assertEquals(4, historyPageFilter.oldestOnPage);",
        "label":1
    },
    {
        "ins1CurCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(10, 1000).subscribe(ts); ts.awaitDone(10, TimeUnit.SECONDS); ts.assertNoErrors();",
        "ins1PreCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(10, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors();",
        "ins2PreCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors();",
        "label":1
    },
    {
        "ins1CurCode":" FetchShuffleBlocks fetchShuffleBlocks = new FetchShuffleBlocks( \"app0\", \"exec1\", 0, new long[] { 0 }, new int[][] {{ 0, 1 }}, false); checkOpenBlocksReceive(fetchShuffleBlocks, blockMarkers);",
        "ins1PreCode":" FetchShuffleBlocks fetchShuffleBlocks = new FetchShuffleBlocks( \"app0\", \"exec1\", 0, new long[] { 0 }, new int[][] {{ 0, 1 }}); checkOpenBlocksReceive(fetchShuffleBlocks, blockMarkers);",
        "ins2PreCode":"public void testCompatibilityWithOldVersion() { when(blockResolver.getBlockData(\"app0\", \"exec1\", 0, 0, 0)).thenReturn(blockMarkers[0]); when(blockResolver.getBlockData(\"app0\", \"exec1\", 0, 0, 1)).thenReturn(blockMarkers[1]);  OpenBlocks openBlocks = new OpenBlocks( \"app0\", \"exec1\", new String[] { \"shuffle_0_0_0\", \"shuffle_0_0_1\" }); checkOpenBlocksReceive(openBlocks, blockMarkers);  verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 0); verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 1); verifyOpenBlockLatencyMetrics();",
        "label":0
    },
    {
        "ins1CurCode":"to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);  operator.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);  operator.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"to, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);  operator.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"assertNull(map.put(i, i + 1)); } map.clear(); assertTrue(map.isEmpty());",
        "ins1PreCode":"assertNull(map.put(i, i + 1)); } map.entrySet().clear(); assertTrue(map.isEmpty());",
        "ins2PreCode":"public void testClear() { SmallSortedMap<Integer, Integer> map = SmallSortedMap.newInstanceForTest(3); for (int i = 0; i < 6; i++) { assertNull(map.put(i, i + 1)); } map.clear(); assertEquals(0, map.getNumArrayEntries()); assertEquals(0, map.getNumOverflowEntries()); assertEquals(0, map.size());",
        "label":0
    },
    {
        "ins1CurCode":"static { Collection<String> translatedPrefixes = new HashSet<>(); ",
        "ins1PreCode":"static { Collection<String> translatedPrefixes = new HashSet<String>(); ",
        "ins2PreCode":"static { List<String> translatedPrefixes = new ArrayList<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"Dispatcher dispatcher = new Dispatcher(this.accessManager, Collections.singleton(mapper)); dispatcher.handle(this.serverRequest, this.serverResponse); verifyNoInteractions(handler); assertThat(this.response.getStatus()).isEqualTo(403);",
        "ins1PreCode":"Dispatcher dispatcher = new Dispatcher(this.accessManager, Collections.singleton(mapper)); dispatcher.handle(this.serverRequest, this.serverResponse); verifyZeroInteractions(handler); assertThat(this.response.getStatus()).isEqualTo(403);",
        "ins2PreCode":"void accessManagerAllowRequest() throws Exception { given(this.accessManager.isAllowed(any(ServerHttpRequest.class))).willReturn(true); HandlerMapper mapper = mock(HandlerMapper.class); Handler handler = mock(Handler.class); given(mapper.getHandler(any(ServerHttpRequest.class))).willReturn(handler); Dispatcher dispatcher = new Dispatcher(this.accessManager, Collections.singleton(mapper)); dispatcher.handle(this.serverRequest, this.serverResponse); verify(handler).handle(this.serverRequest, this.serverResponse);",
        "label":0
    },
    {
        "ins1CurCode":"\"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,rc.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM SYS.ALL_CONSTRAINTS c, SYS.ALL_CONS_COLUMNS col, SYS.ALL_CONSTRAINTS rc\\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\\n\" + \"AND c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"AND rc.OWNER=c.r_OWNER AND rc.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME\"); if (forTable != null) {",
        "ins1PreCode":"\"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,rc.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM SYS.ALL_CONSTRAINTS c\\n\" + \"JOIN SYS.ALL_CONS_COLUMNS col ON c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"JOIN SYS.ALL_CONSTRAINTS rc ON rc.OWNER=c.r_OWNER AND rc.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME \\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\"); if (forTable != null) {",
        "ins2PreCode":"protected JDBCStatement prepareObjectsStatement(JDBCSession session, OracleSchema owner, OracleTableBase forTable) throws SQLException { StringBuilder sql = new StringBuilder(500); sql .append(\"SELECT \").append(OracleUtils.getSysCatalogHint(owner.getDataSource())).append(\"\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.SEARCH_CONDITION,\" + \"col.COLUMN_NAME,col.POSITION\\n\" + \"FROM SYS.ALL_CONSTRAINTS c\\n\" + \"JOIN SYS.ALL_CONS_COLUMNS col ON c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"WHERE c.CONSTRAINT_TYPE<>'R' AND c.OWNER=?\"); if (forTable != null) { sql.append(\" AND c.TABLE_NAME=?\"); } sql.append(\"\\nORDER BY c.CONSTRAINT_NAME,col.POSITION\");  JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); if (forTable != null) { dbStat.setString(2, forTable.getName()); } return dbStat;",
        "label":0
    },
    {
        "ins1CurCode":"Flowable.range(1, 5).hide() .doFinally(this) .compose(TestHelper.conditional()) .subscribe(ts);",
        "ins1PreCode":"Flowable.range(1, 5).hide() .doFinally(this) .filter(Functions.alwaysTrue()) .subscribe(ts);",
        "ins2PreCode":"public void nonFused() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.SYNC);  Flowable.range(1, 5).hide() .doFinally(this) .subscribe(ts);  ts.assertFusionMode(QueueFuseable.NONE) .assertResult(1, 2, 3, 4, 5);  assertEquals(1, calls);",
        "label":0
    },
    {
        "ins1CurCode":"Context root = tomcat.addContext(\"\", TEMP_DIR); Tomcat.addServlet(root, \"Bug48839\", new Bug48839Servlet()); root.addServletMappingDecoded(\"/test\", \"Bug48839\"); ",
        "ins1PreCode":"Context root = tomcat.addContext(\"\", TEMP_DIR); Tomcat.addServlet(root, \"Bug48839\", new Bug48839Servlet()); root.addServletMapping(\"/test\", \"Bug48839\"); ",
        "ins2PreCode":"Context root = tomcat.addContext(\"\", TEMP_DIR); Tomcat.addServlet(root, \"Bug54947\", new TesterServlet()); root.addServletMapping(\"/test\", \"Bug54947\"); ",
        "label":1
    },
    {
        "ins1CurCode":" JavaRDD<Row> rowRDD = jsc.parallelize(personList).map( person -> RowFactory.create(person.getName(), person.getAge())); ",
        "ins1PreCode":" JavaRDD<Row> rowRDD = jsc.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } }); ",
        "ins2PreCode":" JavaRDD<Row> rowRDD = jsc.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = spark.createDataFrame(rowRDD, schema); df.createOrReplaceTempView(\"people\"); List<String> actual = spark.sql(\"SELECT * FROM people\").toJavaRDD() .map(new Function<Row, String>() { @Override public String call(Row row) { return row.getString(0) + \"_\" + row.get(1); } }).collect(); ",
        "label":0
    },
    {
        "ins1CurCode":"void testErrorPath() { ResponseEntity<Map<String, Object>> entity = asMapEntity( this.restTemplate.withBasicAuth(\"user\", \"password\").getForEntity(\"/spring/error\", Map.class)); assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); assertThat(entity.getBody().get(\"error\")).isEqualTo(\"None\"); assertThat(entity.getBody().get(\"status\")).isEqualTo(999);",
        "ins1PreCode":"void testErrorPath() { @SuppressWarnings(\"rawtypes\") ResponseEntity<Map> entity = this.restTemplate.withBasicAuth(\"user\", getPassword()) .getForEntity(\"/spring/error\", Map.class); assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); @SuppressWarnings(\"unchecked\") Map<String, Object> body = entity.getBody(); assertThat(body.get(\"error\")).isEqualTo(\"None\"); assertThat(body.get(\"status\")).isEqualTo(999);",
        "ins2PreCode":"void testErrorPageDirectAccess() { @SuppressWarnings(\"rawtypes\") ResponseEntity<Map> entity = this.restTemplate.withBasicAuth(\"user\", getPassword()).getForEntity(\"/error\", Map.class); assertThat(entity.getStatusCode()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR); @SuppressWarnings(\"unchecked\") Map<String, Object> body = entity.getBody(); assertThat(body.get(\"error\")).isEqualTo(\"None\"); assertThat(body.get(\"status\")).isEqualTo(999);",
        "label":1
    },
    {
        "ins1CurCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); ",
        "ins2PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void successors_selfLoop() { assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void predecessors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"this.environment.getPropertySources().addLast(propertySource2); this.environment.getPropertySources().addLast(propertySource3); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext, this.environment, this.resourceLoader, this.additionalProfiles);",
        "ins1PreCode":"this.environment.getPropertySources().addLast(propertySource2); this.environment.getPropertySources().addLast(propertySource3); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles);",
        "ins2PreCode":"this.environment.getPropertySources().addLast(propertySource1); this.environment.getPropertySources().addLast(propertySource2); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles);",
        "label":1
    },
    {
        "ins1CurCode":" VirtualFile link = VirtualFile.forFile(ws).child(linkString); assertThrows(\"Should have not followed links\", IOException.class, () -> link.open(true));",
        "ins1PreCode":" VirtualFile link = VirtualFile.forFile(ws).child(linkString); try { link.open(true); fail(\"Should have not followed links.\"); } catch (IOException ioe) { ",
        "ins2PreCode":" VirtualFile link = VirtualFile.forFilePath(new FilePath(ws)).child(linkString); try { link.open(true); fail(\"Should have not followed links.\"); } catch (IOException ioe) { ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCallWithResultSet3_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins1PreCode":"public void testCallWithResultSet3_a2() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 3); names = spMapper.getNamesAnnotatedWithXMLResultMap(parms); assertEquals(1, names.size()); assertEquals(1, parms.get(\"totalRows\")); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testCallWithResultSet4_a2() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); names = spMapper.getNamesAnnotatedWithXMLResultMap(parms); assertEquals(2, names.size()); assertEquals(2, parms.get(\"totalRows\")); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void merge1000AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(ts);",
        "ins1PreCode":"public void merge1000AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(ts);",
        "ins2PreCode":"public void merge2000AsyncStreamOf100() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":" StringBuilder sb = new StringBuilder(\"<user username=\\\"\"); sb.append(Escape.xml(username)); sb.append(\"\\\" password=\\\"\"); sb.append(Escape.xml(password)); sb.append(\"\\\"\"); if (fullName != null) { sb.append(\" fullName=\\\"\"); sb.append(Escape.xml(fullName)); sb.append(\"\\\"\"); } synchronized (groups) { if (groups.size() > 0) { sb.append(\" groups=\\\"\"); StringUtils.join(groups, ',', (x) -> Escape.xml(x.getGroupname()), sb); sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\" roles=\\\"\"); StringUtils.join(roles, ',', (x) -> Escape.xml(x.getRolename()), sb); sb.append(\"\\\"\");",
        "ins1PreCode":" StringBuilder sb = new StringBuilder(\"<user username=\\\"\"); sb.append(RequestUtil.filter(username)); sb.append(\"\\\" password=\\\"\"); sb.append(RequestUtil.filter(password)); sb.append(\"\\\"\"); if (fullName != null) { sb.append(\" fullName=\\\"\"); sb.append(RequestUtil.filter(fullName)); sb.append(\"\\\"\"); } synchronized (groups) { if (groups.size() > 0) { sb.append(\" groups=\\\"\"); StringUtils.join(groups, ',', (x) -> RequestUtil.filter(x.getGroupname()), sb); sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\" roles=\\\"\"); StringUtils.join(roles, ',', (x) -> RequestUtil.filter(x.getRolename()), sb); sb.append(\"\\\"\");",
        "ins2PreCode":" StringBuilder sb = new StringBuilder(\"User username=\\\"\"); sb.append(RequestUtil.filter(username)); sb.append(\"\\\"\"); if (fullName != null) { sb.append(\", fullName=\\\"\"); sb.append(RequestUtil.filter(fullName)); sb.append(\"\\\"\"); } synchronized (groups) { if (groups.size() > 0) { sb.append(\", groups=\\\"\"); StringUtils.join(groups, ',', (x) -> RequestUtil.filter(x.getGroupname()), sb); sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\", roles=\\\"\"); StringUtils.join(roles, ',', (x) -> RequestUtil.filter(x.getRolename()), sb); sb.append(\"\\\"\");",
        "label":1
    },
    {
        "ins1CurCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false); s2.add(5.0, 5.0);",
        "ins1PreCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0);",
        "ins2PreCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0);",
        "label":1
    },
    {
        "ins1CurCode":"this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); try (Connection con = datasource.getConnection()) { Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive());",
        "ins1PreCode":"this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "ins2PreCode":"this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); this.datasource.getPoolProperties().setJdbcInterceptors(ResetAbandonedTimer.class.getName()); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); for (int i=0; i<20; i++) { Thread.sleep(200); con.isClosed(); } Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetRenderer() { XYPlot<String> plot = new XYPlot<>(); XYItemRenderer renderer = new XYLineAndShapeRenderer();",
        "ins1PreCode":"public void testSetRenderer() { XYPlot plot = new XYPlot(); XYItemRenderer renderer = new XYLineAndShapeRenderer();",
        "ins2PreCode":"public void testSetRenderer() { CategoryPlot<String, String> plot = new CategoryPlot<>(); CategoryItemRenderer renderer = new LineAndShapeRenderer(); plot.setRenderer(renderer);   MyPlotChangeListener listener = new MyPlotChangeListener(); plot.addChangeListener(listener); renderer.setSeriesPaint(0, Color.BLACK); assertTrue(listener.getEvent() != null);",
        "label":0
    },
    {
        "ins1CurCode":"void setLevelToNull(CapturedOutput output) { this.loggingSystem.beforeInitialize(); initialize(this.initializationContext, null, null); this.logger.debug(\"Hello\");",
        "ins1PreCode":"void setLevelToNull(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null); this.logger.debug(\"Hello\");",
        "ins2PreCode":"void setLevel(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); assertThat(StringUtils.countOccurrencesOf(output.toString(), \"Hello\")).isEqualTo(1);",
        "label":0
    },
    {
        "ins1CurCode":"MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.output.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output.toString()) .doesNotContain(\"Are you using 'uriVariables'?\");",
        "ins1PreCode":"MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.out.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .doesNotContain(\"Are you using 'uriVariables'?\");",
        "ins2PreCode":"MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.out.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .doesNotContain(\"Are you using 'uriVariables'?\");",
        "label":0
    },
    {
        "ins1CurCode":"Date end = new Date(dec2006.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnitType.MONTH, 3); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d4.getTime());",
        "ins1PreCode":"Date end = new Date(dec2006.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.MONTH, 3); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "ins2PreCode":"Date end = new Date(apr22007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.DAY, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "label":1
    },
    {
        "ins1CurCode":"TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooInt()); assertEquals(123, message2.getFooInt()); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooString(\"foo\").build(); TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooString()); assertEquals(\"foo\", message2.getFooString()); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooEnum(TestOneof2.NestedEnum.BAR).build(); TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooEnum()); assertEquals(TestOneof2.NestedEnum.BAR, message2.getFooEnum()); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooMessage( TestOneof2.NestedMessage.newBuilder().setQuxInt(234).build()).build(); TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooMessage()); assertEquals(234, message2.getFooMessage().getQuxInt()); }",
        "ins1PreCode":"TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooInt()); assertEquals(message2.getFooInt(), 123); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooString(\"foo\").build(); TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooString()); assertEquals(message2.getFooString(), \"foo\"); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooEnum(TestOneof2.NestedEnum.BAR).build(); TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooEnum()); assertEquals(message2.getFooEnum(), TestOneof2.NestedEnum.BAR); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooMessage( TestOneof2.NestedMessage.newBuilder().setQuxInt(234).build()).build(); TestOneof2 message2 = TestOneof2.newBuilder().mergeFrom(message).build(); assertTrue(message2.hasFooMessage()); assertEquals(message2.getFooMessage().getQuxInt(), 234); }",
        "ins2PreCode":"TestOneof2 message2 = TestOneof2.parseFrom(serialized); assertTrue(message2.hasFooInt()); assertEquals(message2.getFooInt(), 123); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooString(\"foo\").build(); ByteString serialized = message.toByteString(); TestOneof2 message2 = TestOneof2.parseFrom(serialized); assertTrue(message2.hasFooString()); assertEquals(message2.getFooString(), \"foo\"); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooEnum(TestOneof2.NestedEnum.BAR).build(); ByteString serialized = message.toByteString(); TestOneof2 message2 = TestOneof2.parseFrom(serialized); assertTrue(message2.hasFooEnum()); assertEquals(message2.getFooEnum(), TestOneof2.NestedEnum.BAR); }   { TestOneof2.Builder builder = TestOneof2.newBuilder(); TestOneof2 message = builder.setFooMessage( TestOneof2.NestedMessage.newBuilder().setQuxInt(234).build()).build(); ByteString serialized = message.toByteString(); TestOneof2 message2 = TestOneof2.parseFrom(serialized); assertTrue(message2.hasFooMessage()); assertEquals(message2.getFooMessage().getQuxInt(), 234); }",
        "label":1
    },
    {
        "ins1CurCode":"void toLinksShouldOnlyMatchLinks() { ServerWebExchangeMatcher matcher = EndpointRequest.toLinks();",
        "ins1PreCode":"public void toLinksShouldOnlyMatchLinks() { ServerWebExchangeMatcher matcher = EndpointRequest.toLinks();",
        "ins2PreCode":"public void toLinksShouldOnlyMatchLinks() { RequestMatcher matcher = EndpointRequest.toLinks();",
        "label":1
    },
    {
        "ins1CurCode":"Properties props = new Properties(); props.setProperty(PropertyParser.KEY_ENABLE_DEFAULT_VALUE, \"true\"); Assertions.assertThat(PropertyParser.parse(\"${key:default}\", props)).isEqualTo(\"default\"); Assertions.assertThat(PropertyParser.parse(\"SELECT * FROM ${tableName:users} ORDER BY ${orderColumn:id}\", props)).isEqualTo(\"SELECT * FROM users ORDER BY id\"); Assertions.assertThat(PropertyParser.parse(\"${key:}\", props)).isEmpty(); Assertions.assertThat(PropertyParser.parse(\"${key: }\", props)).isEqualTo(\" \"); Assertions.assertThat(PropertyParser.parse(\"${key::}\", props)).isEqualTo(\":\");",
        "ins1PreCode":"Properties props = new Properties(); props.setProperty(PropertyParser.KEY_ENABLE_DEFAULT_VALUE, \"true\"); Assert.assertThat(PropertyParser.parse(\"${key:default}\", props), Is.is(\"default\")); Assert.assertThat(PropertyParser.parse(\"SELECT * FROM ${tableName:users} ORDER BY ${orderColumn:id}\", props), Is.is(\"SELECT * FROM users ORDER BY id\")); Assert.assertThat(PropertyParser.parse(\"${key:}\", props), Is.is(\"\")); Assert.assertThat(PropertyParser.parse(\"${key: }\", props), Is.is(\" \")); Assert.assertThat(PropertyParser.parse(\"${key::}\", props), Is.is(\":\"));",
        "ins2PreCode":"props.setProperty(PropertyParser.KEY_ENABLE_DEFAULT_VALUE, \"true\"); props.setProperty(PropertyParser.KEY_DEFAULT_VALUE_SEPARATOR, \"?:\"); Assert.assertThat(PropertyParser.parse(\"${key?:default}\", props), Is.is(\"default\")); Assert.assertThat(PropertyParser.parse(\"SELECT * FROM ${schema?:prod}.${tableName == null ? 'users' : tableName} ORDER BY ${orderColumn}\", props), Is.is(\"SELECT * FROM prod.${tableName == null ? 'users' : tableName} ORDER BY ${orderColumn}\")); Assert.assertThat(PropertyParser.parse(\"${key?:}\", props), Is.is(\"\")); Assert.assertThat(PropertyParser.parse(\"${key?: }\", props), Is.is(\" \")); Assert.assertThat(PropertyParser.parse(\"${key?::}\", props), Is.is(\":\"));",
        "label":1
    },
    {
        "ins1CurCode":"return ((Number)value).shortValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + short.class.getCanonicalName()); }",
        "ins1PreCode":"return ((Number)value).shortValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to short\"); }",
        "ins2PreCode":"return ((Number)value).intValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to int\"); }",
        "label":1
    },
    {
        "ins1CurCode":"} if (!containsLogicalDelete){ WHERE(\"logical_delete = ${LOGICAL_DELETE_OFF:0}\"); }",
        "ins1PreCode":"} if (!containsLogicalDelete){ WHERE(\"logical_delete = false\"); }",
        "ins2PreCode":"public String buildSelectByIdAndNameMultipleParamAndProviderContextWithAtParam(@Param(\"id\") final Integer id, ProviderContext context, @Param(\"name\") final String name) { final boolean containsLogicalDelete = context.getMapperMethod().getAnnotation(BaseMapper.ContainsLogicalDelete.class) != null; final String tableName = context.getMapperType().getAnnotation(BaseMapper.Meta.class).tableName(); return new SQL(){{ SELECT(\"*\"); FROM(tableName); if (id != null) { WHERE(\"id = #{id}\"); } if (name != null) { WHERE(\"name like #{name} || '%'\"); } if (!containsLogicalDelete){ WHERE(\"logical_delete = false\"); } }}.toString();",
        "label":0
    },
    {
        "ins1CurCode":"  Stroke result = getSeriesStroke(series); if (result == null && this.autoPopulateSeriesStroke) { DrawingSupplier supplier = getDrawingSupplier();",
        "ins1PreCode":"  if (this.stroke != null) { return this.stroke; }",
        "ins2PreCode":"  if (this.outlineStroke != null) { return this.outlineStroke; }",
        "label":1
    },
    {
        "ins1CurCode":"void parseHandlesAccentsCorrectly() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author = {H'{e}lne Fiaux}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1PreCode":"void parseHandlesAccentsCorrectly() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author = {H\\'{e}lne Fiaux}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"void parsePreambleAndEntryWithoutNewLine() throws IOException { ParserResult result = parser .parse(new StringReader(\"@preamble{some text and \\\\latex}@article{test,author = {H\\'{e}lne Fiaux}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertFalse(result.hasWarnings()); assertEquals(Optional.of(\"some text and \\\\latex\"), result.getDatabase().getPreamble()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "label":1
    },
    {
        "ins1CurCode":"Subscriber<? super T> a = subscribers[i]; if (a instanceof ConditionalSubscriber) { parents[i] = new ParallelFilterConditionalSubscriber<>((ConditionalSubscriber<? super T>)a, predicate); } else { parents[i] = new ParallelFilterSubscriber<>(a, predicate); }",
        "ins1PreCode":"Subscriber<? super T> a = subscribers[i]; if (a instanceof ConditionalSubscriber) { parents[i] = new ParallelFilterConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, predicate); } else { parents[i] = new ParallelFilterSubscriber<T>(a, predicate); }",
        "ins2PreCode":"Subscriber<? super T> a = subscribers[i]; if (a instanceof ConditionalSubscriber) { parents[i] = new ParallelDoOnNextConditionalSubscriber<T>((ConditionalSubscriber<? super T>)a, onNext, errorHandler); } else { parents[i] = new ParallelDoOnNextSubscriber<T>(a, onNext, errorHandler); }",
        "label":1
    },
    {
        "ins1CurCode":"SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream()).hasSize(2); map.setThrowException(true); map.put(\"key3\", \"value3\"); assertThat(adapter.stream()).hasSize(3);",
        "ins1PreCode":"SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.setThrowException(true); map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(3);",
        "ins2PreCode":"SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(3);",
        "label":1
    },
    {
        "ins1CurCode":"Name.root);  RRset rrset = new RRset(); rrset.addRR(txt);",
        "ins1PreCode":"Name.root);  RRset<TXTRecord> rrset = new RRset<>(); rrset.addRR(txt);",
        "ins2PreCode":"Name.root);  RRset<TXTRecord> set = new RRset<>(); set.addRR(txt);",
        "label":1
    },
    {
        "ins1CurCode":"public void testBuild() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop()); ",
        "ins1PreCode":"public void testBuild() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); ",
        "ins2PreCode":"public void testBuildWithIgnoreMissing() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); ",
        "label":1
    },
    {
        "ins1CurCode":"public static int sort( LongArray array, long numRecords, int startByteIndex, int endByteIndex, boolean desc, boolean signed) { assert startByteIndex >= 0 : \"startByteIndex (\" + startByteIndex + \") should >= 0\"; assert endByteIndex <= 7 : \"endByteIndex (\" + endByteIndex + \") should <= 7\"; assert endByteIndex > startByteIndex; assert numRecords * 2 <= array.size(); long inIndex = 0; long outIndex = numRecords; if (numRecords > 0) { long[][] counts = getCounts(array, numRecords, startByteIndex, endByteIndex); for (int i = startByteIndex; i <= endByteIndex; i++) { if (counts[i] != null) { sortAtByte( array, numRecords, counts[i], i, inIndex, outIndex, desc, signed && i == endByteIndex); long tmp = inIndex; inIndex = outIndex; outIndex = tmp; } } } return Ints.checkedCast(inIndex);",
        "ins1PreCode":"public static int sort( LongArray array, int numRecords, int startByteIndex, int endByteIndex, boolean desc, boolean signed) { assert startByteIndex >= 0 : \"startByteIndex (\" + startByteIndex + \") should >= 0\"; assert endByteIndex <= 7 : \"endByteIndex (\" + endByteIndex + \") should <= 7\"; assert endByteIndex > startByteIndex; assert numRecords * 2 <= array.size(); int inIndex = 0; int outIndex = numRecords; if (numRecords > 0) { long[][] counts = getCounts(array, numRecords, startByteIndex, endByteIndex); for (int i = startByteIndex; i <= endByteIndex; i++) { if (counts[i] != null) { sortAtByte( array, numRecords, counts[i], i, inIndex, outIndex, desc, signed && i == endByteIndex); int tmp = inIndex; inIndex = outIndex; outIndex = tmp; } } } return inIndex;",
        "ins2PreCode":"public static int sortKeyPrefixArray( LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex, boolean desc, boolean signed) { assert startByteIndex >= 0 : \"startByteIndex (\" + startByteIndex + \") should >= 0\"; assert endByteIndex <= 7 : \"endByteIndex (\" + endByteIndex + \") should <= 7\"; assert endByteIndex > startByteIndex; assert numRecords * 4 <= array.size(); int inIndex = startIndex; int outIndex = startIndex + numRecords * 2; if (numRecords > 0) { long[][] counts = getKeyPrefixArrayCounts( array, startIndex, numRecords, startByteIndex, endByteIndex); for (int i = startByteIndex; i <= endByteIndex; i++) { if (counts[i] != null) { sortKeyPrefixArrayAtByte( array, numRecords, counts[i], i, inIndex, outIndex, desc, signed && i == endByteIndex); int tmp = inIndex; inIndex = outIndex; outIndex = tmp; } } } return inIndex;",
        "label":1
    },
    {
        "ins1CurCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.get(); assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));",
        "ins1PreCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.getInstance(); assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));",
        "ins2PreCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.getInstance(); FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);",
        "label":1
    },
    {
        "ins1CurCode":"  setFilled(true); setFillColor(FILL_COLOR); setLineColor(LINE_COLOR); setLineWidth(LINE_WIDTH); ",
        "ins1PreCode":"  if (bounds != null) { setLocation(bounds.x, bounds.y); }  setSuppressCalcBounds(false);",
        "ins2PreCode":" if (bounds != null) { setLocation(bounds.x, bounds.y); }  setSuppressCalcBounds(false); ",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(3, s1.getItemCount());  s1.remove(2.0); assertEquals(3.0, s1.getX(1));  s1.remove(1.0); assertEquals(3.0, s1.getX(0));",
        "ins1PreCode":"assertEquals(3, s1.getItemCount());  s1.remove(new Double(2.0)); assertEquals(new Double(3.0), s1.getX(1));  s1.remove(new Double(1.0)); assertEquals(new Double(3.0), s1.getX(0));",
        "ins2PreCode":"assertEquals(3, s1.getItemCount());  s1.remove(new Double(2.0)); assertEquals(new Double(3.0), s1.getX(1));  s1.remove(new Double(1.0)); assertEquals(new Double(3.0), s1.getX(0));",
        "label":1
    },
    {
        "ins1CurCode":"static void setUp() throws Exception { ",
        "ins1PreCode":"public static void setUp() throws Exception { ",
        "ins2PreCode":"public static void initDatabase() throws Exception { try (Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/sptests/MapperConfig.xml\")) {",
        "label":1
    },
    {
        "ins1CurCode":"Parameter[] params = getParameters(); if (params != null) { for (Parameter param : params) { if (LINES_KEY.equals(param.getName())) { lines = Long.parseLong(param.getValue()); continue; } if (SKIP_KEY.equals(param.getName())) { skip = Long.parseLong(param.getValue()); continue;",
        "ins1PreCode":"Parameter[] params = getParameters(); if (params != null) { for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { lines = Long.parseLong(params[i].getValue()); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = Long.parseLong(params[i].getValue()); continue;",
        "ins2PreCode":"Parameter[] params = getParameters(); if (params != null) { for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { setLines(Long.parseLong(params[i].getValue())); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = Long.parseLong(params[i].getValue()); continue;",
        "label":1
    },
    {
        "ins1CurCode":"AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "ins1PreCode":"AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrNull(N1, N2)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrNull(N1, N2)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "ins2PreCode":"AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrNull(N1, N2)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrNull(N1, N2)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "label":1
    },
    {
        "ins1CurCode":"Date end = new Date(s1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnitType.SECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d4.getTime());",
        "ins1PreCode":"Date end = new Date(s1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.SECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "ins2PreCode":"Date end = new Date(s1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.SECOND, 5); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "label":1
    },
    {
        "ins1CurCode":"public void nextObserverError() { NextSubscriber<Integer> no = new NextSubscriber<>(); ",
        "ins1PreCode":"public void nextObserverError() { NextSubscriber<Integer> no = new NextSubscriber<Integer>(); ",
        "ins2PreCode":"public void nextObserverError() { NextObserver<Integer> no = new NextObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void shouldAssingKeysToCollection() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldAssingKeysToCollection() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldAssingKeysToNamedCollection() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"JavaPairRDD<Integer, String> rdd = sc.parallelizePairs(pairs);  rdd.mapToPair(pair -> new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2()))) .saveAsHadoopFile(outputDir, IntWritable.class, Text.class, SequenceFileOutputFormat.class);   JavaPairRDD<Integer, String> readRDD = sc.sequenceFile(outputDir, IntWritable.class, Text.class).mapToPair(pair -> new Tuple2<>(pair._1().get(), pair._2().toString())); assertEquals(pairs, readRDD.collect());",
        "ins1PreCode":"JavaPairRDD<Integer, String> rdd = sc.parallelizePairs(pairs);  rdd.mapToPair(new PairFunction<Tuple2<Integer, String>, IntWritable, Text>() { @Override public Tuple2<IntWritable, Text> call(Tuple2<Integer, String> pair) { return new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2())); } }).saveAsHadoopFile(outputDir, IntWritable.class, Text.class, SequenceFileOutputFormat.class);   JavaPairRDD<Integer, String> readRDD = sc.sequenceFile(outputDir, IntWritable.class, Text.class).mapToPair(new PairFunction<Tuple2<IntWritable, Text>, Integer, String>() { @Override public Tuple2<Integer, String> call(Tuple2<IntWritable, Text> pair) { return new Tuple2<>(pair._1().get(), pair._2().toString()); } }); assertEquals(pairs, readRDD.collect());",
        "ins2PreCode":"public void sequenceFile() { File tempDir = Files.createTempDir(); tempDir.deleteOnExit(); String outputDir = new File(tempDir, \"output\").getAbsolutePath(); List<Tuple2<Integer, String>> pairs = Arrays.asList( new Tuple2<>(1, \"a\"), new Tuple2<>(2, \"aa\"), new Tuple2<>(3, \"aaa\") ); JavaPairRDD<Integer, String> rdd = sc.parallelizePairs(pairs);  rdd.mapToPair(pair -> new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2()))) .saveAsHadoopFile(outputDir, IntWritable.class, Text.class, SequenceFileOutputFormat.class);   JavaPairRDD<Integer, String> readRDD = sc.sequenceFile(outputDir, IntWritable.class, Text.class) .mapToPair(pair -> new Tuple2<>(pair._1().get(), pair._2().toString())); Assert.assertEquals(pairs, readRDD.collect()); Utils.deleteRecursively(tempDir);",
        "label":0
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerObserverTerminated() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerMaybeObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"void runWithSystemPropertiesShouldRestoreOriginalProperties() { String key = \"test.\" + UUID.randomUUID();",
        "ins1PreCode":"public void runWithSystemPropertiesShouldRestoreOriginalProperties() { String key = \"test.\" + UUID.randomUUID();",
        "ins2PreCode":"public void runWithSystemPropertiesWhenValueIsNullShouldRemoveProperty() { String key = \"test.\" + UUID.randomUUID();",
        "label":1
    },
    {
        "ins1CurCode":"public void fileParameter_canStillUse_doubleDotsInFileName() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.addProperty(new ParametersDefinitionProperty(Collections.singletonList( new FileParameterDefinition(\"weird..name.txt\", null) )));  File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, \"test1\", StandardCharsets.UTF_8); ",
        "ins1PreCode":"public void fileParameter_canStillUse_doubleDotsInFileName() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.addProperty(new ParametersDefinitionProperty(Arrays.asList( new FileParameterDefinition(\"weird..name.txt\", null) )));  File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, \"test1\"); ",
        "ins2PreCode":"public void fileParameter_canStillUse_TildeInFileName() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.addProperty(new ParametersDefinitionProperty(Arrays.asList( new FileParameterDefinition(\"~name\", null) )));  File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, \"test1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testIndexOf() { DefaultIntervalXYDataset<String> d = createSampleDataset1(); assertEquals(0, d.indexOf(\"S1\"));",
        "ins1PreCode":"public void testIndexOf() { DefaultIntervalXYDataset d = createSampleDataset1(); assertEquals(0, d.indexOf(\"S1\"));",
        "ins2PreCode":"public void testIndexOf() { DefaultXYDataset d = createSampleDataset1(); assertEquals(0, d.indexOf(\"S1\"));",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"type\", type.toString()); String processorTag = randomAlphaOfLength(10); ConvertProcessor convertProcessor = factory.create(null, processorTag, null, config); assertThat(convertProcessor.getTag(), equalTo(processorTag));",
        "ins1PreCode":"config.put(\"type\", type.toString()); String processorTag = randomAlphaOfLength(10); ConvertProcessor convertProcessor = factory.create(null, processorTag, config); assertThat(convertProcessor.getTag(), equalTo(processorTag));",
        "ins2PreCode":"config.put(\"ignore_missing\", true); String processorTag = randomAlphaOfLength(10); ConvertProcessor convertProcessor = factory.create(null, processorTag, config); assertThat(convertProcessor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValuesUsingMutableMap(sourceBuilder); TestMap source = sourceBuilder.build(); assertMapValuesSet(source); ",
        "ins1PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValues(sourceBuilder); TestMap source = sourceBuilder.build();",
        "ins2PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValues(sourceBuilder); TestMap source = sourceBuilder.build();",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(1, entries.size()); assertEquals(Optional.of(\"Optical properties of MgO doped LiNbO$_3$ single crystals\"), entry.getField(StandardField.TITLE)); assertEquals( Optional.of( \"James Brown and James Marc Brown and Brown, J. M. and Brown, J. and Brown, J. M. and Brown, J.\"), entry.getField(StandardField.AUTHOR)); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"Optical Materials\"), entry.getField(StandardField.JOURNAL)); assertEquals(Optional.of(\"2006\"), entry.getField(StandardField.YEAR)); assertEquals(Optional.of(\"28\"), entry.getField(StandardField.VOLUME)); assertEquals(Optional.of(\"5\"), entry.getField(StandardField.NUMBER)); assertEquals(Optional.of(\"467--72\"), entry.getField(StandardField.PAGES));",
        "ins1PreCode":"assertEquals(1, entries.size()); assertEquals(Optional.of(\"Optical properties of MgO doped LiNbO$_3$ single crystals\"), entry.getField(\"title\")); assertEquals( Optional.of( \"James Brown and James Marc Brown and Brown, J. M. and Brown, J. and Brown, J. M. and Brown, J.\"), entry.getField(\"author\")); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Optical Materials\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"28\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"5\"), entry.getField(\"number\")); assertEquals(Optional.of(\"467--72\"), entry.getField(\"pages\"));",
        "ins2PreCode":"assertEquals(3, entries.size()); assertEquals(Optional.of(\"Optical properties of MgO doped LiNbO$_3$ single crystals\"), entry.getField(\"title\")); assertEquals(\"misc\", entry.getType()); assertEquals(Optional.of(\"Optical Materials\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"28\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"5\"), entry.getField(\"number\")); assertEquals(Optional.of(\"467-72\"), entry.getField(\"pages\"));",
        "label":1
    },
    {
        "ins1CurCode":"public SQLServerTableForeignKey(DBRProgressMonitor monitor, SQLServerTableBase table, SQLServerTableForeignKey source) throws DBException { super(",
        "ins1PreCode":"public SQLServerTableForeignKey(DBRProgressMonitor monitor, SQLServerTable table, SQLServerTableForeignKey source) throws DBException { super(",
        "ins2PreCode":"public MySQLTableForeignKey(DBRProgressMonitor monitor, MySQLTable table, DBSEntityAssociation source) throws DBException { super( monitor, table, source, false); if (source instanceof DBSEntityReferrer) { List<? extends DBSEntityAttributeRef> columns = ((DBSEntityReferrer) source).getAttributeReferences(monitor); if (columns != null) { this.columns = new ArrayList<>(columns.size()); for (DBSEntityAttributeRef srcCol : columns) { if (srcCol instanceof DBSTableForeignKeyColumn) { DBSTableForeignKeyColumn fkCol = (DBSTableForeignKeyColumn) srcCol; this.columns.add(new MySQLTableForeignKeyColumn( this, table.getAttribute(monitor, fkCol.getName()), this.columns.size(), table.getAttribute(monitor, fkCol.getReferencedColumn().getName()))); } } } }",
        "label":0
    },
    {
        "ins1CurCode":"regularExpression = new RegularExpression(); regularExpression.setPattern(from); regexp = regularExpression.getRegexp(getProject()); if (to == null) {",
        "ins1PreCode":"regularExpression = new RegularExpression(); regularExpression.setPattern(from); regexp = regularExpression.getRegexp(project); if (to == null) {",
        "ins2PreCode":"regularExpression = new RegularExpression(); regularExpression.setPattern(from); regexp = regularExpression.getRegexp(project); if (to == null) {",
        "label":1
    },
    {
        "ins1CurCode":"private static JFreeChart createPieChart() { DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", 43.2); data.setValue(\"Visual Basic\", 0.0); data.setValue(\"C/C++\", 17.5); return ChartFactory.createPieChart(\"Pie Chart\", data);",
        "ins1PreCode":"private static JFreeChart createPieChart() { DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", new Double(43.2)); data.setValue(\"Visual Basic\", new Double(0.0)); data.setValue(\"C/C++\", new Double(17.5)); return ChartFactory.createPieChart(\"Pie Chart\", data);",
        "ins2PreCode":"public void setUp() { DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", new Double(43.2)); data.setValue(\"Visual Basic\", new Double(0.0)); data.setValue(\"C/C++\", new Double(17.5)); this.pieChart = ChartFactory.createPieChart(\"Pie Chart\", data);",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetRenderer() { CategoryPlot<String, String> plot = new CategoryPlot<>(); CategoryItemRenderer renderer = new LineAndShapeRenderer();",
        "ins1PreCode":"public void testSetRenderer() { CategoryPlot plot = new CategoryPlot(); CategoryItemRenderer renderer = new LineAndShapeRenderer();",
        "ins2PreCode":"public void testSetRenderer() { XYPlot plot = new XYPlot(); XYItemRenderer renderer = new XYLineAndShapeRenderer(); plot.setRenderer(renderer);   MyPlotChangeListener listener = new MyPlotChangeListener(); plot.addChangeListener(listener); renderer.setSeriesPaint(0, Color.BLACK); assertTrue(listener.getEvent() != null);",
        "label":0
    },
    {
        "ins1CurCode":"this.window = window;  ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<>(window); downstream.onNext(intercept);",
        "ins1PreCode":"this.window = window;  ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(window); downstream.onNext(intercept);",
        "ins2PreCode":"this.window = window;  FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<T>(window); downstream.onNext(intercept);",
        "label":1
    },
    {
        "ins1CurCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNull(results); assertEquals(9, context.getBuffer().position());",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNotNull(results); assertEquals(0, results.length); assertEquals(9, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\\r\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":0
    },
    {
        "ins1CurCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { TomcatReactiveWebServerFactory factory = getFactory(); factory.setShutdown(Shutdown.GRACEFUL); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient(this.webServer.getPort()).build(); this.webServer.shutDownGracefully((result) -> { }); Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> { blockingHandler.stopBlocking(); try { webClient.get().retrieve().toBodilessEntity().block(); return false; } catch (RuntimeException ex) { return ex.getCause() instanceof ConnectException; } }); this.webServer.stop();",
        "ins1PreCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { TomcatReactiveWebServerFactory factory = getFactory(); Shutdown shutdown = new Shutdown(); shutdown.setGracePeriod(Duration.ofSeconds(5)); factory.setShutdown(shutdown); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient(this.webServer.getPort()).build(); webClient.get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown(); AtomicReference<Throwable> errorReference = new AtomicReference<>(); webClient.get().retrieve().toBodilessEntity().doOnError(errorReference::set).subscribe(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); this.webServer.stop(); assertThat(errorReference.get()).hasCauseInstanceOf(ConnectException.class);",
        "ins2PreCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { NettyReactiveWebServerFactory factory = getFactory(); Shutdown shutdown = new Shutdown(); shutdown.setGracePeriod(Duration.ofSeconds(5)); factory.setShutdown(shutdown); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient(this.webServer.getPort()).build(); webClient.get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown(); AtomicReference<Throwable> errorReference = new AtomicReference<>(); webClient.get().retrieve().toBodilessEntity().doOnError(errorReference::set).subscribe(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); this.webServer.stop(); assertThat(errorReference.get()).hasCauseInstanceOf(ConnectException.class);",
        "label":1
    },
    {
        "ins1CurCode":" builder = message.toBuilder(); setMapValuesUsingAccessors(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingAccessors(builder); message = builder.build();",
        "ins1PreCode":" builder = message.toBuilder(); setMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build();",
        "ins2PreCode":" builder = message.toBuilder(); setMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build();",
        "label":1
    },
    {
        "ins1CurCode":"int nRead = populateReadBuffer(to); if (nRead > 0) { return nRead;        }   int limit = socketBufferHandler.getReadBuffer().capacity(); if (to.isDirect() && to.remaining() >= limit) { to.limit(to.position() + limit); nRead = fillReadBuffer(block, to); } else {  nRead = fillReadBuffer(block);    if (nRead > 0) { nRead = populateReadBuffer(to); } } return nRead;",
        "ins1PreCode":"int nRead = populateReadBuffer(to); if (nRead > 0) { to.flip(); return nRead;        }   int limit = socketBufferHandler.getReadBuffer().capacity(); if (to.isDirect() && to.remaining() >= limit) { to.limit(to.position() + limit); nRead = fillReadBuffer(block, to); to.flip(); } else {  nRead = fillReadBuffer(block);    if (nRead > 0) { nRead = populateReadBuffer(to); to.flip(); }",
        "ins2PreCode":"int nRead = populateReadBuffer(to); if (nRead > 0) { to.flip(); return nRead;        }   int limit = socketBufferHandler.getReadBuffer().capacity(); if (to.remaining() >= limit) { to.limit(to.position() + limit); nRead = fillReadBuffer(block, to); updateLastRead(); to.flip(); } else {  nRead = fillReadBuffer(block); updateLastRead();    if (nRead > 0) { nRead = populateReadBuffer(to); to.flip(); }",
        "label":1
    },
    {
        "ins1CurCode":"private int fillReadBuffer(boolean block, ByteBuffer buffer) throws IOException { int n = 0; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { long timeout = getReadTimeout(); do { n = socket.read(buffer); if (n == -1) { throw new EOFException(); } if (n == 0) { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { readBlocking = false; throw new SocketTimeoutException(); } readBlocking = false; } } } } while (n == 0); } else { n = socket.read(buffer); if (n == -1) { throw new EOFException(); } } return n;",
        "ins1PreCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } if (block && nRead == 0) { long timeout = getReadTimeout(); try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; } } return nRead;",
        "ins2PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { long timeout = getWriteTimeout(); try { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { writeBlocking = false; }     } else { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } } while (n > 0 && from.hasRemaining()); }",
        "label":0
    },
    {
        "ins1CurCode":"TestCompletable tc = new TestCompletable();  tc.onSubscribe(Disposable.empty());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"TestCompletable tc = new TestCompletable();  tc.onSubscribe(Disposables.empty());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"TestSingle<Integer> tc = new TestSingle<Integer>();  tc.onSubscribe(Disposables.empty());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"), false)) { assertThat(explodedArchive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive); assertThat(entries.size()).isEqualTo(3);",
        "ins1PreCode":"void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"), false)) { assertThat(this.archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(this.archive); assertThat(entries.size()).isEqualTo(3);",
        "ins2PreCode":"void getNonRecursiveManifest() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"))) { assertThat(explodedArchive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive); assertThat(entries.size()).isEqualTo(4); }",
        "label":0
    },
    {
        "ins1CurCode":"} } catch (Exception e) { LOG.log(Level.SEVERE, \"could not set package at \" + encloser, e); }",
        "ins1PreCode":"} } catch (Exception e) { LOG.error(\"could not set package due to:\" + e + \"' at \" + encloser, e); }",
        "ins2PreCode":"} } catch (Exception e) { LOG.error(\"could not set package due to:\" + e + \"' at \" + encloser, e);",
        "label":0
    },
    {
        "ins1CurCode":"public void testPushThree() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"shufflePush_0_0_2_0\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_1_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_2_0\"), any());",
        "ins1PreCode":"public void testPushThree() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"shufflePush_0_2_0\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_2_0\"), any());",
        "ins2PreCode":"public void testServerFailures() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_2_0\"), any());",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getEndpointId()) .isEqualTo(EndpointId.of(\"testcontroller\")); assertThat(endpoint.getController())",
        "ins1PreCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testcontroller\"); assertThat(endpoint.getController())",
        "ins2PreCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testrestcontroller\"); assertThat(endpoint.getController())",
        "label":1
    },
    {
        "ins1CurCode":"load(QueryEndpointConfiguration.class, (client) -> { WebTestClient.BodyContentSpec body = client.get().uri(\"/query?two=two\") .accept(MediaType.APPLICATION_JSON).exchange().expectStatus() .isBadRequest().expectBody(); validateErrorBody(body, HttpStatus.BAD_REQUEST, \"/endpoints/query\",",
        "ins1PreCode":"load(QueryEndpointConfiguration.class, (client) -> { WebTestClient.BodyContentSpec body = client.get().uri(\"/query?two=two\") .exchange().expectStatus().isBadRequest().expectBody(); validateErrorBody(body, HttpStatus.BAD_REQUEST, \"/endpoints/query\",",
        "ins2PreCode":"load(RequiredParameterEndpointConfiguration.class, (client) -> { WebTestClient.BodyContentSpec body = client.get().uri(\"/requiredparameters\") .exchange().expectStatus().isBadRequest().expectBody(); validateErrorBody(body, HttpStatus.BAD_REQUEST,",
        "label":1
    },
    {
        "ins1CurCode":"public void mapperCrashes() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void mapperCrashes() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void mapperToJust() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"return null; } else { return new ArrayList<>(); }",
        "ins1PreCode":"return null; } else { return new ArrayList<Integer>(); }",
        "ins2PreCode":"return null; } else { return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":"this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).toIterable() .hasOnlyElementsOfType(TestFilter.class);",
        "ins1PreCode":"this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).hasOnlyElementsOfType(TestFilter.class);",
        "ins2PreCode":"this.context.getBeanFactory(), TestServletContextInitializer.class); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()) .hasOnlyElementsOfType(TestServletContextInitializer.class);",
        "label":1
    },
    {
        "ins1CurCode":" try { itemTimeoutObservableSource = Objects.requireNonNull( itemTimeoutIndicator.apply(t),",
        "ins1PreCode":" try { itemTimeoutObservableSource = ObjectHelper.requireNonNull( itemTimeoutIndicator.apply(t),",
        "ins2PreCode":" try { itemTimeoutObservableSource = ObjectHelper.requireNonNull( itemTimeoutIndicator.apply(t),",
        "label":1
    },
    {
        "ins1CurCode":" stream.defaultReadObject(); this.domainGridlineStroke = SerialUtils.readStroke(stream); this.domainGridlinePaint = SerialUtils.readPaint(stream); this.rangeGridlineStroke = SerialUtils.readStroke(stream); this.rangeGridlinePaint = SerialUtils.readPaint(stream); this.rangeCrosshairStroke = SerialUtils.readStroke(stream); this.rangeCrosshairPaint = SerialUtils.readPaint(stream); this.domainCrosshairStroke = SerialUtils.readStroke(stream); this.domainCrosshairPaint = SerialUtils.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtils.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtils.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtils.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtils.readPaint(stream); ",
        "ins1PreCode":" stream.defaultReadObject(); this.domainGridlineStroke = SerialUtilities.readStroke(stream); this.domainGridlinePaint = SerialUtilities.readPaint(stream); this.rangeGridlineStroke = SerialUtilities.readStroke(stream); this.rangeGridlinePaint = SerialUtilities.readPaint(stream); this.rangeCrosshairStroke = SerialUtilities.readStroke(stream); this.rangeCrosshairPaint = SerialUtilities.readPaint(stream); this.domainCrosshairStroke = SerialUtilities.readStroke(stream); this.domainCrosshairPaint = SerialUtilities.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream); ",
        "ins2PreCode":" stream.defaultReadObject(); this.domainGridlineStroke = SerialUtilities.readStroke(stream); this.domainGridlinePaint = SerialUtilities.readPaint(stream); this.rangeGridlineStroke = SerialUtilities.readStroke(stream); this.rangeGridlinePaint = SerialUtilities.readPaint(stream); this.domainMinorGridlineStroke = SerialUtilities.readStroke(stream); this.domainMinorGridlinePaint = SerialUtilities.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream); this.domainCrosshairStroke = SerialUtilities.readStroke(stream); this.domainCrosshairPaint = SerialUtilities.readPaint(stream); this.rangeCrosshairStroke = SerialUtilities.readStroke(stream); this.rangeCrosshairPaint = SerialUtilities.readPaint(stream); this.domainTickBandPaint = SerialUtilities.readPaint(stream); this.rangeTickBandPaint = SerialUtilities.readPaint(stream); this.quadrantOrigin = SerialUtilities.readPoint2D(stream); this.quadrantPaint = new Paint[4]; for (int i = 0; i < 4; i++) { this.quadrantPaint[i] = SerialUtilities.readPaint(stream); }  this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream); this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream); ",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, JdbcType.BIGINT, ProductIdTypeHandler.class); addMapper(); try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() throws Exception { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, JdbcType.BIGINT, ProductIdTypeHandler.class); addMapper(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); Product product = mapper.getProductByNameXml(\"iPad\"); assertEquals(Integer.valueOf(2), product.getId().getValue()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldPickHandlerForNull() throws Exception { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, null, ConstantProductIdTypeHandler.class);   addMapper(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); Product product = mapper.getProductByNameXml(\"iPad\"); assertEquals(Integer.valueOf(999), product.getId().getValue()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"void fromPropertySourceShouldFlattenPropertySources() { StandardEnvironment environment = new StandardEnvironment();",
        "ins1PreCode":"public void fromPropertySourceShouldFlattenPropertySources() { StandardEnvironment environment = new StandardEnvironment();",
        "ins2PreCode":"public void shouldFlattenEnvironment() { StandardEnvironment environment = new StandardEnvironment();",
        "label":1
    },
    {
        "ins1CurCode":"void testNoAst() { String query = \"a b\"; List<Text> expectedTexts = List.of( TooltipTextUtil.createText(\"This search contains entries in which any field contains the term \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, false, query).getDescription();",
        "ins1PreCode":"void testNoAst() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList( TooltipTextUtil.createText(\"This search contains entries in which any field contains the term \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\"), TooltipTextUtil.createText(\" author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, false, query).getDescription();",
        "ins2PreCode":"void testNoAstRegex() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\"), TooltipTextUtil.createText(\" author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription();",
        "label":1
    },
    {
        "ins1CurCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<>(); }",
        "ins1PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); }",
        "ins2PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":"} GanttRenderer that = (GanttRenderer) obj; if (!PaintUtils.equal(this.completePaint, that.completePaint)) { return false; } if (!PaintUtils.equal(this.incompletePaint, that.incompletePaint)) { return false;",
        "ins1PreCode":"} GanttRenderer that = (GanttRenderer) obj; if (!PaintUtilities.equal(this.completePaint, that.completePaint)) { return false; } if (!PaintUtilities.equal(this.incompletePaint, that.incompletePaint)) { return false;",
        "ins2PreCode":"} WaterfallBarRenderer that = (WaterfallBarRenderer) obj; if (!PaintUtilities.equal(this.firstBarPaint, that.firstBarPaint)) { return false; } if (!PaintUtilities.equal(this.lastBarPaint, that.lastBarPaint)) { return false; } if (!PaintUtilities.equal(this.positiveBarPaint, that.positiveBarPaint)) { return false; } if (!PaintUtilities.equal(this.negativeBarPaint, that.negativeBarPaint)) {",
        "label":0
    },
    {
        "ins1CurCode":"Assume.assumeTrue(\"The telemetry should be enabled\", MissingClassTelemetry.enabled());  try { ClassNotFoundException cnfe = new ClassNotFoundException(\"sun.java.MyNonExistentClassGathered\");",
        "ins1PreCode":"Assume.assumeTrue(\"The telemetry should be enabled\", MissingClassTelemetry.enabled());  logging.record(MissingClassTelemetry.class, Logger.getLogger(MissingClassTelemetry.class.getName()).getLevel()).capture(5); ",
        "ins2PreCode":"Assume.assumeTrue(\"The telemetry should be enabled\", MissingClassTelemetry.enabled());  logging.record(MissingClassTelemetry.class, Logger.getLogger(MissingClassTelemetry.class.getName()).getLevel()).capture(5);  try { ClassNotFoundException cnfe = new ClassNotFoundException(\"sun.java.MyNonExistentClassGathered\"); ",
        "label":0
    },
    {
        "ins1CurCode":"void shouldAssignMultipleGeneratedKeysToABean_MultiParams() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Planet planet = new Planet(); planet.setName(\"pluto\"); mapper.insertPlanet_MultiParams(planet, 1); assertEquals(\"pluto-\" + planet.getId(), planet.getCode());",
        "ins1PreCode":"public void shouldAssignMultipleGeneratedKeysToABean_MultiParams() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Planet planet = new Planet(); planet.setName(\"pluto\"); mapper.insertPlanet_MultiParams(planet, Integer.valueOf(1)); assertEquals(\"pluto-\" + planet.getId(), planet.getCode());",
        "ins2PreCode":"public void shouldAssignMultipleGeneratedKeysToABean() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Observable<String>> outerObserver) { outerObserver.onSubscribe(Disposable.empty()); publishNext(outerObserver, 50, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(final Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposable.empty()); publishNext(innerObserver, 50, \"one\"); publishNext(innerObserver, 100, \"two\"); } }));  publishNext(outerObserver, 200, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposable.empty()); publishNext(innerObserver, 0, \"three\");",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Observable<String>> outerObserver) { outerObserver.onSubscribe(Disposables.empty()); publishNext(outerObserver, 50, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(final Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 50, \"one\"); publishNext(innerObserver, 100, \"two\"); } }));  publishNext(outerObserver, 200, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 0, \"three\");",
        "ins2PreCode":"public void switchWithError() { Flowable<Flowable<String>> source = Flowable.unsafeCreate(new Publisher<Flowable<String>>() { @Override public void subscribe(Subscriber<? super Flowable<String>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 50, Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(final Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 50, \"one\"); publishNext(subscriber, 100, \"two\"); } }));  publishNext(subscriber, 200, Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 0, \"three\"); publishNext(subscriber, 100, \"four\"); } }));  publishError(subscriber, 250, new TestException()); } });  Flowable<String> sampled = Flowable.switchOnNext(source); sampled.subscribe(subscriber);  InOrder inOrder = inOrder(subscriber);  scheduler.advanceTimeTo(90, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, never()).onNext(anyString()); verify(subscriber, never()).onComplete(); verify(subscriber, never()).onError(any(Throwable.class));  scheduler.advanceTimeTo(125, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, times(1)).onNext(\"one\"); verify(subscriber, never()).onComplete(); verify(subscriber, never()).onError(any(Throwable.class));  scheduler.advanceTimeTo(175, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, times(1)).onNext(\"two\"); verify(subscriber, never()).onComplete(); verify(subscriber, never()).onError(any(Throwable.class));  scheduler.advanceTimeTo(225, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, times(1)).onNext(\"three\"); verify(subscriber, never()).onComplete(); verify(subscriber, never()).onError(any(Throwable.class));  scheduler.advanceTimeTo(350, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, never()).onNext(anyString()); verify(subscriber, never()).onComplete(); verify(subscriber, times(1)).onError(any(TestException.class));",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetStartValue2() { TaskSeriesCollection<String, String> c = createCollection2(); assertEquals(10L, c.getStartValue(\"S1\", \"Task 1\", 0)); assertEquals(16L, c.getStartValue(\"S1\", \"Task 1\", 1)); assertEquals(30L, c.getStartValue(\"S1\", \"Task 2\", 0)); assertEquals(36L, c.getStartValue(\"S1\", \"Task 2\", 1)); assertEquals(50L, c.getStartValue(\"S2\", \"Task 3\", 0)); assertEquals(56L, c.getStartValue(\"S2\", \"Task 3\", 1));  assertEquals(10L, c.getStartValue(0, 0, 0)); assertEquals(16L, c.getStartValue(0, 0, 1)); assertEquals(30L, c.getStartValue(0, 1, 0)); assertEquals(36L, c.getStartValue(0, 1, 1)); assertEquals(50L, c.getStartValue(1, 2, 0)); assertEquals(56L, c.getStartValue(1, 2, 1));  TaskSeriesCollection<String, String> c3 = createCollection3(); assertEquals(11L, c3.getStartValue(0, 0, 0));",
        "ins1PreCode":"public void testGetStartValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(10L, c.getStartValue(\"S1\", \"Task 1\", 0)); assertEquals(16L, c.getStartValue(\"S1\", \"Task 1\", 1)); assertEquals(30L, c.getStartValue(\"S1\", \"Task 2\", 0)); assertEquals(36L, c.getStartValue(\"S1\", \"Task 2\", 1)); assertEquals(50L, c.getStartValue(\"S2\", \"Task 3\", 0)); assertEquals(56L, c.getStartValue(\"S2\", \"Task 3\", 1));  assertEquals(10L, c.getStartValue(0, 0, 0)); assertEquals(16L, c.getStartValue(0, 0, 1)); assertEquals(30L, c.getStartValue(0, 1, 0)); assertEquals(36L, c.getStartValue(0, 1, 1)); assertEquals(50L, c.getStartValue(1, 2, 0)); assertEquals(56L, c.getStartValue(1, 2, 1));  TaskSeriesCollection c3 = createCollection3(); assertEquals(11L, c3.getStartValue(0, 0, 0));",
        "ins2PreCode":"public void testGetEndValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(15L, c.getEndValue(\"S1\", \"Task 1\", 0)); assertEquals(20L, c.getEndValue(\"S1\", \"Task 1\", 1)); assertEquals(35L, c.getEndValue(\"S1\", \"Task 2\", 0)); assertEquals(40L, c.getEndValue(\"S1\", \"Task 2\", 1)); assertEquals(55L, c.getEndValue(\"S2\", \"Task 3\", 0)); assertEquals(60L, c.getEndValue(\"S2\", \"Task 3\", 1));  assertEquals(15L, c.getEndValue(0, 0, 0)); assertEquals(20L, c.getEndValue(0, 0, 1)); assertEquals(35L, c.getEndValue(0, 1, 0)); assertEquals(40L, c.getEndValue(0, 1, 1)); assertEquals(55L, c.getEndValue(1, 2, 0)); assertEquals(60L, c.getEndValue(1, 2, 1));  TaskSeriesCollection c3 = createCollection3(); assertEquals(111L, c3.getEndValue(0, 0, 0));",
        "label":1
    },
    {
        "ins1CurCode":"int n = -1; for (int i = 0; i < applicationListeners.length; i++) { if (applicationListeners[i].equals(listener)) { n = i;",
        "ins1PreCode":"int n = -1; for (int i = 0; i < applicationListeners.length; i++) { if (applicationListeners.equals(listener)) { n = i;",
        "ins2PreCode":"public void removeWrapperListener(String listener) {   synchronized (wrapperListenersLock) {   int n = -1; for (int i = 0; i < wrapperListeners.length; i++) { if (wrapperListeners[i].equals(listener)) { n = i; break; } } if (n < 0) return;   int j = 0; String results[] = new String[wrapperListeners.length - 1]; for (int i = 0; i < wrapperListeners.length; i++) { if (i != n) results[j++] = wrapperListeners[i]; } wrapperListeners = results;  }   fireContainerEvent(\"removeWrapperListener\", listener); ",
        "label":0
    },
    {
        "ins1CurCode":" StandardManager mgr = new StandardManager(); mgr.startInternal(); mgr.generateSessionId();",
        "ins1PreCode":"result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); System.out.println(result.toString());",
        "ins2PreCode":"private void doTestManagerBaseCreateSession(int threadCount, int iterCount) {   StandardManager mgr = new StandardManager(); mgr.setContainer(new StandardContext()); mgr.generateSessionId(); while (mgr.sessionCreationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionCreationTiming.add(null); } while (mgr.sessionExpirationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionExpirationTiming.add(null); }  Thread[] threads = new Thread[threadCount];  for (int i = 0; i < threadCount; i++) { threads[i] = new Thread( new TestThreadCreateSession(mgr, iterCount)); }  long start = System.currentTimeMillis();  for (int i = 0; i < threadCount; i++) { threads[i].start(); } for (int i = 0; i < threadCount; i++) { try { threads[i].join(); } catch (InterruptedException e) { e.printStackTrace(); fail(e.getMessage()); } } long end = System.currentTimeMillis();  StringBuilder result = new StringBuilder(); result.append(\"Threads: \"); result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); System.out.println(result.toString());",
        "label":1
    },
    {
        "ins1CurCode":"void roundtripWithArticleMonths() throws Exception { Path testBibtexFile = Path.of(\"src/test/resources/testbib/articleWithMonths.bib\"); Charset encoding = StandardCharsets.UTF_8;",
        "ins1PreCode":"void roundtripWithArticleMonths() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/articleWithMonths.bib\"); Charset encoding = StandardCharsets.UTF_8;",
        "ins2PreCode":"void roundtripWithComplexBib() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/complex.bib\"); Charset encoding = StandardCharsets.UTF_8;",
        "label":1
    },
    {
        "ins1CurCode":"public void onNextErrorAcrossThread() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<>(); Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);",
        "ins1PreCode":"public void onNextErrorAcrossThread() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>(); Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);",
        "ins2PreCode":"public void onNextError() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>(); Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);",
        "label":1
    },
    {
        "ins1CurCode":"new Date())));  TaskSeriesCollection<String, String> tsc = new TaskSeriesCollection<>(); tsc.add(s1);",
        "ins1PreCode":"new Date())));  TaskSeriesCollection tsc = new TaskSeriesCollection(); tsc.add(s1);",
        "ins2PreCode":"new Date())));  TaskSeriesCollection tsc = new TaskSeriesCollection(); tsc.add(s1);",
        "label":1
    },
    {
        "ins1CurCode":"modelImpl, run, \"Remove the link between the comment # \" + \"and the element #\", comment, annotatedElement));",
        "ins1PreCode":"modelImpl, run, \"Remove the link between the comment # and the element #\", comment, annotatedElement));",
        "ins2PreCode":"public void addAnnotatedElement(final Object comment, final Object annotatedElement) { if (!(annotatedElement instanceof Element)) { throw new IllegalArgumentException( \"annotatedElement must be instance of Element\"); } if (!(comment instanceof Comment)) { throw new IllegalArgumentException( \"comment must be instance of Comment\"); } RunnableClass run = new RunnableClass() { public void run() { ((Comment) comment).getAnnotatedElements().add( (Element) annotatedElement); } }; editingDomain.getCommandStack().execute( new ChangeCommand( modelImpl, run, \"Add the comment # to the element #\", comment, annotatedElement));",
        "label":0
    },
    {
        "ins1CurCode":"public void refCountAsync() throws InterruptedException {  for (int i = 0; i < 10; i++) { try { refCountAsyncActual(); return; } catch (AssertionError ex) { if (i == 9) { throw ex; } Thread.sleep((int)(200 * (Math.random() * 10 + 1))); }",
        "ins1PreCode":"public void refCountAsync() { final AtomicInteger subscribeCount = new AtomicInteger(); final AtomicInteger nextCount = new AtomicInteger(); Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS) .doOnSubscribe(new Consumer<Subscription>() { @Override public void accept(Subscription s) { subscribeCount.incrementAndGet(); } }) .doOnNext(new Consumer<Long>() { @Override public void accept(Long l) { nextCount.incrementAndGet(); } }) .publish().refCount();  final AtomicInteger receivedCount = new AtomicInteger(); Disposable d1 = r.subscribe(new Consumer<Long>() { @Override public void accept(Long l) { receivedCount.incrementAndGet(); } });  Disposable d2 = r.subscribe();  try { Thread.sleep(10); } catch (InterruptedException e) { }  for (;;) { int a = nextCount.get(); int b = receivedCount.get(); if (a > 10 && a < 20 && a == b) { break; } if (a >= 20) { break; } try { Thread.sleep(20); } catch (InterruptedException e) { } }    d2.dispose(); d1.dispose();  System.out.println(\"onNext: \" + nextCount.get());   assertEquals(nextCount.get(), receivedCount.get());  assertEquals(1, subscribeCount.get());",
        "ins2PreCode":"public void refCountAsync() { final AtomicInteger subscribeCount = new AtomicInteger(); final AtomicInteger nextCount = new AtomicInteger(); Observable<Long> r = Observable.interval(0, 25, TimeUnit.MILLISECONDS) .doOnSubscribe(new Consumer<Disposable>() { @Override public void accept(Disposable d) { subscribeCount.incrementAndGet(); } }) .doOnNext(new Consumer<Long>() { @Override public void accept(Long l) { nextCount.incrementAndGet(); } }) .publish().refCount();  final AtomicInteger receivedCount = new AtomicInteger(); Disposable d1 = r.subscribe(new Consumer<Long>() { @Override public void accept(Long l) { receivedCount.incrementAndGet(); } });  Disposable d2 = r.subscribe();   try { Thread.sleep(260); } catch (InterruptedException e) { }   d2.dispose(); d1.dispose();  System.out.println(\"onNext: \" + nextCount.get());   assertEquals(nextCount.get(), receivedCount.get());  assertEquals(1, subscribeCount.get());",
        "label":0
    },
    {
        "ins1CurCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).hasContentsInOrder( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins1PreCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); assertContentsInOrder(family, \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins2PreCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); assertContentsInOrder(family, \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "label":0
    },
    {
        "ins1CurCode":"});  final TestSubscriber<Object> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"});  final TestSubscriber<Object> ts = new TestSubscriber<Object>(); ",
        "ins2PreCode":"});  final TestSubscriber<Object> ts = new TestSubscriber<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { DefaultPieDataset<String> d1 = new DefaultPieDataset<>(); d1.setValue(\"V1\", 1); d1.setValue(\"V2\", null); d1.setValue(\"V3\", 3); DefaultPieDataset<String> d2 = (DefaultPieDataset) d1.clone(); ",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultPieDataset d1 = new DefaultPieDataset(); d1.setValue(\"V1\", 1); d1.setValue(\"V2\", null); d1.setValue(\"V3\", 3); DefaultPieDataset d2 = (DefaultPieDataset) d1.clone(); ",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); d1.setValue(\"V1\", 1); d1.setValue(\"V2\", null); d1.setValue(\"V3\", 3); DefaultKeyedValuesDataset d2 = (DefaultKeyedValuesDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));",
        "label":0
    },
    {
        "ins1CurCode":"Range range = r.findDomainBounds(null); assertTrue(range == null); DefaultXYZDataset<String> emptyDataset = new DefaultXYZDataset<>(); range = r.findDomainBounds(emptyDataset);",
        "ins1PreCode":"Range range = r.findDomainBounds(null); assertTrue(range == null); DefaultXYZDataset emptyDataset = new DefaultXYZDataset(); range = r.findDomainBounds(emptyDataset);",
        "ins2PreCode":"Range range = r.findRangeBounds(null); assertTrue(range == null); DefaultXYZDataset emptyDataset = new DefaultXYZDataset(); range = r.findRangeBounds(emptyDataset);",
        "label":1
    },
    {
        "ins1CurCode":"private static Set<LocalizationEntry> findLocalizationEntriesInJavaFiles(LocalizationBundleForTest type) throws IOException { try (Stream<Path> pathStream = Files.walk(Path.of(\"src/main\"))) { return pathStream",
        "ins1PreCode":"private static Set<LocalizationEntry> findLocalizationEntriesInJavaFiles(LocalizationBundleForTest type) throws IOException { try (Stream<Path> pathStream = Files.walk(Paths.get(\"src/main\"))) { return pathStream",
        "ins2PreCode":"private static Set<LocalizationEntry> findLocalizationEntriesInFxmlFiles(LocalizationBundleForTest type) throws IOException { try (Stream<Path> pathStream = Files.walk(Paths.get(\"src/main\"))) { return pathStream",
        "label":1
    },
    {
        "ins1CurCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.get(); FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);",
        "ins1PreCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.getInstance(); FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);",
        "ins2PreCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.getInstance(); FormValidation v = jenkins.doCheckDisplayName(jobName, curJobName);",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "label":1
    },
    {
        "ins1CurCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins1PreCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins2PreCode":"Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "label":1
    },
    {
        "ins1CurCode":"});  final ArrayList<String> list = new ArrayList<>(); os.subscribe(new DefaultSubscriber<String>() {",
        "ins1PreCode":"});  final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new DefaultSubscriber<String>() {",
        "ins2PreCode":"});  final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new DefaultObserver<String>() {",
        "label":1
    },
    {
        "ins1CurCode":"public Principal authenticate(String username, String credentials) {  JNDIConnection connection = null; Principal principal = null;  try {   connection = get();    try {   principal = authenticate(connection, username, credentials);  } catch (NullPointerException | NamingException e) {                 containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   close(connection);   connection = get();   principal = authenticate(connection, username, credentials); }    release(connection);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   if (containerLog.isDebugEnabled()) containerLog.debug(\"Returning null principal.\"); return null;  } ",
        "ins1PreCode":"public Principal authenticate(String username, String credentials) {  JNDIConnection connection = null; Principal principal = null;  try {   connection = get();    try {   principal = authenticate(connection, username, credentials);  } catch (NullPointerException | NamingException e) {                 containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   close(connection);   connection = get();   principal = authenticate(connection, username, credentials); }    release(connection);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   close(connection);   if (containerLog.isDebugEnabled()) containerLog.debug(\"Returning null principal.\"); return null;  } ",
        "ins2PreCode":"protected Principal getPrincipal(String username, GSSCredential gssCredential) {  JNDIConnection connection = null; Principal principal = null;  try {   connection = get();    try {   principal = getPrincipal(connection, username, gssCredential);  } catch (CommunicationException | ServiceUnavailableException e) {   containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   close(connection);   connection = get();   principal = getPrincipal(connection, username, gssCredential);  }    release(connection);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   close(connection);   return null;  }  ",
        "label":1
    },
    {
        "ins1CurCode":"ingestDocument.setFieldValue(fieldName, randomAlphaOfLengthBetween(1, 10)); SortOrder order = randomBoolean() ? SortOrder.ASCENDING : SortOrder.DESCENDING; Processor processor = new SortProcessor(randomAlphaOfLength(10), null, fieldName, order, fieldName); try {",
        "ins1PreCode":"ingestDocument.setFieldValue(fieldName, randomAlphaOfLengthBetween(1, 10)); SortOrder order = randomBoolean() ? SortOrder.ASCENDING : SortOrder.DESCENDING; Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, order, fieldName); try {",
        "ins2PreCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); ingestDocument.setFieldValue(fieldName, randomAlphaOfLengthBetween(1, 10)); Processor processor = new JoinProcessor(randomAlphaOfLength(10), fieldName, \"-\", fieldName); try {",
        "label":1
    },
    {
        "ins1CurCode":"public void testEquals_ObjectList5() { XYPlot<String> p1 = new XYPlot<>(); p1.setRenderer(new XYBarRenderer()); XYPlot<String> p2 = new XYPlot<>(); p2.setRenderer(new XYBarRenderer());",
        "ins1PreCode":"public void testEquals_ObjectList5() { XYPlot p1 = new XYPlot(); p1.setRenderer(new XYBarRenderer()); XYPlot p2 = new XYPlot(); p2.setRenderer(new XYBarRenderer());",
        "ins2PreCode":"public void testEquals_ObjectList5() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setRenderer(new BarRenderer()); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setRenderer(new BarRenderer()); assertEquals(p1, p2); p2.setRenderer(1, new LineAndShapeRenderer()); assertNotEquals(p1, p2);",
        "label":0
    },
    {
        "ins1CurCode":"resourceDir = Paths.get(MSBibExportFormatTestFiles.class.getResource(\"MsBibExportFormatTest1.bib\").toURI()).getParent(); try (Stream<Path> stream = Files.list(resourceDir)) { return stream.map(n -> n.getFileName().toString()) .filter(n -> n.endsWith(\".bib\")) .filter(n -> n.startsWith(\"MsBib\")) .collect(Collectors.toList()) .stream(); }",
        "ins1PreCode":" resourceDir = Paths.get(MSBibExportFormatTestFiles.class.getResource(\"MsBibExportFormatTest1.bib\").toURI()).getParent(); System.out.println(resourceDir); try (Stream<Path> stream = Files.list(resourceDir)) { return stream.map(n -> n.getFileName().toString()).filter(n -> n.endsWith(\".bib\")) .filter(n -> n.startsWith(\"MsBib\")).collect(Collectors.toList()).stream(); }",
        "ins2PreCode":"public static Stream<String> fileNames() throws IOException, URISyntaxException { resourceDir = Paths.get(MSBibExportFormatTestFiles.class.getResource(\"BibTeXMLExporterTestArticle.bib\").toURI()).getParent();   try (Stream<Path> stream = Files.list(resourceDir)) { return stream.map(n -> n.getFileName().toString()).filter(n -> n.endsWith(\".bib\")) .filter(n -> n.startsWith(\"BibTeXML\")).collect(Collectors.toList()).stream(); }",
        "label":0
    },
    {
        "ins1CurCode":"void testComplexQueryCaseSensitive() { String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1PreCode":"public void testComplexQueryCaseSensitive() { double textSize = 13; String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testComplexQuery() { double textSize = 13; String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1CurCode":"public void testNestedRadio() throws Exception { HtmlPage p = j.createWebClient().goTo(\"self/testNestedRadio\"); HtmlForm f = p.getFormByName(\"config\"); try { clickButton(p, f, \"Add\", true); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(1).click(); clickButton(p, f, \"Add Moo\", true); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(2).click(); clickButton(p, f, \"Add\", false); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(4).click(); Thread.sleep(500); f.getElementsByTagName(\"button\").get(1).click(); waitForJavaScript(p); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(7).click(); f.getElementsByTagName(\"button\").get(1).click(); waitForJavaScript(p); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(8).click(); } catch (Exception e) { System.err.println(\"HTML at time of failure:\\n\" + p.getBody().asXml()); throw e; } j.submit(f); assertEqualsJsonArray(\"[{\\\"moo\\\":{\\\"inner\\\":\\\"inone\\\"},\\\"outer\\\":\\\"two\\\"},\" + \"{\\\"moo\\\":[{\\\"inner\\\":\\\"intwo\\\"},{\\\"inner\\\":\\\"inone\\\"}],\\\"outer\\\":\\\"one\\\"}]\", rootAction.formData.get(\"items\"));",
        "ins1PreCode":"public void testNestedRadio() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testNestedRadio\"); HtmlForm f = p.getFormByName(\"config\"); try { clickButton(p, f, \"Add\", true); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(1).click(); clickButton(p, f, \"Add Moo\", true); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(2).click(); clickButton(p, f, \"Add\", false); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(4).click(); Thread.sleep(500); f.getElementsByTagName(\"button\").get(1).click(); waitForJavaScript(p); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(7).click(); f.getElementsByTagName(\"button\").get(1).click(); waitForJavaScript(p); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(8).click(); } catch (Exception e) { System.err.println(\"HTML at time of failure:\\n\" + p.getBody().asXml()); throw e; } submit(f); assertEqualsJsonArray(\"[{\\\"moo\\\":{\\\"inner\\\":\\\"inone\\\"},\\\"outer\\\":\\\"two\\\"},\" + \"{\\\"moo\\\":[{\\\"inner\\\":\\\"intwo\\\"},{\\\"inner\\\":\\\"inone\\\"}],\\\"outer\\\":\\\"one\\\"}]\", formData.get(\"items\"));",
        "ins2PreCode":"public void testNestedRadioEnabledTopButton() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testNestedRadioTopButton\"); HtmlForm f = p.getFormByName(\"config\"); try { clickButton(p, f, \"Add\", true); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(1).click(); clickButton(p, f, \"Add Moo\", true); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(2).click(); clickButton(p, f, \"Add\", false); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(4).click(); Thread.sleep(500); f.getElementsByTagName(\"button\").get(3).click(); waitForJavaScript(p); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(7).click(); f.getElementsByTagName(\"button\").get(4).click(); waitForJavaScript(p); f.getElementsByAttribute(\"input\", \"type\", \"radio\").get(8).click(); } catch (Exception e) { System.err.println(\"HTML at time of failure:\\n\" + p.getBody().asXml()); throw e; } submit(f); assertEqualsJsonArray(\"[{\\\"moo\\\":{\\\"inner\\\":\\\"inone\\\"},\\\"outer\\\":\\\"two\\\"},\" + \"{\\\"moo\\\":[{\\\"inner\\\":\\\"intwo\\\"},{\\\"inner\\\":\\\"inone\\\"}],\\\"outer\\\":\\\"one\\\"}]\", formData.get(\"items\"));",
        "label":1
    },
    {
        "ins1CurCode":" try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) { transport.start();",
        "ins1PreCode":" try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher)) { transport.start();",
        "ins2PreCode":" try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport( settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher, clusterSettings)) { transport.start();",
        "label":1
    },
    {
        "ins1CurCode":"public void testPoolThreads10Connections20Validate() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "ins1PreCode":"public void testPoolThreads10Connections20Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testPoolThreads10Connections20ValidateFair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":" List<Row> data = Arrays.asList( RowFactory.create(0.0, \"Hi I heard about Spark\"), RowFactory.create(0.0, \"I wish Java could use case classes\"), RowFactory.create(1.0, \"Logistic regression models are neat\") );",
        "ins1PreCode":" List<Row> data = Arrays.asList( RowFactory.create(0, \"Hi I heard about Spark\"), RowFactory.create(0, \"I wish Java could use case classes\"), RowFactory.create(1, \"Logistic regression models are neat\") );",
        "ins2PreCode":"public void hashingTF() { List<Row> data = Arrays.asList( RowFactory.create(0.0, \"Hi I heard about Spark\"), RowFactory.create(0.0, \"I wish Java could use case classes\"), RowFactory.create(1.0, \"Logistic regression models are neat\") ); StructType schema = new StructType(new StructField[]{ new StructField(\"label\", DataTypes.DoubleType, false, Metadata.empty()), new StructField(\"sentence\", DataTypes.StringType, false, Metadata.empty()) });  Dataset<Row> sentenceData = spark.createDataFrame(data, schema); Tokenizer tokenizer = new Tokenizer() .setInputCol(\"sentence\") .setOutputCol(\"words\"); Dataset<Row> wordsData = tokenizer.transform(sentenceData); int numFeatures = 20; HashingTF hashingTF = new HashingTF() .setInputCol(\"words\") .setOutputCol(\"rawFeatures\") .setNumFeatures(numFeatures); Dataset<Row> featurizedData = hashingTF.transform(wordsData); IDF idf = new IDF().setInputCol(\"rawFeatures\").setOutputCol(\"features\"); IDFModel idfModel = idf.fit(featurizedData); Dataset<Row> rescaledData = idfModel.transform(featurizedData); for (Row r : rescaledData.select(\"features\", \"label\").takeAsList(3)) { Vector features = r.getAs(0); Assert.assertEquals(features.size(), numFeatures); }",
        "label":0
    },
    {
        "ins1CurCode":"\"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "ins1PreCode":"\"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class));",
        "ins2PreCode":"\"org.apache.derby.jdbc.ClientDriver\", \"jdbc:derby://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class));",
        "label":1
    },
    {
        "ins1CurCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<View>(views); Collections.sort(result, new Comparator<View>() {",
        "ins1PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views); Collections.sort(result, new Comparator<View>() {",
        "ins2PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views); Collections.sort(result, new Comparator<View>() { @Override public int compare(View o1, View o2) { return o1.getDisplayName().compareTo(o2.getDisplayName()); } }); return result;",
        "label":0
    },
    {
        "ins1CurCode":"void integrationTest() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void integrationTest() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void integrationTest() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"for(ExasolScriptGrant grant: this.dataSource.getScriptGrants(monitor)) { if (grant.getGrantee().equals(this.getName())) {",
        "ins1PreCode":"for(ExasolScriptGrant grant: this.dataSource.getScriptGrants(monitor)) { if (grant.getName().equals(this.getName())) {",
        "ins2PreCode":"for(ExasolSchemaGrant grant: this.dataSource.getSchemaGrants(monitor)) { if (grant.getName().equals(this.getName())) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":"String result = res.toString();  Assert.assertTrue(result.indexOf(\"<p>00-${'hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>01-#{'hello world'}</p>\") > 0);",
        "ins1PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>00-${'hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>01-#{'hello world'}</p>\") > 0);",
        "ins2PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>00-${'hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>01-#{'hello world'}</p>\") > 0);",
        "label":1
    },
    {
        "ins1CurCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\",",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\",",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createTimeSeriesChart(\"XY Line Chart\", \"Domain\", \"Range\", dataset, true, true, true);",
        "label":0
    },
    {
        "ins1CurCode":"  RMApp rmApp = MockRMAppSubmitter.submitWithMemory(1024, rm); rm.drainEvents();",
        "ins1PreCode":"  RMApp rmApp = rm.submitApp(1024); rm.drainEvents();",
        "ins2PreCode":"  RMApp rmApp = rm.submitApp(1024); rm.drainEvents();",
        "label":1
    },
    {
        "ins1CurCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair(in -> { List<Tuple2<Integer, String>> out = new LinkedList<>();",
        "ins1PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair( new PairFlatMapFunction<Tuple2<String, Integer>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Tuple2<String, Integer> in) { List<Tuple2<Integer, String>> out = new LinkedList<>();",
        "ins2PreCode":"public void testPairToPairFlatMapWithChangingTypes() { List<List<Tuple2<String, Integer>>> inputData = Arrays.asList( Arrays.asList( new Tuple2<>(\"hi\", 1), new Tuple2<>(\"ho\", 2)), Arrays.asList( new Tuple2<>(\"hi\", 1), new Tuple2<>(\"ho\", 2)));  List<List<Tuple2<Integer, String>>> expected = Arrays.asList( Arrays.asList( new Tuple2<>(1, \"h\"), new Tuple2<>(1, \"i\"), new Tuple2<>(2, \"h\"), new Tuple2<>(2, \"o\")), Arrays.asList( new Tuple2<>(1, \"h\"), new Tuple2<>(1, \"i\"), new Tuple2<>(2, \"h\"), new Tuple2<>(2, \"o\")));  JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair(in -> { List<Tuple2<Integer, String>> out = new LinkedList<>(); for (Character s : in._1().toCharArray()) { out.add(new Tuple2<>(in._2(), s.toString())); } return out.iterator(); });  JavaTestUtils.attachTestOutputStream(flatMapped); List<List<Tuple2<String, Integer>>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "label":0
    },
    {
        "ins1CurCode":"void innerError(InnerObserver inner, Throwable e) { set.delete(inner); if (errors.tryAddThrowableOrReport(e)) { if (!delayErrors) {",
        "ins1PreCode":"void innerError(InnerObserver inner, Throwable e) { set.delete(inner); if (errors.addThrowable(e)) { if (!delayErrors) { upstream.cancel(); set.dispose(); } else { if (maxConcurrency != Integer.MAX_VALUE) { upstream.request(1); } } active.decrementAndGet(); drain(); } else { RxJavaPlugins.onError(e); }",
        "ins2PreCode":"void innerError(InnerObserver inner, Throwable e) { set.delete(inner); if (errors.addThrowable(e)) { if (!delayErrors) { upstream.cancel(); set.dispose(); } else { if (maxConcurrency != Integer.MAX_VALUE) { upstream.request(1); } } active.decrementAndGet(); drain(); } else { RxJavaPlugins.onError(e); }",
        "label":1
    },
    {
        "ins1CurCode":"void shouldGetAllUsers() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldGetAllUsers() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetAllUsers_Annotated() { sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class);",
        "label":1
    },
    {
        "ins1CurCode":"{ DependencyManagement src = source.getDependencyManagement(); if ( src != null ) {",
        "ins1PreCode":"{ DependencyManagement src = source.getDependencyManagement(); if ( source.getDependencyManagement() != null ) {",
        "ins2PreCode":"{ PluginManagement src = source.getPluginManagement(); if ( source.getPluginManagement() != null ) {",
        "label":1
    },
    {
        "ins1CurCode":"private StringManager(String packageName) { String bundleName = packageName + \".LocalStrings\"; ResourceBundle bnd = null; try { bnd = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { bnd = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) {  } } } bundle = bnd;  if (bundle != null) { locale = bundle.getLocale(); } else { locale = null; }",
        "ins1PreCode":"String bundleName = packageName + \".LocalStrings\"; try { bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { bundle = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl);",
        "ins2PreCode":"private StringManager(String packageName) { String bundleName = packageName + \".LocalStrings\"; try { bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { bundle = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) {  } } }  if (bundle != null) { locale = bundle.getLocale(); }",
        "label":0
    },
    {
        "ins1CurCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = this.httpClientBuilder.get().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "ins1PreCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "ins2PreCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "label":1
    },
    {
        "ins1CurCode":"}  parents[i] = new ParallelReduceSubscriber<>(subscribers[i], initialValue, reducer); }",
        "ins1PreCode":"}  parents[i] = new ParallelReduceSubscriber<T, R>(subscribers[i], initialValue, reducer); }",
        "ins2PreCode":"}  parents[i] = new ParallelCollectSubscriber<T, C>(subscribers[i], initialValue, collector); }",
        "label":1
    },
    {
        "ins1CurCode":"TomcatReactiveWebServerFactory factory = getFactory(); HttpHandler handler = mock(HttpHandler.class); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>>[] customizers = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class));",
        "ins1PreCode":"TomcatReactiveWebServerFactory factory = getFactory(); HttpHandler handler = mock(HttpHandler.class); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class));",
        "ins2PreCode":"public void builderCustomizersShouldBeInvoked() { UndertowReactiveWebServerFactory factory = getFactory(); HttpHandler handler = mock(HttpHandler.class); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class)); factory.setBuilderCustomizers(Arrays.asList(customizers[0], customizers[1])); factory.addBuilderCustomizers(customizers[2], customizers[3]); this.webServer = factory.getWebServer(handler); InOrder ordered = inOrder((Object[]) customizers); for (UndertowBuilderCustomizer customizer : customizers) { ordered.verify(customizer).customize(any(Undertow.Builder.class)); }",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(Observer<? super T> observer) { CreateEmitter<T> parent = new CreateEmitter<>(observer); observer.onSubscribe(parent);",
        "ins1PreCode":"protected void subscribeActual(Observer<? super T> observer) { CreateEmitter<T> parent = new CreateEmitter<T>(observer); observer.onSubscribe(parent);",
        "ins2PreCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { Emitter<T> parent = new Emitter<T>(observer); observer.onSubscribe(parent);",
        "label":1
    },
    {
        "ins1CurCode":"\"3-Header-[x-ignore]-[...]\\n\" + \"3-Header-[content-type]-[text/plain;charset=UTF-8]\\n\" + \"3-Header-[content-length]-[2]\\n\" + \"3-Header-[date]-[Wed, 11 Nov 2015 19:18:42 GMT]\\n\" +",
        "ins1PreCode":"\"3-Header-[x-ignore]-[...]\\n\" + \"3-Header-[content-type]-[text/plain;charset=UTF-8]\\n\" + \"3-Header-[date]-[Wed, 11 Nov 2015 19:18:42 GMT]\\n\" + \"3-HeadersEnd\\n\" +",
        "ins2PreCode":"public void testAsyncComplete() throws Exception { enableHttp2();  Tomcat tomcat = getTomcatInstance();    Context ctxt = tomcat.addContext(\"\", null); Tomcat.addServlet(ctxt, \"simple\", new SimpleServlet()); ctxt.addServletMappingDecoded(\"/simple\", \"simple\"); Wrapper w = Tomcat.addServlet(ctxt, \"async\", new AsyncComplete()); w.setAsyncSupported(true); ctxt.addServletMappingDecoded(\"/async\", \"async\");  tomcat.start();  openClientConnection(); doHttpUpgrade(); sendClientPreface(); validateHttp2InitialResponse();  byte[] frameHeader = new byte[9]; ByteBuffer headersPayload = ByteBuffer.allocate(128); buildGetRequest(frameHeader, headersPayload, null, 3, \"/async\"); writeFrame(frameHeader, headersPayload);  readSimpleGetResponse();   parser.readFrame(true);  Assert.assertEquals( \"3-HeadersStart\\n\" + \"3-Header-[:status]-[200]\\n\" + \"3-Header-[content-type]-[text/plain;charset=UTF-8]\\n\" + \"3-Header-[date]-[Wed, 11 Nov 2015 19:18:42 GMT]\\n\" + \"3-HeadersEnd\\n\" + \"3-Body-17\\n\" + \"3-Body-8\\n\" + \"3-EndOfStream\\n\", output.getTrace()); ",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldGetUsersByNameWithParamNameAndOrderBy() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldGetUsersByNameWithParamNameAndOrderBy() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getUsersByNameWithParamNameAndOrderBy(\"User\", \"id DESC\"); assertEquals(4, users.size()); assertEquals(\"User4\", users.get(0).getName()); assertEquals(\"User3\", users.get(1).getName()); assertEquals(\"User2\", users.get(2).getName()); assertEquals(\"User1\", users.get(3).getName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldGetUsersByNameWithParamNameUsingMap() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getUsersByNameWithParamNameAndOrderBy(\"User\", \"id DESC\"); assertEquals(4, users.size()); assertEquals(\"User4\", users.get(0).getName()); assertEquals(\"User3\", users.get(1).getName()); assertEquals(\"User2\", users.get(2).getName()); assertEquals(\"User1\", users.get(3).getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster); Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV, Arrays.asList( new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED, \"127.0.0.1\", \"127.0.0.1\", Optional.empty(), Optional.of(1234L), Optional.of(\"endpoint-1\")), new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTING, \"127.0.0.1\", \"127.0.0.1\", Optional.empty(), Optional.of(1234L), Optional.of(\"endpoint-2\")))); DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, \"test-sdk\", \"test-id\"); given(cluster.diagnostics()).willReturn(diagnostics);",
        "ins1PreCode":"Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster); List<EndpointHealth> endpoints = Arrays.asList( new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-1\"), new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTING, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-2\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics);",
        "ins2PreCode":"Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster); List<EndpointHealth> endpoints = Arrays.asList(new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-1\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics);",
        "label":0
    },
    {
        "ins1CurCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { boolean atLeastV9 = dataSource.isAtLeastV9(); try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, \"); if (atLeastV9) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\");    if(atLeastV9) { sql.append(\" AND s.sql_child_number = sq.child_number\"); }",
        "ins1PreCode":"StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM GV$SESSION s \\n\" + \"LEFT JOIN gv$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN gv$sess_io io ON ( s.sid = io.sid AND s.inst_id = io.inst_id )\\n\" +   \"WHERE 1=1\"); if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) {",
        "ins2PreCode":"public Collection<PostgreSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>(); while (dbResult.next()) { sessions.add(new PostgreSession(dbResult)); } return sessions; } } } catch (SQLException e) { throw new DBException(e, session.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK); Thread.sleep(250);",
        "ins1PreCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK); Thread.sleep(250);",
        "ins2PreCode":"public void testDataSendACK() throws Exception { System.err.println(\"Starting ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(),GroupChannel.SEND_OPTIONS_USE_ACK); Thread.sleep(250);",
        "label":0
    },
    {
        "ins1CurCode":"  SparkSession spark = SparkSession.builder().appName(\"JavaKMeansExample\").getOrCreate();    JavaRDD<Row> points = spark.read().text(inputFile).javaRDD().map(new ParsePoint()); StructField[] fields = {new StructField(\"features\", new VectorUDT(), false, Metadata.empty())}; StructType schema = new StructType(fields); Dataset<Row> dataset = spark.createDataFrame(points, schema);   KMeans kmeans = new KMeans() .setK(k); KMeansModel model = kmeans.fit(dataset);   Vector[] centers = model.clusterCenters(); System.out.println(\"Cluster Centers: \"); for (Vector center: centers) { System.out.println(center); }   spark.stop();",
        "ins1PreCode":"  SparkConf conf = new SparkConf().setAppName(\"JavaKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc);    JavaRDD<Row> points = jsc.textFile(inputFile).map(new ParsePoint()); StructField[] fields = {new StructField(\"features\", new VectorUDT(), false, Metadata.empty())}; StructType schema = new StructType(fields); Dataset<Row> dataset = sqlContext.createDataFrame(points, schema);   KMeans kmeans = new KMeans() .setK(k); KMeansModel model = kmeans.fit(dataset);   Vector[] centers = model.clusterCenters(); System.out.println(\"Cluster Centers: \"); for (Vector center: centers) { System.out.println(center); }   jsc.stop();",
        "ins2PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaBisectingKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   JavaRDD<Row> data = jsc.parallelize(Arrays.asList( RowFactory.create(Vectors.dense(0.1, 0.1, 0.1)), RowFactory.create(Vectors.dense(0.3, 0.3, 0.25)), RowFactory.create(Vectors.dense(0.1, 0.1, -0.1)), RowFactory.create(Vectors.dense(20.3, 20.1, 19.9)), RowFactory.create(Vectors.dense(20.2, 20.1, 19.7)), RowFactory.create(Vectors.dense(18.9, 20.0, 19.7)) ));  StructType schema = new StructType(new StructField[]{ new StructField(\"features\", new VectorUDT(), false, Metadata.empty()), });  Dataset<Row> dataset = jsql.createDataFrame(data, schema);  BisectingKMeans bkm = new BisectingKMeans().setK(2); BisectingKMeansModel model = bkm.fit(dataset);  System.out.println(\"Compute Cost: \" + model.computeCost(dataset));  Vector[] clusterCenters = model.clusterCenters(); for (int i = 0; i < clusterCenters.length; i++) { Vector clusterCenter = clusterCenters[i]; System.out.println(\"Cluster Center \" + i + \": \" + clusterCenter); }   jsc.stop();",
        "label":0
    },
    {
        "ins1CurCode":"final String key = HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey(); final int maxContentLength = randomIntBetween(1, 104857600); final Settings settings = createBuilderWithPort().put(key, maxContentLength + \"b\").build(); final int contentLength = randomIntBetween(maxContentLength + 1, Integer.MAX_VALUE);",
        "ins1PreCode":"final String key = HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey(); final int maxContentLength = randomIntBetween(1, 104857600); final Settings settings = Settings.builder().put(key, maxContentLength + \"b\").build(); final int contentLength = randomIntBetween(maxContentLength + 1, Integer.MAX_VALUE);",
        "ins2PreCode":"final String key = HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey(); final int maxContentLength = randomIntBetween(1, 104857600); final Settings settings = Settings.builder().put(key, maxContentLength + \"b\").build(); final int contentLength = randomIntBetween(maxContentLength + 1, Integer.MAX_VALUE);",
        "label":1
    },
    {
        "ins1CurCode":"});  TestObserverEx<Integer> to = new TestObserverEx<>(); firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);",
        "ins1PreCode":"});  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);",
        "ins2PreCode":"});  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); assertThat(output).isEqualTo(expectedOutput.toString());",
        "ins1PreCode":"expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); assertEquals(output, expectedOutput.toString());",
        "ins2PreCode":"expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); Assert.assertEquals(output, expectedOutput.toString());",
        "label":0
    },
    {
        "ins1CurCode":"graph.addNode(gen.nextInt(NODE_POOL_SIZE)); } ArrayList<Integer> nodeList = new ArrayList<>(graph.nodes()); while (graph.edges().size() < NUM_EDGES) { graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen)); } ArrayList<EndpointPair<Integer>> edgeList = new ArrayList<>(graph.edges()); ",
        "ins1PreCode":"graph.addNode(gen.nextInt(NODE_POOL_SIZE)); } ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes()); while (graph.edges().size() < NUM_EDGES) { graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen)); } ArrayList<EndpointPair<Integer>> edgeList = new ArrayList<EndpointPair<Integer>>(graph.edges()); ",
        "ins2PreCode":"graph.addNode(gen.nextInt(NODE_POOL_SIZE)); } ArrayList<Integer> nodeList = new ArrayList<Integer>(graph.nodes()); while (graph.edges().size() < NUM_EDGES) { graph.putEdge(getRandomElement(nodeList, gen), getRandomElement(nodeList, gen)); } ArrayList<EndpointPair<Integer>> edgeList = new ArrayList<EndpointPair<Integer>>(graph.edges()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void cancelAfterFirst() { final TestObserver<Void> to = new TestObserver<>(); ",
        "ins1PreCode":"public void cancelAfterFirst() { final TestObserver<Void> to = new TestObserver<Void>(); ",
        "ins2PreCode":"public void cancelAfterFirstDelayError() { final TestObserver<Void> to = new TestObserver<Void>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public static DynamicMBean createMBean(ContextEnvironment environment) throws Exception {",
        "ins1PreCode":"static DynamicMBean createMBean(ContextEnvironment environment) throws Exception {",
        "ins2PreCode":"static DynamicMBean createMBean(Group group) throws Exception {  String mname = createManagedName(group); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception(\"ManagedBean is not found with \"+mname); throw new MBeanException(e); } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); DynamicMBean mbean = managed.createMBean(group); ObjectName oname = createObjectName(domain, group); if( mserver.isRegistered( oname ))  { mserver.unregisterMBean(oname); } mserver.registerMBean(mbean, oname); return (mbean); ",
        "label":0
    },
    {
        "ins1CurCode":"expected.remove(IdParserFetcher.class);  expected.remove(ACMPortalFetcher.class); expected.remove(GoogleScholar.class); ",
        "ins1PreCode":"expected.remove(IdParserFetcher.class); assertEquals(expected, getClasses(idFetchers)); }",
        "ins2PreCode":"assertEquals(expected, getClasses(fullTextFetchers)); }",
        "label":0
    },
    {
        "ins1CurCode":"private static AggregationScript.LeafFactory newAggregationScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {",
        "ins1PreCode":"private AggregationScript.LeafFactory newAggregationScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {",
        "ins2PreCode":"private ScoreScript.LeafFactory newScoreScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) { ",
        "label":1
    },
    {
        "ins1CurCode":"DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetadata build = IndexMetadata.builder(\"\") .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build();",
        "ins1PreCode":"DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build();",
        "ins2PreCode":"DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build();",
        "label":1
    },
    {
        "ins1CurCode":"void setLoggerGroupWithNullLogLevel() { this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V3_JSON)) .bodyValue(Collections.singletonMap(\"configuredLevel\", null)).exchange().expectStatus().isNoContent();",
        "ins1PreCode":"void setLoggerGroupWithNullLogLevel() { this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON)) .bodyValue(Collections.singletonMap(\"configuredLevel\", null)).exchange().expectStatus().isNoContent();",
        "ins2PreCode":"void setLoggerGroupUsingApplicationJsonShouldSetLogLevel() { this.client.post().uri(\"/actuator/loggers/test\").contentType(MediaType.APPLICATION_JSON) .bodyValue(Collections.singletonMap(\"configuredLevel\", \"debug\")).exchange().expectStatus() .isNoContent(); verify(this.loggingSystem).setLogLevel(\"test.member1\", LogLevel.DEBUG); verify(this.loggingSystem).setLogLevel(\"test.member2\", LogLevel.DEBUG);",
        "label":0
    },
    {
        "ins1CurCode":"} } Tick tick = new NumberTick(currentTickValue, tickLabel, anchor, rotationAnchor, angle); ticks.add(tick);",
        "ins1PreCode":"} } Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); ticks.add(tick);",
        "ins2PreCode":"} } Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); ticks.add(tick);",
        "label":1
    },
    {
        "ins1CurCode":"  assertEquals(1, message.getInt32ToEnumFieldMap().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumFieldMap().get(1));  assertFalse(message.getUnknownFields().asMap().isEmpty());  data = message.toByteString(); TestUnknownEnumValue messageWithUnknownEnums = TestUnknownEnumValue.parseFrom(data); assertEquals(2, messageWithUnknownEnums.getInt32ToInt32FieldMap().size()); assertEquals(1, messageWithUnknownEnums.getInt32ToInt32FieldMap().get(1).intValue()); assertEquals(54321, messageWithUnknownEnums.getInt32ToInt32FieldMap().get(2).intValue());",
        "ins1PreCode":"  assertEquals(1, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1));  assertFalse(message.getUnknownFields().asMap().isEmpty());  data = message.toByteString(); TestUnknownEnumValue messageWithUnknownEnums = TestUnknownEnumValue.parseFrom(data); assertEquals(2, messageWithUnknownEnums.getInt32ToInt32Field().size()); assertEquals(1, messageWithUnknownEnums.getInt32ToInt32Field().get(1).intValue()); assertEquals(54321, messageWithUnknownEnums.getInt32ToInt32Field().get(2).intValue());",
        "ins2PreCode":"  assertEquals(1, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1));  data = message.toByteString(); TestUnknownEnumValue messageWithUnknownEnums = TestUnknownEnumValue.parseFrom(data); assertEquals(2, messageWithUnknownEnums.getInt32ToInt32Field().size()); assertEquals(1, messageWithUnknownEnums.getInt32ToInt32Field().get(1).intValue()); assertEquals(54321, messageWithUnknownEnums.getInt32ToInt32Field().get(2).intValue());",
        "label":1
    },
    {
        "ins1CurCode":"} size--; element.invalidate(); }",
        "ins1PreCode":"} size--; element.setValid(false); }",
        "ins2PreCode":"} size--; element.setValid(false); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindYValueNonSorted() { XYSeries<String> series = new XYSeries<>(\"S1\", false); XYSeriesCollection<String> dataset = new XYSeriesCollection<>(series); assertTrue(Double.isNaN(DatasetUtils.findYValue(dataset, 0, 100.0)));",
        "ins1PreCode":"public void testFindYValueNonSorted() { XYSeries series = new XYSeries(\"S1\", false); XYSeriesCollection dataset = new XYSeriesCollection(series); assertTrue(Double.isNaN(DatasetUtils.findYValue(dataset, 0, 100.0)));",
        "ins2PreCode":"public void testFindYValueWithDuplicates() { XYSeries series = new XYSeries(\"S1\", true, true); XYSeriesCollection dataset = new XYSeriesCollection(series); assertTrue(Double.isNaN(DatasetUtils.findYValue(dataset, 0, 100.0)));",
        "label":1
    },
    {
        "ins1CurCode":"source.put(\"foo.items\", \"a,b,c,c\"); this.sources.add(source); ExampleCustomNoDefaultConstructorBean result = this.binder .bind(\"foo\", ExampleCustomNoDefaultConstructorBean.class).get(); assertThat(result.getItems()).hasSize(4);",
        "ins1PreCode":"source.put(\"foo.items\", \"a,b,c,c\"); this.sources.add(source); ExampleCustomBean result = this.binder.bind(\"foo\", ExampleCustomBean.class).get(); assertThat(result.getItems()).hasSize(4);",
        "ins2PreCode":"public void bindToCollectionShouldAlsoCallSetterIfPresent() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.items\", \"a,b,c\"); this.sources.add(source); ExampleCollectionBean result = this.binder .bind(\"foo\", ExampleCollectionBean.class).get(); assertThat(result.getItems()).hasSize(4); assertThat(result.getItems()).containsExactly(\"a\", \"b\", \"c\", \"d\");",
        "label":0
    },
    {
        "ins1CurCode":"void shouldAssignKeysToList() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldAssignKeysToList() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldAssignKeysToNamedList() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"if (groups.size() > 0) { sb.append(\" groups=\\\"\"); StringUtils.join(groups, ',', (x) -> RequestUtil.filter(x.getGroupname()), sb); sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\" roles=\\\"\"); StringUtils.join(roles, ',', (x) -> RequestUtil.filter(x.getRolename()), sb); sb.append(\"\\\"\"); } } sb.append(\"/>\"); return sb.toString();",
        "ins1PreCode":"if (groups.size() > 0) { sb.append(\" groups=\\\"\"); int n = 0; Iterator<Group> values = groups.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getGroupname())); } sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\" roles=\\\"\"); int n = 0; Iterator<Role> values = roles.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getRolename())); } sb.append(\"\\\"\"); } } sb.append(\"/>\"); return (sb.toString()); ",
        "ins2PreCode":"if (groups.size() > 0) { sb.append(\", groups=\\\"\"); int n = 0; Iterator<Group> values = groups.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getGroupname())); } sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\", roles=\\\"\"); int n = 0; Iterator<Role> values = roles.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getRolename())); } sb.append(\"\\\"\"); } } return (sb.toString());",
        "label":1
    },
    {
        "ins1CurCode":"&& !m.signature.contains(\"MaybeSource\") && !m.signature.contains(\"Disposable\") && !m.signature.contains(\"void subscribe\") ) {",
        "ins1PreCode":"&& !m.signature.contains(\"MaybeSource\") && !m.signature.contains(\"Disposable\") ) { CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11);",
        "ins2PreCode":"public void parallelFlowableDocRefersToCorrectTypes() throws Exception { List<RxMethod> list = BaseTypeParser.parse(TestHelper.findSource(\"ParallelFlowable\", \"io.reactivex.rxjava3.parallel\"), \"ParallelFlowable\");  assertFalse(list.isEmpty());  StringBuilder e = new StringBuilder();  for (RxMethod m : list) { int jdx; if (m.javadoc != null) { jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"onSuccess\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Maybe\") && !m.signature.contains(\"MaybeSource\") && !m.signature.contains(\"Single\") && !m.signature.contains(\"SingleSource\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions onSuccess\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Observer\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions Observer but not using Observable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" SingleObserver\", jdx); if (idx >= 0) { if (!m.signature.contains(\"SingleSource\") && !m.signature.contains(\"Single\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions SingleObserver but not using Single\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" MaybeObserver\", jdx); if (idx >= 0) { if (!m.signature.contains(\"MaybeSource\") && !m.signature.contains(\"Maybe\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions MaybeObserver but not using Maybe\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Disposable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\") && !m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Single\") && !m.signature.contains(\"SingleSource\") && !m.signature.contains(\"Completable\") && !m.signature.contains(\"CompletableSource\") && !m.signature.contains(\"Maybe\") && !m.signature.contains(\"MaybeSource\") && !m.signature.contains(\"Disposable\") ) { CharSequence subSequence = m.javadoc.subSequence(idx - 6, idx + 11); if (idx < 6 || !subSequence.equals(\"{@link Disposable\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions Disposable but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"ObservableSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Flowable doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Flowable.method(Flowable.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } }  checkAtReturnAndSignatureMatch(\"ParallelFlowable\", m, e, \"Flowable\", \"Observable\", \"Maybe\", \"Single\", \"Completable\", \"ConnectableFlowable\", \"ParallelFlowable\", \"Disposable\", \"Iterable\", \"Stream\", \"Future\", \"CompletionStage\");  aOrAn(e, m, \"ParallelFlowable\"); missingClosingDD(e, m, \"ParallelFlowable\", \"io.reactivex.rxjava3.parallel\"); backpressureMentionedWithoutAnnotation(e, m, \"ParallelFlowable\"); } }  if (e.length() != 0) { System.out.println(e);  fail(e.toString()); }",
        "label":0
    },
    {
        "ins1CurCode":"sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { setConnectionTimeoutForStreamCount(activeRemoteStreamCount.decrementAndGet()); }",
        "ins1PreCode":"sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); }",
        "ins2PreCode":"sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); }",
        "label":1
    },
    {
        "ins1CurCode":"public final void testAttributes() { ZipFileSet f = (ZipFileSet) getInstance();  f.setSrc(new File(\"example.zip\")); try { f.setDir(new File(\"examples\")); fail(\"can add dir to \" + f.getDataTypeName() + \" when a src is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\", be.getMessage()); } f = (ZipFileSet) getInstance();  f.setDir(new File(\"examples\")); try { f.setSrc(new File(\"example.zip\")); fail(\"can add src to \" + f.getDataTypeName() + \" when a dir is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\", be.getMessage()); }  f = (ZipFileSet) getInstance(); f.setSrc(new File(\"example.zip\")); f.setPrefix(\"/examples\"); try { f.setFullpath(\"/doc/manual/index.html\"); fail(\"Can add fullpath to \" + f.getDataTypeName() + \" when a prefix is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); } f = (ZipFileSet) getInstance(); f.setSrc(new File(\"example.zip\")); f.setFullpath(\"/doc/manual/index.html\"); try { f.setPrefix(\"/examples\"); fail(\"Can add prefix to \" + f.getDataTypeName() + \" when a fullpath is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); }  f = (ZipFileSet) getInstance(); f.setRefid(new Reference(getProject(), \"test\")); try { f.setSrc(new File(\"example.zip\")); fail(\"Can add src to \" + f.getDataTypeName() + \" when a refid is already present\"); } catch (BuildException be) { assertEquals(\"You must not specify more than one \" + \"attribute when using refid\", be.getMessage()); }  f = (ZipFileSet) getInstance(); f.setSrc(new File(\"example.zip\")); f.setPrefix(\"/examples\"); f.setFileMode(\"600\"); f.setDirMode(\"530\"); getProject().addReference(\"test\",f); ZipFileSet zid = (ZipFileSet) getInstance(); zid.setRefid(new Reference(getProject(), \"test\")); assertTrue(\"src attribute copied by copy constructor\", zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\", f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertEquals(\"file mode attribute copied by copy constructor\", f.getFileMode(getProject()), zid.getFileMode(getProject())); assertEquals(\"dir mode attribute copied by copy constructor\", f.getDirMode(getProject()), zid.getDirMode(getProject()));",
        "ins1PreCode":"public final void testAttributes() { ZipFileSet f = (ZipFileSet)getInstance();  f.setSrc(new File(\"example.zip\")); try { f.setDir(new File(\"examples\")); fail(\"can add dir to \" + f.getDataTypeName() + \" when a src is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); } f = (ZipFileSet)getInstance();  f.setDir(new File(\"examples\")); try { f.setSrc(new File(\"example.zip\")); fail(\"can add src to \" + f.getDataTypeName() + \" when a dir is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); }  f = (ZipFileSet)getInstance(); f.setSrc(new File(\"example.zip\")); f.setPrefix(\"/examples\"); try { f.setFullpath(\"/doc/manual/index.html\"); fail(\"Can add fullpath to \" + f.getDataTypeName() + \" when a prefix is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); } f = (ZipFileSet)getInstance(); f.setSrc(new File(\"example.zip\")); f.setFullpath(\"/doc/manual/index.html\"); try { f.setPrefix(\"/examples\"); fail(\"Can add prefix to \" + f.getDataTypeName() + \" when a fullpath is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); }  f = (ZipFileSet)getInstance(); f.setRefid(new Reference(getProject(), \"test\")); try { f.setSrc(new File(\"example.zip\")); fail(\"Can add src to \" + f.getDataTypeName() + \" when a refid is already present\"); } catch (BuildException be) { assertEquals(\"You must not specify more than one \" + \"attribute when using refid\", be.getMessage()); }  f = (ZipFileSet)getInstance(); f.setSrc(new File(\"example.zip\")); f.setPrefix(\"/examples\"); f.setFileMode(\"600\"); f.setDirMode(\"530\"); getProject().addReference(\"test\",f); ZipFileSet zid=(ZipFileSet)getInstance(); zid.setRefid(new Reference(getProject(), \"test\")); assertTrue(\"src attribute copied by copy constructor\",zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\",f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertTrue(\"file mode attribute copied by copy constructor\",f.getFileMode(getProject())==zid.getFileMode(getProject())); assertTrue(\"dir mode attribute copied by copy constructor\",f.getDirMode(getProject())==zid.getDirMode(getProject()));",
        "ins2PreCode":"public final void testAttributes() { TarFileSet f = (TarFileSet)getInstance();  f.setSrc(new File(\"example.tar\")); try { f.setDir(new File(\"examples\")); fail(\"can add dir to \" + f.getDataTypeName() + \" when a src is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); } f = (TarFileSet)getInstance();  f.setDir(new File(\"examples\")); try { f.setSrc(new File(\"example.tar\")); fail(\"can add src to \" + f.getDataTypeName() + \" when a dir is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); }  f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); f.setPrefix(\"/examples\"); try { f.setFullpath(\"/doc/manual/index.html\"); fail(\"Can add fullpath to \" + f.getDataTypeName() + \" when a prefix is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); } f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); f.setFullpath(\"/doc/manual/index.html\"); try { f.setPrefix(\"/examples\"); fail(\"Can add prefix to \" + f.getDataTypeName() + \" when a fullpath is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); }  f = (TarFileSet)getInstance(); f.setRefid(new Reference(getProject(), \"test\")); try { f.setSrc(new File(\"example.tar\")); fail(\"Can add src to \" + f.getDataTypeName() + \" when a refid is already present\"); } catch (BuildException be) { assertEquals(\"You must not specify more than one \" + \"attribute when using refid\", be.getMessage()); }  f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); f.setPrefix(\"/examples\"); f.setFileMode(\"600\"); f.setDirMode(\"530\"); getProject().addReference(\"test\",f); TarFileSet zid=(TarFileSet)getInstance(); zid.setRefid(new Reference(getProject(), \"test\")); assertTrue(\"src attribute copied by copy constructor\",zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\",f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertTrue(\"file mode attribute copied by copy constructor\",f.getFileMode(getProject())==zid.getFileMode(getProject())); assertTrue(\"dir mode attribute copied by copy constructor\",f.getDirMode(getProject())==zid.getDirMode(getProject()));",
        "label":0
    },
    {
        "ins1CurCode":"+ \"\\\"H\\\" \\\"Ha\\\" = } \" + \"EXECUTE {a}\");  vm.run(Collections.emptyList()); ",
        "ins1PreCode":"+ \"\\\"H\\\" \\\"Ha\\\" = } \" + \"EXECUTE {a}\");  List<BibEntry> v = new ArrayList<>(); vm.run(v); ",
        "ins2PreCode":"+ \"#1 #1 or #0 #1 or #1 #0 or #0 #0 or }\" + \"EXECUTE {test}\");  List<BibEntry> v = new ArrayList<>(); vm.run(v); assertEquals(VM.FALSE, vm.getStack().pop());",
        "label":1
    },
    {
        "ins1CurCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins2PreCode":"Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1CurCode":"public void unorderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "ins1PreCode":"public void unorderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "ins2PreCode":"public void orderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldRemoveItemVariableInTheContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldRemoveItemVariableInTheContext() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); int result = mapper.itemVariableConflict(5, Arrays.asList(1, 2), Arrays.asList(3, 4)); Assert.assertEquals(5, result); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldRemoveIndexVariableInTheContext() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); int result = mapper.indexVariableConflict(4, Arrays.asList(6, 7), Arrays.asList(8, 9)); Assert.assertEquals(4, result); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":" Dataset<Row> output = vectorSlicer.transform(dataset); output.show(false); ",
        "ins1PreCode":"Dataset<Row> output = vectorSlicer.transform(dataset);  System.out.println(output.select(\"userFeatures\", \"features\").first()); ",
        "ins2PreCode":"public void vectorSlice() { Attribute[] attrs = new Attribute[]{ NumericAttribute.defaultAttr().withName(\"f1\"), NumericAttribute.defaultAttr().withName(\"f2\"), NumericAttribute.defaultAttr().withName(\"f3\") }; AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);  List<Row> data = Arrays.asList( RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})), RowFactory.create(Vectors.dense(-2.0, 2.3, 0.0)) );  Dataset<Row> dataset = spark.createDataFrame(data, (new StructType()).add(group.toStructField()));  VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\");  vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});  Dataset<Row> output = vectorSlicer.transform(dataset);  for (Row r : output.select(\"userFeatures\", \"features\").takeAsList(2)) { Vector features = r.getAs(1); Assert.assertEquals(features.size(), 2); }",
        "label":0
    },
    {
        "ins1CurCode":"try { StringBuffer sb = new StringBuffer(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart++ < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart++ < 0 || !sb.substring(windowStart).equals(s)) { while (Calendar.getInstance().before(endTime)",
        "ins1PreCode":"StringBuffer sb = new StringBuffer(); if (timeout == null || timeout.intValue() == 0) { while (sb.toString().indexOf(s) == -1) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (sb.toString().indexOf(s) == -1) { while (Calendar.getInstance().before(endTime)",
        "ins2PreCode":"StringBuffer sb = new StringBuffer(); if (timeout == null || timeout.intValue() == 0) { while (sb.toString().indexOf(s) == -1) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (sb.toString().indexOf(s) == -1) { while (Calendar.getInstance().before(endTime)",
        "label":1
    },
    {
        "ins1CurCode":" try { TestSingle<Integer> tc = new TestSingle<>(); ",
        "ins1PreCode":" try { TestSingle<Integer> tc = new TestSingle<Integer>(); ",
        "ins2PreCode":"public void startOnce() {  List<Throwable> error = TestHelper.trackPluginErrors();  try { TestCompletable tc = new TestCompletable();  tc.onSubscribe(Disposable.empty());  Disposable d = Disposable.empty();  tc.onSubscribe(d);  assertTrue(d.isDisposed());  assertEquals(1, tc.start);  TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName())); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress()); list.sort(Comparator.comparing(WebFetcher::getName));",
        "ins1PreCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"public static List<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new zbMATH(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1CurCode":"Flowable<Integer> result = source.withLatestFrom(other, COMBINER);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"Flowable<Integer> result = source.withLatestFrom(other, COMBINER);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"Flowable<Integer> result = source.withLatestFrom(other, COMBINER);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins1PreCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress()); list.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins2PreCode":"public static List<EntryBasedFetcher> getEntryBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<EntryBasedFetcher> list = new ArrayList<>(); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1CurCode":"File newWLJarFile = null; JarOutputStream newJarStream = null; ClassLoader genericLoader = null;  try { log(\"Checking if weblogic Jar needs to be rebuilt for jar \" + weblogicJarFile.getName(), Project.MSG_VERBOSE);  if (genericJarFile.exists() && genericJarFile.isFile() && weblogicJarFile.exists() && weblogicJarFile.isFile()) {  genericJar = new JarFile(genericJarFile); wlJar = new JarFile(weblogicJarFile);  Hashtable genericEntries = new Hashtable(); Hashtable wlEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable();   for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);  if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } } else {   log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile)); newJarStream.setLevel(0);   for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage();  throw new BuildException(msg, ioe); } finally {  if (genericJar != null) { try { genericJar.close(); } catch (IOException closeException) { } }  if (wlJar != null) { try { wlJar.close(); } catch (IOException closeException) { } }  if (newJarStream != null) { try { newJarStream.close(); } catch (IOException closeException) { }  try { FILE_UTILS.rename(newWLJarFile, weblogicJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true; } } if (genericLoader != null && genericLoader instanceof AntClassLoader) { AntClassLoader loader = (AntClassLoader) genericLoader;",
        "ins1PreCode":"  ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);  if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } } else {   log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile)); newJarStream.setLevel(0);   for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); }  if (genericLoader instanceof AntClassLoader) { AntClassLoader loader = (AntClassLoader) genericLoader;",
        "ins2PreCode":"protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile) { boolean rebuild = false;  JarFile genericJar = null; JarFile wasJar = null; File newwasJarFile = null; JarOutputStream newJarStream = null;  try { log(\"Checking if websphere Jar needs to be rebuilt for jar \" + websphereJarFile.getName(), Project.MSG_VERBOSE);  if (genericJarFile.exists() && genericJarFile.isFile() && websphereJarFile.exists() && websphereJarFile.isFile()) {  genericJar = new JarFile(genericJarFile); wasJar = new JarFile(websphereJarFile);  Hashtable genericEntries = new Hashtable(); Hashtable wasEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable();   for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  wasEntries.put(je.getName(), je); }   ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wasEntries.containsKey(filepath)) {   JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);  if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; } break; } } } else {   log(\"File \" + filepath + \" not present in websphere jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newwasJarFile = new File(websphereJarFile.getAbsolutePath() + \".temp\"); if (newwasJarFile.exists()) { newwasJarFile.delete(); }  newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile)); newJarStream.setLevel(0);   for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wasJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"websphere Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage();  throw new BuildException(msg, ioe); } finally {  if (genericJar != null) { try { genericJar.close(); } catch (IOException closeException) { } }  if (wasJar != null) { try { wasJar.close(); } catch (IOException closeException) { } }  if (newJarStream != null) { try { newJarStream.close(); } catch (IOException closeException) { }  try { FILE_UTILS.rename(newwasJarFile, websphereJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true; } } }  return rebuild;",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"public void testTimeOut() { Commandline cmd = getCommandline(TIME_OUT * 2);",
        "ins1PreCode":"public void testTimeOut() throws Exception { Commandline cmd = getCommandline(TIME_OUT * 2);",
        "ins2PreCode":"public void testTimeOutForked() throws Exception { Commandline cmd = getCommandline(TIME_OUT * 2);",
        "label":1
    },
    {
        "ins1CurCode":"public void testTwoFiles() throws URISyntaxException { Path texFile = Path.of(DefaultTexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Path.of(DefaultTexParserTest.class.getResource(\"paper2.tex\").toURI()); ",
        "ins1PreCode":"public void testTwoFiles() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Paths.get(DefaultTexParserTest.class.getResource(\"paper2.tex\").toURI()); ",
        "ins2PreCode":"public void testTwoFilesDifferentDatabases() throws URISyntaxException { Path texFile = Paths.get(LatexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Paths.get(LatexParserTest.class.getResource(\"paper2.tex\").toURI()); ",
        "label":1
    },
    {
        "ins1CurCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> documents = sc.parallelize(Arrays.asList( Arrays.asList(\"this is a sentence\".split(\" \")), Arrays.asList(\"this is another sentence\".split(\" \")), Arrays.asList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents);",
        "ins1PreCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")), Lists.newArrayList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents);",
        "ins2PreCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")), Lists.newArrayList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents);",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribe(Subscriber<? super T>[] subscribers) { subscribers = RxJavaPlugins.onSubscribe(this, subscribers); ",
        "ins1PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return;",
        "ins2PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return;",
        "label":1
    },
    {
        "ins1CurCode":"Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString); entryFromBibFile.get().setFiles(Arrays.asList( new LinkedFile(\"\", Path.of(\"paper.pdf\"), \"PDF\"), new LinkedFile(\"\", pathPdf.toAbsolutePath(), \"PDF\")) );",
        "ins1PreCode":"Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString); entryFromBibFile.get().setFiles(Arrays.asList( new LinkedFile(\"\", \"paper.pdf\", \"PDF\"), new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\")) );",
        "ins2PreCode":"Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString); entryFromBibFile.get().setFiles(Collections.singletonList( new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\")) );",
        "label":0
    },
    {
        "ins1CurCode":"Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster); Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV, Collections.singletonList(new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED, \"127.0.0.1\", \"127.0.0.1\", Optional.empty(), Optional.of(1234L), Optional.of(\"endpoint-1\")))); DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, \"test-sdk\", \"test-id\"); given(cluster.diagnostics()).willReturn(diagnostics);",
        "ins1PreCode":"Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster); List<EndpointHealth> endpoints = Arrays.asList(new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-1\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics);",
        "ins2PreCode":"Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster); List<EndpointHealth> endpoints = Arrays.asList( new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-1\"), new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTING, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-2\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics);",
        "label":0
    },
    {
        "ins1CurCode":"public void testSearchingForOpenBraketInBooktitle() { BibEntry e = new BibEntry(StandardEntryType.InProceedings); e.setField(StandardField.BOOKTITLE, \"Super Conference (SC)\");  SearchQuery searchQuery = new SearchQuery(\"booktitle=\\\"(\\\"\", EnumSet.noneOf(SearchFlags.class)); assertTrue(searchQuery.isMatch(e));",
        "ins1PreCode":"public void testSearchingForOpenBraketInBooktitle() { BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS.getName()); e.setField(FieldName.BOOKTITLE, \"Super Conference (SC)\");  SearchQuery searchQuery = new SearchQuery(\"booktitle=\\\"(\\\"\", false, false); assertTrue(searchQuery.isMatch(e));",
        "ins2PreCode":"e.setField(StandardField.KEYWORDS, \"banana, pineapple, orange\");  SearchQuery searchQuery = new SearchQuery(\"anyfield==\\\"fruity features\\\"\", false, false); assertTrue(searchQuery.isMatch(e));",
        "label":0
    },
    {
        "ins1CurCode":"UnsafeArrayData arrayCopy = new UnsafeArrayData(); final byte[] arrayDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, numElements, sizeInBytes); return arrayCopy;",
        "ins1PreCode":"UnsafeArrayData arrayCopy = new UnsafeArrayData(); final byte[] arrayDataCopy = new byte[sizeInBytes]; PlatformDependent.copyMemory( baseObject, baseOffset, arrayDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, sizeInBytes ); arrayCopy.pointTo(arrayDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, numElements, sizeInBytes); return arrayCopy;",
        "ins2PreCode":"UnsafeRow rowCopy = new UnsafeRow(); final byte[] rowDataCopy = new byte[sizeInBytes]; PlatformDependent.copyMemory( baseObject, baseOffset, rowDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, sizeInBytes ); rowCopy.pointTo(rowDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); return rowCopy;",
        "label":1
    },
    {
        "ins1CurCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject();",
        "ins1PreCode":"private void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject();",
        "ins2PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.noDataMessagePaint = SerialUtils.readPaint(stream); this.outlineStroke = SerialUtils.readStroke(stream); this.outlinePaint = SerialUtils.readPaint(stream);  this.backgroundPaint = SerialUtils.readPaint(stream);  this.listenerList = new EventListenerList(); ",
        "label":0
    },
    {
        "ins1CurCode":"this.lastModified = lastModified; } }",
        "ins1PreCode":"this.lastModified = lastModified; } } else if (lname.equals(CONTENT_TYPE)) { contentType = value; }",
        "ins2PreCode":"this.lastModified = lastModified; } } else if (lname.equals(CONTENT_TYPE)) { contentType = value; }",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, \"clean\", \"install\" ) ); ",
        "ins1PreCode":"assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\", \"install\" ).getExecutions(); ",
        "ins2PreCode":"assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"package\" ).getExecutions(); ",
        "label":1
    },
    {
        "ins1CurCode":"return isNotEqualToJson((Resource) expected); } failWithMessage(\"Unsupported type for JSON assert {}\", expected.getClass()); return null;",
        "ins1PreCode":"return isNotEqualToJson((Resource) expected); } failWithMessage(\"Unsupported type for JSON assert {]\", expected.getClass()); return null;",
        "ins2PreCode":"return isEqualToJson((Resource) expected); } failWithMessage(\"Unsupport type for JSON assert {}\", expected.getClass()); return null;",
        "label":0
    },
    {
        "ins1CurCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); assertEquals(1, vm.getStack().pop()); assertEquals(0, vm.getStack().size());",
        "ins1PreCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(1, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "ins2PreCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(72, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribe(Subscriber<? super T>[] subscribers) { subscribers = RxJavaPlugins.onSubscribe(this, subscribers); ",
        "ins1PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return;",
        "ins2PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return;",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); observer.onNext(\"one\");",
        "ins1PreCode":"@Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(\"one\");",
        "ins2PreCode":"public void skipAndCountOverlappingBuffers() { Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(\"one\"); subscriber.onNext(\"two\"); subscriber.onNext(\"three\"); subscriber.onNext(\"four\"); subscriber.onNext(\"five\"); } });  Flowable<List<String>> buffered = source.buffer(3, 1); buffered.subscribe(subscriber);  InOrder inOrder = Mockito.inOrder(subscriber); inOrder.verify(subscriber, Mockito.times(1)).onNext(list(\"one\", \"two\", \"three\")); inOrder.verify(subscriber, Mockito.times(1)).onNext(list(\"two\", \"three\", \"four\")); inOrder.verify(subscriber, Mockito.times(1)).onNext(list(\"three\", \"four\", \"five\")); inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.<String>anyList()); inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class)); inOrder.verify(subscriber, Mockito.never()).onComplete();",
        "label":0
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_incidentEdges_withSelfLoop_returnsInEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_incidentEdges_withSelfLoop_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_incidentEdges_withSelfLoop_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":" try { p = Objects.requireNonNull(debounceSelector.apply(t), \"The ObservableSource supplied is null\"); } catch (Throwable e) {",
        "ins1PreCode":" try { p = ObjectHelper.requireNonNull(debounceSelector.apply(t), \"The ObservableSource supplied is null\"); } catch (Throwable e) {",
        "ins2PreCode":" try { p = ObjectHelper.requireNonNull(debounceSelector.apply(t), \"The publisher supplied is null\"); } catch (Throwable e) {",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"public void matchNotUsingDefaultFilters() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter( NotUsingDefaultFilters.class); assertThat(excludes(filter, Controller1.class)).isTrue(); assertThat(excludes(filter, Controller2.class)).isTrue(); assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); assertThat(excludes(filter, ExampleWeb.class)).isTrue(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":0
    },
    {
        "ins1CurCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot<?, ?> subplot1 = plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis();",
        "ins1PreCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot<?, ?> subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis();",
        "ins2PreCode":"public void testNotification() { CombinedRangeXYPlot<String> plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot<String> subplot1 = plot.getSubplots().get(0); NumberAxis xAxis = (NumberAxis) subplot1.getDomainAxis(); xAxis.setAutoRangeIncludesZero(!xAxis.getAutoRangeIncludesZero()); assertEquals(1, this.events.size());   BufferedImage image = new BufferedImage(200, 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.events.clear(); chart.draw(g2, new Rectangle2D.Double(0.0, 0.0, 200.0, 100.0)); assertTrue(this.events.isEmpty());",
        "label":0
    },
    {
        "ins1CurCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options)",
        "label":1
    },
    {
        "ins1CurCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<>(2, 2000, TimeUnit.MILLISECONDS, test, true);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<>(); ",
        "ins1PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void addNode(Object node) { LOG.log(Level.FINE, \"adding MClassifierRole node!!\"); if (!canAddNode(node)) {",
        "ins1PreCode":"public void addNode(Object node) { LOG.debug(\"adding MClassifierRole node!!\"); if (!canAddNode(node)) {",
        "ins2PreCode":"public void addNode(Object node) {  LOG.debug(\"adding usecase node\"); ",
        "label":1
    },
    {
        "ins1CurCode":"@Override public List<Integer> get() { return new ArrayList<>(); }",
        "ins1PreCode":"@Override public List<Integer> get() { return new ArrayList<Integer>(); }",
        "ins2PreCode":"@Override public List<Integer> get() { return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":"throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\"); } Objects.requireNonNull(unit, \"unit is null\"); Objects.requireNonNull(scheduler, \"scheduler is null\"); ",
        "ins1PreCode":"throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\"); } ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ",
        "ins2PreCode":"throw new IllegalArgumentException(\"Overflow! start + count is bigger than Long.MAX_VALUE\"); } ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ",
        "label":1
    },
    {
        "ins1CurCode":"boolean quoted = false;  int c = skipLws(input, false); ",
        "ins1PreCode":"boolean quoted = false;  int c = input.read();   while (c == 32 || c == 9) { c = input.read();",
        "ins2PreCode":"boolean quoted = false;  int c = input.read();   while (c == 32 || c == 9) { c = input.read();",
        "label":1
    },
    {
        "ins1CurCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput output) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(output) .doesNotContain(\"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins1PreCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput capturedOutput) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(capturedOutput) .doesNotContain(\"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins2PreCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput capturedOutput) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(capturedOutput) .doesNotContain(\"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "label":1
    },
    {
        "ins1CurCode":".of(TestEnvironmentPostProcessor.class); List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory, this.bootstrapContext); assertThat(processors).hasSize(1);",
        "ins1PreCode":".of(TestEnvironmentPostProcessor.class); List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory, this.bootstrapRegistry); assertThat(processors).hasSize(1);",
        "ins2PreCode":".of(TestEnvironmentPostProcessor.class.getName()); List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory, this.bootstrapRegistry); assertThat(processors).hasSize(1);",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribe(Subscriber<? super R>[] subscribers) { subscribers = RxJavaPlugins.onSubscribe(this, subscribers); ",
        "ins1PreCode":"public void subscribe(Subscriber<? super R>[] subscribers) { if (!validate(subscribers)) { return;",
        "ins2PreCode":"public void subscribe(Subscriber<? super R>[] subscribers) { if (!validate(subscribers)) { return;",
        "label":1
    },
    {
        "ins1CurCode":"void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, true, new SaveOrderConfig.SortCriterion(StandardField.AUTHOR, false), new SaveOrderConfig.SortCriterion(StandardField.YEAR, true), new SaveOrderConfig.SortCriterion(StandardField.ABSTRACT, false)); metaData.setSaveOrderConfig(saveOrderConfig);  BibEntry firstEntry = new BibEntry(); firstEntry.setType(StandardEntryType.Article); firstEntry.setField(StandardField.AUTHOR, \"A\"); firstEntry.setField(StandardField.YEAR, \"2010\");  BibEntry secondEntry = new BibEntry(); secondEntry.setType(StandardEntryType.Article); secondEntry.setField(StandardField.AUTHOR, \"A\"); secondEntry.setField(StandardField.YEAR, \"2000\");  BibEntry thirdEntry = new BibEntry(); thirdEntry.setType(StandardEntryType.Article); thirdEntry.setField(StandardField.AUTHOR, \"B\"); thirdEntry.setField(StandardField.YEAR, \"2000\"); ",
        "ins1PreCode":"void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, true, new SaveOrderConfig.SortCriterion(\"author\", false), new SaveOrderConfig.SortCriterion(\"year\", true), new SaveOrderConfig.SortCriterion(\"abstract\", false)); metaData.setSaveOrderConfig(saveOrderConfig);  BibEntry firstEntry = new BibEntry(); firstEntry.setType(BibtexEntryTypes.ARTICLE); firstEntry.setField(\"author\", \"A\"); firstEntry.setField(\"year\", \"2010\");  BibEntry secondEntry = new BibEntry(); secondEntry.setType(BibtexEntryTypes.ARTICLE); secondEntry.setField(\"author\", \"A\"); secondEntry.setField(\"year\", \"2000\");  BibEntry thirdEntry = new BibEntry(); thirdEntry.setType(BibtexEntryTypes.ARTICLE); thirdEntry.setField(\"author\", \"B\"); thirdEntry.setField(\"year\", \"2000\"); ",
        "ins2PreCode":"void writeEntriesInOriginalOrderWhenNoSaveOrderConfigIsSetInMetadata() throws Exception { BibEntry firstEntry = new BibEntry(); firstEntry.setType(BibtexEntryTypes.ARTICLE); firstEntry.setField(\"author\", \"A\"); firstEntry.setField(\"year\", \"2010\");  BibEntry secondEntry = new BibEntry(); secondEntry.setType(BibtexEntryTypes.ARTICLE); secondEntry.setField(\"author\", \"B\"); secondEntry.setField(\"year\", \"2000\");  BibEntry thirdEntry = new BibEntry(); thirdEntry.setType(BibtexEntryTypes.ARTICLE); thirdEntry.setField(\"author\", \"A\"); thirdEntry.setField(\"year\", \"2000\"); ",
        "label":1
    },
    {
        "ins1CurCode":" boolean create; long waitTime = System.currentTimeMillis();  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } }  updateStatsBorrow(p, System.currentTimeMillis() - waitTime); ",
        "ins1PreCode":" boolean create; long waitTime = 0;  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { waitTime = System.currentTimeMillis(); p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); waitTime = System.currentTimeMillis() - waitTime; } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } }  updateStatsBorrow(p, waitTime); ",
        "ins2PreCode":" boolean create; long waitTime = 0; ObjectDeque<T> objectDeque = register(key);  try { while (p == null) { create = false; if (blockWhenExhausted) { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = objectDeque.getIdleObjects().takeFirst(); } else { waitTime = System.currentTimeMillis(); p = objectDeque.getIdleObjects().pollFirst( borrowMaxWaitMillis, TimeUnit.MILLISECONDS); waitTime = System.currentTimeMillis() - waitTime; } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(key, p); } catch (Exception e) { try { destroy(key, p, true); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(key, p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(key, p, true); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } } } finally { deregister(key); }  updateStatsBorrow(p, waitTime); ",
        "label":1
    },
    {
        "ins1CurCode":"void simplePropertyWithManyAttributes() { Map<String, String> result = new ParameterExpression(\"id, attr1=val1, attr2=val2, attr3=val3\");",
        "ins1PreCode":"public void simplePropertyWithManyAttributes() { Map<String, String> result = new ParameterExpression(\"id, attr1=val1, attr2=val2, attr3=val3\");",
        "ins2PreCode":"public void expressionWithManyAttributes() { Map<String, String> result = new ParameterExpression(\"(id.toString()), attr1=val1, attr2=val2, attr3=val3\");",
        "label":1
    },
    {
        "ins1CurCode":"}).take(2).subscribe(ts);  assertEquals(2, requested.get());",
        "ins1PreCode":"  assertEquals(Long.MAX_VALUE, requested.get());",
        "ins2PreCode":"public void requestThroughMap() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ts.request(3); final AtomicLong requested = new AtomicLong(); Flowable.<Integer>unsafeCreate(new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> s) { s.onSubscribe(new Subscription() {  @Override public void request(long n) { requested.set(n); }  @Override public void cancel() {  } }); } }).map(Functions.<Integer>identity()).subscribe(ts); assertEquals(3, requested.get());",
        "label":0
    },
    {
        "ins1CurCode":" assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "ins1PreCode":" assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins2PreCode":" assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "label":1
    },
    {
        "ins1CurCode":"void profilesAddedToEnvironmentViaActiveAndIncludeProperty(CapturedOutput capturedOutput) {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev\", \"spring.profiles.include=other\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).containsExactly(\"other\", \"dev\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromdevpropertiesfile\"); validateProfilePreference(capturedOutput, null, \"other\", \"dev\");",
        "ins1PreCode":"public void profilesAddedToEnvironmentViaActiveAndIncludeProperty() {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev\", \"spring.profiles.include=other\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).containsExactly(\"other\", \"dev\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromdevpropertiesfile\"); validateProfilePrecedence(null, \"other\", \"dev\");",
        "ins2PreCode":"public void profilesAddedToEnvironmentAndViaPropertyDuplicate() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev,other\"); this.environment.addActiveProfile(\"dev\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).contains(\"dev\", \"other\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromotherpropertiesfile\"); validateProfilePrecedence(null, \"dev\", \"other\");",
        "label":1
    },
    {
        "ins1CurCode":"String result = res.toString();  Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1CurCode":"builder.field(QUERY_FIELD.getPreferredName()); query.toXContent(builder, params); builder.field(PARENT_TYPE_FIELD.getPreferredName(), parentType); builder.field(SCORE_FIELD.getPreferredName(), score);",
        "ins1PreCode":"builder.field(QUERY_FIELD.getPreferredName()); query.toXContent(builder, params); builder.field(PARENT_TYPE_FIELD.getPreferredName(), type); builder.field(SCORE_FIELD.getPreferredName(), score);",
        "ins2PreCode":"protected void doXContent(XContentBuilder builder, Params params) throws IOException { builder.startObject(NAME); builder.field(QUERY_FIELD.getPreferredName()); query.toXContent(builder, params); builder.field(TYPE_FIELD.getPreferredName(), type); builder.field(SCORE_MODE_FIELD.getPreferredName(), NestedQueryBuilder.scoreModeAsString(scoreMode)); builder.field(MIN_CHILDREN_FIELD.getPreferredName(), minChildren); builder.field(MAX_CHILDREN_FIELD.getPreferredName(), maxChildren); builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped); printBoostAndQueryName(builder); if (innerHitBuilder != null) { builder.field(INNER_HITS_FIELD.getPreferredName(), innerHitBuilder, params); } builder.endObject();",
        "label":0
    },
    {
        "ins1CurCode":"public void longFlow() { Flowable.range(1, 1000000) .publish(v -> Flowable.mergeArray( v.filter(w -> w % 2 == 0), v.filter(w -> w % 2 != 0))) .takeLast(1)",
        "ins1PreCode":"public void longFlow() { Flowable.range(1, 1000000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Integer> v) throws Exception { return Flowable.mergeArray( v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 == 0; } }), v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 != 0; } })); } }) .takeLast(1)",
        "ins2PreCode":"public void longFlow2() { Flowable.range(1, 100000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Integer> v) throws Exception { return Flowable.mergeArray( v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 == 0; } }), v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 != 0; } })); } }) .test()",
        "label":1
    },
    {
        "ins1CurCode":"void testSimpleQueryCaseSensitive() { String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1PreCode":"public void testSimpleQueryCaseSensitive() { double textSize = 13; String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testSimpleQuery() { double textSize = 13; String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1CurCode":"bs.onNext(1);  TestObserver<Integer> to = new TestObserver<>();  final BehaviorDisposable<Integer> bd = new BehaviorDisposable<>(to, bs); to.onSubscribe(bd);",
        "ins1PreCode":"bs.onNext(1);  TestObserver<Integer> to = new TestObserver<Integer>();  final BehaviorDisposable<Integer> bd = new BehaviorDisposable<Integer>(to, bs); to.onSubscribe(bd);",
        "ins2PreCode":"bs.onNext(1);  TestObserver<Integer> to = new TestObserver<Integer>();  final BehaviorDisposable<Integer> bd = new BehaviorDisposable<Integer>(to, bs); to.onSubscribe(bd);",
        "label":1
    },
    {
        "ins1CurCode":"} } for (CategoryDataset<R, C> dataset : this.datasets.values()) { if (dataset != null) {",
        "ins1PreCode":"} } for (CategoryDataset dataset : this.datasets.values()) { if (dataset != null) {",
        "ins2PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {  stream.defaultReadObject(); this.domainGridlineStroke = SerialUtils.readStroke(stream); this.domainGridlinePaint = SerialUtils.readPaint(stream); this.rangeGridlineStroke = SerialUtils.readStroke(stream); this.rangeGridlinePaint = SerialUtils.readPaint(stream); this.domainMinorGridlineStroke = SerialUtils.readStroke(stream); this.domainMinorGridlinePaint = SerialUtils.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtils.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtils.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtils.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtils.readPaint(stream); this.domainCrosshairStroke = SerialUtils.readStroke(stream); this.domainCrosshairPaint = SerialUtils.readPaint(stream); this.rangeCrosshairStroke = SerialUtils.readStroke(stream); this.rangeCrosshairPaint = SerialUtils.readPaint(stream); this.domainTickBandPaint = SerialUtils.readPaint(stream); this.rangeTickBandPaint = SerialUtils.readPaint(stream); this.quadrantOrigin = SerialUtils.readPoint2D(stream); this.quadrantPaint = new Paint[4]; for (int i = 0; i < 4; i++) { this.quadrantPaint[i] = SerialUtils.readPaint(stream); }  this.domainZeroBaselineStroke = SerialUtils.readStroke(stream); this.domainZeroBaselinePaint = SerialUtils.readPaint(stream);    for (ValueAxis axis : this.domainAxes.values()) { if (axis != null) { axis.setPlot(this); axis.addChangeListener(this); } } for (ValueAxis axis : this.rangeAxes.values()) { if (axis != null) { axis.setPlot(this); axis.addChangeListener(this); } } for (XYDataset dataset : this.datasets.values()) { if (dataset != null) { dataset.addChangeListener(this); } } for (XYItemRenderer renderer : this.renderers.values()) { if (renderer != null) { renderer.addChangeListener(this); } } ",
        "label":0
    },
    {
        "ins1CurCode":"public void testInsertTable1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<String, String>();",
        "ins1PreCode":"public void testInsertTable1() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table1.insert\", parms); assertEquals(1, rows); assertEquals(11, parms.get(\"id\"));  } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertTable2() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insert\", parms); assertEquals(1, rows); assertEquals(22, parms.get(\"id\"));  } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);  RidgeRegressionWithSGD ridgeSGDImpl = new RidgeRegressionWithSGD(1.0, 200, 0.0, 1.0); RidgeRegressionModel model = ridgeSGDImpl.run(testRDD.rdd());",
        "ins1PreCode":"List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);  RidgeRegressionWithSGD ridgeSGDImpl = new RidgeRegressionWithSGD(); ridgeSGDImpl.optimizer() .setStepSize(1.0) .setRegParam(0.0) .setNumIterations(200); RidgeRegressionModel model = ridgeSGDImpl.run(testRDD.rdd());",
        "ins2PreCode":"List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);  RidgeRegressionModel model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.0); double unRegularizedErr = predictionError(validationData, model);  model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.1); double regularizedErr = predictionError(validationData, model);",
        "label":0
    },
    {
        "ins1CurCode":"public void testFilterSet() throws IOException { buildRule.executeTarget(\"testFilterSet\"); File tmp  = new File(buildRule.getProject().getProperty(\"output\"), \"copy.filterset.tmp\"); File check  = new File(buildRule.getProject().getBaseDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists()); assertEquals(FileUtilities.getFileContents(tmp), FileUtilities.getFileContents(check));",
        "ins1PreCode":"public void testFilterSet() throws IOException { executeTarget(\"testFilterSet\"); File tmp  = new File(getOutputDir(), \"copy.filterset.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists()); assertTrue(FILE_UTILS.contentEquals(tmp, check));",
        "ins2PreCode":"public void testFilterChain() throws IOException { executeTarget(\"testFilterChain\"); File tmp  = new File(getOutputDir(), \"copy.filterchain.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists()); assertTrue(FILE_UTILS.contentEquals(tmp, check));",
        "label":1
    },
    {
        "ins1CurCode":"public void bindToClassShouldBindToList() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToClassShouldBindToList() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToClassShouldBindToSet() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; String n = (String)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); boolean b = (boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; boolean b = (boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); byte b = (byte)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; byte b = (byte)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = (short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); char b = (char)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = (char)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); int b = (int)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = (int)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); long b = (long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = (long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); float b = (float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = (float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); double b = (double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = (double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Boolean b = (Boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Boolean b = (Boolean)o;\"));  exec(\"Byte o = Byte.valueOf((byte)0); Byte b = o;\"); exec(\"Byte o = null; Byte b = o;\"); exec(\"Byte o = Byte.valueOf((byte)0); Byte b = (Byte)o;\"); exec(\"Byte o = null; Byte b = (Byte)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Short b = (Short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Short b = (Short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Character b = (Character)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Character b = (Character)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Integer b = (Integer)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Integer b = (Integer)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Long b = (Long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Long b = (Long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Float b = (Float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Float b = (Float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Double b = (Double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Double b = (Double)o;\")); ",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((Byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; String n = (String)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); boolean b = (boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; boolean b = (boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); byte b = (byte)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; byte b = (byte)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = (short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); char b = (char)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = (char)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); int b = (int)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = (int)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); long b = (long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = (long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); float b = (float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = (float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); double b = (double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = (double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Boolean b = (Boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Boolean b = (Boolean)o;\"));  exec(\"Byte o = Byte.valueOf((byte)0); Byte b = o;\"); exec(\"Byte o = null; Byte b = o;\"); exec(\"Byte o = Byte.valueOf((byte)0); Byte b = (Byte)o;\"); exec(\"Byte o = null; Byte b = (Byte)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Short b = (Short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; short b = (Short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Character b = (Character)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; char b = (Character)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Integer b = (Integer)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; int b = (Integer)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Long b = (Long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; long b = (Long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Float b = (Float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; float b = (Float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = Byte.valueOf((byte)0); Double b = (Double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Byte o = null; double b = (Double)o;\")); ",
        "ins2PreCode":"public void testBoxedBooleanCasts() { exec(\"Boolean o = Boolean.valueOf(true); Object n = o;\"); exec(\"Boolean o = null; Object n = o;\"); exec(\"Boolean o = Boolean.valueOf(true); Object n = (Object)o;\"); exec(\"Boolean o = null; Object n = (Object)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Number n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Number n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Number n = (Boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Number n = (Boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); boolean b = (boolean)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; boolean b = (boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); byte b = (byte)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; byte b = (byte)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; short b = (short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); char b = (char)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; char b = (char)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; int b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); int b = (int)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; int b = (int)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); long b = (long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; long b = (long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); float b = (float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; float b = (float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); double b = (double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; double b = (double)o;\"));  exec(\"Boolean o = Boolean.valueOf(true); Boolean b = o;\"); exec(\"Boolean o = null; Boolean b = o;\"); exec(\"Boolean o = Boolean.valueOf(true); Boolean b = (Boolean)o;\"); exec(\"Boolean o = null; Boolean b = (Boolean)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Byte b = (Byte)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Byte b = (Byte)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Short b = (Short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Short b = (Short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Character b = (Character)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Character b = (Character)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Integer b = (Integer)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Integer b = (Integer)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Long b = (Long)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Long b = (Long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Float b = (Float)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Float b = (Float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); Double b = (Double)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = Boolean.valueOf(true); ArrayList b = (ArrayList)o;\"));",
        "label":0
    },
    {
        "ins1CurCode":"list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences)); list.add(new RfcFetcher(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName));",
        "ins1PreCode":"list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"public static List<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<MaybeObserver<? super Integer>> moRef = new AtomicReference<>(); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<MaybeObserver<? super Integer>> moRef = new AtomicReference<MaybeObserver<? super Integer>>(); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<SingleObserver<? super Integer>> moRef = new AtomicReference<SingleObserver<? super Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Item.READ, Item.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"aProject1\", \"never_created\", \"aProject2\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"aProject1\", \"never_created\", \"aProject2\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"aProject1\", \"never_created1\", \"never_created2\", \"aProject2\");",
        "label":1
    },
    {
        "ins1CurCode":"void globalError() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "ins1PreCode":"public void globalError() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "ins2PreCode":"public void statusError() throws Exception { this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, \"/400\"));",
        "label":1
    },
    {
        "ins1CurCode":"g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtils.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(), marker.getLabelTextAnchor()); } g2.setComposite(originalComposite); } else if (marker instanceof IntervalMarker) { IntervalMarker im = (IntervalMarker) marker; double start = im.getStartValue(); double end = im.getEndValue(); Range range = rangeAxis.getRange(); if (!(range.intersects(start, end))) { return; }  double start2d = rangeAxis.valueToJava2D(start, dataArea, plot.getRangeAxisEdge()); double end2d = rangeAxis.valueToJava2D(end, dataArea, plot.getRangeAxisEdge()); double low = Math.min(start2d, end2d); double high = Math.max(start2d, end2d);  PlotOrientation orientation = plot.getOrientation(); Rectangle2D rect = null; if (orientation == PlotOrientation.HORIZONTAL) {  low = Math.max(low, dataArea.getMinX()); high = Math.min(high, dataArea.getMaxX()); rect = new Rectangle2D.Double(low, dataArea.getMinY(), high - low, dataArea.getHeight()); } else if (orientation == PlotOrientation.VERTICAL) {  low = Math.max(low, dataArea.getMinY()); high = Math.min(high, dataArea.getMaxY()); rect = new Rectangle2D.Double(dataArea.getMinX(), low, dataArea.getWidth(), high - low); }  final Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, marker.getAlpha())); Paint p = marker.getPaint(); if (p instanceof GradientPaint) { GradientPaint gp = (GradientPaint) p; GradientPaintTransformer t = im.getGradientPaintTransformer(); if (t != null) { gp = t.transform(gp, rect); } g2.setPaint(gp); } else { g2.setPaint(p); } g2.fill(rect);   if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) { if (orientation == PlotOrientation.VERTICAL) { Line2D line = new Line2D.Double(); double x0 = dataArea.getMinX(); double x1 = dataArea.getMaxX(); g2.setPaint(im.getOutlinePaint()); g2.setStroke(im.getOutlineStroke()); if (range.contains(start)) { line.setLine(x0, start2d, x1, start2d); g2.draw(line); } if (range.contains(end)) { line.setLine(x0, end2d, x1, end2d); g2.draw(line); } } else { Line2D line = new Line2D.Double(); double y0 = dataArea.getMinY(); double y1 = dataArea.getMaxY(); g2.setPaint(im.getOutlinePaint()); g2.setStroke(im.getOutlineStroke()); if (range.contains(start)) { line.setLine(start2d, y0, start2d, y1); g2.draw(line); } if (range.contains(end)) { line.setLine(end2d, y0, end2d, y1); g2.draw(line); } } }  String label = marker.getLabel(); RectangleAnchor anchor = marker.getLabelAnchor(); if (label != null) { Font labelFont = marker.getLabelFont(); g2.setFont(labelFont); Point2D coords = calculateRangeMarkerTextAnchorPoint( g2, orientation, dataArea, rect, marker.getLabelOffset(), marker.getLabelOffsetType(), anchor); Rectangle2D r = TextUtils.calcAlignedStringBounds(label, g2, (float) coords.getX(), (float) coords.getY(), marker.getLabelTextAnchor()); g2.setPaint(marker.getLabelBackgroundColor()); g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtils.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(),",
        "ins1PreCode":"g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(), marker.getLabelTextAnchor()); } g2.setComposite(originalComposite); } else if (marker instanceof IntervalMarker) { IntervalMarker im = (IntervalMarker) marker; double start = im.getStartValue(); double end = im.getEndValue(); Range range = rangeAxis.getRange(); if (!(range.intersects(start, end))) { return; }  double start2d = rangeAxis.valueToJava2D(start, dataArea, plot.getRangeAxisEdge()); double end2d = rangeAxis.valueToJava2D(end, dataArea, plot.getRangeAxisEdge()); double low = Math.min(start2d, end2d); double high = Math.max(start2d, end2d);  PlotOrientation orientation = plot.getOrientation(); Rectangle2D rect = null; if (orientation == PlotOrientation.HORIZONTAL) {  low = Math.max(low, dataArea.getMinX()); high = Math.min(high, dataArea.getMaxX()); rect = new Rectangle2D.Double(low, dataArea.getMinY(), high - low, dataArea.getHeight()); } else if (orientation == PlotOrientation.VERTICAL) {  low = Math.max(low, dataArea.getMinY()); high = Math.min(high, dataArea.getMaxY()); rect = new Rectangle2D.Double(dataArea.getMinX(), low, dataArea.getWidth(), high - low); }  final Composite originalComposite = g2.getComposite(); g2.setComposite(AlphaComposite.getInstance( AlphaComposite.SRC_OVER, marker.getAlpha())); Paint p = marker.getPaint(); if (p instanceof GradientPaint) { GradientPaint gp = (GradientPaint) p; GradientPaintTransformer t = im.getGradientPaintTransformer(); if (t != null) { gp = t.transform(gp, rect); } g2.setPaint(gp); } else { g2.setPaint(p); } g2.fill(rect);   if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) { if (orientation == PlotOrientation.VERTICAL) { Line2D line = new Line2D.Double(); double x0 = dataArea.getMinX(); double x1 = dataArea.getMaxX(); g2.setPaint(im.getOutlinePaint()); g2.setStroke(im.getOutlineStroke()); if (range.contains(start)) { line.setLine(x0, start2d, x1, start2d); g2.draw(line); } if (range.contains(end)) { line.setLine(x0, end2d, x1, end2d); g2.draw(line); } } else { Line2D line = new Line2D.Double(); double y0 = dataArea.getMinY(); double y1 = dataArea.getMaxY(); g2.setPaint(im.getOutlinePaint()); g2.setStroke(im.getOutlineStroke()); if (range.contains(start)) { line.setLine(start2d, y0, start2d, y1); g2.draw(line); } if (range.contains(end)) { line.setLine(end2d, y0, end2d, y1); g2.draw(line); } } }  String label = marker.getLabel(); RectangleAnchor anchor = marker.getLabelAnchor(); if (label != null) { Font labelFont = marker.getLabelFont(); g2.setFont(labelFont); Point2D coords = calculateRangeMarkerTextAnchorPoint( g2, orientation, dataArea, rect, marker.getLabelOffset(), marker.getLabelOffsetType(), anchor); Rectangle2D r = TextUtils.calcAlignedStringBounds(label, g2, (float) coords.getX(), (float) coords.getY(), marker.getLabelTextAnchor()); g2.setPaint(marker.getLabelBackgroundColor()); g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(),",
        "ins2PreCode":"g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(),",
        "label":0
    },
    {
        "ins1CurCode":"  a1.setArrowPaint(Color.BLUE); assertFalse(a1.equals(a2)); a2.setArrowPaint(Color.BLUE); assertTrue(a1.equals(a2));",
        "ins1PreCode":"  a1.setArrowPaint(Color.blue); assertFalse(a1.equals(a2)); a2.setArrowPaint(Color.blue); assertTrue(a1.equals(a2));",
        "ins2PreCode":"  a1.setArrowPaint(Color.blue); assertFalse(a1.equals(a2)); a2.setArrowPaint(Color.blue); assertTrue(a1.equals(a2));",
        "label":1
    },
    {
        "ins1CurCode":"s1.add(1.0, 0.5, 1.5, 10.0, 9.5, 10.5); s1.add(2.0, 1.9, 2.1, 20.0, 19.8, 20.3); XYIntervalSeries<String> s2 = new XYIntervalSeries<>(\"S2\"); s2.add(3.0, 2.5, 3.5, 30.0, 29.5, 30.5);",
        "ins1PreCode":"s1.add(1.0, 0.5, 1.5, 10.0, 9.5, 10.5); s1.add(2.0, 1.9, 2.1, 20.0, 19.8, 20.3); XYIntervalSeries<String> s2 = new XYIntervalSeries(\"S2\"); s2.add(3.0, 2.5, 3.5, 30.0, 29.5, 30.5);",
        "ins2PreCode":"public void testFindRangeBounds2() { XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"S1\"); s1.add(1.0, 0.5, 1.5, 10.0, 9.5, 10.5); s1.add(2.0, 1.9, 2.1, 20.0, 19.8, 20.3); XYIntervalSeries<String> s2 = new XYIntervalSeries<>(\"S2\"); s2.add(3.0, 2.5, 3.5, 30.0, 29.5, 30.5); s2.add(4.0, 3.9, 4.1, 9.0, 9.0, 9.0); XYIntervalSeriesCollection<String> dataset = new XYIntervalSeriesCollection<>(); dataset.addSeries(s1); dataset.addSeries(s2);  XYBarRenderer renderer = new XYBarRenderer(); renderer.setUseYInterval(false); Range r = renderer.findRangeBounds(dataset); assertEquals(9.0, r.getLowerBound(), EPSILON); assertEquals(30.0, r.getUpperBound(), EPSILON);  renderer.setSeriesVisible(1, Boolean.FALSE); r = renderer.findRangeBounds(dataset); assertEquals(10.0, r.getLowerBound(), EPSILON); assertEquals(20.0, r.getUpperBound(), EPSILON);",
        "label":0
    },
    {
        "ins1CurCode":"  XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); ",
        "ins1PreCode":"  XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); ",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYLineChart(\"XY Line Chart\", \"Domain\",",
        "label":1
    },
    {
        "ins1CurCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.range(0, 100000)",
        "ins1PreCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(0, 100000)",
        "ins2PreCode":"public void backpressure() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(0, 100000)",
        "label":1
    },
    {
        "ins1CurCode":"void roundTripWithPrependingNewlines() throws IOException { ",
        "ins1PreCode":"public void roundTripWithPrependingNewlines() throws IOException { ",
        "ins2PreCode":"private String testSingleWrite(String bibtexEntry) throws IOException {  ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();  assertEquals(bibtexEntry, actual); return actual;",
        "label":0
    },
    {
        "ins1CurCode":"assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessageStartingWith(\"Search location '\").withMessageEndingWith(\"' must end with '*/'\");",
        "ins1PreCode":"assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildcard patterns must end with '*/'\");",
        "ins2PreCode":"void whenConfigLocationSpecifiesUnknownFileExtensionConfigFileProcessingFailsFast() { String location = \"classpath:application.unknown\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.location=\" + location); assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessageContaining(location) .withMessageContaining(\"If the location is meant to reference a directory, it must end in '/'\");",
        "label":0
    },
    {
        "ins1CurCode":"{ case 99: return jjMoveStringLiteralDfa7_2(active0, 0x100000000000L); default :",
        "ins1PreCode":"{ case 99: return jjMoveStringLiteralDfa7_2(active0, 0x80000000000L); default :",
        "ins2PreCode":"{ case 101: return jjMoveStringLiteralDfa8_2(active0, 0x80000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"void testWithNbibFile() throws IOException, URISyntaxException { Path file = Path.of(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI()); ",
        "ins1PreCode":"void testWithNbibFile() throws IOException, URISyntaxException { Path file = Paths.get(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI()); ",
        "ins2PreCode":"void testWithMultipleEntries() throws IOException, URISyntaxException { Path file = Paths .get(MedlinePlainImporter.class.getResource(\"MedlinePlainImporterStringOutOfBounds.txt\").toURI()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testRewriteZeroPermissions() throws IOException { buildRule.executeTarget(\"rewriteZeroPermissions\"); try (org.apache.tools.zip.ZipFile zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\"))) { org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "ins1PreCode":"public void testRewriteZeroPermissions() throws IOException { buildRule.executeTarget(\"rewriteZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\"); assertEquals(UnixStat.FILE_FLAG | 0644, ze.getUnixMode()); } finally { if (zf != null) { zf.close(); }",
        "ins2PreCode":"public void testAcceptZeroPermissions() throws IOException { buildRule.executeTarget(\"acceptZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\"); assertEquals(0000, ze.getUnixMode()); } finally { if (zf != null) { zf.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"if (changedir) { try { if (!ftp.changeWorkingDirectory(directory)) { return null; } currentPath = ftp.printWorkingDirectory(); } catch (IOException ioe) { throw new BuildException(ioe, task.getLocation()); } } if (fileListMap.containsKey(currentPath)) { task.log(\"filelist map used in listing files\", Project.MSG_DEBUG); return fileListMap.get(currentPath); } FTPFile[] result; try {",
        "ins1PreCode":"if (changedir) { try { boolean result = ftp.changeWorkingDirectory(directory); if (!result) { return null; } currentPath = ftp.printWorkingDirectory(); } catch (IOException ioe) { throw new BuildException(ioe, task.getLocation()); } } if (fileListMap.containsKey(currentPath)) { task.log(\"filelist map used in listing files\", Project.MSG_DEBUG); return ((FTPFile[]) fileListMap.get(currentPath)); } FTPFile[] result = null; try {",
        "ins2PreCode":"public FTPFile[] listFiles(String directory, boolean changedir) {  String currentPath = directory; if (changedir) { try { boolean result = ftp.changeWorkingDirectory(directory); if (!result) { return null; } currentPath = ftp.printWorkingDirectory(); } catch (IOException ioe) { throw new BuildException(ioe, getLocation()); } } if (fileListMap.containsKey(currentPath)) { getProject().log(\"filelist map used in listing files\", Project.MSG_DEBUG); return ((FTPFile[]) fileListMap.get(currentPath)); } FTPFile[] result = null; try {",
        "label":1
    },
    {
        "ins1CurCode":"public void addSeries(S seriesKey, double[][] data) { Args.nullNotPermitted(seriesKey, \"seriesKey\"); Args.nullNotPermitted(data, \"data\"); if (data.length != 3) {",
        "ins1PreCode":"public void addSeries(Comparable seriesKey, double[][] data) { if (seriesKey == null) { throw new IllegalArgumentException( \"The 'seriesKey' cannot be null.\"); } if (data == null) { throw new IllegalArgumentException(\"The 'data' is null.\"); }",
        "ins2PreCode":"public void addSeries(S seriesKey, double[][] data) { if (seriesKey == null) { throw new IllegalArgumentException( \"The 'seriesKey' cannot be null.\"); } if (data == null) { throw new IllegalArgumentException(\"The 'data' is null.\"); } if (data.length != 2) { throw new IllegalArgumentException( \"The 'data' array must have length == 2.\"); } if (data[0].length != data[1].length) { throw new IllegalArgumentException( \"The 'data' array must contain two arrays with equal length.\"); } int seriesIndex = indexOf(seriesKey); if (seriesIndex == -1) { this.seriesKeys.add(seriesKey); this.seriesList.add(data); } else { this.seriesList.remove(seriesIndex); this.seriesList.add(seriesIndex, data); } notifyListeners(new DatasetChangeEvent(this, this));",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); assertThat(!graph.edgeValueOrDefault(node, otherNode, DEFAULT).equals(DEFAULT)) .isEqualTo(hasEdge); }",
        "ins1PreCode":"assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); } }",
        "ins2PreCode":"assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); } }",
        "label":1
    },
    {
        "ins1CurCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtils.writePaint(this.paint, stream); SerialUtils.writeStroke(this.stroke, stream); SerialUtils.writePaint(this.outlinePaint, stream); SerialUtils.writeStroke(this.outlineStroke, stream); SerialUtils.writePaint(this.labelPaint, stream);",
        "ins1PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.paint, stream); SerialUtilities.writeStroke(this.stroke, stream); SerialUtilities.writePaint(this.outlinePaint, stream); SerialUtilities.writeStroke(this.outlineStroke, stream); SerialUtilities.writePaint(this.labelPaint, stream);",
        "ins2PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.majorTickPaint, stream); SerialUtilities.writeStroke(this.majorTickStroke, stream); SerialUtilities.writePaint(this.minorTickPaint, stream); SerialUtilities.writeStroke(this.minorTickStroke, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainXYPlot<String> plot1 = createPlot(); CombinedDomainXYPlot<String> plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainXYPlot plot1 = createPlot(); CombinedDomainXYPlot plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainCategoryPlot plot1 = createPlot(); CombinedDomainCategoryPlot plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2); assertTrue(plot1.getClass() == plot2.getClass()); assertTrue(plot1.equals(plot2));",
        "label":0
    },
    {
        "ins1CurCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.memory.offHeap.enabled\", \"false\"); final TaskMemoryManager memoryManager =",
        "ins1PreCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager =",
        "ins2PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager =",
        "label":0
    },
    {
        "ins1CurCode":"}, mapFactory).toFlowable();  Map<Integer, String> expected = new LinkedHashMap<>(); expected.put(2, \"bb\");",
        "ins1PreCode":"}, mapFactory).toFlowable();  Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\");",
        "ins2PreCode":"}, mapFactory).toObservable();  Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\");",
        "label":1
    },
    {
        "ins1CurCode":" throw new IllegalArgumentException( \"dynamic setter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");",
        "ins1PreCode":" throw new IllegalArgumentException( \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");",
        "ins2PreCode":"static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {  MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name);  if (getter != null) { return getter; }   if (receiverClass.isArray() && \"length\".equals(name)) {  return arrayLengthGetter(receiverClass); } else if (Map.class.isAssignableFrom(receiverClass)) {   return MethodHandles.insertArguments(MAP_GET, 1, name); } else if (List.class.isAssignableFrom(receiverClass)) {    try { int index = Integer.parseInt(name); return MethodHandles.insertArguments(LIST_GET, 1, index); } catch (NumberFormatException exception) { throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\"); } }  throw new IllegalArgumentException( \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");",
        "label":0
    },
    {
        "ins1CurCode":"public void mapperToEmpty() { TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void mapperToEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void mapperToCrashingCallable() { TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, true); ",
        "ins2PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); ",
        "label":0
    },
    {
        "ins1CurCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).iteratesAs( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins1PreCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).iteratesOverSequence( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins2PreCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).iteratesOverSequence( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "label":1
    },
    {
        "ins1CurCode":"while (true) { if ((value & ~0x7FL) == 0) { UnsafeUtil.putByte(buffer, pos++, (byte) value); position++; return; } else { UnsafeUtil.putByte(buffer, pos++, (byte) (((int) value & 0x7F) | 0x80)); position++; value >>>= 7; } } } else { try { while (true) { if ((value & ~0x7FL) == 0) { buffer[position++] = (byte) value; return; } else { buffer[position++] = (byte) (((int) value & 0x7F) | 0x80); value >>>= 7; } } } catch (IndexOutOfBoundsException e) { throw new OutOfSpaceException( String.format(\"Pos: %d, limit: %d, len: %d\", position, limit, 1), e); }",
        "ins1PreCode":"while (true) { if ((value & ~0x7FL) == 0) { UNSAFE.putByte(buffer, pos++, (byte) value); position++; return; } else { UNSAFE.putByte(buffer, pos++, (byte) (((int) value & 0x7F) | 0x80)); position++; value >>>= 7; } } } else { try { while (true) { if ((value & ~0x7FL) == 0) { buffer[position++] = (byte) value; return; } else { buffer[position++] = (byte) (((int) value & 0x7F) | 0x80); value >>>= 7; } } } catch (IndexOutOfBoundsException e) { throw new OutOfSpaceException( new IndexOutOfBoundsException( String.format(\"Pos: %d, limit: %d, len: %d\", position, limit, 1))); }",
        "ins2PreCode":"while (true) { if ((value & ~0x7F) == 0) { UNSAFE.putByte(buffer, pos++, (byte) value); break; } else { UNSAFE.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7;",
        "label":0
    },
    {
        "ins1CurCode":"double value = array[index]; if (index < size - 1) { System.arraycopy(array, index + 1, array, index, size - index - 1); }",
        "ins1PreCode":"double value = array[index]; if (index < size - 1) { System.arraycopy(array, index + 1, array, index, size - index); }",
        "ins2PreCode":"float value = array[index]; if (index < size - 1) { System.arraycopy(array, index + 1, array, index, size - index); }",
        "label":1
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_15; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[42] = jj_gen; ; } jj_consume_token(RBRACE); } catch (Throwable jjte000) {",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_13: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[34] = jj_gen; break label_13; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[35] = jj_gen; ; } jj_consume_token(RCURL); } catch (Throwable jjte000) {",
        "ins2PreCode":"case IDENTIFIER: Expression(); label_12: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[29] = jj_gen; break label_12; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[30] = jj_gen; ;",
        "label":0
    },
    {
        "ins1CurCode":"Object item = readItem(reader, context, items); items.add(item); } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e);",
        "ins1PreCode":"Object item = readItem(reader, context, items); items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(FINE, \"Failed to resolve class\", e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(FINE, \"Failed to resolve class\", e); RobustReflectionConverter.addErrorInContext(context, e);",
        "ins2PreCode":"Object item = readItem(reader, context, collection); collection.add(item); } catch (CannotResolveClassException e) { LOGGER.log(FINE, \"Failed to resolve class\", e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(FINE, \"Failed to resolve class\", e); RobustReflectionConverter.addErrorInContext(context, e);",
        "label":1
    },
    {
        "ins1CurCode":"public void adjacentEdges_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addEdge(N1, N2, E12);",
        "ins1PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try {",
        "ins2PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try { adjacentEdges.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N2, N3, E23); assertThat(network.adjacentEdges(E12)).containsExactlyElementsIn(adjacentEdges); }",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposable.empty()); observer.onComplete();",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "label":1
    },
    {
        "ins1CurCode":"void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.jar\", \"BOOT-INF\"));",
        "ins1PreCode":"public void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.jar\", \"BOOT-INF\"));",
        "ins2PreCode":"public void explodedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.war\", \"WEB-INF\"));",
        "label":1
    },
    {
        "ins1CurCode":"}  int fragmentPos = path.indexOf('#'); if (fragmentPos > -1) { log.warn(sm.getString(\"request.fragmentInDispatchPath\", path)); path = path.substring(0, fragmentPos); }   if (path.startsWith(\"/\")) { return context.getServletContext().getRequestDispatcher(path);",
        "ins1PreCode":"if (path == null) { return null; } else if (path.startsWith(\"/\")) { return context.getServletContext().getRequestDispatcher(path);",
        "ins2PreCode":"  if (path == null) return null; else if (path.startsWith(\"/\")) return context.getServletContext().getRequestDispatcher(path);",
        "label":0
    },
    {
        "ins1CurCode":"secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0); ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "ins1PreCode":"secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "ins2PreCode":"secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "label":1
    },
    {
        "ins1CurCode":"public void setUp() throws Exception {",
        "ins1PreCode":"protected void setUp() throws Exception { super.setUp(); resolver = (GraphConflictResolver) lookup( GraphConflictResolver.ROLE, \"default\" ); ",
        "ins2PreCode":"protected void setUp() throws Exception { super.setUp(); transform = (ClasspathTransformation) lookup( ClasspathTransformation.ROLE, \"default\" ); ",
        "label":0
    },
    {
        "ins1CurCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; }",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders();",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; } ListSet offs = i.getOffenders(); UMLDeploymentDiagram dd = (UMLDeploymentDiagram) offs.get(0);  ListSet newOffs = computeOffenders(dd); boolean res = offs.equals(newOffs); return res;",
        "label":0
    },
    {
        "ins1CurCode":"public void testInvalidTimezone() { DateProcessor processor = new DateProcessor(randomAlphaOfLength(10), null, new TestTemplateService.MockTemplateScript.Factory(\"invalid_timezone\"), templatize(randomLocale(random())), \"date_as_string\", Collections.singletonList(\"yyyy\"), \"date_as_date\");",
        "ins1PreCode":"public void testInvalidTimezone() { DateProcessor processor = new DateProcessor(randomAlphaOfLength(10), new TestTemplateService.MockTemplateScript.Factory(\"invalid_timezone\"), templatize(randomLocale(random())), \"date_as_string\", Collections.singletonList(\"yyyy\"), \"date_as_date\");",
        "ins2PreCode":"public void testInvalidLocale() { DateProcessor processor = new DateProcessor(randomAlphaOfLength(10), templatize(ZoneOffset.UTC), new TestTemplateService.MockTemplateScript.Factory(\"invalid_locale\"), \"date_as_string\", Collections.singletonList(\"yyyy\"), \"date_as_date\");",
        "label":1
    },
    {
        "ins1CurCode":"if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).destroySubcontext(name.getSuffix(1)); } else {",
        "ins1PreCode":"if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else {",
        "ins2PreCode":"public void unbind(Name name) throws NamingException { checkWritable();  while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) throw new NamingException (sm.getString(\"namingContext.invalidName\"));  NamingEntry entry = bindings.get(name.get(0));  if (entry == null) { throw new NameNotFoundException (sm.getString(\"namingContext.nameNotBound\", name.get(0))); }  if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else { throw new NamingException (sm.getString(\"namingContext.contextExpected\")); } } else { bindings.remove(name.get(0)); } ",
        "label":0
    },
    {
        "ins1CurCode":"public void observerCheckTerminatedNonDelayErrorErrorResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return new TestException(); }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"public void observerCheckTerminatedNonDelayErrorErrorResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return new TestException(); }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void observerCheckTerminatedNonDelayErrorError() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty()); ",
        "label":0
    },
    {
        "ins1CurCode":"Year y = new Year(1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-631123200000L, y.getFirstMillisecond(cal));   boolean pass = false; try { y.getFirstMillisecond((Calendar) null); }",
        "ins1PreCode":"Year y = new Year(1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-631123200000L, y.getFirstMillisecond(zone));   boolean pass = false; try { y.getFirstMillisecond((TimeZone) null); }",
        "ins2PreCode":"Year y = new Year(1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-599587200001L, y.getLastMillisecond(zone));   boolean pass = false; try { y.getLastMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"long timeout = getReadTimeout(); try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; }",
        "ins1PreCode":"long timeout = getReadTimeout(); try { blockReadDone = new AtomicBoolean(false); registerReadInterest(); synchronized (blockReadDone) { if (!blockReadDone.get()) { try { if (timeout > 0) { blockReadDone.wait(timeout); } else { blockReadDone.wait(); } } catch (InterruptedException e) {  } if (!blockReadDone.get()) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { blockReadDone = null; }",
        "ins2PreCode":"} if (n == 0) { if (blockWriteDone == null) { blockWriteDone = new AtomicBoolean(false); } else { blockWriteDone.set(false); } registerWriteInterest(); synchronized (blockWriteDone) { if (!blockWriteDone.get()) { try { if (timeout > 0) { blockWriteDone.wait(timeout); } else { blockWriteDone.wait(); } } catch (InterruptedException e) {  } if (!blockWriteDone.get()) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { blockWriteDone = null; }",
        "label":0
    },
    {
        "ins1CurCode":"ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value()); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30));",
        "ins1PreCode":"ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30));",
        "ins2PreCode":".create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")) .attribute(URI_TEMPLATE_ATTRIBUTE, \"/projects/{project}\").build(); given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30));",
        "label":1
    },
    {
        "ins1CurCode":"if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON FUNCTION \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS \" + SQLUtils.quoteString(command.getObject().getDescription()))); }",
        "ins1PreCode":"if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON FUNCTION \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS '\" + SQLUtils.escapeString(command.getObject().getDescription()) + \"'\")); }",
        "ins2PreCode":"if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON SCRIPT \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS '\" + SQLUtils.escapeString(command.getObject().getDescription()) + \"'\")); }",
        "label":1
    },
    {
        "ins1CurCode":"public void nearMaxValueWithoutBackpressure() { TestSubscriber<Long> ts = new TestSubscriber<>(); Flowable.rangeLong(Long.MAX_VALUE - 1L, 2L).subscribe(ts);",
        "ins1PreCode":"public void nearMaxValueWithoutBackpressure() { TestSubscriber<Long> ts = new TestSubscriber<Long>(); Flowable.rangeLong(Long.MAX_VALUE - 1L, 2L).subscribe(ts);",
        "ins2PreCode":"public void nearMaxValueWithBackpressure() { TestSubscriber<Long> ts = new TestSubscriber<Long>(3L); Flowable.rangeLong(Long.MAX_VALUE - 1L, 2L).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) { return; }",
        "ins1PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target);",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target);",
        "label":1
    },
    {
        "ins1CurCode":"void addActiveFilter(InputFilter filter) { ",
        "ins1PreCode":"public void addActiveFilter(InputFilter filter) { ",
        "ins2PreCode":"public void addActiveFilter(OutputFilter filter) {  if (lastActiveFilter == -1) { filter.setBuffer(outputStreamOutputBuffer); } else { for (int i = 0; i <= lastActiveFilter; i++) { if (activeFilters[i] == filter) return; } filter.setBuffer(activeFilters[lastActiveFilter]); }  activeFilters[++lastActiveFilter] = filter;  filter.setResponse(response); ",
        "label":0
    },
    {
        "ins1CurCode":"if ( snapshotMetadata == null ) { snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat, timestamp ); snapshots.put( key, snapshotMetadata );",
        "ins1PreCode":"if ( snapshotMetadata == null ) { snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat ); snapshots.put( key, snapshotMetadata );",
        "ins2PreCode":"if ( snapshotMetadata == null ) { snapshotMetadata = new LocalSnapshotMetadata( artifact, legacyFormat ); snapshots.put( key, snapshotMetadata );",
        "label":1
    },
    {
        "ins1CurCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> documents = jsc.parallelize(Arrays.asList( Arrays.asList(\"this is a sentence\".split(\" \")), Arrays.asList(\"this is another sentence\".split(\" \")), Arrays.asList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents); termFreqs.collect(); IDF idf = new IDF(); JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs); List<Vector> localTfIdfs = tfIdfs.collect(); int indexOfThis = tf.indexOf(\"this\"); for (Vector v : localTfIdfs) { Assert.assertEquals(0.0, v.apply(indexOfThis), 1e-15);",
        "ins1PreCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> documents = sc.parallelize(Arrays.asList( Arrays.asList(\"this is a sentence\".split(\" \")), Arrays.asList(\"this is another sentence\".split(\" \")), Arrays.asList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents); termFreqs.collect(); IDF idf = new IDF(); JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs); List<Vector> localTfIdfs = tfIdfs.collect(); int indexOfThis = tf.indexOf(\"this\"); for (Vector v: localTfIdfs) { Assert.assertEquals(0.0, v.apply(indexOfThis), 1e-15);",
        "ins2PreCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> documents = sc.parallelize(Arrays.asList( Arrays.asList(\"this is a sentence\".split(\" \")), Arrays.asList(\"this is another sentence\".split(\" \")), Arrays.asList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents); termFreqs.collect(); IDF idf = new IDF(2); JavaRDD<Vector> tfIdfs = idf.fit(termFreqs).transform(termFreqs); List<Vector> localTfIdfs = tfIdfs.collect(); int indexOfThis = tf.indexOf(\"this\"); for (Vector v: localTfIdfs) { Assert.assertEquals(0.0, v.apply(indexOfThis), 1e-15);",
        "label":1
    },
    {
        "ins1CurCode":"fail(); } catch (RuntimeException expected) { assertThat(expected.getCause()).isInstanceOf(SomeCheckedException.class); }",
        "ins1PreCode":"fail(); } catch (RuntimeException expected) { assertTrue(expected.getCause() instanceof SomeCheckedException); }",
        "ins2PreCode":"public void testPropagateIfInstanceOf_DeclaredThrown() { Sample sample = new Sample() { @Override public void oneDeclared() throws SomeCheckedException { try { methodThatThrowsChecked(); } catch (Throwable t) { Throwables.propagateIfInstanceOf(t, SomeCheckedException.class); throw Throwables.propagate(t); } } };   try { sample.oneDeclared(); fail(); } catch (SomeCheckedException expected) { }",
        "label":0
    },
    {
        "ins1CurCode":"int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; Platform.copyMemory( baseObject, baseOffset + offset, mag, Platform.INT_ARRAY_OFFSET, size * 4);   BigInteger v = new BigInteger(0, EMPTY); Platform.putInt(v, Platform.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); Platform.putObjectVolatile(v, Platform.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale);",
        "ins1PreCode":"int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; PlatformDependent.copyMemory(baseObject, baseOffset + offset, mag, PlatformDependent.INT_ARRAY_OFFSET, size * 4);   BigInteger v = new BigInteger(0, EMPTY); PlatformDependent.UNSAFE.putInt(v, PlatformDependent.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); PlatformDependent.UNSAFE.putObjectVolatile(v, PlatformDependent.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale);",
        "ins2PreCode":" if (precision <= Decimal.MAX_LONG_DIGITS()) { final long value = PlatformDependent.UNSAFE.getLong(baseObject, baseOffset + offset); return Decimal.apply(value, precision, scale);",
        "label":0
    },
    {
        "ins1CurCode":"public void merge10000SyncStreamOf10() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNSyncStreamsOfN(10000, 10).subscribe(ts);",
        "ins1PreCode":"public void merge10000SyncStreamOf10() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(10000, 10).subscribe(ts);",
        "ins2PreCode":"public void merge1000000SyncStreamOf1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(1000000, 1).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"public int compareTo(DeweyDecimal other) { final int max = Math.max(other.components.length, components.length);",
        "ins1PreCode":"@Override public int compareTo(DeweyDecimal other) { final int max = Math.max(other.components.length, components.length);",
        "ins2PreCode":"public boolean isGreaterThanOrEqual(final DeweyDecimal other) { final int max = Math.max(other.components.length, components.length);  for (int i = 0; i < max; i++) { final int component1 = (i < components.length) ? components[ i ] : 0; final int component2 = (i < other.components.length) ? other.components[ i ] : 0;  if (component2 > component1) { return false; } if (component2 < component1) { return true; } }  return true;",
        "label":0
    },
    {
        "ins1CurCode":".setInputCol(\"prediction\") .setOutputCol(\"predictedLabel\") .setLabels(labelIndexer.labelsArray()[0]); ",
        "ins1PreCode":".setInputCol(\"prediction\") .setOutputCol(\"predictedLabel\") .setLabels(labelIndexer.labels()); ",
        "ins2PreCode":".setInputCol(\"prediction\") .setOutputCol(\"predictedLabel\") .setLabels(labelIndexer.labels()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void jettyCustomizations() { JettyServletWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void jettyCustomizations() throws Exception { JettyServletWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void jettyCustomizersShouldBeInvoked() throws Exception { HttpHandler handler = mock(HttpHandler.class);",
        "label":1
    },
    {
        "ins1CurCode":" BibEntry entry = new BibEntry(); entry.setType(new UnknownEntryType(\"ReallyUnknownType\")); entry.setField(StandardField.COMMENT, \"testentry\"); entry.setCiteKey(\"test\");",
        "ins1PreCode":" BibEntry entry = new BibEntry(); entry.setType(\"ReallyUnknownType\"); entry.setField(\"Comment\", \"testentry\"); entry.setCiteKey(\"test\");",
        "ins2PreCode":"\"}\" + OS.NEWLINE;  BibEntry entry = new BibEntry(); entry.setType(\"other\"); entry.setField(\"Comment\", \"testentry\"); entry.setCiteKey(\"test\");",
        "label":0
    },
    {
        "ins1CurCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); @SuppressWarnings(\"unchecked\") CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData);",
        "label":1
    },
    {
        "ins1CurCode":"public void removeAlias(String alias) {  alias = alias.toLowerCase(Locale.ENGLISH); ",
        "ins1PreCode":"public void removeAlias(String alias) {  alias = alias.toLowerCase(); ",
        "ins2PreCode":"public void removeWrapperLifecycle(String listener) {   synchronized (wrapperLifecyclesLock) {   int n = -1; for (int i = 0; i < wrapperLifecycles.length; i++) { if (wrapperLifecycles[i].equals(listener)) { n = i; break; } } if (n < 0) return;   int j = 0; String results[] = new String[wrapperLifecycles.length - 1]; for (int i = 0; i < wrapperLifecycles.length; i++) { if (i != n) results[j++] = wrapperLifecycles[i]; } wrapperLifecycles = results;  }   fireContainerEvent(\"removeWrapperLifecycle\", listener); ",
        "label":0
    },
    {
        "ins1CurCode":"void testCleanHistoryOnStartProperty() { MockEnvironment environment = new MockEnvironment();",
        "ins1PreCode":"public void testCleanHistoryOnStartProperty() { MockEnvironment environment = new MockEnvironment();",
        "ins2PreCode":"public void testCleanHistoryOnStartPropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment();",
        "label":1
    },
    {
        "ins1CurCode":"void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": true,\\\"read_basic_data\\\": true}\";",
        "ins1PreCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": true,\\\"read_basic_data\\\": true}\";",
        "ins2PreCode":"public void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": false,\\\"read_basic_data\\\": true}\";",
        "label":1
    },
    {
        "ins1CurCode":"void testcrossrefDepartment() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry() .withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, Department of Electrical Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingEE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"[auth]\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins1PreCode":"void testcrossrefDepartment() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, Department of Electrical Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingEE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins2PreCode":"void testcrossrefSchool() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingCE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "label":1
    },
    {
        "ins1CurCode":"final int maxIterations = 1000; for (int counter = 1; counter < maxIterations; counter++) { File localFile = FILE_UTILS.createTempFile(task.getProject(), \"ant\" + Integer.toString(counter), \".tmp\",",
        "ins1PreCode":"final int maxIterations = 1000; for (int counter = 1; counter < maxIterations; counter++) { File localFile = FILE_UTILS.createTempFile( \"ant\" + Integer.toString(counter), \".tmp\",",
        "ins2PreCode":"final int maxIterations = 1000; for (int counter = 1; counter < maxIterations; counter++) { File localFile = FILE_UTILS.createTempFile( \"ant\" + Integer.toString(counter), \".tmp\",",
        "label":1
    },
    {
        "ins1CurCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.get(); ",
        "ins1PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.getActiveInstance(); ",
        "ins2PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.get(); final HashSet<String> hs = new HashSet<>(nodes); List<String> names = null;  for (String node_s : hs) { try { Computer computer = jenkins.getComputer(node_s); if (computer == null) { if (names == null) { names = ComputerSet.getComputerNames(); } String adv = EditDistance.findNearest(node_s, names); throw new IllegalArgumentException(adv == null ? hudson.model.Messages.Computer_NoSuchSlaveExistsWithoutAdvice(node_s) : hudson.model.Messages.Computer_NoSuchSlaveExists(node_s, adv)); } computer.cliOffline(cause); } catch (Exception e) { if (hs.size() == 1) { throw e; }  stderr.println(node_s + \": \" + e.getMessage()); errorOccurred = true; continue; } }  if (errorOccurred) { throw new AbortException(CLI_LISTPARAM_SUMMARY_ERROR_TEXT); } return 0;",
        "label":0
    },
    {
        "ins1CurCode":" LogValidationFilter f = new LogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger(",
        "ins1PreCode":" LogValidationFilter f = new LogValidationFilter( \"The web application [] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger(",
        "ins2PreCode":" LogValidationFilter f = new LogValidationFilter( \"The web application [] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger(",
        "label":1
    },
    {
        "ins1CurCode":"public void testNoData() throws Exception { MappedFieldType ft = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE); ",
        "ins1PreCode":"public void testNoData() throws Exception { MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE); ft.setName(\"field\"); ",
        "ins2PreCode":"public void testUnmapped() throws Exception { MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE); ft.setName(\"field\"); ",
        "label":1
    },
    {
        "ins1CurCode":"} this.subscribers = s; this.values = new AtomicReferenceArray<>(n); this.upstream = new AtomicReference<>(); this.requested = new AtomicLong();",
        "ins1PreCode":"} this.subscribers = s; this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Subscription>(); this.requested = new AtomicLong();",
        "ins2PreCode":"} this.observers = s; this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Disposable>(); this.error = new AtomicThrowable();",
        "label":0
    },
    {
        "ins1CurCode":"inputFilter); } else { result.add(shrinkStatus(stat)); }",
        "ins1PreCode":"inputFilter); } else { result.add(stat); }",
        "ins2PreCode":"inputFilter); } else { result.add(stat); }",
        "label":0
    },
    {
        "ins1CurCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), true, new GeoIpCache(1000), false); IngestDocument originalIngestDocument = RandomDocumentPicks.randomIngestDocument(random(),",
        "ins1PreCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), true, new GeoIpCache(1000)); IngestDocument originalIngestDocument = RandomDocumentPicks.randomIngestDocument(random(),",
        "ins2PreCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), true, new GeoIpCache(1000)); IngestDocument originalIngestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.emptyMap());",
        "label":1
    },
    {
        "ins1CurCode":"public void testEquals_ObjectList4() { XYPlot<String> p1 = new XYPlot<>(); p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); XYPlot<String> p2 = new XYPlot<>(); p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);",
        "ins1PreCode":"public void testEquals_ObjectList4() { XYPlot p1 = new XYPlot(); p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); XYPlot p2 = new XYPlot(); p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);",
        "ins2PreCode":"public void testEquals_ObjectList2() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); assertEquals(p1, p2); p2.setDomainAxisLocation(1, AxisLocation.TOP_OR_LEFT); assertNotEquals(p1, p2);",
        "label":0
    },
    {
        "ins1CurCode":"void parseIgnoresWhitespaceInEpilogueAfterEntry() throws IOException { String testEntry = \"@article{test,author={Ed von Test}}\";",
        "ins1PreCode":"public void parseIgnoresWhitespaceInEpilogueAfterEntry() throws IOException { String testEntry = \"@article{test,author={Ed von Test}}\";",
        "ins2PreCode":"public void parseTrimsWhitespaceInEpilogueAfterEntry() throws IOException { String testEntry = \"@article{test,author={Ed von Test}}\";",
        "label":1
    },
    {
        "ins1CurCode":" FigNode figNode = null; ArgoDiagram diag = ProjectManager.getManager().getCurrentProject() .getActiveDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else {",
        "ins1PreCode":"FigNode figNode = null;  if (Model.getFacade().isAClassifierRole(node)) { figNode = new FigClassifierRole(gm, lay, node); } else if (Model.getFacade().isAMessage(node)) { figNode = new FigMessage(gm, lay, node); } else if (Model.getFacade().isAComment(node)) { figNode = new FigComment(gm, node); } else {",
        "ins2PreCode":"FigNode figNode = null;  if (Model.getFacade().isAActionState(node)) { figNode = new FigActionState(gm, node); } else if (Model.getFacade().isAFinalState(node)) { figNode = new FigFinalState(gm, node); } else if (Model.getFacade().isAStubState(node)) { figNode = new FigStubState(gm, node); } else if (Model.getFacade().isASubmachineState(node)) { figNode = new FigSubmachineState(gm, node); } else if (Model.getFacade().isACompositeState(node)) { figNode = new FigCompositeState(gm, node); } else if (Model.getFacade().isASynchState(node)) { figNode = new FigSynchState(gm, node); } else if (Model.getFacade().isAState(node)) { figNode = new FigSimpleState(gm, node); } else if (Model.getFacade().isAComment(node)) { figNode = new FigComment(gm, node); } else if (Model.getFacade().isAPseudostate(node)) { Object pState = node; Object kind = Model.getFacade().getKind(pState); if (kind == null) { LOG.warn(\"found a null type pseudostate\"); return null; } if (kind.equals(Model.getPseudostateKind().getInitial())) { figNode = new FigInitialState(gm, node); } else if (kind.equals( Model.getPseudostateKind().getChoice())) { figNode = new FigBranchState(gm, node); } else if (kind.equals( Model.getPseudostateKind().getJunction())) { figNode = new FigJunctionState(gm, node); } else if (kind.equals( Model.getPseudostateKind().getFork())) { figNode = new FigForkState(gm, node); } else if (kind.equals( Model.getPseudostateKind().getJoin())) { figNode = new FigJoinState(gm, node); } else if (kind.equals( Model.getPseudostateKind().getShallowHistory())) { figNode = new FigShallowHistoryState(gm, node); } else if (kind.equals( Model.getPseudostateKind().getDeepHistory())) { figNode = new FigDeepHistoryState(gm, node); } else { LOG.warn(\"found a type not known\"); } } if (figNode == null) { LOG.debug(\"TODO: StateDiagramRenderer getFigNodeFor\");",
        "label":0
    },
    {
        "ins1CurCode":"if (timespan == timeskip) { if (maxSize == Long.MAX_VALUE) { source.subscribe(new WindowExactUnboundedObserver<>( downstream, timespan, unit, scheduler, bufferSize)); return; } source.subscribe(new WindowExactBoundedObserver<>( downstream, timespan, unit, scheduler, bufferSize, maxSize, restartTimerOnMaxSize)); return; } source.subscribe(new WindowSkipObserver<>(downstream, timespan, timeskip, unit, scheduler.createWorker(), bufferSize));",
        "ins1PreCode":"if (timespan == timeskip) { if (maxSize == Long.MAX_VALUE) { source.subscribe(new WindowExactUnboundedObserver<T>( downstream, timespan, unit, scheduler, bufferSize)); return; } source.subscribe(new WindowExactBoundedObserver<T>( downstream, timespan, unit, scheduler, bufferSize, maxSize, restartTimerOnMaxSize)); return; } source.subscribe(new WindowSkipObserver<T>(downstream, timespan, timeskip, unit, scheduler.createWorker(), bufferSize));",
        "ins2PreCode":"if (timespan == timeskip) { if (maxSize == Long.MAX_VALUE) { source.subscribe(new WindowExactUnboundedSubscriber<T>( downstream, timespan, unit, scheduler, bufferSize)); return; } source.subscribe(new WindowExactBoundedSubscriber<T>( downstream, timespan, unit, scheduler, bufferSize, maxSize, restartTimerOnMaxSize)); return; } source.subscribe(new WindowSkipSubscriber<T>(downstream, timespan, timeskip, unit, scheduler.createWorker(), bufferSize));",
        "label":1
    },
    {
        "ins1CurCode":"public ArgoDiagram createDiagram(Object namespace) { if (!Model.getFacade().isANamespace(namespace)) { LOG.log(Level.SEVERE, \"No namespace as argument {0}\",namespace);  throw new IllegalArgumentException(",
        "ins1PreCode":"public ArgoDiagram createDiagram(Object namespace) { if (!Model.getFacade().isANamespace(namespace)) { LOG.error(\"No namespace as argument\"); LOG.error(namespace); throw new IllegalArgumentException(",
        "ins2PreCode":"DiagramSettings settings) { if (!Model.getFacade().isANamespace(namespace)) { LOG.error(\"No namespace as argument\"); LOG.error(namespace); throw new IllegalArgumentException(",
        "label":1
    },
    {
        "ins1CurCode":"public void onNextNull() { TestSubscriber<Integer> ts = new TestSubscriber<>();  SafeSubscriber<Integer> so = new SafeSubscriber<>(ts); ",
        "ins1PreCode":"public void onNextNull() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts); ",
        "ins2PreCode":"public void onNextNormal() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  SafeSubscriber<Integer> so = new SafeSubscriber<Integer>(ts); ",
        "label":1
    },
    {
        "ins1CurCode":"void defaultFilterConfiguration() throws IOException { AnnotatedBeanDefinition definition = createBeanDefinition(DefaultConfigurationFilter.class); this.handler.handle(definition, this.registry); BeanDefinition filterRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationFilter.class.getName()); MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat((EnumSet<DispatcherType>) propertyValues.get(\"dispatcherTypes\")) .containsExactly(DispatcherType.REQUEST); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((String[]) propertyValues.get(\"servletNames\")).isEmpty(); assertThat((String[]) propertyValues.get(\"urlPatterns\")).isEmpty(); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationFilter.class.getName()); assertThat(propertyValues.get(\"filter\")).isEqualTo(definition);",
        "ins1PreCode":"void defaultFilterConfiguration() throws IOException { ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(DefaultConfigurationFilter.class.getName())); this.handler.handle(scanned, this.registry); BeanDefinition filterRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationFilter.class.getName()); MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat((EnumSet<DispatcherType>) propertyValues.get(\"dispatcherTypes\")) .containsExactly(DispatcherType.REQUEST); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((String[]) propertyValues.get(\"servletNames\")).isEmpty(); assertThat((String[]) propertyValues.get(\"urlPatterns\")).isEmpty(); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationFilter.class.getName()); assertThat(propertyValues.get(\"filter\")).isEqualTo(scanned);",
        "ins2PreCode":"void defaultServletConfiguration() throws IOException { ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(DefaultConfigurationServlet.class.getName())); this.handler.handle(scanned, this.registry); BeanDefinition servletRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationServlet.class.getName()); MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((Integer) propertyValues.get(\"loadOnStartup\")).isEqualTo(-1); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationServlet.class.getName()); assertThat((String[]) propertyValues.get(\"urlMappings\")).isEmpty(); assertThat(propertyValues.get(\"servlet\")).isEqualTo(scanned);",
        "label":0
    },
    {
        "ins1CurCode":"channel.start(Channel.DEFAULT); }catch ( ChannelException x ) { if (x.getMessage().contains(\"option flag conflict\")) error = true; }",
        "ins1PreCode":"channel.start(Channel.DEFAULT); }catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; }",
        "ins2PreCode":"channel.start(Channel.DEFAULT); }catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; }",
        "label":1
    },
    {
        "ins1CurCode":"public void tomcatConnectorCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatConnectorCustomizer[] customizers = new TomcatConnectorCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatConnectorCustomizer.class)); factory.setTomcatConnectorCustomizers( Arrays.asList(customizers[0], customizers[1])); factory.addConnectorCustomizers(customizers[2], customizers[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) customizers); for (TomcatConnectorCustomizer customizer : customizers) { ordered.verify(customizer).customize(any(Connector.class)); }",
        "ins1PreCode":"public void tomcatConnectorCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatConnectorCustomizer[] listeners = new TomcatConnectorCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatConnectorCustomizer.class)); factory.setTomcatConnectorCustomizers(Arrays.asList(listeners[0], listeners[1])); factory.addConnectorCustomizers(listeners[2], listeners[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) listeners); for (TomcatConnectorCustomizer listener : listeners) { ordered.verify(listener).customize(any(Connector.class)); }",
        "ins2PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatServletWebServerFactory factory = getFactory(); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] listeners = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); factory.setTomcatProtocolHandlerCustomizers( Arrays.asList(listeners[0], listeners[1])); factory.addProtocolHandlerCustomizers(listeners[2], listeners[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) listeners); for (TomcatProtocolHandlerCustomizer listener : listeners) { ordered.verify(listener).customize(any(ProtocolHandler.class)); }",
        "label":1
    },
    {
        "ins1CurCode":"public void test2bisButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"});",
        "ins1PreCode":"public void test2bisButCaseInsensitive() { if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"});",
        "ins2PreCode":"public void testPatternsDifferInCaseScanningSensitive() { if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"});",
        "label":1
    },
    {
        "ins1CurCode":"@Override public Tuple apply(Throwable n) { return new Tuple(1L, n); }})",
        "ins1PreCode":"@Override public Tuple apply(Throwable n) { return new Tuple(new Long(1), n); }})",
        "ins2PreCode":"@Override public Tuple apply(Throwable n) { return new Tuple(new Long(1), n); }})",
        "label":1
    },
    {
        "ins1CurCode":" try { if (process.execute() != 0) { throw new BuildException(\"JJTree failed.\");",
        "ins1PreCode":" try { if (Execute.isFailure(process.execute())) { throw new BuildException(\"JJTree failed.\");",
        "ins2PreCode":" try { if (Execute.isFailure(process.execute())) { throw new BuildException(\"JJDoc failed.\");",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32FieldMap().keySet()));",
        "ins1PreCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "label":1
    },
    {
        "ins1CurCode":"private WeakReference<ClassLoader> useFrqInSeparateLoader() throws Exception { final ClassLoader myLoader = getClass().getClassLoader(); URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent()); ",
        "ins1PreCode":"private WeakReference<ClassLoader> useFrqInSeparateLoader() throws Exception { final URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader(); final URL[] urls = myLoader.getURLs(); URLClassLoader sepLoader = new URLClassLoader(urls, myLoader.getParent()); ",
        "ins2PreCode":"private WeakReference<ClassLoader> useFrqInSeparateLoader() throws Exception { final URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader(); final URL[] urls = myLoader.getURLs(); URLClassLoader sepLoader = new URLClassLoader(urls, myLoader.getParent()); ",
        "label":1
    },
    {
        "ins1CurCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints, String dispatcherServletPath) { StaticWebApplicationContext context = new StaticWebApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context .getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } if (dispatcherServletPath != null) { DispatcherServletPath path = () -> dispatcherServletPath; context.registerBean(DispatcherServletPath.class, () -> path); }",
        "ins1PreCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints, String... servletPaths) { StaticWebApplicationContext context = new StaticWebApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context .getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } if (servletPaths != null) { DispatcherServletPathProvider pathProvider = () -> new LinkedHashSet<>( Arrays.asList(servletPaths)); context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider); }",
        "ins2PreCode":"private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, PathMappedEndpoints pathMappedEndpoints) { StaticApplicationContext context = new StaticApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context.getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } return assertThat(new RequestMatcherAssert(context, matcher));",
        "label":0
    },
    {
        "ins1CurCode":"  expected.remove(ACMPortalFetcher.class); expected.remove(JstorFetcher.class); expected.remove(GoogleScholar.class); ",
        "ins1PreCode":"assertEquals(expected, getClasses(fullTextFetchers)); }",
        "ins2PreCode":"expected.remove(IdParserFetcher.class); assertEquals(expected, getClasses(idFetchers)); }",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(\"valueD\"); assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrDefault(2, 3, DEFAULT)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, DEFAULT)).isEqualTo(\"valueD\"); ",
        "ins1PreCode":"assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(\"valueD\");  String toString = graph.toString(); assertThat(toString).doesNotContain(\"valueA\"); assertThat(toString).contains(\"valueB\"); assertThat(toString).contains(\"valueC\");",
        "ins2PreCode":"assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(\"valueD\");  String toString = graph.toString(); assertThat(toString).contains(\"valueA\"); assertThat(toString).contains(\"valueB\"); assertThat(toString).contains(\"valueC\");",
        "label":1
    },
    {
        "ins1CurCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.log(Level.FINE, \"toDoItemsChanged\"); List<ToDoItem> items = tde.getToDoItemList();",
        "ins1PreCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.debug(\"toDoItemsChanged\"); List<ToDoItem> items = tde.getToDoItemList();",
        "ins2PreCode":"public void toDoItemsAdded(ToDoListEvent tde) { LOG.debug(\"toDoItemAdded\"); List<ToDoItem> items = tde.getToDoItemList();",
        "label":1
    },
    {
        "ins1CurCode":"{ String objectName = oldObject.getName(); if (!isFullyCached()) { this.loadObjects(monitor, owner);",
        "ins1PreCode":"{ String objectName = oldObject.getName(); if (!isCached()) { this.loadObjects(monitor, owner);",
        "ins2PreCode":"{ String objectName = oldObject.getName(); if (!isCached()) { this.loadObjects(monitor, owner);",
        "label":1
    },
    {
        "ins1CurCode":"public void liveReloadDisabled() { Map<String, Object> properties = new HashMap<>();",
        "ins1PreCode":"public void liveReloadDisabled() throws Exception { Map<String, Object> properties = new HashMap<>();",
        "ins2PreCode":"public void restartDisabled() throws Exception { Map<String, Object> properties = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"public static Completable concatArray(CompletableSource... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins1PreCode":"public static Completable concatArray(CompletableSource... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins2PreCode":"public static Completable mergeArray(CompletableSource... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "label":1
    },
    {
        "ins1CurCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":"Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins2PreCode":"Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "label":1
    },
    {
        "ins1CurCode":"if (LINES_KEY.equals(params[i].getName())) { lines = new Long(params[i].getValue()).longValue(); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = new Long(params[i].getValue()).longValue(); continue; }",
        "ins1PreCode":"if (LINES_KEY.equals(params[i].getName())) { lines = new Long(params[i].getValue()).longValue(); break; } if (SKIP_KEY.equals(params[i].getName())) { skip = new Long(params[i].getValue()).longValue(); break; }",
        "ins2PreCode":"if (LINES_KEY.equals(params[i].getName())) { setLines(new Long(params[i].getValue()).longValue()); break; } if (SKIP_KEY.equals(params[i].getName())) { skip = new Long(params[i].getValue()).longValue(); break; }",
        "label":1
    },
    {
        "ins1CurCode":"queryBuilder = (HasParentQueryBuilder) queryBuilder.rewrite(context);  assertNotNull(context); Map<String, InnerHitContextBuilder> innerHitBuilders = new HashMap<>();",
        "ins1PreCode":"queryBuilder = (HasParentQueryBuilder) queryBuilder.rewrite(context);  Map<String, InnerHitContextBuilder> innerHitBuilders = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(queryBuilder, innerHitBuilders);",
        "ins2PreCode":"protected void doAssertLuceneQuery(HasChildQueryBuilder queryBuilder, Query query, QueryShardContext context) throws IOException { assertThat(query, instanceOf(HasChildQueryBuilder.LateParsingQuery.class)); HasChildQueryBuilder.LateParsingQuery lpq = (HasChildQueryBuilder.LateParsingQuery) query; assertEquals(queryBuilder.minChildren(), lpq.getMinChildren()); assertEquals(queryBuilder.maxChildren(), lpq.getMaxChildren()); assertEquals(queryBuilder.scoreMode(), lpq.getScoreMode()); if (queryBuilder.innerHit() != null) {   queryBuilder = (HasChildQueryBuilder) queryBuilder.rewrite(context); Map<String, InnerHitContextBuilder> innerHitBuilders = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(queryBuilder, innerHitBuilders); assertTrue(innerHitBuilders.containsKey(queryBuilder.innerHit().getName())); InnerHitContextBuilder innerHits = innerHitBuilders.get(queryBuilder.innerHit().getName()); assertEquals(innerHits.innerHitBuilder(), queryBuilder.innerHit()); }",
        "label":0
    },
    {
        "ins1CurCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex(2l); Assertions.assertNotNull(person, \"person must not be null\"); Assertions.assertEquals(\"Christian\", person.getFirstName()); Assertions.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assertions.assertNotNull(parent, \"parent must not be null\"); Assertions.assertEquals(\"John\", parent.getFirstName()); Assertions.assertEquals(\"Smith\", parent.getLastName()); }",
        "ins1PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "ins2PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex2(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "label":1
    },
    {
        "ins1CurCode":" JFileChooser chooser = new JFileChooser(); chooser.setDialogTitle(Translator.localize(\"action.deploy-profile\")); chooser.setFileView(ProjectFileView.getInstance()); chooser.setApproveButtonText(Translator.localize(\"filechooser.export\")); chooser.setAcceptAllFileFilterUsed(true); pm.setXmiFileChooserFilter(chooser); if (fn.length() > 0) { fn = PersistenceManager.getInstance().getBaseName(fn); chooser.setSelectedFile(new File(fn)); } int result = chooser.showSaveDialog(ArgoFrame.getFrame()); if (result == JFileChooser.APPROVE_OPTION) { theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name); ProjectBrowser.getInstance().trySaveWithProgressMonitor(true, theFile, false); }",
        "ins1PreCode":" JFileChooser chooser = new JFileChooser(); chooser.setDialogTitle(\"Save Profile\"); chooser.setFileView(ProjectFileView.getInstance()); chooser.setApproveButtonText(\"Save\"); chooser.setAcceptAllFileFilterUsed(true); pm.setXmiFileChooserFilter(chooser); if (fn.length() > 0) { fn = PersistenceManager.getInstance().getBaseName(fn); chooser.setSelectedFile(new File(fn)); } int result = chooser.showSaveDialog(ArgoFrame.getFrame()); if (result == JFileChooser.APPROVE_OPTION) { theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name); ProjectBrowser.getInstance().trySaveWithProgressMonitor( true, theFile, false); }",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { PersistenceManager pm = PersistenceManager.getInstance();  JFileChooser chooser = new JFileChooser(); chooser.setDialogTitle(Translator.localize( \"action.export-project-as-xmi\")); chooser.setFileView(ProjectFileView.getInstance()); chooser.setApproveButtonText(Translator.localize( \"filechooser.export\")); chooser.setAcceptAllFileFilterUsed(true); pm.setXmiFileChooserFilter(chooser);  String fn = Configuration.getString( PersistenceManager.KEY_PROJECT_NAME_PATH); if (fn.length() > 0) { fn = PersistenceManager.getInstance().getBaseName(fn); chooser.setSelectedFile(new File(fn)); }  int result = chooser.showSaveDialog(ArgoFrame.getFrame()); if (result == JFileChooser.APPROVE_OPTION) { File theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); Configuration.setString( PersistenceManager.KEY_PROJECT_NAME_PATH, PersistenceManager.getInstance().getBaseName( theFile.getPath())); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name); ProjectBrowser.getInstance().trySaveWithProgressMonitor( false, theFile, false); } }",
        "label":0
    },
    {
        "ins1CurCode":"+ getViewPathBasename(), Project.MSG_VERBOSE); } int result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { throw new BuildException(\"Failed executing: \" + commandLine, getLocation()); }",
        "ins1PreCode":"Commandline commandLine = new Commandline(); Project aProj = getProject(); int result = 0;   if (getViewPath() == null) { setViewPath(aProj.getBaseDir().getPath()); }     commandLine.setExecutable(getClearToolCommand()); commandLine.createArgument().setValue(COMMAND_UNCHECKOUT);  checkOptions(commandLine);  if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getViewPathBasename(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "ins2PreCode":"Commandline commandLine = new Commandline(); Project aProj = getProject(); int result = 0;   if (getViewPath() == null) { setViewPath(aProj.getBaseDir().getPath()); }     commandLine.setExecutable(getClearToolCommand()); commandLine.createArgument().setValue(COMMAND_CHECKOUT);  checkOptions(commandLine);      if (!getNotco() && lsCheckout()) { getProject().log(\"Already checked out in this view: \" + getViewPathBasename(), Project.MSG_VERBOSE); return; } if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getViewPathBasename(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "label":1
    },
    {
        "ins1CurCode":"  HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request).getRequest(); ",
        "ins1PreCode":"  HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request); ",
        "ins2PreCode":"  HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDirectoryRetaining() { buildRule.executeTarget(\"testDirectoryRetaining\");",
        "ins1PreCode":"public void testDirectoryRetaining() throws IOException { buildRule.executeTarget(\"testDirectoryRetaining\");",
        "ins2PreCode":"private void testCompleteDirectoryMove(String target) throws IOException { buildRule.executeTarget(target);",
        "label":1
    },
    {
        "ins1CurCode":"}  List<File> parents = new Vector<>(); String dirname;  while ((dirname = dir.getParent()) != null) { File checkDir = new File(dirname); if (dirCache.contains(checkDir)) { break; } dir = checkDir; parents.add(dir); }   int i = parents.size() - 1;  if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); if (parent != null && !ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException(\"could not change to directory: %s\", ftp.getReplyString()); }  while (i >= 0) { dir = parents.get(i--);  if (!ftp.changeWorkingDirectory(dir.getName())) {  log(\"creating remote directory \" + resolveFile(dir.getPath()), Project.MSG_VERBOSE); if (!ftp.makeDirectory(dir.getName())) { handleMkDirFailure(ftp); } if (!ftp.changeWorkingDirectory(dir.getName())) { throw new BuildException( \"could not change to directory: %s\", ftp.getReplyString()); }",
        "ins1PreCode":"}  Vector parents = new Vector(); String dirname;  while ((dirname = dir.getParent()) != null) { File checkDir = new File(dirname); if (dirCache.contains(checkDir)) { break; } dir = checkDir; parents.addElement(dir); }   int i = parents.size() - 1;  if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); if (parent != null) { if (!ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException(\"could not change to \" + \"directory: \" + ftp.getReplyString()); } }  while (i >= 0) { dir = (File) parents.elementAt(i--);  if (!ftp.changeWorkingDirectory(dir.getName())) {  log(\"creating remote directory \" + resolveFile(dir.getPath()), Project.MSG_VERBOSE); if (!ftp.makeDirectory(dir.getName())) { handleMkDirFailure(ftp); } if (!ftp.changeWorkingDirectory(dir.getName())) { throw new BuildException(\"could not change to \" + \"directory: \" + ftp.getReplyString()); }",
        "ins2PreCode":"}  Vector parents = new Vector(); String dirname;  while ((dirname = dir.getParent()) != null) { File checkDir = new File(dirname); if (dirCache.contains(checkDir)) { break; } dir = checkDir; parents.addElement(dir); }   int i = parents.size() - 1;  if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); if (parent != null) { if (!ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException(\"could not change to \" + \"directory: \" + ftp.getReplyString()); } }  while (i >= 0) { dir = (File) parents.elementAt(i--);  if (!ftp.changeWorkingDirectory(dir.getName())) {  task.log(\"creating remote directory \" + resolveFile(dir.getPath()), Project.MSG_VERBOSE); if (!ftp.makeDirectory(dir.getName())) { handleMkDirFailure(ftp); } if (!ftp.changeWorkingDirectory(dir.getName())) { throw new BuildException(\"could not change to \" + \"directory: \" + ftp.getReplyString()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { String sql = String.format(SQL_RENAME_TABLE,",
        "ins1PreCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { String sql = String.format(SQL_RENAME_TABLE,",
        "ins2PreCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"public void propertySourceAnnotationWithName() { SpringApplication application = new SpringApplication(",
        "ins1PreCode":"public void propertySourceAnnotationWithName() throws Exception { SpringApplication application = new SpringApplication(",
        "ins2PreCode":"public void propertySourceAnnotationMultipleLocations() throws Exception { SpringApplication application = new SpringApplication(",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,a = {a\\nb}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins1PreCode":".parse(new StringReader(\"@article{test,a = {a\\nb}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\"));",
        "ins2PreCode":".parse(new StringReader(\"@article{test,a = {a\\tb}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\"));",
        "label":1
    },
    {
        "ins1CurCode":"TestSubscriber<Integer> ts = TestSubscriber.create();  Flowable.just(Flowable.just(1)).concatMapDelayError((Function)Functions.identity(), true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts); ",
        "ins1PreCode":"TestSubscriber<Integer> ts = TestSubscriber.create();  Flowable.just(Flowable.just(1)).concatMapDelayError((Function)Functions.identity(), 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts); ",
        "ins2PreCode":"public void concatMapJustJust() { TestSubscriber<Integer> ts = TestSubscriber.create();  Flowable.just(Flowable.just(1)).concatMap((Function)Functions.identity(), 2, ImmediateThinScheduler.INSTANCE).subscribe(ts);  ts.assertValue(1); ts.assertNoErrors(); ts.assertComplete();",
        "label":0
    },
    {
        "ins1CurCode":"Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, null, config); fail(\"factory create should have failed\");",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void draggedOnBottomOfGroupAddsAfterItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "ins1PreCode":"public void draggedOnBottomOfGroupAddsAfterItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "ins2PreCode":"public void draggedOnTopOfGroupAddsBeforeItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "label":1
    },
    {
        "ins1CurCode":"ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapContext, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins1PreCode":"ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins2PreCode":"ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "label":1
    },
    {
        "ins1CurCode":";  assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such node 'never_created'\"));",
        "ins1PreCode":";  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"No such node 'never_created'\"));",
        "ins2PreCode":".invokeWithArgs(\"never_created\");  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"No such job 'never_created'\"));",
        "label":1
    },
    {
        "ins1CurCode":"List<Throwable> errors = trackPluginErrors(); try { Disposable d1 = Disposable.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposable.empty(); ",
        "ins1PreCode":"List<Throwable> errors = trackPluginErrors(); try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "ins2PreCode":"List<Throwable> errors = trackPluginErrors(); try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"void shouldSerializeAProxyForABeanWithoutDefaultConstructor() throws Exception { AuthorWithoutDefaultConstructor author = new AuthorWithoutDefaultConstructor(999, \"someone\", \"!@#@!#!@#\", \"someone@somewhere.com\", \"blah\", Section.NEWS);",
        "ins1PreCode":"public void shouldSerializeAProxyForABeanWithoutDefaultConstructor() throws Exception { AuthorWithoutDefaultConstructor author = new AuthorWithoutDefaultConstructor(999, \"someone\", \"!@#@!#!@#\", \"someone@somewhere.com\", \"blah\", Section.NEWS);",
        "ins2PreCode":"public void shouldSerializeAProxyForABeanWithoutDefaultConstructorAndUnloadedProperties() throws Exception { AuthorWithoutDefaultConstructor author = new AuthorWithoutDefaultConstructor(999, \"someone\", \"!@#@!#!@#\", \"someone@somewhere.com\", \"blah\", Section.NEWS);",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 43; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 43; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CombinedRangeXYPlot<String> plot1 = createPlot(); CombinedRangeXYPlot<String> plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedRangeXYPlot plot1 = createPlot(); CombinedRangeXYPlot plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedRangeCategoryPlot plot1 = createPlot(); CombinedRangeCategoryPlot plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2); assertTrue(plot1.getClass() == plot2.getClass()); assertTrue(plot1.equals(plot2));",
        "label":0
    },
    {
        "ins1CurCode":".isEqualTo(\"[jars/]\"); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).areExactly(1, endingWith(\"app.jar\"));",
        "ins1PreCode":".isEqualTo(\"[jars/]\"); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).areExactly(1, endingWith(\"app.jar!/\"));",
        "ins2PreCode":"List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\")); assertThat(archives).areExactly(1, endingWith(\"app.jar!/\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "label":1
    },
    {
        "ins1CurCode":"};  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"};  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"};  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testEmptyMapIsNotAdded() { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "ins1PreCode":"public void testEmptyMapIsNotAdded() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "ins2PreCode":"public void testList() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner()",
        "label":1
    },
    {
        "ins1CurCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass()); Instantiator<ConfigDataLocationResolver<?>> instantiator = new Instantiator<>(ConfigDataLocationResolver.class,",
        "ins1PreCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, Binder binder, ResourceLoader resourceLoader, List<String> names) { Instantiator<ConfigDataLocationResolver<?>> instantiator = new Instantiator<>(ConfigDataLocationResolver.class, (availableParameters) -> {",
        "ins2PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, List<String> names) { this.logger = logFactory.getLog(getClass()); Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> availableParameters.add(Log.class, logFactory::getLog)); this.loaders = instantiator.instantiate(names); this.locationTypes = getLocationTypes(this.loaders);",
        "label":0
    },
    {
        "ins1CurCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins1PreCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins2PreCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"void connectionToEntryUsingAbsoluteUrlForEntryFromNestedJarFile() throws Exception { URL url = new URL(\"jar:\" + this.rootJarFile.toURI().toURL() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) {",
        "ins1PreCode":"void connectionToEntryUsingAbsoluteUrlForEntryFromNestedJarFile() throws Exception { URL url = new URL(\"jar:file:\" + getAbsolutePath() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) {",
        "ins2PreCode":"void connectionToEntryUsingRelativeUrlForEntryFromNestedJarFile() throws Exception { URL url = new URL(\"jar:file:\" + getRelativePath() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); } }",
        "label":0
    },
    {
        "ins1CurCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String results = decoder.decode(ByteBuffer.wrap(\"a string\".getBytes()), context); assertNull(results); assertEquals(8, context.getBuffer().position());",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\".getBytes()), context); assertNotNull(results); assertEquals(0, results.length); assertEquals(8, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\".getBytes()), context); assertNotNull(results); assertEquals(0, results.length); assertEquals(8, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1CurCode":"throws IOException { Objects.requireNonNull( input, \"input cannot be null\" ); ",
        "ins1PreCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "ins2PreCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "label":1
    },
    {
        "ins1CurCode":"throw new TestException(); } else { return new ArrayList<>(); }",
        "ins1PreCode":"throw new TestException(); } else { return new ArrayList<Integer>(); }",
        "ins2PreCode":"throw new TestException(); } else { return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"editor\"));",
        "label":1
    },
    {
        "ins1CurCode":"Flowable.range(1, 5) .doFinally(this) .compose(TestHelper.conditional()) .subscribe(ts);",
        "ins1PreCode":"Flowable.range(1, 5) .doFinally(this) .filter(Functions.alwaysTrue()) .subscribe(ts);",
        "ins2PreCode":"public void syncFusedBoundary() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.SYNC | QueueFuseable.BOUNDARY);  Flowable.range(1, 5) .doFinally(this) .subscribe(ts);  ts.assertFusionMode(QueueFuseable.NONE) .assertResult(1, 2, 3, 4, 5);  assertEquals(1, calls);",
        "label":0
    },
    {
        "ins1CurCode":"public void mergeObservableMaxConcurrent() { final List<Long> requested = new ArrayList<>(); Flowable<Completable> cs = Flowable",
        "ins1PreCode":"public void mergeObservableMaxConcurrent() { final List<Long> requested = new ArrayList<Long>(); Flowable<Completable> cs = Flowable",
        "ins2PreCode":"public void mergeDelayErrorObservableMaxConcurrent() { final List<Long> requested = new ArrayList<Long>(); Flowable<Completable> cs = Flowable",
        "label":1
    },
    {
        "ins1CurCode":"public void setUp() throws Exception { super.setUp(); for (int i = 0; i < channels.length; i++) { channels[i] = new GroupChannel(); channels[i].getMembershipService().setPayload( (\"Channel-\" + (i + 1)).getBytes(\"ASCII\")); listeners[i] = new TestMsgListener( (\"Listener-\" + (i + 1))); channels[i].addChannelListener(listeners[i]); } TesterUtil.addRandomDomain(channels); for (int i = 0; i < channels.length; i++) { channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ); }",
        "ins1PreCode":"public void setUp() throws Exception { super.setUp(); for (int i = 0; i < channels.length; i++) { channels[i] = new GroupChannel(); channels[i].getMembershipService().setPayload( (\"Channel-\" + (i + 1)).getBytes(\"ASCII\")); listeners[i] = new TestMsgListener( (\"Listener-\" + (i + 1))); channels[i].addChannelListener(listeners[i]); channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ); } TesterUtil.addRandomDomain(channels);",
        "ins2PreCode":"public void setUp() throws Exception { for (int i = 0; i < channels.length; i++) { channels[i] = new GroupChannel(); channels[i].getMembershipService().setPayload( (\"Channel-\" + (i + 1)).getBytes(\"ASCII\")); listeners[i] = new TestMbrListener( (\"Listener-\" + (i + 1))); channels[i].addMembershipListener(listeners[i]); DomainFilterInterceptor filter = new DomainFilterInterceptor(); filter.setDomain(UUIDGenerator.randomUUID(false)); channels[i].addInterceptor(filter); }",
        "label":0
    },
    {
        "ins1CurCode":" try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null ParallelFailureHandling\"); } catch (Throwable exc) {",
        "ins1PreCode":" try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "ins2PreCode":" try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "label":1
    },
    {
        "ins1CurCode":"String tmpdir = project.getProperty(\"tmpregexp\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\");",
        "ins1PreCode":"String tmpdir = project.getProperty(\"tmpregexp\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(2); executeTarget(\"testNoPreserve\");",
        "ins2PreCode":"String tmpdir = project.getProperty(\"tmpregexp\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(2); executeTarget(\"testPreserve\");",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsSpace() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1, ,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1, ,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1,2, \");",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsSpace() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1, ,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1, ,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2, \");",
        "ins2PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsInvalid() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1a,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1a,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"aa,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse 'aa,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2a,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2a,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,aa,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,aa,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,3a\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2,3a', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,aa\");",
        "label":0
    },
    {
        "ins1CurCode":"static OracleTableColumn addColumn(OracleTableBase table, String columnName, String columnType, int ordinalPosition) throws DBException { OracleTableColumn column = new OracleTableColumn(table);",
        "ins1PreCode":"static OracleTableColumn addColumn(OracleTableBase table, String columnName, String columnType, int ordinalPosition) { OracleTableColumn column = new OracleTableColumn(table);",
        "ins2PreCode":"private PostgreTableColumn addColumn(PostgreTableBase table, String columnName, String columnType, int ordinalPosition) { PostgreTableColumn column = new PostgreTableColumn(table);",
        "label":1
    },
    {
        "ins1CurCode":"public void orderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "ins1PreCode":"public void orderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "ins2PreCode":"public void unorderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValuesOnly() { TestObserverEx<Integer> to = new TestObserverEx<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void assertValuesOnly() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void assertValuesOnlyThrowsOnUnexpectedValue() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"boolean mustChange = true; if (expression != null) { Object oldValue = Model.getFacade().getBody(expression).toString(); if (oldValue != null && oldValue.equals(body)) {",
        "ins1PreCode":"boolean mustChange = true; if (expression != null) { Object oldValue = Model.getDataTypesHelper().getBody(expression); if (oldValue != null && oldValue.equals(body)) {",
        "ins2PreCode":"public void setBody(String body) {  Object expression = getExpression(); boolean mustChange = true; if (expression != null) { Object oldValue = Model.getDataTypesHelper().getBody(expression); if (oldValue != null && oldValue.equals(body)) { mustChange = false; } } if (mustChange) { String lang = null; if (expression != null) { lang = Model.getDataTypesHelper().getLanguage(expression); } if (lang == null) { lang = EMPTYSTRING; }  setExpression(lang, body); }",
        "label":0
    },
    {
        "ins1CurCode":"gzipClient.connect(); gzipClient.processRequest(); Assert.assertTrue(gzipClient.isResponse200()); List<String> responseHeaders = gzipClient.getResponseHeaders(); Assert.assertTrue(responseHeaders.contains(\"Content-Encoding: gzip\")); Assert.assertTrue(responseHeaders.contains(\"Content-Length: \" + gzipSize)); Assert.assertTrue(responseHeaders.contains(\"Vary: accept-encoding\"));  gzipClient.reset(); gzipClient.setRequest(new String[] { \"GET /index.html HTTP/1.1\" + CRLF + \"Host: localhost\" + CRLF + \"Connection: Close\" + CRLF+ CRLF }); gzipClient.connect(); gzipClient.processRequest(); Assert.assertTrue(gzipClient.isResponse200()); responseHeaders = gzipClient.getResponseHeaders(); Assert.assertTrue(responseHeaders.contains(\"Content-Type: text/html\")); Assert.assertFalse(responseHeaders.contains(\"Content-Encoding: gzip\")); Assert.assertTrue(responseHeaders.contains(\"Content-Length: \" + indexSize)); Assert.assertTrue(responseHeaders.contains(\"Vary: accept-encoding\"));",
        "ins1PreCode":"gzipClient.connect(); gzipClient.processRequest(); assertTrue(gzipClient.isResponse200()); List<String> responseHeaders = gzipClient.getResponseHeaders(); assertTrue(responseHeaders.contains(\"Content-Encoding: gzip\")); assertTrue(responseHeaders.contains(\"Content-Length: \" + gzipSize)); assertTrue(responseHeaders.contains(\"Vary: accept-encoding\"));  gzipClient.reset(); gzipClient.setRequest(new String[] { \"GET /index.html HTTP/1.1\" + CRLF + \"Host: localhost\" + CRLF + \"Connection: Close\" + CRLF+ CRLF }); gzipClient.connect(); gzipClient.processRequest(); assertTrue(gzipClient.isResponse200()); responseHeaders = gzipClient.getResponseHeaders(); assertTrue(responseHeaders.contains(\"Content-Type: text/html\")); assertFalse(responseHeaders.contains(\"Content-Encoding: gzip\")); assertTrue(responseHeaders.contains(\"Content-Length: \" + indexSize)); assertTrue(responseHeaders.contains(\"Vary: accept-encoding\"));",
        "ins2PreCode":"client.connect(); client.processRequest(); assertTrue(client.isResponse200()); List<String> responseHeaders = client.getResponseHeaders(); assertTrue(responseHeaders.contains(\"Content-Encoding: br\")); assertTrue(responseHeaders.contains(\"Content-Length: \" + brSize)); assertTrue(responseHeaders.contains(\"Vary: accept-encoding\"));  client.reset(); client.setRequest(new String[] { \"GET /index.html HTTP/1.1\" + CRLF + \"Host: localhost\" + CRLF + \"Connection: Close\" + CRLF+ CRLF }); client.connect(); client.processRequest(); assertTrue(client.isResponse200()); responseHeaders = client.getResponseHeaders(); assertTrue(responseHeaders.contains(\"Content-Type: text/html\")); assertFalse(responseHeaders.contains(\"Content-Encoding\")); assertTrue(responseHeaders.contains(\"Content-Length: \" + indexSize)); assertTrue(responseHeaders.contains(\"Vary: accept-encoding\"));",
        "label":1
    },
    {
        "ins1CurCode":"buf.addLast(new Node(5));  List<Integer> values = new ArrayList<>(); buf.collect(values);",
        "ins1PreCode":"buf.addLast(new Node(5));  List<Integer> values = new ArrayList<Integer>(); buf.collect(values);",
        "ins2PreCode":"buf.addLast(new Node(5));  List<Integer> values = new ArrayList<Integer>(); buf.collect(values);",
        "label":1
    },
    {
        "ins1CurCode":"} catch (InvocationTargetException ex) { DBWorkbench.getPlatformUI().showError( \"Export error\",",
        "ins1PreCode":"} catch (InvocationTargetException ex) { DBUserInterface.getInstance().showError( \"Export error\",",
        "ins2PreCode":"} catch (InvocationTargetException ex) { DBUserInterface.getInstance().showError( \"Import error\",",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"assertFalse(ro.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertFalse(ro.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertFalse(ro.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"(webXml.getClass().getName() + \".setDistributable(true)\"); }  StringBuilder code = digester.getGeneratedCode(); if (code != null) { code.append(System.lineSeparator()); code.append(digester.toVariableName(webXml)).append(\".setDistributable(true);\"); code.append(System.lineSeparator()); }",
        "ins1PreCode":"(webXml.getClass().getName() + \".setDistributable(true)\"); }",
        "ins2PreCode":"\".setDenyUncoveredHttpMethods(true)\"); }",
        "label":1
    },
    {
        "ins1CurCode":"public void disposedInOnComplete() { final TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void disposedInOnComplete() { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void disposedInOnComplete() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedRate()).isEmpty(); assertThat(tasks.getCustom()).isEmpty(); assertThat(tasks.getFixedDelay()).hasSize(1);",
        "ins1PreCode":"assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedRate()).isEmpty(); assertThat(tasks.getFixedDelay()).hasSize(1); FixedDelayTaskDescription description = (FixedDelayTaskDescription) tasks",
        "ins2PreCode":"assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedRate()).isEmpty(); assertThat(tasks.getFixedDelay()).hasSize(1); FixedDelayTaskDescription description = (FixedDelayTaskDescription) tasks",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"trace\")).isTrue();",
        "ins1PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue();",
        "ins2PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"public void eagerDisposedOnComplete() { final TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void eagerDisposedOnComplete() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void eagerDisposedOnError() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>();  tc.onSubscribe(Disposable.empty());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>();  tc.onSubscribe(Disposables.empty());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>();  tc.onSubscribe(Disposables.empty());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getAllUsers(new RowBounds(0, 4)); Assertions.assertEquals(4, users.size()); }",
        "ins1PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getAllUsers(new RowBounds(0, 4)); Assert.assertEquals(4, users.size()); }",
        "ins2PreCode":"AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); List<User> users = mapper.getAllUsers(new RowBounds(0, 4)); Assert.assertEquals(4, users.size()); }",
        "label":1
    },
    {
        "ins1CurCode":"assertFalse(rso.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertFalse(rso.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertFalse(rso.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerialization5() { DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>(); CategoryAxis domainAxis1 = new CategoryAxis(\"Domain 1\"); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); BarRenderer renderer1 = new BarRenderer(); CategoryPlot p1 = new CategoryPlot(dataset1, domainAxis1, rangeAxis1, renderer1); CategoryAxis domainAxis2 = new CategoryAxis(\"Domain 2\"); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\"); BarRenderer renderer2 = new BarRenderer(); DefaultCategoryDataset<String, String> dataset2 = new DefaultCategoryDataset<>(); p1.setDataset(1, dataset2); p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1); assertEquals(p1, p2);    CategoryAxis domainAxisA = p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); DefaultCategoryDataset<String, String> datasetA = (DefaultCategoryDataset) p2.getDataset(0); BarRenderer rendererA = (BarRenderer) p2.getRenderer(0); CategoryAxis domainAxisB = p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); DefaultCategoryDataset<String, String> datasetB = (DefaultCategoryDataset) p2.getDataset(1);",
        "ins1PreCode":"public void testSerialization5() { DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); CategoryAxis domainAxis1 = new CategoryAxis(\"Domain 1\"); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); BarRenderer renderer1 = new BarRenderer(); CategoryPlot p1 = new CategoryPlot(dataset1, domainAxis1, rangeAxis1, renderer1); CategoryAxis domainAxis2 = new CategoryAxis(\"Domain 2\"); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\"); BarRenderer renderer2 = new BarRenderer(); DefaultCategoryDataset dataset2 = new DefaultCategoryDataset(); p1.setDataset(1, dataset2); p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1); assertEquals(p1, p2);    CategoryAxis domainAxisA = p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); DefaultCategoryDataset datasetA = (DefaultCategoryDataset) p2.getDataset(0); BarRenderer rendererA = (BarRenderer) p2.getRenderer(0); CategoryAxis domainAxisB = p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); DefaultCategoryDataset datasetB = (DefaultCategoryDataset) p2.getDataset(1);",
        "ins2PreCode":"public void testSerialization5() { XYSeriesCollection dataset1 = new XYSeriesCollection(); NumberAxis domainAxis1 = new NumberAxis(\"Domain 1\"); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); StandardXYItemRenderer renderer1 = new StandardXYItemRenderer(); XYPlot p1 = new XYPlot(dataset1, domainAxis1, rangeAxis1, renderer1); NumberAxis domainAxis2 = new NumberAxis(\"Domain 2\"); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\"); StandardXYItemRenderer renderer2 = new StandardXYItemRenderer(); XYSeriesCollection dataset2 = new XYSeriesCollection(); p1.setDataset(1, dataset2); p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); XYPlot p2 = (XYPlot) TestUtils.serialised(p1); assertEquals(p1, p2);    NumberAxis domainAxisA = (NumberAxis) p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); XYSeriesCollection datasetA = (XYSeriesCollection) p2.getDataset(0); StandardXYItemRenderer rendererA = (StandardXYItemRenderer) p2.getRenderer(0); NumberAxis domainAxisB = (NumberAxis) p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); XYSeriesCollection datasetB = (XYSeriesCollection) p2.getDataset(1); StandardXYItemRenderer rendererB = (StandardXYItemRenderer) p2.getRenderer(1); assertTrue(datasetA.hasListener(p2)); assertTrue(domainAxisA.hasListener(p2)); assertTrue(rangeAxisA.hasListener(p2)); assertTrue(rendererA.hasListener(p2)); assertTrue(datasetB.hasListener(p2)); assertTrue(domainAxisB.hasListener(p2)); assertTrue(rangeAxisB.hasListener(p2)); assertTrue(rendererB.hasListener(p2));",
        "label":0
    },
    {
        "ins1CurCode":" try { v = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); assertThat(excludes(filter, SecurityFilterChain.class)).isTrue(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isTrue(); assertThat(excludes(filter, ExampleModule.class)).isTrue();",
        "ins2PreCode":"void matchNotUsingDefaultFilters() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(NotUsingDefaultFilters.class); assertThat(excludes(filter, Controller1.class)).isTrue(); assertThat(excludes(filter, Controller2.class)).isTrue(); assertThat(excludes(filter, ExampleControllerAdvice.class)).isTrue(); assertThat(excludes(filter, ExampleWeb.class)).isTrue(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isTrue(); assertThat(excludes(filter, ExampleModule.class)).isTrue();",
        "label":0
    },
    {
        "ins1CurCode":" try { FILE_UTILS.rename(newWLJarFile, weblogicJarFile); } catch (IOException renameException) {",
        "ins1PreCode":" try { fileUtils.rename(newWLJarFile, weblogicJarFile); } catch (IOException renameException) {",
        "ins2PreCode":" try { FileUtils.newFileUtils().rename(newwasJarFile, websphereJarFile); } catch (IOException renameException) {",
        "label":0
    },
    {
        "ins1CurCode":"return isNotEqualToJson((Resource) expected); } failWithMessage(\"Unsupport type for JSON assert {]\", expected.getClass()); return null;",
        "ins1PreCode":"return isNotEqualToJson((Resource) expected); } throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "ins2PreCode":"return isEqualToJson((Resource) expected); } throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "label":0
    },
    {
        "ins1CurCode":"testCrawler.performCrawl();  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\", \"ArXiv.bib\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\", \"Springer.bib\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"studyResult.bib\")));",
        "ins1PreCode":"testCrawler.performCrawl();  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"ArXiv.bib\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"Springer.bib\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"studyResult.bib\")));",
        "ins2PreCode":"void repositoryStructureCorrectlyCreated() throws Exception {  getTestStudyRepository();  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"Springer.bib\"))); assertTrue(Files.notExists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"IEEEXplore.bib\"))); assertTrue(Files.notExists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"IEEEXplore.bib\"))); assertTrue(Files.notExists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"IEEEXplore.bib\")));",
        "label":0
    },
    {
        "ins1CurCode":"p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); XYPlot p2 = (XYPlot) TestUtils.serialised(p1); assertEquals(p1, p2);",
        "ins1PreCode":"p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); XYPlot p2 = (XYPlot) TestUtilities.serialised(p1); assertEquals(p1, p2);",
        "ins2PreCode":"p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1CurCode":"public final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) { Objects.requireNonNull(onRequest, \"onRequest is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "ins1PreCode":"public final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) { ObjectHelper.requireNonNull(onRequest, \"onRequest is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "ins2PreCode":"public final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) { ObjectHelper.requireNonNull(onCancel, \"onCancel is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "label":1
    },
    {
        "ins1CurCode":"} if (result == null) { result = this.defaultStroke; }",
        "ins1PreCode":"} if (result == null) { result = this.baseStroke; }",
        "ins2PreCode":"} if (result == null) { result = this.baseOutlineStroke; }",
        "label":1
    },
    {
        "ins1CurCode":"protected void doStartTest1(String text) { reg.setPattern(\"^starttest\"); assertFalse(\"^starttest in default mode\", reg.matches(text)); assertFalse(\"^starttest in single line mode\", reg.matches(text, RegexpMatcher.MATCH_SINGLELINE)); assertTrue(\"^starttest in multi line mode\",",
        "ins1PreCode":"protected void doStartTest1(String text) { reg.setPattern(\"^starttest\"); assertTrue(\"^starttest in default mode\", !reg.matches(text)); assertTrue(\"^starttest in single line mode\", !reg.matches(text, RegexpMatcher.MATCH_SINGLELINE)); assertTrue(\"^starttest in multi line mode\",",
        "ins2PreCode":"protected void doEndTest1(String text) { reg.setPattern(\"endtest$\"); assertTrue(\"endtest$ in default mode\", !reg.matches(text)); assertTrue(\"endtest$ in single line mode\", !reg.matches(text, RegexpMatcher.MATCH_SINGLELINE)); assertTrue(\"endtest$ in multi line mode\",",
        "label":1
    },
    {
        "ins1CurCode":"public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<>(); } else { return new HashSet<>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<>(); } };  Single<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory);  Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<>(Arrays.asList(\"eee\"))); ",
        "ins1PreCode":"public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<String>(); } else { return new HashSet<String>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<Integer, Collection<String>>(); } };  Single<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\"))); ",
        "ins2PreCode":"public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<String>(); } else { return new HashSet<String>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<Integer, Collection<String>>(); } };  Single<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\"))); ",
        "label":1
    },
    {
        "ins1CurCode":"} if (hasValidData) { result = maximum; }",
        "ins1PreCode":"} if (hasValidData) { result = new Double(maximum); }",
        "ins2PreCode":"public static Number findMinimumStackedRangeValue(CategoryDataset dataset) { Args.nullNotPermitted(dataset, \"dataset\"); Number result = null; boolean hasValidData = false; double minimum = 0.0; int categoryCount = dataset.getColumnCount(); for (int item = 0; item < categoryCount; item++) { double total = 0.0; int seriesCount = dataset.getRowCount(); for (int series = 0; series < seriesCount; series++) { Number number = dataset.getValue(series, item); if (number != null) { hasValidData = true; double value = number.doubleValue(); if (value < 0.0) { total = total + value;  } } } minimum = Math.min(minimum, total); } if (hasValidData) { result = new Double(minimum); }",
        "label":1
    },
    {
        "ins1CurCode":".create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value()); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(5)); assertThat(this.registry.get(\"http.client.requests\")",
        "ins1PreCode":".create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value()); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\")",
        "ins2PreCode":".attribute(URI_TEMPLATE_ATTRIBUTE, \"/projects/{project}\").build(); given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value()); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\")",
        "label":1
    },
    {
        "ins1CurCode":"final ConnectableFlowable<Integer> cf = pp.replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<>(); ",
        "ins1PreCode":"final ConnectableFlowable<Integer> cf = pp.replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"final ConnectableFlowable<Integer> cf = pp.replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertNull(target.get(\"build\"));  assertNull(target.get(\"os\")); ",
        "ins1PreCode":"assertNull(target.get(\"build\"));  assertThat(target.get(\"os\"), is(\"Other\")); assertThat(target.get(\"os_name\"), is(\"Other\")); assertNull(target.get(\"os_major\")); assertNull(target.get(\"os_minor\")); ",
        "ins2PreCode":" assertThat(target.get(\"name\"), is(\"EasouSpider\")); assertNull(target.get(\"major\")); assertNull(target.get(\"minor\")); assertNull(target.get(\"patch\")); assertNull(target.get(\"build\"));  assertThat(target.get(\"os\"), is(\"Other\")); assertThat(target.get(\"os_name\"), is(\"Other\")); assertNull(target.get(\"os_major\")); assertNull(target.get(\"os_minor\")); ",
        "label":0
    },
    {
        "ins1CurCode":"upstream.dispose(); set.dispose(); errors.tryTerminateConsumer(downstream); }",
        "ins1PreCode":"upstream.dispose(); set.dispose(); if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream);",
        "ins2PreCode":"upstream.dispose(); set.dispose(); if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream);",
        "label":1
    },
    {
        "ins1CurCode":"void basicAdd() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\");",
        "ins1PreCode":"public void basicAdd() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\");",
        "ins2PreCode":"public void nonTransitiveAdd() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\", false);",
        "label":1
    },
    {
        "ins1CurCode":"void parseRecognizesHeaderButIgnoresEncoding() throws IOException { ParserResult result = parser.parse(new StringReader(\"This file was created with JabRef 2.1 beta 2.\" + \"\\n\"",
        "ins1PreCode":"public void parseRecognizesHeaderButIgnoresEncoding() throws IOException { ParserResult result = parser.parse(new StringReader(\"This file was created with JabRef 2.1 beta 2.\" + \"\\n\"",
        "ins2PreCode":"public void parseRecognizesFormatedEntry() throws IOException { ParserResult result = parser.parse(",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"Misc/test.pdf\", \"\"))), entry.getField(StandardField.FILE)); assertFalse(Files.exists(fileBefore));",
        "ins1PreCode":"assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"Misc/test.pdf\", \"\"))), entry.getField(\"file\")); assertFalse(Files.exists(fileBefore));",
        "ins2PreCode":"assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"Misc/1989/test.pdf\", \"\"))), entry.getField(\"file\")); assertFalse(Files.exists(fileBefore));",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribe(Subscriber<? super R>[] subscribers) { subscribers = RxJavaPlugins.onSubscribe(this, subscribers); ",
        "ins1PreCode":"public void subscribe(Subscriber<? super R>[] subscribers) { if (!validate(subscribers)) { return;",
        "ins2PreCode":"public void subscribe(Subscriber<? super R>[] subscribers) { if (!validate(subscribers)) { return;",
        "label":1
    },
    {
        "ins1CurCode":"void defaultSnippetsAreWritten() throws Exception { this.mvc.perform(get(\"/\")).andDo(document(\"default-snippets\"));",
        "ins1PreCode":"public void defaultSnippetsAreWritten() throws Exception { this.mvc.perform(get(\"/\")).andDo(document(\"default-snippets\"));",
        "ins2PreCode":"public void defaultSnippetsAreWritten() throws Exception { this.webTestClient.get().uri(\"/\").exchange().expectStatus().is2xxSuccessful().expectBody()",
        "label":1
    },
    {
        "ins1CurCode":"public void testPoolThreads10Connections10Fair() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true);",
        "ins1PreCode":"public void testPoolThreads10Connections10Fair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testDBCPThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":"public void customBeanNameGenerator() { TestSpringApplication application = new TestSpringApplication(",
        "ins1PreCode":"public void customBeanNameGenerator() throws Exception { TestSpringApplication application = new TestSpringApplication(",
        "ins2PreCode":"public void customBeanNameGeneratorWithNonWebApplication() throws Exception { TestSpringApplication application = new TestSpringApplication(",
        "label":1
    },
    {
        "ins1CurCode":"protected void insertIntoEntryTable(List<BibEntry> bibEntries) { StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\");  for (int i = 0; i < bibEntries.size() - 1; i++) { insertIntoEntryQuery.append(\", (?)\"); }  try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery.toString(), new String[]{\"SHARED_ID\"})) { for (int i = 0; i < bibEntries.size(); i++) { preparedEntryStatement.setString(i + 1, bibEntries.get(i).getType().getName()); } preparedEntryStatement.executeUpdate();  try (ResultSet generatedKeys = preparedEntryStatement.getGeneratedKeys()) {   for (BibEntry bibEntry : bibEntries) { generatedKeys.next(); bibEntry.getSharedBibEntryData().setSharedID(generatedKeys.getInt(1)); } if (generatedKeys.next()) { LOGGER.error(\"Error: Some shared IDs left unassigned\"); }",
        "ins1PreCode":"protected void insertIntoEntryTable(BibEntry bibEntry) {  String insertIntoEntryQuery = \"INSERT INTO \" + escape(\"ENTRY\") + \"(\" + escape(\"TYPE\") + \") VALUES(?)\";  try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery, new String[]{\"SHARED_ID\"})) {  preparedEntryStatement.setString(1, bibEntry.getType().getName()); preparedEntryStatement.executeUpdate();",
        "ins2PreCode":"protected void insertIntoEntryTable(BibEntry bibEntry) {  StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\");   try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery.toString(), Statement.RETURN_GENERATED_KEYS)) {  preparedEntryStatement.setString(1, bibEntry.getType().getName()); preparedEntryStatement.executeUpdate();",
        "label":0
    },
    {
        "ins1CurCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createScatterPlot(\"Scatter Plot\", \"Domain\",",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createScatterPlot(\"Scatter Plot\", \"Domain\",",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"void constructorParameterSimpleProperty() throws IOException { process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void constructorParameterSimpleProperty() throws IOException { process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokSimpleProperty() throws IOException { process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"int offset, int length) { for (int i = 0; i < length; i++) { if (buffers[offset + i].hasRemaining()) { return CompletionHandlerCall.CONTINUE;",
        "ins1PreCode":"int offset, int length) { for (int i = 0; i < length; i++) { if (buffers[offset + i].remaining() > 0) { return CompletionHandlerCall.CONTINUE;",
        "ins2PreCode":"int offset, int length) { for (int i = 0; i < length; i++) { if (buffers[offset + i].remaining() > 0) { return CompletionHandlerCall.CONTINUE;",
        "label":1
    },
    {
        "ins1CurCode":"Flowable<Long> w = Flowable.interval(1, TimeUnit.SECONDS, scheduler);  TestSubscriber<Long> ts1 = new TestSubscriber<>();  w.subscribe(ts1);  ts1.assertNoErrors();  scheduler.advanceTimeTo(2, TimeUnit.SECONDS);  TestSubscriber<Long> ts2 = new TestSubscriber<>(); ",
        "ins1PreCode":"Flowable<Long> w = Flowable.interval(1, TimeUnit.SECONDS, scheduler);  TestSubscriber<Long> ts1 = new TestSubscriber<Long>();  w.subscribe(ts1);  ts1.assertNoErrors();  scheduler.advanceTimeTo(2, TimeUnit.SECONDS);  TestSubscriber<Long> ts2 = new TestSubscriber<Long>(); ",
        "ins2PreCode":"ConnectableFlowable<Long> w = Flowable.interval(1, TimeUnit.SECONDS, scheduler).publish();  TestSubscriber<Long> ts1 = new TestSubscriber<Long>();  w.subscribe(ts1); w.connect();  ts1.assertNoValues();  scheduler.advanceTimeTo(2, TimeUnit.SECONDS);  TestSubscriber<Long> ts2 = new TestSubscriber<Long>(); w.subscribe(ts2);",
        "label":1
    },
    {
        "ins1CurCode":"final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<>(); final TestSubscriber<Integer> ts2 = new TestSubscriber<>(); ",
        "ins1PreCode":"final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); final TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); final TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void blockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<>(); ",
        "ins1PreCode":"public void blockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>(); ",
        "ins2PreCode":"public void blockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(properties.getPort()).isEqualTo(config.port()); assertThat(properties.getProtocol()).isEqualTo(config.protocol()); assertThat(properties.isGraphiteTagsEnabled()).isEqualTo(config.graphiteTagsEnabled()); assertThat(properties.getTagsAsPrefix()).isEqualTo(config.tagsAsPrefix());",
        "ins1PreCode":"assertThat(properties.getPort()).isEqualTo(config.port()); assertThat(properties.getProtocol()).isEqualTo(config.protocol()); assertThat(properties.getTagsAsPrefix()).isEqualTo(config.tagsAsPrefix());",
        "ins2PreCode":"void defaultValuesAreConsistent() { GangliaProperties properties = new GangliaProperties(); GangliaConfig config = GangliaConfig.DEFAULT; assertThat(properties.isEnabled()).isEqualTo(config.enabled()); assertThat(properties.getStep()).isEqualTo(config.step()); assertThat(properties.getRateUnits()).isEqualTo(config.rateUnits()); assertThat(properties.getDurationUnits()).isEqualTo(config.durationUnits()); assertThat(properties.getProtocolVersion()).isEqualTo(config.protocolVersion()); assertThat(properties.getAddressingMode()).isEqualTo(config.addressingMode()); assertThat(properties.getTimeToLive()).isEqualTo(config.ttl()); assertThat(properties.getHost()).isEqualTo(config.host()); assertThat(properties.getPort()).isEqualTo(config.port());",
        "label":0
    },
    {
        "ins1CurCode":"final PublishProcessor<Integer> pp = PublishProcessor.create();  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"final PublishProcessor<Integer> pp = PublishProcessor.create();  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"final PublishProcessor<Integer> pp = PublishProcessor.create();  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"StringBuilder sb = new StringBuilder(); int windowStart = -s.length(); if (timeout == null || timeout == 0) { while (windowStart < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); windowStart++; } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout); while (windowStart < 0",
        "ins1PreCode":"StringBuilder sb = new StringBuilder(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); windowStart++; } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart < 0",
        "ins2PreCode":"StringBuilder sb = new StringBuilder(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); windowStart++; } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart < 0",
        "label":1
    },
    {
        "ins1CurCode":"void bindToCollectionWithDefaultConstructor() { ",
        "ins1PreCode":"public void bindToCollectionWithDefaultConstructor() { ",
        "ins2PreCode":"public void bindToListShouldAllowDuplicateValues() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) { logger.error(\"--> Unexpected successful request [{}]\", FakeRestRequest.requestToString(request)); throw new AssertionError();",
        "ins1PreCode":"@Override public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) { throw new AssertionError(); }",
        "ins2PreCode":"@Override public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) { throw new AssertionError(); }",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull R> Maybe<R> zip( @NonNull MaybeSource<? extends T1> source1, @NonNull MaybeSource<? extends T2> source2, @NonNull MaybeSource<? extends T3> source3,",
        "ins1PreCode":"public static <T1, T2, T3, T4, T5, T6, R> Maybe<R> zip( @NonNull MaybeSource<? extends T1> source1, @NonNull MaybeSource<? extends T2> source2, @NonNull MaybeSource<? extends T3> source3,",
        "ins2PreCode":"public static <T1, T2, T3, T4, T5, T6, R> Single<R> zip( @NonNull SingleSource<? extends T1> source1, @NonNull SingleSource<? extends T2> source2,",
        "label":1
    },
    {
        "ins1CurCode":"int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation  = sendfile.stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation, true); } catch (IOException e) {",
        "ins1PreCode":"int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation  = sendfile.stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation); } catch (IOException e) {",
        "ins2PreCode":"sendfile.streamReservation = sendfile.stream.reserveWindowSize(reservation, true); } sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation); }",
        "label":1
    },
    {
        "ins1CurCode":"StandardPieSectionLabelGenerator g1 = new StandardPieSectionLabelGenerator(); StandardPieSectionLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"StandardPieSectionLabelGenerator g1 = new StandardPieSectionLabelGenerator(); StandardPieSectionLabelGenerator g2 = (StandardPieSectionLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"public void removeNode_antiparallelEdges() { assume().that(graphIsMutable()).isTrue();  putEdge(N1, N2); putEdge(N2, N1);  assertThat(graphAsMutableGraph.removeNode(N1)).isTrue(); assertThat(graph.nodes()).containsExactly(N2); assertThat(graph.edges()).isEmpty();  assertThat(graphAsMutableGraph.removeNode(N2)).isTrue(); assertThat(graph.nodes()).isEmpty();",
        "ins1PreCode":"putEdge(N2, N1);  assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.nodes()).containsExactly(N2); assertThat(graph.edges()).isEmpty();  assertThat(graph.removeNode(N2)).isTrue(); assertThat(graph.nodes()).isEmpty();",
        "ins2PreCode":"putEdge(N2, N1);  assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.nodes()).containsExactly(N2); assertThat(graph.edges()).isEmpty();  assertThat(graph.removeNode(N2)).isTrue(); assertThat(graph.nodes()).isEmpty();",
        "label":1
    },
    {
        "ins1CurCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "ins1PreCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "ins2PreCode":"public void draggedOnBottomOfGroupAddsAfterItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "label":1
    },
    {
        "ins1CurCode":" if (figNode != null) { LOG.log(Level.FINE, \"Model element {0} converted to {1}\", new Object[]{modelElement, figNode}); } else { LOG.log(Level.FINE, \"Dropped object NOT added {0}\", figNode); }",
        "ins1PreCode":" if (figNode != null) { LOG.debug(\"Model element \" + modelElement + \" converted to \" + figNode); } else { LOG.debug(\"Dropped object NOT added \" + figNode); }",
        "ins2PreCode":"public DiagramElement createDiagramElement( final Object modelElement, final Rectangle bounds) {  FigNodeModelElement figNode = null;  DiagramSettings settings = getDiagramSettings();  if (Model.getFacade().isANode(modelElement)) { figNode = new FigNode(modelElement, bounds, settings); } else if (Model.getFacade().isAPort(modelElement)) { figNode = new FigPort(modelElement, bounds, settings); } else if (Model.getFacade().isAAssociation(modelElement)) { figNode = createNaryAssociationNode(modelElement, bounds, settings); } else if (Model.getFacade().isAComponent(modelElement)) { figNode = new FigComponent(modelElement, bounds, settings); } else if (Model.getFacade().isAClass(modelElement)) { figNode = new FigClass(modelElement, bounds, settings); } else if (Model.getFacade().isAInterface(modelElement)) { figNode = new FigInterface(modelElement, bounds, settings); } else if (Model.getFacade().isAObject(modelElement)) { figNode = new FigObject(modelElement, bounds, settings); } else if (Model.getFacade().isAActor(modelElement)) { figNode = new FigActor(modelElement, bounds, settings); } else if (Model.getFacade().isAComment(modelElement)) { figNode = new FigComment(modelElement, bounds, settings); } return figNode;",
        "label":0
    },
    {
        "ins1CurCode":"public void autoConfiguresTomcatMetricsWithEmbeddedServletTomcat() { resetTomcatState(); new WebApplicationContextRunner( AnnotationConfigServletWebServerApplicationContext::new) .withConfiguration(AutoConfigurations.of( TomcatMetricsAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class)) .withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class) .withPropertyValues(\"server.tomcat.mbeanregistry.enabled=true\") .run((context) -> {",
        "ins1PreCode":"public void autoConfiguresTomcatMetricsWithEmbeddedServletTomcat() { new WebApplicationContextRunner( AnnotationConfigServletWebServerApplicationContext::new) .withConfiguration(AutoConfigurations.of( TomcatMetricsAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class)) .withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class) .run((context) -> { context.publishEvent( new ApplicationStartedEvent(new SpringApplication(),",
        "ins2PreCode":"public void autoConfiguresTomcatMetricsWithEmbeddedReactiveTomcat() { new ReactiveWebApplicationContextRunner( AnnotationConfigReactiveWebServerApplicationContext::new) .withConfiguration(AutoConfigurations.of( TomcatMetricsAutoConfiguration.class, ReactiveWebServerFactoryAutoConfiguration.class)) .withUserConfiguration(ReactiveWebServerConfiguration.class, MeterRegistryConfiguration.class) .run((context) -> { context.publishEvent( new ApplicationStartedEvent(new SpringApplication(),",
        "label":1
    },
    {
        "ins1CurCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins1PreCode":"else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins2PreCode":"else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "label":1
    },
    {
        "ins1CurCode":"public void testEquals() { XIntervalSeries<String> s1 = new XIntervalSeries<>(\"s1\"); XIntervalSeries<String> s2 = new XIntervalSeries<>(\"s1\"); assertTrue(s1.equals(s2));   s1 = new XIntervalSeries<>(\"s2\"); assertFalse(s1.equals(s2)); s2 = new XIntervalSeries<>(\"s2\"); assertTrue(s1.equals(s2));   s1 = new XIntervalSeries<>(\"s2\", false, true); assertFalse(s1.equals(s2)); s2 = new XIntervalSeries<>(\"s2\", false, true); assertTrue(s1.equals(s2));   s1 = new XIntervalSeries<>(\"s2\", false, false); assertFalse(s1.equals(s2)); s2 = new XIntervalSeries<>(\"s2\", false, false); assertTrue(s1.equals(s2));",
        "ins1PreCode":"public void testEquals() { XIntervalSeries s1 = new XIntervalSeries(\"s1\"); XIntervalSeries s2 = new XIntervalSeries(\"s1\"); assertTrue(s1.equals(s2));   s1 = new XIntervalSeries(\"s2\"); assertFalse(s1.equals(s2)); s2 = new XIntervalSeries(\"s2\"); assertTrue(s1.equals(s2));   s1 = new XIntervalSeries(\"s2\", false, true); assertFalse(s1.equals(s2)); s2 = new XIntervalSeries(\"s2\", false, true); assertTrue(s1.equals(s2));   s1 = new XIntervalSeries(\"s2\", false, false); assertFalse(s1.equals(s2)); s2 = new XIntervalSeries(\"s2\", false, false); assertTrue(s1.equals(s2));",
        "ins2PreCode":"public void testEquals() { XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); XYIntervalSeries s2 = new XYIntervalSeries(\"s1\"); assertTrue(s1.equals(s2));   s1 = new XYIntervalSeries(\"s2\"); assertFalse(s1.equals(s2)); s2 = new XYIntervalSeries(\"s2\"); assertTrue(s1.equals(s2));   s1 = new XYIntervalSeries(\"s2\", false, true); assertFalse(s1.equals(s2)); s2 = new XYIntervalSeries(\"s2\", false, true); assertTrue(s1.equals(s2));   s1 = new XYIntervalSeries(\"s2\", false, false); assertFalse(s1.equals(s2)); s2 = new XYIntervalSeries(\"s2\", false, false); assertTrue(s1.equals(s2));",
        "label":1
    },
    {
        "ins1CurCode":"void testPropertyContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testPropertyContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testParametersInAttribute() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"FreeStyleBuild b = p.scheduleBuild2(0).get();  assertEquals(\"Build must fail, because we used AbortExceptionPublisher\", Result.FAILURE, b.getResult()); j.assertLogNotContains(\"\\tat\", b);",
        "ins1PreCode":"FreeStyleBuild b = p.scheduleBuild2(0).get();  assertEquals(\"Build must fail, because we used AbortExceptionPublisher\", b.getResult(), Result.FAILURE); j.assertLogNotContains(\"\\tat\", b);",
        "ins2PreCode":"FreeStyleBuild b = p.scheduleBuild2(0).get();  assertEquals(\"Build must fail, because we used FalsePublisher\", b.getResult(), Result.FAILURE); j.assertLogContains(\"\\tat hudson.model.utils.IOExceptionPublisher\", b);",
        "label":1
    },
    {
        "ins1CurCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  TestObservable<String> o1 = new TestObservable<>(\"one\", \"two\", \"three\"); TestObservable<String> o2 = new TestObservable<>(\"four\", \"five\", \"six\"); ",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  TestObservable<String> o1 = new TestObservable<String>(\"one\", \"two\", \"three\"); TestObservable<String> o2 = new TestObservable<String>(\"four\", \"five\", \"six\"); ",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver();  TestObservable<String> o1 = new TestObservable<String>(\"one\", \"two\", \"three\"); TestObservable<String> o2 = new TestObservable<String>(\"four\", \"five\", \"six\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void predecessors_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N2);",
        "ins1PreCode":"public void predecessors_checkReturnedSetMutability() { addNode(N2); Set<Integer> predecessors = network.predecessors(N2); try {",
        "ins2PreCode":"public void predecessors_checkReturnedSetMutability() { addNode(N2); Set<Integer> predecessors = network.predecessors(N2); try { predecessors.add(N1); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors); }",
        "label":0
    },
    {
        "ins1CurCode":"}  else if ( EXTERNAL_HTTP_WILDCARD.equals( repo ) && isExternalHttpRepo( originalRepository ) ) {",
        "ins1PreCode":"} else if ( WILDCARD.equals( repo ) ) { result = true;",
        "ins2PreCode":"} else if ( WILDCARD.equals( repo ) ) { result = true;",
        "label":1
    },
    {
        "ins1CurCode":"public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) { List<NodePropertyDescriptor> result = new ArrayList<>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);",
        "ins1PreCode":"public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);",
        "ins2PreCode":"public static List<NodePropertyDescriptor> getGlobalNodePropertyDescriptors() { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);",
        "label":1
    },
    {
        "ins1CurCode":".take(1000) .subscribeOn(Schedulers.io()); FlowableCache<Long> cached = new FlowableCache<>(source, 16);  Flowable<Long> output = cached.observeOn(Schedulers.computation());  List<TestSubscriber<Long>> list = new ArrayList<>(100); for (int i = 0; i < 100; i++) { TestSubscriber<Long> ts = new TestSubscriber<>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<>(); for (int i = 0; i < 10; i++) {",
        "ins1PreCode":".take(1000) .subscribeOn(Schedulers.io()); FlowableCache<Long> cached = new FlowableCache<Long>(source, 16);  Flowable<Long> output = cached.observeOn(Schedulers.computation());  List<TestSubscriber<Long>> list = new ArrayList<TestSubscriber<Long>>(100); for (int i = 0; i < 100; i++) { TestSubscriber<Long> ts = new TestSubscriber<Long>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) {",
        "ins2PreCode":".take(1000) .subscribeOn(Schedulers.io()); ObservableCache<Long> cached = new ObservableCache<Long>(source, 16);  Observable<Long> output = cached.observeOn(Schedulers.computation());  List<TestObserver<Long>> list = new ArrayList<TestObserver<Long>>(100); for (int i = 0; i < 100; i++) { TestObserver<Long> to = new TestObserver<Long>(); list.add(to); output.skip(i * 10).take(10).subscribe(to); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists()); ",
        "ins1PreCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { assertTrue(\"Expected file \" + result + \" doesn\\'t exist\", result.exists()); ",
        "ins2PreCode":"public void assertEqualContent(File expect, File result) throws IOException { assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists());  try (InputStream inExpect = new BufferedInputStream(Files.newInputStream(expect.toPath())); InputStream inResult = new BufferedInputStream(Files.newInputStream(result.toPath()))) { int expectedByte = inExpect.read(); while (expectedByte != -1) { assertEquals(expectedByte, inResult.read()); expectedByte = inExpect.read(); } assertEquals(\"End of file\", -1, inResult.read()); }",
        "label":0
    },
    {
        "ins1CurCode":"void shouldGetReadablePropertyNames() { RichType rich = new RichType();",
        "ins1PreCode":"public void shouldGetReadablePropertyNames() { RichType rich = new RichType();",
        "ins2PreCode":"public void shouldGetWriteablePropertyNames() { RichType rich = new RichType();",
        "label":1
    },
    {
        "ins1CurCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = newRuns(1, 10); ",
        "ins1PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "ins2PreCode":"public void test_newerThan_near_newest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 8L, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1CurCode":"Minute m = new Minute(1, 2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-614962680001L, m.getLastMillisecond(cal));   boolean pass = false; try { m.getLastMillisecond((Calendar) null); }",
        "ins1PreCode":"Minute m = new Minute(1, 2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-614962680001L, m.getLastMillisecond(zone));   boolean pass = false; try { m.getLastMillisecond((TimeZone) null); }",
        "ins2PreCode":"Millisecond m = new Millisecond(500, 50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-623289609500L, m.getFirstMillisecond(zone));   boolean pass = false; try { m.getFirstMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"return; } Collection<Marker> markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { for (Marker marker : markers) { r.drawRangeMarker(g2, this, axis, marker, dataArea);",
        "ins1PreCode":"return; } Collection markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next(); r.drawRangeMarker(g2, this, axis, marker, dataArea);",
        "ins2PreCode":"protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {  CategoryItemRenderer r = getRenderer(index); if (r == null) { return; }  Collection<Marker> markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { Iterator<Marker> iterator = markers.iterator(); while (iterator.hasNext()) { CategoryMarker marker = (CategoryMarker) iterator.next(); r.drawDomainMarker(g2, this, axis, marker, dataArea); } } ",
        "label":0
    },
    {
        "ins1CurCode":"protected void customizeConnector(Connector connector) { int port = (getPort() >= 0) ? getPort() : 0; connector.setPort(port);",
        "ins1PreCode":"protected void customizeConnector(Connector connector) { int port = (getPort() >= 0 ? getPort() : 0); connector.setPort(port);",
        "ins2PreCode":"protected void customizeConnector(Connector connector) { int port = (getPort() >= 0 ? getPort() : 0); connector.setPort(port);",
        "label":1
    },
    {
        "ins1CurCode":"public void onNext(T t) { if (done || emitter.isDisposed()) { return;",
        "ins1PreCode":"public void onNext(T t) { if (emitter.isDisposed() || done) { return;",
        "ins2PreCode":"public void onNext(T t) { if (emitter.isCancelled() || done) { return; } if (t == null) { onError(ExceptionHelper.createNullPointerException(\"onNext called with a null value.\")); return; } if (get() == 0 && compareAndSet(0, 1)) { emitter.onNext(t); if (decrementAndGet() == 0) { return; } } else { SimplePlainQueue<T> q = queue; synchronized (q) { q.offer(t); } if (getAndIncrement() != 0) { return; } } drainLoop();",
        "label":0
    },
    {
        "ins1CurCode":"return false; } if (!Objects.equals(this.arrowStroke, that.arrowStroke)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtils.equal(this.arrowStroke, that.arrowStroke)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtils.equal(this.arrowStroke, that.arrowStroke)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(parseScript(o))); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue())); ",
        "ins1PreCode":"consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(parseScript(o)));  parseInternalRequest(internal, request, consumers);",
        "ins2PreCode":"Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o));  parseInternalRequest(internal, request, consumers);",
        "label":1
    },
    {
        "ins1CurCode":" Person person = persons.get(0); Assertions.assertEquals(\"grandma\", person.getName()); Assertions.assertTrue(person.owns(\"book\")); Assertions.assertTrue(person.owns(\"tv\")); Assertions.assertEquals(2, person.getItems().size());  person = persons.get(1); Assertions.assertEquals(\"sister\", person.getName()); Assertions.assertTrue(person.owns(\"phone\")); Assertions.assertTrue(person.owns(\"shoes\")); Assertions.assertEquals(2, person.getItems().size());  person = persons.get(2); Assertions.assertEquals(\"brother\", person.getName()); Assertions.assertTrue(person.owns(\"car\")); Assertions.assertEquals(1, person.getItems().size()); }",
        "ins1PreCode":" Person person = persons.get(0); Assert.assertEquals(\"grandma\", person.getName()); Assert.assertTrue(person.owns(\"book\")); Assert.assertTrue(person.owns(\"tv\")); Assert.assertEquals(2, person.getItems().size());  person = persons.get(1); Assert.assertEquals(\"sister\", person.getName()); Assert.assertTrue(person.owns(\"phone\")); Assert.assertTrue(person.owns(\"shoes\")); Assert.assertEquals(2, person.getItems().size());  person = persons.get(2); Assert.assertEquals(\"brother\", person.getName()); Assert.assertTrue(person.owns(\"car\")); Assert.assertEquals(1, person.getItems().size()); }",
        "ins2PreCode":" Person person = persons.get(0); Assert.assertEquals(\"grandma\", person.getName()); Assert.assertTrue(person.owns(\"book\")); Assert.assertTrue(person.owns(\"tv\")); Assert.assertEquals(2, person.getItems().size());  person = persons.get(1); Assert.assertEquals(\"brother\", person.getName()); Assert.assertTrue(person.owns(\"car\")); Assert.assertEquals(1, person.getItems().size());  person = persons.get(2); Assert.assertEquals(\"sister\", person.getName()); Assert.assertTrue(person.owns(\"phone\")); Assert.assertTrue(person.owns(\"shoes\")); Assert.assertEquals(2, person.getItems().size()); }",
        "label":1
    },
    {
        "ins1CurCode":"Hour h = new Hour(15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-623293200000L, h.getFirstMillisecond(cal));   boolean pass = false; try { h.getFirstMillisecond((Calendar) null); }",
        "ins1PreCode":"Hour h = new Hour(15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-623293200000L, h.getFirstMillisecond(zone));   boolean pass = false; try { h.getFirstMillisecond((TimeZone) null); }",
        "ins2PreCode":"Hour h = new Hour(2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-614959200001L, h.getLastMillisecond(zone));   boolean pass = false; try { h.getLastMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"rs.onComplete();  TestSubscriber<Integer> ts = new TestSubscriber<>(0L); ",
        "ins1PreCode":"rs.onComplete();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "ins2PreCode":"rs.onComplete();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { PomTestWrapper pom = buildPom( \"dependency-order/wo-plugin-mgmt\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() );",
        "ins1PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"dependency-order/wo-plugin-mngt\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() );",
        "ins2PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"dependency-order/w-plugin-mngt\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() );",
        "label":1
    },
    {
        "ins1CurCode":"public void testInsertAnnotated() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { InsertMapper mapper = sqlSession.getMapper(InsertMapper.class);",
        "ins1PreCode":"public void testInsertAnnotated() throws Exception { Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/keycolumn/MapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = sqlSessionFactory.openSession(); try { InsertMapper mapper = sqlSession.getMapper(InsertMapper.class); Name name = new Name(); name.setFirstName(\"Fred\"); name.setLastName(\"Flintstone\");  int rows = mapper.insertNameAnnotated(name);  assertNotNull(name.getId()); assertEquals(1, rows); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertMapped() throws Exception { Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/keycolumn/MapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = sqlSessionFactory.openSession(); try { InsertMapper mapper = sqlSession.getMapper(InsertMapper.class); Name name = new Name(); name.setFirstName(\"Fred\"); name.setLastName(\"Flintstone\");  int rows = mapper.insertNameMapped(name);  assertNotNull(name.getId()); assertEquals(1, rows); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void edgesConnecting_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting); }",
        "ins1PreCode":"public void edgesConnecting_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  assume().that(graphIsMutable()).isTrue();  addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting); }",
        "ins2PreCode":"public void edgesConnecting_checkReturnedSetMutability() { addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting); }",
        "label":0
    },
    {
        "ins1CurCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset<String> d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testEquals() { DefaultBoxAndWhiskerXYDataset<String> d1 = new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); DefaultBoxAndWhiskerXYDataset<String> d2 = new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); assertTrue(d1.equals(d2));  d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); assertFalse(d1.equals(d2)); d2.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); assertTrue(d1.equals(d2));",
        "label":0
    },
    {
        "ins1CurCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc);  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"a\");",
        "ins1PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "ins2PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\");",
        "label":1
    },
    {
        "ins1CurCode":"final ConcurrentHashMap<K, Collection<V>> result = new ConcurrentHashMap<K, Collection<V>>();  observable.doOnNext(new Consumer<GroupedObservable<K, V>>() {  @Override public void accept(final GroupedObservable<K, V> o) { result.put(o.getKey(), new ConcurrentLinkedQueue<V>()); o.subscribe(new Consumer<V>() {  @Override public void accept(V v) { result.get(o.getKey()).add(v); }  }); } }).blockingSubscribe(); ",
        "ins1PreCode":"final ConcurrentHashMap<K, Collection<V>> result = new ConcurrentHashMap<K, Collection<V>>();  observable.blockingForEach(new Consumer<GroupedObservable<K, V>>() { ",
        "ins2PreCode":"final ConcurrentHashMap<K, Collection<V>> result = new ConcurrentHashMap<K, Collection<V>>();  flowable.blockingForEach(new Consumer<GroupedFlowable<K, V>>() { ",
        "label":1
    },
    {
        "ins1CurCode":"  Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\");   KMeans kmeans = new KMeans().setK(2).setSeed(1L); KMeansModel model = kmeans.fit(dataset);   double WSSSE = model.computeCost(dataset); System.out.println(\"Within Set Sum of Squared Errors = \" + WSSSE); ",
        "ins1PreCode":"public static void main(String[] args) { if (args.length != 2) { System.err.println(\"Usage: ml.JavaKMeansExample <file> <k>\"); System.exit(1); } String inputFile = args[0]; int k = Integer.parseInt(args[1]);   SparkSession spark = SparkSession .builder() .appName(\"JavaKMeansExample\") .getOrCreate();    JavaRDD<Row> points = spark.read().text(inputFile).javaRDD().map(new ParsePoint()); StructField[] fields = {new StructField(\"features\", new VectorUDT(), false, Metadata.empty())}; StructType schema = new StructType(fields); Dataset<Row> dataset = spark.createDataFrame(points, schema);   KMeans kmeans = new KMeans() .setK(k); KMeansModel model = kmeans.fit(dataset);",
        "ins2PreCode":"public static void main(String[] args) { SparkSession spark = SparkSession .builder() .appName(\"JavaBisectingKMeansExample\") .getOrCreate();    Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\");   BisectingKMeans bkm = new BisectingKMeans().setK(2).setSeed(1); BisectingKMeansModel model = bkm.fit(dataset);   double cost = model.computeCost(dataset); System.out.println(\"Within Set Sum of Squared Errors = \" + cost);   System.out.println(\"Cluster Centers: \"); Vector[] centers = model.clusterCenters(); for (Vector center : centers) { System.out.println(center); }   spark.stop();",
        "label":0
    },
    {
        "ins1CurCode":"for(ExasolConnectionGrant grant: this.dataSource.getConnectionGrants(monitor)) { if (grant.getGrantee().equals(this.getName())) conGrants.add(grant);",
        "ins1PreCode":"for(ExasolConnectionGrant grant: this.dataSource.getConnectionGrants(monitor)) { if (grant.getName().equals(this.getName())) conGrants.add(grant);",
        "ins2PreCode":"for (ExasolRoleGrant grant: this.dataSource.getRoleGrants(monitor)) { if (grant.getName().equals(this.getName())) roleGrants.add(grant);",
        "label":1
    },
    {
        "ins1CurCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"TestObserver<Integer> to = TestObserver.create();  to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"void propertySourceAnnotationMultipleLocations() { SpringApplication application = new SpringApplication(WithPropertySourceMultipleLocations.class);",
        "ins1PreCode":"public void propertySourceAnnotationMultipleLocations() { SpringApplication application = new SpringApplication(WithPropertySourceMultipleLocations.class);",
        "ins2PreCode":"public void propertySourceAnnotationMultipleLocationsAndName() { SpringApplication application = new SpringApplication(WithPropertySourceMultipleLocationsAndName.class);",
        "label":1
    },
    {
        "ins1CurCode":"Statement stmt = mock(Statement.class); when(conn.createStatement()).thenReturn(stmt); when(stmt.getUpdateCount()).thenReturn(-1); ScriptRunner runner = new ScriptRunner(conn);",
        "ins1PreCode":"Statement stmt = mock(Statement.class); when(conn.createStatement()).thenReturn(stmt); ScriptRunner runner = new ScriptRunner(conn); ",
        "ins2PreCode":"Statement stmt = mock(Statement.class); when(conn.createStatement()).thenReturn(stmt); ScriptRunner runner = new ScriptRunner(conn); ",
        "label":1
    },
    {
        "ins1CurCode":"public void normal() { final TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void normal() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void normal() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; Arrays.setAll(listeners, i -> mock(TomcatContextCustomizer.class)); factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins1PreCode":"TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatContextCustomizer.class); }",
        "ins2PreCode":"TomcatReactiveWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(LifecycleListener.class); }",
        "label":1
    },
    {
        "ins1CurCode":"private void validateLifetime(final PooledObject<PooledConnectionAndInfo> p) throws Exception { if (maxConnLifetimeMillis > 0) { final long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) {",
        "ins1PreCode":"private void validateLifetime(PooledObject<PooledConnectionAndInfo> p) throws Exception { if (maxConnLifetimeMillis > 0) { long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) {",
        "ins2PreCode":"private void validateLifetime(PooledObject<PooledConnectionAndInfo> p) throws Exception { if (maxConnLifetimeMillis > 0) { long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) {",
        "label":1
    },
    {
        "ins1CurCode":"public Class<?> getType(ELContext context) throws NullPointerException, PropertyNotFoundException, ELException { context.notifyBeforeEvaluation(getExpressionString()); try { Class<?> result = this.target.getType(context); context.notifyAfterEvaluation(getExpressionString()); return result; } catch (PropertyNotFoundException e) {",
        "ins1PreCode":"PropertyNotFoundException, ELException { try { return this.target.getType(context); } catch (PropertyNotFoundException e) {",
        "ins2PreCode":"PropertyNotFoundException, ELException { try { return this.target.isReadOnly(context); } catch (PropertyNotFoundException e) {",
        "label":1
    },
    {
        "ins1CurCode":"} }, NUM_MSG) .subscribe(new TestSubscriber<>(subscriber)); ",
        "ins1PreCode":"} }, NUM_MSG) .subscribe(new TestSubscriber<String>(subscriber)); ",
        "ins2PreCode":"} }) .subscribe(new TestSubscriber<String>(subscriber)); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testBug49726a() throws Exception { getTomcatInstanceTestWebapp(false, true); ",
        "ins1PreCode":"public void testBug49726a() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start(); ",
        "ins2PreCode":"public void testBug49726b() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start(); ",
        "label":1
    },
    {
        "ins1CurCode":"void activeProfilesFromDefaultPropertiesShouldNotTakePrecedence() { this.initializer.setSearchNames(\"enableprofile\");",
        "ins1PreCode":"public void activeProfilesFromDefaultPropertiesShouldNotTakePrecedence() { this.initializer.setSearchNames(\"enableprofile\");",
        "ins2PreCode":"public void includedProfilesFromDefaultPropertiesShouldNotTakePrecedence() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1CurCode":"public void removeNode_existingNode() { assume().that(graphIsMutable()).isTrue();  putEdge(N1, N2); putEdge(N4, N1); assertThat(graphAsMutableGraph.removeNode(N1)).isTrue(); assertThat(graphAsMutableGraph.removeNode(N1)).isFalse(); assertThat(graph.nodes()).containsExactly(N2, N4);",
        "ins1PreCode":"putEdge(N1, N2); putEdge(N4, N1); assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.removeNode(N1)).isFalse(); assertThat(graph.nodes()).containsExactly(N2, N4);",
        "ins2PreCode":"putEdge(N1, N2); putEdge(N4, N1); assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.removeNode(N1)).isFalse(); assertThat(graph.nodes()).containsExactly(N2, N4);",
        "label":1
    },
    {
        "ins1CurCode":"append)))); } catch (IOException e) { throw new BuildException(e, getLocation()); }",
        "ins1PreCode":"append)))); } catch (IOException e) { throw new BuildException(e, location); }",
        "ins2PreCode":"append)))); } catch (IOException e) { throw new BuildException(e, location); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerialization4() {  XYSeriesCollection<String> dataset = new XYSeriesCollection<>(); JFreeChart chart = ChartFactory.createXYLineChart(\"Test Chart\",",
        "ins1PreCode":"public void testSerialization4() {  XYSeriesCollection dataset = new XYSeriesCollection(); JFreeChart chart = ChartFactory.createXYLineChart(\"Test Chart\",",
        "ins2PreCode":"public void testSerialization4() { DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>(); JFreeChart chart = ChartFactory.createBarChart( \"Test Chart\", \"Category Axis\", \"Value Axis\", dataset, PlotOrientation.VERTICAL, true, true, false); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND); JFreeChart chart2 = TestUtils.serialised(chart); assertEquals(chart, chart2);   try { chart2.createBufferedImage(300, 200); } catch (Exception e) { fail(\"No exception should be thrown.\"); }",
        "label":0
    },
    {
        "ins1CurCode":"static final QueueDrainSubscriber<Integer, Integer, Integer> createUnordered(TestSubscriber<Integer> ts, final Disposable d) { return new QueueDrainSubscriber<Integer, Integer, Integer>(ts, new SpscArrayQueue<>(4)) { @Override",
        "ins1PreCode":"static final QueueDrainSubscriber<Integer, Integer, Integer> createUnordered(TestSubscriber<Integer> ts, final Disposable d) { return new QueueDrainSubscriber<Integer, Integer, Integer>(ts, new SpscArrayQueue<Integer>(4)) { @Override",
        "ins2PreCode":"static final QueueDrainSubscriber<Integer, Integer, Integer> createOrdered(TestSubscriber<Integer> ts, final Disposable d) { return new QueueDrainSubscriber<Integer, Integer, Integer>(ts, new SpscArrayQueue<Integer>(4)) { @Override",
        "label":1
    },
    {
        "ins1CurCode":"return; } if (isFragment) {      return; }  TagVariableInfo[] tagVarInfos = n.getTagVariableInfos(); VariableInfo[] varInfos = n.getVariableInfos(); if ((varInfos.length == 0) && (tagVarInfos.length == 0)) { return; }  List<Object> declaredVariables = n.getScriptingVars(scope);  if (varInfos.length > 0) { for (int i = 0; i < varInfos.length; i++) { if (varInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(tmpVarName); out.print(\" = \"); out.print(varName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(tagVarInfos[i])) continue;",
        "ins1PreCode":"  if (n.getScriptingVars(scope).contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(tmpVarName); out.print(\" = \"); out.print(varName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue;   if (n.getScriptingVars(scope).contains(tagVarInfos[i])) continue;",
        "ins2PreCode":"  if (n.getScriptingVars(scope).contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(varName); out.print(\" = \"); out.print(tmpVarName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue;   if (n.getScriptingVars(scope).contains(tagVarInfos[i])) continue;",
        "label":1
    },
    {
        "ins1CurCode":"public void usingDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "ins1PreCode":"public void usingDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "ins2PreCode":"public void usingDoesNotDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "label":1
    },
    {
        "ins1CurCode":"getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getProperty(\"output\").replace( File.separatorChar, '/'); ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "ins1PreCode":"getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getBaseDir().getAbsolutePath().replace( File.separatorChar, '/') + \"/tmp\"; ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "ins2PreCode":"getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getBaseDir().getAbsolutePath().replace( File.separatorChar, '/') + \"/tmp\"; ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "label":1
    },
    {
        "ins1CurCode":"g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtils.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(),",
        "ins1PreCode":"g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(),",
        "ins2PreCode":"g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(),",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article\\n{\\ntest,author={Ed von Test}}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":".parse(new StringReader(\"@article\\n{\\ntest,author={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":".parse(new StringReader(\"@article(test,author={Ed von Test})\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"  List<Row> data = Arrays.asList( RowFactory.create(0, Vectors.dense(1.0, 0.1, -8.0)), RowFactory.create(1, Vectors.dense(2.0, 1.0, -4.0)), RowFactory.create(2, Vectors.dense(4.0, 10.0, 8.0)) ); StructType schema = new StructType(new StructField[]{ new StructField(\"id\", DataTypes.IntegerType, false, Metadata.empty()), new StructField(\"features\", new VectorUDT(), false, Metadata.empty()) }); Dataset<Row> dataFrame = spark.createDataFrame(data, schema);  MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.select(\"features\", \"scaledFeatures\").show(); ",
        "ins1PreCode":"  Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show(); ",
        "ins2PreCode":"  Dataset<Row> dataFrame = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); ",
        "label":1
    },
    {
        "ins1CurCode":" }).take(1); TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<>(); f.subscribe(subscriber);",
        "ins1PreCode":" }).take(1); TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<Integer>(); f.subscribe(subscriber);",
        "ins2PreCode":"}).take(1);  TestObserverEx<Integer> observer = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"state == AsyncState.ERROR) { state = AsyncState.DISPATCHING; if (!ContainerThreadMarker.isContainerThread()) { doDispatch = true;",
        "ins1PreCode":"state == AsyncState.ERROR) { state = AsyncState.DISPATCHING; doDispatch = true; } else {",
        "ins2PreCode":"public synchronized boolean asyncComplete() { boolean doComplete = false;  if (state == AsyncState.STARTING) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.STARTED) { state = AsyncState.COMPLETING; doComplete = true; } else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.READ_WRITE_OP) { clearNonBlockingListeners(); state = AsyncState.MUST_COMPLETE; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncComplete()\", state));  } return doComplete;",
        "label":0
    },
    {
        "ins1CurCode":"if ( tgt == null ) { tgt = new DependencyManagement(); target.setDependencyManagement( tgt ); }",
        "ins1PreCode":"if ( tgt == null ) { target.setDependencyManagement( tgt = new DependencyManagement() ); }",
        "ins2PreCode":"if ( tgt == null ) { target.setDistributionManagement( tgt = new DistributionManagement() ); }",
        "label":0
    },
    {
        "ins1CurCode":"void shouldFlushAllItemsOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\"));",
        "ins1PreCode":"public void shouldFlushAllItemsOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\"));",
        "ins2PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new LruCache(new PerpetualCache(\"default\"));",
        "label":1
    },
    {
        "ins1CurCode":"Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collect();  List<Row> expected = new ArrayList<>(2); expected.add(RowFactory.create(\"Michael\", 29));",
        "ins1PreCode":"Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collect();  List<Row> expected = new ArrayList<Row>(2); expected.add(RowFactory.create(\"Michael\", 29));",
        "ins2PreCode":"public void dataFrameRDDOperations() { List<Person> personList = new ArrayList<>(2); Person person1 = new Person(); person1.setName(\"Michael\"); person1.setAge(29); personList.add(person1); Person person2 = new Person(); person2.setName(\"Yin\"); person2.setAge(28); personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  DataFrame df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD().map(new Function<Row, String>() { @Override public String call(Row row) { return row.getString(0) + \"_\" + row.get(1); } }).collect();  List<String> expected = new ArrayList<>(2); expected.add(\"Michael_29\"); expected.add(\"Yin_28\");  Assert.assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,review={escaped \\\\{ bracket}}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\{ bracket\"), entry.getField(\"review\")); assertFalse(result.hasWarnings());",
        "ins1PreCode":"assertFalse(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\{ bracket\"), e.getField(\"review\"));",
        "ins2PreCode":"assertFalse(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\} bracket\"), e.getField(\"review\"));",
        "label":1
    },
    {
        "ins1CurCode":"FieldFormatterCleanups actions = new FieldFormatterCleanups(true, Cleanups.parse(\"title[lower_case,identity]\"));  FieldFormatterCleanup lowerCaseTitle = new FieldFormatterCleanup(StandardField.TITLE, new LowerCaseFormatter()); FieldFormatterCleanup identityInTitle = new FieldFormatterCleanup(StandardField.TITLE, new IdentityFormatter()); assertEquals(Arrays.asList(lowerCaseTitle, identityInTitle), actions.getConfiguredActions());  actions.applySaveActions(entry);  assertEquals(Optional.of(\"educational session 1\"), entry.getField(StandardField.TITLE));",
        "ins1PreCode":"FieldFormatterCleanups actions = new FieldFormatterCleanups(true, Cleanups.parse(\"title[lower_case,identity]\"));  FieldFormatterCleanup lowerCaseTitle = new FieldFormatterCleanup(\"title\", new LowerCaseFormatter()); FieldFormatterCleanup identityInTitle = new FieldFormatterCleanup(\"title\", new IdentityFormatter()); assertEquals(Arrays.asList(lowerCaseTitle, identityInTitle), actions.getConfiguredActions());  actions.applySaveActions(entry);  assertEquals(Optional.of(\"educational session 1\"), entry.getField(\"title\"));",
        "ins2PreCode":"FieldFormatterCleanups actions = new FieldFormatterCleanups(true, Cleanups.parse(\"title[lower_case,identity,normalize_date]\"));  FieldFormatterCleanup lowerCaseTitle = new FieldFormatterCleanup(\"title\", new LowerCaseFormatter()); FieldFormatterCleanup identityInTitle = new FieldFormatterCleanup(\"title\", new IdentityFormatter()); FieldFormatterCleanup normalizeDatesInTitle = new FieldFormatterCleanup(\"title\", new NormalizeDateFormatter()); assertEquals(Arrays.asList(lowerCaseTitle, identityInTitle, normalizeDatesInTitle), actions.getConfiguredActions());  actions.applySaveActions(entry);  assertEquals(Optional.of(\"educational session 1\"), entry.getField(\"title\"));",
        "label":1
    },
    {
        "ins1CurCode":"UnicastProcessor(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<>(Objects.requireNonNull(onTerminate, \"onTerminate\")); this.delayError = delayError; this.downstream = new AtomicReference<>(); this.once = new AtomicBoolean();",
        "ins1PreCode":"UnicastProcessor(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<Runnable>(onTerminate); this.delayError = delayError; this.downstream = new AtomicReference<Subscriber<? super T>>(); this.once = new AtomicBoolean();",
        "ins2PreCode":"UnicastSubject(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<Runnable>(Objects.requireNonNull(onTerminate, \"onTerminate\")); this.delayError = delayError; this.downstream = new AtomicReference<Observer<? super T>>(); this.once = new AtomicBoolean();",
        "label":0
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":"public void errorInPredicate() { TestObserverEx<Object> to = new TestObserverEx<>(); to.onError(new RuntimeException());",
        "ins1PreCode":"public void errorInPredicate() { TestObserverEx<Object> to = new TestObserverEx<Object>(); to.onError(new RuntimeException());",
        "ins2PreCode":"public void errorInPredicate() { TestObserver<Object> to = new TestObserver<Object>(); to.onError(new RuntimeException());",
        "label":1
    },
    {
        "ins1CurCode":"public void usingDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "ins1PreCode":"public void usingDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "ins2PreCode":"public void usingDoesNotDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "label":1
    },
    {
        "ins1CurCode":"public final <@NonNull R> Observable<R> concatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Observable<R> concatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins2PreCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int bufferSize) {",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(v).hide(); } }, false, 2); }",
        "ins1PreCode":"return Flowable.just(v).hide(); } }, 2, false); }",
        "ins2PreCode":"return Flowable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); }",
        "label":0
    },
    {
        "ins1CurCode":"int features = 2; int iterations = 15; int users = 100; int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, false);  JavaRDD<Rating> data = sc.parallelize(testData._1());  MatrixFactorizationModel model = new ALS().setRank(features) .setIterations(iterations) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins1PreCode":"int features = 2; int iterations = 15; int users = 20; int products = 30; scala.Tuple2<List<Rating>, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7);  JavaRDD<Rating> data = sc.parallelize(testData._1());  MatrixFactorizationModel model = new ALS().setRank(features) .setIterations(iterations) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3);",
        "ins2PreCode":"int features = 1; int iterations = 15; int users = 10; int products = 10; scala.Tuple2<List<Rating>, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.train(data.rdd(), features, iterations); validatePrediction(model, users, products, features, testData._2(), 0.3);",
        "label":0
    },
    {
        "ins1CurCode":"for (int i = 0; i < sessions.length; i++) { if (!sessions[i].isValid()) { expiredSessions.incrementAndGet(); expireHere++;",
        "ins1PreCode":"for (int i = 0; i < sessions.length; i++) { if (!sessions[i].isValid()) { expiredSessions++; expireHere++;",
        "ins2PreCode":"public void processExpires() {  long timeNow = System.currentTimeMillis(); Session sessions[] = findSessions(); int expireHere = 0 ;  if(log.isDebugEnabled()) log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (int i = 0; i < sessions.length; i++) { if (sessions[i]!=null && !sessions[i].isValid()) { expireHere++; } } long timeEnd = System.currentTimeMillis(); if(log.isDebugEnabled()) log.debug(\"End expire sessions \" + getName() + \" processingTime \" + (timeEnd - timeNow) + \" expired sessions: \" + expireHere); processingTime += ( timeEnd - timeNow ); ",
        "label":0
    },
    {
        "ins1CurCode":"void operationWithSecurityInterceptorForbidden() { given(securityService.getAccessLevel(any(), eq(\"app-id\"))).willReturn(AccessLevel.RESTRICTED);",
        "ins1PreCode":"public void operationWithSecurityInterceptorForbidden() { given(securityService.getAccessLevel(any(), eq(\"app-id\"))).willReturn(AccessLevel.RESTRICTED);",
        "ins2PreCode":"public void operationWithSecurityInterceptorSuccess() { given(securityService.getAccessLevel(any(), eq(\"app-id\"))).willReturn(AccessLevel.FULL);",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(expected.getUnfinishedMessage() instanceof TestMap); map = (TestMap) expected.getUnfinishedMessage(); assertTrue(map.getInt32ToMessageFieldMap().isEmpty()); }",
        "ins1PreCode":"assertTrue(expected.getUnfinishedMessage() instanceof TestMap); map = (TestMap) expected.getUnfinishedMessage(); assertTrue(map.getInt32ToMessageField().isEmpty()); }",
        "ins2PreCode":"assertTrue(expected.getUnfinishedMessage() instanceof TestMap); map = (TestMap) expected.getUnfinishedMessage(); assertTrue(map.getInt32ToMessageField().isEmpty()); }",
        "label":1
    },
    {
        "ins1CurCode":"ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapContext, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);",
        "ins1PreCode":"ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);",
        "ins2PreCode":"ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);",
        "label":1
    },
    {
        "ins1CurCode":"public void testPathAsResource() { buildRule.executeTarget(\"testPathAsResource\"); final String toDir = buildRule.getProject().getProperty(\"to.dir\"); assertTrue(new File(toDir + \"/file1.txt\").exists()); assertTrue(new File(toDir + \"/file2.txt\").exists()); assertTrue(new File(toDir + \"/file3.txt\").exists());",
        "ins1PreCode":"public void testPathAsResource() { buildRule.executeTarget(\"testPathAsResource\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "ins2PreCode":"public void testZipfileset() { buildRule.executeTarget(\"testZipfileset\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtPredicateNoMatch() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void assertValueAtPredicateNoMatch() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void assertValueAtPredicateNoMatch() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata) throws IOException {  ValuesSource rawValuesSource = config.getValuesSource(); if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, cardinality, metadata);",
        "ins1PreCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket, Map<String, Object> metadata) throws IOException {  ValuesSource rawValuesSource = config.getValuesSource(); if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, collectsFromSingleBucket, metadata);",
        "ins2PreCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator children, boolean collectsFromSingleBucket, Map<String, Object> metadata) throws IOException {  ValuesSource rawValuesSource = config.getValuesSource(); if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ChildrenToParentAggregator(name, factories, searchContext, children, childFilter, parentFilter, valuesSource, maxOrd, collectsFromSingleBucket, metadata);",
        "label":1
    },
    {
        "ins1CurCode":"ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<T>(comparator));  return RxJavaPlugins.onAssembly(new ParallelSortedJoin<>(railSorted, comparator));",
        "ins1PreCode":"ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<T>(comparator));  return RxJavaPlugins.onAssembly(new ParallelSortedJoin<T>(railSorted, comparator));",
        "ins2PreCode":"public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) { Objects.requireNonNull(comparator, \"comparator is null\");",
        "label":0
    },
    {
        "ins1CurCode":"TestConcurrencySubscriber tw = new TestConcurrencySubscriber();  Subscriber<String> w = serializedSubscriber(new SafeSubscriber<>(tw)); ",
        "ins1PreCode":"TestConcurrencySubscriber tw = new TestConcurrencySubscriber();  Subscriber<String> w = serializedSubscriber(new SafeSubscriber<String>(tw)); ",
        "ins2PreCode":"TestConcurrencySubscriber tw = new TestConcurrencySubscriber();  Observer<String> w = serializedObserver(new SafeObserver<String>(tw)); ",
        "label":1
    },
    {
        "ins1CurCode":"Group group = user.getUserDatabase().findGroup(groupname); if (group == null) { throw new IllegalArgumentException(sm.getString(\"userMBean.invalidGroup\", groupname)); }",
        "ins1PreCode":"Group group = user.getUserDatabase().findGroup(groupname); if (group == null) { throw new IllegalArgumentException(\"Invalid group name '\" + groupname + \"'\"); }",
        "ins2PreCode":"Group group = user.getUserDatabase().findGroup(groupname); if (group == null) { throw new IllegalArgumentException(\"Invalid group name '\" + groupname + \"'\"); }",
        "label":1
    },
    {
        "ins1CurCode":"  s1.remove(1.0); assertFalse(s1.equals(s2)); s2.remove(1.0); assertTrue(s2.equals(s1));",
        "ins1PreCode":"  s1.remove(new Double(1.0)); assertFalse(s1.equals(s2)); s2.remove(new Double(1.0)); assertTrue(s2.equals(s1));",
        "ins2PreCode":"  s1.remove(new Double(1.0)); assertFalse(s1.equals(s2)); s2.remove(new Double(1.0)); assertTrue(s2.equals(s1));",
        "label":1
    },
    {
        "ins1CurCode":"protected FigNode getNodePresentationFor(Layer lay, Object modelElement) { assert modelElement != null : \"A modelElement must be supplied\";",
        "ins1PreCode":"private FigNode getNodePresentationFor(Layer lay, Object modelElement) { assert modelElement != null : \"A modelElement must be supplied\";",
        "ins2PreCode":"private FigNode getNodePresentationFor(Layer lay, Object modelElement) { assert modelElement != null : \"A modelElement must be supplied\"; for (Object fig : lay.getContentsNoEdges()) {  if (fig instanceof FigNode && modelElement.equals(((FigNode) fig).getOwner())) { return ((FigNode) fig); } } for (Object fig : lay.getContentsEdgesOnly()) { if (fig instanceof FigEdgeModelElement && modelElement.equals(((FigEdgeModelElement) fig) .getOwner())) { return ((FigEdgeModelElement) fig).getEdgePort(); } } return null;",
        "label":0
    },
    {
        "ins1CurCode":"Object element, String property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.log(Level.WARNING, \"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.log(Level.FINE, \"Attempted duplicate registration of event listener\" + \" - Element: {0} Listener: {1}\", new Object[]{element, listener}); }",
        "ins1PreCode":"Object element, String property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener); }",
        "ins2PreCode":"Object element, String[] property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener);",
        "label":0
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION), query).getDescription(); ",
        "ins1PreCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription(); ",
        "ins2PreCode":"TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, false, query).getDescription(); ",
        "label":0
    },
    {
        "ins1CurCode":"Completable completable = stringSubject.ignoreElements();  final AtomicReference<Disposable> disposableRef = new AtomicReference<>(); Disposable completableSubscription = completable.subscribe(new Action() {",
        "ins1PreCode":"Completable completable = stringSubject.ignoreElements();  final AtomicReference<Disposable> disposableRef = new AtomicReference<Disposable>(); Disposable completableSubscription = completable.subscribe(new Action() {",
        "ins2PreCode":"Completable completable = stringSubject.ignoreElements();  final AtomicReference<Disposable> disposableRef = new AtomicReference<Disposable>(); Disposable completableSubscription = completable.subscribe(new Action() {",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { try { Disposable d1 = Disposable.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposable.empty(); ",
        "ins1PreCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "ins2PreCode":"protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<Object> h = new TimedNode<>(null, 0L); this.tail = h;",
        "ins1PreCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<Object> h = new TimedNode<Object>(null, 0L); this.tail = h;",
        "ins2PreCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<T> h = new TimedNode<T>(null, 0L); this.tail = h;",
        "label":0
    },
    {
        "ins1CurCode":"public void testFindLiveItemsUpperBound_Unordered() { DefaultXYDataset<String> d = new DefaultXYDataset<>(); ",
        "ins1PreCode":"public void testFindLiveItemsUpperBound_Unordered() { DefaultXYDataset d = new DefaultXYDataset(); ",
        "ins2PreCode":"public void testFindLiveItemsUpperBound_Ascending() { DefaultXYDataset d = new DefaultXYDataset() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"public void ofNameWhenDotAndAssociative() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.[bar]\");",
        "ins1PreCode":"public void ofNameWhenDotAndAssociative() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.[bar]\");",
        "ins2PreCode":"public void ofNameWithWhitespaceInAssociativeElement() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo[b a r]\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testWebapp_2_4() throws Exception { File appDir = new File(\"test/webapp-2.4\"); JspCServletContext context = new JspCServletContext( null, appDir.toURI().toURL(), null, false, false); Assert.assertEquals(2, context.getEffectiveMajorVersion());",
        "ins1PreCode":"public void testWebapp_2_4() throws Exception { File appDir = new File(\"test/webapp-2.4\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion());",
        "ins2PreCode":"public void testWebapp_2_5() throws Exception { File appDir = new File(\"test/webapp-2.5\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion());",
        "label":1
    },
    {
        "ins1CurCode":"private String fiddleName(String origin) { StringBuilder result = new StringBuilder(); for (char ch : origin.toCharArray()) { if (Character.isLowerCase(ch)) { result.append(Character.toUpperCase(ch)); } else if (Character.isUpperCase(ch)) { result.append(Character.toLowerCase(ch)); } else { result.append(ch); }",
        "ins1PreCode":"private String fiddleName(String origin) { StringBuilder result = new StringBuilder(); for (int icounter = 0; icounter < origin.length(); icounter++) { if (Character.isLowerCase(origin.charAt(icounter))) { result.append(Character.toUpperCase(origin.charAt(icounter))); } else if (Character.isUpperCase(origin.charAt(icounter))) { result.append(Character.toLowerCase(origin.charAt(icounter))); } else { result.append(origin.charAt(icounter)); }",
        "ins2PreCode":"private String fiddleName(String origin) { StringBuilder result = new StringBuilder(); for (int icounter = 0; icounter < origin.length(); icounter++) { if (Character.isLowerCase(origin.charAt(icounter))) { result.append(Character.toUpperCase(origin.charAt(icounter))); } else if (Character.isUpperCase(origin.charAt(icounter))) { result.append(Character.toLowerCase(origin.charAt(icounter))); } else { result.append(origin.charAt(icounter)); }",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void createNodeShouldFailIfNodeAlreadyExistWhenNameSpecifiedExplicitly() throws Exception {  j.createSlave(\"ExistingAgent\", null, null);  final CLICommandInvoker.Result result = command .authorizedTo(Computer.CREATE, Jenkins.READ) .withStdin(Computer.class.getResourceAsStream(\"node.xml\")) .invokeWithArgs(\"ExistingAgent\") ;  assertThat(result.stderr(), containsString(\"ERROR: Node 'ExistingAgent' already exists\")); assertThat(result, hasNoStandardOutput());",
        "ins1PreCode":"@Test public void createNodeShouldFailIfNodeAlreadyExistWhenNameSpecifiedExplicitly() throws Exception {  j.createSlave(\"ExistingSlave\", null, null);  final CLICommandInvoker.Result result = command .authorizedTo(Computer.CREATE, Jenkins.READ) .withStdin(Computer.class.getResourceAsStream(\"node.xml\")) .invokeWithArgs(\"ExistingSlave\") ;  assertThat(result.stderr(), containsString(\"ERROR: Node 'ExistingSlave' already exists\")); assertThat(result, hasNoStandardOutput());",
        "ins2PreCode":"@Test public void createNodeShouldFailIfNodeAlreadyExist() throws Exception {  j.createSlave(\"SlaveFromXML\", null, null);  final CLICommandInvoker.Result result = command .authorizedTo(Computer.CREATE, Jenkins.READ) .withStdin(Computer.class.getResourceAsStream(\"node.xml\")) .invoke() ;  assertThat(result.stderr(), containsString(\"ERROR: Node 'SlaveFromXML' already exists\")); assertThat(result, hasNoStandardOutput());",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<>(); ",
        "ins1PreCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void subscribeConsumerConsumer() { final List<Integer> list = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void shouldGetOrderDetailsEachHavingAnOrderHeader() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldGetOrderDetailsEachHavingAnOrderHeader() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetOrderDetailsEachHavingAnOrderHeaderAnnotationBased() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testFillPaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.WHITE, r.getBaseFillPaint());   r.setAutoPopulateSeriesFillPaint(false); assertEquals(Color.WHITE, r.lookupSeriesFillPaint(0)); assertNull(r.getSeriesFillPaint(0));",
        "ins1PreCode":"public void testFillPaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.white, r.getBaseFillPaint());   r.setAutoPopulateSeriesFillPaint(false); assertEquals(Color.white, r.lookupSeriesFillPaint(0)); assertNull(r.getSeriesFillPaint(0));",
        "ins2PreCode":"public void testPaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.blue, r.getBasePaint());   r.setAutoPopulateSeriesPaint(false); assertEquals(Color.blue, r.lookupSeriesPaint(0)); assertNull(r.getSeriesPaint(0));",
        "label":0
    },
    {
        "ins1CurCode":"s.onError(new TestException(\"First\")); } }), true, 2, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer());",
        "ins1PreCode":"s.onError(new TestException(\"First\")); } }), 2, true, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer());",
        "ins2PreCode":"public void badInnerSource() { @SuppressWarnings(\"rawtypes\") final Subscriber[] ts0 = { null }; TestSubscriberEx<Integer> ts = Flowable.just(1).hide().concatMap(Functions.justFunction(new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> s) { ts0[0] = s; s.onSubscribe(new BooleanSubscription()); s.onError(new TestException(\"First\")); } }), 2, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer());  ts.assertFailureAndMessage(TestException.class, \"First\");  List<Throwable> errors = TestHelper.trackPluginErrors(); try { ts0[0].onError(new TestException(\"Second\"));  TestHelper.assertUndeliverable(errors, 0, TestException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void actionPerformed(ActionEvent e) { Project p = ProjectManager.getManager().getCurrentProject(); Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); ArgoDiagram diagram = createDiagram(ns); p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded(ns); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "ins1PreCode":"public void actionPerformed(ActionEvent e) { super.actionPerformed(e); Project p = ProjectManager.getManager().getCurrentProject(); Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); ArgoDiagram diagram = createDiagram(ns); p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded(ns); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "ins2PreCode":" Project p = ProjectManager.getManager().getCurrentProject(); ArgoDiagram diagram = createDiagram(p.getRoot()); assert (diagram != null)",
        "label":0
    },
    {
        "ins1CurCode":"void testNamingResults() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testNamingResults() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testResultsOnlyForNaming() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":".assertResult(1);  assertFalse(\"Subject still has observers!\", ps.hasObservers());",
        "ins1PreCode":".assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins2PreCode":".assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "label":1
    },
    {
        "ins1CurCode":"setSuppressCalcBounds(true);  Dimension size = new Dimension(0, 0);  addFig(getBigPort()); addFig(getStereotypeFig()); addChildDimensions(size, getStereotypeFig()); addFig(getNameFig()); addChildDimensions(size, getNameFig()); addFig(getOperationsFig()); addChildDimensions(size, getOperationsFig()); addFig(borderFig);  setSuppressCalcBounds(false);   enableSizeChecking(true); setBounds(X0, Y0, size.width, size.height);",
        "ins1PreCode":" enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "ins2PreCode":"setSuppressCalcBounds(false);  setBounds(X0, Y0, WIDTH, 22 + 2 * ROWHEIGHT);",
        "label":0
    },
    {
        "ins1CurCode":"Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableGroupJoin<>( this, other, leftEnd, rightEnd, resultSelector));",
        "ins1PreCode":"Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "ins2PreCode":"Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "label":1
    },
    {
        "ins1CurCode":"createGrapeEngine().grab(args, dependency); URL[] urls = this.groovyClassLoader.getURLs(); assertThat(urls).hasSize(1); assertThat(urls[0].toExternalForm().endsWith(\".pom\")).isTrue();",
        "ins1PreCode":"createGrapeEngine().grab(args, dependency); URL[] urls = this.groovyClassLoader.getURLs(); assertThat(urls.length).isEqualTo(1); assertThat(urls[0].toExternalForm().endsWith(\".pom\")).isTrue();",
        "ins2PreCode":" URL[] urls = this.groovyClassLoader.getURLs(); assertThat(urls.length).isEqualTo(1); assertThat(urls[0].toExternalForm().endsWith(\"-sources.jar\")).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"} }; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher)) {",
        "ins1PreCode":"} }; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) {",
        "ins2PreCode":"private void runExpectHeaderTest( final Settings settings, final String expectation, final int contentLength, final HttpResponseStatus expectedStatus) throws InterruptedException { final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() { @Override public void dispatchRequest(RestRequest request, RestChannel channel, ThreadContext threadContext) { channel.sendResponse(new BytesRestResponse(OK, BytesRestResponse.TEXT_CONTENT_TYPE, new BytesArray(\"done\"))); }  @Override public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError(); } }; try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) { transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses()); try (Netty4HttpClient client = new Netty4HttpClient()) { final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\"); request.headers().set(HttpHeaderNames.EXPECT, expectation); HttpUtil.setContentLength(request, contentLength);  final FullHttpResponse response = client.post(remoteAddress.address(), request); assertThat(response.status(), equalTo(expectedStatus)); if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) { final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.EMPTY_BUFFER); final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest);  assertThat(continuationResponse.status(), is(HttpResponseStatus.OK)); assertThat(new String(ByteBufUtil.getBytes(continuationResponse.content()), StandardCharsets.UTF_8), is(\"done\")); } } }",
        "label":0
    },
    {
        "ins1CurCode":"E x; while ( (x = unlinkFirst()) == null) { if (nanos <= 0) { return null;",
        "ins1PreCode":"E x; while ( (x = unlinkFirst()) == null) { if (nanos <= 0) return null;",
        "ins2PreCode":"E x; while ( (x = unlinkLast()) == null) { if (nanos <= 0) return null;",
        "label":1
    },
    {
        "ins1CurCode":"public void resolveTypeDescriptorOnConcreteClass() throws IOException { process(SimpleGenericProperties.class, (roundEnv, typeUtils) -> { TypeDescriptor typeDescriptor = typeUtils.resolveTypeDescriptor( roundEnv.getRootElement(SimpleGenericProperties.class)); assertThat( typeDescriptor.getGenerics().keySet().stream().map(Object::toString)) .containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\")) .hasToString(String.class.getName()); assertThat(typeDescriptor.resolveGeneric(\"B\")) .hasToString(Integer.class.getName()); assertThat(typeDescriptor.resolveGeneric(\"C\")) .hasToString(Duration.class.getName());  });",
        "ins1PreCode":"public void resolveTypeDescriptorOnConcreteClass() throws IOException { process(SimpleGenericProperties.class, (roundEnv, typeUtils) -> { for (Element rootElement : roundEnv.getRootElements()) { TypeDescriptor typeDescriptor = typeUtils .resolveTypeDescriptor((TypeElement) rootElement); assertThat(typeDescriptor.getGenerics().keySet().stream() .map(Object::toString)).containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\"))",
        "ins2PreCode":"public void resolveTypeDescriptorOnIntermediateClass() throws IOException { process(AbstractIntermediateGenericProperties.class, (roundEnv, typeUtils) -> { for (Element rootElement : roundEnv.getRootElements()) { TypeDescriptor typeDescriptor = typeUtils .resolveTypeDescriptor((TypeElement) rootElement); assertThat(typeDescriptor.getGenerics().keySet().stream() .map(Object::toString)).containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\"))",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StandardXYZToolTipGenerator g1 = new StandardXYZToolTipGenerator(); StandardXYZToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StandardXYZToolTipGenerator g1 = new StandardXYZToolTipGenerator(); StandardXYZToolTipGenerator g2 = (StandardXYZToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"StandardXYSeriesLabelGenerator g1 = new StandardXYSeriesLabelGenerator(\"Series {0}\"); StandardXYSeriesLabelGenerator g2 = (StandardXYSeriesLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "label":1
    },
    {
        "ins1CurCode":"  IoBuffer ioBuffer = IoBuffer.wrap(bb1, bb2, bb3); ",
        "ins1PreCode":"  IoBuffer ioBuffer = new IoBuffer(bb1, bb2, bb3); ",
        "ins2PreCode":"  IoBuffer ioBuffer = new IoBuffer(bb1, bb2, bb3); ",
        "label":1
    },
    {
        "ins1CurCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<>(subscriber, 0L); ",
        "ins1PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber, 0L); ",
        "ins2PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer);  @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2)); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "label":1
    },
    {
        "ins1CurCode":"public void cloudFoundryPlatformActiveSetsCloudControllerUrl() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); String cloudControllerUrl = (String) ReflectionTestUtils .getField(interceptorSecurityService, \"cloudControllerUrl\"); assertThat(cloudControllerUrl).isEqualTo(\"http://my-cloud-controller.com\"); });",
        "ins1PreCode":"public void cloudFoundryPlatformActiveSetsCloudControllerUrl() { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping,",
        "ins2PreCode":"public void cloudFoundryPlatformActiveSetsCloudControllerUrl() { setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping,",
        "label":0
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerCompletableObserverTerminated() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerCompletableObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerEmitterTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"Parameter[] params = getParameters(); if (params != null) { for (Parameter param : params) { if (CONTAINS_KEY.equals(param.getType())) { contains.addElement(param.getValue()); } else if (NEGATE_KEY.equals(param.getType())) { setNegate(Project.toBoolean(param.getValue())); }",
        "ins1PreCode":"Parameter[] params = getParameters(); if (params != null) { for (int i = 0; i < params.length; i++) { if (CONTAINS_KEY.equals(params[i].getType())) { contains.addElement(params[i].getValue()); } else if (NEGATE_KEY.equals(params[i].getType())) { setNegate(Project.toBoolean(params[i].getValue())); }",
        "ins2PreCode":"Parameter[] params = getParameters(); if (params != null) { for (int i = 0; i < params.length; i++) { if (REGEXP_KEY.equals(params[i].getType())) { setRegexp(params[i].getValue()); } else if (NEGATE_KEY.equals(params[i].getType())) { setNegate(Project.toBoolean(params[i].getValue())); } else if (CS_KEY.equals(params[i].getType())) { setCaseSensitive(Project.toBoolean(params[i].getValue())); }",
        "label":1
    },
    {
        "ins1CurCode":"void javaBeanMetadataDeprecatedPropertyWithAnnotation() throws IOException { process(DeprecatedSingleProperty.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanMetadataDeprecatedPropertyWithAnnotation() throws IOException { process(DeprecatedSingleProperty.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokDeprecatedPropertyOnField() throws IOException { process(LombokDeprecatedSingleProperty.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"static String readQuotedToken(StringReader input) throws IOException { ",
        "ins1PreCode":"private static String readQuotedToken(StringReader input) throws IOException { ",
        "ins2PreCode":"private static String readLhex(StringReader input) throws IOException { ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);  LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult); ",
        "ins1PreCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); ",
        "ins2PreCode":"public void testUnknownKey() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); ",
        "label":1
    },
    {
        "ins1CurCode":" Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<>(subscriber); processor.subscribe(ts);",
        "ins1PreCode":" Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber); processor.subscribe(ts);",
        "ins2PreCode":" Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber); processor.subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"result = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.log(Level.WARNING, \"ActivityDiagramRenderer getFigNodeFor unexpected node \" + node); return null; } LOG.log(Level.FINE, \"ActivityDiagramRenderer getFigNodeFor {0}\", result); lay.add(result);",
        "ins1PreCode":"result = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.warn(\"ActivityDiagramRenderer getFigNodeFor unexpected node \" + node); return null; } LOG.debug(\"ActivityDiagramRenderer getFigNodeFor \" + result); lay.add(result);",
        "ins2PreCode":"result = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.warn(\"SequenceDiagramRenderer getFigNodeFor unexpected node \" + node); return null; } LOG.debug(\"SequenceDiagramRenderer getFigNodeFor \" + result); lay.add(result);",
        "label":1
    },
    {
        "ins1CurCode":"assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessageStartingWith(\"Search location '\").withMessageEndingWith(\"' must end with '*/'\");",
        "ins1PreCode":"assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildcard patterns must end with '*/'\");",
        "ins2PreCode":"assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildard pattern with multiple '*'s cannot be used as search location\");",
        "label":0
    },
    {
        "ins1CurCode":"StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0, 0); assertEquals(\"num-chunks\", 0, blockMeta.getNumChunks());",
        "ins1PreCode":"StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); assertEquals(\"num-chunks\", 0, blockMeta.getNumChunks());",
        "ins2PreCode":"StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onComplete(stream.getID()); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[]{9}, new int[][]{{0}});",
        "label":1
    },
    {
        "ins1CurCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins1PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins2PreCode":"List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { if (cookieHeader.contains(\"name=\")) { assertTrue(cookieHeader.contains(\"name=val?ue\")); }",
        "label":0
    },
    {
        "ins1CurCode":"} assertTrue(classUnderTest + \" must capture the right bytes\", stillEqual); assertFalse(classUnderTest + \" must have exhausted the iterator\", iter.hasNext()); ",
        "ins1PreCode":"} assertTrue(classUnderTest + \" must capture the right bytes\", stillEqual); assertFalse(classUnderTest + \" must have exhausted the itertor\", iter.hasNext()); ",
        "ins2PreCode":"} assertTrue(CLASSNAME + \" must capture the right bytes\", stillEqual); assertFalse(CLASSNAME + \" must have exhausted the itertor\", iter.hasNext()); ",
        "label":1
    },
    {
        "ins1CurCode":"void filterCapturesSessionIdWhenSessionIsUsed() { executeFilter(MockServerWebExchange.from(MockServerHttpRequest.get(\"https://api.example.com\")), (exchange) -> {",
        "ins1PreCode":"public void filterCapturesSessionIdWhenSessionIsUsed() { executeFilter(MockServerWebExchange.from(MockServerHttpRequest.get(\"https://api.example.com\")), (exchange) -> {",
        "ins2PreCode":"public void filterDoesNotCaptureIdOfUnusedSession() { executeFilter(MockServerWebExchange.from(MockServerHttpRequest.get(\"https://api.example.com\")), (exchange) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public Object get(final GeneratedMessageV3 message) { final List newList = new ArrayList<>(); final int size = getRepeatedCount(message);",
        "ins1PreCode":"public Object get(final GeneratedMessageV3 message) { final List newList = new ArrayList(); final int size = getRepeatedCount(message);",
        "ins2PreCode":"public Object get(final GeneratedMessage message) { final List newList = new ArrayList(); final int size = getRepeatedCount(message); for (int i = 0; i < size; i++) { newList.add(getRepeated(message, i)); } return Collections.unmodifiableList(newList);",
        "label":0
    },
    {
        "ins1CurCode":"  if (maxMessageSize > -1 && maxMessageSize > session.getMaxTextMessageBufferSize()) { if (maxMessageSize > Integer.MAX_VALUE) {  } session.setMaxTextMessageBufferSize((int) maxMessageSize); }",
        "ins1PreCode":"  Class<?> type = method.getParameterTypes()[indexPayload]; if (Util.isPrimitive(type)) { primitiveType = type; return; } else { primitiveType = null;",
        "ins2PreCode":"try { if (decoderClazzes != null) { for (Class<? extends Decoder> decoderClazz : decoderClazzes) { if (Binary.class.isAssignableFrom(decoderClazz)) { Binary<?> decoder = (Binary<?>) decoderClazz.newInstance(); decoder.init(config); decoders.add(decoder);",
        "label":1
    },
    {
        "ins1CurCode":"m.getHeader().setRcode(Rcode.NXDOMAIN); Resolver mockResolver = Mockito.mock(Resolver.class); when(mockResolver.send(ArgumentMatchers.any(Message.class))) .thenAnswer( (Answer<Message>) invocation -> { Message query = invocation.getArgument(0); Message answer = m.clone(); answer.addRecord(query.getQuestion(), Section.QUESTION); return answer; }); Lookup.setDefaultResolver(mockResolver);",
        "ins1PreCode":"m.getHeader().setRcode(Rcode.NXDOMAIN); Resolver mockResolver = Mockito.mock(Resolver.class); when(mockResolver.send(ArgumentMatchers.any(Message.class))).thenReturn(m); Lookup.setDefaultResolver(mockResolver);",
        "ins2PreCode":"m.getHeader().setRcode(Rcode.NXDOMAIN); Resolver mockResolver = Mockito.mock(Resolver.class); when(mockResolver.send(ArgumentMatchers.any(Message.class))).thenReturn(m); Lookup.setDefaultResolver(mockResolver);",
        "label":1
    },
    {
        "ins1CurCode":"void keyStoreProviderIsUsedWhenCreatingKeyStore() throws Exception { Ssl ssl = new Ssl();",
        "ins1PreCode":"public void keyStoreProviderIsUsedWhenCreatingKeyStore() throws Exception { Ssl ssl = new Ssl();",
        "ins2PreCode":"public void trustStoreProviderIsUsedWhenCreatingTrustStore() throws Exception { Ssl ssl = new Ssl();",
        "label":1
    },
    {
        "ins1CurCode":"public void testNotDeterministic() { DeterministicFactoryTestScript.Factory factory = scriptEngine.compile(\"not_deterministic_test\", \"Math.random()\", DeterministicFactoryTestScript.CONTEXT, Collections.emptyMap()); assertFalse(factory.isResultDeterministic());",
        "ins1PreCode":"public void testNotDeterministic() { FactoryTestScript.Factory factory = scriptEngine.compile(\"not_deterministic_test\", \"Math.random()\", FactoryTestScript.CONTEXT, Collections.emptyMap()); assertFalse(factory.isResultDeterministic());",
        "ins2PreCode":"public void testMixedDeterministicIsNotDeterministic() { FactoryTestScript.Factory factory = scriptEngine.compile(\"not_deterministic_test\", \"Integer.parseInt('123') + Math.random()\", FactoryTestScript.CONTEXT, Collections.emptyMap()); assertFalse(factory.isResultDeterministic());",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"properties\", fieldNames);  UserAgentProcessor processor = factory.create(null, null, null, config); assertThat(processor.getField(), equalTo(\"_field\"));",
        "ins1PreCode":"config.put(\"properties\", fieldNames);  UserAgentProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\"));",
        "ins2PreCode":"config.put(\"field\", \"_field\"); config.put(\"properties\", fieldNames); AttachmentProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testExcludeHasPrecedence() { assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins1PreCode":"public void testExcludeHasPrecedence() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void testAlternateIncludeExclude() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setProperty(\"useAsyncIO\", \"true\"); ",
        "ins1PreCode":" Tomcat tomcat = getTomcatInstance();  ",
        "ins2PreCode":"private UpgradeConnection doUpgrade( Class<? extends HttpUpgradeHandler> upgradeHandlerClass) throws Exception {  Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(\"\", null);  UpgradeServlet servlet = new UpgradeServlet(upgradeHandlerClass); Tomcat.addServlet(ctx, \"servlet\", servlet); ctx.addServletMappingDecoded(\"/\", \"servlet\");  tomcat.start();    Socket socket = SocketFactory.getDefault().createSocket(\"localhost\", getPort());  socket.setSoTimeout(5000);  UpgradeConnection uc = new UpgradeConnection(socket);  uc.getWriter().write(\"GET / HTTP/1.1\" + CRLF); uc.getWriter().write(\"Host: whatever\" + CRLF); uc.getWriter().write(CRLF); uc.getWriter().flush();  String status = uc.getReader().readLine();  Assert.assertNotNull(status); Assert.assertEquals(\"101\", getStatusCode(status));   String line = uc.getReader().readLine(); while (line != null && line.length() > 0) {  line = uc.getReader().readLine(); }  return uc;",
        "label":0
    },
    {
        "ins1CurCode":".run((context) -> { assertThat(context).hasSingleBean(DefaultWebFluxTagsProvider.class); assertThat(context.getBean(DefaultWebFluxTagsProvider.class)).extracting(\"ignoreTrailingSlash\") .isEqualTo(false); });",
        "ins1PreCode":".run((context) -> { assertThat(context).hasSingleBean(DefaultWebFluxTagsProvider.class); assertThat(ReflectionTestUtils.getField(context.getBean(DefaultWebFluxTagsProvider.class), \"ignoreTrailingSlash\")).isEqualTo(false); });",
        "ins2PreCode":".run((context) -> { assertThat(context).hasSingleBean(DefaultWebMvcTagsProvider.class); assertThat(ReflectionTestUtils.getField(context.getBean(DefaultWebMvcTagsProvider.class), \"ignoreTrailingSlash\")).isEqualTo(false); });",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 50; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 50; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"void testSimpleQuery() { String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1PreCode":"public void testSimpleQuery() { double textSize = 13; String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testSimpleQueryRegex() { double textSize = 13; String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1CurCode":"public void combineLatestArrayOfSources() {  Flowable.combineLatestArray(new Flowable[] { Flowable.just(1), Flowable.just(2)",
        "ins1PreCode":"public void combineLatestArrayOfSources() {  Flowable.combineLatest(new Flowable[] { Flowable.just(1), Flowable.just(2)",
        "ins2PreCode":"public void combineLatestDelayErrorArrayOfSources() {  Flowable.combineLatestDelayError(new Flowable[] { Flowable.just(1), Flowable.just(2)",
        "label":1
    },
    {
        "ins1CurCode":"public void parse(final Object umlMessage, final String text) { try { parseMessage(umlMessage, text); } catch (ParseException pe) {",
        "ins1PreCode":"public void parse(final Object modelElement, final String text) { try { parseMessage(modelElement, text); } catch (ParseException pe) {",
        "ins2PreCode":"public void parse(Object modelElement, String text) { try { parseRole(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.association-role\"; Object[] args = { pe.getLocalizedMessage(), Integer.valueOf(pe.getErrorOffset()), }; ArgoEventPump.fireEvent(new ArgoHelpEvent( ArgoEventTypes.HELP_CHANGED, this, Translator.messageFormat(msg, args))); }",
        "label":0
    },
    {
        "ins1CurCode":"client.connect(); client.processRequest(); Assert.assertTrue(client.isResponse501());",
        "ins1PreCode":"client.connect(); client.processRequest(); assertTrue(client.isResponse501());",
        "ins2PreCode":"client.connect(); client.processRequest(); assertTrue(client.isResponse501());",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<?> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt = new StandardCategoryToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertSame(tt2, tt);",
        "label":0
    },
    {
        "ins1CurCode":" try { TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<>(); ",
        "ins1PreCode":" try { TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<Integer>(); ",
        "ins2PreCode":" try { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":" List<String> actual = new ArrayList<String>(); @SuppressWarnings( \"unchecked\" ) List<Plugin> plugins = (List<Plugin>) pom.getValue( \"build/plugins\" ); for ( Plugin plugin : plugins ) {",
        "ins1PreCode":" List<String> actual = new ArrayList<String>(); for ( Plugin plugin : (List<Plugin>) pom.getValue( \"build/plugins\" ) ) {",
        "ins2PreCode":" List<String> actual = new ArrayList<String>(); for ( Plugin plugin : (List<Plugin>) pom.getValue( \"build/plugins\" ) ) {",
        "label":1
    },
    {
        "ins1CurCode":"void analysisWithKnownProperty() { MapPropertySource source = new MapPropertySource(\"test\", Collections.singletonMap(\"test.property\", \"invalid\"));",
        "ins1PreCode":"public void analysisWithKnownProperty() { MapPropertySource source = new MapPropertySource(\"test\", Collections.singletonMap(\"test.property\", \"invalid\"));",
        "ins2PreCode":"public void analysisWithKnownPropertyAndNoReason() { MapPropertySource source = new MapPropertySource(\"test\", Collections.singletonMap(\"test.property\", \"invalid\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void boundedBlockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<>(); ",
        "ins1PreCode":"public void boundedBlockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>(); ",
        "ins2PreCode":"public void boundedBlockingSubscribeConsumerConsumerBufferExceed() { final List<Object> list = new ArrayList<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1); ",
        "ins1PreCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<>(series1); ",
        "ins2PreCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<>(series1); ",
        "label":1
    },
    {
        "ins1CurCode":" for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }",
        "ins1PreCode":" for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }",
        "ins2PreCode":" for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }",
        "label":1
    },
    {
        "ins1CurCode":"HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(1).click(); HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt two\");",
        "ins1PreCode":"HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); f.getButtonByCaption(\"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(1).click(); f.getButtonByCaption(\"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt two\");",
        "ins2PreCode":"HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); f.getButtonByCaption(\"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt 4\");",
        "label":0
    },
    {
        "ins1CurCode":"public void publishFunctionCancelOuterAfterOneInner() { final AtomicReference<Flowable<Integer>> ref = new AtomicReference<>(); ",
        "ins1PreCode":"public void publishFunctionCancelOuterAfterOneInner() { final AtomicReference<Flowable<Integer>> ref = new AtomicReference<Flowable<Integer>>(); ",
        "ins2PreCode":"public void publishFunctionCancelOuterAfterOneInnerBackpressured() { final AtomicReference<Flowable<Integer>> ref = new AtomicReference<Flowable<Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception { ReflectionTestUtils.setField(this.tokenValidator, \"tokenKeys\", INVALID_KEYS);",
        "ins1PreCode":"public void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception { ReflectionTestUtils.setField(this.tokenValidator, \"tokenKeys\", INVALID_KEYS);",
        "ins2PreCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);",
        "label":1
    },
    {
        "ins1CurCode":"void setLevelToNull(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", null); this.logger.debug(\"Hello\"); assertThat(StringUtils.countOccurrencesOf(output.toString(), \"Hello\")).isEqualTo(1);",
        "ins1PreCode":"public void setLevelToNull() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", null); this.logger.debug(\"Hello\"); assertThat(StringUtils.countOccurrencesOf(this.output.toString(), \"Hello\")).isEqualTo(1);",
        "ins2PreCode":"public void setLevel() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); assertThat(StringUtils.countOccurrencesOf(this.output.toString(), \"Hello\")).isEqualTo(1);",
        "label":1
    },
    {
        "ins1CurCode":"return null; } else if (path.startsWith(\"/\")) { return context.getServletContext().getRequestDispatcher(path); }",
        "ins1PreCode":"return null; } else if (path.startsWith(\"/\")) { return (context.getServletContext().getRequestDispatcher(path)); }",
        "ins2PreCode":" if (context == null) return (null);   if (path == null) return (null); else if (path.startsWith(\"/\")) return (context.getServletContext().getRequestDispatcher(path));   String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); if (servletPath == null) servletPath = getServletPath();   String pathInfo = getPathInfo(); String requestPath = null;  if (pathInfo == null) { requestPath = servletPath; } else { requestPath = servletPath + pathInfo; }  int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; }  return (context.getServletContext().getRequestDispatcher(relative)); ",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder()",
        "ins1PreCode":"assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder()",
        "ins2PreCode":"assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder()",
        "label":1
    },
    {
        "ins1CurCode":"void keyStoreProviderIsUsedWhenCreatingKeyStore() throws Exception { Ssl ssl = new Ssl();",
        "ins1PreCode":"public void keyStoreProviderIsUsedWhenCreatingKeyStore() throws Exception { Ssl ssl = new Ssl();",
        "ins2PreCode":"public void trustStoreProviderIsUsedWhenCreatingTrustStore() throws Exception { Ssl ssl = new Ssl();",
        "label":1
    },
    {
        "ins1CurCode":"void wrongJavaType() { Configuration configuration = sqlSessionFactory.getConfiguration();",
        "ins1PreCode":"public void wrongJavaType() { Configuration configuration = sqlSessionFactory.getConfiguration();",
        "ins2PreCode":"public void missingRequiredJavaType() { Configuration configuration = sqlSessionFactory.getConfiguration();",
        "label":1
    },
    {
        "ins1CurCode":"void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(\"author\", \"Mr. Author\");  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());  try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins1PreCode":"public void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(\"author\", \"Mr. Author\");  SavePreferences preferences = new SavePreferences().withEncoding(encoding).withSaveInOriginalOrder(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  StringSaveSession session = databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries(), preferences);  try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"),encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), session.getStringValue()); }",
        "ins2PreCode":"public void roundtripWithUnknownMetaData() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/unknownMetaData.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  SavePreferences preferences = new SavePreferences().withEncoding(encoding).withSaveInOriginalOrder(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  StringSaveSession session = databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries(), preferences); try (Scanner scanner = new Scanner(testBibtexFile,encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), session.getStringValue()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testBasicSet() { Project p = buildRule.getProject(); buildRule.executeTarget(\"testbasicset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "ins1PreCode":"public void testBasicSet() { Project p = getProject(); executeTarget(\"testbasicset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "ins2PreCode":"public void testSmallSet() { Project p = getProject(); executeTarget(\"testsmallset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "label":1
    },
    {
        "ins1CurCode":"this.locale = Locale.ENGLISH; } else { this.locale = bundleLocale; }",
        "ins1PreCode":"this.locale = Locale.ENGLISH; } else { this.locale = bundle.getLocale(); }",
        "ins2PreCode":"private StringManager(String packageName) { ResourceBundle b = null;  String bundleName = packageName + \".LocalStrings\"; try { b = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { b = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) {  } } }  this.bundle = b; if (bundle != null) { locale = bundle.getLocale(); } else { locale = null; }",
        "label":0
    },
    {
        "ins1CurCode":"public void testRemoveSubplot() { CombinedDomainXYPlot plot = new CombinedDomainXYPlot(); XYPlot<String> plot1 = new XYPlot<>(); XYPlot<String> plot2 = new XYPlot<>(); plot.add(plot1);",
        "ins1PreCode":"public void testRemoveSubplot() { CombinedDomainXYPlot plot = new CombinedDomainXYPlot(); XYPlot plot1 = new XYPlot(); XYPlot plot2 = new XYPlot(); plot.add(plot1);",
        "ins2PreCode":"public void testRemoveSubplot() { CombinedRangeXYPlot plot = new CombinedRangeXYPlot(); XYPlot plot1 = new XYPlot(); XYPlot plot2 = new XYPlot(); plot.add(plot1);",
        "label":1
    },
    {
        "ins1CurCode":"void getIdBasedFetchersReturnsAllFetcherDerivingFromIdBasedFetcher() throws Exception { List<IdBasedFetcher> idFetchers = WebFetchers.getIdBasedFetchers(importFormatPreferences);",
        "ins1PreCode":"public void getIdBasedFetchersReturnsAllFetcherDerivingFromIdBasedFetcher() throws Exception { List<IdBasedFetcher> idFetchers = WebFetchers.getIdBasedFetchers(importFormatPreferences);",
        "ins2PreCode":"public void getSearchBasedFetchersReturnsAllFetcherDerivingFromSearchBasedFetcher() throws Exception { List<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences);",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetMaximumItemCount() { XIntervalSeries<String> s1 = new XIntervalSeries<>(\"S1\"); assertEquals(Integer.MAX_VALUE, s1.getMaximumItemCount());",
        "ins1PreCode":"public void testSetMaximumItemCount() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); assertEquals(Integer.MAX_VALUE, s1.getMaximumItemCount());",
        "ins2PreCode":"public void testSetMaximumItemCount() { XYIntervalSeries s1 = new XYIntervalSeries(\"S1\"); assertEquals(Integer.MAX_VALUE, s1.getMaximumItemCount());",
        "label":1
    },
    {
        "ins1CurCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete();",
        "ins1PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "ins2PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1CurCode":"private static JFreeChart createWaterfallChart() { Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}}; CategoryDataset<String, String> dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart(\"Waterfall Chart\",",
        "ins1PreCode":"Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart(\"Waterfall Chart\",",
        "ins2PreCode":"Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedAreaChart( \"Stacked Area Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true ); ",
        "label":1
    },
    {
        "ins1CurCode":"  Map<String, JarEntry> genericEntries = genericJar.stream() .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b));   Map<String, JarEntry> wasEntries = wasJar.stream() .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b));   genericLoader = getClassLoaderFromJar(genericJarFile);  Map<String, JarEntry> replaceEntries = new HashMap<>(); for (String filepath : genericEntries.keySet()) {",
        "ins1PreCode":"  Hashtable<String, JarEntry> genericEntries = StreamUtils.enumerationAsStream(genericJar.entries()) .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b, Hashtable::new));   Hashtable<String, JarEntry> wasEntries = StreamUtils.enumerationAsStream(wasJar.entries()) .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));   genericLoader = getClassLoaderFromJar(genericJarFile);  Hashtable<String, JarEntry> replaceEntries = new Hashtable<>(); for (String filepath : genericEntries.keySet()) {",
        "ins2PreCode":"wlJar = new JarFile(weblogicJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath);  if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) { ",
        "label":0
    },
    {
        "ins1CurCode":"public void testMalformed05() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.005a,en-gb;q=0.5\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testMalformed05() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.005a\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testMalformed06() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.00005a\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command) {",
        "ins2PreCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command) {",
        "label":1
    },
    {
        "ins1CurCode":"nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins1PreCode":"nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins2PreCode":"nMatchingItems++; } fireNodesInserted(path, childIndices, children); }",
        "label":1
    },
    {
        "ins1CurCode":"Object element, String property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.log(Level.WARNING, \"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.log(Level.FINE, \"Attempted duplicate registration of event listener\" + \" - Element: {0} Listener: {1}\", new Object[]{element, listener}); }",
        "ins1PreCode":"Object element, String property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener); }",
        "ins2PreCode":"Object element) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, null}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element); } else { LOG.warn(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener);",
        "label":0
    },
    {
        "ins1CurCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<>(); ",
        "ins1PreCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<Thread>(); ",
        "ins2PreCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<Thread>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void onSuccessCleansUp() { TestResourceSingleObserver<Integer> rso = new TestResourceSingleObserver<>(); ",
        "ins1PreCode":"public void onSuccessCleansUp() { TestResourceSingleObserver<Integer> rso = new TestResourceSingleObserver<Integer>(); ",
        "ins2PreCode":"public void onErrorCleansUp() { TestResourceSingleObserver<Integer> rso = new TestResourceSingleObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public boolean performFinish() { try { DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try {",
        "ins1PreCode":"public boolean performFinish() { try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try {",
        "ins2PreCode":"final ProjectExportData exportData = mainPage.getExportData(); try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try {",
        "label":1
    },
    {
        "ins1CurCode":"public void observeOnNormal() throws InterruptedException { final AtomicReference<String> name = new AtomicReference<>(); final AtomicReference<Throwable> err = new AtomicReference<>(); final CountDownLatch cdl = new CountDownLatch(1);",
        "ins1PreCode":"public void observeOnNormal() throws InterruptedException { final AtomicReference<String> name = new AtomicReference<String>(); final AtomicReference<Throwable> err = new AtomicReference<Throwable>(); final CountDownLatch cdl = new CountDownLatch(1);",
        "ins2PreCode":"public void observeOnError() throws InterruptedException { final AtomicReference<String> name = new AtomicReference<String>(); final AtomicReference<Throwable> err = new AtomicReference<Throwable>(); final CountDownLatch cdl = new CountDownLatch(1);",
        "label":1
    },
    {
        "ins1CurCode":"public Object getObject(Object key) { Object result = null; @SuppressWarnings(\"unchecked\") WeakReference<Object> weakReference = (WeakReference<Object>) delegate.getObject(key); if (weakReference != null) {",
        "ins1PreCode":"public Object getObject(Object key) { Object result = null; WeakReference weakReference = (WeakReference) delegate.getObject(key); if (weakReference != null) {",
        "ins2PreCode":"public Object getObject(Object key) { Object result = null; SoftReference softReference = (SoftReference) delegate.getObject(key); if (softReference != null) {",
        "label":1
    },
    {
        "ins1CurCode":"private List<XYDataset> getDatasetsMappedToDomainAxis(Integer axisIndex) { Args.nullNotPermitted(axisIndex, \"axisIndex\"); List<XYDataset> result = new ArrayList<XYDataset>();",
        "ins1PreCode":"private List<XYDataset> getDatasetsMappedToDomainAxis(Integer axisIndex) { ParamChecks.nullNotPermitted(axisIndex, \"axisIndex\"); List<XYDataset> result = new ArrayList<XYDataset>();",
        "ins2PreCode":"private List<XYDataset> getDatasetsMappedToRangeAxis(Integer axisIndex) { ParamChecks.nullNotPermitted(axisIndex, \"axisIndex\"); List<XYDataset> result = new ArrayList<XYDataset>();",
        "label":1
    },
    {
        "ins1CurCode":"ArrayList c = new ArrayList(Model.getFacade().getIncomings(getTarget())); if (Model.getFacade().getUmlVersion().startsWith(\"1\") && Model.getFacade().isAState(getTarget())) { ArrayList i =",
        "ins1PreCode":"ArrayList c = new ArrayList(Model.getFacade().getIncomings(getTarget())); if (Model.getFacade().isAState(getTarget())) { ArrayList i =",
        "ins2PreCode":"ArrayList c = new ArrayList(Model.getFacade().getIncomings(getTarget())); if (Model.getFacade().isAState(getTarget())) { ArrayList i =",
        "label":1
    },
    {
        "ins1CurCode":"public static <T, R> Flowable<R> combineLatestArray(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } Objects.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } ObjectHelper.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"return empty(); } ObjectHelper.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":0
    },
    {
        "ins1CurCode":"void parseRecognizesAbsoluteFile() throws IOException { ParserResult result = parser",
        "ins1PreCode":"public void parseRecognizesAbsoluteFile() throws IOException { ParserResult result = parser",
        "ins2PreCode":"public void parseRecognizesDateFieldWithConcatenation() throws IOException { ParserResult result = parser",
        "label":1
    },
    {
        "ins1CurCode":"public void hasNextThrows() { Single.zip(new CrashingMappedIterable<>(100, 20, 100, new Function<Integer, Single<Integer>>() { @Override",
        "ins1PreCode":"public void hasNextThrows() { Single.zip(new CrashingMappedIterable<Single<Integer>>(100, 20, 100, new Function<Integer, Single<Integer>>() { @Override",
        "ins2PreCode":"public void nextThrows() { Single.zip(new CrashingMappedIterable<Single<Integer>>(100, 100, 5, new Function<Integer, Single<Integer>>() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"public void defaultPropertyAsFallback() { this.environment.getPropertySources()",
        "ins1PreCode":"public void defaultPropertyAsFallback() throws Exception { this.environment.getPropertySources()",
        "ins2PreCode":"public void defaultPropertyAsFallbackDuringFileParsing() throws Exception { this.environment.getPropertySources()",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public void multipleErrors() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins1PreCode":"public void multipleErrors() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins2PreCode":"public void multipleErrors() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, xAxis, yAxis, renderer); ",
        "ins1PreCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); ",
        "ins2PreCode":"NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); ",
        "label":1
    },
    {
        "ins1CurCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasBinaryContent(new byte[] { 3 }); }",
        "ins1PreCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "ins2PreCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerialization() { DefaultPieDataset<String> d1 = new DefaultPieDataset<>(); d1.setValue(\"C1\", 234.2); d1.setValue(\"C2\", null); d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7);  DefaultPieDataset<String> d2 = (DefaultPieDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"public void testSerialization() { DefaultPieDataset d1 = new DefaultPieDataset(); d1.setValue(\"C1\", 234.2); d1.setValue(\"C2\", null); d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7);  DefaultPieDataset d2 = (DefaultPieDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testSerialization() { DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); d1.setValue(\"C1\", 234.2); d1.setValue(\"C2\", null); d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7);  KeyedValuesDataset d2 = (KeyedValuesDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":1
    },
    {
        "ins1CurCode":"public void parseLevels() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins1PreCode":"public void parseLevels() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins2PreCode":"public void parseLevelsCaseInsensitive() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "label":1
    },
    {
        "ins1CurCode":"public void disabled() { SpringApplication application = new SpringApplication(Config.class);",
        "ins1PreCode":"public void disabled() throws Exception { SpringApplication application = new SpringApplication(Config.class);",
        "ins2PreCode":"public void enabled() { SpringApplication application = new SpringApplication(Config.class); application.setWebApplicationType(WebApplicationType.NONE); Map<String, Object> props = new HashMap<>(); props.put(\"spring.output.ansi.enabled\", \"ALWAYS\"); application.setDefaultProperties(props); this.context = application.run(); assertThat(AnsiOutputEnabledValue.get()).isEqualTo(Enabled.ALWAYS);",
        "label":0
    },
    {
        "ins1CurCode":"void gitFullDetailsAlwaysPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\").run((context) -> {",
        "ins1PreCode":"public void gitFullDetailsAlwaysPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\").run((context) -> {",
        "ins2PreCode":"public void gitFullDetailsAlwaysPresent() { this.contextRunner.withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO))",
        "label":1
    },
    {
        "ins1CurCode":"void movesFileWithFileDirPattern() { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"[entrytype]\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"Misc\").resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", Path.of(\"Misc/test.pdf\"), \"\"))), entry.getField(StandardField.FILE));",
        "ins1PreCode":"void movesFileWithFileDirPattern() throws Exception { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"[entrytype]\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"Misc\").resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"Misc/test.pdf\", \"\"))), entry.getField(StandardField.FILE));",
        "ins2PreCode":"void movesFileWithSubdirectoryPattern() throws Exception { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"[entrytype]/[year]/[auth]\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"Misc\").resolve(\"1989\").resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"Misc/1989/test.pdf\", \"\"))), entry.getField(StandardField.FILE));",
        "label":1
    },
    {
        "ins1CurCode":"private int jjMoveStringLiteralDfa7_1(long old0, long active0) {",
        "ins1PreCode":"private final int jjMoveStringLiteralDfa7_1(long old0, long active0) {",
        "ins2PreCode":"private final int jjMoveStringLiteralDfa8_1(long old0, long active0) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testInsert() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH)) { User user1 = new User(null, \"Pocoyo\"); sqlSession.insert(\"insert\", user1); User user2 = new User(null, \"Valentina\"); sqlSession.insert(\"insert\", user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); } try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<User> users = sqlSession.selectList(\"select\");",
        "ins1PreCode":"public void testInsert() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { User user1 = new User(null, \"Pocoyo\"); sqlSession.insert(\"insert\", user1); User user2 = new User(null, \"Valentina\"); sqlSession.insert(\"insert\", user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); } try { sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertJdbc3() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { User user1 = new User(null, \"Pocoyo\"); sqlSession.insert(\"insertIdentity\", user1); User user2 = new User(null, \"Valentina\"); sqlSession.insert(\"insertIdentity\", user2); sqlSession.flushStatements(); assertEquals(Integer.valueOf(0), user1.getId()); assertEquals(Integer.valueOf(1), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); }  try { sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"selectIdentity\"); Assert.assertTrue(users.size() == 2); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"void getAccessLevelWhenTokenIsNotValidShouldThrowException() throws Exception { prepareResponse((response) -> response.setResponseCode(401));",
        "ins1PreCode":"public void getAccessLevelWhenTokenIsNotValidShouldThrowException() throws Exception { prepareResponse((response) -> response.setResponseCode(401));",
        "ins2PreCode":"public void getAccessLevelWhenForbiddenShouldThrowException() throws Exception { prepareResponse((response) -> response.setResponseCode(403));",
        "label":1
    },
    {
        "ins1CurCode":"Millisecond m = new Millisecond(500, 50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-623289609500L, m.getFirstMillisecond(cal));   boolean pass = false; try { m.getFirstMillisecond((Calendar) null); }",
        "ins1PreCode":"Millisecond m = new Millisecond(500, 50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-623289609500L, m.getFirstMillisecond(zone));   boolean pass = false; try { m.getFirstMillisecond((TimeZone) null); }",
        "ins2PreCode":"Millisecond m = new Millisecond(750, 55, 1, 2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-614962684250L, m.getLastMillisecond(zone));   boolean pass = false; try { m.getLastMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"TestMap.EnumValue.BAR.getNumber(), builder.getInt32ToEnumFieldValueOrThrow(1)); builder.putInt32ToEnumFieldValue(1, -1); assertEquals(-1, builder.getInt32ToEnumFieldValueOrThrow(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, builder.getInt32ToEnumFieldOrThrow(1)); ",
        "ins1PreCode":"builder.putInt32ToEnumFieldValue(1, -1); fail(); } catch (IllegalArgumentException e) { ",
        "ins2PreCode":"public void testPut() { TestMap.Builder builder = TestMap.newBuilder(); builder.putInt32ToInt32Field(1, 11); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1));  builder.putInt32ToStringField(1, \"a\"); assertEquals(\"a\", builder.getInt32ToStringFieldOrThrow(1)); try { builder.putInt32ToStringField(1, null); fail(); } catch (NullPointerException e) {  }  builder.putInt32ToBytesField(1, TestUtil.toBytes(\"11\")); assertEquals(TestUtil.toBytes(\"11\"), builder.getInt32ToBytesFieldOrThrow(1)); try { builder.putInt32ToBytesField(1, null); fail(); } catch (NullPointerException e) {  }  builder.putInt32ToEnumField(1, TestMap.EnumValue.FOO); assertEquals(TestMap.EnumValue.FOO, builder.getInt32ToEnumFieldOrThrow(1)); try { builder.putInt32ToEnumField(1, null); fail(); } catch (NullPointerException e) {  }  builder.putStringToInt32Field(\"a\", 1); assertEquals(1, builder.getStringToInt32FieldOrThrow(\"a\")); try { builder.putStringToInt32Field(null, -1); } catch (NullPointerException e) {  }",
        "label":0
    },
    {
        "ins1CurCode":"UTF8String remain = pad.substring(0, spaces - padChars * count);  int resultSize = Math.toIntExact((long)numBytes + pad.numBytes * count + remain.numBytes); byte[] data = new byte[resultSize]; copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes);",
        "ins1PreCode":"UTF8String remain = pad.substring(0, spaces - padChars * count);  byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes);",
        "ins2PreCode":"UTF8String remain = pad.substring(0, spaces - padChars * count);  byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; ",
        "label":1
    },
    {
        "ins1CurCode":"final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(MockOptInProtocol1.NAME); newProtocols.add(MockOptInProtocol2.NAME); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save();  final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertProtocolEnabled(MockOptInProtocol1.NAME, \"before the roundtrip\"); assertProtocolEnabled(MockOptInProtocol2.NAME, \"before the roundtrip\");  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"There should be two additional enabled protocols\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 2)); assertProtocolEnabled(MockOptInProtocol1.NAME, \"after the roundtrip\"); assertProtocolEnabled(MockOptInProtocol2.NAME, \"after the roundtrip\");",
        "ins1PreCode":"public void agentProtocols_multipleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\"))); Assume.assumeThat(\"We assume that JNLP4-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP4-connect\")));  final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); newProtocols.add(\"JNLP4-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\")); assertThat(\"JNLP4-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP4-connect\"));  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have two additional enabled protocols\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 2)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\")); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP4-connect\"));",
        "ins2PreCode":"public void agentProtocols_singleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\")));  final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\"));  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have additional enabled protocol\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 1)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void setUp() { fetcher = new IsbnFetcher(mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS)); ",
        "ins1PreCode":"public void setUp() { fetcher = new IsbnFetcher(JabRefPreferences.getInstance().getImportFormatPreferences()); ",
        "ins2PreCode":"bibEntry.setField(\"url\", \"http://www.ebook.de/de/product/6441328/joshua_bloch_effective_java.html\");  fetcher = new IsbnViaEbookDeFetcher(JabRefPreferences.getInstance().getImportFormatPreferences());",
        "label":1
    },
    {
        "ins1CurCode":"{ PomTestWrapper pom = buildPom( \"plugin-exec-inheritance/wo-merge\" ); @SuppressWarnings( \"unchecked\" ) List<PluginExecution> executions =",
        "ins1PreCode":"{ PomTestWrapper pom = buildPom( \"plugin-exec-inheritance/wo-merge\" ); List<PluginExecution> executions = (List<PluginExecution>) pom.getValue( \"build/pluginsAsMap[@name='org.apache.maven.its.plugins:maven-it-plugin-log-file']/executions\" );",
        "ins2PreCode":"{ PomTestWrapper pom = buildPom( \"plugin-exec-inheritance/w-merge\" ); List<PluginExecution> executions = (List<PluginExecution>) pom.getValue( \"build/pluginsAsMap[@name='org.apache.maven.its.plugins:maven-it-plugin-log-file']/executions\" );",
        "label":1
    },
    {
        "ins1CurCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "ins1PreCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins2PreCode":"public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, Collections.unmodifiableSet(new LinkedHashSet<>(interceptors)));",
        "label":0
    },
    {
        "ins1CurCode":"} } finally { executor.close(false); }",
        "ins1PreCode":"} } finally { executor.rollback(true); executor.close(false);",
        "ins2PreCode":"public void shouldSelect2DiscriminatedPosts() throws Exception {  Executor executor = createExecutor(new JdbcTransaction(ds, null, false)); try { MappedStatement selectStatement = ExecutorTestHelper.prepareSelectDiscriminatedPost(config); List<Map<String,String>> products = executor.query(selectStatement, null, new RowBounds(2, 2), Executor.NO_RESULT_HANDLER); assertEquals(2, products.size()); for (Map<String,String> m : products) { if (\"IMAGES\".equals(m.get(\"SECTION\"))) { assertNull(m.get(\"subject\")); } else { assertNotNull(m.get(\"subject\")); } } } finally { executor.rollback(true); executor.close(false); }",
        "label":0
    },
    {
        "ins1CurCode":"PieDataset result = null; try { SAXParser parser = getSAXParserFactory().newSAXParser(); PieDatasetHandler handler = new PieDatasetHandler(); parser.parse(in, handler); result = handler.getDataset(); } catch (SAXException e) { throw new RuntimeException(e); } catch (ParserConfigurationException e2) { throw new RuntimeException(e2); }",
        "ins1PreCode":"public static PieDataset readPieDatasetFromXML(InputStream in) throws IOException {  PieDataset result = null; SAXParserFactory factory = SAXParserFactory.newInstance(); try { SAXParser parser = factory.newSAXParser(); PieDatasetHandler handler = new PieDatasetHandler(); parser.parse(in, handler); result = handler.getDataset(); } catch (SAXException e) { System.out.println(e.getMessage()); } catch (ParserConfigurationException e2) { System.out.println(e2.getMessage()); } return result; ",
        "ins2PreCode":"public static CategoryDataset readCategoryDatasetFromXML(InputStream in) throws IOException {  CategoryDataset result = null;  SAXParserFactory factory = SAXParserFactory.newInstance(); try { SAXParser parser = factory.newSAXParser(); CategoryDatasetHandler handler = new CategoryDatasetHandler(); parser.parse(in, handler); result = handler.getDataset(); } catch (SAXException e) { System.out.println(e.getMessage()); } catch (ParserConfigurationException e2) { System.out.println(e2.getMessage()); } return result; ",
        "label":1
    },
    {
        "ins1CurCode":"} } if (servletPath != null) { DispatcherServletPathProvider pathProvider = () -> servletPath;",
        "ins1PreCode":"} } DispatcherServletPathProvider pathProvider = () -> servletPath; context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider);",
        "ins2PreCode":"private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, PathMappedEndpoints pathMappedEndpoints) { StaticApplicationContext context = new StaticApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context.getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } return assertThat(new RequestMatcherAssert(context, matcher));",
        "label":0
    },
    {
        "ins1CurCode":"public void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput capturedOutput) { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") .run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(capturedOutput).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins1PreCode":"public void afterMaxUrisReachedFurtherUrisAreDenied() { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") .run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.output.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins2PreCode":"public void afterMaxUrisReachedFurtherUrisAreDenied() { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") .run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.output.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "label":1
    },
    {
        "ins1CurCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i, srcOffset += 4) { intData[i + rowId] = Platform.getInt(src, srcOffset); if (bigEndianPlatform) { intData[i + rowId] = java.lang.Integer.reverseBytes(intData[i + rowId]); }",
        "ins1PreCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { intData[i + rowId] = Platform.getInt(src, srcOffset); srcIndex += 4; srcOffset += 4; }",
        "ins2PreCode":"public void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { longData[i + rowId] = Platform.getLong(src, srcOffset); srcIndex += 8; srcOffset += 8; }",
        "label":1
    },
    {
        "ins1CurCode":"}  Assert.assertEquals(Response.SC_NOT_FOUND, rc); Assert.assertEquals(\"InitErrorDestroy\", trace.toString());",
        "ins1PreCode":"}  assertEquals(Response.SC_NOT_FOUND, rc); assertEquals(\"InitErrorDestroy\", trace.toString());",
        "ins2PreCode":"}  assertEquals(Response.SC_NOT_FOUND, rc); assertEquals(\"InitErrorDestroy\", trace.toString());",
        "label":1
    },
    {
        "ins1CurCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views); result.sort(new Comparator<View>() { @Override",
        "ins1PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<View>(views); Collections.sort(result, new Comparator<View>() { @Override",
        "ins2PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views); Collections.sort(result, new Comparator<View>() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"final ConnectableFlowable<Integer> cf = pp.replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<>(); ",
        "ins1PreCode":"final ConnectableFlowable<Integer> cf = pp.replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"final ConnectableFlowable<Integer> cf = pp.replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public Set<Map.Entry<K,V>> entrySet() { LinkedHashSet<Map.Entry<K,V>> set = new LinkedHashSet<Map.Entry<K,V>>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry<K,V> entry = innerMap.get(key); if ( entry != null && entry.isActive() ) { set.add(entry); }",
        "ins1PreCode":"public Set<MapEntry> entrySet() { LinkedHashSet<MapEntry> set = new LinkedHashSet<MapEntry>(super.size()); Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry != null && entry.isActive() ) { set.add(new MapEntry(key, entry.getValue())); }",
        "ins2PreCode":"public Set<Object> keySet() {   LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isActive() ) set.add(key);",
        "label":0
    },
    {
        "ins1CurCode":"public void appendOnlyLinkedArrayListForEachWhilePreGrow() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<>(12);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<>(); ",
        "ins1PreCode":"public void appendOnlyLinkedArrayListForEachWhilePreGrow() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(12);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void appendOnlyLinkedArrayListForEachWhileExact() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(3);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"}  DebounceInnerObserver<T, U> dis = new DebounceInnerObserver<>(this, idx, t); ",
        "ins1PreCode":"}  DebounceInnerObserver<T, U> dis = new DebounceInnerObserver<T, U>(this, idx, t); ",
        "ins2PreCode":"}  DebounceInnerSubscriber<T, U> dis = new DebounceInnerSubscriber<T, U>(this, idx, t); ",
        "label":1
    },
    {
        "ins1CurCode":"Settings settings = Settings.builder() .put(\"network.host\", host) .put(TransportSettings.PORT.getKey(), 0) .put(\"transport.profiles.client1.port\", 0)",
        "ins1PreCode":"Settings settings = Settings.builder() .put(\"network.host\", host) .put(TcpTransport.PORT.getKey(), 0) .put(\"transport.profiles.client1.port\", 0)",
        "ins2PreCode":"Settings settings = Settings.builder() .put(\"network.host\", host) .put(TcpTransport.PORT.getKey(), 22) .put(\"transport.profiles.default.port\", 0)",
        "label":1
    },
    {
        "ins1CurCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins1PreCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins2PreCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle());",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals( \"5: 1\\n\" + \"5: 0x00000002\\n\" + \"5: 0x0000000000000003\\n\" + \"5: \\\"4\\\"\\n\" + \"5: {\\n\" + \"  12: 6\\n\" + \"}\\n\" + \"5 {\\n\" + \"  10: 5\\n\" + \"}\\n\" + \"8: 1\\n\" + \"8: 2\\n\" + \"8: 3\\n\" + \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "ins1PreCode":" assertEquals( \"5: 1\\n\" + \"5: 0x00000002\\n\" + \"5: 0x0000000000000003\\n\" + \"5: \\\"4\\\"\\n\" + \"5 {\\n\" + \"  10: 5\\n\" + \"}\\n\" + \"8: 1\\n\" + \"8: 2\\n\" + \"8: 3\\n\" + \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "ins2PreCode":"public void testPrintUnknownFields() throws Exception {   TestEmptyMessage message = TestEmptyMessage.newBuilder() .setUnknownFields(makeUnknownFieldSet()) .build();  assertEquals( \"5: 1\\n\" + \"5: 0x00000002\\n\" + \"5: 0x0000000000000003\\n\" + \"5: \\\"4\\\"\\n\" + \"5 {\\n\" + \"  10: 5\\n\" + \"}\\n\" + \"8: 1\\n\" + \"8: 2\\n\" + \"8: 3\\n\" + \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "label":0
    },
    {
        "ins1CurCode":"long contentLength = event.getTransferredBytes();  FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH ); String result = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = format.format( contentLength );  String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0L ) { double bytesPerSecond = contentLength / ( duration / 1000.0 ); throughput = \" at \" + format.format( (long) bytesPerSecond ) + \"/s\"; }  out.println( result + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" );",
        "ins1PreCode":"TransferResource resource = event.getResource(); long contentLength = event.getTransferredBytes(); if ( contentLength >= 0 ) { String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\";  String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0 ) { DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) ); double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 ); throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\"; }  out.println( type + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" );",
        "ins2PreCode":"TransferResource resource = event.getResource(); long contentLength = event.getTransferredBytes(); if ( contentLength >= 0 ) { String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\";  String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0 ) { DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) ); double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 ); throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\"; }  out.info( type + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" );",
        "label":1
    },
    {
        "ins1CurCode":"void customExceptionConversionWord(CapturedOutput output) { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); assertThat(output).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); }",
        "ins1PreCode":"public void customExceptionConversionWord() { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf(containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput)); }",
        "ins2PreCode":"public void customExceptionConversionWord() { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf(containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput)); }",
        "label":1
    },
    {
        "ins1CurCode":"throws ArtifactMetadataRetrievalException { Set<Artifact> dependencies = new HashSet<>(); ",
        "ins1PreCode":"throws ArtifactMetadataRetrievalException { Set dependencies = new HashSet(); ",
        "ins2PreCode":"throws ArtifactMetadataRetrievalException { Set dependencies = new HashSet(); ",
        "label":1
    },
    {
        "ins1CurCode":"TestMap message = builder.build();  String textData = TextFormat.printer().printToString(message); ",
        "ins1PreCode":"TestMap message = builder.build();  String textData = TextFormat.printToString(message); ",
        "ins2PreCode":"TestMap message = builder.build();  String textData = TextFormat.printToString(message); ",
        "label":1
    },
    {
        "ins1CurCode":"StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.eclipse.aether.artifact.Artifact art = dep.getArtifact(); ",
        "ins1PreCode":"StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.sonatype.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.sonatype.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ).append( \")\" ); }  if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ).append( \")\" ); }",
        "ins2PreCode":"StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.sonatype.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.sonatype.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ); appendManagementSource( buffer, art, \"scope\" ); buffer.append( \")\" ); }  if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ); appendManagementSource( buffer, art, \"version\" );",
        "label":0
    },
    {
        "ins1CurCode":"if (popup.getComponentCount() > 0) { initActions(); LOG.log(Level.INFO, \"Showing popup at \" + e.getX() + \",\" + e.getY()); getPopupMenu().show(this, e.getX(), e.getY());",
        "ins1PreCode":"if (popup.getComponentCount() > 0) { initActions(); LOG.info(\"Showing popup at \" + e.getX() + \",\" + e.getY()); getPopupMenu().show(this, e.getX(), e.getY());",
        "ins2PreCode":"if (popup.getComponentCount() > 0) { initActions(); LOG.debug(\"Showing popup at \" + e.getX() + \",\" + e.getY()); getPopupMenu().show(this, e.getX(), e.getY());",
        "label":0
    },
    {
        "ins1CurCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-fragments\"); ",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0-fragments\"); ",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0-fragments\"); ",
        "label":1
    },
    {
        "ins1CurCode":"figNode = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.log(Level.FINE, \"TODO: StateDiagramRenderer getFigNodeFor\"); ",
        "ins1PreCode":"figNode = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.debug(\"TODO: StateDiagramRenderer getFigNodeFor\"); throw new IllegalArgumentException(",
        "ins2PreCode":"figNode = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.error(\"TODO: CollabDiagramRenderer getFigNodeFor\"); throw new IllegalArgumentException(",
        "label":0
    },
    {
        "ins1CurCode":"public void testClear() { XIntervalSeries<String> s1 = new XIntervalSeries<>(\"S1\"); s1.addChangeListener(this);",
        "ins1PreCode":"public void testClear() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); s1.addChangeListener(this);",
        "ins2PreCode":"public void testClear() { XYIntervalSeries s1 = new XYIntervalSeries(\"S1\"); s1.addChangeListener(this);",
        "label":1
    },
    {
        "ins1CurCode":"if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ArrayValuesSourceAggregationBuilder<?> other = (ArrayValuesSourceAggregationBuilder<?>) obj; return Objects.equals(fields, other.fields) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(userValueTypeHint, other.userValueTypeHint);",
        "ins1PreCode":"if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ArrayValuesSourceAggregationBuilder<?, ?> other = (ArrayValuesSourceAggregationBuilder<?, ?>) obj; return Objects.equals(fields, other.fields) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(valueType, other.valueType) && Objects.equals(valuesSourceType, other.valuesSourceType);",
        "ins2PreCode":"if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ValuesSourceAggregationBuilder<?, ?> other = (ValuesSourceAggregationBuilder<?, ?>) obj; return Objects.equals(valuesSourceType, other.valuesSourceType) && Objects.equals(field, other.field) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(script, other.script) && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(timeZone, other.timeZone) && Objects.equals(valueType, other.valueType);",
        "label":0
    },
    {
        "ins1CurCode":"void initFieldsShouldSetNullFields() { InitFieldsTestClass test = new InitFieldsTestClass();",
        "ins1PreCode":"public void initFieldsShouldSetNullFields() { InitFieldsTestClass test = new InitFieldsTestClass();",
        "ins2PreCode":"public void initFieldsShouldSetNullFields() { InitFieldsTestClass test = new InitFieldsTestClass();",
        "label":1
    },
    {
        "ins1CurCode":"void shouldGetUsersByNameUsingMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldGetUsersByNameUsingMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetUsersByNameWithParamNameAndOrderBy() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"String processorTag = randomAlphaOfLength(10);  GeoIpProcessor processor = factory.create(null, processorTag, null, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins1PreCode":"String processorTag = randomAlphaOfLength(10);  GeoIpProcessor processor = factory.create(null, processorTag, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins2PreCode":"String processorTag = randomAlphaOfLength(10);  AttachmentProcessor processor = factory.create(null, processorTag, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"XYLineAndShapeRenderer clone = (XYLineAndShapeRenderer) super.clone(); clone.seriesLinesVisibleMap = new HashMap<>(this.seriesLinesVisibleMap); clone.legendLine = CloneUtils.clone(this.legendLine); clone.seriesShapesVisibleMap = new HashMap<>(this.seriesShapesVisibleMap);",
        "ins1PreCode":"XYLineAndShapeRenderer clone = (XYLineAndShapeRenderer) super.clone(); clone.seriesLinesVisibleMap = new HashMap<>(this.seriesLinesVisibleMap); if (this.legendLine != null) { clone.legendLine = ShapeUtils.clone(this.legendLine); }",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { LineAndShapeRenderer clone = (LineAndShapeRenderer) super.clone(); clone.seriesLinesVisibleMap = new HashMap<>(this.seriesLinesVisibleMap); clone.seriesShapesVisibleMap = new HashMap<>(this.seriesShapesVisibleMap); clone.seriesShapesFilledMap = new HashMap<>(this.seriesShapesFilledMap); return clone;",
        "label":0
    },
    {
        "ins1CurCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  spMapper.adderAsSelect(parameter); assertEquals((Integer) 5, parameter.getSum());  parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); spMapper.adderAsSelect(parameter); assertEquals((Integer) 5, parameter.getSum());",
        "ins1PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum());  parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum());",
        "ins2PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum());  parameter = new Parameter(); parameter.setAddend1(4); parameter.setAddend2(5); spMapper.adder(parameter); assertEquals((Integer) 9, parameter.getSum());",
        "label":1
    },
    {
        "ins1CurCode":"List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');",
        "ins1PreCode":"List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(filesDirectory)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');",
        "ins2PreCode":"List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(filesDirectory)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[bibtexkey].*\\\\\\\\.[extension]\", ',');",
        "label":1
    },
    {
        "ins1CurCode":"given(securityService.getAccessLevel(any(), eq(\"app-id\"))) .willReturn(Mono.just(AccessLevel.FULL)); this.contextRunner.run(withWebTestClient((client) -> client.get() .uri(\"/cfApplication\").accept(MediaType.APPLICATION_JSON) .header(\"Authorization\", \"bearer \" + mockAccessToken()).exchange() .expectStatus().isOk().expectBody().jsonPath(\"_links.length()\") .isEqualTo(5).jsonPath(\"_links.self.href\").isNotEmpty() .jsonPath(\"_links.self.templated\").isEqualTo(false) .jsonPath(\"_links.info.href\").isNotEmpty() .jsonPath(\"_links.info.templated\").isEqualTo(false) .jsonPath(\"_links.env.href\").isNotEmpty().jsonPath(\"_links.env.templated\") .isEqualTo(false).jsonPath(\"_links.test.href\").isNotEmpty() .jsonPath(\"_links.test.templated\").isEqualTo(false) .jsonPath(\"_links.test-part.href\").isNotEmpty() .jsonPath(\"_links.test-part.templated\").isEqualTo(true)));",
        "ins1PreCode":"given(securityService.getAccessLevel(any(), eq(\"app-id\"))) .willReturn(Mono.just(AccessLevel.FULL)); load(TestEndpointConfiguration.class, (client) -> client.get() .uri(\"/cfApplication\").accept(MediaType.APPLICATION_JSON) .header(\"Authorization\", \"bearer \" + mockAccessToken()).exchange() .expectStatus().isOk().expectBody().jsonPath(\"_links.length()\") .isEqualTo(5).jsonPath(\"_links.self.href\").isNotEmpty() .jsonPath(\"_links.self.templated\").isEqualTo(false) .jsonPath(\"_links.info.href\").isNotEmpty() .jsonPath(\"_links.info.templated\").isEqualTo(false) .jsonPath(\"_links.env.href\").isNotEmpty().jsonPath(\"_links.env.templated\") .isEqualTo(false).jsonPath(\"_links.test.href\").isNotEmpty() .jsonPath(\"_links.test.templated\").isEqualTo(false) .jsonPath(\"_links.test-part.href\").isNotEmpty() .jsonPath(\"_links.test-part.templated\").isEqualTo(true));",
        "ins2PreCode":"public void linksToOtherEndpointsWithFullAccess() { given(securityService.getAccessLevel(any(), eq(\"app-id\"))) .willReturn(AccessLevel.FULL); load(TestEndpointConfiguration.class, (client) -> client.get().uri(\"/cfApplication\") .accept(MediaType.APPLICATION_JSON) .header(\"Authorization\", \"bearer \" + mockAccessToken()).exchange() .expectStatus().isOk().expectBody().jsonPath(\"_links.length()\") .isEqualTo(5).jsonPath(\"_links.self.href\").isNotEmpty() .jsonPath(\"_links.self.templated\").isEqualTo(false) .jsonPath(\"_links.info.href\").isNotEmpty() .jsonPath(\"_links.info.templated\").isEqualTo(false) .jsonPath(\"_links.env.href\").isNotEmpty() .jsonPath(\"_links.env.templated\").isEqualTo(false) .jsonPath(\"_links.test.href\").isNotEmpty() .jsonPath(\"_links.test.templated\").isEqualTo(false) .jsonPath(\"_links.test-part.href\").isNotEmpty() .jsonPath(\"_links.test-part.templated\").isEqualTo(true));",
        "label":0
    },
    {
        "ins1CurCode":"public void disposedOnCall() { final TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void disposedOnCall() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void disposedOnCall() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testPatternsDifferInCaseScanningInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"});",
        "ins1PreCode":"public void testPatternsDifferInCaseScanningInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"});",
        "ins2PreCode":"public void testParentDiffersInCaseScanningInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/beta/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"});",
        "label":1
    },
    {
        "ins1CurCode":"mappings.add(\"foo\", \"bar\"); mappings.add(\"baz\", \"boo\"); List<MimeMappings.Mapping> mappingList = new ArrayList<>(mappings.getAll()); assertThat(mappingList.get(0).getExtension()).isEqualTo(\"foo\");",
        "ins1PreCode":"mappings.add(\"foo\", \"bar\"); mappings.add(\"baz\", \"boo\"); List<MimeMappings.Mapping> mappingList = new ArrayList<>(); mappingList.addAll(mappings.getAll()); assertThat(mappingList.get(0).getExtension()).isEqualTo(\"foo\");",
        "ins2PreCode":"public void iterate() { MimeMappings mappings = new MimeMappings(); mappings.add(\"foo\", \"bar\"); mappings.add(\"baz\", \"boo\"); List<MimeMappings.Mapping> mappingList = new ArrayList<>(); for (MimeMappings.Mapping mapping : mappings) { mappingList.add(mapping); } assertThat(mappingList.get(0).getExtension()).isEqualTo(\"foo\"); assertThat(mappingList.get(0).getMimeType()).isEqualTo(\"bar\"); assertThat(mappingList.get(1).getExtension()).isEqualTo(\"baz\"); assertThat(mappingList.get(1).getMimeType()).isEqualTo(\"boo\");",
        "label":0
    },
    {
        "ins1CurCode":"public void testConstructor1() { YIntervalDataItem item1 = new YIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(Double.valueOf(1.0), item1.getX()); assertEquals(2.0, item1.getYValue(), EPSILON);",
        "ins1PreCode":"public void testConstructor1() { YIntervalDataItem item1 = new YIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(new Double(1.0), item1.getX()); assertEquals(2.0, item1.getYValue(), EPSILON);",
        "ins2PreCode":"public void testConstructor1() { XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(new Double(1.0), item1.getX()); assertEquals(2.0, item1.getXLowValue(), EPSILON); assertEquals(3.0, item1.getXHighValue(), EPSILON); assertEquals(4.0, item1.getYValue(), EPSILON);",
        "label":0
    },
    {
        "ins1CurCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); List<Country> countries = new ArrayList<>(); countries.add(new Country(\"China\", \"CN\"));",
        "ins1PreCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); List<Country> countries = new ArrayList<Country>(); countries.add(new Country(\"China\", \"CN\"));",
        "ins2PreCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); List<Country> countries = new ArrayList<Country>(); countries.add(new Country(\"China\", \"CN\"));",
        "label":1
    },
    {
        "ins1CurCode":"} } catch (IllegalModelElementConnectionException e1) { LOG.log(Level.SEVERE, \"Exception\", e1); }",
        "ins1PreCode":"} } catch (IllegalModelElementConnectionException e1) { LOG.error(\"Exception\", e1); }",
        "ins2PreCode":"} } catch (IllegalModelElementConnectionException e1) { LOG.error(\"Exception\", e1); }",
        "label":1
    },
    {
        "ins1CurCode":"windows.getAndIncrement();  ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(w); downstream.onNext(intercept); if (intercept.tryAbandon()) { w.onComplete();",
        "ins1PreCode":"windows.getAndIncrement();  downstream.onNext(w); }",
        "ins2PreCode":"if (emitted != requested.get()) { emitted++; downstream.onNext(w); } else {",
        "label":1
    },
    {
        "ins1CurCode":"public void setShowProperties(final boolean showem) { if (npSettings.isShowProperties() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES;  public void redo() { npSettings.setShowProperties(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { npSettings.setShowProperties(!showem); fireNotationEvent(key, showem, !showem);",
        "ins1PreCode":"public void setShowProperties(final boolean showem) { if (diaDefault.isShowProperties() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES;  public void redo() { diaDefault.setShowProperties(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { diaDefault.setShowProperties(!showem); fireNotationEvent(key, showem, !showem);",
        "ins2PreCode":"public void setShowTypes(final boolean showem) { if (diaDefault.isShowTypes() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_TYPES;  public void redo() { diaDefault.setShowTypes(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { diaDefault.setShowTypes(!showem); fireNotationEvent(key, showem, !showem);",
        "label":1
    },
    {
        "ins1CurCode":"p.setProperty( \"key2\", \"value2\" );  Map<String, String> values = new HashMap<>(); values.put( \"key\", \"${key}\" );",
        "ins1PreCode":"p.setProperty( \"key2\", \"value2\" );  Map<String, String> values = new HashMap<String, String>(); values.put( \"key\", \"${key}\" );",
        "ins2PreCode":"p.setProperty( \"key2\", \"value2\" );  Map<String, String> values = new HashMap<String, String>(); values.put( \"key\", \"val\" );",
        "label":1
    },
    {
        "ins1CurCode":"  Rectangle2D bounds = TextUtils.getTextBounds(tickLabel, g2, g2.getFontMetrics());",
        "ins1PreCode":"  Rectangle2D bounds = TextUtilities.getTextBounds(tickLabel, g2, g2.getFontMetrics());",
        "ins2PreCode":"  Rectangle2D bounds = TextUtilities.getTextBounds(tickLabel, g2, g2.getFontMetrics());",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"public void merge1000AsyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(to);",
        "ins1PreCode":"public void merge1000AsyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(to);",
        "ins2PreCode":"public void merge2000AsyncStreamOf100() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"  for (JarEntry je : wasEntries.values()) { if (je.getCompressedSize() == -1",
        "ins1PreCode":"  for (JarEntry je : Collections.list(wasEntries.elements())) { if (je.getCompressedSize() == -1",
        "ins2PreCode":"protected boolean isRebuildRequired(File genericJarFile, File weblogicJarFile) { boolean rebuild = false;  JarFile genericJar = null; JarFile wlJar = null; File newWLJarFile = null; JarOutputStream newJarStream = null; ClassLoader genericLoader = null;  try { log(\"Checking if weblogic Jar needs to be rebuilt for jar \" + weblogicJarFile.getName(), Project.MSG_VERBOSE);  if (genericJarFile.exists() && genericJarFile.isFile() && weblogicJarFile.exists() && weblogicJarFile.isFile()) {  genericJar = new JarFile(genericJarFile); wlJar = new JarFile(weblogicJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath);  if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) {   log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } else {   log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newWLJarFile.toPath())); newJarStream.setLevel(0);   for (JarEntry je : wlEntries.values()) { if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }  InputStream is;  if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage();  throw new BuildException(msg, ioe); } finally { FileUtils.close(genericJar); FileUtils.close(wlJar); FileUtils.close(newJarStream);  if (newJarStream != null) { try { FILE_UTILS.rename(newWLJarFile, weblogicJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true; } } if (genericLoader instanceof AntClassLoader) { @SuppressWarnings(\"resource\") AntClassLoader loader = (AntClassLoader) genericLoader; loader.cleanup(); } } return rebuild;",
        "label":0
    },
    {
        "ins1CurCode":"void processAndApplySetsDefaultProfiles(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext, this.environment, this.resourceLoader, this.additionalProfiles);",
        "ins1PreCode":"void processAndApplySetsDefaultProfiles(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles);",
        "ins2PreCode":"void processAndApplySetsActiveProfiles(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles);",
        "label":1
    },
    {
        "ins1CurCode":"SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); SlidingCategoryDataset<String, String> d2; d2 = CloneUtils.clone(d1); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset<String, String>) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\");",
        "ins1PreCode":"SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); SlidingCategoryDataset<String, String> d2; d2 = (SlidingCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\");",
        "ins2PreCode":"u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); SlidingCategoryDataset<String, String> d2 = (SlidingCategoryDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":0
    },
    {
        "ins1CurCode":"  Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\")); ",
        "ins1PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "ins2PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"private IoBuffer putShort(Pointer pointer, short value) { if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 2) { throw new BufferUnderflowException(); } for (int i = 0; i < 16; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 8 - i : i))); }",
        "ins1PreCode":"public IoBuffer putShort(short value) { if (remaining() < 2) { throw new BufferUnderflowException(); }  for (int i = 0; i < 16; i += 8) { put((byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 8 - i : i))); }",
        "ins2PreCode":"public IoBuffer putInt(int value) { if (remaining() < 4) { throw new BufferUnderflowException(); }  for (int i = 0; i < 32; i += 8) { put((byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 24 - i : i))); }",
        "label":0
    },
    {
        "ins1CurCode":"public void getAccessLevelWhenCloudControllerIsNotReachableThrowsException() throws Exception { prepareResponse((response) -> response.setResponseCode(500)); StepVerifier.create( this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeErrorWith((throwable) -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.SERVICE_UNAVAILABLE); }).verify(); expectRequest((request) -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION))",
        "ins1PreCode":"public void getAccessLevelWhenCloudControllerIsNotReachableThrowsException() throws Exception { prepareResponse(response -> response.setResponseCode(500)); StepVerifier.create( this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeErrorWith(throwable -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.SERVICE_UNAVAILABLE); }).verify(); expectRequest(request -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION))",
        "ins2PreCode":"public void getUaaUrlWhenCloudControllerUrlIsNotReachableShouldThrowException() throws Exception { prepareResponse(response -> response.setResponseCode(500)); StepVerifier.create(this.securityService.getUaaUrl()) .consumeErrorWith(throwable -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.SERVICE_UNAVAILABLE); }).verify(); expectRequest(request -> assertThat(request.getPath()) .isEqualTo(CLOUD_CONTROLLER + \"/info\"));",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> concat( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Flowable<T> concat( Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3, Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Observable<T> mergeDelayError( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-config-order/wo-plugin-mgmt\" ); String prefix = \"build/plugins[1]/executions[1]/configuration/\";",
        "ins1PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-config-order/wo-plugin-mngt\" ); String prefix = \"build/plugins[1]/executions[1]/configuration/\";",
        "ins2PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-config-order/w-plugin-mngt\" ); String prefix = \"build/plugins[1]/executions[1]/configuration/\";",
        "label":1
    },
    {
        "ins1CurCode":"public void predicateThrowsExceptionAndValueInCauseMessageFlowable() { TestSubscriberEx<Boolean> ts = new TestSubscriberEx<>(); final IllegalArgumentException ex = new IllegalArgumentException();",
        "ins1PreCode":"public void predicateThrowsExceptionAndValueInCauseMessageFlowable() { TestSubscriberEx<Boolean> ts = new TestSubscriberEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException();",
        "ins2PreCode":"public void predicateThrowsExceptionAndValueInCauseMessageFlowable() { TestSubscriberEx<Boolean> ts = new TestSubscriberEx<Boolean>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> aggregated = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(value -> (long) value._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), aggregated.collectAsList());",
        "ins1PreCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(value -> (long) value._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), agged.collectAsList());",
        "ins2PreCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(v -> (long)v._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), agged.collectAsList());",
        "label":1
    },
    {
        "ins1CurCode":"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {  TestSubscriber<Integer> ts = new TestSubscriber<>(1); Disposable d = Disposable.empty();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1CurCode":"});  assertEquals(\"1;\", bitset(x.bits[0])); assertEquals(\"6;\", bitset(x.bits[1]));",
        "ins1PreCode":"});  assertEquals(x.bits[0],1L<<1); assertEquals(x.bits[1],1L<<6);",
        "ins2PreCode":"});  assertEquals(x.bits[0],1L<<59); assertEquals(x.bits[1],1L<<8);",
        "label":0
    },
    {
        "ins1CurCode":"ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncIndexBySearchAction(bulkByScrollTask, logger, assigningClient, threadPool, scriptService, request, state, listener).start();",
        "ins1PreCode":"ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncIndexBySearchAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, state, listener).start();",
        "ins2PreCode":"clusterService.localNode(), () -> { ClusterState state = clusterService.state(); ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncDeleteByQueryAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, scriptService, listener).start();",
        "label":0
    },
    {
        "ins1CurCode":"configuration.setEnvironment(environment); configuration.addMapper(MultipleIncludePersonMapper.class); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);  initDb(sqlSessionFactory);  return sqlSessionFactory;",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(MultipleIncludePersonMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(MultipleReverseIncludePersonMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"public void loadTwoPropertiesFilesWithProfilesUsingAdditionalLocation() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins1PreCode":"public void loadTwoPropertiesFilesWithProfilesUsingAdditionalLocation() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1CurCode":"Day d = new Day(26, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-621187200000L, d.getFirstMillisecond(cal));   boolean pass = false; try { d.getFirstMillisecond((Calendar) null); }",
        "ins1PreCode":"Day d = new Day(26, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-621187200000L, d.getFirstMillisecond(zone));   boolean pass = false; try { d.getFirstMillisecond((TimeZone) null); }",
        "ins2PreCode":"Day d = new Day(1, 2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-628358400001L, d.getLastMillisecond(zone));   boolean pass = false; try { d.getLastMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"System.out.println(\"flatMapRangeAsyncLoop > \" + i); } TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); Flowable.range(0, 1000) .flatMap(new Function<Integer, Flowable<Integer>>() { final Random rnd = new Random(); @Override public Flowable<Integer> apply(Integer t) { Flowable<Integer> r = Flowable.just(t); if (rnd.nextBoolean()) { r = r.hide(); } return r; } }) .observeOn(Schedulers.computation()) .subscribe(ts);  ts.awaitDone(2500, TimeUnit.MILLISECONDS); if (ts.completions() == 0) { System.out.println(ts.values().size()); } ts.assertTerminated(); ts.assertNoErrors(); List<Integer> list = ts.values(); if (list.size() < 1000) { Set<Integer> set = new HashSet<>(list); for (int j = 0; j < 1000; j++) {",
        "ins1PreCode":"System.out.println(\"flatMapRangeAsyncLoop > \" + i); } TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); Flowable.range(0, 1000) .flatMap(new Function<Integer, Flowable<Integer>>() { final Random rnd = new Random(); @Override public Flowable<Integer> apply(Integer t) { Flowable<Integer> r = Flowable.just(t); if (rnd.nextBoolean()) { r = r.hide(); } return r; } }) .observeOn(Schedulers.computation()) .subscribe(ts);  ts.awaitDone(2500, TimeUnit.MILLISECONDS); if (ts.completions() == 0) { System.out.println(ts.values().size()); } ts.assertTerminated(); ts.assertNoErrors(); List<Integer> list = ts.values(); if (list.size() < 1000) { Set<Integer> set = new HashSet<Integer>(list); for (int j = 0; j < 1000; j++) {",
        "ins2PreCode":"System.out.println(\"flatMapRangeAsyncLoop > \" + i); } TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.range(0, 1000) .flatMap(new Function<Integer, Observable<Integer>>() { final Random rnd = new Random(); @Override public Observable<Integer> apply(Integer t) { Observable<Integer> r = Observable.just(t); if (rnd.nextBoolean()) { r = r.hide(); } return r; } }) .observeOn(Schedulers.computation()) .subscribe(to);  to.awaitDone(2500, TimeUnit.MILLISECONDS); if (to.completions() == 0) { System.out.println(to.values().size()); } to.assertTerminated(); to.assertNoErrors(); List<Integer> list = to.values(); if (list.size() < 1000) { Set<Integer> set = new HashSet<Integer>(list); for (int j = 0; j < 1000; j++) {",
        "label":1
    },
    {
        "ins1CurCode":"void bindToArrayWhenNestedShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToArrayWhenNestedShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToArrayWhenNestedListShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":" if (this.subplots != null) { for (XYPlot plot : this.subplots) { LegendItemCollection more = plot.getLegendItems();",
        "ins1PreCode":" if (this.subplots != null) { Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { XYPlot plot = (XYPlot) iterator.next(); LegendItemCollection more = plot.getLegendItems();",
        "ins2PreCode":"result = new LegendItemCollection(); if (this.subplots != null) { Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { XYPlot plot = (XYPlot) iterator.next(); LegendItemCollection more = plot.getLegendItems();",
        "label":1
    },
    {
        "ins1CurCode":"private final void onError(Throwable t) { if (listener == null) { return; } Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(applicationLoader); listener.onError(t); } catch (Throwable t2) { ExceptionUtils.handleThrowable(t2); log.warn(sm.getString(\"upgrade.sos.onErrorFail\"), t2); } finally { thread.setContextClassLoader(originalClassLoader); } try { close(); } catch (IOException ioe) { if (log.isDebugEnabled()) { log.debug(sm.getString(\"upgrade.sos.errorCloseFail\"), ioe); }",
        "ins1PreCode":"protected final void onError(Throwable t) { if (listener == null) {",
        "ins2PreCode":"protected final void onError(Throwable t) { if (listener == null) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindLiveItemsUpperBound_Ascending() { DefaultXYDataset<String> d = new DefaultXYDataset<String>() { @Override",
        "ins1PreCode":"public void testFindLiveItemsUpperBound_Ascending() { DefaultXYDataset d = new DefaultXYDataset() { @Override",
        "ins2PreCode":"public void testFindLiveItemsUpperBound_Unordered() { DefaultXYDataset d = new DefaultXYDataset(); ",
        "label":0
    },
    {
        "ins1CurCode":" PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType(); assertThat(document.getFields().size(), equalTo(4)); assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));",
        "ins1PreCode":" PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType(); assertThat(document.getFields().size(), equalTo(3)); assertThat(document.getFields().get(0).binaryValue().utf8ToString(), equalTo(\"field\\u0000term\"));",
        "ins2PreCode":"public void testExtractTermsAndRanges_failed() throws Exception { addQueryFieldMappings(); TermRangeQuery query = new TermRangeQuery(\"field1\", new BytesRef(\"a\"), new BytesRef(\"z\"), true, true); DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(), documentMapper, null, null); fieldMapper.processQuery(query, parseContext); ParseContext.Document document = parseContext.doc();  PercolatorFieldMapper.FieldType fieldType = (PercolatorFieldMapper.FieldType) fieldMapper.fieldType(); assertThat(document.getFields().size(), equalTo(1)); assertThat(document.getField(fieldType.extractionResultField.name()).stringValue(), equalTo(EXTRACTION_FAILED));",
        "label":0
    },
    {
        "ins1CurCode":".getAttachment(); if (att == null) { throw new IOException(sm.getString(\"endpoint.nio.keyMustBeCancelled\")); }",
        "ins1PreCode":".getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); }",
        "ins2PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) {  do { if (getSocket().flush(true, selector, writeTimeout)) { break; } } while (true); } updateLastWrite(); } finally { if (selector != null) { pool.put(selector); } }    ",
        "label":0
    },
    {
        "ins1CurCode":"public void getAccessLevelWhenForbiddenShouldThrowException() { this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "ins1PreCode":"public void getAccessLevelWhenForbiddenShouldThrowException() throws Exception { this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "ins2PreCode":"public void getAccessLevelWhenCloudControllerIsNotReachableThrowsException() throws Exception { this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Observable<String>> outerObserver) { outerObserver.onSubscribe(Disposable.empty()); publishNext(outerObserver, 0, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposable.empty()); publishNext(innerObserver, 10, \"1-one\"); publishNext(innerObserver, 20, \"1-two\");  publishNext(innerObserver, 30, \"1-three\"); publishCompleted(innerObserver, 40); } })); publishNext(outerObserver, 25, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposable.empty()); publishNext(innerObserver, 10, \"2-one\");",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Observable<String>> outerObserver) { outerObserver.onSubscribe(Disposables.empty()); publishNext(outerObserver, 0, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 10, \"1-one\"); publishNext(innerObserver, 20, \"1-two\");  publishNext(innerObserver, 30, \"1-three\"); publishCompleted(innerObserver, 40); } })); publishNext(outerObserver, 25, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 10, \"2-one\");",
        "ins2PreCode":"public void switchIssue737() {  Flowable<Flowable<String>> source = Flowable.unsafeCreate(new Publisher<Flowable<String>>() { @Override public void subscribe(Subscriber<? super Flowable<String>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 0, Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 10, \"1-one\"); publishNext(subscriber, 20, \"1-two\");  publishNext(subscriber, 30, \"1-three\"); publishCompleted(subscriber, 40); } })); publishNext(subscriber, 25, Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 10, \"2-one\"); publishNext(subscriber, 20, \"2-two\"); publishNext(subscriber, 30, \"2-three\"); publishCompleted(subscriber, 40); } })); publishCompleted(subscriber, 30); } });  Flowable<String> sampled = Flowable.switchOnNext(source); sampled.subscribe(subscriber);  scheduler.advanceTimeTo(1000, TimeUnit.MILLISECONDS);  InOrder inOrder = inOrder(subscriber); inOrder.verify(subscriber, times(1)).onNext(\"1-one\"); inOrder.verify(subscriber, times(1)).onNext(\"1-two\"); inOrder.verify(subscriber, times(1)).onNext(\"2-one\"); inOrder.verify(subscriber, times(1)).onNext(\"2-two\"); inOrder.verify(subscriber, times(1)).onNext(\"2-three\"); inOrder.verify(subscriber, times(1)).onComplete(); inOrder.verifyNoMoreInteractions();",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries<String> s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "label":1
    },
    {
        "ins1CurCode":"public void cloudFoundryPlatformActive() { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils",
        "ins1PreCode":"public void cloudFoundryPlatformActive() { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); assertThat(handlerMapping.getEndpointMapping().getPath()) .isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils",
        "ins2PreCode":"public void cloudFoundryPlatformActive() { setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\"));",
        "label":0
    },
    {
        "ins1CurCode":"ctx.addServletMapping(\"/stage2\", \"error\");  ctx.addApplicationListener(TrackingRequestListener.class.getName());  tomcat.start();  StringBuilder url = new StringBuilder(48); url.append(\"http://localhost:\"); url.append(getPort()); url.append(\"/stage1?iter=\"); url.append(iter); if (useThread) { url.append(\"&useThread=y\"); } ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(\"requestInitialized-\"); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); if (loop != iter) { expected.append(\"onStartAsync-\"); } loop--; } expected.append(\"ErrorServletGet-onError-onComplete-requestDestroyed\"); assertEquals(expected.toString(), res.toString());",
        "ins1PreCode":"ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); if (loop != iter) { expected.append(\"onStartAsync-\"); } loop--; } expected.append(\"ErrorServletGet-onError-onComplete-\"); assertEquals(expected.toString(), res.toString());",
        "ins2PreCode":"ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(); int loop = iter;",
        "label":0
    },
    {
        "ins1CurCode":"private void constructFigs() { getStereotypeFig().setKeyword(getKeyword()); ",
        "ins1PreCode":"private void constructFigs() { getStereotypeFig().setKeyword(\"datatype\"); ",
        "ins2PreCode":"private void initialize() { getStereotypeFig().setKeyword(\"interface\");    enableSizeChecking(false); setSuppressCalcBounds(true); addFig(getBigPort()); addFig(getStereotypeFig()); addFig(getNameFig()); addFig(getOperationsFig()); addFig(borderFig);  setSuppressCalcBounds(false);   enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void run() { cd.addAll(Disposable.empty()); }",
        "ins1PreCode":"@Override public void run() { cd.addAll(Disposables.empty()); }",
        "ins2PreCode":"@Override public void run() { cd.addAll(Disposables.empty()); }",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testFilenameAsParam() throws Exception { buildRule.executeTarget(\"testFilenameAsParam\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='one.xml'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/two.txt\",      \"filename='two.xml'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/three.txt\",    \"filename='three.xml'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='four.xml'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filedir ='-not-set-'\");",
        "ins1PreCode":"public void testFilenameAsParam() throws Exception { executeTarget(\"testFilenameAsParam\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='one.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/two.txt\",      \"filename='two.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/three.txt\",    \"filename='three.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='four.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filedir ='-not-set-'\");",
        "ins2PreCode":"public void testFilenameAsParamNoSetting() throws Exception { executeTarget(\"testFilenameAsParamNoSetting\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/two.txt\",      \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/three.txt\",    \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='-not-set-'\");",
        "label":1
    },
    {
        "ins1CurCode":"public Set<K> keySet() {   LinkedHashSet<K> set = new LinkedHashSet<K>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<K,MapEntry<K,V>> e = i.next(); K key = e.getKey(); MapEntry<K,V> entry = innerMap.get(key); if ( entry!=null && entry.isActive() ) set.add(key);",
        "ins1PreCode":"public Set<Object> keySet() {   LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isActive() ) set.add(key);",
        "ins2PreCode":"public Set<MapEntry> entrySet() { LinkedHashSet<MapEntry> set = new LinkedHashSet<MapEntry>(super.size()); Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry != null && entry.isActive() ) { set.add(new MapEntry(key, entry.getValue())); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testBug51445AddServlet() throws Exception {  initLatch(); ",
        "ins1PreCode":"public void testBug51445AddServlet() throws Exception {  latch = new CountDownLatch(BUG51445_THREAD_COUNT); ",
        "ins2PreCode":"public void testBug51445AddChild() throws Exception {  latch = new CountDownLatch(BUG51445_THREAD_COUNT); ",
        "label":1
    },
    {
        "ins1CurCode":"public RestRequest.Method method() { HttpMethod httpMethod = request.method(); if (httpMethod == HttpMethod.GET) return RestRequest.Method.GET;  if (httpMethod == HttpMethod.POST) return RestRequest.Method.POST;  if (httpMethod == HttpMethod.PUT) return RestRequest.Method.PUT;  if (httpMethod == HttpMethod.DELETE) return RestRequest.Method.DELETE;  if (httpMethod == HttpMethod.HEAD) { return RestRequest.Method.HEAD; }  if (httpMethod == HttpMethod.OPTIONS) { return RestRequest.Method.OPTIONS; }  if (httpMethod == HttpMethod.PATCH) { return RestRequest.Method.PATCH; }  if (httpMethod == HttpMethod.TRACE) { return RestRequest.Method.TRACE; }  if (httpMethod == HttpMethod.CONNECT) { return RestRequest.Method.CONNECT; }",
        "ins1PreCode":"public Method method() { HttpMethod httpMethod = request.method(); if (httpMethod == HttpMethod.GET) return Method.GET;  if (httpMethod == HttpMethod.POST) return Method.POST;  if (httpMethod == HttpMethod.PUT) return Method.PUT;  if (httpMethod == HttpMethod.DELETE) return Method.DELETE;  if (httpMethod == HttpMethod.HEAD) { return Method.HEAD; }  if (httpMethod == HttpMethod.OPTIONS) { return Method.OPTIONS; }  if (httpMethod == HttpMethod.PATCH) { return Method.PATCH; }  if (httpMethod == HttpMethod.TRACE) { return Method.TRACE; }  if (httpMethod == HttpMethod.CONNECT) { return Method.CONNECT; }",
        "ins2PreCode":"public Method method() { HttpMethod httpMethod = request.method(); if (httpMethod == HttpMethod.GET) return Method.GET;  if (httpMethod == HttpMethod.POST) return Method.POST;  if (httpMethod == HttpMethod.PUT) return Method.PUT;  if (httpMethod == HttpMethod.DELETE) return Method.DELETE;  if (httpMethod == HttpMethod.HEAD) { return Method.HEAD; }  if (httpMethod == HttpMethod.OPTIONS) { return Method.OPTIONS; }  if (httpMethod == HttpMethod.PATCH) { return Method.PATCH; }  if (httpMethod == HttpMethod.TRACE) { return Method.TRACE; }  if (httpMethod == HttpMethod.CONNECT) { return Method.CONNECT; }",
        "label":1
    },
    {
        "ins1CurCode":"} ByteChunk bc = cookieValue.getByteChunk(); if (getPreserveCookieHeader()) { int len = bc.getLength();",
        "ins1PreCode":"} ByteChunk bc = cookieValue.getByteChunk(); if (CookieSupport.PRESERVE_COOKIE_HEADER) { int len = bc.getLength();",
        "ins2PreCode":"public void parseCookieHeader(MimeHeaders headers, ServerCookies serverCookies) {  if (headers == null) {  return; }   int pos = headers.findHeader(\"Cookie\", 0); while (pos >= 0) { MessageBytes cookieValue = headers.getValue(pos);  if (cookieValue != null && !cookieValue.isNull() ) { if (cookieValue.getType() != MessageBytes.T_BYTES ) { Exception e = new Exception(); log.warn(\"Cookies: Parsing cookie as String. Expected bytes.\", e); cookieValue.toBytes(); } if (log.isDebugEnabled()) { log.debug(\"Cookies: Parsing b[]: \" + cookieValue.toString()); } ByteChunk bc = cookieValue.getByteChunk();  Cookie.parseCookie(bc.getBytes(), bc.getOffset(), bc.getLength(), serverCookies); }   pos = headers.findHeader(\"Cookie\", ++pos); }",
        "label":0
    },
    {
        "ins1CurCode":"IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), null, Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false, MatcherWatchdog.noop());",
        "ins1PreCode":"IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false, MatcherWatchdog.noop());",
        "ins2PreCode":"IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, true, MatcherWatchdog.noop());",
        "label":1
    },
    {
        "ins1CurCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);",
        "ins1PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testValue\"); autoCompleter.indexEntry(entry);",
        "ins2PreCode":"public void completeBeginnigOfSecondWordReturnsWord() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"handlerBlock.blockEnableState = null; } } else if (handlerBlock.blockEnableState == null) { handlerBlock.blockEnableState = ControlEnableState.disable(handlerBlock.blockControl);",
        "ins1PreCode":"handlerBlock.blockEnableState = null; } } else if (handlerConfiguration == null || handlerBlock.blockEnableState == null) { handlerBlock.blockEnableState = ControlEnableState.disable(handlerBlock.blockControl);",
        "ins2PreCode":"protected void enableHandlerContent(NetworkHandlerDescriptor descriptor) { HandlerBlock handlerBlock = configurations.get(descriptor); DBWHandlerConfiguration handlerConfiguration = handlerBlock.loadedConfigs.get(wizard.getPageSettings().getActiveDataSource().getId()); handlerBlock.useHandlerCheck.setSelection(handlerConfiguration.isEnabled()); if (handlerConfiguration.isEnabled()) { if (handlerBlock.blockEnableState != null) { handlerBlock.blockEnableState.restore(); handlerBlock.blockEnableState = null; } } else if (handlerBlock.blockEnableState == null) { handlerBlock.blockEnableState = ControlEnableState.disable(handlerBlock.blockControl); }",
        "label":0
    },
    {
        "ins1CurCode":"public void groupByShouldPropagateError() { final Throwable e = new RuntimeException(\"Oops\"); final TestSubscriberEx<Integer> inner1 = new TestSubscriberEx<>(); final TestSubscriberEx<Integer> inner2 = new TestSubscriberEx<>();  final TestSubscriberEx<GroupedFlowable<Integer, Integer>> outer = new TestSubscriberEx<>(new DefaultSubscriber<GroupedFlowable<Integer, Integer>>() { ",
        "ins1PreCode":"public void groupByShouldPropagateError() { final Throwable e = new RuntimeException(\"Oops\"); final TestSubscriberEx<Integer> inner1 = new TestSubscriberEx<Integer>(); final TestSubscriberEx<Integer> inner2 = new TestSubscriberEx<Integer>();  final TestSubscriberEx<GroupedFlowable<Integer, Integer>> outer = new TestSubscriberEx<GroupedFlowable<Integer, Integer>>(new DefaultSubscriber<GroupedFlowable<Integer, Integer>>() { ",
        "ins2PreCode":"public void groupByShouldPropagateError() { final Throwable e = new RuntimeException(\"Oops\"); final TestObserverEx<Integer> inner1 = new TestObserverEx<Integer>(); final TestObserverEx<Integer> inner2 = new TestObserverEx<Integer>();  final TestObserverEx<GroupedObservable<Integer, Integer>> outer = new TestObserverEx<GroupedObservable<Integer, Integer>>(new DefaultObserver<GroupedObservable<Integer, Integer>>() { ",
        "label":1
    },
    {
        "ins1CurCode":"setOutputStream(new PrintStream( new BufferedOutputStream( FileUtils.newOutputStream(Paths.get(output.getPath()), append))));",
        "ins1PreCode":"setOutputStream(new PrintStream( new BufferedOutputStream( new FileOutputStream(output .getPath(), append))));",
        "ins2PreCode":"setErrorStream(new PrintStream( new BufferedOutputStream( new FileOutputStream(error.getPath(), append))));",
        "label":1
    },
    {
        "ins1CurCode":"void completeEmptyStringReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testKey\"); database.insertEntry(entry);  Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"\"))); assertEquals(Collections.emptyList(), result);",
        "ins1PreCode":"public void completeEmptyStringReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testKey\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"\"))); assertEquals(Collections.emptyList(), result);",
        "ins2PreCode":"public void completeEmptyStringReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testKey\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"\"))); assertEquals(Collections.emptyList(), result);",
        "label":1
    },
    {
        "ins1CurCode":" if (Model.getFacade().isANode(modelElement)) { figNode = new FigNode(modelElement, bounds, settings); } else if (Model.getFacade().isAPort(modelElement)) { figNode = new FigPort(modelElement, bounds, settings); } else if (Model.getFacade().isAAssociation(modelElement)) {",
        "ins1PreCode":" if (Model.getFacade().isANode(modelElement)) { figNode = new FigMNode(modelElement, bounds, settings); } else if (Model.getFacade().isAAssociation(modelElement)) {",
        "ins2PreCode":"public DiagramElement createDiagramElement( final Object modelElement, final Rectangle bounds) {  FigNodeModelElement figNode = null;  DiagramSettings settings = getDiagramSettings();  if (Model.getFacade().isANode(modelElement)) { figNode = new FigMNode(modelElement, bounds, settings); } else if (Model.getFacade().isAAssociation(modelElement)) { figNode = createNaryAssociationNode(modelElement, bounds, settings); } else if (Model.getFacade().isANodeInstance(modelElement)) { figNode = new FigNodeInstance(modelElement, bounds, settings); } else if (Model.getFacade().isAComponent(modelElement)) { figNode = new FigComponent(modelElement, bounds, settings); } else if (Model.getFacade().isAComponentInstance(modelElement)) { figNode = new FigComponentInstance(modelElement, bounds, settings); } else if (Model.getFacade().isAClass(modelElement)) { figNode = new FigClass(modelElement, bounds, settings); } else if (Model.getFacade().isAInterface(modelElement)) { figNode = new FigInterface(modelElement, bounds, settings); } else if (Model.getFacade().isAObject(modelElement)) { figNode = new FigObject(modelElement, bounds, settings); } else if (Model.getFacade().isAActor(modelElement)) { figNode = new FigActor(modelElement, bounds, settings); } else if (Model.getFacade().isAComment(modelElement)) { figNode = new FigComment(modelElement, bounds, settings); }  if (figNode != null) { LOG.debug(\"Model element \" + modelElement + \" converted to \" + figNode); } else { LOG.debug(\"Dropped object NOT added \" + figNode); } return figNode;",
        "label":0
    },
    {
        "ins1CurCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, null, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins1PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, null, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "label":1
    },
    {
        "ins1CurCode":" try (ACLContext ignored = ACL.as2(manager.impersonate2())) { Exception e = Assert.assertThrows(AccessDeniedException.class, () -> jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Build.ARTIFACTS)); Assert.assertEquals(\"manager is missing a permission, one of Job/WipeOut, Run/Artifacts is required\", e.getMessage()); }",
        "ins1PreCode":"final User manager = User.getOrCreateByIdOrFullName(\"manager\");  expectedException.expectMessage(\"manager is missing a permission, one of Job/WipeOut, Run/Artifacts is required\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as2(manager.impersonate2())) { jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Build.ARTIFACTS); }",
        "ins2PreCode":"final User manager = User.getOrCreateByIdOrFullName(\"manager\");  expectedException.expectMessage(\"manager is missing the Overall/Administer permission\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as2(manager.impersonate2())) { jenkins.getACL().checkAnyPermission(Jenkins.MANAGE, Jenkins.SYSTEM_READ); }",
        "label":0
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_15; }",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_16; }",
        "ins2PreCode":"case IDENTIFIER: Expression(); label_17: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[43] = jj_gen; break label_17; }",
        "label":1
    },
    {
        "ins1CurCode":"}  to.awaitDone(10, TimeUnit.SECONDS); ",
        "ins1PreCode":"}  to .awaitDone(5, TimeUnit.SECONDS) ; ",
        "ins2PreCode":"public void fusedNoConcurrentCleanDueToCancel() { for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final UnicastSubject<Integer> us = UnicastSubject.create();  TestObserver<Integer> to = us.hide() .observeOn(Schedulers.io()) .observeOn(Schedulers.single()) .unsubscribeOn(Schedulers.computation()) .firstOrError() .test();  for (int i = 0; us.hasObservers() && i < 10000; i++) { us.onNext(i); }  to .awaitDone(5, TimeUnit.SECONDS) ;  if (!errors.isEmpty()) { throw new CompositeException(errors); }  to.assertResult(0); } finally { RxJavaPlugins.reset(); } }",
        "label":0
    },
    {
        "ins1CurCode":"q.offer(1);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"q.offer(1);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void drainMaxLoopDontAccept() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 1; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1);  QueueDrainHelper.drainMaxLoop(q, ts, false, null, qd);  ts.assertEmpty();",
        "label":0
    },
    {
        "ins1CurCode":"public void assertValue() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"public void assertValue() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"public void assertValue() { TestSubscriber<Integer> ts = TestSubscriber.create();  ts.onSubscribe(new BooleanSubscription());  try { ts.assertValue(1); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  ts.onNext(1);  ts.assertValue(1);  try { ts.assertValue(2); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  ts.onNext(2);  try { ts.assertValue(1); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }",
        "label":0
    },
    {
        "ins1CurCode":"}  List<Dependency> list = new ArrayList<>( artifacts.size() ); ",
        "ins1PreCode":"}  List<Dependency> list = new ArrayList<Dependency>( artifacts.size() ); ",
        "ins2PreCode":"}  List<Dependency> list = new ArrayList<Dependency>( artifacts.size() ); ",
        "label":1
    },
    {
        "ins1CurCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void getPathFromRootInSimpleTree() { TreeNodeTestData.TreeNodeMock root = new TreeNodeTestData.TreeNodeMock(); TreeNodeTestData.TreeNodeMock node = TreeNodeTestData.getNodeInSimpleTree(root);  List<TreeNodeTestData.TreeNodeMock> path = node.getPathFromRoot(); assertEquals(3, path.size());",
        "ins1PreCode":"public void getPathFromRootInSimpleTree() { TreeNodeMock root = new TreeNodeMock(); TreeNodeMock node = getNodeInSimpleTree(root);  List<TreeNodeMock> path = node.getPathFromRoot(); assertEquals(3, path.size());",
        "ins2PreCode":"public void getPathFromRootInComplexTree() { TreeNodeMock root = new TreeNodeMock(); TreeNodeMock node = getNodeInComplexTree(root);  List<TreeNodeMock> path = node.getPathFromRoot(); assertEquals(4, path.size());",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super String> t1) { t1.onSubscribe(Disposable.empty()); System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));",
        "ins1PreCode":"@Override public void subscribe(Observer<? super String> t1) { t1.onSubscribe(Disposables.empty()); System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis()));",
        "ins2PreCode":"public void iterativeBackoff() { Subscriber<String> consumer = TestHelper.mockSubscriber();  Flowable<String> producer = Flowable.unsafeCreate(new Publisher<String>() {  private AtomicInteger count = new AtomicInteger(4); long last = System.currentTimeMillis();  @Override public void subscribe(Subscriber<? super String> t1) { t1.onSubscribe(new BooleanSubscription()); System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis())); last = System.currentTimeMillis(); if (count.getAndDecrement() == 0) { t1.onNext(\"hello\"); t1.onComplete(); } else { t1.onError(new RuntimeException()); } }  }); TestSubscriber<String> ts = new TestSubscriber<String>(consumer); producer.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() {  @Override public Flowable<Object> apply(Flowable<? extends Throwable> attempts) {  return attempts .map(new Function<Throwable, Tuple>() { @Override public Tuple apply(Throwable n) { return new Tuple(new Long(1), n); }}) .scan(new BiFunction<Tuple, Tuple, Tuple>() { @Override public Tuple apply(Tuple t, Tuple n) { return new Tuple(t.count + n.count, n.n); }}) .flatMap(new Function<Tuple, Flowable<Object>>() { @Override public Flowable<Object> apply(Tuple t) { System.out.println(\"Retry # \" + t.count); return t.count > 20 ? Flowable.<Object>error(t.n) : Flowable.timer(t.count * 1L, TimeUnit.MILLISECONDS) .cast(Object.class); }}); } }).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors();  InOrder inOrder = inOrder(consumer); inOrder.verify(consumer, never()).onError(any(Throwable.class)); inOrder.verify(consumer, times(1)).onNext(\"hello\"); inOrder.verify(consumer, times(1)).onComplete(); inOrder.verifyNoMoreInteractions(); ",
        "label":0
    },
    {
        "ins1CurCode":"Iterator<User> iterator = cursor.iterator();  Assertions.assertFalse(cursor.isOpen());   Assertions.assertTrue(iterator.hasNext());  Assertions.assertTrue(iterator.hasNext()); Assertions.assertTrue(cursor.isOpen()); Assertions.assertFalse(cursor.isConsumed());  User user; user = iterator.next(); Assertions.assertEquals(\"Kate\", user.getName()); Assertions.assertEquals(1, cursor.getCurrentIndex());  Assertions.assertTrue(iterator.hasNext()); user = iterator.next(); Assertions.assertNull(user); Assertions.assertEquals(2, cursor.getCurrentIndex());   Assertions.assertFalse(iterator.hasNext()); Assertions.assertFalse(cursor.isOpen()); Assertions.assertTrue(cursor.isConsumed()); }",
        "ins1PreCode":"Iterator<User> iterator = cursor.iterator();  assertFalse(cursor.isOpen());   assertTrue(iterator.hasNext());  assertTrue(iterator.hasNext()); assertTrue(cursor.isOpen()); assertFalse(cursor.isConsumed());  User user; user = iterator.next(); assertEquals(\"Kate\", user.getName()); assertEquals(1, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertNull(user); assertEquals(2, cursor.getCurrentIndex());   assertFalse(iterator.hasNext()); assertFalse(cursor.isOpen()); assertTrue(cursor.isConsumed()); }",
        "ins2PreCode":"Iterator<User> iterator = cursor.iterator();  assertFalse(cursor.isOpen());   assertEquals(-1, cursor.getCurrentIndex());   assertTrue(iterator.hasNext());  assertTrue(iterator.hasNext()); assertTrue(cursor.isOpen()); assertFalse(cursor.isConsumed());   assertEquals(-1, cursor.getCurrentIndex());  User user; user = iterator.next(); assertNull(user); assertEquals(0, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertEquals(\"Kate\", user.getName()); assertEquals(1, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertNull(user); assertEquals(2, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertNull(user); assertEquals(3, cursor.getCurrentIndex());   assertFalse(iterator.hasNext()); assertFalse(cursor.isOpen()); assertTrue(cursor.isConsumed()); }",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(final Observer<? super Integer> o) { o.onSubscribe(Disposable.empty()); task.replace(Schedulers.single().scheduleDirect(new Runnable() {",
        "ins1PreCode":"@Override public void subscribe(final Observer<? super Integer> o) { o.onSubscribe(Disposables.empty()); task.replace(Schedulers.single().scheduleDirect(new Runnable() {",
        "ins2PreCode":"public void noBufferingOrBlockingOfSequence() throws Throwable { int repeat = 0; for (;;) { final SerialDisposable task = new SerialDisposable(); try { final CountDownLatch finished = new CountDownLatch(1); final int COUNT = 30; final CountDownLatch timeHasPassed = new CountDownLatch(COUNT); final AtomicBoolean running = new AtomicBoolean(true); final AtomicInteger count = new AtomicInteger(0); final Flowable<Integer> obs = Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(final Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); task.replace(Schedulers.single().scheduleDirect(new Runnable() {  @Override public void run() { try { while (running.get() && !task.isDisposed()) { subscriber.onNext(count.incrementAndGet()); timeHasPassed.countDown(); } subscriber.onComplete(); } catch (Throwable e) { subscriber.onError(e); } finally { finished.countDown(); } } })); }  });  Iterator<Integer> it = obs.blockingNext().iterator();  assertTrue(it.hasNext()); int a = it.next(); assertTrue(it.hasNext()); int b = it.next();  assertTrue(\"a and b should be different\", a != b);   timeHasPassed.await(8000, TimeUnit.MILLISECONDS);  assertTrue(it.hasNext()); int c = it.next();  assertTrue(\"c should not just be the next in sequence\", c != (b + 1)); assertTrue(\"expected that c [\" + c + \"] is higher than or equal to \" + COUNT, c >= COUNT);  assertTrue(it.hasNext()); int d = it.next(); assertTrue(d > c);   running.set(false);  finished.await();  assertFalse(it.hasNext());  System.out.println(\"a: \" + a + \" b: \" + b + \" c: \" + c); break; } catch (AssertionError ex) { if (++repeat == 3) { throw ex; } Thread.sleep((int)(1000 * Math.pow(2, repeat - 1))); } finally { task.dispose(); } }",
        "label":0
    },
    {
        "ins1CurCode":"public String toString() { StringBuffer buf = new StringBuffer(\"{dependselector targetdir: \"); if (targetdir == null) { buf.append(\"NOT YET SET\"); } else { buf.append(targetdir.getName()); }",
        "ins1PreCode":"public String toString() { StringBuffer buf = new StringBuffer(\"{dependselector targetdir: \"); buf.append(targetdir); buf.append(\" granularity: \");",
        "ins2PreCode":"public String toString() { StringBuffer buf = new StringBuffer(\"{presentselector targetdir: \"); buf.append(targetdir); buf.append(\" present: \");",
        "label":1
    },
    {
        "ins1CurCode":"q.push(o2);  Assert.assertEquals(o2, q.first.getContent()); Assert.assertEquals(o1, q.last.getContent());  Object r1 = q.pop();  Assert.assertEquals(o1, r1); Assert.assertEquals(o2, q.first.getContent()); Assert.assertEquals(o2, q.last.getContent());   Object r2 = q.pop(); Assert.assertEquals(o2, r2); Assert.assertNull(q.first); Assert.assertNull(q.last);",
        "ins1PreCode":"q.push(o2);  assertEquals(o2, q.first.getContent()); assertEquals(o1, q.last.getContent());  Object r1 = q.pop();  assertEquals(o1, r1); assertEquals(o2, q.first.getContent()); assertEquals(o2, q.last.getContent());   Object r2 = q.pop(); assertEquals(o2, r2); assertNull(q.first); assertNull(q.last);",
        "ins2PreCode":"q.unpop(o2);  assertEquals(o1, q.first.getContent()); assertEquals(o2, q.last.getContent());  Object r2 = q.pop();  assertEquals(o2, r2); assertEquals(o1, q.first.getContent()); assertEquals(o1, q.last.getContent());   Object r1 = q.pop(); assertEquals(o1, r1); assertNull(q.first); assertNull(q.last);",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindDomainBounds2() { DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>(); double[] x1 = new double[] {1.0, 2.0, 3.0};",
        "ins1PreCode":"public void testFindDomainBounds2() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0};",
        "ins2PreCode":"public void testFindDomainBounds3() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0};",
        "label":1
    },
    {
        "ins1CurCode":"public void close(ChannelHandlerContext ctx, ChannelPromise promise) { List<Tuple<HttpPipelinedResponse, ChannelPromise>> inflightResponses = aggregator.removeAllInflightResponses();  if (inflightResponses.isEmpty() == false) { ClosedChannelException closedChannelException = new ClosedChannelException(); for (Tuple<HttpPipelinedResponse, ChannelPromise> inflightResponse : inflightResponses) { try {",
        "ins1PreCode":"public void close(ChannelHandlerContext ctx, ChannelPromise promise) { List<Tuple<Netty4HttpResponse, ChannelPromise>> inflightResponses = aggregator.removeAllInflightResponses();  if (inflightResponses.isEmpty() == false) { ClosedChannelException closedChannelException = new ClosedChannelException(); for (Tuple<Netty4HttpResponse, ChannelPromise> inflightResponse : inflightResponses) { try {",
        "ins2PreCode":"public void close(ChannelHandlerContext ctx, ChannelPromise promise) { List<Tuple<NioHttpResponse, NettyListener>> inflightResponses = aggregator.removeAllInflightResponses();  if (inflightResponses.isEmpty() == false) { ClosedChannelException closedChannelException = new ClosedChannelException(); for (Tuple<NioHttpResponse, NettyListener> inflightResponse : inflightResponses) { try {",
        "label":0
    },
    {
        "ins1CurCode":"{ try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(generateSessionReadQuery(options))) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins1PreCode":"{ try { boolean onlyConnections = CommonUtils.getOption(options, OPTION_SHOW_ONLY_CONNECTIONS); boolean supportsDatabaseInfo = ((SQLServerDataSource) session.getDataSource()).isServerVersionAtLeast(SQLServerConstants.SQL_SERVER_2012_VERSION_MAJOR, 0);  StringBuilder sql = new StringBuilder(); sql.append(\"SELECT s.*,\"); if (supportsDatabaseInfo) { sql.append(\"db.name as database_name,\"); } else { sql.append(\"NULL as database_name,\"); } sql.append(\"c.connection_id,(select text from sys.dm_exec_sql_text(c.most_recent_sql_handle)) as sql_text\\n\") .append(\"FROM sys.dm_exec_sessions s\\n\"); if (onlyConnections) { sql.append(\"LEFT OUTER \"); } sql.append(\"JOIN sys.dm_exec_connections c ON c.session_id=s.session_id\\n\"); if (supportsDatabaseInfo) { sql.append(\"LEFT OUTER JOIN sys.sysdatabases db on db.dbid=s.database_id\\n\"); } sql.append(\"ORDER BY s.session_id DESC\");  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins2PreCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { boolean atLeastV11 = dataSource.isAtLeastV11(); try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, \"); if (atLeastV11) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\");    if (atLeastV11) { sql.append(\" AND s.sql_child_number = sq.child_number (+)\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) { sql.append(\" AND s.TYPE = 'USER'\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_INACTIVE)) { sql.append(\" AND s.STATUS <> 'INACTIVE'\"); } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "label":0
    },
    {
        "ins1CurCode":"expectedException.expectMessage(\"manager is missing the Overall/Administer permission\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as2(manager.impersonate2())) { jenkins.getACL().checkAnyPermission(Jenkins.ADMINISTER);",
        "ins1PreCode":"expectedException.expectMessage(\"manager is missing the Overall/Administer permission\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as(manager.impersonate())) { jenkins.getACL().checkAnyPermission(Jenkins.ADMINISTER);",
        "ins2PreCode":"expectedException.expectMessage(\"manager is missing a permission, one of Overall/Administer, Overall/Read is required\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as(manager.impersonate())) { jenkins.getACL().checkAnyPermission(Jenkins.ADMINISTER, Jenkins.READ);",
        "label":1
    },
    {
        "ins1CurCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins1PreCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); author2.getId();",
        "ins2PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy));  assertTrue(author2 instanceof Proxy);",
        "label":0
    },
    {
        "ins1CurCode":"configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins1PreCode":"configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins2PreCode":"configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "label":1
    },
    {
        "ins1CurCode":".set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\") .set(package$.MODULE$.SHUFFLE_SPILL_COMPRESS(), false) .set(package$.MODULE$.SHUFFLE_COMPRESS(), false)); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins1PreCode":".set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\") .set(\"spark.shuffle.spill.compress\", \"false\") .set(\"spark.shuffle.compress\", \"false\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins2PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(invocationOnMock -> { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(invocationOnMock -> { Object[] args = invocationOnMock.getArguments();  return new DiskBlockObjectWriter( (File) args[1], serializerManager, (SerializerInstance) args[2], (Integer) args[3], false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] ); });",
        "label":0
    },
    {
        "ins1CurCode":"handshakeStatus = result.getHandshakeStatus();  if (doWrite) { flush(netOutBuffer); }",
        "ins1PreCode":"handshakeStatus = result.getHandshakeStatus();  if ( doWrite ) flush(netOutBuffer); return result;",
        "ins2PreCode":"protected SSLEngineResult handshakeWrap() throws IOException {   netOutBuffer.clear();  getBufHandler().configureWriteBufferForRead(); SSLEngineResult result = sslEngine.wrap(getBufHandler().getWriteBuffer(), netOutBuffer);  netOutBuffer.flip();  handshakeStatus = result.getHandshakeStatus(); return result;",
        "label":0
    },
    {
        "ins1CurCode":"T item = supplier.get(); if (item != null) { cs = Objects.requireNonNull(mapper.apply(item), \"The mapper returned a null MaybeSource\"); }",
        "ins1PreCode":"T item = supplier.get(); if (item != null) { cs = ObjectHelper.requireNonNull(mapper.apply(item), \"The mapper returned a null MaybeSource\"); }",
        "ins2PreCode":"T item = supplier.get(); if (item != null) { cs = ObjectHelper.requireNonNull(mapper.apply(item), \"The mapper returned a null SingleSource\"); }",
        "label":1
    },
    {
        "ins1CurCode":"enterRule(_localctx, 38, RULE_postfix); try { setState(353); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(350); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(351); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(352); braceaccess();",
        "ins1PreCode":"setState(351); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,28,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(348); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(349); fieldaccess();",
        "ins2PreCode":"setState(355); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(353); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(354); fieldaccess();",
        "label":0
    },
    {
        "ins1CurCode":"while (true) { if ((value & ~0x7F) == 0) { UnsafeUtil.putByte(buffer, pos++, (byte) value); break; } else { UnsafeUtil.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7;",
        "ins1PreCode":"while (true) { if ((value & ~0x7F) == 0) { UNSAFE.putByte(buffer, pos++, (byte) value); break; } else { UNSAFE.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7;",
        "ins2PreCode":"while (true) { if ((value & ~0x7FL) == 0) { UNSAFE.putByte(buffer, pos++, (byte) value); break; } else { UNSAFE.putByte(buffer, pos++, (byte) (((int) value & 0x7F) | 0x80)); value >>>= 7;",
        "label":1
    },
    {
        "ins1CurCode":"void tryEnvironmentPreparedEvent() throws Exception { File file = new File(this.tempDir, \"pid\"); file.createNewFile(); SpringApplicationEvent event = createEnvironmentPreparedEvent(\"spring.pid.file\", file.getAbsolutePath());",
        "ins1PreCode":"public void tryEnvironmentPreparedEvent() throws Exception { File file = this.temporaryFolder.newFile(); SpringApplicationEvent event = createEnvironmentPreparedEvent(\"spring.pid.file\", file.getAbsolutePath());",
        "ins2PreCode":"public void tryReadyEvent() throws Exception { File file = this.temporaryFolder.newFile(); SpringApplicationEvent event = createReadyEvent(\"spring.pid.file\", file.getAbsolutePath());",
        "label":1
    },
    {
        "ins1CurCode":"if (plot instanceof CombinedDomainCategoryPlot) { CombinedDomainCategoryPlot cp = (CombinedDomainCategoryPlot) plot; for (CategoryPlot subplot : cp.getSubplots()) { if (subplot != null) { applyToPlot(subplot); } } } if (plot instanceof CombinedRangeCategoryPlot) { CombinedRangeCategoryPlot cp = (CombinedRangeCategoryPlot) plot; for (CategoryPlot subplot : cp.getSubplots()) { if (subplot != null) {",
        "ins1PreCode":"if (plot instanceof CombinedDomainCategoryPlot) { CombinedDomainCategoryPlot cp = (CombinedDomainCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } if (plot instanceof CombinedRangeCategoryPlot) { CombinedRangeCategoryPlot cp = (CombinedRangeCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) {",
        "ins2PreCode":"protected <S extends Comparable<S>> void  applyToXYPlot(XYPlot<S> plot) { plot.setAxisOffset(this.axisOffset);",
        "label":0
    },
    {
        "ins1CurCode":"context.getBean(DataSource.class)); context.close(); verify(statement, never()).execute(\"SHUTDOWN\");",
        "ins1PreCode":"context.getBean(DataSource.class)); context.close(); verify(statement, times(0)).execute(\"SHUTDOWN\");",
        "ins2PreCode":"public void inMemoryH2IsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class)); context.close(); verify(statement, times(1)).execute(\"SHUTDOWN\");",
        "label":0
    },
    {
        "ins1CurCode":"runner.runScript(reader);  assertEquals( \"select userid from account where userid = 'j2ee'\" + System.getProperty(\"line.separator\") + System.getProperty(\"line.separator\") + \"USERID\\t\" + System.getProperty(\"line.separator\") + \"j2ee\\t\" + System.getProperty(\"line.separator\"), sw.toString());",
        "ins1PreCode":"runner.runScript(reader);  assertEquals(\"select userid from account where userid = 'j2ee'\\n\\nUSERID\\t\\nj2ee\\t\\n\", sw.toString());",
        "ins2PreCode":"runner.runScript(reader);  assertEquals(\"select userid from account where userid = 'j2ee';\\n\\nUSERID\\t\\nj2ee\\t\\n\", sw.toString());",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public void testRadio() throws Exception { HtmlPage p = j.createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); getHtmlButton(f, \"Add\", true).click(); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(1).click(); getHtmlButton(f, \"Add\", false).click(); f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click(); j.submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", rootAction.formData.get(\"foos\"));",
        "ins1PreCode":"public void testRadio() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); getHtmlButton(f, \"Add\", true).click(); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(1).click(); getHtmlButton(f, \"Add\", false).click(); f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click(); submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\"));",
        "ins2PreCode":"public void testRadio_ExistingData() throws Exception { list.add(new FooRadio(\"1\", \"one\")); list.add(new FooRadio(\"2\", \"two\")); list.add(new FooRadio(\"three\", \"one\")); HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); getHtmlButton(f, \"Add\", false).click(); f.getInputByValue(\"\").setValueAttribute(\"txt 4\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click(); submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"1\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"2\\\"},\" + \"{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"three\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt 4\\\"}]\", formData.get(\"foos\"));",
        "label":0
    },
    {
        "ins1CurCode":" if (inner.isUnbounded()) { if (!HalfSerializer.onNext(downstream, vr, this, errors)) { return;",
        "ins1PreCode":" if (inner.isUnbounded()) { if (get() == 0 && compareAndSet(0, 1)) { downstream.onNext(vr); if (!compareAndSet(1, 0)) { errors.tryTerminateConsumer(downstream);",
        "ins2PreCode":"}  if (vr == null) { continue; }  if (inner.isUnbounded()) { if (get() == 0 && compareAndSet(0, 1)) { downstream.onNext(vr);",
        "label":0
    },
    {
        "ins1CurCode":"public void groupByBackpressure3() throws InterruptedException { TestSubscriber<String> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void groupByBackpressure3() throws InterruptedException { TestSubscriber<String> ts = new TestSubscriber<String>(); ",
        "ins2PreCode":"public void groupByBackpressure3() throws InterruptedException { TestObserver<String> to = new TestObserver<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); }",
        "ins1PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getEndValue(r,",
        "ins2PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getStartValue(r,",
        "label":1
    },
    {
        "ins1CurCode":"public void testRemoveSubplot() { CombinedDomainXYPlot<String> plot = new CombinedDomainXYPlot<>(); XYPlot<String> plot1 = new XYPlot<>();",
        "ins1PreCode":"public void testRemoveSubplot() { CombinedDomainXYPlot plot = new CombinedDomainXYPlot(); XYPlot<String> plot1 = new XYPlot<>();",
        "ins2PreCode":"public void testRemoveSubplot() { CombinedRangeXYPlot plot = new CombinedRangeXYPlot(); XYPlot<String> plot1 = new XYPlot<>();",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"servlet\", new CharsetServlet()); ctx.addServletMappingDecoded(\"/\", \"servlet\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"servlet\", new CharsetServlet()); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"servlet\", new Bug52811Servlet()); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0); XIntervalDataItem item2 = CloneUtils.clone(item1); assertTrue(item1 != item2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0); XIntervalDataItem item2 = (XIntervalDataItem) item1.clone(); assertTrue(item1 != item2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { YIntervalDataItem item1 = new YIntervalDataItem(1.0, 2.0, 1.5, 2.5); YIntervalDataItem item2 = (YIntervalDataItem) item1.clone(); assertTrue(item1 != item2);",
        "label":1
    },
    {
        "ins1CurCode":"fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(ExceptionHelper.nullWarning(\"onNext called with a null value.\"), ex.getMessage()); }",
        "ins1PreCode":"fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage()); }",
        "ins2PreCode":"fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void containsReturnsTrueForEntryInAux() throws Exception { Path auxFile = Path.of(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData);",
        "ins1PreCode":"public void containsReturnsTrueForEntryInAux() throws Exception { Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData);",
        "ins2PreCode":"public void containsReturnsTrueForEntryNotInAux() throws Exception { Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData);",
        "label":1
    },
    {
        "ins1CurCode":"expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); assertThat(output).isEqualTo(expectedOutput.toString());",
        "ins1PreCode":"expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); Assert.assertEquals(output, expectedOutput.toString());",
        "ins2PreCode":"expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); assertEquals(output, expectedOutput.toString());",
        "label":0
    },
    {
        "ins1CurCode":"public final <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull R> Flowable<R> withLatestFrom( @NonNull Publisher<T1> source1, @NonNull Publisher<T2> source2,",
        "ins1PreCode":"public final <T1, T2, T3, @NonNull R> Flowable<R> withLatestFrom( @NonNull Publisher<T1> source1, @NonNull Publisher<T2> source2,",
        "ins2PreCode":"public final <T1, T2, T3, R> Observable<R> withLatestFrom( @NonNull ObservableSource<T1> source1, @NonNull ObservableSource<T2> source2,",
        "label":0
    },
    {
        "ins1CurCode":"Observable<String> o3 = Observable.just(\"five\", \"six\");  Iterable<Observable<String>> is = Arrays.asList(o1, o2, o3); ",
        "ins1PreCode":"Observable<String> o3 = Observable.just(\"five\", \"six\");  @SuppressWarnings(\"unchecked\") Iterable<Observable<String>> is = Arrays.asList(o1, o2, o3);",
        "ins2PreCode":"Flowable<String> f3 = Flowable.just(\"five\", \"six\");  @SuppressWarnings(\"unchecked\") Iterable<Flowable<String>> is = Arrays.asList(f1, f2, f3);",
        "label":1
    },
    {
        "ins1CurCode":"public void setLocaltunnels(final String tunnels) { for (String tunnelSpec : tunnels.split(\", \")) { if (tunnelSpec.length() > 0) { final String[] spec = tunnelSpec.split(\":\", 3); final int lport = Integer.parseInt(spec[0]);",
        "ins1PreCode":"public void setLocaltunnels(final String tunnels) { final String[] specs = tunnels.split(\", \"); for (int i = 0; i < specs.length; i++) { if (specs[i].length() > 0) { final String[] spec = specs[i].split(\":\", 3); final int lport = Integer.parseInt(spec[0]);",
        "ins2PreCode":"public void setRemotetunnels(final String tunnels) { final String[] specs = tunnels.split(\", \"); for (int i = 0; i < specs.length; i++) { if (specs[i].length() > 0) { final String[] spec = specs[i].split(\":\", 3); final int rport = Integer.parseInt(spec[0]);",
        "label":1
    },
    {
        "ins1CurCode":"for (Class<? extends Decoder> decoderClazz : decoderClazzes) { if (Text.class.isAssignableFrom(decoderClazz)) { Text<?> decoder = (Text<?>) decoderClazz.getDeclaredConstructor().newInstance(); decoder.init(config); decoders.add(decoder); } else if (TextStream.class.isAssignableFrom( decoderClazz)) { TextStream<?> decoder = (TextStream<?>) decoderClazz.getDeclaredConstructor().newInstance(); decoder.init(config); decoders.add(decoder); } else {  } } } } catch (ReflectiveOperationException e) { throw new IllegalArgumentException(e);",
        "ins1PreCode":"for (Class<? extends Decoder> decoderClazz : decoderClazzes) { if (Text.class.isAssignableFrom(decoderClazz)) { Text<?> decoder = (Text<?>) decoderClazz.newInstance(); decoder.init(config); decoders.add(decoder); } else if (TextStream.class.isAssignableFrom( decoderClazz)) { TextStream<?> decoder = (TextStream<?>) decoderClazz.newInstance(); decoder.init(config); decoders.add(decoder); } else {  } } } } catch (IllegalAccessException | InstantiationException e) { throw new IllegalArgumentException(e);",
        "ins2PreCode":"if (Binary.class.isAssignableFrom(decoderClazz)) { Binary<?> decoder = (Binary<?>) decoderClazz.newInstance(); decoder.init(config); decoders.add(decoder); } else if (BinaryStream.class.isAssignableFrom( decoderClazz)) { BinaryStream<?> decoder = (BinaryStream<?>) decoderClazz.newInstance(); decoder.init(config); decoders.add(decoder); } else {  } } } } catch (IllegalAccessException | InstantiationException e) { throw new IllegalArgumentException(e);",
        "label":1
    },
    {
        "ins1CurCode":"expected.remove(IsbnViaChimboriFetcher.class); expected.remove(IsbnViaEbookDeFetcher.class); expected.remove(IsbnViaOttoBibFetcher.class); assertEquals(expected, getClasses(idFetchers));",
        "ins1PreCode":"expected.remove(IsbnViaChimboriFetcher.class); expected.remove(IsbnViaEbookDeFetcher.class); assertEquals(expected, getClasses(idFetchers));",
        "ins2PreCode":"assertEquals(expected, getClasses(searchBasedFetchers)); }",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerMaybeObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void tryTerminateConsumerMaybeObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerSingleError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"void createWithNameShouldAddMapping() { ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases(",
        "ins1PreCode":"public void createWithNameShouldAddMapping() { ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases(",
        "ins2PreCode":"public void addAliasesFromNameShouldAddMapping() { ConfigurationPropertyNameAliases aliases = new ConfigurationPropertyNameAliases();",
        "label":1
    },
    {
        "ins1CurCode":"Exceptions.throwIfFatal(exc); cancelAndClear(); errors.tryAddThrowableOrReport(exc); errors.tryTerminateConsumer(downstream); return; } v1 = a; } boolean e1 = a == null;  boolean d2 = second.done; T b = v2; if (b == null) { try { b = q2.poll(); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); cancelAndClear(); errors.tryAddThrowableOrReport(exc); errors.tryTerminateConsumer(downstream); return; } v2 = b; }  boolean e2 = b == null;  if (d1 && d2 && e1 && e2) { complete(true); return; } if ((d1 && d2) && (e1 != e2)) { cancelAndClear(); complete(false); return; }  if (e1 || e2) { break; }  boolean c;  try { c = comparer.test(a, b); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); cancelAndClear(); errors.tryAddThrowableOrReport(exc); errors.tryTerminateConsumer(downstream);",
        "ins1PreCode":"Exceptions.throwIfFatal(exc); cancelAndClear(); if (errors.addThrowable(exc)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(exc); } return; } v1 = a; } boolean e1 = a == null;  boolean d2 = second.done; T b = v2; if (b == null) { try { b = q2.poll(); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); cancelAndClear(); if (errors.addThrowable(exc)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(exc); } return; } v2 = b; }  boolean e2 = b == null;  if (d1 && d2 && e1 && e2) { complete(true); return; } if ((d1 && d2) && (e1 != e2)) { cancelAndClear(); complete(false); return; }  if (e1 || e2) { break; }  boolean c;  try { c = comparer.test(a, b); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); cancelAndClear(); errors.addThrowable(exc); errors.tryTerminateConsumer(downstream);",
        "ins2PreCode":"Exceptions.throwIfFatal(exc); cancelAndClear(); if (errors.addThrowable(exc)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(exc); } return; } v1 = a; } boolean e1 = a == null;  boolean d2 = second.done; T b = v2; if (b == null) { try { b = q2.poll(); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); cancelAndClear(); if (errors.addThrowable(exc)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(exc); } return; } v2 = b; }  boolean e2 = b == null;  if (d1 && d2 && e1 && e2) { downstream.onSuccess(true); return; } if ((d1 && d2) && (e1 != e2)) { cancelAndClear(); downstream.onSuccess(false); return; }  if (e1 || e2) { break; }  boolean c;  try { c = comparer.test(a, b); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); cancelAndClear(); errors.addThrowable(exc); errors.tryTerminateConsumer(downstream);",
        "label":1
    },
    {
        "ins1CurCode":"  final DoubleValuesSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.needsScores(); bindings.add(variable, valueSource); }",
        "ins1PreCode":"  final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); }",
        "ins2PreCode":"  final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); }",
        "label":1
    },
    {
        "ins1CurCode":"if (gm instanceof CollabDiagramGraphModel) { Object collaboration = ((CollabDiagramGraphModel) gm).getOwner(); node = Model.getCollaborationsFactory().buildLifeline(collaboration); } else {",
        "ins1PreCode":"if (gm instanceof CollabDiagramGraphModel) { Object collaboration = ((CollabDiagramGraphModel) gm).getHomeModel(); node = Model.getCollaborationsFactory().buildClassifierRole( collaboration); } else {",
        "ins2PreCode":"public Object makeNode() { Object node = null; Editor ce = Globals.curEditor(); GraphModel gm = ce.getGraphModel(); if (gm instanceof SequenceDiagramGraphModel) { Object owner = ((SequenceDiagramGraphModel) gm).getOwner(); node = Model.getCollaborationsFactory().buildLifeline(owner); } else { throw new IllegalStateException(\"Graphmodel is not a \" + \"sequence diagram graph model\"); } return node;",
        "label":0
    },
    {
        "ins1CurCode":"void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap();",
        "ins1PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap();",
        "ins2PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap();",
        "label":1
    },
    {
        "ins1CurCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}}; CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1PreCode":"  Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; ",
        "ins2PreCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; ",
        "label":1
    },
    {
        "ins1CurCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T, R> Flowable<R> zipArray(Function<? super Object[], ? extends R> zipper, boolean delayError, int bufferSize, Publisher<? extends T>... sources) { if (sources.length == 0) {",
        "label":1
    },
    {
        "ins1CurCode":"private Element getChild(String name, Element e) { if (e == null) { return null;",
        "ins1PreCode":"private Element getChild(String name, Element e) { NodeList children = e.getChildNodes(); ",
        "ins2PreCode":"private List<Element> getChildren(String name, Element e) { List<Element> result = new LinkedList<>(); NodeList children = e.getChildNodes();  int j = children.getLength(); for (int i = 0; i < j; i++) { Node test = children.item(i); if (test.getNodeType() == Node.ELEMENT_NODE) { Element entry = (Element) test; if (entry.getTagName().equals(name)) { result.add(entry); } } }  return result;",
        "label":0
    },
    {
        "ins1CurCode":"public void putEdge_existingSelfLoopEdgeBetweenSameNodes() { assume().that(graphIsMutable()).isTrue(); assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void putEdge_existingSelfLoopEdgeBetweenSameNodes() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void putEdge_existingSelfLoopEdgeBetweenSameNodes() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"SafeObserver<Integer> so = new SafeObserver<Integer>(to);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"SafeObserver<Integer> so = new SafeObserver<Integer>(to);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"SafeObserver<Integer> so = new SafeObserver<Integer>(to);  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull T7, @NonNull R> Observable<R> combineLatest( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2,",
        "ins1PreCode":"public static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> combineLatest( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2,",
        "ins2PreCode":"public static <T1, T2, T3, T4, T5, T6, T7, R> Observable<R> zip( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3,",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldCompleteIfUnderlyingComletes() { Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<>(subscriber); withTimeout.subscribe(subscriber);",
        "ins1PreCode":"public void shouldCompleteIfUnderlyingComletes() { Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber); withTimeout.subscribe(subscriber);",
        "ins2PreCode":"public void shouldCompleteIfUnderlyingComletes() { Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); withTimeout.subscribe(observer);",
        "label":1
    },
    {
        "ins1CurCode":"assertFalse(ro.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertFalse(ro.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertFalse(ro.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"return current; } return queue.get();",
        "ins1PreCode":"SpscLinkedArrayQueue<R> getOrCreateQueue() { for (;;) { SpscLinkedArrayQueue<R> current = queue.get();",
        "ins2PreCode":"SpscLinkedArrayQueue<R> getOrCreateQueue() { for (;;) { SpscLinkedArrayQueue<R> current = queue.get();",
        "label":1
    },
    {
        "ins1CurCode":"public void adjacentNodes_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N1);",
        "ins1PreCode":"public void adjacentNodes_checkReturnedSetMutability() { addNode(N1); Set<Integer> adjacentNodes = network.adjacentNodes(N1); try {",
        "ins2PreCode":"public void adjacentNodes_checkReturnedSetMutability() { addNode(N1); Set<Integer> adjacentNodes = network.adjacentNodes(N1); try { adjacentNodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes); }",
        "label":0
    },
    {
        "ins1CurCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\"), TooltipTextUtil.createText(\" author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();",
        "ins2PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the term \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, false, query).getDescription();",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StackedXYAreaRenderer r1 = new StackedXYAreaRenderer(); StackedXYAreaRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYAreaRenderer r1 = new StackedXYAreaRenderer(); StackedXYAreaRenderer r2 = (StackedXYAreaRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer(); ClusteredXYBarRenderer r2 = (ClusteredXYBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldGetUserArray() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldGetUserArray() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User[] users = mapper.getUsers(); assertEquals(\"User1\", users[0].getName()); assertEquals(\"User2\", users[1].getName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldGetUserArrayXml() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User[] users = mapper.getUsersXml(); assertEquals(\"User1\", users[0].getName()); assertEquals(\"User2\", users[1].getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"flowablePlain = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) { return Flowable.empty(); } });  flowableConvert = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) { return Completable.complete().toFlowable(); } });  flowableDedicated = source.flatMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) { return Completable.complete();",
        "ins1PreCode":"flowablePlain = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.empty(); } });  flowableConvert = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Completable.complete().toFlowable(); } });  flowableDedicated = source.flatMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) throws Exception { return Completable.complete();",
        "ins2PreCode":"flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.empty(); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Completable.complete().toFlowable(); } });  flowableDedicated = source.switchMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) throws Exception { return Completable.complete();",
        "label":1
    },
    {
        "ins1CurCode":"  BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/result_handler/CreateDB.sql\");",
        "ins1PreCode":"  SqlSession session = sqlSessionFactory.openSession(); Connection conn = session.getConnection(); reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/result_handler/CreateDB.sql\"); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.runScript(reader); conn.close(); reader.close(); session.close();",
        "ins2PreCode":"public void setUp() throws Exception { Connection conn = null;  try { Class.forName(\"org.hsqldb.jdbcDriver\"); conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:lname\", \"sa\", \"\");  Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/CreateDB.sql\");  ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); runner.runScript(reader); conn.commit(); reader.close();  reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/MapperConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class); } finally { if (conn != null) { conn.close(); }",
        "label":0
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposable.empty()); observer.onComplete();",
        "ins1PreCode":"@Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "ins2PreCode":"@Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty()); to.dispose();",
        "label":1
    },
    {
        "ins1CurCode":"T message, byte[] data, int position, int limit, Registers registers) throws IOException { final sun.misc.Unsafe unsafe = UNSAFE; int currentPresenceFieldOffset = NO_PRESENCE_SENTINEL; int currentPresenceField = 0; int tag = 0; int oldNumber = -1; int pos = 0; while (position < limit) { tag = data[position++]; if (tag < 0) { position = decodeVarint32(tag, data, position, registers); tag = registers.int1; } final int number = tag >>> 3; final int wireType = tag & 0x7; if (number > oldNumber) { pos = positionForFieldNumber(number, pos / INTS_PER_FIELD); } else { pos = positionForFieldNumber(number); } oldNumber = number; if (pos == -1) {  pos = 0; } else { final int typeAndOffset = buffer[pos + 1]; final int fieldType = type(typeAndOffset); final long fieldOffset = offset(typeAndOffset); if (fieldType <= 17) {  final int presenceMaskAndOffset = buffer[pos + 2]; final int presenceMask = 1 << (presenceMaskAndOffset >>> OFFSET_BITS); final int presenceFieldOffset = presenceMaskAndOffset & OFFSET_MASK;      if (presenceFieldOffset != currentPresenceFieldOffset) { if (currentPresenceFieldOffset != NO_PRESENCE_SENTINEL) { unsafe.putInt(message, (long) currentPresenceFieldOffset, currentPresenceField); } if (presenceFieldOffset != NO_PRESENCE_SENTINEL) { currentPresenceField = unsafe.getInt(message, (long) presenceFieldOffset); } currentPresenceFieldOffset = presenceFieldOffset; } switch (fieldType) { case 0: if (wireType == WireFormat.WIRETYPE_FIXED64) { UnsafeUtil.putDouble(message, fieldOffset, decodeDouble(data, position)); position += 8; currentPresenceField |= presenceMask; continue; } break; case 1: if (wireType == WireFormat.WIRETYPE_FIXED32) { UnsafeUtil.putFloat(message, fieldOffset, decodeFloat(data, position)); position += 4; currentPresenceField |= presenceMask; continue; } break; case 2: case 3: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); unsafe.putLong(message, fieldOffset, registers.long1); currentPresenceField |= presenceMask; continue; } break; case 4: case 11: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt(message, fieldOffset, registers.int1); currentPresenceField |= presenceMask; continue; } break; case 5: case 14: if (wireType == WireFormat.WIRETYPE_FIXED64) { unsafe.putLong(message, fieldOffset, decodeFixed64(data, position)); position += 8; currentPresenceField |= presenceMask; continue; } break; case 6: case 13: if (wireType == WireFormat.WIRETYPE_FIXED32) { unsafe.putInt(message, fieldOffset, decodeFixed32(data, position)); position += 4; currentPresenceField |= presenceMask; continue; } break; case 7: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); UnsafeUtil.putBoolean(message, fieldOffset, registers.long1 != 0); currentPresenceField |= presenceMask; continue; } break; case 8: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { if ((typeAndOffset & ENFORCE_UTF8_MASK) == 0) { position = decodeString(data, position, registers); } else { position = decodeStringRequireUtf8(data, position, registers); } unsafe.putObject(message, fieldOffset, registers.object1); currentPresenceField |= presenceMask; continue; } break; case 9: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { position = decodeMessageField( getMessageFieldSchema(pos), data, position, limit, registers); final Object oldValue = unsafe.getObject(message, fieldOffset); if (oldValue == null) { unsafe.putObject(message, fieldOffset, registers.object1); } else { unsafe.putObject( message, fieldOffset, Internal.mergeMessage(oldValue, registers.object1)); } currentPresenceField |= presenceMask; continue; } break; case 10: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { position = decodeBytes(data, position, registers); unsafe.putObject(message, fieldOffset, registers.object1); currentPresenceField |= presenceMask; continue; } break; case 12: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt(message, fieldOffset, registers.int1); currentPresenceField |= presenceMask; continue; } break; case 15: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt( message, fieldOffset, CodedInputStream.decodeZigZag32(registers.int1)); currentPresenceField |= presenceMask; continue; } break; case 16: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); unsafe.putLong( message, fieldOffset, CodedInputStream.decodeZigZag64(registers.long1)); currentPresenceField |= presenceMask; continue; } break; default: break; } } else if (fieldType == 27) {  if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { ProtobufList<?> list = (ProtobufList<?>) unsafe.getObject(message, fieldOffset); if (!list.isModifiable()) { final int size = list.size(); list = list.mutableCopyWithCapacity( size == 0 ? AbstractProtobufList.DEFAULT_CAPACITY : size * 2); unsafe.putObject(message, fieldOffset, list); } position = decodeMessageList( getMessageFieldSchema(pos), tag, data, position, limit, list, registers); continue; } } else if (fieldType <= 49) {  final int oldPosition = position; position = parseRepeatedField( message, data, position, limit, tag, number, wireType, pos, typeAndOffset, fieldType, fieldOffset, registers); if (position != oldPosition) { continue; } } else if (fieldType == 50) { if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { final int oldPosition = position; position = parseMapField(message, data, position, limit, pos, fieldOffset, registers); if (position != oldPosition) { continue; } } } else { final int oldPosition = position; position = parseOneofField( message, data, position, limit, tag, number, wireType, typeAndOffset, fieldType, fieldOffset, pos, registers); if (position != oldPosition) { continue; } } } position = decodeUnknownField( tag, data, position, limit, getMutableUnknownFields(message), registers); } if (currentPresenceFieldOffset != NO_PRESENCE_SENTINEL) { unsafe.putInt(message, (long) currentPresenceFieldOffset, currentPresenceField); }",
        "ins1PreCode":"T message, byte[] data, int position, int limit, Registers registers) throws IOException { final sun.misc.Unsafe unsafe = UNSAFE; int tag = 0; int oldNumber = -1; int pos = 0; while (position < limit) { tag = data[position++]; if (tag < 0) { position = decodeVarint32(tag, data, position, registers); tag = registers.int1; } final int number = tag >>> 3; final int wireType = tag & 0x7; if (number > oldNumber) { pos = positionForFieldNumber(number, pos / INTS_PER_FIELD); } else { pos = positionForFieldNumber(number); } oldNumber = number; if (pos == -1) {  pos = 0; } else { final int typeAndOffset = buffer[pos + 1]; final int fieldType = type(typeAndOffset); final long fieldOffset = offset(typeAndOffset); if (fieldType <= 17) { switch (fieldType) { case 0: if (wireType == WireFormat.WIRETYPE_FIXED64) { UnsafeUtil.putDouble(message, fieldOffset, decodeDouble(data, position)); position += 8; continue; } break; case 1: if (wireType == WireFormat.WIRETYPE_FIXED32) { UnsafeUtil.putFloat(message, fieldOffset, decodeFloat(data, position)); position += 4; continue; } break; case 2: case 3: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); unsafe.putLong(message, fieldOffset, registers.long1); continue; } break; case 4: case 11: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt(message, fieldOffset, registers.int1); continue; } break; case 5: case 14: if (wireType == WireFormat.WIRETYPE_FIXED64) { unsafe.putLong(message, fieldOffset, decodeFixed64(data, position)); position += 8; continue; } break; case 6: case 13: if (wireType == WireFormat.WIRETYPE_FIXED32) { unsafe.putInt(message, fieldOffset, decodeFixed32(data, position)); position += 4; continue; } break; case 7: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); UnsafeUtil.putBoolean(message, fieldOffset, registers.long1 != 0); continue; } break; case 8: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { if ((typeAndOffset & ENFORCE_UTF8_MASK) == 0) { position = decodeString(data, position, registers); } else { position = decodeStringRequireUtf8(data, position, registers); } unsafe.putObject(message, fieldOffset, registers.object1); continue; } break; case 9: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { position = decodeMessageField( getMessageFieldSchema(pos), data, position, limit, registers); final Object oldValue = unsafe.getObject(message, fieldOffset); if (oldValue == null) { unsafe.putObject(message, fieldOffset, registers.object1); } else { unsafe.putObject( message, fieldOffset, Internal.mergeMessage(oldValue, registers.object1)); } continue; } break; case 10: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { position = decodeBytes(data, position, registers); unsafe.putObject(message, fieldOffset, registers.object1); continue; } break; case 12: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt(message, fieldOffset, registers.int1); continue; } break; case 15: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt( message, fieldOffset, CodedInputStream.decodeZigZag32(registers.int1)); continue; } break; case 16: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); unsafe.putLong( message, fieldOffset, CodedInputStream.decodeZigZag64(registers.long1)); continue; } break; default: break; } } else if (fieldType == 27) {  if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { ProtobufList<?> list = (ProtobufList<?>) unsafe.getObject(message, fieldOffset); if (!list.isModifiable()) { final int size = list.size(); list = list.mutableCopyWithCapacity( size == 0 ? AbstractProtobufList.DEFAULT_CAPACITY : size * 2); unsafe.putObject(message, fieldOffset, list); } position = decodeMessageList( getMessageFieldSchema(pos), tag, data, position, limit, list, registers); continue; } } else if (fieldType <= 49) {  final int oldPosition = position; position = parseRepeatedField( message, data, position, limit, tag, number, wireType, pos, typeAndOffset, fieldType, fieldOffset, registers); if (position != oldPosition) { continue; } } else if (fieldType == 50) { if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { final int oldPosition = position; position = parseMapField(message, data, position, limit, pos, fieldOffset, registers); if (position != oldPosition) { continue; } } } else { final int oldPosition = position; position = parseOneofField( message, data, position, limit, tag, number, wireType, typeAndOffset, fieldType, fieldOffset, pos, registers); if (position != oldPosition) { continue; } } } position = decodeUnknownField( tag, data, position, limit, getMutableUnknownFields(message), registers); } if (position != limit) { throw InvalidProtocolBufferException.parseFailure(); } return position;",
        "ins2PreCode":"throws IOException { final sun.misc.Unsafe unsafe = UNSAFE; int currentPresenceFieldOffset = -1; int currentPresenceField = 0; int tag = 0; int oldNumber = -1; int pos = 0; while (position < limit) { tag = data[position++]; if (tag < 0) { position = decodeVarint32(tag, data, position, registers); tag = registers.int1; } final int number = tag >>> 3; final int wireType = tag & 0x7; if (number > oldNumber) { pos = positionForFieldNumber(number, pos / INTS_PER_FIELD); } else { pos = positionForFieldNumber(number); } oldNumber = number; if (pos == -1) {  pos = 0; } else { final int typeAndOffset = buffer[pos + 1]; final int fieldType = type(typeAndOffset); final long fieldOffset = offset(typeAndOffset); if (fieldType <= 17) {  final int presenceMaskAndOffset = buffer[pos + 2]; final int presenceMask = 1 << (presenceMaskAndOffset >>> OFFSET_BITS); final int presenceFieldOffset = presenceMaskAndOffset & OFFSET_MASK;   if (presenceFieldOffset != currentPresenceFieldOffset) { if (currentPresenceFieldOffset != -1) { unsafe.putInt(message, (long) currentPresenceFieldOffset, currentPresenceField); } currentPresenceFieldOffset = presenceFieldOffset; currentPresenceField = unsafe.getInt(message, (long) presenceFieldOffset); } switch (fieldType) { case 0: if (wireType == WireFormat.WIRETYPE_FIXED64) { UnsafeUtil.putDouble(message, fieldOffset, decodeDouble(data, position)); position += 8; currentPresenceField |= presenceMask; continue; } break; case 1: if (wireType == WireFormat.WIRETYPE_FIXED32) { UnsafeUtil.putFloat(message, fieldOffset, decodeFloat(data, position)); position += 4; currentPresenceField |= presenceMask; continue; } break; case 2: case 3: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); unsafe.putLong(message, fieldOffset, registers.long1); currentPresenceField |= presenceMask; continue; } break; case 4: case 11: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt(message, fieldOffset, registers.int1); currentPresenceField |= presenceMask; continue; } break; case 5: case 14: if (wireType == WireFormat.WIRETYPE_FIXED64) { unsafe.putLong(message, fieldOffset, decodeFixed64(data, position)); position += 8; currentPresenceField |= presenceMask; continue; } break; case 6: case 13: if (wireType == WireFormat.WIRETYPE_FIXED32) { unsafe.putInt(message, fieldOffset, decodeFixed32(data, position)); position += 4; currentPresenceField |= presenceMask; continue; } break; case 7: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); UnsafeUtil.putBoolean(message, fieldOffset, registers.long1 != 0); currentPresenceField |= presenceMask; continue; } break; case 8: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { if ((typeAndOffset & ENFORCE_UTF8_MASK) == 0) { position = decodeString(data, position, registers); } else { position = decodeStringRequireUtf8(data, position, registers); } unsafe.putObject(message, fieldOffset, registers.object1); currentPresenceField |= presenceMask; continue; } break; case 9: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { position = decodeMessageField( getMessageFieldSchema(pos), data, position, limit, registers); if ((currentPresenceField & presenceMask) == 0) { unsafe.putObject(message, fieldOffset, registers.object1); } else { unsafe.putObject( message, fieldOffset, Internal.mergeMessage( unsafe.getObject(message, fieldOffset), registers.object1)); } currentPresenceField |= presenceMask; continue; } break; case 10: if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { position = decodeBytes(data, position, registers); unsafe.putObject(message, fieldOffset, registers.object1); currentPresenceField |= presenceMask; continue; } break; case 12: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); final int enumValue = registers.int1; EnumVerifier enumVerifier = getEnumFieldVerifier(pos); if (enumVerifier == null || enumVerifier.isInRange(enumValue)) { unsafe.putInt(message, fieldOffset, enumValue); currentPresenceField |= presenceMask; } else {  getMutableUnknownFields(message).storeField(tag, (long) enumValue); } continue; } break; case 15: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint32(data, position, registers); unsafe.putInt( message, fieldOffset, CodedInputStream.decodeZigZag32(registers.int1)); currentPresenceField |= presenceMask; continue; } break; case 16: if (wireType == WireFormat.WIRETYPE_VARINT) { position = decodeVarint64(data, position, registers); unsafe.putLong( message, fieldOffset, CodedInputStream.decodeZigZag64(registers.long1));  currentPresenceField |= presenceMask; continue; } break; case 17: if (wireType == WireFormat.WIRETYPE_START_GROUP) { final int endTag = (number << 3) | WireFormat.WIRETYPE_END_GROUP; position = decodeGroupField( getMessageFieldSchema(pos), data, position, limit, endTag, registers); if ((currentPresenceField & presenceMask) == 0) { unsafe.putObject(message, fieldOffset, registers.object1); } else { unsafe.putObject( message, fieldOffset, Internal.mergeMessage( unsafe.getObject(message, fieldOffset), registers.object1)); }  currentPresenceField |= presenceMask; continue; } break; default: break; } } else if (fieldType == 27) {  if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { ProtobufList<?> list = (ProtobufList<?>) unsafe.getObject(message, fieldOffset); if (!list.isModifiable()) { final int size = list.size(); list = list.mutableCopyWithCapacity( size == 0 ? AbstractProtobufList.DEFAULT_CAPACITY : size * 2); unsafe.putObject(message, fieldOffset, list); } position = decodeMessageList( getMessageFieldSchema(pos), tag, data, position, limit, list, registers); continue; } } else if (fieldType <= 49) {  final int oldPosition = position; position = parseRepeatedField( message, data, position, limit, tag, number, wireType, pos, typeAndOffset, fieldType, fieldOffset, registers); if (position != oldPosition) { continue; } } else if (fieldType == 50) { if (wireType == WireFormat.WIRETYPE_LENGTH_DELIMITED) { final int oldPosition = position; position = parseMapField(message, data, position, limit, pos, fieldOffset, registers); if (position != oldPosition) { continue; } } } else { final int oldPosition = position; position = parseOneofField( message, data, position, limit, tag, number, wireType, typeAndOffset, fieldType, fieldOffset, pos, registers); if (position != oldPosition) { continue; } } } if (tag == endGroup && endGroup != 0) { break; }  if (hasExtensions && registers.extensionRegistry != ExtensionRegistryLite.getEmptyRegistry()) { position = decodeExtensionOrUnknownField( tag, data, position, limit, message, defaultInstance, (UnknownFieldSchema<UnknownFieldSetLite, UnknownFieldSetLite>) unknownFieldSchema, registers); } else { position = decodeUnknownField( tag, data, position, limit, getMutableUnknownFields(message), registers); } } if (currentPresenceFieldOffset != -1) { unsafe.putInt(message, (long) currentPresenceFieldOffset, currentPresenceField);",
        "label":0
    },
    {
        "ins1CurCode":"ftp.storeFile(tempFile.getName(), instream); instream.close(); if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) { FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());",
        "ins1PreCode":"ftp.storeFile(tempFile.getName(), instream); instream.close(); boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode()); if (success) { FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName());",
        "ins2PreCode":"private long getTimeDiff(FTPClient ftp) { long returnValue = 0; File tempFile = findFileName(ftp); try {  FILE_UTILS.createNewFile(tempFile); long localTimeStamp = tempFile.lastModified(); BufferedInputStream instream = new BufferedInputStream(Files.newInputStream(tempFile.toPath())); ftp.storeFile(tempFile.getName(), instream); instream.close(); boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode()); if (success) { FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName()); if (ftpFiles.length == 1) { long remoteTimeStamp = ftpFiles[0].getTimestamp().getTime().getTime(); returnValue = localTimeStamp - remoteTimeStamp; } ftp.deleteFile(ftpFiles[0].getName()); }   Delete mydelete = new Delete(); mydelete.bindToOwner(this); mydelete.setFile(tempFile.getCanonicalFile()); mydelete.execute(); } catch (Exception e) { throw new BuildException(e, getLocation()); } return returnValue;",
        "label":0
    },
    {
        "ins1CurCode":"tokenizer = new StringTokenizer(bases, \",\");  List<Object> classifiers = new ArrayList<Object>(); Object ns = Model.getFacade().getNamespace(modelElement);",
        "ins1PreCode":"tokenizer = new StringTokenizer(bases, \",\");  List classifiers = new ArrayList(); Object ns = Model.getFacade().getNamespace(modelElement);",
        "ins2PreCode":"tokenizer = new StringTokenizer(bases, \",\");  List classifiers = new ArrayList(); Object ns = Model.getFacade().getNamespace(modelElement);",
        "label":1
    },
    {
        "ins1CurCode":"public void runDTUsingConstructor() { List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = jsc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<>();",
        "ins1PreCode":"public void runDTUsingConstructor() { List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<>();",
        "ins2PreCode":"public void runDTUsingStaticMethods() { List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"description\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \");",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"comment\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \");",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { StringBuilder query = new StringBuilder(\"ALTER TABLE \"); query.append(command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL)).append(\" \"); appendTableModifiers(monitor, command.getObject(), command, query, true);  actionList.add( new SQLDatabasePersistAction(query.toString()) );",
        "label":0
    },
    {
        "ins1CurCode":"public ProjectHelper getProjectHelperForBuildFile(Resource buildFile) throws BuildException { ProjectHelper ph = StreamUtils.iteratorAsStream(getHelpers()) .filter(helper -> helper.canParseBuildFile(buildFile)) .findFirst().orElse(null);  if (ph == null) { throw new BuildException(\"BUG: at least the ProjectHelper2 should \" + \"have supported the file \" + buildFile); } if (DEBUG) { System.out.println(\"ProjectHelper \" + ph.getClass().getName() + \" selected for the build file \" + buildFile); } return ph;",
        "ins1PreCode":"public ProjectHelper getProjectHelperForBuildFile(Resource buildFile) throws BuildException { for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) { ProjectHelper helper = it.next(); if (helper.canParseBuildFile(buildFile)) { if (DEBUG) { System.out.println(\"ProjectHelper \" + helper.getClass().getName() + \" selected for the build file \" + buildFile); } return helper; }",
        "ins2PreCode":"public ProjectHelper getProjectHelperForAntlib(Resource antlib) throws BuildException { for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) { ProjectHelper helper = it.next(); if (helper.canParseAntlibDescriptor(antlib)) { if (DEBUG) { System.out.println(\"ProjectHelper \" + helper.getClass().getName() + \" selected for the antlib \" + antlib); } return helper; }",
        "label":0
    },
    {
        "ins1CurCode":"int users = 100; int products = 200; Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); ",
        "ins1PreCode":"int users = 100; int products = 200; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); ",
        "ins2PreCode":"int users = 80; int products = 160; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, true); ",
        "label":1
    },
    {
        "ins1CurCode":"public void assertNotMatchCount() { assertThrows(AssertionError.class, () -> { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber);  subscriber.assertValue(1); subscriber.assertValueCount(2); subscriber.assertComplete().assertNoErrors(); });",
        "ins1PreCode":"oi.subscribe(subscriber);  thrown.expect(AssertionError.class); ",
        "ins2PreCode":"public void assertTestObserver() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber);  subscriber.assertValues(1, 2); subscriber.assertValueCount(2); subscriber.assertComplete().assertNoErrors();",
        "label":0
    },
    {
        "ins1CurCode":"}  if (action == LIST_FILES && listing == null) { throw new BuildException(",
        "ins1PreCode":"}  if ((action == LIST_FILES) && (listing == null)) { throw new BuildException(",
        "ins2PreCode":"}  if ((action == LIST_FILES) && (listing == null)) { throw new BuildException(",
        "label":1
    },
    {
        "ins1CurCode":"public void assertTestSubscriber() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<>(); oi.subscribe(ts);",
        "ins1PreCode":"public void assertTestSubscriber() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); oi.subscribe(ts);",
        "ins2PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"public void printBannerShouldPrintMargin() { AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER);",
        "ins1PreCode":"public void printBannerShouldPrintMargin() throws Exception { AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER);",
        "ins2PreCode":"public void printBannerWhenHasMarginPropertyShouldPrintSizedMargin() throws Exception { AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER);",
        "label":1
    },
    {
        "ins1CurCode":"} } return Collections.unmodifiableList( list );",
        "ins1PreCode":"} } return list;",
        "ins2PreCode":"List<Dependency> list = new ArrayList<>( artifacts.size() );  for ( Artifact a : getArtifacts()  ) {  if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ) { Dependency dependency = new Dependency();  dependency.setArtifactId( a.getArtifactId() ); dependency.setGroupId( a.getGroupId() ); dependency.setVersion( a.getVersion() ); dependency.setScope( a.getScope() ); dependency.setType( a.getType() ); dependency.setClassifier( a.getClassifier() );  list.add( dependency ); } } return list;",
        "label":1
    },
    {
        "ins1CurCode":"return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableSwitchMap<>(this, mapper, bufferSize, false));",
        "ins1PreCode":"return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, false));",
        "ins2PreCode":"return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, true));",
        "label":1
    },
    {
        "ins1CurCode":"setSuppressCalcBounds(false);  setBounds(X0, Y0, WIDTH, STEREOHEIGHT + NAME_FIG_HEIGHT);",
        "ins1PreCode":"setSuppressCalcBounds(false);  setBounds(X0, Y0, WIDTH, 22 + 2 * ROWHEIGHT);",
        "ins2PreCode":" enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "label":0
    },
    {
        "ins1CurCode":"public void responseToOptionsRequestIncludesCorsHeaders() { this.contextRunner.run(withWebTestClient((client) -> client.options() .uri(\"/cfApplication/test\").accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus().isOk() .expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\")));",
        "ins1PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class, (client) -> client.options() .uri(\"/cfApplication/test\").accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus().isOk() .expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "ins2PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class, (client) -> client.options().uri(\"/cfApplication/test\") .accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus() .isOk().expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader() .valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "label":0
    },
    {
        "ins1CurCode":"public WebServer getWebServer(HttpHandler httpHandler) { if (this.disableMBeanRegistry) { Registry.disableRegistry(); }",
        "ins1PreCode":"public WebServer getWebServer(HttpHandler httpHandler) { Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");",
        "ins2PreCode":"public WebServer getWebServer(ServletContextInitializer... initializers) { Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testToStringHelperLenient_moreThanNineAnonymousClasses() {  Object unused1 = new Object() {}; Object unused2 = new Object() {}; Object unused3 = new Object() {}; Object unused4 = new Object() {}; Object unused5 = new Object() {}; Object unused6 = new Object() {}; Object unused7 = new Object() {}; Object unused8 = new Object() {}; Object unused9 = new Object() {}; Object o10 = new Object() {};",
        "ins1PreCode":"public void testToStringHelperLenient_moreThanNineAnonymousClasses() {  Object o1 = new Object() {}; Object o2 = new Object() {}; Object o3 = new Object() {}; Object o4 = new Object() {}; Object o5 = new Object() {}; Object o6 = new Object() {}; Object o7 = new Object() {}; Object o8 = new Object() {}; Object o9 = new Object() {}; Object o10 = new Object() {};",
        "ins2PreCode":"public void testToStringHelper_moreThanNineAnonymousClasses() {  Object o1 = new Object() {}; Object o2 = new Object() {}; Object o3 = new Object() {}; Object o4 = new Object() {}; Object o5 = new Object() {}; Object o6 = new Object() {}; Object o7 = new Object() {}; Object o8 = new Object() {}; Object o9 = new Object() {}; Object o10 = new Object() {};",
        "label":1
    },
    {
        "ins1CurCode":"void setIgnoreBeanInfoPropertyByDefault(CapturedOutput capturedOutput) { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins1PreCode":"public void setIgnoreBeanInfoPropertyByDefault() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins2PreCode":"public void disableIgnoreBeanInfoProperty() { System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, \"false\");",
        "label":0
    },
    {
        "ins1CurCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);",
        "ins1PreCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "ins2PreCode":"public void completePartOfWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"public void unorderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<>(1); Disposable d = Disposable.empty();",
        "ins1PreCode":"public void unorderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "ins2PreCode":"public void orderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1CurCode":"File appDir = new File(\"test/webapp-3.0\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(3, context.getEffectiveMajorVersion());",
        "ins1PreCode":"File appDir = new File(\"test/webapp-3.0\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(3, context.getEffectiveMajorVersion());",
        "ins2PreCode":"File appDir = new File(\"test/webapp-3.1\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(3, context.getEffectiveMajorVersion());",
        "label":1
    },
    {
        "ins1CurCode":"void responseIsCommittedWhenRequestIsAsyncAndExceptionIsThrown() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "ins1PreCode":"public void responseIsCommittedWhenRequestIsAsyncAndExceptionIsThrown() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "ins2PreCode":"public void responseIsCommittedWhenRequestIsAsyncAndStatusIs400Plus() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "label":1
    },
    {
        "ins1CurCode":"void wrap() throws Exception { XADataSource dataSource = mock(XADataSource.class);",
        "ins1PreCode":"public void wrap() throws Exception { XADataSource dataSource = mock(XADataSource.class);",
        "ins2PreCode":"public void wrap() throws Exception { XADataSource dataSource = mock(XADataSource.class);",
        "label":1
    },
    {
        "ins1CurCode":"return false; } if (!Objects.equals(this.data, that.data)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtils.equal(this.data, that.data)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtils.equal(this.data, that.data)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"public void errorDelegateThrows() { TestObserverEx<Integer> to = new TestObserverEx<>(new Observer<Integer>() { ",
        "ins1PreCode":"public void errorDelegateThrows() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(new Observer<Integer>() { ",
        "ins2PreCode":"public void completeDelegateThrows() { TestObserver<Integer> to = new TestObserver<Integer>(new Observer<Integer>() { ",
        "label":1
    },
    {
        "ins1CurCode":"public Hashtable<String, Class<?>> getTaskDefinitions() { synchronized (taskClassDefinitions) { synchronized (antTypeTable) { if (rebuildTaskClassDefinitions) { taskClassDefinitions.clear(); for (Map.Entry<String, AntTypeDefinition> e : antTypeTable.entrySet()) { final Class<?> clazz = e.getValue().getExposedClass(project); if (clazz == null) { continue; } if (Task.class.isAssignableFrom(clazz)) { taskClassDefinitions.put(e.getKey(), e.getValue().getTypeClass(project)); }",
        "ins1PreCode":"public Hashtable getTaskDefinitions() { synchronized (taskClassDefinitions) { synchronized (antTypeTable) { if (rebuildTaskClassDefinitions) { taskClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (Task.class.isAssignableFrom(clazz)) { taskClassDefinitions.put(name, antTypeTable.getTypeClass(name)); }",
        "ins2PreCode":"public Hashtable getDataTypeDefinitions() { synchronized (typeClassDefinitions) { synchronized (antTypeTable) { if (rebuildTypeClassDefinitions) { typeClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (!(Task.class.isAssignableFrom(clazz))) { typeClassDefinitions.put(name, antTypeTable.getTypeClass(name)); }",
        "label":0
    },
    {
        "ins1CurCode":"} } catch (BSFException be) { throw getBuildException(be); } finally {",
        "ins1PreCode":"} } catch (BSFException be) { throwBuildException(be); } finally {",
        "ins2PreCode":"public Object evaluateScript(String execName) throws BuildException { checkLanguage(); ClassLoader origLoader = replaceContextLoader(); try { BSFManager m = createManager(); declareBeans(m);  if (engine == null) { return m.eval(getLanguage(), execName, 0, 0, getScript()); } else { return engine.eval(execName, 0, 0, getScript()); } } catch (BSFException be) { throwBuildException(be);  return null; } finally {",
        "label":0
    },
    {
        "ins1CurCode":"public void createUndirected_expectedNodeCount() { Graph<Integer, String> undirectedGraph = GraphBuilder.undirected() .expectedNodeCount(NODE_COUNT) .build(); assertThat(undirectedGraph.addEdge(E12, N1, N2)).isTrue();",
        "ins1PreCode":"public void createUndirected_expectedNodeCount() { UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(config().expectedNodeCount(NODE_COUNT)); assertThat(undirectedGraph.addEdge(E12, N1, N2)).isTrue();",
        "ins2PreCode":"public void createDirected_expectedEdgeCount() { DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(config().expectedEdgeCount(EDGE_COUNT)); assertThat(directedGraph.addEdge(E12, N1, N2)).isTrue();",
        "label":0
    },
    {
        "ins1CurCode":"return (Observable<T>)wrap(sources[0]); } return RxJavaPlugins.onAssembly(new ObservableAmb<>(sources, null));",
        "ins1PreCode":"return (Observable<T>)wrap(sources[0]); } return RxJavaPlugins.onAssembly(new ObservableAmb<T>(sources, null));",
        "ins2PreCode":"return fromPublisher(sources[0]); } return RxJavaPlugins.onAssembly(new FlowableAmb<T>(sources, null));",
        "label":1
    },
    {
        "ins1CurCode":"final Settings settings = Settings.builder() .put(\"path.home\", createTempDir()) .put(\"reindex.ssl.supported_protocols\", \"TLSv1.2\") .build();",
        "ins1PreCode":"final Settings settings = Settings.builder() .put(\"path.home\", createTempDir()) .build(); final Environment environment = TestEnvironment.newEnvironment(settings);",
        "ins2PreCode":".put(\"path.home\", createTempDir()) .put(\"reindex.ssl.verification_mode\", \"NONE\") .build(); final Environment environment = TestEnvironment.newEnvironment(settings);",
        "label":1
    },
    {
        "ins1CurCode":"public void runWithSystemPropertiesWhenContextFailsShouldRemoveProperties() { String key = \"test.\" + UUID.randomUUID();",
        "ins1PreCode":"public void runWithSystemPropertiesWhenContextFailsShouldRemoveProperties() throws Exception { String key = \"test.\" + UUID.randomUUID();",
        "ins2PreCode":"public void runWithSystemPropertiesShouldSetAndRemoveProperties() { String key = \"test.\" + UUID.randomUUID(); assertThat(System.getProperties().containsKey(key)).isFalse(); get().withSystemProperties(key + \"=value\") .run((context) -> assertThat(System.getProperties()).containsEntry(key, \"value\")); assertThat(System.getProperties().containsKey(key)).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"propertySource.setProperty(\"spring.config.import\", \"spring,boot\"); ConfigData configData = new ConfigData(Collections.singleton(propertySource)); ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0); assertThat(contributor.getImports()).containsExactly(\"spring\", \"boot\");",
        "ins1PreCode":"propertySource.setProperty(\"spring.config.import\", \"spring,boot\"); ConfigData configData = new ConfigData(Collections.singleton(propertySource)); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); assertThat(contributor.getImports()).containsExactly(\"spring\", \"boot\");",
        "ins2PreCode":"propertySource.setProperty(\"spring.config.import\", \"springboot\"); ConfigData configData = new ConfigData(Collections.singleton(propertySource)); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); assertThat(contributor.hasUnprocessedImports(ImportPhase.BEFORE_PROFILE_ACTIVATION)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { NumberAxis a1 = new NumberAxis(\"Test\"); NumberAxis a2 = CloneUtils.clone(a1); assertTrue(a1 != a2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { NumberAxis a1 = new NumberAxis(\"Test\"); NumberAxis a2 = (NumberAxis) a1.clone(); assertTrue(a1 != a2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { SubCategoryAxis a1 = new SubCategoryAxis(\"Test\"); a1.addSubCategory(\"SubCategoryA\"); SubCategoryAxis a2 = CloneUtils.clone(a1); assertTrue(a1 != a2); assertTrue(a1.getClass() == a2.getClass()); assertTrue(a1.equals(a2));",
        "label":0
    },
    {
        "ins1CurCode":"System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); Assert.assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins1PreCode":"System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins2PreCode":"System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposable.empty(); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"Collections.singletonList(\"application/json\")); WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(context, parameterMapper, mediaTypes, Collections.singletonList(endpointPathMapper), Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)),",
        "ins1PreCode":"Collections.singletonList(\"application/json\")); WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(context, parameterMapper, mediaTypes, endpointPathMapper, Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)),",
        "ins2PreCode":"Collections.singletonList(\"application/json\")); CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( context, parameterMapper, mediaTypes, endpointPathMapper, Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)),",
        "label":1
    },
    {
        "ins1CurCode":"Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(new ApplicationListener( TesterEchoServer.Config.class.getName(), false)); ",
        "ins1PreCode":"Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); ",
        "ins2PreCode":"Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); ",
        "label":1
    },
    {
        "ins1CurCode":"File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(testFile.setLastModified(testFile.lastModified() - FileUtils.getFileUtils().getFileTimestampGranularity() * 3)); long ts1 = testFile.lastModified();",
        "ins1PreCode":"File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 3))); long ts1 = testFile.lastModified();",
        "ins2PreCode":"File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 3))); long ts1 = testFile.lastModified();",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull R> Observable<R> combineLatest( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2,",
        "ins1PreCode":"public static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2,",
        "ins2PreCode":"public static <T1, T2, T3, T4, T5, T6, R> Observable<R> zip( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3,",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,author=\\\"Ed von Test\\\"}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":".parse(new StringReader(\"@article{test,author=\\\"Ed von Test\\\"}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":".parse(new StringReader(\"@article{test,year = 2005}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"2005\"), e.getField(\"year\"));",
        "label":1
    },
    {
        "ins1CurCode":".getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange() .block(Duration.ofSeconds(30)); });",
        "ins1PreCode":".getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange() .block(); });",
        "ins2PreCode":".getField(interceptorSecurityService, \"webClient\"); assertThatExceptionOfType(RuntimeException.class) .isThrownBy( webClient.get().uri(\"https://self-signed.badssl.com/\") .exchange()::block) .withCauseInstanceOf(SSLException.class);",
        "label":0
    },
    {
        "ins1CurCode":"} else if (value instanceof Long) { return (long)value; } else if (value instanceof Float) { return (float)value; } else { throw new ClassCastException( \"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to float\"); }",
        "ins1PreCode":"} else if (value instanceof Long) { return (long)value; } else { return (float)value; }",
        "ins2PreCode":"} else if (value instanceof Float) { return (float)value; } else { return (double)value; }",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectCreateActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(appender).isInstanceOf(RollingFileAppender.class); RollingPolicy rollingPolicy = ((RollingFileAppender<?>) appender).getRollingPolicy(); String fileNamePattern = ((SizeAndTimeBasedRollingPolicy<?>) rollingPolicy).getFileNamePattern(); assertThat(fileNamePattern).endsWith(\"spring.log.%d{yyyy-MM-dd}.%i.gz\");",
        "ins1PreCode":"assertThat(appender).isInstanceOf(RollingFileAppender.class); RollingPolicy rollingPolicy = ((RollingFileAppender<?>) appender).getRollingPolicy(); String fileNamePattern = ((SizeAndTimeBasedRollingPolicy) rollingPolicy).getFileNamePattern(); assertThat(fileNamePattern).endsWith(\"spring.log.%d{yyyy-MM-dd}.%i.gz\");",
        "ins2PreCode":"assertThat(appender).isInstanceOf(RollingFileAppender.class); RollingPolicy rollingPolicy = ((RollingFileAppender<?>) appender).getRollingPolicy(); String fileNamePattern = ((SizeAndTimeBasedRollingPolicy) rollingPolicy).getFileNamePattern(); assertThat(fileNamePattern).endsWith(\"my.log.%d{yyyyMMdd}.%i.gz\");",
        "label":1
    },
    {
        "ins1CurCode":" while (!serverChannel.outboundMessages().isEmpty()) { clientChannel.writeOneInbound(serverChannel.readOutbound()); }",
        "ins1PreCode":" while (!serverChannel.outboundMessages().isEmpty()) { clientChannel.writeInbound(serverChannel.readOutbound()); }",
        "ins2PreCode":" while (!clientChannel.outboundMessages().isEmpty()) { serverChannel.writeInbound(clientChannel.readOutbound()); }",
        "label":1
    },
    {
        "ins1CurCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset<String> d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultBoxAndWhiskerXYDataset<String> d1 = new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset<String> d2 = CloneUtils.clone(d1); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   d1.add(new Date(2L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); assertFalse(d1.equals(d2));",
        "label":0
    },
    {
        "ins1CurCode":"verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 0); verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 1); verifyOpenBlockLatencyMetrics(2, 2);",
        "ins1PreCode":"verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 0); verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 1); verifyOpenBlockLatencyMetrics();",
        "ins2PreCode":"verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 0); verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 1); verifyOpenBlockLatencyMetrics();",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"void testEnumWithOgnlDirectorWithInterface() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeWithInterface(() -> Type.DIRECTOR); Assertions.assertEquals(1, persons.size(), \"Persons must contain 1 persons\");",
        "ins1PreCode":"public void testEnumWithOgnlDirectorWithInterface() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assertions.assertEquals(1, persons.size(), \"Persons must contain 1 persons\");",
        "ins2PreCode":"public void testEnumWithOgnlDirectorNameAttributeWithInterface() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeNameAttributeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assertions.assertEquals(1, persons.size(), \"Persons must contain 1 persons\");",
        "label":1
    },
    {
        "ins1CurCode":"void shouldApplyTypeHandlerWithJdbcTypeSpecified() { addMapper();",
        "ins1PreCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() { addMapper();",
        "ins2PreCode":"public void shouldApplyTypeHandlerUsingConstructor() { addMapper();",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "label":0
    },
    {
        "ins1CurCode":"  acceptor.getSessionConfig().setSslContext(BogusSslContextFactory.getInstance(true)); ",
        "ins1PreCode":"  acceptor.setSslContext(BogusSslContextFactory.getInstance(true)); ",
        "ins2PreCode":"public static void main(String[] args) throws Exception {  OneThreadSelectorStrategy strategy = new OneThreadSelectorStrategy(new SelectorFactory( NioSelectorProcessor.class)); NioTcpServer acceptor = new NioTcpServer(strategy); acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"), new DummyHttpSever());  acceptor.getSessionConfig().setTcpNoDelay(true);  acceptor.bind(new InetSocketAddress(8080));   Thread.sleep(20000); acceptor.unbindAll(); ",
        "label":0
    },
    {
        "ins1CurCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericView sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource();",
        "ins1PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource();",
        "ins2PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource();",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); observer.onError(new TestException(\"First\"));",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\"));",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\"));",
        "label":1
    },
    {
        "ins1CurCode":"public Map<Object, ExasolLock> getLocks(DBCSession session,Map<String, Object> options) throws DBException { try { Map<Object, ExasolLock> locks = new HashMap<>(10); ",
        "ins1PreCode":"public Map<BigInteger, ExasolLock> getLocks(DBCSession session,Map<String, Object> options) throws DBException { try { Map<BigInteger, ExasolLock> locks = new HashMap<BigInteger,ExasolLock>(10); ",
        "ins2PreCode":"public Map<Integer,PostgreLock> getLocks(DBCSession session, Map<String, Object> options) throws DBException { try {  Map<Integer,PostgreLock> locks = new HashMap<Integer,PostgreLock>(10); ",
        "label":1
    },
    {
        "ins1CurCode":"ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncDeleteByQueryAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, scriptService, listener).start();",
        "ins1PreCode":"ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncDeleteByQueryAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, scriptService, state, listener).start();",
        "ins2PreCode":"protected void doExecute(Task task, UpdateByQueryRequest request, ActionListener<BulkByScrollResponse> listener) { BulkByScrollTask bulkByScrollTask = (BulkByScrollTask) task; BulkByScrollParallelizationHelper.startSlicedAction(request, bulkByScrollTask, UpdateByQueryAction.INSTANCE, listener, client, clusterService.localNode(), () -> { ClusterState state = clusterService.state(); ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncIndexBySearchAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, state, listener).start(); } );",
        "label":0
    },
    {
        "ins1CurCode":"CharsetDecoder decoder = ctx.getDecoder(); CharBuffer buffer = decoder.decode(buf); decoded = buffer.toString(); } else {",
        "ins1PreCode":"CharsetDecoder decoder = ctx.getDecoder(); CharBuffer buffer = decoder.decode(buf); decoded = new String(buffer.array()); } else {",
        "ins2PreCode":"private String decodeNormal(Context ctx, ByteBuffer in) { String decoded = null; int matchCount = ctx.getMatchCount();   int oldPos = in.position(); int oldLimit = in.limit();  while (in.hasRemaining() && decoded == null) { byte b = in.get();  if (delimBuf.get(matchCount) == b) { matchCount++;  if (matchCount == delimBuf.limit()) {  int pos = in.position(); in.limit(pos); in.position(oldPos);  ctx.append(in);  in.limit(oldLimit); in.position(pos);  try { if (ctx.getOverflowLength() == 0) { ByteBuffer buf = ctx.getBuffer(); buf.flip(); buf.limit(buf.limit() - matchCount);  CharsetDecoder decoder = ctx.getDecoder(); CharBuffer buffer = decoder.decode(buf); decoded = new String(buffer.array()); } else { int overflowLength = ctx.getOverflowLength(); throw new IllegalStateException(\"Line is too long: \" + overflowLength); } } catch (CharacterCodingException cce) { throw new ProtocolDecoderException(cce); } finally { ctx.reset(); }  oldPos = pos; matchCount = 0; } } else {  in.position(Math.max(0, in.position() - matchCount)); matchCount = 0; } }   in.position(oldPos); ctx.append(in);  ctx.setMatchCount(matchCount); return decoded;",
        "label":0
    },
    {
        "ins1CurCode":"final AtomicInteger subsCount = new AtomicInteger(0);  final TestSubscriber<String> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"final AtomicInteger subsCount = new AtomicInteger(0);  final TestSubscriber<String> ts = new TestSubscriber<String>(); ",
        "ins2PreCode":"final AtomicInteger subsCount = new AtomicInteger(0);  final TestSubscriber<String> ts = new TestSubscriber<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);   assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/pdfInSubdirectory.pdf\")), result);",
        "ins1PreCode":"List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);   assertEquals(Collections.singletonList(Paths.get(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/pdfInSubdirectory.pdf\")), result);",
        "ins2PreCode":"List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[bibtexkey].*\\\\\\\\.[extension]\", ',');",
        "label":0
    },
    {
        "ins1CurCode":"SomeChainingException thrown = new SomeChainingException(cause);  assertThat(thrown).hasCauseThat().isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);  try { Throwables.getCauseAs(thrown, IllegalStateException.class); fail(\"Should have thrown CCE\"); } catch (ClassCastException expected) { assertThat(expected).hasCauseThat().isSameAs(thrown); }",
        "ins1PreCode":"SomeChainingException thrown = new SomeChainingException(cause);  assertThat(thrown.getCause()).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);  try { Throwables.getCauseAs(thrown, IllegalStateException.class); fail(\"Should have thrown CCE\"); } catch (ClassCastException expected) { assertThat(expected.getCause()).isSameAs(thrown); }",
        "ins2PreCode":"SomeChainingException thrown = new SomeChainingException(cause);  assertThat(thrown.getCause()).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);  try { Throwables.getCauseAs(thrown, IllegalStateException.class); fail(\"Should have thrown CCE\"); } catch (ClassCastException expected) { assertThat(expected.getCause()).isSameAs(thrown); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testDateConstructor1() { TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Locale locale = Locale.getDefault(); Second s1 = new Second(new Date(1016729758999L), zone, locale); Second s2 = new Second(new Date(1016729759000L), zone, locale);  assertEquals(58, s1.getSecond()); assertEquals(1016729758999L, s1.getLastMillisecond(cal));  assertEquals(59, s2.getSecond()); assertEquals(1016729759000L, s2.getFirstMillisecond(cal));",
        "ins1PreCode":" assertEquals(58, s1.getSecond()); assertEquals(1016729758999L, s1.getLastMillisecond(zone));  assertEquals(59, s2.getSecond()); assertEquals(1016729759000L, s2.getFirstMillisecond(zone));",
        "ins2PreCode":" assertEquals(58, s1.getSecond()); assertEquals(1016751358999L, s1.getLastMillisecond(zone));  assertEquals(59, s2.getSecond()); assertEquals(1016751359000L, s2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1CurCode":"public void completeBeginnigOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);",
        "ins1PreCode":"public void completeBeginnigOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testValue\"); autoCompleter.indexEntry(entry);",
        "ins2PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testValue\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); set.add(new Medra()); return set;",
        "ins1PreCode":"set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); return set;",
        "ins2PreCode":"public static SortedSet<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { SortedSet<SearchBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); set.add(new ArXiv(importFormatPreferences)); set.add(new INSPIREFetcher(importFormatPreferences)); set.add(new GvkFetcher()); set.add(new MedlineFetcher()); set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences));   set.add(new GoogleScholar(importFormatPreferences)); set.add(new DBLPFetcher(importFormatPreferences)); set.add(new SpringerFetcher()); set.add(new CrossRef()); set.add(new CiteSeer()); set.add(new DOAJFetcher(importFormatPreferences)); set.add(new IEEE(importFormatPreferences)); set.add(new CompositeSearchBasedFetcher(set, 30)); set.add(new CollectionOfComputerScienceBibliographiesFetcher(importFormatPreferences)); return set;",
        "label":0
    },
    {
        "ins1CurCode":"private void setUpLogin() throws Exception {   basicContext = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); basicContext.setSessionTimeout(SHORT_SESSION_TIMEOUT_MINS);   Tomcat.addServlet(basicContext, \"TesterServlet3\", new TesterServletEncodeUrl()); basicContext.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); basicContext.addConstraint(sc);   Tomcat.addServlet(basicContext, \"TesterServlet4\", new TesterServletEncodeUrl()); basicContext.addServletMapping(URI_PUBLIC, \"TesterServlet4\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); basicContext.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); basicContext.setLoginConfig(lc); AuthenticatorBase basicAuthenticator = new BasicAuthenticator(); basicContext.getPipeline().addValve(basicAuthenticator);",
        "ins1PreCode":"private void setUpLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet3\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet3\");  SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); ctxt.addConstraint(sc);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new BasicAuthenticator());",
        "ins2PreCode":"private void setUpLogin() throws Exception {   basicContext = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); basicContext.setSessionTimeout(SHORT_SESSION_TIMEOUT_MINS);   Tomcat.addServlet(basicContext, \"TesterServlet3\", new TesterServlet()); basicContext.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); basicContext.addConstraint(sc);   Tomcat.addServlet(basicContext, \"TesterServlet4\", new TesterServlet()); basicContext.addServletMapping(URI_PUBLIC, \"TesterServlet4\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); basicContext.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); basicContext.setLoginConfig(lc); AuthenticatorBase basicAuthenticator = new BasicAuthenticator(); basicContext.getPipeline().addValve(basicAuthenticator);",
        "label":0
    },
    {
        "ins1CurCode":"try { boolean onlyConnections = CommonUtils.getOption(options, OPTION_SHOW_ONLY_CONNECTIONS); boolean supportsDatabaseInfo = ((SQLServerDataSource) session.getDataSource()).isServerVersionAtLeast(SQLServerConstants.SQL_SERVER_2012_VERSION_MAJOR, 0);  StringBuilder sql = new StringBuilder(); sql.append(\"SELECT s.*,\"); if (supportsDatabaseInfo) { sql.append(\"db.name as database_name,\"); } else { sql.append(\"NULL as database_name,\"); } sql.append(\"c.connection_id,(select text from sys.dm_exec_sql_text(c.most_recent_sql_handle)) as sql_text\\n\") .append(\"FROM sys.dm_exec_sessions s\\n\"); if (onlyConnections) { sql.append(\"LEFT OUTER \"); } sql.append(\"JOIN sys.dm_exec_connections c ON c.session_id=s.session_id\\n\"); if (supportsDatabaseInfo) { sql.append(\"LEFT OUTER JOIN sys.sysdatabases db on db.dbid=s.database_id\\n\"); } sql.append(\"ORDER BY s.session_id DESC\");  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins1PreCode":"boolean onlyConnections = CommonUtils.getOption(options, OPTION_SHOW_ONLY_CONNECTIONS); try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"SELECT s.*,db.name as database_name,c.connection_id,(select text from sys.dm_exec_sql_text(c.most_recent_sql_handle)) as sql_text\\n\" + \"FROM sys.dm_exec_sessions s\\n\" + (onlyConnections ? \"\" : \"LEFT OUTER \") + \"JOIN sys.dm_exec_connections c ON c.session_id=s.session_id\\n\" + \"LEFT OUTER JOIN sys.sysdatabases db on db.dbid=s.database_id\\n\" + \"ORDER BY s.session_id DESC\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins2PreCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM V$SESSION s \\n\" + \"LEFT JOIN v$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN v$sess_io io ON ( s.sid = io.sid)\\n\" +   \"WHERE 1=1\"); if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) { sql.append(\" AND s.TYPE = 'USER'\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_INACTIVE)) { sql.append(\" AND s.STATUS <> 'INACTIVE'\"); } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<OracleServerSession> sessions = new ArrayList<>(); while (dbResult.next()) { sessions.add(new OracleServerSession(dbResult)); } return sessions; } } } catch (SQLException e) { throw new DBException(e, session.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":" JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = stream.mapToPair(in -> new Tuple2<>(in, in.length()));  JavaPairDStream<String, Integer> filtered = pairStream.filter(in -> in._1().contains(\"a\")); JavaTestUtils.attachTestOutputStream(filtered);",
        "ins1PreCode":" JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = stream.mapToPair( new PairFunction<String, String, Integer>() { @Override public Tuple2<String, Integer> call(String in) { return new Tuple2<>(in, in.length()); } });  JavaPairDStream<String, Integer> filtered = pairStream.filter( new Function<Tuple2<String, Integer>, Boolean>() { @Override public Boolean call(Tuple2<String, Integer> in) { return in._1().contains(\"a\"); } }); JavaTestUtils.attachTestOutputStream(filtered);",
        "ins2PreCode":"public void testPairFilter() { List<List<String>> inputData = Arrays.asList( Arrays.asList(\"giants\", \"dodgers\"), Arrays.asList(\"yankees\", \"red sox\"));  List<List<Tuple2<String, Integer>>> expected = Arrays.asList( Arrays.asList(new Tuple2<>(\"giants\", 6)), Arrays.asList(new Tuple2<>(\"yankees\", 7)));  JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = stream.mapToPair(x -> new Tuple2<>(x, x.length())); JavaPairDStream<String, Integer> filtered = pairStream.filter(x -> x._1().contains(\"a\")); JavaTestUtils.attachTestOutputStream(filtered); List<List<Tuple2<String, Integer>>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "label":0
    },
    {
        "ins1CurCode":"public List<View> sort(@NonNull List<? extends View> views) { List<View> result = new ArrayList<>(views);",
        "ins1PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views);",
        "ins2PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views);",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article\\n{\\ntest,author={Ed von Test}}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":".parse(new StringReader(\"@article\\n{\\ntest,author={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void createUndirected_expectedNodeCount() { MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected() .expectedNodeCount(NODE_COUNT)",
        "ins1PreCode":"public void createUndirected_expectedNodeCount() { Graph<Integer, String> undirectedGraph = GraphBuilder.undirected() .expectedNodeCount(NODE_COUNT)",
        "ins2PreCode":"public void createDirected_expectedEdgeCount() { Graph<Integer, String> directedGraph = GraphBuilder.directed() .expectedEdgeCount(EDGE_COUNT)",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerMaybeObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void tryTerminateConsumerMaybeObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":" try { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<>(); ",
        "ins1PreCode":" try { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>(); ",
        "ins2PreCode":" try { TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.shouldSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "ins1PreCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "ins2PreCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetDomainAxisForDataset() { XYDataset dataset = new XYSeriesCollection<String>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins1PreCode":"public void testGetDomainAxisForDataset() { XYDataset dataset = new XYSeriesCollection(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins2PreCode":"public void testGetRangeAxisForDataset() { XYDataset dataset = new XYSeriesCollection(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeNumberSingleShouldFailIfBuildNumberIsHyphen() { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"-\");",
        "ins1PreCode":"@Test public void dummyRangeNumberSingleShouldFailIfBuildNumberIsHyphen() { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"-\");",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeIsInvalid() { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1-3-\");",
        "label":1
    },
    {
        "ins1CurCode":"public static SortedList<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new INSPIREFetcher(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new ACMPortalFetcher(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new SpringerFetcher()); list.add(new CrossRef()); list.add(new CiteSeer()); list.add(new DOAJFetcher(importFormatPreferences)); list.add(new IEEE(importFormatPreferences));  ObservableList<SearchBasedFetcher> observableList = FXCollections.observableList(list); return new SortedList<>(observableList, Comparator.comparing(WebFetcher::getName));",
        "ins1PreCode":"public static List<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new INSPIREFetcher(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new ACMPortalFetcher(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new SpringerFetcher()); list.add(new CrossRef()); list.add(new CiteSeer()); list.add(new DOAJFetcher(importFormatPreferences)); list.add(new IEEE(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"public static List<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<IdBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new IsbnFetcher(importFormatPreferences)); list.add(new DiVA(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new MedlineFetcher()); list.add(new TitleFetcher(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences)); list.add(new RfcFetcher(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":1
    },
    {
        "ins1CurCode":"items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); }",
        "ins1PreCode":"items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(Level.WARNING,\"Failed to resolve class\",e); }",
        "ins2PreCode":"collection.add(item); } catch (CannotResolveClassException e) { System.err.println(\"failed to locate class: \"+e); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { HighLowRenderer r1 = new HighLowRenderer(); r1.setCloseTickPaint(Color.GREEN); HighLowRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); TestUtils.checkIndependence(r1, r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowRenderer r1 = new HighLowRenderer(); r1.setCloseTickPaint(Color.green); HighLowRenderer r2 = CloneUtils.clone(r1);",
        "ins2PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"System.out.println(\"concatMapRangeAsyncLoop > \" + i); } TestObserverEx<Integer> to = new TestObserverEx<>(); Observable.range(0, 1000)",
        "ins1PreCode":"System.out.println(\"concatMapRangeAsyncLoop > \" + i); } TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.range(0, 1000)",
        "ins2PreCode":"System.out.println(\"concatMapRangeAsyncLoop > \" + i); } TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { SymbolicXYItemLabelGenerator g1 = new SymbolicXYItemLabelGenerator(); SymbolicXYItemLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { SymbolicXYItemLabelGenerator g1 = new SymbolicXYItemLabelGenerator(); SymbolicXYItemLabelGenerator g2 = (SymbolicXYItemLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { GrayPaintScale g1 = new GrayPaintScale(); GrayPaintScale g2 = CloneUtils.clone(g1); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"public static <T> Observable<T> merge( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Observable<T> merge( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Observable<T> mergeDelayError( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":1
    },
    {
        "ins1CurCode":"public void preHandleSuccessfulWithFullAccess() { String accessToken = mockAccessToken();",
        "ins1PreCode":"public void preHandleSuccessfulWithFullAccess() throws Exception { String accessToken = mockAccessToken();",
        "ins2PreCode":"public void preHandleSuccessfulWithRestrictedAccess() throws Exception { String accessToken = mockAccessToken();",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribeActual(Subscriber<? super T> s) { SerializedSubscriber<T> z = new SerializedSubscriber<>(s);  FlowableProcessor<Throwable> processor = UnicastProcessor.<Throwable>create(8).toSerialized();  Publisher<?> when;  try { when = Objects.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, s); return; }  WhenReceiver<T, Throwable> receiver = new WhenReceiver<>(source);  RetryWhenSubscriber<T> subscriber = new RetryWhenSubscriber<>(z, processor, receiver); ",
        "ins1PreCode":"public void subscribeActual(Subscriber<? super T> s) { SerializedSubscriber<T> z = new SerializedSubscriber<T>(s);  FlowableProcessor<Throwable> processor = UnicastProcessor.<Throwable>create(8).toSerialized();  Publisher<?> when;  try { when = Objects.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, s); return; }  WhenReceiver<T, Throwable> receiver = new WhenReceiver<T, Throwable>(source);  RetryWhenSubscriber<T> subscriber = new RetryWhenSubscriber<T>(z, processor, receiver); ",
        "ins2PreCode":"public void subscribeActual(Subscriber<? super T> s) {  SerializedSubscriber<T> z = new SerializedSubscriber<T>(s);  FlowableProcessor<Object> processor = UnicastProcessor.<Object>create(8).toSerialized();  Publisher<?> when;  try { when = Objects.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, s); return; }  WhenReceiver<T, Object> receiver = new WhenReceiver<T, Object>(source);  RepeatWhenSubscriber<T> subscriber = new RepeatWhenSubscriber<T>(z, processor, receiver); ",
        "label":0
    },
    {
        "ins1CurCode":"if (producer != null) { try { pipe.setProducer((IDataTransferProducer<?>) producer.createNode()); } catch (DBException e) {",
        "ins1PreCode":"if (producer != null) { try { pipe.setProducer((IDataTransferProducer) producer.createNode()); } catch (DBException e) {",
        "ins2PreCode":"}  for (int i = 0; i < dataPipes.size(); i++) { DataTransferPipe pipe = dataPipes.get(i); if (!rewrite && pipe.getConsumer() != null) { continue; } if (consumer != null) { try { IDataTransferConsumer consumerNode = (IDataTransferConsumer) consumer.createNode(); pipe.setConsumer(consumerNode);",
        "label":0
    },
    {
        "ins1CurCode":"network.addNode(gen.nextInt(NODE_POOL_SIZE)); } ArrayList<Integer> nodeList = new ArrayList<>(network.nodes()); for (int i = 0; i < NUM_EDGES; ++i) {  assertThat( network.addEdge( getRandomElement(nodeList, gen), getRandomElement(nodeList, gen), new Object())) .isTrue(); } ArrayList<Object> edgeList = new ArrayList<>(network.edges()); ",
        "ins1PreCode":"network.addNode(gen.nextInt(NODE_POOL_SIZE)); } ArrayList<Integer> nodeList = new ArrayList<Integer>(network.nodes()); for (int i = 0; i < NUM_EDGES; ++i) {  assertThat( network.addEdge( getRandomElement(nodeList, gen), getRandomElement(nodeList, gen), new Object())) .isTrue(); } ArrayList<Object> edgeList = new ArrayList<Object>(network.edges()); ",
        "ins2PreCode":"network.addNode(gen.nextInt(NODE_POOL_SIZE)); } ArrayList<Integer> nodeList = new ArrayList<Integer>(network.nodes()); for (int i = 0; i < NUM_EDGES; ++i) {  assertThat( network.addEdge( getRandomElement(nodeList, gen), getRandomElement(nodeList, gen), new Object())) .isTrue(); } ArrayList<Object> edgeList = new ArrayList<Object>(network.edges()); ",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"1-4~#nov#\"), entry.getField(StandardField.DATE));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"1-4~#nov#\"), entry.getField(\"date\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\{ bracket\"), entry.getField(\"review\")); assertFalse(result.hasWarnings());",
        "label":1
    },
    {
        "ins1CurCode":" TreeMap<Integer,ArrayList<ByteEntry>> tempMap = new TreeMap<>(); for (Entry<ByteEntry,int[]> item : bcStats.entrySet()) { ByteEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]);  ArrayList<ByteEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<>(); tempMap.put(count, list);",
        "ins1PreCode":" TreeMap<Integer,ArrayList<ByteEntry>> tempMap = new TreeMap<Integer,ArrayList<ByteEntry>>(); for (Entry<ByteEntry,int[]> item : bcStats.entrySet()) { ByteEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]);  ArrayList<ByteEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<ByteEntry>(); tempMap.put(count, list);",
        "ins2PreCode":" TreeMap<Integer,ArrayList<CharEntry>> tempMap = new TreeMap<Integer,ArrayList<CharEntry>>(); for (Entry<CharEntry,int[]> item : ccStats.entrySet()) { CharEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]);  ArrayList<CharEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<CharEntry>(); tempMap.put(count, list);",
        "label":0
    },
    {
        "ins1CurCode":"public MBeanNotificationInfo[] getNotificationInfo() {  if (notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[] { new MBeanNotificationInfo( new String[] { \"j2ee.object.created\" }, Notification.class.getName(), \"web application is created\"), new MBeanNotificationInfo( new String[] { \"j2ee.state.starting\" }, Notification.class.getName(), \"change web application is starting\"), new MBeanNotificationInfo( new String[] { \"j2ee.state.running\" }, Notification.class.getName(), \"web application is running\"), new MBeanNotificationInfo( new String[] { \"j2ee.state.stopping\" }, Notification.class.getName(), \"web application start to stopped\"), new MBeanNotificationInfo( new String[] { \"j2ee.object.stopped\" }, Notification.class.getName(), \"web application is stopped\"), new MBeanNotificationInfo( new String[] { \"j2ee.object.deleted\" }, Notification.class.getName(), \"web application is deleted\"), new MBeanNotificationInfo( new String[] { \"j2ee.object.failed\" }, Notification.class.getName(), \"web application failed\") }; }",
        "ins1PreCode":"public MBeanNotificationInfo[] getNotificationInfo() {  if(notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[]{ new MBeanNotificationInfo(new String[] { \"j2ee.object.created\"}, Notification.class.getName(), \"web application is created\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.starting\"}, Notification.class.getName(), \"change web application is starting\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.running\"}, Notification.class.getName(), \"web application is running\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopping\"}, Notification.class.getName(), \"web application start to stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.stopped\"}, Notification.class.getName(), \"web application is stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.deleted\"}, Notification.class.getName(), \"web application is deleted\" ) }; ",
        "ins2PreCode":"public MBeanNotificationInfo[] getNotificationInfo() {  if(notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[]{ new MBeanNotificationInfo(new String[] { \"j2ee.object.created\"}, Notification.class.getName(), \"servlet is created\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.starting\"}, Notification.class.getName(), \"servlet is starting\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.running\"}, Notification.class.getName(), \"servlet is running\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopped\"}, Notification.class.getName(), \"servlet start to stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.stopped\"}, Notification.class.getName(), \"servlet is stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.deleted\"}, Notification.class.getName(), \"servlet is deleted\" ) };  }  return notificationInfo;",
        "label":0
    },
    {
        "ins1CurCode":" parser.readFrame(true); Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace()); output.clearTrace();",
        "ins1PreCode":" parser.readFrame(true); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace();",
        "ins2PreCode":"public void testExceedMaxActiveStreams01() throws Exception {  enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendWindowUpdate(0, (1 << 31) - 2);  sendWindowUpdate(3, (1 << 31) - 8193);   while (!output.getTrace().contains(\"3-EndOfStream\")) { parser.readFrame(true); } output.clearTrace();   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "label":0
    },
    {
        "ins1CurCode":"public void testIterationOrder() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); TestMap message = builder.build();",
        "ins1PreCode":"public void testIterationOrder() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();",
        "ins2PreCode":"public void testIterationOrder() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();",
        "label":1
    },
    {
        "ins1CurCode":"sql.append( \"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" \\r\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,rc.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM SYS.ALL_CONSTRAINTS c\\n\" + \"JOIN SYS.ALL_CONS_COLUMNS col ON c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"JOIN SYS.ALL_CONSTRAINTS rc ON rc.OWNER=c.r_OWNER AND rc.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME \\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\");",
        "ins1PreCode":"sql.append( \"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" \\r\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,ref.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM SYS.ALL_CONSTRAINTS c\\n\" + \"JOIN SYS.ALL_CONS_COLUMNS col ON c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"JOIN SYS.ALL_CONSTRAINTS ref ON ref.OWNER=c.r_OWNER AND ref.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME \\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\");",
        "ins2PreCode":"protected JDBCStatement prepareObjectsStatement(JDBCSession session, OracleSchema owner, OracleTableBase forTable) throws SQLException { StringBuilder sql = new StringBuilder(500); sql .append(\"SELECT \").append(OracleUtils.getSysCatalogHint(owner.getDataSource())).append(\"\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.SEARCH_CONDITION,\" + \"col.COLUMN_NAME,col.POSITION\\n\" + \"FROM SYS.ALL_CONSTRAINTS c\\n\" + \"JOIN SYS.ALL_CONS_COLUMNS col ON c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"WHERE c.CONSTRAINT_TYPE<>'R' AND c.OWNER=?\"); if (forTable != null) { sql.append(\" AND c.TABLE_NAME=?\"); } sql.append(\"\\nORDER BY c.CONSTRAINT_NAME,col.POSITION\");  JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); if (forTable != null) { dbStat.setString(2, forTable.getName()); } return dbStat;",
        "label":0
    },
    {
        "ins1CurCode":" if (container instanceof Context) { name.append(\",context=\"); Context context = (Context) container;  String contextName = ((Context)container).getName(); if (!contextName.startsWith(\"/\")) { contextName = \"/\" + contextName; } name.append(contextName); ",
        "ins1PreCode":" if (container instanceof Context) { name.append(\",path=\"); Context context = (Context) container;  String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; } name.append(path); ",
        "ins2PreCode":" if (container instanceof Context) { name.append(\",path=\"); Context context = (Context) container;  String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; } name.append(path); ",
        "label":0
    },
    {
        "ins1CurCode":"configuration.addMapper(PersonMapper.class); configuration.addMapper(PetMapper.class); c.close(); ",
        "ins1PreCode":"configuration.addMapper(PersonMapper.class); configuration.addMapper(PetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"configuration.addMapper(MultipleCrossIncludePersonMapper.class); configuration.addMapper(MultipleCrossIncludePetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"} } catch (BadLocationException b) { LOG.log(Level.SEVERE, \"A BadLocationException happened\\n\"",
        "ins1PreCode":"} } catch (BadLocationException b) { LOG.error( \"A BadLocationException happened\\n\"",
        "ins2PreCode":"} } catch (BadLocationException b) { LOG.error( \"A BadLocationException happened\\n\"",
        "label":1
    },
    {
        "ins1CurCode":"Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn); conn.close(); ",
        "ins1PreCode":"Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn);  return sqlSessionFactory;",
        "ins2PreCode":"sqlSessionFactory = new SqlSessionFactoryBuilder().build(batisConfigReader); } catch(Exception anException) { throw new RuntimeException(\"Mapper configuration failed, expected this to work: \" + anException.getMessage(), anException); }  SqlSession session = sqlSessionFactory.openSession();  Connection conn = session.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); Reader createScriptReader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/inline_association_with_dot/create.sql\"); runner.runScript(createScriptReader);  sqlSession = sqlSessionFactory.openSession();",
        "label":0
    },
    {
        "ins1CurCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber);",
        "ins1PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber);",
        "ins2PreCode":"public void assertNotMatchValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, SecurityFilterChain.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins2PreCode":"void matchWithIncludeFilter() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithIncludeFilter.class); assertThat(excludes(filter, Controller1.class)).isFalse(); assertThat(excludes(filter, Controller2.class)).isFalse(); assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"public void compose() { TestObserverEx<String> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void compose() { TestObserverEx<String> to = new TestObserverEx<String>(); ",
        "ins2PreCode":"public void compose() { TestSubscriberEx<String> ts = new TestSubscriberEx<String>(); Flowable.just(1, 2, 3).compose(new FlowableTransformer<Integer, String>() {",
        "label":1
    },
    {
        "ins1CurCode":"public void testNoMatchesFromDatabaseWithArticleTypeEntry() { BibEntry entry = new BibEntry(StandardEntryType.Article); entry.setField(StandardField.AUTHOR, \"harrer\"); database.insertEntry(entry);",
        "ins1PreCode":"public void testNoMatchesFromDatabaseWithArticleTypeEntry() { BibEntry entry = new BibEntry(); entry.setType(\"article\"); entry.setField(\"author\", \"harrer\"); database.insertEntry(entry);",
        "ins2PreCode":"public void testCorrectMatchFromDatabaseWithArticleTypeEntry() { BibEntry entry = new BibEntry(); entry.setType(\"article\"); entry.setField(\"author\", \"harrer\"); database.insertEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"}  Object stateMachine = Model.getFacade().getStateMachine(dm); if (stateMachine == null) { return NO_PROBLEM; }  if (stateMachine != null && Model.getFacade().getTop(stateMachine) == dm) {   return NO_PROBLEM; }  Collection outgoing = Model.getFacade().getOutgoings(dm); if (outgoing == null || outgoing.size() > 0) { return NO_PROBLEM; }  if (!Model.getFacade().isACompositeState(dm)) { return PROBLEM_FOUND; }     Collection transitions = Model.getFacade().getTransitions(stateMachine); for (Object t : transitions) {",
        "ins1PreCode":"}  Object sm = Model.getFacade().getStateMachine(dm); if (sm != null && Model.getFacade().getTop(sm) == dm) {   return NO_PROBLEM; }  Collection outgoing = Model.getFacade().getOutgoings(dm); if (outgoing == null || outgoing.size() > 0) { return NO_PROBLEM; }  if (!Model.getFacade().isACompositeState(dm)) { return PROBLEM_FOUND; }     Collection transitions = Model.getFacade().getTransitions(sm); for (Object t : transitions) {",
        "ins2PreCode":"public boolean predicate2(Object dm, Designer dsgr) { if (!(Model.getFacade().isAStateVertex(dm))) { return NO_PROBLEM; }  if (Model.getFacade().isAPseudostate(dm)) { Object k = Model.getFacade().getKind(dm); if (k.equals(Model.getPseudostateKind().getChoice())) { return NO_PROBLEM; } if (k.equals(Model.getPseudostateKind().getJunction())) { return NO_PROBLEM; } if (k.equals(Model.getPseudostateKind().getInitial())) { return NO_PROBLEM; } } if (!Model.getFacade().isAState(dm)) { return NO_PROBLEM; }  Object sm = Model.getStateMachinesHelper().getStateMachine(dm); if (sm != null && Model.getFacade().getTop(sm) == dm) {   return NO_PROBLEM; }  Collection incoming = Model.getFacade().getIncomings(dm); if (incoming.size() > 0) { return NO_PROBLEM; }  if (!Model.getFacade().isACompositeState(dm)) { return PROBLEM_FOUND; }     Collection transitions = Model.getFacade().getTransitions(sm); for (Object t : transitions) { Object sourceState = Model.getFacade().getSource(t); Object targetState = Model.getFacade().getTarget(t); if (!isSomeSubvertexOf(sourceState, dm) && isSomeSubvertexOf(targetState, dm)) { return NO_PROBLEM; } }  return PROBLEM_FOUND;",
        "label":0
    },
    {
        "ins1CurCode":"void bindToArrayWhenNonSequentialShouldThrowException() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToArrayWhenNonSequentialShouldThrowException() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToCollectionWhenNonSequentialShouldThrowException() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StatisticalBarRenderer r1 = new StatisticalBarRenderer(); StatisticalBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StatisticalBarRenderer r1 = new StatisticalBarRenderer(); StatisticalBarRenderer r2 = (StatisticalBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowRenderer r1 = new HighLowRenderer(); r1.setCloseTickPaint(Color.green); HighLowRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"public void testTimeZone() { Tstamp.CustomFormat format = tstamp.createFormat();",
        "ins1PreCode":"public void testTimeZone() throws Exception { Tstamp.CustomFormat format = tstamp.createFormat();",
        "ins2PreCode":"public void testWriteOrder() throws Exception { Tstamp.CustomFormat format = tstamp.createFormat();",
        "label":1
    },
    {
        "ins1CurCode":"String pluginShortName = \"require-system-during-load\"; dynamicLoad(pluginShortName + \".hpi\"); try (ACLContext context = ACL.as2(User.getById(\"underprivileged\", true).impersonate2())) { r.jenkins.pluginManager.start(Collections.singletonList(r.jenkins.pluginManager.getPlugin(pluginShortName)));",
        "ins1PreCode":"String pluginShortName = \"require-system-during-load\"; dynamicLoad(pluginShortName + \".hpi\"); try (ACLContext context = ACL.as(User.getById(\"underprivileged\", true).impersonate())) { r.jenkins.pluginManager.start(Collections.singletonList(r.jenkins.pluginManager.getPlugin(pluginShortName)));",
        "ins2PreCode":"String pluginShortName = \"require-system-in-initializer\"; dynamicLoad(pluginShortName + \".jpi\"); try (ACLContext context = ACL.as(User.getById(\"underprivileged\", true).impersonate())) { r.jenkins.pluginManager.start(Collections.singletonList(r.jenkins.pluginManager.getPlugin(pluginShortName)));",
        "label":1
    },
    {
        "ins1CurCode":" default : LOG.log(Level.SEVERE, \"Invalid event:\" + event.getEventType()); break;",
        "ins1PreCode":" default : LOG.error(\"Invalid event:\" + event.getEventType()); break;",
        "ins2PreCode":" default: LOG.error(\"Invalid event:\" + event.getEventType()); break;",
        "label":1
    },
    {
        "ins1CurCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);",
        "ins1PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); ",
        "ins2PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testClientSucceedsWithVerificationDisabled() throws IOException { assumeFalse(\"Cannot disable verification in FIPS JVM\", inFipsJvm()); final List<Thread> threads = new ArrayList<>();",
        "ins1PreCode":"public void testClientSucceedsWithVerificationDisabled() throws IOException { assertFalse(\"Cannot disable verification in FIPS JVM\", inFipsJvm()); final List<Thread> threads = new ArrayList<>();",
        "ins2PreCode":"public void testClientFailsWithUntrustedCertificate() throws IOException { final List<Thread> threads = new ArrayList<>(); final Settings settings = Settings.builder() .put(\"path.home\", createTempDir()) .build(); final Environment environment = TestEnvironment.newEnvironment(settings); final ReindexSslConfig ssl = new ReindexSslConfig(settings, environment, mock(ResourceWatcherService.class)); try (RestClient client = TransportReindexAction.buildRestClient(getRemoteInfo(), ssl, 1L, threads)) { expectThrows(SSLHandshakeException.class, () -> client.performRequest(new Request(\"GET\", \"/\"))); }",
        "label":0
    },
    {
        "ins1CurCode":"public void successors_selfLoop() { assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void predecessors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"public ValueAxis getDomainAxisForDataset(int index) { Args.requireNonNegative(index, \"index\"); ValueAxis valueAxis;",
        "ins1PreCode":"public ValueAxis getDomainAxisForDataset(int index) { ParamChecks.requireNonNegative(index, \"index\"); ValueAxis valueAxis;",
        "ins2PreCode":"public ValueAxis getRangeAxisForDataset(int index) { ParamChecks.requireNonNegative(index, \"index\"); ValueAxis valueAxis;",
        "label":1
    },
    {
        "ins1CurCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); List<Car> cars = mapper.getCars(); Assertions.assertEquals(4, cars.size()); Assertions.assertEquals(\"VW\", cars.get(0).getType()); Assertions.assertNotNull(cars.get(0).getEngine()); Assertions.assertNull(cars.get(0).getBrakes()); Assertions.assertEquals(\"Opel\", cars.get(1).getType()); Assertions.assertNull(cars.get(1).getEngine()); Assertions.assertNotNull(cars.get(1).getBrakes()); }",
        "ins1PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); List<Car> cars = mapper.getCars(); Assert.assertEquals(4, cars.size()); Assert.assertEquals(\"VW\", cars.get(0).getType()); Assert.assertNotNull(cars.get(0).getEngine()); Assert.assertNull(cars.get(0).getBrakes()); Assert.assertEquals(\"Opel\", cars.get(1).getType()); Assert.assertNull(cars.get(1).getEngine()); Assert.assertNotNull(cars.get(1).getBrakes()); }",
        "ins2PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); List<Car> cars = mapper.getCarsAndDetectAssociationType(); Assert.assertEquals(4, cars.size()); Assert.assertEquals(\"VW\", cars.get(0).getType()); Assert.assertNotNull(cars.get(0).getEngine()); Assert.assertNull(cars.get(0).getBrakes()); Assert.assertEquals(\"Opel\", cars.get(1).getType()); Assert.assertNull(cars.get(1).getEngine()); Assert.assertNotNull(cars.get(1).getBrakes()); }",
        "label":1
    },
    {
        "ins1CurCode":"public final <@NonNull T1, @NonNull T2, @NonNull R> Observable<R> withLatestFrom( @NonNull ObservableSource<T1> source1, @NonNull ObservableSource<T2> source2,",
        "ins1PreCode":"public final <T1, T2, R> Observable<R> withLatestFrom( @NonNull ObservableSource<T1> source1, @NonNull ObservableSource<T2> source2,",
        "ins2PreCode":"public final <T1, T2, @NonNull R> Flowable<R> withLatestFrom(@NonNull Publisher<T1> source1, @NonNull Publisher<T2> source2, @NonNull Function3<? super T, ? super T1, ? super T2, R> combiner) {",
        "label":0
    },
    {
        "ins1CurCode":" assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void getLoggingConfiguration() { this.loggingSystem.beforeInitialize();",
        "ins1PreCode":"public void getLoggingConfiguration() throws Exception { this.loggingSystem.beforeInitialize();",
        "ins2PreCode":"public void getLoggingConfiguration() throws Exception { this.loggingSystem.beforeInitialize();",
        "label":1
    },
    {
        "ins1CurCode":"public void testNullGuardAdd() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, MethodHandles.publicLookup(),",
        "ins1PreCode":"public void testNullGuardAdd() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition, MethodHandles.publicLookup(),",
        "ins2PreCode":"public void testNullGuardAddWhenCached() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition, MethodHandles.publicLookup(),",
        "label":1
    },
    {
        "ins1CurCode":"return false; } if (!ObjectUtils.equal(this.data, that.data)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtilities.equal(this.data, that.data)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtilities.equal(this.data, that.data)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerializeAndParse() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); TestMap message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build();",
        "ins1PreCode":"public void testSerializeAndParse() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build();",
        "ins2PreCode":"public void testSerializeAndParse() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesUpdated(message);  builder = message.toBuilder(); builder.clear(); message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesCleared(message);",
        "label":0
    },
    {
        "ins1CurCode":"void javaBeanMetadataNestedGroup() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanMetadataNestedGroup() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokMetadataNestedGroupNoGetter() throws IOException { process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"ctx.addApplicationListener(TrackingRequestListener.class.getName());  TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv);  tomcat.start();  StringBuilder url = new StringBuilder(48); url.append(\"http://localhost:\"); url.append(getPort()); url.append(\"/stage1?iter=\"); url.append(iter); if (useThread) { url.append(\"&useThread=y\"); } ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(\"requestInitialized-\"); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); loop--; } expected.append(\"NonAsyncServletGet-\"); expected.append(\"requestDestroyed\"); assertEquals(expected.toString(), res.toString());   List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > 0); assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);",
        "ins1PreCode":"ctx.addApplicationListener(TrackingRequestListener.class.getName());  tomcat.start();  StringBuilder url = new StringBuilder(48); url.append(\"http://localhost:\"); url.append(getPort()); url.append(\"/stage1?iter=\"); url.append(iter); if (useThread) { url.append(\"&useThread=y\"); } ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(\"requestInitialized-\"); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); loop--; } expected.append(\"NonAsyncServletGet-\"); expected.append(\"requestDestroyed\"); assertEquals(expected.toString(), res.toString());",
        "ins2PreCode":"ctx.addApplicationListener(TrackingRequestListener.class.getName());  tomcat.start();  StringBuilder url = new StringBuilder(48); url.append(\"http://localhost:\"); url.append(getPort()); url.append(\"/stage1?iter=\"); url.append(iter); if (useThread) { url.append(\"&useThread=y\"); } ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(\"requestInitialized-\"); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); if (loop != iter) { expected.append(\"onStartAsync-\"); } loop--; } expected.append(\"ErrorServletGet-onError-onComplete-requestDestroyed\"); assertEquals(expected.toString(), res.toString());",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtInvalidIndex() { assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1PreCode":"Observable.just(1, 2).subscribe(to);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); to.assertValueAt(2, new Predicate<Integer>() {",
        "ins2PreCode":"public void assertValueAtPredicateMatch() { TestObserver<Integer> to = new TestObserver<>();  Observable.just(1, 2).subscribe(to);  to.assertValueAt(1, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 2; } });",
        "label":0
    },
    {
        "ins1CurCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try {  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(generateSessionReadQuery(options))) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins1PreCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { boolean atLeastV11 = dataSource.isAtLeastV11(); try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, \"); if (atLeastV11) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\");    if (atLeastV11) { sql.append(\" AND s.sql_child_number = sq.child_number (+)\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) { sql.append(\" AND s.TYPE = 'USER'\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_INACTIVE)) { sql.append(\" AND s.STATUS <> 'INACTIVE'\"); } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins2PreCode":"{ try { boolean onlyConnections = CommonUtils.getOption(options, OPTION_SHOW_ONLY_CONNECTIONS); boolean supportsDatabaseInfo = ((SQLServerDataSource) session.getDataSource()).isServerVersionAtLeast(SQLServerConstants.SQL_SERVER_2012_VERSION_MAJOR, 0);  StringBuilder sql = new StringBuilder(); sql.append(\"SELECT s.*,\"); if (supportsDatabaseInfo) { sql.append(\"db.name as database_name,\"); } else { sql.append(\"NULL as database_name,\"); } sql.append(\"c.connection_id,(select text from sys.dm_exec_sql_text(c.most_recent_sql_handle)) as sql_text\\n\") .append(\"FROM sys.dm_exec_sessions s\\n\"); if (onlyConnections) { sql.append(\"LEFT OUTER \"); } sql.append(\"JOIN sys.dm_exec_connections c ON c.session_id=s.session_id\\n\"); if (supportsDatabaseInfo) { sql.append(\"LEFT OUTER JOIN sys.sysdatabases db on db.dbid=s.database_id\\n\"); } sql.append(\"ORDER BY s.session_id DESC\");  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "label":0
    },
    {
        "ins1CurCode":"JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream);  JavaPairDStream<String, Integer> combined = pairStream.combineByKey(i -> i, (x, y) -> x + y, (x, y) -> x + y, new HashPartitioner(2));",
        "ins1PreCode":"JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream);  JavaPairDStream<String, Integer> combined = pairStream.<Integer>combineByKey(i -> i, (x, y) -> x + y, (x, y) -> x + y, new HashPartitioner(2));",
        "ins2PreCode":" JavaPairDStream<String, Integer> combined = pairStream.combineByKey( new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i; } }, new IntegerSum(), new IntegerSum(), new HashPartitioner(2)); ",
        "label":0
    },
    {
        "ins1CurCode":"public boolean offerFirst(final E e, final long timeout, final TimeUnit unit) throws InterruptedException { Objects.requireNonNull(e, \"e\"); long nanos = unit.toNanos(timeout);",
        "ins1PreCode":"public boolean offerFirst(final E e, final long timeout, final TimeUnit unit) throws InterruptedException { if (e == null) { throw new NullPointerException(); }",
        "ins2PreCode":"public boolean offerLast(final E e, final long timeout, final TimeUnit unit) throws InterruptedException { if (e == null) { throw new NullPointerException(); }",
        "label":1
    },
    {
        "ins1CurCode":"List.of(new ContentSelector(StandardField.AUTHOR, List.of(\"Test Author\")), new ContentSelector(StandardField.TITLE, List.of(\"Test Title\"))); GroupTreeNode expectedImportedGroupNode = new GroupTreeNode(new ExplicitGroup(\"Imported unknown\", GroupHierarchyType.INDEPENDENT, ';')); ",
        "ins1PreCode":"List.of(new ContentSelector(StandardField.AUTHOR, List.of(\"Test Author\")), new ContentSelector(StandardField.TITLE, List.of(\"Test Title\"))); GroupTreeNode expectedImportedGroupNode = new GroupTreeNode(new ExplicitGroup(\"Imported unknown\", GroupHierarchyType.INDEPENDENT, JabRefPreferences.getInstance().getKeywordDelimiter())); ",
        "ins2PreCode":"void mergeMetaDataWithoutAllEntriesGroup() { MetaData target = new MetaData(); target.addContentSelector(new ContentSelector(StandardField.AUTHOR, List.of(\"Test Author\"))); GroupTreeNode targetRootGroup = new GroupTreeNode(new TestGroup(\"targetGroup\", GroupHierarchyType.INDEPENDENT)); target.setGroups(targetRootGroup); MetaData other = new MetaData(); GroupTreeNode otherRootGroup = new GroupTreeNode(new TestGroup(\"otherGroup\", GroupHierarchyType.INCLUDING)); other.setGroups(otherRootGroup); other.addContentSelector(new ContentSelector(StandardField.TITLE, List.of(\"Test Title\"))); List<ContentSelector> expectedContentSelectors = List.of(new ContentSelector(StandardField.AUTHOR, List.of(\"Test Author\")), new ContentSelector(StandardField.TITLE, List.of(\"Test Title\")));  new DatabaseMerger().mergeMetaData(target, other, \"unknown\", List.of());   assertEquals(expectedContentSelectors, target.getContentSelectorList());   assertEquals(targetRootGroup, target.getGroups().get()); assertEquals(target.getGroups().get().getChildren().size(), 1); assertEquals(otherRootGroup, target.getGroups().get().getChildren().get(0));",
        "label":0
    },
    {
        "ins1CurCode":"public void hsqlServerIsNotShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class)); Statement statement = configureDataSourceBehavior(",
        "ins1PreCode":"public void hsqlServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior(",
        "ins2PreCode":"public void inMemoryHsqlIsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior(",
        "label":1
    },
    {
        "ins1CurCode":"try { if (value == null) { downstream.onError(ExceptionHelper.createNullPointerException(\"onSuccess called with a null value.\")); } else {",
        "ins1PreCode":"try { if (value == null) { downstream.onError(new NullPointerException(\"onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.\")); } else {",
        "ins2PreCode":"try { if (value == null) { downstream.onError(new NullPointerException(\"onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.\")); } else {",
        "label":1
    },
    {
        "ins1CurCode":"} ftp.changeToParentDirectory(); } catch (FTPConnectionClosedException ftpcce) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", ftpcce); } catch (IOException e) {",
        "ins1PreCode":"} ftp.changeToParentDirectory(); } catch (IOException e) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", e); }",
        "ins2PreCode":"protected void scandir(String dir, String vpath, boolean fast) {  if (fast && hasBeenScanned(vpath)) { return; } try { if (!ftp.changeWorkingDirectory(dir)) { return; } String completePath; if (vpath.isEmpty()) { completePath = rootPath; } else { completePath = rootPath + task.getSeparator() + vpath.replace(File.separatorChar, task.getSeparator().charAt(0)); } FTPFile[] newfiles = listFiles(completePath, false);  if (newfiles == null) { ftp.changeToParentDirectory(); return; } for (FTPFile file : newfiles) { if (file != null && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file)); if (isFunctioningAsDirectory(ftp, dir, file)) { boolean slowScanAllowed = true; if (!isFollowSymlinks() && file.isSymbolicLink()) { dirsExcluded.addElement(name); slowScanAllowed = false; } else if (isIncluded(name)) { accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath), fast); } else { dirsNotIncluded.addElement(name); if (fast && couldHoldIncluded(name)) { scandir(file.getName(), name + File.separator, fast); } } if (!fast && slowScanAllowed) { scandir(file.getName(), name + File.separator, fast); } } else { if (!isFollowSymlinks() && file.isSymbolicLink()) { filesExcluded.addElement(name); } else if (isFunctioningAsFile(ftp, dir, file)) { accountForIncludedFile(name); } } } } ftp.changeToParentDirectory(); } catch (IOException e) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", e); }",
        "label":0
    },
    {
        "ins1CurCode":"dataset.add(new BoxAndWhiskerItem(1.0, null, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins1PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, null, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, null, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposable.empty(); observer.onSubscribe(bs1);  Disposable bs2 = Disposable.empty(); observer.onSubscribe(bs2);",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1);  Disposable bs2 = Disposables.empty(); observer.onSubscribe(bs2);",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1);  Disposable bs2 = Disposables.empty(); observer.onSubscribe(bs2);",
        "label":1
    },
    {
        "ins1CurCode":"  Tomcat.addServlet(ctx, \"TesterServlet\", new ServerNameTesterServlet()); ctx.addServletMappingDecoded(\"/foo\", \"TesterServlet\");  tomcat.start();  String request = \"GET http://a:8080/foo HTTP/1.1\" + SimpleHttpClient.CRLF + \"Host: a:8080\" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF;  Client client = new Client(tomcat.getConnector().getLocalPort()); client.setRequest(new String[] {request});  client.connect(); client.processRequest();   Assert.assertTrue(client.isResponse200()); Assert.assertEquals(\"request.getServerName() is [a] and request.getServerPort() is 8080\", client.getResponseBody()); ",
        "ins1PreCode":"  Tomcat.addServlet(ctx, \"TesterServlet\", new TesterServlet()); ctx.addServletMappingDecoded(\"/foo\", \"TesterServlet\");",
        "ins2PreCode":"public void testInconsistentHostHeader02() throws Exception { Tomcat tomcat = getTomcatInstance();    tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");   Context ctx = tomcat.addContext(\"\", null);   Tomcat.addServlet(ctx, \"TesterServlet\", new TesterServlet()); ctx.addServletMappingDecoded(\"/foo\", \"TesterServlet\");  tomcat.start();  String request = \"GET http://a:8080/foo HTTP/1.1\" + SimpleHttpClient.CRLF + \"Host: b:8080\" + SimpleHttpClient.CRLF + SimpleHttpClient.CRLF;  Client client = new Client(tomcat.getConnector().getLocalPort()); client.setRequest(new String[] {request});  client.connect(); client.processRequest();   Assert.assertTrue(client.isResponse400());",
        "label":0
    },
    {
        "ins1CurCode":"public Object clone() throws CloneNotSupportedException { DefaultXYDataset clone = (DefaultXYDataset) super.clone(); clone.seriesKeys = new ArrayList(this.seriesKeys); clone.seriesList = new ArrayList(this.seriesList.size()); for (int i = 0; i < this.seriesList.size(); i++) { double[][] data = this.seriesList.get(i); double[] x = data[0];",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException { DefaultXYDataset clone = (DefaultXYDataset) super.clone(); clone.seriesKeys = new java.util.ArrayList(this.seriesKeys); clone.seriesList = new ArrayList(this.seriesList.size()); for (int i = 0; i < this.seriesList.size(); i++) { double[][] data = (double[][]) this.seriesList.get(i); double[] x = data[0];",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { DefaultXYZDataset clone = (DefaultXYZDataset) super.clone(); clone.seriesKeys = new java.util.ArrayList(this.seriesKeys); clone.seriesList = new ArrayList(this.seriesList.size()); for (int i = 0; i < this.seriesList.size(); i++) { double[][] data = (double[][]) this.seriesList.get(i); double[] x = data[0]; double[] y = data[1]; double[] z = data[2]; double[] xx = new double[x.length]; double[] yy = new double[y.length]; double[] zz = new double[z.length]; System.arraycopy(x, 0, xx, 0, x.length); System.arraycopy(y, 0, yy, 0, y.length); System.arraycopy(z, 0, zz, 0, z.length); clone.seriesList.add(i, new double[][] {xx, yy, zz}); } return clone;",
        "label":0
    },
    {
        "ins1CurCode":"x.printStackTrace(); return; } } };",
        "ins1PreCode":"x.printStackTrace(); return; } finally { threadCounter++; }",
        "ins2PreCode":"x.printStackTrace(); return; } finally { threadCounter++; }",
        "label":1
    },
    {
        "ins1CurCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, bufferSize, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "ins1PreCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "ins2PreCode":"public final <R> Observable<R> flatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableFlatMap<>(this, mapper, delayErrors, maxConcurrency, bufferSize));",
        "label":0
    },
    {
        "ins1CurCode":" List<Movie> newList = listOfLists.get(1); List<Movie> oldList = new ArrayList<>(listOfLists.get(0));  Set<Movie> delta = new LinkedHashSet<>(); delta.addAll(newList);",
        "ins1PreCode":" List<Movie> newList = listOfLists.get(1); List<Movie> oldList = new ArrayList<Movie>(listOfLists.get(0));  Set<Movie> delta = new LinkedHashSet<Movie>(); delta.addAll(newList);",
        "ins2PreCode":" List<Movie> newList = listOfLists.get(1); List<Movie> oldList = new ArrayList<Movie>(listOfLists.get(0));  Set<Movie> delta = new LinkedHashSet<Movie>(); delta.addAll(newList);",
        "label":1
    },
    {
        "ins1CurCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints, String... servletPaths) { StaticWebApplicationContext context = new StaticWebApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context .getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } if (servletPaths != null) { DispatcherServletPathProvider pathProvider = () -> new LinkedHashSet<>( Arrays.asList(servletPaths)); context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider);",
        "ins1PreCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints, String servletPath) { StaticWebApplicationContext context = new StaticWebApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context .getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } if (servletPath != null) { DispatcherServletPathProvider pathProvider = () -> servletPath; context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider);",
        "ins2PreCode":"private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, PathMappedEndpoints pathMappedEndpoints) { StaticApplicationContext context = new StaticApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context.getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } return assertThat(new RequestMatcherAssert(context, matcher));",
        "label":0
    },
    {
        "ins1CurCode":"return Flowable.just(v).hide(); } }, true, 2, ImmediateThinScheduler.INSTANCE); }",
        "ins1PreCode":"return Flowable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); }",
        "ins2PreCode":"return Flowable.just(v).hide(); } }, 2, false); }",
        "label":0
    },
    {
        "ins1CurCode":".assertResult(1);  assertFalse(\"Subject still has observers!\", ps.hasObservers());",
        "ins1PreCode":".assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins2PreCode":".assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "label":1
    },
    {
        "ins1CurCode":"public static <T, R> Flowable<R> zipArray(@NonNull Function<? super Object[], ? extends R> zipper, boolean delayError, int bufferSize, @NonNull Publisher<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins1PreCode":"public static <T, R> Flowable<R> zipArray(@NonNull Function<? super Object[], ? extends R> zipper, boolean delayError, int bufferSize, @NonNull Publisher<? extends T>... sources) { if (sources.length == 0) { return empty();",
        "ins2PreCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } Objects.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new FlowableCombineLatest<>(sources, combiner, bufferSize, false));",
        "label":0
    },
    {
        "ins1CurCode":"Platform.copyMemory( baseObject, baseOffset, arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); return arrayCopy;",
        "ins1PreCode":"Platform.copyMemory( baseObject, baseOffset, arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, numElements, sizeInBytes); return arrayCopy;",
        "ins2PreCode":"public UnsafeRow copy() { UnsafeRow rowCopy = new UnsafeRow(); final byte[] rowDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes ); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); return rowCopy;",
        "label":0
    },
    {
        "ins1CurCode":"public void testMapSplitter_trimmedBoth() { Map<String, String> m = COMMA_SPLITTER .trimResults() .withKeyValueSeparator(Splitter.on(':').trimResults()) .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \"); ASSERT.that(m).isEqualTo( ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"));",
        "ins1PreCode":"public void testMapSplitter_trimmedBoth() { Map<String, String> m = Splitter.on(',') .trimResults() .withKeyValueSeparator(Splitter.on(':').trimResults()) .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \"); assertEquals(\"tom\", m.get(\"boy\")); assertEquals(\"tina\", m.get(\"girl\")); assertEquals(\"kitty\", m.get(\"cat\")); assertEquals(\"tommy\", m.get(\"dog\"));",
        "ins2PreCode":"public void testMapSplitter_trimmedKeyValue() { Map<String, String> m = Splitter.on(',') .withKeyValueSeparator(Splitter.on(':').trimResults()) .split(\"boy  : tom , girl: tina , cat  : kitty , dog: tommy \"); assertEquals(\"tom\", m.get(\"boy\")); assertEquals(\"tina\", m.get(\"girl\")); assertEquals(\"kitty\", m.get(\"cat\")); assertEquals(\"tommy\", m.get(\"dog\"));",
        "label":1
    },
    {
        "ins1CurCode":"public Long getRowCount(DBRProgressMonitor monitor) {",
        "ins1PreCode":"public synchronized Long getRowCount(DBRProgressMonitor monitor) {",
        "ins2PreCode":"public synchronized Long getRealRowCount(DBRProgressMonitor monitor) { if (realRowCount != null) { return realRowCount; } if (!isPersisted()) {  return null; }   try (DBCSession session = DBUtils.openMetaSession(monitor, this, \"Read row count\")) { realRowCount = countData(new AbstractExecutionSource(this, session.getExecutionContext(), this), session, null, DBSDataContainer.FLAG_NONE); } catch (DBException e) { log.debug(\"Can't fetch row count\", e); } if (realRowCount == null) { realRowCount = -1L; }  return realRowCount;",
        "label":0
    },
    {
        "ins1CurCode":"public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify) { Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\"); Collection markers;",
        "ins1PreCode":"public void addDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ParamChecks.nullNotPermitted(marker, \"marker\"); ParamChecks.nullNotPermitted(layer, \"layer\"); Collection markers;",
        "ins2PreCode":"public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) { Collection markers; if (layer == Layer.FOREGROUND) { markers = (Collection) this.foregroundRangeMarkers.get( new Integer(index)); if (markers == null) { markers = new java.util.ArrayList(); this.foregroundRangeMarkers.put(new Integer(index), markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = (Collection) this.backgroundRangeMarkers.get( new Integer(index)); if (markers == null) { markers = new java.util.ArrayList(); this.backgroundRangeMarkers.put(new Integer(index), markers); } markers.add(marker); } marker.addChangeListener(this); if (notify) { fireChangeEvent(); }",
        "label":0
    },
    {
        "ins1CurCode":"void beanMethods() throws Exception { MockAtomikosDataSourceBean bean = spy(new MockAtomikosDataSourceBean());",
        "ins1PreCode":"public void beanMethods() throws Exception { MockAtomikosDataSourceBean bean = spy(new MockAtomikosDataSourceBean());",
        "ins2PreCode":"public void beanMethods() throws Exception { MockAtomikosConnectionFactoryBean bean = spy(new MockAtomikosConnectionFactoryBean());",
        "label":1
    },
    {
        "ins1CurCode":"entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation(fileField));  when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey]\"); cleanup.cleanup(entry);",
        "ins1PreCode":"entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation(fileField));  when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey]\"); cleanup.cleanup(entry);",
        "ins2PreCode":"entry.setField(StandardField.TITLE, \"test title\");  when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey] - [fulltitle]\"); cleanup.cleanup(entry);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XYBubbleRenderer r1 = new XYBubbleRenderer(); XYBubbleRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYBubbleRenderer r1 = new XYBubbleRenderer(); XYBubbleRenderer r2 = (XYBubbleRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYBarRenderer r1 = new StackedXYBarRenderer(); StackedXYBarRenderer r2 = (StackedXYBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"  Assert.assertTrue(client.isResponse400());",
        "ins1PreCode":"  assertTrue(client.isResponse400());",
        "ins2PreCode":"  assertTrue(client.isResponse400());",
        "label":1
    },
    {
        "ins1CurCode":"secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0); ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "ins1PreCode":"secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "ins2PreCode":"secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "label":1
    },
    {
        "ins1CurCode":"};  Disposable sub1 = Disposable.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposable.empty(); ",
        "ins1PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "ins2PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":" Boolean finalResult = r.start(); Assert.assertTrue(finalResult != null && finalResult); ",
        "ins1PreCode":" Boolean finalResult = r.start(); Assert.assertTrue(finalResult == null ? false : finalResult); ",
        "ins2PreCode":" Boolean finalResult = r.start(); Assert.assertTrue(finalResult == null ? false : finalResult); ",
        "label":1
    },
    {
        "ins1CurCode":"buildRule.executeTarget(\"containsregex\"); String contents = getFileString(buildRule.getProject().getProperty(\"output\") + \"/containsregex\"); assertThat(contents, containsString(\"hello world\")); assertThat(contents, not(containsString(\"this is the moon\"))); assertThat(contents, containsString(\"World here\"));",
        "ins1PreCode":"buildRule.executeTarget(\"containsregex\"); String contents = getFileString(buildRule.getProject().getProperty(\"output\") + \"/containsregex\"); assertContains(\"hello world\", contents); assertNotContains(\"this is the moon\", contents); assertContains(\"World here\", contents);",
        "ins2PreCode":"public void testFilterContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeTrue(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\").contains(\"bye world\"));  buildRule.executeTarget(\"filtercontainsregex\"); String contents = getFileString(buildRule.getProject().getProperty(\"output\") + \"/filtercontainsregex\"); assertContains(\"hello world\", contents); assertNotContains(\"this is the moon\", contents); assertContains(\"World here\", contents);",
        "label":1
    },
    {
        "ins1CurCode":"} else if (value instanceof Double) { return (double)value; } else if (value instanceof BigInteger) { return ((BigInteger)value).doubleValue(); } else {",
        "ins1PreCode":"} else if (value instanceof Double) { return (double)value; } else { throw new ClassCastException(\"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" +",
        "ins2PreCode":"public static float defTofloatImplicit(final Object value) { if (value instanceof Byte) { return (byte)value; } else if (value instanceof Short) { return (short)value; } else if (value instanceof Character) { return (char)value; } else if (value instanceof Integer) { return (int)value; } else if (value instanceof Long) { return (long)value; } else if (value instanceof Float) { return (float)value; } else { throw new ClassCastException(\"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + float.class.getCanonicalName()); }",
        "label":0
    },
    {
        "ins1CurCode":".withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:https://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping( context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(interceptor, \"cloudFoundrySecurityService\"); String cloudControllerUrl = (String) ReflectionTestUtils .getField(interceptorSecurityService, \"cloudControllerUrl\"); assertThat(cloudControllerUrl) .isEqualTo(\"https://my-cloud-controller.com\"); });",
        "ins1PreCode":".withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping( context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(interceptor, \"cloudFoundrySecurityService\"); String cloudControllerUrl = (String) ReflectionTestUtils .getField(interceptorSecurityService, \"cloudControllerUrl\"); assertThat(cloudControllerUrl) .isEqualTo(\"http://my-cloud-controller.com\"); });",
        "ins2PreCode":".withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping( context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(interceptor, \"cloudFoundrySecurityService\"); String cloudControllerUrl = (String) ReflectionTestUtils .getField(interceptorSecurityService, \"cloudControllerUrl\"); assertThat(cloudControllerUrl) .isEqualTo(\"http://my-cloud-controller.com\"); });",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> concat( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Flowable<T> concat( @NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> merge( @NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":1
    },
    {
        "ins1CurCode":"void inputStreamReadPastSubsection() throws Exception { RandomAccessData subsection = this.file.getSubsection(1, 2);",
        "ins1PreCode":"public void inputStreamReadPastSubsection() throws Exception { RandomAccessData subsection = this.file.getSubsection(1, 2);",
        "ins2PreCode":"public void getEntryUrlStream() throws Exception { URL url = new URL(this.jarFile.getUrl(), \"1.dat\");",
        "label":1
    },
    {
        "ins1CurCode":" PublishProcessor<Integer> source = PublishProcessor.create(); final List<PublishProcessor<Integer>> subjects = new ArrayList<>(); for (int i = 0; i < n; i++) {",
        "ins1PreCode":" PublishProcessor<Integer> source = PublishProcessor.create(); final List<PublishProcessor<Integer>> subjects = new ArrayList<PublishProcessor<Integer>>(); for (int i = 0; i < n; i++) {",
        "ins2PreCode":" PublishSubject<Integer> source = PublishSubject.create(); final List<PublishSubject<Integer>> subjects = new ArrayList<PublishSubject<Integer>>(); for (int i = 0; i < n; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"public void primaryExporterIsAllowed() { this.contextRunner.withPropertyValues(\"spring.jmx.enabled=true\") .withUserConfiguration(CustomMBeanExporter.class).run((context) -> { assertThat(context).getBeans(MBeanExporter.class).hasSize(2);",
        "ins1PreCode":"public void primaryExporterIsAllowed() { this.contextRunner.withUserConfiguration(CustomMBeanExporter.class) .run((context) -> { assertThat(context).getBeans(MBeanExporter.class).hasSize(2);",
        "ins2PreCode":"public void handlerAdaptersCreated() { this.contextRunner.run((context) -> { assertThat(context).getBeans(HandlerAdapter.class).hasSize(3); assertThat(context.getBean(RequestMappingHandlerAdapter.class) .getMessageConverters()).isNotEmpty().isEqualTo( context.getBean(HttpMessageConverters.class).getConverters()); });",
        "label":0
    },
    {
        "ins1CurCode":" assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-strikeout.pdf\")));",
        "ins1PreCode":" assertEquals(Collections.singletonList(expected), importer.importAnnotations(Paths.get(\"src/test/resources/pdfs/minimal-strikeout.pdf\")));",
        "ins2PreCode":" assertEquals(Collections.singletonList(expected), importer.importAnnotations(Paths.get(\"src/test/resources/pdfs/minimal-highlight-with-note.pdf\")));",
        "label":1
    },
    {
        "ins1CurCode":"  Dataset<Row> predictions = model.transform(dataset);   ClusteringEvaluator evaluator = new ClusteringEvaluator();  double silhouette = evaluator.evaluate(predictions); System.out.println(\"Silhouette with squared euclidean distance = \" + silhouette); ",
        "ins1PreCode":"  double cost = model.computeCost(dataset); System.out.println(\"Within Set Sum of Squared Errors = \" + cost); ",
        "ins2PreCode":"public static void main(String[] args) {  SparkSession spark = SparkSession .builder() .appName(\"JavaKMeansExample\") .getOrCreate();    Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\");   KMeans kmeans = new KMeans().setK(2).setSeed(1L); KMeansModel model = kmeans.fit(dataset);   Dataset<Row> predictions = model.transform(dataset);   ClusteringEvaluator evaluator = new ClusteringEvaluator();  double silhouette = evaluator.evaluate(predictions); System.out.println(\"Silhouette with squared euclidean distance = \" + silhouette);   Vector[] centers = model.clusterCenters(); System.out.println(\"Cluster Centers: \"); for (Vector center: centers) { System.out.println(center); }   spark.stop();",
        "label":0
    },
    {
        "ins1CurCode":" @Override public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError();",
        "ins1PreCode":" @Override public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError();",
        "ins2PreCode":" @Override public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError();",
        "label":1
    },
    {
        "ins1CurCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockGraphManager.keyType);  switch (otype) {  case LockGraphManager.typeWait: dbStat.setInt(1, (int) options.get(pidWait)); break;  case LockGraphManager.typeHold: dbStat.setInt(1, (int) options.get(pidHold)); break;",
        "ins1PreCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockManagerViewer.keyType);  switch (otype) {  case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(PostgreLockEditor.pidWait)); break;  case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(PostgreLockEditor.pidHold)); break;",
        "ins2PreCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockManagerViewer.keyType);  switch(otype) { case LockManagerViewer.typeWait: dbStat.setBigDecimal(1, new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidWait))); break; case LockManagerViewer.typeHold: dbStat.setBigDecimal(1,  new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidHold)));",
        "label":0
    },
    {
        "ins1CurCode":"Date end = new Date(m1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnitType.MILLISECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime());",
        "ins1PreCode":"Date end = new Date(m1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.MILLISECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime());",
        "ins2PreCode":"Date end = new Date(m1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.MILLISECOND, 10); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime());",
        "label":1
    },
    {
        "ins1CurCode":"}  for (int i = 0; i < oneofs.length; i++) { oneofs[i].setProto(proto.getOneofDecl(i)); }",
        "ins1PreCode":"}  for (int i = 0; i < enumTypes.length; i++) { enumTypes[i].setProto(proto.getEnumType(i)); }",
        "ins2PreCode":"private void setProto(final FileDescriptorProto proto) { this.proto = proto;  for (int i = 0; i < messageTypes.length; i++) { messageTypes[i].setProto(proto.getMessageType(i)); }  for (int i = 0; i < enumTypes.length; i++) { enumTypes[i].setProto(proto.getEnumType(i)); }  for (int i = 0; i < services.length; i++) { services[i].setProto(proto.getService(i)); }  for (int i = 0; i < extensions.length; i++) { extensions[i].setProto(proto.getExtension(i)); }",
        "label":0
    },
    {
        "ins1CurCode":"void testSelectListWithNestedResultMap() throws Exception { String xmlConfig = \"org/apache/ibatis/submitted/custom_collection_handling/MapperConfig.xml\";",
        "ins1PreCode":"public void testSelectListWithNestedResultMap() throws Exception { String xmlConfig = \"org/apache/ibatis/submitted/custom_collection_handling/MapperConfig.xml\";",
        "ins2PreCode":"public void testSelectListWithNestedSelect() throws Exception { String xmlConfig = \"org/apache/ibatis/submitted/custom_collection_handling/MapperConfig.xml\";",
        "label":1
    },
    {
        "ins1CurCode":"while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry.isPrimary() ) set.add(key); }",
        "ins1PreCode":"while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); MapEntry entry = (MapEntry)e.getValue(); if ( entry.isPrimary() ) set.add(entry.getKey()); }",
        "ins2PreCode":"while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); MapEntry entry = (MapEntry)e.getValue(); if ( entry.isPrimary() ) set.add(entry); }",
        "label":0
    },
    {
        "ins1CurCode":"TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatContextCustomizer.class)); factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins1PreCode":"TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; Arrays.setAll(listeners, i -> mock(TomcatContextCustomizer.class)); factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins2PreCode":"TomcatServletWebServerFactory factory = getFactory(); TomcatConnectorCustomizer[] listeners = new TomcatConnectorCustomizer[4]; Arrays.setAll(listeners, i -> mock(TomcatConnectorCustomizer.class)); factory.setTomcatConnectorCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "label":1
    },
    {
        "ins1CurCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel channel = getSocket(); if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel .getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(to, channel, selector, att.getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(to); if (nRead == -1) {",
        "ins1PreCode":"private int fillReadBuffer(boolean block) throws IOException { int nRead; NioChannel channel = getSocket(); socketBufferHandler.configureReadBufferForWrite(); if (block) { Selector selector = null; try { selector = pool.get(); } catch ( IOException x ) {  } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel.getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(socketBufferHandler.getReadBuffer()); if (nRead == -1) {",
        "ins2PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) {  do { if (getSocket().flush(true, selector, writeTimeout)) { break; } } while (true); } updateLastWrite(); } finally { if (selector != null) { pool.put(selector); } }    ",
        "label":0
    },
    {
        "ins1CurCode":"void couchbaseClusterIsUp() { Cluster cluster = mock(Cluster.class);",
        "ins1PreCode":"public void couchbaseClusterIsUp() { Cluster cluster = mock(Cluster.class);",
        "ins2PreCode":"public void couchbaseClusterIsDown() { Cluster cluster = mock(Cluster.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void putEdge_doesntAllowSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(graph.allowsSelfLoops()).isFalse(); ",
        "ins1PreCode":"public void putEdge_doesntAllowSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isFalse(); ",
        "ins2PreCode":"public void putEdge_doesntAllowSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isFalse(); ",
        "label":1
    },
    {
        "ins1CurCode":"d1.setValue(\"C4\", 452.7);  DefaultPieDataset<String> d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"d1.setValue(\"C4\", 452.7);  DefaultPieDataset<String> d2 = (DefaultPieDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testSerialization() { DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); d1.setValue(\"C1\", 234.2); d1.setValue(\"C2\", null); d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7);  KeyedValuesDataset d2 = (KeyedValuesDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":0
    },
    {
        "ins1CurCode":"void ignoresIfMissingSecretFromRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\"));",
        "ins1PreCode":"public void ignoresIfMissingSecretFromRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\"));",
        "ins2PreCode":"public void ignoresInvalidSecretInRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\"));",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\")); ",
        "ins1PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "ins2PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void assertError2() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"public void assertError2() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"public void assertError2() { TestSubscriber<Integer> ts = TestSubscriber.create();  try { ts.assertError(TestException.class); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError ex) {  }  try { ts.assertError(new TestException()); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError ex) {  }  try { ts.assertError(Functions.<Throwable>alwaysTrue()); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError ex) {  }  try { ts.assertSubscribed(); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  ts.onSubscribe(new BooleanSubscription());  ts.assertSubscribed();  ts.assertNoErrors();  TestException ex = new TestException(\"Forced failure\");  ts.onError(ex);  ts.assertError(ex);  ts.assertError(TestException.class);  ts.assertError(Functions.<Throwable>alwaysTrue());  ts.assertError(new Predicate<Throwable>() { @Override public boolean test(Throwable t) { return t.getMessage() != null && t.getMessage().contains(\"Forced\"); } });  try { ts.assertError(new RuntimeException()); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  try { ts.assertError(IOException.class); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  try { ts.assertNoErrors(); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  try { ts.assertError(Functions.<Throwable>alwaysFalse()); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  ts.assertValueCount(0);  ts.assertNoValues();",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldInsertNewAuthorWithBeforeAutoKey() throws Exception {  Executor executor = createExecutor(new JdbcTransaction(ds, null, false)); try {",
        "ins1PreCode":"public void shouldInsertNewAuthorWithBeforeAutoKey() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try {",
        "ins2PreCode":"public void shouldInsertNewAuthorWithAutoKey() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try {",
        "label":1
    },
    {
        "ins1CurCode":"public void testLoadProject() throws Exception { testSave(); File file = new File(\"test.xmi\");",
        "ins1PreCode":"public void testLoadProject() throws Exception { File file = new File(\"test.xmi\"); ",
        "ins2PreCode":"public void testLoadProject13() throws Exception { String filename = \"/testmodels/uml13/Alittlebitofeverything.xmi\"; URL url = TestZargoFilePersister.class.getResource(filename); assertTrue(\"Unintended failure: resource to be tested is not found: \" + filename + \", converted to URL: \" + url, url != null); String name = url.getFile();  XmiFilePersister persister = new XmiFilePersister();  Project project = ProjectManager.getManager().makeEmptyProject(); ProjectManager.getManager().setCurrentProject(project);  persister.doLoad(new File(name));  ProjectManager.getManager().removeProject(project);",
        "label":0
    },
    {
        "ins1CurCode":"File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file, StandardCharsets.UTF_8), Result.FAILURE.toString());",
        "ins1PreCode":"File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "ins2PreCode":"File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "label":1
    },
    {
        "ins1CurCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.avg(value -> value._2() * 2.0)); Assert.assertEquals(",
        "ins1PreCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.avg(value -> value._2() * 2.0)); Assert.assertEquals(",
        "ins2PreCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.avg(v -> (double)(v._2() * 2))); Assert.assertEquals(",
        "label":1
    },
    {
        "ins1CurCode":"Vectors.dense(1.0, 4.0, 6.0) ); JavaRDD<Vector> data = jsc.parallelize(points, 2); KMeansModel model = new KMeans().setK(1).setMaxIterations(5).run(data.rdd());",
        "ins1PreCode":"Vectors.dense(1.0, 4.0, 6.0) ); JavaRDD<Vector> data = sc.parallelize(points, 2); KMeansModel model = new KMeans().setK(1).setMaxIterations(5).run(data.rdd());",
        "ins2PreCode":");  JavaRDD<Vector> data = sc.parallelize(points, 2); GaussianMixtureModel model = new GaussianMixture().setK(2).setMaxIterations(1).setSeed(1234)",
        "label":1
    },
    {
        "ins1CurCode":"public void timedAndSizedTruncation() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<>(2, 2000, TimeUnit.MILLISECONDS, test, false); List<Integer> values = new ArrayList<>(); ",
        "ins1PreCode":"public void timedAndSizedTruncation() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false); List<Integer> values = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void timedAndSizedTruncation() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false); List<Integer> values = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\")); assertThat(exception.getMetadata(\"es.processor_tag\").get(0), equalTo(processorTag));",
        "ins1PreCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\")); assertThat(exception.getHeader(\"processor_tag\").get(0), equalTo(processorTag));",
        "ins2PreCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\")); assertThat(exception.getHeader(\"processor_tag\").get(0), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"patternBank.put(\"THREE\", \"3\"); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), patternBank, Arrays.asList(\"%{ONE:one}\", \"%{TWO:two}\", \"%{THREE:three}\"), fieldName, false, false, MatcherWatchdog.noop()); processor.execute(doc);",
        "ins1PreCode":"patternBank.put(\"THREE\", \"3\"); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), patternBank, Arrays.asList(\"%{ONE:one}\", \"%{TWO:two}\", \"%{THREE:three}\"), fieldName, false, false, ThreadWatchdog.noop()); processor.execute(doc);",
        "ins2PreCode":"patternBank.put(\"THREE\", \"3\"); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), patternBank, Arrays.asList(\"%{ONE:one}\", \"%{TWO:two}\", \"%{THREE:three}\"), fieldName, true, false, ThreadWatchdog.noop()); processor.execute(doc);",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) {",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) { final ExasolTableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1CurCode":"tomcat.start();  HttpURLConnection conn = getConnection(\"http://localhost:\" + getPort() + \"/\"); InputStream is = conn.getInputStream();",
        "ins1PreCode":"tomcat.start();  HttpURLConnection conn = getConnection(); InputStream is = conn.getInputStream();",
        "ins2PreCode":"tomcat.start();  HttpURLConnection conn = getConnection(); conn.setChunkedStreamingMode(8 * 1024);",
        "label":1
    },
    {
        "ins1CurCode":"public void checkTerminatedDelayErrorEmptyError() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return new TestException(); }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32); ",
        "ins1PreCode":"public void checkTerminatedDelayErrorEmptyError() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return new TestException(); }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); ",
        "ins2PreCode":"public void checkTerminatedNonDelayErrorError() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return new TestException(); }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); ",
        "label":1
    },
    {
        "ins1CurCode":"} if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { writeBlocking = false; }",
        "ins1PreCode":"} if (n == 0) { if (blockWriteDone == null) { blockWriteDone = new AtomicBoolean(false); } else { blockWriteDone.set(false); } registerWriteInterest(); synchronized (blockWriteDone) { if (!blockWriteDone.get()) { try { if (timeout > 0) { blockWriteDone.wait(timeout); } else { blockWriteDone.wait(); } } catch (InterruptedException e) {  } if (!blockWriteDone.get()) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { blockWriteDone = null; }",
        "ins2PreCode":"long timeout = getReadTimeout(); try { blockReadDone = new AtomicBoolean(false); registerReadInterest(); synchronized (blockReadDone) { if (!blockReadDone.get()) { try { if (timeout > 0) { blockReadDone.wait(timeout); } else { blockReadDone.wait(); } } catch (InterruptedException e) {  } if (!blockReadDone.get()) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { blockReadDone = null; }",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldUpdateAuthorCommit() { Author original; try (SqlSession session = sqlMapper.openSession()) { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); Author updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } try (SqlSession session = sqlMapper.openSession()) { Author updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "ins1PreCode":"public void shouldUpdateAuthorCommit() throws Exception { SqlSession session = sqlMapper.openSession(); Author original; Author updated; try { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldUpdateAuthorIfNecessary() throws Exception { SqlSession session = sqlMapper.openSession(); Author original; Author updated; try { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); original.setBio(null); int updates = session.update(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.updateAuthorIfNecessary\", original); assertEquals(1, updates); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Item.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\", \"aProject\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testFilterChain() throws IOException { buildRule.executeTarget(\"testFilterChain\"); File tmp  = new File(buildRule.getProject().getProperty(\"output\"), \"copy.filterchain.tmp\"); File check  = new File(buildRule.getProject().getBaseDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists()); assertEquals(FileUtilities.getFileContents(tmp), FileUtilities.getFileContents(check));",
        "ins1PreCode":"public void testFilterChain() throws IOException { executeTarget(\"testFilterChain\"); File tmp  = new File(getOutputDir(), \"copy.filterchain.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists()); assertTrue(FILE_UTILS.contentEquals(tmp, check));",
        "ins2PreCode":"public void testFilterSet() throws IOException { executeTarget(\"testFilterSet\"); File tmp  = new File(getOutputDir(), \"move.filterset.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists()); assertTrue(FILE_UTILS.contentEquals(tmp, check));",
        "label":0
    },
    {
        "ins1CurCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assertions.assertEquals(2, pm.findAll().size()); }   try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); pm.delete(1); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assertions.assertEquals(1, pm.findAll().size()); }",
        "ins1PreCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }   try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); pm.delete(1); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(1, pm.findAll().size()); }",
        "ins2PreCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); Person p = new Person(3, \"hello\", \"world\"); pm.createWithOptions(p); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(3, pm.findAll().size()); }",
        "label":1
    },
    {
        "ins1CurCode":"jarOutputStream.putNextEntry(indexEntry); Writer writer = new OutputStreamWriter(jarOutputStream, StandardCharsets.UTF_8); writer.write(\"0001 BOOT-INF/lib/a.jar\\n\"); writer.write(\"0001 BOOT-INF/lib/b.jar\\n\"); writer.write(\"0002 BOOT-INF/lib/c.jar\\n\"); writer.write(\"0003 BOOT-INF/lib/d.jar\\n\"); writer.flush();",
        "ins1PreCode":"jarOutputStream.putNextEntry(indexEntry); Writer writer = new OutputStreamWriter(jarOutputStream, StandardCharsets.UTF_8); writer.write(\"a\\n\"); writer.write(\"b\\n\"); writer.write(\"c\\n\"); writer.write(\"d\\n\"); writer.flush();",
        "ins2PreCode":"jarOutputStream.putNextEntry(indexEntry); Writer writer = new OutputStreamWriter(jarOutputStream, StandardCharsets.UTF_8); writer.write(\"a\\n\"); writer.write(\"b\\n\"); writer.write(\"c\\n\"); writer.write(\"d\\n\"); writer.flush();",
        "label":1
    },
    {
        "ins1CurCode":"public Class<?> getSetterType(String name) { PropertyTokenizer prop = new PropertyTokenizer(name);",
        "ins1PreCode":"public Class getSetterType(String name) { PropertyTokenizer prop = new PropertyTokenizer(name);",
        "ins2PreCode":"public Class getGetterType(String name) { PropertyTokenizer prop = new PropertyTokenizer(name);",
        "label":1
    },
    {
        "ins1CurCode":"boolean timeoutOccurred = false; final FutureTask exec_task = new FutureTask(new Callable() { @Override public Object call() {",
        "ins1PreCode":"boolean timeoutOccurred = false; final FutureTask exec_task = new FutureTask(new Callable() { public Object call() { assertJenkinsNotInQuietMode();",
        "ins2PreCode":"boolean timeoutOccurred = false; final FutureTask exec_task = new FutureTask(new Callable() { public Object call() { assertJenkinsNotInQuietMode();",
        "label":1
    },
    {
        "ins1CurCode":"void filterShouldRecordTimer() { ClientRequest request = ClientRequest",
        "ins1PreCode":"public void filterShouldRecordTimer() { ClientRequest request = ClientRequest",
        "ins2PreCode":"public void filterWhenUriTemplatePresentShouldRecordTimer() { ClientRequest request = ClientRequest",
        "label":1
    },
    {
        "ins1CurCode":"IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = (IntervalCategoryToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StandardPieSectionLabelGenerator g1 = new StandardPieSectionLabelGenerator(); StandardPieSectionLabelGenerator g2 = (StandardPieSectionLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 56) kind = 56; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 56) kind = 56; jjCheckNAdd(29);",
        "ins1PreCode":"else if ((0x1800000000L & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 54) kind = 54; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 54) kind = 54; jjCheckNAdd(28);",
        "ins2PreCode":"else if ((0x1800000000L & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 54) kind = 54; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 54) kind = 54; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 54) kind = 54; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 54) kind = 54; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 54) kind = 54; jjCheckNAdd(28);",
        "label":1
    },
    {
        "ins1CurCode":"Object element, String[] property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.log(Level.WARNING, \"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.log(Level.FINE, \"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener);",
        "ins1PreCode":"Object element, String[] property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener);",
        "ins2PreCode":"Object element, String property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener); }",
        "label":0
    },
    {
        "ins1CurCode":"JavaRDD<Vector> rdd2 = poissonJavaVectorRDD(sc, mean, m, n, p); JavaRDD<Vector> rdd3 = poissonJavaVectorRDD(sc, mean, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "ins1PreCode":"JavaRDD<Vector> rdd2 = poissonJavaVectorRDD(sc, mean, m, n, p); JavaRDD<Vector> rdd3 = poissonJavaVectorRDD(sc, mean, m, n, p, seed); for (JavaRDD<Vector> rdd: Lists.newArrayList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "ins2PreCode":"JavaRDD<Vector> rdd2 = exponentialJavaVectorRDD(sc, mean, m, n, p); JavaRDD<Vector> rdd3 = exponentialJavaVectorRDD(sc, mean, m, n, p, seed); for (JavaRDD<Vector> rdd: Lists.newArrayList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "label":1
    },
    {
        "ins1CurCode":"public DBSObject refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { if (metaContext == null && executionContext == null) { ",
        "ins1PreCode":"public DBSObject refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { readDatabaseInfo(monitor); ",
        "ins2PreCode":"public synchronized DBSObject refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { tableCache.clearCache(); foreignKeyCache.clearCache(); constraintCache.clearCache(); indexCache.clearCache(); packageCache.clearCache(); proceduresCache.clearCache(); triggerCache.clearCache(); dataTypeCache.clearCache(); sequenceCache.clearCache(); synonymCache.clearCache(); schedulerJobCache.clearCache(); recycleBin.clearCache(); return this;",
        "label":0
    },
    {
        "ins1CurCode":"@Test public void dropLinksAfterGC() throws Exception { RunListener.all().clear();  FreeStyleProject p = r.createFreeStyleProject();",
        "ins1PreCode":"@Test public void dropLinksAfterGC() throws Exception { FreeStyleProject p = r.createFreeStyleProject(); FreeStyleBuild b1 = r.buildAndAssertSuccess(p); FreeStyleBuild b2 = r.buildAndAssertSuccess(p);",
        "ins2PreCode":"@Test public void dropLinksAfterGC2() throws Exception { FreeStyleProject p = r.createFreeStyleProject(); FreeStyleBuild b1 = r.buildAndAssertSuccess(p); FreeStyleBuild b2 = r.buildAndAssertSuccess(p);",
        "label":1
    },
    {
        "ins1CurCode":"public void backpressureWithTimedDelay() { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.range(1, Flowable.bufferSize() * 2)",
        "ins1PreCode":"public void backpressureWithTimedDelay() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(1, Flowable.bufferSize() * 2)",
        "ins2PreCode":"public void backpressureWithSubscriptionTimedDelay() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(1, Flowable.bufferSize() * 2)",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribeActual(Observer<? super R> t) { final SerializedObserver<R> serial = new SerializedObserver<>(t); final WithLatestFromObserver<T, U, R> wlf = new WithLatestFromObserver<>(serial, combiner); ",
        "ins1PreCode":"public void subscribeActual(Observer<? super R> t) { final SerializedObserver<R> serial = new SerializedObserver<R>(t); final WithLatestFromObserver<T, U, R> wlf = new WithLatestFromObserver<T, U, R>(serial, combiner); ",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super R> s) { final SerializedSubscriber<R> serial = new SerializedSubscriber<R>(s); final WithLatestFromSubscriber<T, U, R> wlf = new WithLatestFromSubscriber<T, U, R>(serial, combiner); ",
        "label":1
    },
    {
        "ins1CurCode":"Iterator<User> iterator = cursor.iterator();  Assertions.assertFalse(cursor.isOpen());   Assertions.assertEquals(-1, cursor.getCurrentIndex());   Assertions.assertTrue(iterator.hasNext());  Assertions.assertTrue(iterator.hasNext()); Assertions.assertTrue(cursor.isOpen()); Assertions.assertFalse(cursor.isConsumed());   Assertions.assertEquals(-1, cursor.getCurrentIndex());  User user; user = iterator.next(); Assertions.assertNull(user); Assertions.assertEquals(0, cursor.getCurrentIndex());  Assertions.assertTrue(iterator.hasNext()); user = iterator.next(); Assertions.assertEquals(\"Kate\", user.getName()); Assertions.assertEquals(1, cursor.getCurrentIndex());  Assertions.assertTrue(iterator.hasNext()); user = iterator.next(); Assertions.assertNull(user); Assertions.assertEquals(2, cursor.getCurrentIndex());  Assertions.assertTrue(iterator.hasNext()); user = iterator.next(); Assertions.assertNull(user); Assertions.assertEquals(3, cursor.getCurrentIndex());   Assertions.assertFalse(iterator.hasNext()); Assertions.assertFalse(cursor.isOpen()); Assertions.assertTrue(cursor.isConsumed()); }",
        "ins1PreCode":"Iterator<User> iterator = cursor.iterator();  assertFalse(cursor.isOpen());   assertEquals(-1, cursor.getCurrentIndex());   assertTrue(iterator.hasNext());  assertTrue(iterator.hasNext()); assertTrue(cursor.isOpen()); assertFalse(cursor.isConsumed());   assertEquals(-1, cursor.getCurrentIndex());  User user; user = iterator.next(); assertNull(user); assertEquals(0, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertEquals(\"Kate\", user.getName()); assertEquals(1, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertNull(user); assertEquals(2, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertNull(user); assertEquals(3, cursor.getCurrentIndex());   assertFalse(iterator.hasNext()); assertFalse(cursor.isOpen()); assertTrue(cursor.isConsumed()); }",
        "ins2PreCode":"Iterator<User> iterator = cursor.iterator();  assertFalse(cursor.isOpen());   assertTrue(iterator.hasNext());  assertTrue(iterator.hasNext()); assertTrue(cursor.isOpen()); assertFalse(cursor.isConsumed());  User user; user = iterator.next(); assertEquals(\"Kate\", user.getName()); assertEquals(1, cursor.getCurrentIndex());  assertTrue(iterator.hasNext()); user = iterator.next(); assertNull(user); assertEquals(2, cursor.getCurrentIndex());   assertFalse(iterator.hasNext()); assertFalse(cursor.isOpen()); assertTrue(cursor.isConsumed()); }",
        "label":0
    },
    {
        "ins1CurCode":"public static void execute(Shell shell, @NotNull final DBSDataSourceContainer dataSourceContainer) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBPDataSource dataSource = dataSourceContainer.getDataSource(); if (dataSource != null) { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSource); if (txnManager != null) { DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); }",
        "ins1PreCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.commit(monitor); } catch (DBCException e) {",
        "ins2PreCode":"throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.rollback(monitor, null); } catch (DBCException e) {",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"application.addListeners(listener); application.setWebApplicationType(WebApplicationType.NONE); assertThatIllegalStateException().isThrownBy(application::run); verify(handler).registerExitCode(11);",
        "ins1PreCode":"application.addListeners(listener); application.setWebApplicationType(WebApplicationType.NONE); try { application.run(); fail(\"Did not throw\"); } catch (IllegalStateException ex) { }",
        "ins2PreCode":"application.addListeners(listener); application.setWebApplicationType(WebApplicationType.NONE); try { application.run(); fail(\"Did not throw\"); } catch (IllegalStateException ex) { }",
        "label":1
    },
    {
        "ins1CurCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\").run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context .getBean(\"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils .getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils",
        "ins1PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context.getBean( \"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils",
        "ins2PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .run(context -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils",
        "label":1
    },
    {
        "ins1CurCode":"((Profile) handle).applyProfile((Profile) profile); }  Iterator<Package> iter = ((Profile) profile).getNestedPackages().iterator(); while (iter.hasNext()) { Package p = iter.next(); if (p instanceof Profile) { applyProfile(handle, p); }",
        "ins1PreCode":"((Profile) handle).applyProfile((Profile) profile); } }",
        "ins2PreCode":"((Profile) handle).unapplyProfile((Profile) profile); } }",
        "label":1
    },
    {
        "ins1CurCode":"void convertShouldConvertElements() { Data data = new Data(); data.type = new int[] { 1, 2, 3 }; String converted = (String) new ApplicationConversionService().convert(data.type, TypeDescriptor.nested(ReflectionUtils.findField(Data.class, \"type\"), 0),",
        "ins1PreCode":"public void convertShouldConvertElements() { if (this.conversionService instanceof ApplicationConversionService) { Data data = new Data(); data.type = new int[] { 1, 2, 3 }; String converted = (String) this.conversionService.convert(data.type, TypeDescriptor.nested(ReflectionUtils.findField(Data.class, \"type\"), 0),",
        "ins2PreCode":"public void convertShouldConvertElements() { if (this.conversionService instanceof ApplicationConversionService) { Data data = new Data(); data.type = Arrays.asList(1, 2, 3); String converted = (String) this.conversionService.convert(data.type, TypeDescriptor.nested(ReflectionUtils.findField(Data.class, \"type\"), 0),",
        "label":1
    },
    {
        "ins1CurCode":"public void setLevel() { this.loggingSystem.beforeInitialize();",
        "ins1PreCode":"public void setLevel() throws Exception { this.loggingSystem.beforeInitialize();",
        "ins2PreCode":"public void setLevelToNull() throws Exception { this.loggingSystem.beforeInitialize();",
        "label":1
    },
    {
        "ins1CurCode":".clientConnector(clientConnector).build(); Mono<String> result = client.post().uri(\"/test\").contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromValue(\"Hello World\")).exchange() .flatMap((response) -> response.bodyToMono(String.class));",
        "ins1PreCode":".clientConnector(clientConnector).build(); Mono<String> result = client.post().uri(\"/test\").contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(\"Hello World\")).exchange() .flatMap((response) -> response.bodyToMono(String.class));",
        "ins2PreCode":".clientConnector(clientConnector).build(); Mono<String> result = client.post().uri(\"/test\").contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(\"Hello World\")).exchange() .flatMap((response) -> response.bodyToMono(String.class));",
        "label":1
    },
    {
        "ins1CurCode":" { Composite catPanel = UIUtils.createComposite(sash, 1); catPanel.setLayoutData(new GridData(GridData.FILL_BOTH)); catalogTable = new Table(catPanel, SWT.BORDER | SWT.CHECK); catalogTable.addListener(SWT.Selection, event -> { TableItem item = (TableItem) event.item; if (item != null) { MySQLCatalog catalog = (MySQLCatalog) item.getData(); if (event.detail == SWT.CHECK) { catalogTable.select(catalogTable.indexOf(item)); checkedObjects.remove(catalog); } loadTables(catalog); updateState(); } }); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; catalogTable.setLayoutData(gd);  Composite buttonsPanel = UIUtils.createComposite(catPanel, 3); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); new Label(buttonsPanel, SWT.NONE).setLayoutData(new GridData(GridData.GRAB_HORIZONTAL)); createCheckButtons(buttonsPanel, catalogTable); }  final Button exportViewsCheck; { Composite tablesPanel = UIUtils.createComposite(sash, 1); tablesPanel.setLayoutData(new GridData(GridData.FILL_BOTH));  tablesTable = new Table(tablesPanel, SWT.BORDER | SWT.CHECK); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; tablesTable.setLayoutData(gd); tablesTable.addListener(SWT.Selection, event -> { if (event.detail == SWT.CHECK) { updateCheckedTables(); updateState(); } }); Composite buttonsPanel = UIUtils.createComposite(tablesPanel, 3); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));",
        "ins1PreCode":" { Composite catPanel = UIUtils.createPlaceholder(sash, 1); catPanel.setLayoutData(new GridData(GridData.FILL_BOTH)); catalogTable = new Table(catPanel, SWT.BORDER | SWT.CHECK); catalogTable.addListener(SWT.Selection, new Listener() { public void handleEvent(Event event) { TableItem item = (TableItem) event.item; if (item != null) { MySQLCatalog catalog = (MySQLCatalog) item.getData(); if (event.detail == SWT.CHECK) { catalogTable.select(catalogTable.indexOf(item)); checkedObjects.remove(catalog); } loadTables(catalog); updateState(); } } }); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; catalogTable.setLayoutData(gd);  Composite buttonsPanel = UIUtils.createPlaceholder(catPanel, 3, 5); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); new Label(buttonsPanel, SWT.NONE).setLayoutData(new GridData(GridData.GRAB_HORIZONTAL)); createCheckButtons(buttonsPanel, catalogTable); }  final Button exportViewsCheck; { Composite tablesPanel = UIUtils.createPlaceholder(sash, 1); tablesPanel.setLayoutData(new GridData(GridData.FILL_BOTH));  tablesTable = new Table(tablesPanel, SWT.BORDER | SWT.CHECK); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; tablesTable.setLayoutData(gd); tablesTable.addListener(SWT.Selection, new Listener() { public void handleEvent(Event event) { if (event.detail == SWT.CHECK) { updateCheckedTables(); updateState(); } } }); Composite buttonsPanel = UIUtils.createPlaceholder(tablesPanel, 3, 5); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));",
        "ins2PreCode":" { Composite catPanel = UIUtils.createPlaceholder(sash, 1); catPanel.setLayoutData(new GridData(GridData.FILL_BOTH)); schemasTable = new Table(catPanel, SWT.BORDER | SWT.CHECK); schemasTable.addListener(SWT.Selection, event -> { TableItem item = (TableItem) event.item; PostgreSchema catalog = (PostgreSchema) item.getData(); if (event.detail == SWT.CHECK) { schemasTable.select(schemasTable.indexOf(item)); checkedObjects.remove(catalog); } loadTables(catalog); updateState(); }); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; schemasTable.setLayoutData(gd);  Composite buttonsPanel = UIUtils.createPlaceholder(catPanel, 3, 5); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); new Label(buttonsPanel, SWT.NONE).setLayoutData(new GridData(GridData.GRAB_HORIZONTAL)); createCheckButtons(buttonsPanel, schemasTable); }  final Button exportViewsCheck; { Composite tablesPanel = UIUtils.createPlaceholder(sash, 1); tablesPanel.setLayoutData(new GridData(GridData.FILL_BOTH));  tablesTable = new Table(tablesPanel, SWT.BORDER | SWT.CHECK); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; tablesTable.setLayoutData(gd); tablesTable.addListener(SWT.Selection, event -> { if (event.detail == SWT.CHECK) { updateCheckedTables(); updateState(); } });  Composite buttonsPanel = UIUtils.createPlaceholder(tablesPanel, 3, 5); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));",
        "label":0
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); ",
        "ins2PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false); ",
        "label":0
    },
    {
        "ins1CurCode":"StandardCategorySeriesLabelGenerator g1 = new StandardCategorySeriesLabelGenerator(\"{1}\"); StandardCategorySeriesLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"StandardCategorySeriesLabelGenerator g1 = new StandardCategorySeriesLabelGenerator(\"{1}\"); StandardCategorySeriesLabelGenerator g2 = (StandardCategorySeriesLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"StandardCategoryItemLabelGenerator g1 = new StandardCategoryItemLabelGenerator(); StandardCategoryItemLabelGenerator g2 = (StandardCategoryItemLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "label":1
    },
    {
        "ins1CurCode":"public void operationWithSecurityInterceptorForbidden() { given(securityService.getAccessLevel(any(), eq(\"app-id\")))",
        "ins1PreCode":"public void operationWithSecurityInterceptorForbidden() throws Exception { given(securityService.getAccessLevel(any(), eq(\"app-id\")))",
        "ins2PreCode":"public void operationWithSecurityInterceptorSuccess() throws Exception { given(securityService.getAccessLevel(any(), eq(\"app-id\")))",
        "label":1
    },
    {
        "ins1CurCode":"public void getAccessLevelWhenTokenIsNotValidShouldThrowException() throws Exception { prepareResponse((response) -> response.setResponseCode(401)); StepVerifier.create( this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeErrorWith((throwable) -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.INVALID_TOKEN); }).verify(); expectRequest((request) -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION))",
        "ins1PreCode":"public void getAccessLevelWhenTokenIsNotValidShouldThrowException() throws Exception { prepareResponse(response -> response.setResponseCode(401)); StepVerifier.create( this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeErrorWith(throwable -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.INVALID_TOKEN); }).verify(); expectRequest(request -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION))",
        "ins2PreCode":"public void getAccessLevelWhenForbiddenShouldThrowException() throws Exception { prepareResponse(response -> response.setResponseCode(403)); StepVerifier.create( this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeErrorWith(throwable -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.ACCESS_DENIED); }).verify(); expectRequest(request -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION))",
        "label":1
    },
    {
        "ins1CurCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins2PreCode":"public void testBug54011() throws Exception { ByteChunk res = new ByteChunk();  int rc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug5nnnn/bug54012.jsp\", res, null);  Assert.assertEquals(HttpServletResponse.SC_OK, rc);  String body = res.toString(); Assert.assertTrue(body.contains(\"OK\"));",
        "label":0
    },
    {
        "ins1CurCode":"private SqlSessionFactory getSqlSessionFactoryXmlConfig(String resource) throws Exception { try (Reader configReader = Resources.getResourceAsReader(resource)) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader);",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryXmlConfig(String resource) throws Exception { Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close(); ",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryXmlConfig(String resource) throws Exception { Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException { ParserResult result = parser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor);  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\")); assertTrue(result.hasWarnings());",
        "ins1PreCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException {  ParserResult result = BibtexParser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor);  assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":".parse(new StringReader(\"@article{test,author=\\\"Test {\\\" Test}\\\"}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1CurCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = CloneUtils.clone(d1); assertTrue(d1 != d2);",
        "ins1PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) d1.clone(); assertTrue(d1 != d2);",
        "ins2PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":0
    },
    {
        "ins1CurCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(monitor, owner, command, options); final GenericTableColumn column = command.getObject();",
        "ins1PreCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(owner, command, options); final GenericTableColumn column = command.getObject();",
        "ins2PreCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(owner, command, options); final GenericTableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1CurCode":" if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.getPainlessStructFromJavaClass(iface);  if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) {",
        "ins1PreCode":" if (struct != null) { MethodHandle handle = struct.getters.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.getPainlessStructFromJavaClass(iface);  if (struct != null) { MethodHandle handle = struct.getters.get(name); if (handle != null) {",
        "ins2PreCode":" if (struct != null) { MethodHandle handle = struct.setters.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.getPainlessStructFromJavaClass(iface);  if (struct != null) { MethodHandle handle = struct.setters.get(name); if (handle != null) {",
        "label":1
    },
    {
        "ins1CurCode":"public void visitConditional(EConditional userConditionalNode, ScriptScope scriptScope) { ConditionalNode irConditionalNode = new ConditionalNode(userConditionalNode.getLocation()); irConditionalNode.attachDecoration( new IRDExpressionType(scriptScope.getDecoration(userConditionalNode, ValueType.class).getValueType())); irConditionalNode.setConditionNode(injectCast(userConditionalNode.getConditionNode(), scriptScope));",
        "ins1PreCode":"public void visitConditional(EConditional userConditionalNode, ScriptScope scriptScope) { ConditionalNode irConditionalNode = new ConditionalNode(userConditionalNode.getLocation()); irConditionalNode.setExpressionType(scriptScope.getDecoration(userConditionalNode, ValueType.class).getValueType()); irConditionalNode.setConditionNode(injectCast(userConditionalNode.getConditionNode(), scriptScope));",
        "ins2PreCode":"public void visitElvis(EElvis userElvisNode, ScriptScope scriptScope) { ElvisNode irElvisNode = new ElvisNode(userElvisNode.getLocation()); irElvisNode.setExpressionType(scriptScope.getDecoration(userElvisNode, ValueType.class).getValueType()); irElvisNode.setLeftNode(injectCast(userElvisNode.getLeftNode(), scriptScope));",
        "label":1
    },
    {
        "ins1CurCode":"throws DBException { try (JDBCSession session = DBUtils.openMetaSession(monitor, view, \"Load view source code\")) { DatabaseMetaData fbMetaData = session.getOriginal().getMetaData();",
        "ins1PreCode":"throws DBException { try (JDBCSession session = DBUtils.openMetaSession(monitor, view.getDataSource(), \"Load view source code\")) { DatabaseMetaData fbMetaData = session.getOriginal().getMetaData();",
        "ins2PreCode":"throws DBException { try (JDBCSession session = DBUtils.openMetaSession(monitor, trigger.getDataSource(), \"Load trigger source code\")) { DatabaseMetaData fbMetaData = session.getOriginal().getMetaData();",
        "label":1
    },
    {
        "ins1CurCode":"public void appendOnlyLinkedArrayListForEachWhileAll() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<>(2);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<>(); ",
        "ins1PreCode":"public void appendOnlyLinkedArrayListForEachWhileAll() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void appendOnlyLinkedArrayListForEachWhileBigger() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(4);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"for (int i = 0; i < 50; i++) { final AsyncSubject<String> subject = AsyncSubject.create(); final AtomicReference<String> value1 = new AtomicReference<>(); ",
        "ins1PreCode":"for (int i = 0; i < 50; i++) { final AsyncSubject<String> subject = AsyncSubject.create(); final AtomicReference<String> value1 = new AtomicReference<String>(); ",
        "ins2PreCode":"for (int i = 0; i < 50; i++) { final ReplaySubject<String> subject = ReplaySubject.create(); final AtomicReference<String> value1 = new AtomicReference<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void shouldAssignKeyToBean() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldAssignKeyToBean() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldAssignKeyToNamedBean() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"return; } Boolean isColor = (c instanceof Color); if (isColor) { target.setFillColor((Color) c); } target.setFilled(isColor); target.endTrans();     ArgoDiagram activeDiagram = DiagramUtils.getActiveDiagram(); for (Object t : TargetManager.getInstance().getTargets()) { Fig fig = null; if (t instanceof FigNodeModelElement) { fig = (Fig) t; } else { fig = activeDiagram.presentationFor(t); } if (fig != null && fig != target) { if (isColor) { fig.setFillColor((Color) c); } fig.setFilled(isColor); fig.endTrans(); }",
        "ins1PreCode":"return; } if (c instanceof Color) { target.setFillColor((Color) c); } target.setFilled(c instanceof Color); target.endTrans();",
        "ins2PreCode":"return; } if (c instanceof Color) { target.setLineColor((Color) c); } target.setLineWidth((c instanceof Color) ? ArgoFig.LINE_WIDTH : 0); target.endTrans();",
        "label":1
    },
    {
        "ins1CurCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = jsc.parallelize(testData._1()); ",
        "ins1PreCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = sc.parallelize(testData._1()); ",
        "ins2PreCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, true);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features)",
        "label":1
    },
    {
        "ins1CurCode":"this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON)) .bodyValue(Collections.singletonMap(\"configuredLevel\", null)).exchange().expectStatus().isNoContent(); verify(this.loggingSystem).setLogLevel(\"test.member1\", null);",
        "ins1PreCode":"this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON)) .body(Collections.singletonMap(\"configuredLevel\", null)).exchange().expectStatus().isNoContent(); verify(this.loggingSystem).setLogLevel(\"test.member1\", null);",
        "ins2PreCode":"void setLoggerGroupWithNoLogLevel() { this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON)).body(Collections.emptyMap()) .exchange().expectStatus().isNoContent();",
        "label":1
    },
    {
        "ins1CurCode":"void testCallWithResultSet3_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testCallWithResultSet3_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testCallWithResultSet4_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"LengthAdjustmentType.CONTRACT, labelOffsetType); } return anchor.getAnchorPoint(anchorRect); ",
        "ins1PreCode":"LengthAdjustmentType.CONTRACT, labelOffsetType); } return RectangleAnchor.coordinates(anchorRect, anchor); ",
        "ins2PreCode":"LengthAdjustmentType.CONTRACT, labelOffsetForRange); } return RectangleAnchor.coordinates(anchorRect, anchor); ",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"void getEndpointsShouldIncludeServletEndpoints() { this.contextRunner.withUserConfiguration(TestServletEndpoint.class).run(assertDiscoverer((discoverer) -> {",
        "ins1PreCode":"public void getEndpointsShouldIncludeServletEndpoints() { this.contextRunner.withUserConfiguration(TestServletEndpoint.class).run(assertDiscoverer((discoverer) -> {",
        "ins2PreCode":"public void getEndpointsShouldDiscoverProxyServletEndpoints() { this.contextRunner.withUserConfiguration(TestProxyServletEndpoint.class)",
        "label":1
    },
    {
        "ins1CurCode":"} else { if (q == null) { q = new SpscArrayQueue<>(bufferSize); inner.queue = q;",
        "ins1PreCode":"} else { if (q == null) { q = getInnerQueue(inner); }",
        "ins2PreCode":"requested.decrementAndGet(); } if (maxConcurrency != Integer.MAX_VALUE && !cancelled && ++scalarEmitted == scalarLimit) { scalarEmitted = 0; upstream.request(scalarLimit); } } else { if (q == null) { q = getMainQueue(); } if (!q.offer(value)) { onError(new IllegalStateException(\"Scalar queue full?!\")); return; } } if (decrementAndGet() == 0) { return; } } else { SimpleQueue<U> q = getMainQueue(); if (!q.offer(value)) { onError(new IllegalStateException(\"Scalar queue full?!\")); return;",
        "label":0
    },
    {
        "ins1CurCode":"  assertThat( projects, hasItem( pluginProject ) ); assertThat( projects, hasItem( pluginLevelDepProject ) ); ",
        "ins1PreCode":"  assertTrue( projects.contains( pluginProject ) ); assertTrue( projects.contains( pluginLevelDepProject ) ); ",
        "ins2PreCode":"projects = new ProjectSorter( projects ).getSortedProjects();  System.out.println( projects );  assertEquals( parentProject, projects.get( 0 ) );   assertTrue( projects.contains( pluginProject ) ); assertTrue( projects.contains( pluginLevelDepProject ) );",
        "label":1
    },
    {
        "ins1CurCode":" if (errorOccurred) { throw new AbortException(CLI_LISTPARAM_SUMMARY_ERROR_TEXT); }",
        "ins1PreCode":" if (errorOccurred) { throw new AbortException(\"Error occured while performing this command, see previous stderr output.\"); }",
        "ins2PreCode":" if (errorOccurred) { throw new AbortException(\"Error occured while performing this command, see previous stderr output.\"); }",
        "label":1
    },
    {
        "ins1CurCode":"factory.clearCache(); MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isNotSameAs(metadataReader2); verify(factory, times(2)).createMetadataReader(any(Resource.class));",
        "ins1PreCode":"factory.clearCache(); MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isNotEqualTo(sameInstance(metadataReader2)); verify(factory, times(2)).createMetadataReader(any(Resource.class));",
        "ins2PreCode":"void getMetadataReaderUsesCache() throws Exception { TestConcurrentReferenceCachingMetadataReaderFactory factory = spy( new TestConcurrentReferenceCachingMetadataReaderFactory()); MetadataReader metadataReader1 = factory.getMetadataReader(getClass().getName()); MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isSameAs(metadataReader2); verify(factory, times(1)).createMetadataReader(any(Resource.class));",
        "label":0
    },
    {
        "ins1CurCode":"return oname.toString(); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException(sm.getString(\"userMBean.createError.group\", groupname)); iae.initCause(e);",
        "ins1PreCode":"return oname.toString(); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException( \"Cannot create object name for group [\" + groupname + \"]\"); iae.initCause(e);",
        "ins2PreCode":"database.removeGroup(group); } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException( \"Exception destroying group [\" + groupname + \"] MBean\"); iae.initCause(e);",
        "label":0
    },
    {
        "ins1CurCode":"if ( build.getFilters() != null ) { List<String> filters = new ArrayList<>(); for ( String filter : build.getFilters() )",
        "ins1PreCode":"if ( build.getFilters() != null ) { List<String> filters = new ArrayList<String>(); for ( String filter : build.getFilters() )",
        "ins2PreCode":"if ( build.getFilters() != null ) { List<String> filters = new ArrayList<String>(); for ( String filter : build.getFilters() )",
        "label":1
    },
    {
        "ins1CurCode":"builder.clearField(f(\"int32_to_message_field\")); message = builder.build(); assertEquals(0, message.getInt32ToInt32FieldMap().size()); assertEquals(0, message.getInt32ToMessageFieldMap().size());   setMapValues(builder, \"int32_to_int32_field\", mapForValues(11, 22, 33, 44)); setMapValues( builder, \"int32_to_message_field\", mapForValues( 111, MessageValue.newBuilder().setValue(222).build(), 333, MessageValue.newBuilder().setValue(444).build())); message = builder.build(); assertEquals(22, message.getInt32ToInt32FieldMap().get(11).intValue()); assertEquals(44, message.getInt32ToInt32FieldMap().get(33).intValue()); assertEquals(222, message.getInt32ToMessageFieldMap().get(111).getValue()); assertEquals(444, message.getInt32ToMessageFieldMap().get(333).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 66)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(666).build())); message = builder.build(); assertEquals(66, message.getInt32ToInt32FieldMap().get(55).intValue()); assertEquals(666, message.getInt32ToMessageFieldMap().get(555).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 55)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(555).build())); message = builder.build(); assertEquals(55, message.getInt32ToInt32FieldMap().get(55).intValue()); assertEquals(555, message.getInt32ToMessageFieldMap().get(555).getValue());   for (int i = 0; i < builder.getRepeatedFieldCount(f(\"int32_to_int32_field\")); i++) { Message mapEntry = (Message) builder.getRepeatedField(f(\"int32_to_int32_field\"), i); int oldKey = ((Integer) getFieldValue(mapEntry, \"key\")).intValue(); int oldValue = ((Integer) getFieldValue(mapEntry, \"value\")).intValue();  Message.Builder mapEntryBuilder = mapEntry.toBuilder(); setFieldValue(mapEntryBuilder, \"key\", oldValue); setFieldValue(mapEntryBuilder, \"value\", oldKey); builder.setRepeatedField(f(\"int32_to_int32_field\"), i, mapEntryBuilder.build()); } message = builder.build(); assertEquals(11, message.getInt32ToInt32FieldMap().get(22).intValue()); assertEquals(33, message.getInt32ToInt32FieldMap().get(44).intValue()); assertEquals(55, message.getInt32ToInt32FieldMap().get(55).intValue());",
        "ins1PreCode":"builder.clearField(f(\"int32_to_message_field\")); message = builder.build(); assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToMessageField().size());   setMapValues(builder, \"int32_to_int32_field\", mapForValues(11, 22, 33, 44)); setMapValues( builder, \"int32_to_message_field\", mapForValues( 111, MessageValue.newBuilder().setValue(222).build(), 333, MessageValue.newBuilder().setValue(444).build())); message = builder.build(); assertEquals(22, message.getInt32ToInt32Field().get(11).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(33).intValue()); assertEquals(222, message.getInt32ToMessageField().get(111).getValue()); assertEquals(444, message.getInt32ToMessageField().get(333).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 66)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(666).build())); message = builder.build(); assertEquals(66, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(666, message.getInt32ToMessageField().get(555).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 55)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(555).build())); message = builder.build(); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(555, message.getInt32ToMessageField().get(555).getValue());   for (int i = 0; i < builder.getRepeatedFieldCount(f(\"int32_to_int32_field\")); i++) { Message mapEntry = (Message) builder.getRepeatedField(f(\"int32_to_int32_field\"), i); int oldKey = ((Integer) getFieldValue(mapEntry, \"key\")).intValue(); int oldValue = ((Integer) getFieldValue(mapEntry, \"value\")).intValue();  Message.Builder mapEntryBuilder = mapEntry.toBuilder(); setFieldValue(mapEntryBuilder, \"key\", oldValue); setFieldValue(mapEntryBuilder, \"value\", oldKey); builder.setRepeatedField(f(\"int32_to_int32_field\"), i, mapEntryBuilder.build()); } message = builder.build(); assertEquals(11, message.getInt32ToInt32Field().get(22).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(44).intValue()); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue());",
        "ins2PreCode":"builder.clearField(f(\"int32_to_message_field\")); message = builder.build(); assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToMessageField().size());   setMapValues(builder, \"int32_to_int32_field\", mapForValues(11, 22, 33, 44)); setMapValues( builder, \"int32_to_message_field\", mapForValues( 111, MessageValue.newBuilder().setValue(222).build(), 333, MessageValue.newBuilder().setValue(444).build())); message = builder.build(); assertEquals(22, message.getInt32ToInt32Field().get(11).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(33).intValue()); assertEquals(222, message.getInt32ToMessageField().get(111).getValue()); assertEquals(444, message.getInt32ToMessageField().get(333).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 66)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(666).build())); message = builder.build(); assertEquals(66, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(666, message.getInt32ToMessageField().get(555).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 55)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(555).build())); message = builder.build(); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(555, message.getInt32ToMessageField().get(555).getValue());   for (int i = 0; i < builder.getRepeatedFieldCount(f(\"int32_to_int32_field\")); i++) { Message mapEntry = (Message) builder.getRepeatedField(f(\"int32_to_int32_field\"), i); int oldKey = ((Integer) getFieldValue(mapEntry, \"key\")).intValue(); int oldValue = ((Integer) getFieldValue(mapEntry, \"value\")).intValue();  Message.Builder mapEntryBuilder = mapEntry.toBuilder(); setFieldValue(mapEntryBuilder, \"key\", oldValue); setFieldValue(mapEntryBuilder, \"value\", oldKey); builder.setRepeatedField(f(\"int32_to_int32_field\"), i, mapEntryBuilder.build()); } message = builder.build(); assertEquals(11, message.getInt32ToInt32Field().get(22).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(44).intValue()); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue());",
        "label":1
    },
    {
        "ins1CurCode":"public void testFileResourcePlain() { buildRule.executeTarget(\"testFileResourcePlain\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists());",
        "ins1PreCode":"public void testFileResourcePlain() { executeTarget(\"testFileResourcePlain\"); File file1 = new File(getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists());",
        "ins2PreCode":"public void testPathAsResource() { executeTarget(\"testPathAsResource\"); File file1 = new File(getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists());",
        "label":1
    },
    {
        "ins1CurCode":"return; } for (FTPFile file : newfiles) { if (file != null && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file)); if (isFunctioningAsDirectory(ftp, dir, file)) { boolean slowScanAllowed = true; if (!isFollowSymlinks() && file.isSymbolicLink()) { dirsExcluded.addElement(name); slowScanAllowed = false; } else if (isIncluded(name)) { accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath), fast); } else {",
        "ins1PreCode":"return; } for (int i = 0; i < newfiles.length; i++) { FTPFile file = newfiles[i]; if (file != null && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file)); if (isFunctioningAsDirectory(ftp, dir, file)) { boolean slowScanAllowed = true; if (!isFollowSymlinks() && file.isSymbolicLink()) { dirsExcluded.addElement(name); slowScanAllowed = false; } else if (isIncluded(name)) { accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath) , fast); } else {",
        "ins2PreCode":"return; } for (int i = 0; i < newfiles.length; i++) { FTPFile file = newfiles[i]; if (file != null && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file)); if (isFunctioningAsDirectory(ftp, dir, file)) { boolean slowScanAllowed = true; if (!isFollowSymlinks() && file.isSymbolicLink()) { dirsExcluded.addElement(name); slowScanAllowed = false; } else if (isIncluded(name)) { accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath) , fast); } else {",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); TestUtils.checkIndependence(r1, r2);",
        "ins1PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StatisticalLineAndShapeRenderer r1 = new StatisticalLineAndShapeRenderer(); StatisticalLineAndShapeRenderer r2 = CloneUtils.clone(r1);",
        "label":1
    },
    {
        "ins1CurCode":"public Unit() { calendarFields.put(MILLISECOND, Integer.valueOf(Calendar.MILLISECOND)); calendarFields.put(SECOND, Integer.valueOf(Calendar.SECOND)); calendarFields.put(MINUTE, Integer.valueOf(Calendar.MINUTE)); calendarFields.put(HOUR, Integer.valueOf(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, Integer.valueOf(Calendar.DATE)); calendarFields.put(WEEK, Integer.valueOf(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, Integer.valueOf(Calendar.MONTH)); calendarFields.put(YEAR, Integer.valueOf(Calendar.YEAR));",
        "ins1PreCode":"public Unit() { calendarFields.put(MILLISECOND, new Integer(Calendar.MILLISECOND)); calendarFields.put(SECOND, new Integer(Calendar.SECOND)); calendarFields.put(MINUTE, new Integer(Calendar.MINUTE)); calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, new Integer(Calendar.DATE)); calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, new Integer(Calendar.MONTH)); calendarFields.put(YEAR, new Integer(Calendar.YEAR));",
        "ins2PreCode":"public Unit() { calendarFields.put(MILLISECOND, new Integer(Calendar.MILLISECOND)); calendarFields.put(SECOND, new Integer(Calendar.SECOND)); calendarFields.put(MINUTE, new Integer(Calendar.MINUTE)); calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, new Integer(Calendar.DATE)); calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, new Integer(Calendar.MONTH)); calendarFields.put(YEAR, new Integer(Calendar.YEAR));",
        "label":1
    },
    {
        "ins1CurCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assertions.assertNotNull(person, \"Persons must not be null\"); Person parent = person.getParent(); Assertions.assertNull(parent, \"Parent must be null\"); }",
        "ins1PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person parent = person.getParent(); Assert.assertNull(\"Parent must be null\", parent); }",
        "ins2PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person parent = person.getParent(); Assert.assertNull(\"Parent must be null\", parent); }",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"  return ByteString.copyFrom(result); }  final int originalBufferPos = pos; final int bufferedBytes = bufferSize - pos;   totalBytesRetired += bufferSize; pos = 0; bufferSize = 0;   int sizeLeft = size - bufferedBytes;    List<byte[]> chunks = readRawBytesSlowPathRemainingChunks(sizeLeft);   final byte[] bytes = new byte[size];   System.arraycopy(buffer, originalBufferPos, bytes, 0, bufferedBytes);   int tempPos = bufferedBytes; for (final byte[] chunk : chunks) { System.arraycopy(chunk, 0, bytes, tempPos, chunk.length); tempPos += chunk.length; }  return ByteString.wrap(bytes);",
        "ins1PreCode":"final byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return ByteString.wrap(result); }  final int originalBufferPos = pos; final int bufferedBytes = bufferSize - pos;   totalBytesRetired += bufferSize; pos = 0; bufferSize = 0;   int sizeLeft = size - bufferedBytes;    List<byte[]> chunks = readRawBytesSlowPathRemainingChunks(sizeLeft);   List<ByteString> byteStrings = new ArrayList<ByteString>(1 + chunks.size()); byteStrings.add(ByteString.copyFrom(buffer, originalBufferPos, bufferedBytes)); for (byte[] chunk : chunks) { byteStrings.add(ByteString.wrap(chunk)); } return ByteString.copyFrom(byteStrings);",
        "ins2PreCode":"private byte[] readRawBytesSlowPath(final int size) throws IOException {  byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return result; }",
        "label":0
    },
    {
        "ins1CurCode":"if (monitor != null) { monitor.beginTask(\"Load action for '\" + this.getName() + \"'...\", 1); try (final JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Load action for \" + OracleObjectType.JOB + \" '\" + this.getName() + \"'\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement(",
        "ins1PreCode":"if (monitor != null) { monitor.beginTask(\"Load action for '\" + this.getName() + \"'...\", 1); try (final JDBCSession session = DBUtils.openMetaSession(monitor, this.getDataSource(), \"Load action for \" + OracleObjectType.JOB + \" '\" + this.getName() + \"'\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement(",
        "ins2PreCode":"if (jobAction == null && monitor != null) { monitor.beginTask(\"Load action for '\" + this.getName() + \"'...\", 1); try (final JDBCSession session = DBUtils.openMetaSession(monitor, this.getDataSource(), \"Load action for \" + OracleObjectType.JOB + \" '\" + this.getName() + \"'\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement(",
        "label":1
    },
    {
        "ins1CurCode":"value instanceof Long    || value instanceof Float   || value instanceof Double ) {",
        "ins1PreCode":"value instanceof Long    || value instanceof Float   || value instanceof Double  || value instanceof BigInteger ) {",
        "ins2PreCode":"public static Float defToFloatExplicit(final Object value) { if (value == null) { return null; } else if (value instanceof Character) { return (float)(char)value; } else if ( value instanceof Byte    || value instanceof Short   || value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double ) { return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Float.class.getCanonicalName()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void removeNode_queryAfterRemoval() { assume().that(graphIsMutable()).isTrue();  addNode(N1); @SuppressWarnings(\"unused\") Set<Integer> unused = graph.adjacentNodes(N1); assertThat(graphAsMutableGraph.removeNode(N1)).isTrue(); try {",
        "ins1PreCode":"@SuppressWarnings(\"unused\") Set<Integer> unused = graph.adjacentNodes(N1); assertThat(graph.removeNode(N1)).isTrue(); try {",
        "ins2PreCode":"@SuppressWarnings(\"unused\") Set<Integer> unused = graph.adjacentNodes(N1); assertThat(graph.removeNode(N1)).isTrue(); try {",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> merge( @NonNull SingleSource<? extends T> source1, @NonNull SingleSource<? extends T> source2, @NonNull SingleSource<? extends T> source3, @NonNull SingleSource<? extends T> source4 ) {",
        "ins1PreCode":"public static <T> Flowable<T> merge( SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) {",
        "ins2PreCode":"public static <T> Flowable<T> mergeDelayError( SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) {",
        "label":1
    },
    {
        "ins1CurCode":"public void take() { TestSubscriber<Integer> ts = new TestSubscriber<>();  FlowableCache<Integer> cached = new FlowableCache<>(Flowable.range(1, 100), 16); cached.take(10).subscribe(ts);",
        "ins1PreCode":"public void take() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  FlowableCache<Integer> cached = new FlowableCache<Integer>(Flowable.range(1, 100), 16); cached.take(10).subscribe(ts);",
        "ins2PreCode":"public void take() { TestObserver<Integer> to = new TestObserver<Integer>();  ObservableCache<Integer> cached = new ObservableCache<Integer>(Observable.range(1, 1000), 16); cached.take(10).subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\");",
        "ins1PreCode":"public static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\");",
        "ins2PreCode":"public static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "ins1PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "ins2PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "label":0
    },
    {
        "ins1CurCode":"public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\");",
        "ins1PreCode":"public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\");",
        "ins2PreCode":"public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean tillTheEnd, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\");",
        "label":1
    },
    {
        "ins1CurCode":"public Regexp newRegexp(Project p) throws BuildException { String systemDefault; if (p == null) {",
        "ins1PreCode":"public Regexp newRegexp(Project p) throws BuildException { String systemDefault = null; if (p == null) {",
        "ins2PreCode":"public RegexpMatcher newRegexpMatcher(Project p) throws BuildException { String systemDefault = null; if (p == null) {",
        "label":1
    },
    {
        "ins1CurCode":"HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); String localUrl = getLocalUrl(\"https\", \"/test.txt\"); assertThatIOException().isThrownBy(() -> getResponse(localUrl, requestFactory));",
        "ins1PreCode":"HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory);",
        "ins2PreCode":"protected final void testBasicSslWithKeyStore(String keyStore) throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(null, \"password\", keyStore)); this.webServer = factory.getWebServer(); this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory) .build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); assertThat(getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory)) .isEqualTo(\"test\");",
        "label":0
    },
    {
        "ins1CurCode":"public void assertNotMatchValue() { assertThrows(AssertionError.class, () -> { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts);  ts.assertValues(1, 3); ts.assertValueCount(2); ts.assertTerminated(); });",
        "ins1PreCode":"oi.subscribe(ts);  thrown.expect(AssertionError.class); ",
        "ins2PreCode":"public void assertNeverAtNotMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts);  ts.assertNever(3); ts.assertValueCount(2); ts.assertTerminated();",
        "label":0
    },
    {
        "ins1CurCode":"void bindToMapNonScalarCollectionShouldPopulateMap() { Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class);",
        "ins1PreCode":"public void bindToMapNonScalarCollectionShouldPopulateMap() { Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class);",
        "ins2PreCode":"public void bindToMapNonScalarCollectionWithDotKeysShouldBind() { Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class);",
        "label":1
    },
    {
        "ins1CurCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin( Publisher<? extends TRight> other, Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins2PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> groupJoin( ObservableSource<? extends TRight> other, Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd, Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd, BiFunction<? super T, ? super Observable<TRight>, ? extends R> resultSelector ) {",
        "label":1
    },
    {
        "ins1CurCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; }",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders();",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; } ListSet offs = i.getOffenders(); UMLDeploymentDiagram dd = (UMLDeploymentDiagram) offs.get(0);  ListSet newOffs = computeOffenders(dd); boolean res = offs.equals(newOffs); return res;",
        "label":0
    },
    {
        "ins1CurCode":"private boolean compareFiles(File file1, File file2) { try { if (!file1.exists() || !file2.exists()) { System.out.println(\"One or both files do not exist:\" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile()); return false; }  if (file1.length() != file2.length()) { System.out.println(\"File size mismatch:\" + file1.getAbsoluteFile() + \"(\" + file1.length() + \"), \" + file2.getAbsoluteFile()  + \"(\" + file2.length() + \")\"); return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { System.out.println(\"Bytes mismatch:\" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile() + \" at byte \" + index); return false; } } } return true; } catch (IOException e) { System.out.println(\"IOException comparing files: \" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile()); return false;",
        "ins1PreCode":"private boolean compareFiles(String name1, String name2) { File file1 = new File(System.getProperty(\"root\"), name1); File file2 = new File(System.getProperty(\"root\"), name2);  try { if (!file1.exists() || !file2.exists()) { System.out.println(\"One or both files do not exist:\" + name1 + \", \" + name2); return false; }  if (file1.length() != file2.length()) { System.out.println(\"File size mismatch:\" + name1 + \"(\" + file1.length() + \"), \" + name2  + \"(\" + file2.length() + \")\"); return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { System.out.println(\"Bytes mismatch:\" + name1 + \", \" + name2 + \" at byte \" + index); return false; } } } return true; } catch (IOException e) { System.out.println(\"IOException comparing files: \" + name1 + \", \" + name2); return false;",
        "ins2PreCode":"private boolean compareFiles(String name1, String name2) { File file1 = new File(System.getProperty(\"root\"), name1); File file2 = new File(System.getProperty(\"root\"), name2);  try { if (!file1.exists() || !file2.exists()) { System.out.println(\"One or both files do not exist:\" + name1 + \", \" + name2); return false; }  if (file1.length() != file2.length()) { System.out.println(\"File size mismatch:\" + name1 + \"(\" + file1.length() + \"), \" + name2  + \"(\" + file2.length() + \")\"); return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { System.out.println(\"Bytes mismatch:\" + name1 + \", \" + name2 + \" at byte \" + index); return false; } } } return true; } catch (IOException e) { System.out.println(\"IOException comparing files: \" + name1 + \", \" + name2); return false; }",
        "label":0
    },
    {
        "ins1CurCode":"byte[] buffer2 = new byte[BUF_SIZE];  try (FileInputStream fis1 = new FileInputStream(file1)) { try (FileInputStream fis2 = new FileInputStream(file2)) { int read = 0;",
        "ins1PreCode":"byte[] buffer2 = new byte[BUF_SIZE];  @SuppressWarnings(\"resource\") FileInputStream fis1 = new FileInputStream(file1); try { @SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); try { int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } } finally { fis2.close(); } } finally { fis1.close(); }",
        "ins2PreCode":"private boolean compareFiles(String name1, String name2) throws IOException { File file1 = new File(System.getProperty(\"root\"), name1); File file2 = new File(System.getProperty(\"root\"), name2);   if (!file1.exists() || !file2.exists()) { return false; }  if (file1.length() != file2.length()) { return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  @SuppressWarnings(\"resource\") FileInputStream fis1 = new FileInputStream(file1); @SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } return true; ",
        "label":0
    },
    {
        "ins1CurCode":"void parseCombinesMultipleAuthorFields() throws IOException { ParserResult result = parser.parse(",
        "ins1PreCode":"public void parseCombinesMultipleAuthorFields() throws IOException { ParserResult result = parser.parse(",
        "ins2PreCode":"public void parseCombinesMultipleEditorFields() throws IOException { ParserResult result = parser.parse(",
        "label":1
    },
    {
        "ins1CurCode":"ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, WebClient.Builder webClientBuilder, ControllerEndpointsSupplier controllerEndpointsSupplier, ApplicationContext applicationContext) { CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( applicationContext, parameterMapper, endpointMediaTypes, null, Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( webClientBuilder, applicationContext.getEnvironment()); Collection<ExposableWebEndpoint> webEndpoints = endpointDiscoverer.getEndpoints();",
        "ins1PreCode":"ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, WebClient.Builder webClientBuilder, ControllerEndpointsSupplier controllerEndpointsSupplier) { CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, null, Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( webClientBuilder, this.applicationContext.getEnvironment()); Collection<ExposableWebEndpoint> webEndpoints = endpointDiscoverer.getEndpoints();",
        "ins2PreCode":"RestTemplateBuilder restTemplateBuilder, ServletEndpointsSupplier servletEndpointsSupplier, ControllerEndpointsSupplier controllerEndpointsSupplier) { CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, null, Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( restTemplateBuilder, this.applicationContext.getEnvironment()); Collection<ExposableWebEndpoint> webEndpoints = discoverer.getEndpoints();",
        "label":1
    },
    {
        "ins1CurCode":"long timeout = getReadTimeout(); try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; }",
        "ins1PreCode":"long timeout = getReadTimeout(); try { readBlock = new CountDownLatch(1); registerReadInterest(); if (timeout > 0) { if (!readBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { readBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { readBlock = null; }",
        "ins2PreCode":"if (n == 0) { try { writeBlock = new CountDownLatch(1); registerWriteInterest(); if (timeout > 0) { if (!writeBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { writeBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { writeBlock = null; }",
        "label":0
    },
    {
        "ins1CurCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> processor.execute(ingestDocument)); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse setting [Ingest Field] with value [junk]\"));",
        "ins1PreCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> processor.execute(ingestDocument)); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse [junk]\"));",
        "ins2PreCode":"public void testTooLarge() { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"8912pb\"); Processor processor = newProcessor(fieldName, randomBoolean(), fieldName); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> processor.execute(ingestDocument)); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse setting [Ingest Field] with value [8912pb] as a size in bytes\")); assertThat(exception.getCause().getMessage(), CoreMatchers.containsString(\"Values greater than 9223372036854775807 bytes are not supported\"));",
        "label":0
    },
    {
        "ins1CurCode":"s1.add(3.0, 3.0, 3.0, 3.0); s1.add(2.0, 2.0, 2.0, 2.0); assertEquals(0, s1.indexOf(1.0)); assertEquals(1, s1.indexOf(3.0)); assertEquals(2, s1.indexOf(2.0));",
        "ins1PreCode":"s1.add(3.0, 3.0, 3.0, 3.0); s1.add(2.0, 2.0, 2.0, 2.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(3.0))); assertEquals(2, s1.indexOf(new Double(2.0)));",
        "ins2PreCode":"s1.add(3.0, 3.0, 3.0, 3.0); s1.add(2.0, 2.0, 2.0, 2.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(3.0))); assertEquals(2, s1.indexOf(new Double(2.0)));",
        "label":1
    },
    {
        "ins1CurCode":"void getValueWhenOriginCapableShouldIncludeSourceOrigin() { Map<String, Object> source = new LinkedHashMap<>();",
        "ins1PreCode":"public void getValueWhenOriginCapableShouldIncludeSourceOrigin() { Map<String, Object> source = new LinkedHashMap<>();",
        "ins2PreCode":"public void getValueOrigin() { Map<String, Object> source = new LinkedHashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, ScriptScope scriptScope) { Class<?> valueType = scriptScope.getDecoration(userBooleanConstantNode, ValueType.class).getValueType(); Object constant = scriptScope.getDecoration(userBooleanConstantNode, StandardConstant.class).getStandardConstant();  ConstantNode irConstantNode = new ConstantNode(userBooleanConstantNode.getLocation()); irConstantNode.attachDecoration(new IRDExpressionType(valueType)); irConstantNode.setConstant(constant); ",
        "ins1PreCode":"public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userBooleanConstantNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userBooleanConstantNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userBooleanConstantNode, StandardConstant.class).getStandardConstant()); ",
        "ins2PreCode":"public void visitNumeric(ENumeric userNumericNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userNumericNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant()); ",
        "label":0
    },
    {
        "ins1CurCode":"if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) { if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGDECIMAL; else delegate = DOUBLE; } else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER;",
        "ins1PreCode":"if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) delegate = DOUBLE; else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER;",
        "ins2PreCode":"if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) delegate = DOUBLE; else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER;",
        "label":1
    },
    {
        "ins1CurCode":"public boolean hasFreshToken(@NonNull User user, ApiTokenProperty.TokenInfoAndStats legacyStats) { if (legacyStats == null) {",
        "ins1PreCode":"public boolean hasFreshToken(@Nonnull User user, ApiTokenProperty.TokenInfoAndStats legacyStats) { if (legacyStats == null) {",
        "ins2PreCode":"public boolean hasMoreRecentlyUsedToken(@Nonnull User user, ApiTokenProperty.TokenInfoAndStats legacyStats) { if (legacyStats == null) {",
        "label":1
    },
    {
        "ins1CurCode":"public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, this.messageConverters, setOf(interceptors), this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "ins1PreCode":"public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, Collections.unmodifiableSet(new LinkedHashSet<>(interceptors)));",
        "ins2PreCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "label":0
    },
    {
        "ins1CurCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), null, new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins2PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), null, new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "label":0
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposable.empty(); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"PublishSubject<Integer> ps = PublishSubject.create();  final TestObserver<Void> to1 = new TestObserver<>(); ",
        "ins1PreCode":"PublishSubject<Integer> ps = PublishSubject.create();  final TestObserver<Void> to1 = new TestObserver<Void>(); ",
        "ins2PreCode":"PublishSubject<Integer> ps = PublishSubject.create();  final TestObserver<Void> to1 = new TestObserver<Void>(); ",
        "label":1
    },
    {
        "ins1CurCode":"});  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);",
        "ins1PreCode":"});  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);",
        "ins2PreCode":"});  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); firehose.replay().autoConnect().observeOn(Schedulers.computation()).takeLast(100).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"Flowable<Integer> result = source.withLatestFrom(other, COMBINER);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"Flowable<Integer> result = source.withLatestFrom(other, COMBINER);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"Flowable<Integer> result = source.withLatestFrom(other, COMBINER);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void setRetriesAllowed(String retriesAllowed) { if (\"FOREVER\".equalsIgnoreCase(retriesAllowed)) { this.retriesAllowed = Retryable.RETRY_FOREVER;",
        "ins1PreCode":"public void setRetriesAllowed(String retriesAllowed) { String r = retriesAllowed != null ? retriesAllowed.toUpperCase(Locale.ENGLISH) : null; if (\"FOREVER\".equals(r)) { this.retriesAllowed = Retryable.RETRY_FOREVER;",
        "ins2PreCode":"public void setRetriesAllowed(String retriesAllowed) { String r = retriesAllowed != null ? retriesAllowed.toUpperCase(Locale.ENGLISH) : null; if (\"FOREVER\".equals(r)) { this.retriesAllowed = Retryable.RETRY_FOREVER;",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {1, 2}); plot.mapDatasetToDomainAxes(0, axisIndices);",
        "ins1PreCode":"assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToDomainAxes(0, axisIndices);",
        "ins2PreCode":"assertEquals(yAxis2, plot.getRangeAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToRangeAxes(0, axisIndices);",
        "label":1
    },
    {
        "ins1CurCode":"static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {  for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { PainlessClass struct = painlessLookup.getPainlessStructFromJavaClass(clazz);  if (struct != null) { MethodHandle handle = struct.getters.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.getPainlessStructFromJavaClass(iface); ",
        "ins1PreCode":"static MethodHandle lookupGetter(Definition definition, Class<?> receiverClass, String name) {  for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { Struct struct = definition.RuntimeClassToStruct(clazz);  if (struct != null) { MethodHandle handle = struct.getters.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = definition.RuntimeClassToStruct(iface); ",
        "ins2PreCode":"static MethodHandle lookupSetter(Definition definition, Class<?> receiverClass, String name) {  for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { Struct struct = definition.RuntimeClassToStruct(clazz);  if (struct != null) { MethodHandle handle = struct.setters.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = definition.RuntimeClassToStruct(iface); ",
        "label":1
    },
    {
        "ins1CurCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelect\", 1); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins1PreCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelect\", 1); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins2PreCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assert.assertTrue(blog instanceof Proxy);",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual(Observer<? super Integer> o) { ts0[0] = o; o.onSubscribe(Disposable.empty()); o.onError(new TestException(\"First\"));",
        "ins1PreCode":"protected void subscribeActual(Observer<? super Integer> o) { ts0[0] = o; o.onSubscribe(Disposables.empty()); o.onError(new TestException(\"First\"));",
        "ins2PreCode":"public void badInnerSource() { @SuppressWarnings(\"rawtypes\") final Subscriber[] ts0 = { null }; TestSubscriberEx<Integer> ts = Flowable.just(1).hide().concatMap(Functions.justFunction(new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> s) { ts0[0] = s; s.onSubscribe(new BooleanSubscription()); s.onError(new TestException(\"First\")); } }), 2, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer());  ts.assertFailureAndMessage(TestException.class, \"First\");  List<Throwable> errors = TestHelper.trackPluginErrors(); try { ts0[0].onError(new TestException(\"Second\"));  TestHelper.assertUndeliverable(errors, 0, TestException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.ENGLISH); ",
        "ins1PreCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.US); ",
        "ins2PreCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.US); ",
        "label":1
    },
    {
        "ins1CurCode":" createTestZip( zipDestination ); Files.createDirectories( mavenHomeDir ); File garbage = mavenHomeDir.resolve( \"garbage\" ).toFile(); Files.createFile( garbage.toPath() );  configuration.setAlwaysUnpack( true );  Path homeDir = install.createDist( configuration );  Assert.assertEquals( mavenHomeDir, homeDir ); Assert.assertTrue( Files.isDirectory( mavenHomeDir ) ); Assert.assertFalse( Files.exists( homeDir.resolve( \"garbage\" ) ) ); Assert.assertTrue( Files.exists( zipDestination ) ); ",
        "ins1PreCode":" createTestZip( zipDestination ); mavenHomeDir.mkdirs(); File garbage = new File( mavenHomeDir, \"garbage\" ); FileUtils.touch( garbage ); configuration.setAlwaysUnpack( true );  File homeDir = install.createDist( configuration );  Assert.assertEquals( mavenHomeDir, homeDir ); Assert.assertTrue( mavenHomeDir.isDirectory() ); Assert.assertFalse( new File( homeDir, \"garbage\" ).exists() ); Assert.assertTrue( zipDestination.exists() ); ",
        "ins2PreCode":" createTestZip( zipDestination ); File garbage = new File( mavenHomeDir, \"garbage\" ); FileUtils.touch( garbage ); configuration.setAlwaysUnpack( true );  File homeDir = install.createDist( configuration );  Assert.assertEquals( mavenHomeDir, homeDir ); Assert.assertTrue( mavenHomeDir.isDirectory() ); Assert.assertTrue( new File( homeDir, \"bin/mvn\" ).exists() ); Assert.assertFalse( new File( homeDir, \"garbage\" ).exists() ); Assert.assertTrue( zipDestination.exists() ); ",
        "label":1
    },
    {
        "ins1CurCode":"\"'->'\", \"'=~'\", \"'==~'\", \"'++'\", \"'--'\", \"'='\", \"'+='\", \"'-='\", \"'*='\", \"'/='\", \"'%='\", \"'&='\", \"'^='\", \"'|='\", \"'<<='\", \"'>>='\", \"'>>>='\", null, null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\", null, \"'def'\"",
        "ins1PreCode":"\"'->'\", \"'=~'\", \"'==~'\", \"'++'\", \"'--'\", \"'='\", \"'+='\", \"'-='\", \"'*='\", \"'/='\", \"'%='\", \"'&='\", \"'^='\", \"'|='\", \"'<<='\", \"'>>='\", \"'>>>='\", null, null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\"",
        "ins2PreCode":"\"'->'\", \"'=~'\", \"'==~'\", \"'++'\", \"'--'\", \"'='\", \"'+='\", \"'-='\", \"'*='\", \"'/='\", \"'%='\", \"'&='\", \"'^='\", \"'|='\", \"'<<='\", \"'>>='\", \"'>>>='\", null, null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\"",
        "label":1
    },
    {
        "ins1CurCode":"public void getMinEndIndex() { TimePeriodValues<String> s = new TimePeriodValues<>(\"Test\"); assertEquals(-1, s.getMinEndIndex());",
        "ins1PreCode":"public void getMinEndIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMinEndIndex());",
        "ins2PreCode":"public void getMaxEndIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMaxEndIndex());",
        "label":1
    },
    {
        "ins1CurCode":"public void removeValue(R rowKey, C columnKey) { setValue(null, rowKey, columnKey);   boolean allNull = true; int rowIndex = getRowIndex(rowKey); DefaultKeyedValues row = this.rows.get(rowIndex);  for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getValue(item) != null) { allNull = false; break; } }  if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); }   allNull = true;   for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getValue(columnIndex) != null) { allNull = false; break; } }  if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = this.rows.get(item); int columnIndex = row.getIndex(columnKey);",
        "ins1PreCode":"public void removeValue(Comparable rowKey, Comparable columnKey) { setValue(null, rowKey, columnKey);   boolean allNull = true; int rowIndex = getRowIndex(rowKey); DefaultKeyedValues row = (DefaultKeyedValues) this.rows.get(rowIndex);  for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getValue(item) != null) { allNull = false; break; } }  if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); }   allNull = true;   for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (DefaultKeyedValues) this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getValue(columnIndex) != null) { allNull = false; break; } }  if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (DefaultKeyedValues) this.rows.get(item); int columnIndex = row.getIndex(columnKey);",
        "ins2PreCode":"public void removeObject(Comparable rowKey, Comparable columnKey) { int rowIndex = getRowIndex(rowKey); if (rowIndex < 0) { throw new UnknownKeyException(\"Row key (\" + rowKey + \") not recognised.\"); } int columnIndex = getColumnIndex(columnKey); if (columnIndex < 0) { throw new UnknownKeyException(\"Column key (\" + columnKey + \") not recognised.\"); } setObject(null, rowKey, columnKey);   boolean allNull = true; KeyedObjects row = (KeyedObjects) this.rows.get(rowIndex);  for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getObject(item) != null) { allNull = false; break; } }  if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); }   allNull = true;  for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int colIndex = row.getIndex(columnKey); if (colIndex >= 0 && row.getObject(colIndex) != null) { allNull = false; break; } }  if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = (KeyedObjects) this.rows.get(item); int colIndex = row.getIndex(columnKey); if (colIndex >= 0) { row.removeValue(colIndex); } } this.columnKeys.remove(columnKey); }",
        "label":0
    },
    {
        "ins1CurCode":"return new DiskBlockObjectWriter( (File) args[1], serializerManager, (SerializerInstance) args[2],",
        "ins1PreCode":"(SerializerInstance) args[2], (Integer) args[3], new WrapStream(), false,",
        "ins2PreCode":"(SerializerInstance) args[2], (Integer) args[3], new WrapStream(), false,",
        "label":1
    },
    {
        "ins1CurCode":"SubCategoryAxis a1 = new SubCategoryAxis(\"Test\"); a1.addSubCategory(\"SubCategoryA\"); SubCategoryAxis a2 = CloneUtils.clone(a1); assertTrue(a1 != a2);",
        "ins1PreCode":"SubCategoryAxis a1 = new SubCategoryAxis(\"Test\"); a1.addSubCategory(\"SubCategoryA\"); SubCategoryAxis a2 = (SubCategoryAxis) a1.clone(); assertTrue(a1 != a2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { NumberAxis a1 = new NumberAxis(\"Test\"); NumberAxis a2 = (NumberAxis) a1.clone(); assertTrue(a1 != a2); assertTrue(a1.getClass() == a2.getClass()); assertTrue(a1.equals(a2));",
        "label":0
    },
    {
        "ins1CurCode":"new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\") .set(\"spark.shuffle.spill.compress\", \"false\") .set(\"spark.shuffle.compress\", \"false\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins1PreCode":"new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);  tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer( new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments();  return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins2PreCode":"} }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "label":0
    },
    {
        "ins1CurCode":"public void testEquals_ObjectList3() { XYPlot<String> p1 = new XYPlot<>(); p1.setRangeAxis(new NumberAxis(\"A\")); XYPlot<String> p2 = new XYPlot<>(); p2.setRangeAxis(new NumberAxis(\"A\"));",
        "ins1PreCode":"public void testEquals_ObjectList3() { XYPlot p1 = new XYPlot(); p1.setRangeAxis(new NumberAxis(\"A\")); XYPlot p2 = new XYPlot(); p2.setRangeAxis(new NumberAxis(\"A\"));",
        "ins2PreCode":"public void testEquals_ObjectList() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setDomainAxis(new CategoryAxis(\"A\")); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setDomainAxis(new CategoryAxis(\"A\")); assertEquals(p1, p2); p2.setDomainAxis(1, new CategoryAxis(\"B\")); assertNotEquals(p1, p2);",
        "label":0
    },
    {
        "ins1CurCode":"AuthorList al = AuthorList.parse(fieldText); DocBookAuthorFormatter formatter = new DocBookAuthorFormatter(); formatter.addBody(sb, al, StandardField.AUTHOR.getName(), DocBookVersion.DOCBOOK_4); return sb.toString();",
        "ins1PreCode":"AuthorList al = AuthorList.parse(fieldText); DocBookAuthorFormatter formatter = new DocBookAuthorFormatter(); formatter.addBody(sb, al, FieldName.AUTHOR, DocBookVersion.DOCBOOK_4); return sb.toString();",
        "ins2PreCode":"AuthorList al = AuthorList.parse(fieldText); DocBookAuthorFormatter formatter = new DocBookAuthorFormatter(); formatter.addBody(sb, al, FieldName.EDITOR, DocBookVersion.DOCBOOK_5); return sb.toString();",
        "label":1
    },
    {
        "ins1CurCode":"void testSelectBlogWithPosts() { try (SqlSession session = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testSelectBlogWithPosts() { try (SqlSession session = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testSelectBlogWithPostsColumnPrefix() { try (SqlSession session = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testSmallSet() { Project p = buildRule.getProject(); buildRule.executeTarget(\"testsmallset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "ins1PreCode":"public void testSmallSet() { Project p = getProject(); executeTarget(\"testsmallset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "ins2PreCode":"public void testMethodParam() { Project p = getProject(); executeTarget(\"testmethodparam\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "label":1
    },
    {
        "ins1CurCode":"public StubItem[] getDiscoverableItems() { Snapshot s = this.snapshot; List<StubItem> r = new ArrayList<>(); ",
        "ins1PreCode":"public StubItem[] getDiscoverableItems() { Snapshot s = this.snapshot; List<StubItem> r = new ArrayList<StubItem>(); ",
        "ins2PreCode":"public Item[] getItems() { Snapshot s = this.snapshot; List<Item> r = new ArrayList<Item>(); ",
        "label":0
    },
    {
        "ins1CurCode":"double[] weights = {10, 10};  JavaRDD<LabeledPoint> testRDD = jsc.parallelize( LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();",
        "ins1PreCode":"double[] weights = {10, 10};  JavaRDD<LabeledPoint> testRDD = sc.parallelize( LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();",
        "ins2PreCode":"double[] weights = {10, 10};  JavaRDD<LabeledPoint> testRDD = sc.parallelize( LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache();",
        "label":1
    },
    {
        "ins1CurCode":"result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(THREAD_SLEEP_TIME); result.append('4');",
        "ins1PreCode":"result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4');",
        "ins2PreCode":"result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4');",
        "label":1
    },
    {
        "ins1CurCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>(); ",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> mergeDelayError( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Flowable<T> mergeDelayError( @NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> concat( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4) {",
        "label":0
    },
    {
        "ins1CurCode":"public void assertValueAtInvalidIndex() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void assertValueAtInvalidIndex() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void assertValueAtPredicateMatch() { TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"upstream.dispose(); queue.clear(); errors.tryAddThrowableOrReport(ex); errors.tryTerminateConsumer(downstream);",
        "ins1PreCode":"upstream.dispose(); queue.clear(); errors.addThrowable(ex); errors.tryTerminateConsumer(downstream);",
        "ins2PreCode":"upstream.dispose(); queue.clear(); errors.addThrowable(ex); errors.tryTerminateConsumer(downstream);",
        "label":1
    },
    {
        "ins1CurCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "ins2PreCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCursorIteratorNoSuchElementExceptionWithHasNext() throws IOException {  try (SqlSession sqlSession = sqlSessionFactory.openSession(); Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1))) { try {",
        "ins1PreCode":"public void testCursorIteratorNoSuchElementExceptionWithHasNext() { SqlSession sqlSession = sqlSessionFactory.openSession();  Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1)); try { Iterator<User> iterator = usersCursor.iterator();  User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex());  Assert.assertFalse(iterator.hasNext()); iterator.next(); Assert.fail(\"We should have failed since we call next() when hasNext() returned false\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testCursorIteratorNoSuchElementExceptionNoHasNext() { SqlSession sqlSession = sqlSessionFactory.openSession();  Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1)); try { Iterator<User> iterator = usersCursor.iterator();  User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex());   iterator.next(); Assert.fail(\"We should have failed since we call next() when is no more items\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, fields.length); IndexableField pointField = fields[0]; assertEquals(1, pointField.fieldType().pointDataDimensionCount()); assertEquals(1230, pointField.numericValue().longValue());",
        "ins1PreCode":"assertEquals(1, fields.length); IndexableField pointField = fields[0]; assertEquals(1, pointField.fieldType().pointDimensionCount()); assertEquals(1230, pointField.numericValue().longValue());",
        "ins2PreCode":"public void testNotIndexed() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"index\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject());  DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));  assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(SourceToParse.source(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 123) .endObject()), XContentType.JSON));  IndexableField[] fields = doc.rootDoc().getFields(\"field\"); assertEquals(1, fields.length); IndexableField dvField = fields[0]; assertEquals(DocValuesType.SORTED_NUMERIC, dvField.fieldType().docValuesType()); assertEquals(1230, dvField.numericValue().longValue());",
        "label":0
    },
    {
        "ins1CurCode":"void testUserSpecifiedJarPath() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\");",
        "ins1PreCode":"public void testUserSpecifiedJarPath() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\");",
        "ins2PreCode":"public void testUserSpecifiedNestedJarPath() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\");",
        "label":1
    },
    {
        "ins1CurCode":"final AtomicInteger counter = new AtomicInteger();  List<Observable<?>> observableList = new ArrayList<>(); observableList.add(Observable.create(new ObservableOnSubscribe<Object>() {",
        "ins1PreCode":"final AtomicInteger counter = new AtomicInteger();  List<Observable<?>> observableList = new ArrayList<Observable<?>>(); observableList.add(Observable.create(new ObservableOnSubscribe<Object>() {",
        "ins2PreCode":"public void firstErrorPreventsSecondSubscription() { final AtomicInteger counter = new AtomicInteger();  List<Flowable<?>> flowableList = new ArrayList<>(); flowableList.add(Flowable.create(new FlowableOnSubscribe<Object>() { @Override public void subscribe(FlowableEmitter<Object> e) throws Exception { throw new TestException(); } }, BackpressureStrategy.MISSING)); flowableList.add(Flowable.create(new FlowableOnSubscribe<Object>() { @Override public void subscribe(FlowableEmitter<Object> e) throws Exception { counter.getAndIncrement(); } }, BackpressureStrategy.MISSING));  Flowable.zip(flowableList, new Function<Object[], Object>() { @Override public Object apply(Object[] a) throws Exception { return a; } }) .test() .assertFailure(TestException.class) ;  assertEquals(0, counter.get());",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribe(final Observer<? super Observable<Long>> observer) {  final Disposable upstream = Disposable.fromRunnable(new Runnable() { @Override",
        "ins1PreCode":"public void subscribe(final Observer<? super Observable<Long>> observer) {  final Disposable upstream = Disposables.fromRunnable(new Runnable() { @Override",
        "ins2PreCode":"public void unSubscribeFlowableOfFlowables() throws InterruptedException {  final AtomicBoolean unsubscribed = new AtomicBoolean(); final CountDownLatch latch = new CountDownLatch(1);  Flowable<Flowable<Long>> source = Flowable.unsafeCreate(new Publisher<Flowable<Long>>() {  @Override public void subscribe(final Subscriber<? super Flowable<Long>> subscriber) {  final Subscription s = new Subscription() {  @Override public void request(long n) {  }  @Override public void cancel() { System.out.println(\"*** unsubscribed\"); unsubscribed.set(true); }  }; subscriber.onSubscribe(s);  new Thread(new Runnable() {  @Override public void run() {  while (!unsubscribed.get()) { subscriber.onNext(Flowable.just(1L, 2L)); } System.out.println(\"Done looping after unsubscribe: \" + unsubscribed.get()); subscriber.onComplete();   latch.countDown(); } }).start(); }  });  final AtomicInteger count = new AtomicInteger(); Flowable.merge(source).take(6).blockingForEach(new Consumer<Long>() {  @Override public void accept(Long v) { System.out.println(\"Value: \" + v); int c = count.incrementAndGet(); if (c > 6) { fail(\"Should be only 6\"); }  } });  latch.await(1000, TimeUnit.MILLISECONDS);  System.out.println(\"unsubscribed: \" + unsubscribed.get());  assertTrue(unsubscribed.get()); ",
        "label":0
    },
    {
        "ins1CurCode":"Path myPath = new Path(buildRule.getProject()); myPath.setLocation(new File(mainjarstring)); buildRule.getProject().setUserProperty(MagicNames.BUILD_SYSCLASSPATH, \"ignore\"); loader = buildRule.getProject().createClassLoader(myPath);",
        "ins1PreCode":"Path myPath = new Path(buildRule.getProject()); myPath.setLocation(new File(mainjarstring)); buildRule.getProject().setUserProperty(\"build.sysclasspath\", \"ignore\"); loader = buildRule.getProject().createClassLoader(myPath);",
        "ins2PreCode":"Path myPath = new Path(buildRule.getProject()); myPath.setLocation(new File(mainjarstring)); buildRule.getProject().setUserProperty(\"build.sysclasspath\", \"ignore\"); loader = buildRule.getProject().createClassLoader(myPath);",
        "label":1
    },
    {
        "ins1CurCode":"public boolean removeDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) { Collection<CategoryMarker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundDomainMarkers.get(index); } else { markers = this.backgroundDomainMarkers.get(index); }",
        "ins1PreCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundDomainMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundDomainMarkers.get(index); }",
        "ins2PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\"); List<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundRangeMarkers.get(index); } else { markers = this.backgroundRangeMarkers.get(index); } if (markers == null) { return false; } boolean removed = markers.remove(marker); if (removed && notify) { fireChangeEvent(); } return removed;",
        "label":0
    },
    {
        "ins1CurCode":"} catch (Exception e) {  log.warn(Localizer.getMessage(\"jsp.warning.compiler.classfile.delete.fail.unknown\"), e); }",
        "ins1PreCode":"} catch (Exception e) {  }",
        "ins2PreCode":"public void removeGeneratedFiles() { try { String classFileName = ctxt.getClassFileName(); if (classFileName != null) { File classFile = new File(classFileName); if (log.isDebugEnabled()) log.debug(\"Deleting \" + classFile); if (classFile.exists()) { if (!classFile.delete()) { log.warn(Localizer.getMessage( \"jsp.warning.compiler.classfile.delete.fail\", classFile.getAbsolutePath())); }",
        "label":0
    },
    {
        "ins1CurCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, SQLObjectEditor.NestedObjectCommand<ExasolFunction, SQLObjectEditor<ExasolFunction, ExasolSchema>.PropertyHandler> command) { if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON FUNCTION \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS \" + SQLUtils.quoteString(command.getObject(), command.getObject().getDescription()))); }",
        "ins1PreCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolFunction, SQLObjectEditor<ExasolFunction, ExasolSchema>.PropertyHandler> command) { if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON FUNCTION \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS \" + SQLUtils.quoteString(command.getObject().getDescription()))); }",
        "ins2PreCode":"actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON SCRIPT \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS \" + SQLUtils.quoteString(command.getObject().getDescription()))); }",
        "label":0
    },
    {
        "ins1CurCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); ",
        "ins2PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); ",
        "label":1
    },
    {
        "ins1CurCode":"  assertEquals(\"Initially the rolling queue length for the label is 0.\", 0f, label.loadStatistics.queueLength.getLatest(TimeScale.SEC10), 0.0); assertEquals(\"Initially the rolling queue length for the alt label is 0.\", 0f, altLabel.loadStatistics.queueLength.getLatest(TimeScale.SEC10), 0.0); ",
        "ins1PreCode":" assertTrue( \"Initially the rolling queue length for the label is 0.\", label.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f); assertTrue( \"Initially the rolling queue length for the alt label is 0.\", altLabel.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f); ",
        "ins2PreCode":"  assertTrue( \"Initially the rolling queue length for the label is 0.\", label.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f); ",
        "label":0
    },
    {
        "ins1CurCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber(); Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries)); TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber); origin.retry().observeOn(Schedulers.computation()).subscribe(ts);",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber(); Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries)); TestSubscriberEx<String> ts = new TestSubscriberEx<String>(subscriber); origin.retry().observeOn(Schedulers.computation()).subscribe(ts);",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver(); Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(NUM_RETRIES)); TestObserver<String> to = new TestObserver<String>(observer); origin.retry().observeOn(Schedulers.computation()).subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<T> h = new TimedNode<>(null, 0L); this.tail = h;",
        "ins1PreCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<T> h = new TimedNode<T>(null, 0L); this.tail = h;",
        "ins2PreCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<Object> h = new TimedNode<Object>(null, 0L); this.tail = h;",
        "label":0
    },
    {
        "ins1CurCode":"ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy));",
        "ins1PreCode":"ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy));",
        "ins2PreCode":"ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy))));",
        "label":1
    },
    {
        "ins1CurCode":" if (n == 1) { a[0].subscribe(new SingleMap.MapSingleObserver<>(observer, new SingletonArrayFunc())); return; }  ZipCoordinator<T, R> parent = new ZipCoordinator<>(observer, n, zipper); ",
        "ins1PreCode":" if (n == 1) { a[0].subscribe(new SingleMap.MapSingleObserver<T, R>(observer, new SingletonArrayFunc())); return; }  ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper); ",
        "ins2PreCode":" if (n == 1) { a[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new SingletonArrayFunc())); return; }  ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper); ",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(v); } }, true, 2, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"return Flowable.just(v); } }, 2, true, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"public void pollThrowsDelayError() { Flowable.just(1) .map(new Function<Integer, Integer>() { @Override public Integer apply(Integer v) throws Exception { throw new TestException(); } }) .compose(TestHelper.<Integer>flowableStripBoundary()) .concatMapDelayError(new Function<Integer, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Integer v) throws Exception { return Flowable.just(v); } }) .test() .assertFailure(TestException.class);",
        "label":0
    },
    {
        "ins1CurCode":"Assert.assertTrue(body, body.contains(\"ServletName=[Include]\"));  Assert.assertTrue(body, body.contains(\"IncludeMatchValue=[mapping]\")); Assert.assertTrue(body, body.contains(\"IncludePattern=[/mapping]\"));",
        "ins1PreCode":"Assert.assertTrue(body, body.contains(\"ServletName=[Include]\"));  Assert.assertTrue(body, body.contains(\"IncludeMatchValue=[/mapping]\")); Assert.assertTrue(body, body.contains(\"IncludePattern=[/mapping]\"));",
        "ins2PreCode":"private void doTestMappingDirect(String contextPath, String mapping, String requestPath, String matchValue, String matchType) throws Exception { Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(contextPath, null);  Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMappingDecoded(mapping, \"Mapping\");  tomcat.start();  ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + contextPath + requestPath); String body = bc.toString();  Assert.assertTrue(body, body.contains(\"MatchValue=[\" + matchValue + \"]\")); Assert.assertTrue(body, body.contains(\"Pattern=[\" + mapping + \"]\")); Assert.assertTrue(body, body.contains(\"MatchType=[\" + matchType + \"]\")); Assert.assertTrue(body, body.contains(\"ServletName=[Mapping]\"));",
        "label":0
    },
    {
        "ins1CurCode":"void testAddNewTermListNewListInList(@TempDir Path tempDir) { ",
        "ins1PreCode":"void testAddNewTermListNewListInList(@TempDirectory.TempDir Path tempDir) { ",
        "ins2PreCode":"void testRemoveTermList(@TempDirectory.TempDir Path tempDir) { ",
        "label":1
    },
    {
        "ins1CurCode":"public void testBccOnly() throws InterruptedException { final int port = TEST_PORT + 4; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread(port); ",
        "ins1PreCode":"public void testBccOnly() throws InterruptedException { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result);",
        "ins2PreCode":"public void testNoSubject() throws InterruptedException { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result);",
        "label":1
    },
    {
        "ins1CurCode":"void testSerialization() throws IOException { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.Article);  entry.setField(StandardField.AUTHOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins1PreCode":"void testSerialization() throws IOException { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.Article);  entry.setField(StandardField.AUTHOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins2PreCode":"void writeEntryWithOrField() throws Exception { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.InBook);  entry.setField(StandardField.EDITOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@InBook{,\" + OS.NEWLINE + \"  editor  = {Foo Bar},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1CurCode":"+ \" -> \" + after.get() / 1024.0 / 1024.0); }",
        "ins1PreCode":"+ \" -> \" + after.get() / 1024.0 / 1024.0); }",
        "ins2PreCode":"public void noBoundedRetentionViaThreadLocal() throws Exception { Observable<byte[]> source = Observable.range(1, 200) .map(new Function<Integer, byte[]>() { @Override public byte[] apply(Integer v) throws Exception { return new byte[1024 * 1024]; } }) .replay(new Function<Observable<byte[]>, Observable<byte[]>>() { @Override public Observable<byte[]> apply(final Observable<byte[]> o) throws Exception { return o.take(1) .concatMap(new Function<byte[], Observable<byte[]>>() { @Override public Observable<byte[]> apply(byte[] v) throws Exception { return o; } }); } }, 1) .takeLast(1) ;  System.out.println(\"Bounded Replay Leak check: Wait before GC\"); Thread.sleep(1000);  System.out.println(\"Bounded Replay Leak check: GC\"); System.gc();  Thread.sleep(500);  final MemoryMXBean memoryMXBean = ManagementFactory.getMemoryMXBean(); MemoryUsage memHeap = memoryMXBean.getHeapMemoryUsage(); long initial = memHeap.getUsed();  System.out.printf(\"Bounded Replay Leak check: Starting: %.3f MB%n\", initial / 1024.0 / 1024.0);  final AtomicLong after = new AtomicLong();  source.subscribe(new Consumer<byte[]>() { @Override public void accept(byte[] v) throws Exception { System.out.println(\"Bounded Replay Leak check: Wait before GC 2\"); Thread.sleep(1000);  System.out.println(\"Bounded Replay Leak check:  GC 2\"); System.gc();  Thread.sleep(500);  after.set(memoryMXBean.getHeapMemoryUsage().getUsed()); } });  System.out.printf(\"Bounded Replay Leak check: After: %.3f MB%n\", after.get() / 1024.0 / 1024.0);  if (initial + 100 * 1024 * 1024 < after.get()) { Assert.fail(\"Bounded Replay Leak check: Memory leak detected: \" + (initial / 1024.0 / 1024.0) + \" -> \" + after.get() / 1024.0 / 1024.0); }",
        "label":0
    },
    {
        "ins1CurCode":"this.server.expect(requestTo(String.format( \"https://oss.sonatype.org/service/local/repositories/releases/content/org/springframework/boot/spring-boot/%s/spring-boot-%s.jar.sha1\", \"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)) .andRespond(withSuccess().body(\"ce8d8b6838ecceb68962b975b18682f4237ccf71\".getBytes())); boolean published = this.service.artifactsPublished(getReleaseInfo());",
        "ins1PreCode":"this.server.expect(requestTo(String.format( \"https://oss.sonatype.org/service/local/repositories/releases/content/org/springframework/boot/spring-boot/%s/spring-boot-%s.jar.sha1\", \"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)).andRespond(withSuccess()); boolean published = this.service.artifactsPublished(getReleaseInfo());",
        "ins2PreCode":"void artifactsPublishedWhenNotPublishedShouldReturnFalse() { this.server.expect(requestTo(String.format( \"https://oss.sonatype.org/service/local/repositories/releases/content/org/springframework/boot/spring-boot/%s/spring-boot-%s.jar.sha1\", \"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)) .andRespond(withStatus(HttpStatus.NOT_FOUND)); boolean published = this.service.artifactsPublished(getReleaseInfo()); assertThat(published).isFalse(); this.server.verify();",
        "label":0
    },
    {
        "ins1CurCode":".to(TestHelper.<Integer>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(ExceptionHelper.nullWarning(\"The collectionSupplier returned a null Collection.\"));",
        "ins1PreCode":".to(TestHelper.<Integer>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins2PreCode":".to(TestHelper.<Integer>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "label":1
    },
    {
        "ins1CurCode":"void createUrlFromString() throws Exception { JarFile.registerUrlProtocolHandler();",
        "ins1PreCode":"public void createUrlFromString() throws Exception { JarFile.registerUrlProtocolHandler();",
        "ins2PreCode":"private void nonNestedJarFileFromString(String spec) throws Exception { JarFile.registerUrlProtocolHandler(); URL url = new URL(spec); assertThat(url.toString()).isEqualTo(spec); InputStream inputStream = url.openStream(); assertThat(inputStream).isNotNull(); assertThat(inputStream.read()).isEqualTo(2); JarURLConnection connection = (JarURLConnection) url.openConnection(); assertThat(connection.getURL().toString()).isEqualTo(spec); assertThat(connection.getJarFileURL().toURI()) .isEqualTo(this.rootJarFile.toURI()); assertThat(connection.getEntryName()).isEqualTo(\"2.dat\");",
        "label":0
    },
    {
        "ins1CurCode":"public void setCluster(Cluster cluster) {  Cluster oldCluster = null; Lock writeLock = clusterLock.writeLock(); writeLock.lock(); try {  oldCluster = this.cluster; if (oldCluster == cluster) return; this.cluster = cluster;   if (getState().isAvailable() && (oldCluster != null) && (oldCluster instanceof Lifecycle)) { try { ((Lifecycle) oldCluster).stop(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: stop: \", e); } }   if (cluster != null) cluster.setContainer(this);  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) { try { ((Lifecycle) cluster).start(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: start: \", e); } } } finally { writeLock.unlock(); }   support.firePropertyChange(\"cluster\", oldCluster, cluster);",
        "ins1PreCode":"public synchronized void setCluster(Cluster cluster) {  Cluster oldCluster = this.cluster; if (oldCluster == cluster) return; this.cluster = cluster;   if (getState().isAvailable() && (oldCluster != null) && (oldCluster instanceof Lifecycle)) { try { ((Lifecycle) oldCluster).stop(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: stop: \", e); } }   if (cluster != null) cluster.setContainer(this);  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) { try { ((Lifecycle) cluster).start(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: start: \", e); } }   support.firePropertyChange(\"cluster\", oldCluster, this.cluster);",
        "ins2PreCode":"public synchronized void setLoader(Loader loader) {   Loader oldLoader = this.loader; if (oldLoader == loader) return; this.loader = loader;   if (getState().isAvailable() && (oldLoader != null) && (oldLoader instanceof Lifecycle)) { try { ((Lifecycle) oldLoader).stop(); } catch (LifecycleException e) { log.error(\"StandardContext.setLoader: stop: \", e); } }   if (loader != null) loader.setContext(this); if (getState().isAvailable() && (loader != null) && (loader instanceof Lifecycle)) { try { ((Lifecycle) loader).start(); } catch (LifecycleException e) { log.error(\"StandardContext.setLoader: start: \", e); } }   support.firePropertyChange(\"loader\", oldLoader, this.loader);",
        "label":1
    },
    {
        "ins1CurCode":"labelOffsetType, LengthAdjustmentType.CONTRACT); } return anchor.getAnchorPoint(anchorRect);",
        "ins1PreCode":"labelOffsetType, LengthAdjustmentType.CONTRACT); } return RectangleAnchor.coordinates(anchorRect, anchor);",
        "ins2PreCode":"labelOffsetType, LengthAdjustmentType.CONTRACT); } return RectangleAnchor.coordinates(anchorRect, anchor); ",
        "label":1
    },
    {
        "ins1CurCode":"  if (conflicts.isEmpty()) { for (Map.Entry<String, String> entry : initParameters.entrySet()) {",
        "ins1PreCode":"  for (Map.Entry<String, String> entry : initParameters.entrySet()) { setInitParameter(entry.getKey(), entry.getValue());",
        "ins2PreCode":"public Set<String> setInitParameters(Map<String, String> initParameters) {  Set<String> conflicts = new HashSet<String>();  for (Map.Entry<String, String> entry : initParameters.entrySet()) { if (entry.getKey() == null || entry.getValue() == null) { throw new IllegalArgumentException(sm.getString( \"applicationFilterRegistration.nullInitParams\", entry.getKey(), entry.getValue())); } if (getInitParameter(entry.getKey()) != null) { conflicts.add(entry.getKey()); } }    for (Map.Entry<String, String> entry : initParameters.entrySet()) { setInitParameter(entry.getKey(), entry.getValue()); }  return conflicts;",
        "label":0
    },
    {
        "ins1CurCode":"int index = -1;  final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i);",
        "ins1PreCode":"int index = -1;  for (int i = 0; i < entries.size() && index == -1; ++i) { Object element = entries.elementAt(i);",
        "ins2PreCode":"int index = -1;  for (int i = 0; i < entries.size() && index == -1; ++i) { Object element = entries.elementAt(i);",
        "label":1
    },
    {
        "ins1CurCode":"public void testFullPathMatchesCaseSensitive() { assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins1PreCode":"public void testFullPathMatchesCaseSensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void testExcludeOneFile() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1CurCode":"public void testAlternateIncludeExclude() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {",
        "ins1PreCode":"public void testAlternateIncludeExclude() { if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {",
        "ins2PreCode":"public void testAlternateExcludeInclude() { if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setExcludes(new String[] {",
        "label":1
    },
    {
        "ins1CurCode":"void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\")",
        "ins1PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\")",
        "ins2PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\")",
        "label":1
    },
    {
        "ins1CurCode":"ChannelPromise promise = embeddedChannel.newPromise(); promises.add(promise); HttpPipelinedRequest<FullHttpRequest> pipelinedRequest = requests.get(i); NioHttpRequest nioHttpRequest = new NioHttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()); NioHttpResponse resp = nioHttpRequest.createResponse(RestStatus.OK, BytesArray.EMPTY); embeddedChannel.writeAndFlush(resp, promise);",
        "ins1PreCode":"ArrayList<ChannelPromise> promises = new ArrayList<>(); for (int i = 1; i < requests.size(); ++i) { final FullHttpResponse httpResponse = new DefaultFullHttpResponse(HTTP_1_1, OK); ChannelPromise promise = embeddedChannel.newPromise(); promises.add(promise); int sequence = requests.get(i).getSequence(); NioHttpResponse resp = new NioHttpResponse(sequence, httpResponse); embeddedChannel.writeAndFlush(resp, promise);",
        "ins2PreCode":"ArrayList<ChannelPromise> promises = new ArrayList<>(); for (int i = 1; i < requests.size(); ++i) { final FullHttpResponse httpResponse = new DefaultFullHttpResponse(HTTP_1_1, OK); ChannelPromise promise = embeddedChannel.newPromise(); promises.add(promise); int sequence = requests.get(i).getSequence(); Netty4HttpResponse resp = new Netty4HttpResponse(sequence, httpResponse); embeddedChannel.writeAndFlush(resp, promise);",
        "label":0
    },
    {
        "ins1CurCode":"void configureShouldApplyCustomizer() { this.customizers.add(this.mockCustomizer);",
        "ins1PreCode":"public void configureShouldApplyCustomizer() { this.customizers.add(this.mockCustomizer);",
        "ins2PreCode":"public void configureShouldApplyFilter() { this.filters.add(this.mockFilter);",
        "label":1
    },
    {
        "ins1CurCode":"public void testParseScrollFullyLoaded() throws Exception { AtomicBoolean called = new AtomicBoolean(); sourceWithMockedRemoteCall(\"scroll_fully_loaded.json\").doStartNextScroll(\"\", timeValueMillis(0), wrapAsListener(r -> { assertEquals(\"AVToMiDL50DjIiBO3yKA\", r.getHits().get(0).getId()); assertEquals(\"{\\\"test\\\":\\\"test3\\\"}\", r.getHits().get(0).getSource().utf8ToString()); assertEquals(\"testrouting\", r.getHits().get(0).getRouting()); called.set(true); })); assertTrue(called.get());",
        "ins1PreCode":"public void testParseScrollFullyLoaded() throws Exception { AtomicBoolean called = new AtomicBoolean(); sourceWithMockedRemoteCall(\"scroll_fully_loaded.json\").doStartNextScroll(\"\", timeValueMillis(0), r -> { assertEquals(\"AVToMiDL50DjIiBO3yKA\", r.getHits().get(0).getId()); assertEquals(\"{\\\"test\\\":\\\"test3\\\"}\", r.getHits().get(0).getSource().utf8ToString()); assertEquals(\"testrouting\", r.getHits().get(0).getRouting()); called.set(true); }); assertTrue(called.get());",
        "ins2PreCode":"public void testParseScrollFullyLoadedFrom1_7() throws Exception { AtomicBoolean called = new AtomicBoolean(); sourceWithMockedRemoteCall(\"scroll_fully_loaded_1_7.json\").doStartNextScroll(\"\", timeValueMillis(0), r -> { assertEquals(\"AVToMiDL50DjIiBO3yKA\", r.getHits().get(0).getId()); assertEquals(\"{\\\"test\\\":\\\"test3\\\"}\", r.getHits().get(0).getSource().utf8ToString()); assertEquals(\"testrouting\", r.getHits().get(0).getRouting()); called.set(true); }); assertTrue(called.get());",
        "label":1
    },
    {
        "ins1CurCode":"public void ignoresInvalidSecretInRequest() throws Exception { this.context = getContext( () -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins1PreCode":"public void ignoresInvalidSecretInRequest() throws Exception { loadContext(\"spring.devtools.remote.secret:supersecret\"); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins2PreCode":"public void invokeRestartWithDefaultSetup() throws Exception { loadContext(\"spring.devtools.remote.secret:supersecret\"); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins1PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins2PreCode":"public void testCookiesInstance() throws Exception {  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "label":1
    },
    {
        "ins1CurCode":" try (CommonAnalysisPlugin commonAnalysisPlugin = new CommonAnalysisPlugin()) { IllegalArgumentException ex = expectThrows(IllegalArgumentException.class, () -> createTestAnalysis(IndexSettingsModule.newIndexSettings(\"index\", settings), settings, commonAnalysisPlugin)); assertEquals(\"The [nGram] token filter name was deprecated in 6.4 and cannot be used in new indices. \" + \"Please change the filter name to [ngram] instead.\", ex.getMessage()); }  final Settings settingsPre7 = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir()) .put(IndexMetaData.SETTING_VERSION_CREATED, VersionUtils.randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_6_0)) .put(\"index.analysis.analyzer.custom_analyzer.type\", \"custom\") .put(\"index.analysis.analyzer.custom_analyzer.tokenizer\", \"standard\") .putList(\"index.analysis.analyzer.custom_analyzer.filter\", \"my_ngram\").put(\"index.analysis.filter.my_ngram.type\", \"nGram\") .build(); try (CommonAnalysisPlugin commonAnalysisPlugin = new CommonAnalysisPlugin()) { createTestAnalysis(IndexSettingsModule.newIndexSettings(\"index\", settingsPre7), settingsPre7, commonAnalysisPlugin); assertWarnings(\"The [nGram] token filter name is deprecated and will be removed in a future version. \"",
        "ins1PreCode":" try (CommonAnalysisPlugin commonAnalysisPlugin = new CommonAnalysisPlugin()) { Map<String, TokenFilterFactory> tokenFilters = createTestAnalysis(IndexSettingsModule.newIndexSettings(\"index\", settings), settings, commonAnalysisPlugin).tokenFilter; TokenFilterFactory tokenFilterFactory = tokenFilters.get(\"nGram\"); Tokenizer tokenizer = new MockTokenizer(); tokenizer.setReader(new StringReader(\"foo bar\"));  IllegalArgumentException ex = expectThrows(IllegalArgumentException.class, () -> tokenFilterFactory.create(tokenizer)); assertEquals(\"The [nGram] token filter name was deprecated in 6.4 and cannot be used in new indices. \" + \"Please change the filter name to [ngram] instead.\", ex.getMessage()); }  final Settings settingsPre7 = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir()) .put(IndexMetaData.SETTING_VERSION_CREATED, VersionUtils.randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_6_0)) .put(\"index.analysis.analyzer.custom_analyzer.type\", \"custom\") .put(\"index.analysis.analyzer.custom_analyzer.tokenizer\", \"standard\") .putList(\"index.analysis.analyzer.custom_analyzer.filter\", \"my_ngram\").put(\"index.analysis.filter.my_ngram.type\", \"nGram\") .build(); try (CommonAnalysisPlugin commonAnalysisPlugin = new CommonAnalysisPlugin()) { Map<String, TokenFilterFactory> tokenFilters = createTestAnalysis(IndexSettingsModule.newIndexSettings(\"index\", settingsPre7), settingsPre7, commonAnalysisPlugin).tokenFilter; TokenFilterFactory tokenFilterFactory = tokenFilters.get(\"nGram\"); Tokenizer tokenizer = new MockTokenizer(); tokenizer.setReader(new StringReader(\"foo bar\")); assertNotNull(tokenFilterFactory.create(tokenizer)); assertWarnings(\"The [nGram] token filter name is deprecated and will be removed in a future version. \"",
        "ins2PreCode":" try (CommonAnalysisPlugin commonAnalysisPlugin = new CommonAnalysisPlugin()) { Map<String, TokenFilterFactory> tokenFilters = createTestAnalysis(IndexSettingsModule.newIndexSettings(\"index\", settings), settings, commonAnalysisPlugin).tokenFilter; TokenFilterFactory tokenFilterFactory = tokenFilters.get(\"edgeNGram\"); Tokenizer tokenizer = new MockTokenizer(); tokenizer.setReader(new StringReader(\"foo bar\"));  IllegalArgumentException ex = expectThrows(IllegalArgumentException.class, () -> tokenFilterFactory.create(tokenizer)); assertEquals(\"The [edgeNGram] token filter name was deprecated in 6.4 and cannot be used in new indices. \" + \"Please change the filter name to [edge_ngram] instead.\", ex.getMessage()); }  final Settings settingsPre7 = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir()) .put(IndexMetaData.SETTING_VERSION_CREATED, VersionUtils.randomVersionBetween(random(), Version.V_7_0_0, Version.V_7_6_0)) .put(\"index.analysis.analyzer.custom_analyzer.type\", \"custom\") .put(\"index.analysis.analyzer.custom_analyzer.tokenizer\", \"standard\") .putList(\"index.analysis.analyzer.custom_analyzer.filter\", \"my_ngram\") .put(\"index.analysis.filter.my_ngram.type\", \"edgeNGram\") .build();  try (CommonAnalysisPlugin commonAnalysisPlugin = new CommonAnalysisPlugin()) { Map<String, TokenFilterFactory> tokenFilters = createTestAnalysis(IndexSettingsModule.newIndexSettings(\"index\", settingsPre7), settingsPre7, commonAnalysisPlugin).tokenFilter; TokenFilterFactory tokenFilterFactory = tokenFilters.get(\"edgeNGram\"); Tokenizer tokenizer = new MockTokenizer(); tokenizer.setReader(new StringReader(\"foo bar\")); assertNotNull(tokenFilterFactory.create(tokenizer)); assertWarnings(\"The [edgeNGram] token filter name is deprecated and will be removed in a future version. \"",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T, @NonNull R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<@NonNull ? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T, R> Observable<R> zipArray( @NonNull Function<? super Object[], ? extends R> zipper,",
        "label":0
    },
    {
        "ins1CurCode":"};  Disposable sub1 = Disposable.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposable.empty(); ",
        "ins1PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "ins2PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public ValueAxis getAxisForDataset(int index) { ValueAxis valueAxis; List<Integer> axisIndices = this.datasetToAxesMap.get(index); if (axisIndices != null) {  Integer axisIndex = axisIndices.get(0); valueAxis = getAxis(axisIndex); }",
        "ins1PreCode":"public ValueAxis getAxisForDataset(int index) { ValueAxis valueAxis; List axisIndices = (List) this.datasetToAxesMap.get( new Integer(index)); if (axisIndices != null) {  Integer axisIndex = (Integer) axisIndices.get(0); valueAxis = getAxis(axisIndex.intValue()); }",
        "ins2PreCode":"Args.requireNonNegative(index, \"index\"); CategoryAxis axis; List axisIndices = (List) this.datasetToDomainAxesMap.get( new Integer(index)); if (axisIndices != null) {  Integer axisIndex = (Integer) axisIndices.get(0); axis = getDomainAxis(axisIndex.intValue()); } else {",
        "label":1
    },
    {
        "ins1CurCode":"protected void printThreadResults(TestThread[] threads, String name, int active, int expected) { long minfetch = Long.MAX_VALUE, maxfetch = Long.MIN_VALUE, totalfetch = 0; long maxwait = 0, minwait = Long.MAX_VALUE, totalwait = 0; for (int i=0; i<threads.length; i++) {",
        "ins1PreCode":"protected void printThreadResults(TestThread[] threads, String name, int active, int expected) { long minfetch = Long.MAX_VALUE, maxfetch = Long.MIN_VALUE, totalfetch = 0; long maxwait = 0, minwait = Long.MAX_VALUE, averagewait = 0, totalwait = 0; float avgfetch = 0; for (int i=0; i<threads.length; i++) {",
        "ins2PreCode":"protected void printThreadResults(TestThread[] threads, String name, int active, int expected) { long minfetch = Long.MAX_VALUE, maxfetch = Long.MIN_VALUE, totalfetch = 0; long maxwait = 0, minwait = Long.MAX_VALUE, averagewait = 0, totalwait = 0; float avgfetch = 0; for (int i=0; i<threads.length; i++) { TestThread t = threads[i]; totalfetch += t.nroffetch; totalwait  += t.totalwait; maxwait = Math.max(maxwait,t.maxwait); minwait = Math.min(minwait, t.minwait); minfetch = Math.min(minfetch, t.nroffetch); maxfetch = Math.max(maxfetch, t.nroffetch); if (FairnessTest.this.printthread) System.out.println(t.getName()+\" : Nr-of-fetch:\"+t.nroffetch+ \" Max fetch Time:\"+(((float)t.maxwait)/1000000f)+\"ms. :Max close time:\"+(((float)t.cmax)/1000000f)+\"ms.\"); } System.out.println(\"[\"+name+\"] Max fetch:\"+(maxfetch)+\" Min fetch:\"+(minfetch)+\" Average fetch:\"+ (((float)totalfetch))/(float)threads.length); System.out.println(\"[\"+name+\"] Max wait:\"+(((float)maxwait)/1000000f)+\"ms. Min wait:\"+(((float)minwait)/1000000f)+\"ms. Average wait:\"+(((((float)totalwait))/(float)totalfetch)/1000000f)+\" ms.\"); System.out.println(\"[\"+name+\"] Max active:\"+active+\" Expected Active:\"+expected);  ",
        "label":0
    },
    {
        "ins1CurCode":"public String[] findLifecycleListenerNames() throws MBeanException { Container container = doGetManagedResource(); List<String> result = new ArrayList<>();",
        "ins1PreCode":"public String[] findLifecycleListenerNames() throws MBeanException { Container container = null; List<String> result = new ArrayList<>();  try { container = (Container) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e); } catch (RuntimeOperationsException e) { throw new MBeanException(e); } catch (InvalidTargetObjectTypeException e) { throw new MBeanException(e); }",
        "ins2PreCode":"public String[] findContainerListenerNames() throws MBeanException { Container container = null; List<String> result = new ArrayList<>();  try { container = (Container) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e); } catch (RuntimeOperationsException e) { throw new MBeanException(e); } catch (InvalidTargetObjectTypeException e) { throw new MBeanException(e); }",
        "label":1
    },
    {
        "ins1CurCode":"}  Collection<Marker> markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { for (Marker marker : markers) { r.drawRangeMarker(g2, this, axis, marker, dataArea);",
        "ins1PreCode":"}  Collection markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next(); r.drawRangeMarker(g2, this, axis, marker, dataArea);",
        "ins2PreCode":"}  Collection markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) {",
        "label":0
    },
    {
        "ins1CurCode":"public void interruptWait() { BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<>(128); ",
        "ins1PreCode":"public void interruptWait() { BlockingFlowableIterator<Integer> it = new BlockingFlowableIterator<Integer>(128); ",
        "ins2PreCode":"public void interruptWait() { BlockingObservableIterator<Integer> it = new BlockingObservableIterator<Integer>(128); ",
        "label":1
    },
    {
        "ins1CurCode":"{ IssueManagement src = source.getIssueManagement(); if ( src != null ) {",
        "ins1PreCode":"{ IssueManagement src = source.getIssueManagement(); if ( source.getIssueManagement() != null ) {",
        "ins2PreCode":"{ CiManagement src = source.getCiManagement(); if ( source.getCiManagement() != null ) {",
        "label":1
    },
    {
        "ins1CurCode":"+ \"do not exist.\", String.join( \", \", notFoundOptionalProfiles ) ); logger.info( message ); }",
        "ins1PreCode":"+ \"do not exist.\", String.join( \", \", notFoundOptionalProfiles ) ); logger.warn( message ); }",
        "ins2PreCode":"private void validateRequiredProfiles( MavenSession session, ProfileActivation profileActivation ) { final Set<String> allAvailableProfiles = getAllProfiles( session );  final Set<String> requiredProfiles = new HashSet<>( ); requiredProfiles.addAll( profileActivation.getRequiredActiveProfileIds() ); requiredProfiles.addAll( profileActivation.getRequiredInactiveProfileIds() );   final Set<String> notFoundRequiredProfiles = requiredProfiles.stream() .filter( rap -> !allAvailableProfiles.contains( rap ) ) .collect( toSet() );  if ( !notFoundRequiredProfiles.isEmpty() ) { final String message = String.format( \"The requested profiles [%s] could not be activated or deactivated because they do not exist.\", String.join( \", \", notFoundRequiredProfiles ) ); addExceptionToResult( session.getResult(), new MissingProfilesException( message ) ); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testSingle12() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb; q =\\t1\\t\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q1_000, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testSingle12() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.500\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testSingle13() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5009\")); ",
        "label":0
    },
    {
        "ins1CurCode":"void parseRecognizesEntryWithWhitespace() throws IOException { ParserResult result = parser",
        "ins1PreCode":"public void parseRecognizesEntryWithWhitespace() throws IOException { ParserResult result = parser",
        "ins2PreCode":"public void parseRecognizesEntryWithNewlines() throws IOException { ParserResult result = parser",
        "label":1
    },
    {
        "ins1CurCode":"s1.add(3.0, 3.0); s1.add(2.0, 2.0); assertEquals(0, s1.indexOf(1.0)); assertEquals(1, s1.indexOf(3.0)); assertEquals(2, s1.indexOf(2.0));",
        "ins1PreCode":"s1.add(3.0, 3.0); s1.add(2.0, 2.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(3.0))); assertEquals(2, s1.indexOf(new Double(2.0)));",
        "ins2PreCode":"s1.add(2.0, 2.0); s1.add(2.0, 3.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(2.0)));",
        "label":0
    },
    {
        "ins1CurCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() +",
        "ins1PreCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfigurationBuilder.create().build(), new URI(\"ftp://localhost:\" + getPort() +",
        "ins2PreCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfigurationBuilder.create().build(), new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":1
    },
    {
        "ins1CurCode":" BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"Peptidomics of the larval {\\\\protect{{D}rosophila melanogaster}} central nervous system.\"); ",
        "ins1PreCode":" BibEntry entry = new BibEntry(); entry.setField(\"title\", \"Peptidomics of the larval {\\\\protect{{D}rosophila melanogaster}} central nervous system.\"); ",
        "ins2PreCode":" BibEntry entry = new BibEntry(); entry.setField(\"title\", \"Insect neuropeptide bursicon homodimers induce innate immune and stress genes during molting by activating the {NF}-$\\\\kappa$B transcription factor Relish.\"); ",
        "label":1
    },
    {
        "ins1CurCode":"); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.append( key,",
        "ins1PreCode":"); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key,",
        "ins2PreCode":"); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key,",
        "label":1
    },
    {
        "ins1CurCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValuesUsingAccessors(sourceBuilder); TestMap source = sourceBuilder.build();",
        "ins1PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValuesUsingMutableMap(sourceBuilder); TestMap source = sourceBuilder.build();",
        "ins2PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValues(sourceBuilder); TestMap source = sourceBuilder.build(); assertMapValuesSet(source);  TestMap.Builder destination = TestMap.newBuilder(); copyMapValues(source, destination); assertMapValuesSet(destination.build());",
        "label":0
    },
    {
        "ins1CurCode":"} } } catch (Exception e) { monitor.subTask(\"Error refreshing job state \" + e.getMessage());",
        "ins1PreCode":"} } } catch (SQLException e) { monitor.subTask(\"Error refreshing job state \" + e.getMessage());",
        "ins2PreCode":"public String getObjectDefinitionText(DBRProgressMonitor monitor, Map<String, Object> options) throws DBException { if (jobAction == null && monitor != null) { monitor.beginTask(\"Load action for '\" + this.getName() + \"'...\", 1); try (final JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Load action for \" + OracleObjectType.JOB + \" '\" + this.getName() + \"'\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT JOB_ACTION FROM \" + OracleUtils.getSysSchemaPrefix(getDataSource()) + \"ALL_SCHEDULER_JOBS \" + \"WHERE OWNER=? AND JOB_NAME=? \")) { dbStat.setString(1, getOwner() ); dbStat.setString(2, getName()); dbStat.setFetchSize(DBConstants.METADATA_FETCH_SIZE); try (JDBCResultSet dbResult = dbStat.executeQuery()) { StringBuilder action = null; int lineCount = 0; while (dbResult.next()) { if (monitor.isCanceled()) { break; } final String line = dbResult.getString(1); if (action == null) { action = new StringBuilder(4000); } action.append(line); lineCount++; monitor.subTask(\"Line \" + lineCount); } if (action != null) { jobAction = action.toString(); } } } catch (SQLException e) { throw new DBCException(e, session.getExecutionContext()); } } finally { monitor.done(); } } return jobAction;",
        "label":0
    },
    {
        "ins1CurCode":".retry(retry5);  FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<>(subscriber); ",
        "ins1PreCode":".retry(retry5);  FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber); ",
        "ins2PreCode":"Flowable<Long> f = Flowable.unsafeCreate(so).retry(5);  AsyncSubscriber<Long> async = new AsyncSubscriber<Long>(subscriber); ",
        "label":1
    },
    {
        "ins1CurCode":"graph.putEdgeValue(4, 4, \"valueD\");  assertThat(graph.edgeValueOrNull(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValueOrNull(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrNull(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrNull(4, 4)).isEqualTo(\"valueD\"); ",
        "ins1PreCode":"graph.putEdgeValue(4, 4, \"valueD\");  assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\"); ",
        "ins2PreCode":"graph.putEdgeValue(4, 4, \"valueD\");  assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\"); ",
        "label":1
    },
    {
        "ins1CurCode":"int users = 80; int products = 160; Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); ",
        "ins1PreCode":"int users = 80; int products = 160; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); ",
        "ins2PreCode":"int users = 100; int products = 200; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); ",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); ",
        "ins2PreCode":"TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true); ",
        "label":0
    },
    {
        "ins1CurCode":"public void testWebapp_2_2() throws Exception { File appDir = new File(\"test/webapp-2.2\"); JspCServletContext context = new JspCServletContext( null, appDir.toURI().toURL(), null, false, false); Assert.assertEquals(2, context.getEffectiveMajorVersion());",
        "ins1PreCode":"public void testWebapp_2_2() throws Exception { File appDir = new File(\"test/webapp-2.2\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion());",
        "ins2PreCode":"public void testWebapp_2_3() throws Exception { File appDir = new File(\"test/webapp-2.3\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion());",
        "label":1
    },
    {
        "ins1CurCode":"public void testHash1() throws Exception { CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() { @Override public int next(int n) {",
        "ins1PreCode":"public void testHash1() throws Exception { CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() { public int next(int n) { return n-1;",
        "ins2PreCode":"public void testHash2() throws Exception { CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() { public int next(int n) { return 1;",
        "label":1
    },
    {
        "ins1CurCode":"User user = mapper.getUser(1); user.equals(null); assertEquals(3, user.setterCounter); } finally {",
        "ins1PreCode":"User user = mapper.getUser(1); user.equals(null); assertEquals(3, user.lazyLoadCounter); } finally {",
        "ins2PreCode":"User user = mapper.getUser(1); user.clone(); assertEquals(3, user.lazyLoadCounter); } finally {",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"public void testDBCPThreads20Connections10() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.threadcount = 20;",
        "ins1PreCode":"public void testDBCPThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testPoolThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":"void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"), false)) { assertThat(this.archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(this.archive); assertThat(entries.size()).isEqualTo(3);",
        "ins1PreCode":"public void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), false); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(3);",
        "ins2PreCode":"public void getNonRecursiveManifest() throws Exception { ExplodedArchive archive = new ExplodedArchive( new File(\"src/test/resources/root\")); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(4);",
        "label":0
    },
    {
        "ins1CurCode":"void shouldInsertArrayValue() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldInsertArrayValue() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldInsertNullValue() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/wo-plugin-mgmt/sub\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() );",
        "ins1PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/wo-plugin-mngt/sub\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() );",
        "ins2PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/w-plugin-mngt/sub\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() );",
        "label":1
    },
    {
        "ins1CurCode":"String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: sc.read(netInBuffer, socket, handshakeReadCompletionHandler); return 1; case UNDERFLOW:  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniDefault\")); } hostName = endpoint.getDefaultSSLHostConfigName(); clientRequestedCiphers = Collections.emptyList(); break; }  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); }  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers, clientRequestedApplicationProtocols); ",
        "ins1PreCode":"}  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers); ",
        "ins2PreCode":"}  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers); ",
        "label":1
    },
    {
        "ins1CurCode":"descriptor.paramWith = \"a,b\";  JenkinsRule.WebClient wc = j.createWebClient() .withThrowExceptionOnFailingStatusCode(false); HtmlPage p = wc.goTo(\"test\");",
        "ins1PreCode":"descriptor.paramWith = \"a,b\";  JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); HtmlPage p = wc.goTo(\"test\");",
        "ins2PreCode":"descriptor.paramWith = \"a,b',document.title='hacked'+'\";  JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); HtmlPage p = wc.goTo(\"test\");",
        "label":1
    },
    {
        "ins1CurCode":"public void unbind(Name name) throws NamingException {  if (!checkWritable()) { return; }",
        "ins1PreCode":"public void unbind(Name name) throws NamingException { checkWritable(); ",
        "ins2PreCode":"public void destroySubcontext(Name name) throws NamingException {  checkWritable(); ",
        "label":1
    },
    {
        "ins1CurCode":"List<TokenFilterFactory> previousTokenFilters, Function<String, TokenFilterFactory> allFilters) { final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters, allFilters); final SynonymMap synonyms = buildSynonyms(analyzer, getRulesFromSettings(environment)); final String name = name(); return new TokenFilterFactory() { @Override public String name() { return name; }  @Override public TokenStream create(TokenStream tokenStream) { return synonyms.fst == null ? tokenStream : new SynonymFilter(tokenStream, synonyms, false); }  @Override public TokenFilterFactory getSynonymFilter() {    return IDENTITY_FILTER; }",
        "ins1PreCode":"List<TokenFilterFactory> previousTokenFilters, Function<String, TokenFilterFactory> allFilters) { final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters); final SynonymMap synonyms = buildSynonyms(analyzer, getRulesFromSettings(environment));",
        "ins2PreCode":"List<TokenFilterFactory> previousTokenFilters, Function<String, TokenFilterFactory> allFilters) { final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters); final SynonymMap synonyms = buildSynonyms(analyzer, getRulesFromSettings(environment));",
        "label":0
    },
    {
        "ins1CurCode":"if (params != null) { for (Parameter param : params) { final String paramName = param.getName(); if (LINES_KEY.equals(paramName)) { lines = Long.parseLong(param.getValue()); } else if (SKIP_KEY.equals(paramName)) { skip = Long.parseLong(param.getValue());",
        "ins1PreCode":"if (params != null) { for (Parameter param : params) { if (LINES_KEY.equals(param.getName())) { lines = Long.parseLong(param.getValue()); continue; } if (SKIP_KEY.equals(param.getName())) { skip = Long.parseLong(param.getValue()); continue; }",
        "ins2PreCode":"if (params != null) { for (Parameter param : params) { if (LINES_KEY.equals(param.getName())) { setLines(Long.parseLong(param.getValue())); continue; } if (SKIP_KEY.equals(param.getName())) { skip = Long.parseLong(param.getValue()); continue; }",
        "label":1
    },
    {
        "ins1CurCode":"try { panel.getDatabase().addString(string); undoEdit.addEdit(new UndoableInsertString(panel.getDatabase(), string)); } catch (KeyCollisionException ex) {",
        "ins1PreCode":"try { panel.getDatabase().addString(string); undoEdit.addEdit(new UndoableInsertString(panel, panel.getDatabase(), string)); } catch (KeyCollisionException ex) {",
        "ins2PreCode":"try { panel.getDatabase().removeString(inMem.getId()); undoEdit.addEdit(new UndoableRemoveString(panel, panel.getDatabase(), string)); } catch (Exception ex) {",
        "label":1
    },
    {
        "ins1CurCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<>(); List<Flowable<Integer>> sourceList = new ArrayList<>(i); Set<Integer> expected = new HashSet<>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<>(ts.values()); ",
        "ins1PreCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(ts.values()); ",
        "ins2PreCode":"break; } TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i - 1).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(ts.values()); ",
        "label":1
    },
    {
        "ins1CurCode":"this.logger.debug(\"testatdebug\"); this.logger.error(\"testaterror\"); assertThat(this.output.toString()).doesNotContain(\"testatdebug\").doesNotContain(\"testaterror\");",
        "ins1PreCode":"this.logger.debug(\"testatdebug\"); this.logger.error(\"testaterror\"); assertThat(this.outputCapture.toString()).doesNotContain(\"testatdebug\").doesNotContain(\"testaterror\");",
        "ins2PreCode":"this.logger.debug(\"testatdebug\"); this.logger.error(\"testaterror\"); assertThat(this.outputCapture.toString()).doesNotContain(\"testatdebug\").doesNotContain(\"testaterror\");",
        "label":1
    },
    {
        "ins1CurCode":"if ( tgt == null ) { tgt = new DeploymentRepository(); target.setRepository( tgt ); mergeDeploymentRepository( tgt, src, sourceDominant, context );",
        "ins1PreCode":"if ( tgt == null ) { target.setRepository( tgt = new DeploymentRepository() ); mergeDeploymentRepository( tgt, src, sourceDominant, context );",
        "ins2PreCode":"if ( tgt == null ) { target.setSnapshotRepository( tgt = new DeploymentRepository() ); mergeDeploymentRepository( tgt, src, sourceDominant, context );",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such item \u2018never_created\u2019 exists.\"));",
        "ins1PreCode":"assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such job \\u2018never_created\\u2019 exists.\"));",
        "ins2PreCode":"@Test public void connectNodeShouldFailIfNodeDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Computer.CONNECT, Jenkins.READ) .invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "label":0
    },
    {
        "ins1CurCode":"public void parse(final Object multiplicityOwner, final String text) { try { setMultiplicity(multiplicityOwner, text); } catch (ParseException pe) {",
        "ins1PreCode":"public void parse(final Object multiplicityOwner, final String text) { try { parseMultiplicity(multiplicityOwner, text); } catch (ParseException pe) {",
        "ins2PreCode":"public void parse(Object modelElement, String text) { try { NotationUtilityUml.parseModelElement(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.node-modelelement\"; Object[] args = { pe.getLocalizedMessage(), Integer.valueOf(pe.getErrorOffset()), }; ArgoEventPump.fireEvent(new ArgoHelpEvent( ArgoEventTypes.HELP_CHANGED, this, Translator.messageFormat(msg, args))); }",
        "label":0
    },
    {
        "ins1CurCode":"plot.setNotify(false);  Point2D zoomPoint = this.selectionZoomStrategy.getZoomPoint(); Point2D zp = zoomPoint != null ? zoomPoint : new Point(); z.zoomDomainAxes(0.0, this.info.getPlotInfo(), zp);",
        "ins1PreCode":"plot.setNotify(false);  Point2D zp = (this.zoomPoint != null ? this.zoomPoint : new Point()); z.zoomDomainAxes(0.0, this.info.getPlotInfo(), zp);",
        "ins2PreCode":"plot.setNotify(false);  Point2D zp = (this.zoomPoint != null ? this.zoomPoint : new Point()); z.zoomRangeAxes(0.0, this.info.getPlotInfo(), zp);",
        "label":1
    },
    {
        "ins1CurCode":"ap.onNext(3); ap.onComplete(); TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ap.subscribe(to);",
        "ins1PreCode":"ap.onNext(3); ap.onComplete(); TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ap.subscribe(to);",
        "ins2PreCode":"public void failFastMultipleEvents() { UnicastSubject<Integer> ap = UnicastSubject.create(false); ap.onNext(1); ap.onNext(2); ap.onNext(3); ap.onComplete(); TestObserver<Integer> to = TestObserver.create(); ap.subscribe(to);  to .assertValueCount(3) .assertComplete();",
        "label":0
    },
    {
        "ins1CurCode":"public void mergeALotOfSourcesOneByOneSynchronouslyTakeHalf() { int n = 10000; List<Flowable<Integer>> sourceList = new ArrayList<>(n); for (int i = 0; i < n; i++) {",
        "ins1PreCode":"public void mergeALotOfSourcesOneByOneSynchronouslyTakeHalf() { int n = 10000; List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(n); for (int i = 0; i < n; i++) {",
        "ins2PreCode":"public void mergeALotOfSourcesOneByOneSynchronouslyTakeHalf() { int n = 10000; List<Observable<Integer>> sourceList = new ArrayList<Observable<Integer>>(n); for (int i = 0; i < n; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"touchFile.delete();  assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );  file.getParentFile().mkdirs(); file.createNewFile(); updateCheckManager.touch( a, remoteRepository );  assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );  assertNull( updateCheckManager.readLastUpdated( touchFile, updateCheckManager.getRepositoryKey( remoteRepository ) ) ); ",
        "ins1PreCode":"touchFile.delete();  assertTrue( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) );  file.getParentFile().mkdirs(); file.createNewFile(); updateCheckManager.touch( a, remoteRepository );  assertFalse( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) );  assertNull( updateCheckManager.readLastUpdated( touchFile, remoteRepository.getId() ) ); ",
        "ins2PreCode":"touchFile.delete();  assertTrue( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) );  updateCheckManager.touch( a, remoteRepository );  assertFalse( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) );  assertFalse( file.exists() ); assertNotNull( updateCheckManager.readLastUpdated( touchFile, remoteRepository.getId() ) );",
        "label":1
    },
    {
        "ins1CurCode":"String bearerPrefix = \"bearer \"; if (authorization == null || !authorization.toLowerCase(Locale.ENGLISH).startsWith(bearerPrefix)) { throw new CloudFoundryAuthorizationException(Reason.MISSING_AUTHORIZATION,",
        "ins1PreCode":"String bearerPrefix = \"bearer \"; if (authorization == null || !authorization.toLowerCase().startsWith(bearerPrefix)) { throw new CloudFoundryAuthorizationException(Reason.MISSING_AUTHORIZATION,",
        "ins2PreCode":"String bearerPrefix = \"bearer \"; if (authorization == null || !authorization.toLowerCase().startsWith(bearerPrefix)) { throw new CloudFoundryAuthorizationException(Reason.MISSING_AUTHORIZATION,",
        "label":1
    },
    {
        "ins1CurCode":"void parseLevelsNone() { addPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=OFF\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.error(\"testaterror\"); assertThat(this.output).doesNotContain(\"testatdebug\").doesNotContain(\"testaterror\");",
        "ins1PreCode":"public void parseLevelsNone() { addPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=OFF\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.error(\"testaterror\"); assertThat(this.output.toString()).doesNotContain(\"testatdebug\").doesNotContain(\"testaterror\");",
        "ins2PreCode":"public void parseLevelsMapsFalseToOff() { addPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=false\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.error(\"testaterror\"); assertThat(this.output.toString()).doesNotContain(\"testatdebug\").doesNotContain(\"testaterror\");",
        "label":1
    },
    {
        "ins1CurCode":"final ExasolTableForeignKey constraint = command.getObject();  if (command.getProperties().containsKey(DBConstants.PROP_ID_ENABLED)) { actionList.add(",
        "ins1PreCode":"final ExasolTableForeignKey constraint = command.getObject();  if (command.getProperties().containsKey(\"enabled\")) { actionList.add(",
        "ins2PreCode":"final ExasolTableUniqueKey constraint = command.getObject();  if (command.getProperties().containsKey(\"enabled\")) {",
        "label":1
    },
    {
        "ins1CurCode":"protected void start(PrintWriter writer, String name) {  if (debug >= 1) { log(sm.getString(\"hostManagerServlet.start\", name)); }",
        "ins1PreCode":"protected void start(PrintWriter writer, String name) {  if (debug >= 1) log(\"start: Starting host with name '\" + name + \"'\"); ",
        "ins2PreCode":"protected void stop(PrintWriter writer, String name) {  if (debug >= 1) log(\"stop: Stopping host with name '\" + name + \"'\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.range(0, 100000)",
        "ins1PreCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(0, 100000)",
        "ins2PreCode":"public void backpressure() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(0, 100000)",
        "label":1
    },
    {
        "ins1CurCode":"throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.shape = SerialUtils.readShape(stream); this.stroke = SerialUtils.readStroke(stream); this.outlinePaint = SerialUtils.readPaint(stream); this.fillPaint = SerialUtils.readPaint(stream);",
        "ins1PreCode":"throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.shape = SerialUtilities.readShape(stream); this.stroke = SerialUtilities.readStroke(stream); this.outlinePaint = SerialUtilities.readPaint(stream); this.fillPaint = SerialUtilities.readPaint(stream);",
        "ins2PreCode":"throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.noDataMessagePaint = SerialUtilities.readPaint(stream); this.outlineStroke = SerialUtilities.readStroke(stream); this.outlinePaint = SerialUtilities.readPaint(stream);  this.backgroundPaint = SerialUtilities.readPaint(stream); ",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValuePredicateEmpty() { assertThrows(\"No values\", AssertionError.class, () -> { TestSubscriberEx<Object> ts = new TestSubscriberEx<>();",
        "ins1PreCode":"Flowable.empty().subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); ts.assertValue(new Predicate<Object>() {",
        "ins2PreCode":"Flowable.empty().subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); ts.assertValueAt(0, new Predicate<Object>() {",
        "label":1
    },
    {
        "ins1CurCode":"BiFunction<? super T, ? super Observable<TRight>, ? extends R> resultSelector ) { Objects.requireNonNull(other, \"other is null\"); Objects.requireNonNull(leftEnd, \"leftEnd is null\"); Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(",
        "ins1PreCode":"BiFunction<? super T, ? super Observable<TRight>, ? extends R> resultSelector ) { ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(",
        "ins2PreCode":"Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) { ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(",
        "label":1
    },
    {
        "ins1CurCode":"T item = supplier.get(); if (item != null) { cs = Objects.requireNonNull(mapper.apply(item), \"The mapper returned a null CompletableSource\"); }",
        "ins1PreCode":"T item = supplier.get(); if (item != null) { cs = ObjectHelper.requireNonNull(mapper.apply(item), \"The mapper returned a null CompletableSource\"); }",
        "ins2PreCode":"T item = supplier.get(); if (item != null) { cs = ObjectHelper.requireNonNull(mapper.apply(item), \"The mapper returned a null MaybeSource\"); }",
        "label":1
    },
    {
        "ins1CurCode":"final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.get(i); ",
        "ins1PreCode":"final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i); ",
        "ins2PreCode":"final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i); ",
        "label":1
    },
    {
        "ins1CurCode":"{ case 110: return jjMoveStringLiteralDfa6_1(active0, 0x80000000000L); default :",
        "ins1PreCode":"{ case 110: return jjMoveStringLiteralDfa6_1(active0, 0x40000000000L); default :",
        "ins2PreCode":"{ case 99: return jjMoveStringLiteralDfa7_1(active0, 0x40000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"public void sync() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.getBuildersList().add(Functions.isWindows() ? new BatchFile(\"ping 127.0.0.1\") : new Shell(\"sleep 3\"));  assertThat(new CLICommandInvoker(j, new BuildCommand()).invokeWithArgs(\"-s\", p.getName()), CLICommandInvoker.Matcher.succeeded()); assertFalse(p.getBuildByNumber(1).isBuilding());",
        "ins1PreCode":"public void sync() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.getBuildersList().add(new Shell(\"sleep 3\"));  try (CLI cli = new CLI(j.getURL())) { cli.execute(\"build\", \"-s\", p.getName()); assertFalse(p.getBuildByNumber(1).isBuilding());",
        "ins2PreCode":"public void syncWOutputStreaming() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.getBuildersList().add(new Shell(\"sleep 3\"));  try (CLI cli = new CLI(j.getURL())) { cli.execute(\"build\", \"-s\", \"-v\", \"-r\", \"5\", p.getName()); assertFalse(p.getBuildByNumber(1).isBuilding());",
        "label":1
    },
    {
        "ins1CurCode":"public void testNested4() { thrown.expect(BuildException.class); thrown.expectMessage(\"Nested conditions not permitted in conjunction with if/unless attributes\"); ",
        "ins1PreCode":"public void testNested4() { String specificMessage = \"Nested conditions \" + \"not permitted in conjunction with if/unless attributes\";  StringBuilder target = new StringBuilder(\"testNested4x\"); for (char ch : Arrays.asList('a', 'b', 'c')) { target.setCharAt(target.length() - 1, ch); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\"); } catch (BuildException ex) { assertEquals(specificMessage, ex.getMessage()); }",
        "ins2PreCode":"public void testNested7() { String specificMessage = \"A single nested condition is required.\";  StringBuilder target = new StringBuilder(\"testNested7x\"); for (char ch : Arrays.asList('a', 'b')) { target.setCharAt(target.length() - 1, ch); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\"); } catch (BuildException ex) { assertEquals(specificMessage, ex.getMessage()); }",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void setBuildDescriptionShouldFailIfJobDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Run.UPDATE, Item.READ, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "ins1PreCode":"@Test public void setBuildDescriptionShouldFailIfJobDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Run.UPDATE, Job.READ, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.DELETE, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "label":0
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toFlowable();  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"aa\");",
        "ins1PreCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toFlowable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\");",
        "ins2PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "label":1
    },
    {
        "ins1CurCode":"public void orderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<>(0); Disposable d = Disposable.empty();",
        "ins1PreCode":"public void orderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposable.empty();",
        "ins2PreCode":"public void unorderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1CurCode":"  final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<>()); final List<Thread> threads = Collections.synchronizedList(new ArrayList<>());  for (int i = 1; i <= 200; i++) { final int count = i; if (count == 20) {   source.start(); } if (count == 100) {  source.join(); } Thread t = new Thread(new Runnable() {  @Override public void run() { List<Long> values = replay.toList().blockingGet(); listOfListsOfValues.add(values); System.out.println(\"Finished thread: \" + count); } }); t.start(); System.out.println(\"Started thread: \" + i); threads.add(t); }   for (Thread t : threads) { t.join(); }   List<Long> sums = new ArrayList<>(); for (List<Long> values : listOfListsOfValues) {",
        "ins1PreCode":"  final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>()); final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());  for (int i = 1; i <= 200; i++) { final int count = i; if (count == 20) {   source.start(); } if (count == 100) {  source.join(); } Thread t = new Thread(new Runnable() {  @Override public void run() { List<Long> values = replay.toList().blockingGet(); listOfListsOfValues.add(values); System.out.println(\"Finished thread: \" + count); } }); t.start(); System.out.println(\"Started thread: \" + i); threads.add(t); }   for (Thread t : threads) { t.join(); }   List<Long> sums = new ArrayList<Long>(); for (List<Long> values : listOfListsOfValues) {",
        "ins2PreCode":"  final List<List<Long>> listOfListsOfValues = Collections.synchronizedList(new ArrayList<List<Long>>()); final List<Thread> threads = Collections.synchronizedList(new ArrayList<Thread>());  for (int i = 1; i <= 200; i++) { final int count = i; if (count == 20) {   source.start(); } if (count == 100) {  source.join(); } Thread t = new Thread(new Runnable() {  @Override public void run() { List<Long> values = replay.toList().blockingGet(); listOfListsOfValues.add(values); System.out.println(\"Finished thread: \" + count); } }); t.start(); System.out.println(\"Started thread: \" + i); threads.add(t); }   for (Thread t : threads) { t.join(); }   List<Long> sums = new ArrayList<Long>(); for (List<Long> values : listOfListsOfValues) {",
        "label":1
    },
    {
        "ins1CurCode":"rrset.addRR(txt); rrset.addRR(rrsig); DNSSEC.verify(rrset, rrsig, dnskey, Instant.ofEpochMilli(60));",
        "ins1PreCode":"rrset.addRR(txt); rrset.addRR(rrsig); DNSSEC.verify(rrset, rrsig, dnskey, new Date(60));",
        "ins2PreCode":"set.addRR(txt); set.addRR(rrsig); DNSSEC.verify(set, rrsig, dnskey, new Date(60));",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerialization() { DefaultBoxAndWhiskerXYDataset<String> d1 = new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0,",
        "ins1PreCode":"public void testSerialization() { DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0,",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = CloneUtils.clone(d1); assertTrue(d1 != d2);",
        "label":1
    },
    {
        "ins1CurCode":"PublishProcessor<Object> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"PublishProcessor<Object> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"PublishProcessor<Object> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void onNextError() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<>(); Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);",
        "ins1PreCode":"public void onNextError() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>(); Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);",
        "ins2PreCode":"public void onNextErrorAcrossThread() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>(); Flowable<Long> f = Flowable.interval(50, TimeUnit.MILLISECONDS);",
        "label":1
    },
    {
        "ins1CurCode":"void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class)",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class)",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "label":1
    },
    {
        "ins1CurCode":"HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { SecurityContext context = SecurityContextHolder.createEmptyContext(); context.setAuthentication(new UsernamePasswordAuthenticationToken( \"Alice\", \"secret\", Arrays.asList(new SimpleGrantedAuthority(\"ROLE_ACTUATOR\")))); SecurityContextHolder.setContext(context); try { filterChain.doFilter(new SecurityContextHolderAwareRequestWrapper( request, \"ROLE_\"), response); } finally { SecurityContextHolder.clearContext(); }",
        "ins1PreCode":"HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { filterChain.doFilter(new HttpServletRequestWrapper(request) {  @Override public Principal getUserPrincipal() {  return new Principal() {  @Override public String getName() { return \"Alice\"; }  };  }  }, response); }",
        "ins2PreCode":"HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException { filterChain.doFilter(new HttpServletRequestWrapper(request) {  @Override public Principal getUserPrincipal() {  return new Principal() {  @Override public String getName() { return \"Alice\"; }  };  }  }, response); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerialization() { TimeSeries<String> s1 = new TimeSeries<>(\"A test\"); s1.add(new Year(2000), 13.75); s1.add(new Year(2001), 11.90); s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimeSeries<String> s2 = TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "ins1PreCode":"public void testSerialization() { TimeSeries s1 = new TimeSeries(\"A test\"); s1.add(new Year(2000), 13.75); s1.add(new Year(2001), 11.90); s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimeSeries s2 = TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "ins2PreCode":"public void testSerialization() { TimePeriodValues s1 = new TimePeriodValues(\"A test\"); s1.add(new Year(2000), 13.75); s1.add(new Year(2001), 11.90); s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimePeriodValues s2 = TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "label":1
    },
    {
        "ins1CurCode":"void responseIsCommittedWhenExceptionIsThrownDuringAsyncDispatch() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "ins1PreCode":"public void responseIsCommittedWhenExceptionIsThrownDuringAsyncDispatch() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "ins2PreCode":"public void responseIsCommittedWhenStatusIs400PlusDuringAsyncDispatch() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\"));",
        "label":1
    },
    {
        "ins1CurCode":"this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins1PreCode":"this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, this.interceptors);",
        "ins2PreCode":"this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, Collections.unmodifiableSet(new LinkedHashSet<>(interceptors)));",
        "label":1
    },
    {
        "ins1CurCode":"public void getSearchBasedFetchersReturnsAllFetcherDerivingFromSearchBasedFetcher() throws Exception { List<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences);  Set<Class<? extends SearchBasedFetcher>> expected = reflections.getSubTypesOf(SearchBasedFetcher.class); expected.remove(SearchBasedParserFetcher.class); assertEquals(expected, getClasses(searchBasedFetchers));",
        "ins1PreCode":"public void getSearchBasedFetchersReturnsAllFetcherDerivingFromSearchBasedFetcher() throws Exception { List<SearchBasedFetcher> idFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences);  Set<Class<? extends SearchBasedFetcher>> expected = reflections.getSubTypesOf(SearchBasedFetcher.class); expected.remove(SearchBasedParserFetcher.class); assertEquals(expected, getClasses(idFetchers));",
        "ins2PreCode":"public void getIdBasedFetchersReturnsAllFetcherDerivingFromIdBasedFetcher() throws Exception { List<IdBasedFetcher> idFetchers = WebFetchers.getIdBasedFetchers(importFormatPreferences);  Set<Class<? extends IdBasedFetcher>> expected = reflections.getSubTypesOf(IdBasedFetcher.class); expected.remove(AbstractIsbnFetcher.class); expected.remove(IdBasedParserFetcher.class);  expected.remove(IsbnViaChimboriFetcher.class); expected.remove(IsbnViaEbookDeFetcher.class); assertEquals(expected, getClasses(idFetchers));",
        "label":0
    },
    {
        "ins1CurCode":"public void interrupt() throws InterruptedException { final AtomicReference<Object> exception = new AtomicReference<>(); final CountDownLatch latch = new CountDownLatch(1);",
        "ins1PreCode":"public void interrupt() throws InterruptedException { final AtomicReference<Object> exception = new AtomicReference<Object>(); final CountDownLatch latch = new CountDownLatch(1);",
        "ins2PreCode":"public void interrupt() throws InterruptedException { final AtomicReference<Object> exception = new AtomicReference<Object>(); final CountDownLatch latch = new CountDownLatch(1);",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final ExasolTableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1CurCode":"protected void fireTreeNodesChanged( final Object source, final Object[] path, final int[] childIndices, final Object[] children) { ",
        "ins1PreCode":"protected void fireTreeNodesChanged( Object source, Object[] path, int[] childIndices, Object[] children) { ",
        "ins2PreCode":"protected void fireTreeNodesInserted( Object source, Object[] path, int[] childIndices, Object[] children) {   Object[] listeners = listenerList.getListenerList(); TreeModelEvent e = null;   for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == TreeModelListener.class) {  if (e == null) e = new TreeModelEvent( source, path, childIndices, children); ((TreeModelListener) listeners[i + 1]).treeNodesInserted(e); } }",
        "label":0
    },
    {
        "ins1CurCode":"d1.addSeries(\"S1\", data1); XYBarDataset bd1 = new XYBarDataset(d1, 5.0); XYBarDataset bd2 = (XYBarDataset) TestUtils.serialised(bd1); assertEquals(bd1, bd2);",
        "ins1PreCode":"d1.addSeries(\"S1\", data1); XYBarDataset bd1 = new XYBarDataset(d1, 5.0); XYBarDataset bd2 = (XYBarDataset) TestUtilities.serialised(bd1); assertEquals(bd1, bd2);",
        "ins2PreCode":"public void testPublicCloneable() { DefaultXYDataset d1 = new DefaultXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[][] data1 = new double[][] {x1, y1}; d1.addSeries(\"S1\", data1); XYBarDataset bd1 = new XYBarDataset(d1, 5.0); assertTrue(bd1 instanceof PublicCloneable);",
        "label":0
    },
    {
        "ins1CurCode":"{ case 101: return jjMoveStringLiteralDfa8_2(active0, 0x100000000000L); default :",
        "ins1PreCode":"{ case 101: return jjMoveStringLiteralDfa8_2(active0, 0x80000000000L); default :",
        "ins2PreCode":"{ case 111: return jjMoveStringLiteralDfa9_2(active0, 0x80000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(1, client().prepareGet(\"test\", \"4\").get().getVersion());  int slices = randomSlices(2, 10); int expectedSlices = expectedSliceStatuses(slices, \"test\");   assertThat( updateByQuery() .source(\"test\") .refresh(true) .setSlices(slices).get(), matcher() .updated(4) .slices(hasSize(expectedSlices))); assertEquals(2, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());   assertThat( updateByQuery() .source(\"test\") .filter(termQuery(\"foo\", \"no_match\")) .setSlices(slices) .refresh(true).get(), matcher() .updated(0) .slices(hasSize(expectedSlices))); assertEquals(2, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());   assertThat( updateByQuery() .source(\"test\") .filter(termQuery(\"foo\", \"a\")) .refresh(true) .setSlices(slices).get(), matcher() .updated(2) .slices(hasSize(expectedSlices))); assertEquals(3, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"2\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());",
        "ins1PreCode":"client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(1, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());  int slices = randomSlices(2, 10); int expectedSlices = expectedSliceStatuses(slices, \"test\");   assertThat( updateByQuery() .source(\"test\") .refresh(true) .setSlices(slices).get(), matcher() .updated(4) .slices(hasSize(expectedSlices))); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat( updateByQuery() .source(\"test\") .filter(termQuery(\"foo\", \"no_match\")) .setSlices(slices) .refresh(true).get(), matcher() .updated(0) .slices(hasSize(expectedSlices))); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat( updateByQuery() .source(\"test\") .filter(termQuery(\"foo\", \"a\")) .refresh(true) .setSlices(slices).get(), matcher() .updated(2) .slices(hasSize(expectedSlices))); assertEquals(3, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"test\", \"2\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());",
        "ins2PreCode":"client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(1, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").refresh(true).get(), matcher().updated(4)); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").filter(termQuery(\"foo\", \"no_match\")).refresh(true).get(), matcher().updated(0)); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").filter(termQuery(\"foo\", \"a\")).refresh(true).get(), matcher().updated(2)); assertEquals(3, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"test\", \"2\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   UpdateByQueryRequestBuilder request = updateByQuery().source(\"test\").size(3).refresh(true); request.source().addSort(\"foo.keyword\", SortOrder.ASC); assertThat(request.get(), matcher().updated(3));  assertEquals(4, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(4, client().prepareGet(\"test\", \"test\", \"2\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());",
        "label":0
    },
    {
        "ins1CurCode":" try { TestDisposableObserver<Integer> tc = new TestDisposableObserver<>(); ",
        "ins1PreCode":" try { TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>(); ",
        "ins2PreCode":"public void startOnce() {  List<Throwable> error = TestHelper.trackPluginErrors();  try { TestCompletable tc = new TestCompletable();  tc.onSubscribe(Disposable.empty());  Disposable d = Disposable.empty();  tc.onSubscribe(d);  assertTrue(d.isDisposed());  assertEquals(1, tc.start);  TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName())); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, new FunctionTable(), Collections.emptyMap(), MethodHandles.publicLookup(),",
        "ins1PreCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, new FunctionTable(), MethodHandles.publicLookup(), \"eq\",",
        "ins2PreCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, new FunctionTable(), MethodHandles.publicLookup(), \"eq\",",
        "label":1
    },
    {
        "ins1CurCode":"String type = context.getStringAttribute(\"type\"); Properties props = context.getChildrenAsProperties(); TransactionFactory factory = (TransactionFactory) resolveClass(type).getDeclaredConstructor().newInstance(); factory.setProperties(props);",
        "ins1PreCode":"String type = context.getStringAttribute(\"type\"); Properties props = context.getChildrenAsProperties(); TransactionFactory factory = (TransactionFactory) resolveClass(type).newInstance(); factory.setProperties(props);",
        "ins2PreCode":"String type = context.getStringAttribute(\"type\"); Properties props = context.getChildrenAsProperties(); DataSourceFactory factory = (DataSourceFactory) resolveClass(type).newInstance(); factory.setProperties(props);",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-order/wo-plugin-mgmt\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() );",
        "ins1PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-order/wo-plugin-mngt\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() );",
        "ins2PreCode":"throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-order/w-plugin-mngt\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() );",
        "label":1
    },
    {
        "ins1CurCode":"private static long[][] getKeyPrefixArrayCounts( LongArray array, long startIndex, long numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][];",
        "ins1PreCode":"private static long[][] getKeyPrefixArrayCounts( LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][];",
        "ins2PreCode":"private static long[][] getCounts( LongArray array, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][];   long bitwiseMax = 0; long bitwiseMin = -1L; long maxOffset = array.getBaseOffset() + numRecords * 8; Object baseObject = array.getBaseObject();",
        "label":0
    },
    {
        "ins1CurCode":"return; } source.subscribe(new ToListObserver<>(t, coll));",
        "ins1PreCode":"return; } source.subscribe(new ToListObserver<T, U>(t, coll));",
        "ins2PreCode":"return; } source.subscribe(new ToListObserver<T, U>(t, coll));",
        "label":1
    },
    {
        "ins1CurCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); skipTokens(st, 2); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins1PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins2PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "label":0
    },
    {
        "ins1CurCode":"void testCallWithResultSet1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testCallWithResultSet1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testCallWithResultSet1_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testProhibitSymlinks() { assumeTrue(\"System does not support Symlinks\", supportsSymlinks); assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\");",
        "ins1PreCode":"public void testProhibitSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\");",
        "ins2PreCode":"public void testFileSymlink() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-file-setup\");",
        "label":1
    },
    {
        "ins1CurCode":"});  to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"});  to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"});  to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete();",
        "ins1PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "ins2PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(5)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1CurCode":"private String decodeAuto(Context ctx, ByteBuffer in) { String decoded = null; int matchCount = ctx.getMatchCount();   int oldPos = in.position(); int oldLimit = in.limit();  while (in.hasRemaining() && decoded == null) { byte b = in.get(); boolean matched = false;  switch (b) { case '\\r':   matchCount++; break;  case '\\n':  matchCount++; matched = true; break;  default: matchCount = 0; }  if (matched) {  int pos = in.position(); in.limit(pos); in.position(oldPos);  ctx.append(in);  in.limit(oldLimit); in.position(pos);  try { if (ctx.getOverflowLength() == 0) { ByteBuffer buf = ctx.getBuffer(); buf.flip(); buf.limit(buf.limit() - matchCount);  CharsetDecoder decoder = ctx.getDecoder(); CharBuffer buffer = decoder.decode(buf); decoded = new String(buffer.array()); } else { int overflowPosition = ctx.getOverflowLength(); throw new IllegalStateException(\"Line is too long: \" + overflowPosition); } } catch (CharacterCodingException cce) { throw new RuntimeException(cce); } finally { ctx.reset(); } oldPos = pos; matchCount = 0; } }   in.position(oldPos); ctx.append(in);  ctx.setMatchCount(matchCount); return decoded;",
        "ins1PreCode":"private String[] decodeAuto(Context ctx, ByteBuffer in) { List<String> decoded = new ArrayList<String>(); int matchCount = ctx.getMatchCount();   int oldPos = in.position(); int oldLimit = in.limit();  while (in.hasRemaining()) { byte b = in.get(); boolean matched = false;  switch (b) { case '\\r':   matchCount++; break;  case '\\n':  matchCount++; matched = true; break;  default: matchCount = 0; }  if (matched) {  int pos = in.position(); in.limit(pos); in.position(oldPos);  ctx.append(in);  in.limit(oldLimit); in.position(pos);  try { if (ctx.getOverflowLength() == 0) { ByteBuffer buf = ctx.getBuffer(); buf.flip(); buf.limit(buf.limit() - matchCount);  CharsetDecoder decoder = ctx.getDecoder(); CharBuffer buffer = decoder.decode(buf); String str = new String(buffer.array()); decoded.add(str); } else { int overflowPosition = ctx.getOverflowLength(); throw new IllegalStateException(\"Line is too long: \" + overflowPosition); } } catch (CharacterCodingException cce) { throw new RuntimeException(cce); } finally { ctx.reset(); } oldPos = pos; matchCount = 0; } }   in.position(oldPos); ctx.append(in);  ctx.setMatchCount(matchCount); return decoded.toArray(new String[decoded.size()]);",
        "ins2PreCode":"private String[] decodeNormal(Context ctx, ByteBuffer in) { List<String> decoded = new ArrayList<String>(); int matchCount = ctx.getMatchCount();   int oldPos = in.position(); int oldLimit = in.limit();  while (in.hasRemaining()) { byte b = in.get();  if (delimBuf.get(matchCount) == b) { matchCount++;  if (matchCount == delimBuf.limit()) {  int pos = in.position(); in.limit(pos); in.position(oldPos);  ctx.append(in);  in.limit(oldLimit); in.position(pos);  try { if (ctx.getOverflowLength() == 0) { ByteBuffer buf = ctx.getBuffer(); buf.flip(); buf.limit(buf.limit() - matchCount);  CharsetDecoder decoder = ctx.getDecoder(); CharBuffer buffer = decoder.decode(buf); String str = new String(buffer.array()); decoded.add(str); } else { int overflowLength = ctx.getOverflowLength(); throw new IllegalStateException(\"Line is too long: \" + overflowLength); } } catch (CharacterCodingException cce) { throw new RuntimeException(cce); } finally { ctx.reset(); }   oldPos = pos; matchCount = 0; } } else {  in.position(Math.max(0, in.position() - matchCount)); matchCount = 0; } }   in.position(oldPos); ctx.append(in);  ctx.setMatchCount(matchCount); return decoded.toArray(new String[decoded.size()]);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { DateTitle t1 = new DateTitle(); DateTitle t2 = CloneUtils.clone(t1); assertTrue(t1 != t2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DateTitle t1 = new DateTitle(); DateTitle t2 = (DateTitle) t1.clone(); assertTrue(t1 != t2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { ShortTextTitle t1 = new ShortTextTitle(\"ABC\"); ShortTextTitle t2 = (ShortTextTitle) t1.clone(); assertTrue(t1 != t2);",
        "label":0
    },
    {
        "ins1CurCode":"Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry != null && entry.isPrimary() ) set.add(entry); }",
        "ins1PreCode":"Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry != null && entry.isPrimary() ) set.add(entry.getValue()); }",
        "ins2PreCode":"public Set keySet() {   LinkedHashSet set = new LinkedHashSet(super.size()); Iterator i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isPrimary() ) set.add(key); } return Collections.unmodifiableSet(set); ",
        "label":0
    },
    {
        "ins1CurCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); skipTokens(st, 1); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins1PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins2PreCode":"public boolean isDescend() { String flags = Configuration.getString( Argo.KEY_IMPORT_GENERAL_SETTINGS_FLAGS); if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) { return false; } } return true;",
        "label":0
    },
    {
        "ins1CurCode":"public void producerRequestThroughBufferWithSize4() { TestSubscriber<List<Integer>> ts = new TestSubscriber<>(); final AtomicLong requested = new AtomicLong();",
        "ins1PreCode":"public void producerRequestThroughBufferWithSize4() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); final AtomicLong requested = new AtomicLong();",
        "ins2PreCode":"public void producerRequestOverflowThroughBufferWithSize1() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(Long.MAX_VALUE >> 1); ",
        "label":1
    },
    {
        "ins1CurCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> us = UnicastSubject.create(); TestHelper.emit(us, 1, 2, 3, 4, 5);  us .doFinally(this)",
        "ins1PreCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doFinally(this)",
        "ins2PreCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doFinally(this)",
        "label":1
    },
    {
        "ins1CurCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); Assert.assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); Assert.assertEquals(\"The second result is not correct.\", \"Hello, Unweaved World!\", result); ",
        "ins1PreCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Unweaved World!\", result); ",
        "ins2PreCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result); ",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(client.isResponse400());",
        "ins1PreCode":"  assertTrue(client.isResponse400());",
        "ins2PreCode":"  assertTrue(client.isResponse200());",
        "label":1
    },
    {
        "ins1CurCode":"}  return new String(resultArr, 0, resultPos);",
        "ins1PreCode":"}  if (resultPos < resultArr.length) { resultArr = Arrays.copyOf(resultArr, resultPos); } return UnsafeUtil.moveToString(resultArr);",
        "ins2PreCode":"String decodeUtf8(byte[] bytes, int index, int size) throws InvalidProtocolBufferException {  if ((index | size | bytes.length - index - size) < 0) { throw new ArrayIndexOutOfBoundsException( String.format(\"buffer length=%d, index=%d, size=%d\", bytes.length, index, size)); }  int offset = index; final int limit = offset + size;    char[] resultArr = new char[size]; int resultPos = 0;    while (offset < limit) { byte b = bytes[offset]; if (!DecodeUtil.isOneByte(b)) { break; } offset++; DecodeUtil.handleOneByte(b, resultArr, resultPos++); }  while (offset < limit) { byte byte1 = bytes[offset++]; if (DecodeUtil.isOneByte(byte1)) { DecodeUtil.handleOneByte(byte1, resultArr, resultPos++);   while (offset < limit) { byte b = bytes[offset]; if (!DecodeUtil.isOneByte(b)) { break; } offset++; DecodeUtil.handleOneByte(b, resultArr, resultPos++); } } else if (DecodeUtil.isTwoBytes(byte1)) { if (offset >= limit) { throw InvalidProtocolBufferException.invalidUtf8(); } DecodeUtil.handleTwoBytes(byte1,  bytes[offset++], resultArr, resultPos++); } else if (DecodeUtil.isThreeBytes(byte1)) { if (offset >= limit - 1) { throw InvalidProtocolBufferException.invalidUtf8(); } DecodeUtil.handleThreeBytes( byte1, bytes[offset++], bytes[offset++], resultArr, resultPos++); } else { if (offset >= limit - 2) { throw InvalidProtocolBufferException.invalidUtf8(); } DecodeUtil.handleFourBytes( byte1, bytes[offset++], bytes[offset++], bytes[offset++], resultArr, resultPos++);  resultPos++; } }  return new String(resultArr, 0, resultPos);",
        "label":0
    },
    {
        "ins1CurCode":"void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\r\\n ID = ?\";",
        "ins1PreCode":"public void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\r\\n ID = ?\";",
        "ins2PreCode":"public void shouldTrimWHEREANDWithTABForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\t ID = ?\";",
        "label":1
    },
    {
        "ins1CurCode":"} } throw new BuildException(\"BUG: at least the ProjectHelper2 should \" + \"have supported the file \" + buildFile);",
        "ins1PreCode":"} } throw new RuntimeException(\"BUG: at least the ProjectHelper2 should \" + \"have supported the file \" + buildFile);",
        "ins2PreCode":"} } throw new RuntimeException(\"BUG: at least the ProjectHelper2 should \" + \"have supported the file \" + antlib);",
        "label":1
    },
    {
        "ins1CurCode":"}  queue = new SpscArrayQueue<>(prefetch); ",
        "ins1PreCode":"}  queue = new SpscArrayQueue<T>(prefetch); ",
        "ins2PreCode":"}  queue = new SpscArrayQueue<T>(prefetch); ",
        "label":1
    },
    {
        "ins1CurCode":"public static String getViewSource(DBRProgressMonitor monitor, GenericTableBase view) throws DBException",
        "ins1PreCode":"public static String getViewSource(DBRProgressMonitor monitor, GenericTable view) throws DBException",
        "ins2PreCode":"public static String getTriggerSource(DBRProgressMonitor monitor, FireBirdTrigger trigger) throws DBException { try (JDBCSession session = DBUtils.openMetaSession(monitor, trigger, \"Load trigger source code\")) { DatabaseMetaData fbMetaData = session.getOriginal().getMetaData(); String source = (String) fbMetaData.getClass().getMethod(\"getTriggerSourceCode\", String.class).invoke(fbMetaData, trigger.getName()); if (CommonUtils.isEmpty(source)) { return null; }  return getTriggerSourceWithHeader(monitor, trigger, source); } catch (SQLException e) { throw new DBException(\"Can't read source code of trigger '\" + trigger.getName() + \"'\", e); } catch (Exception e) { log.debug(e); return null; }",
        "label":0
    },
    {
        "ins1CurCode":"public void inputStreamReadPastSubsection() throws Exception { RandomAccessData subsection = this.file.getSubsection(1, 2); InputStream inputStream = subsection.getInputStream(); assertThat(inputStream.read()).isEqualTo(1);",
        "ins1PreCode":"public void inputStreamReadPastSubsection() throws Exception { RandomAccessData subsection = this.file.getSubsection(1, 2); InputStream inputStream = subsection.getInputStream(ResourceAccess.PER_READ); assertThat(inputStream.read()).isEqualTo(1);",
        "ins2PreCode":"public void getEntryUrlStream() throws Exception { URL url = new URL(this.jarFile.getUrl(), \"1.dat\"); url.openConnection(); InputStream stream = url.openStream(); assertThat(stream.read()).isEqualTo(1); assertThat(stream.read()).isEqualTo(-1);",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetStartValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(10L, c.getStartValue(\"S1\", \"Task 1\", 0)); assertEquals(16L, c.getStartValue(\"S1\", \"Task 1\", 1)); assertEquals(30L, c.getStartValue(\"S1\", \"Task 2\", 0)); assertEquals(36L, c.getStartValue(\"S1\", \"Task 2\", 1)); assertEquals(50L, c.getStartValue(\"S2\", \"Task 3\", 0)); assertEquals(56L, c.getStartValue(\"S2\", \"Task 3\", 1));  assertEquals(10L, c.getStartValue(0, 0, 0)); assertEquals(16L, c.getStartValue(0, 0, 1)); assertEquals(30L, c.getStartValue(0, 1, 0)); assertEquals(36L, c.getStartValue(0, 1, 1)); assertEquals(50L, c.getStartValue(1, 2, 0)); assertEquals(56L, c.getStartValue(1, 2, 1));  TaskSeriesCollection c3 = createCollection3(); assertEquals(11L, c3.getStartValue(0, 0, 0)); assertEquals(22L, c3.getStartValue(0, 1, 0)); assertEquals(33L, c3.getStartValue(0, 1, 1)); assertTrue(c3.getStartValue(1, 0, 0) == null); assertEquals(44L, c3.getStartValue(1, 1, 0)); assertEquals(55L, c3.getStartValue(1, 1, 1)); assertEquals(66L, c3.getStartValue(1, 1, 2));",
        "ins1PreCode":"public void testGetStartValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(new Long(10L), c.getStartValue(\"S1\", \"Task 1\", 0)); assertEquals(new Long(16L), c.getStartValue(\"S1\", \"Task 1\", 1)); assertEquals(new Long(30L), c.getStartValue(\"S1\", \"Task 2\", 0)); assertEquals(new Long(36L), c.getStartValue(\"S1\", \"Task 2\", 1)); assertEquals(new Long(50L), c.getStartValue(\"S2\", \"Task 3\", 0)); assertEquals(new Long(56L), c.getStartValue(\"S2\", \"Task 3\", 1));  assertEquals(new Long(10L), c.getStartValue(0, 0, 0)); assertEquals(new Long(16L), c.getStartValue(0, 0, 1)); assertEquals(new Long(30L), c.getStartValue(0, 1, 0)); assertEquals(new Long(36L), c.getStartValue(0, 1, 1)); assertEquals(new Long(50L), c.getStartValue(1, 2, 0)); assertEquals(new Long(56L), c.getStartValue(1, 2, 1));  TaskSeriesCollection c3 = createCollection3(); assertEquals(new Long(11), c3.getStartValue(0, 0, 0)); assertEquals(new Long(22), c3.getStartValue(0, 1, 0)); assertEquals(new Long(33), c3.getStartValue(0, 1, 1)); assertTrue(c3.getStartValue(1, 0, 0) == null); assertEquals(new Long(44), c3.getStartValue(1, 1, 0)); assertEquals(new Long(55), c3.getStartValue(1, 1, 1)); assertEquals(new Long(66), c3.getStartValue(1, 1, 2));",
        "ins2PreCode":"public void testGetEndValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(new Long(15L), c.getEndValue(\"S1\", \"Task 1\", 0)); assertEquals(new Long(20L), c.getEndValue(\"S1\", \"Task 1\", 1)); assertEquals(new Long(35L), c.getEndValue(\"S1\", \"Task 2\", 0)); assertEquals(new Long(40L), c.getEndValue(\"S1\", \"Task 2\", 1)); assertEquals(new Long(55L), c.getEndValue(\"S2\", \"Task 3\", 0)); assertEquals(new Long(60L), c.getEndValue(\"S2\", \"Task 3\", 1));  assertEquals(new Long(15L), c.getEndValue(0, 0, 0)); assertEquals(new Long(20L), c.getEndValue(0, 0, 1)); assertEquals(new Long(35L), c.getEndValue(0, 1, 0)); assertEquals(new Long(40L), c.getEndValue(0, 1, 1)); assertEquals(new Long(55L), c.getEndValue(1, 2, 0)); assertEquals(new Long(60L), c.getEndValue(1, 2, 1));  TaskSeriesCollection c3 = createCollection3(); assertEquals(new Long(111), c3.getEndValue(0, 0, 0)); assertEquals(new Long(222), c3.getEndValue(0, 1, 0)); assertEquals(new Long(333), c3.getEndValue(0, 1, 1)); assertTrue(c3.getEndValue(1, 0, 0) == null); assertEquals(new Long(444), c3.getEndValue(1, 1, 0)); assertEquals(new Long(555), c3.getEndValue(1, 1, 1)); assertEquals(new Long(666), c3.getEndValue(1, 1, 2));",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMappingDecoded(mapping, \"Mapping\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(mapping, \"Mapping\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"Include\", new IncludeServlet()); ctx.addServletMapping(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); ",
        "label":0
    },
    {
        "ins1CurCode":"public void testNotNullColumnWithChildrenNoFid() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);",
        "ins1PreCode":"public void testNotNullColumnWithChildrenNoFid() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);  Father test = fatherMapper.selectByIdNoFid(1); assertNotNull(test); assertNotNull(test.getChildren()); assertEquals(2, test.getChildren().size()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testNotNullColumnWithoutChildrenNoFid() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);  Father test = fatherMapper.selectByIdNoFid(2); assertNotNull(test); assertNotNull(test.getChildren()); assertTrue(test.getChildren().isEmpty()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"PublishProcessor<String> main = PublishProcessor.create();  TestSubscriber<String> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"PublishProcessor<String> main = PublishProcessor.create();  TestSubscriber<String> ts = new TestSubscriber<String>(); ",
        "ins2PreCode":"PublishProcessor<String> main = PublishProcessor.create();  TestSubscriber<String> ts = new TestSubscriber<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded.get()); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded.get(), jarEntry.getName()); if (jarEntry.isDirectory()) {",
        "ins1PreCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded, jarEntry.getName()); if (jarEntry.isDirectory()) {",
        "ins2PreCode":"private void explodeArchive(File archive, File destination) throws IOException { FileSystemUtils.deleteRecursively(destination); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(destination, jarEntry.getName()); if (jarEntry.isDirectory()) { extracted.mkdirs(); } else { FileOutputStream extractedOutputStream = new FileOutputStream(extracted); StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream); extractedOutputStream.close(); } } jarFile.close();",
        "label":0
    },
    {
        "ins1CurCode":"public void testSetSeriesURLGenerator() { CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1 = new StandardCategoryURLGenerator(); renderer.setSeriesItemURLGenerator(0, url1); CategoryURLGenerator url2 = renderer.getItemURLGenerator(0, 0); assertSame(url2, url1);",
        "label":0
    },
    {
        "ins1CurCode":"int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = poissonJavaRDD(jsc, mean, m); JavaDoubleRDD rdd2 = poissonJavaRDD(jsc, mean, m, p); JavaDoubleRDD rdd3 = poissonJavaRDD(jsc, mean, m, p, seed); for (JavaDoubleRDD rdd : Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "ins1PreCode":"int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = poissonJavaRDD(sc, mean, m); JavaDoubleRDD rdd2 = poissonJavaRDD(sc, mean, m, p); JavaDoubleRDD rdd3 = poissonJavaRDD(sc, mean, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "ins2PreCode":"int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = exponentialJavaRDD(sc, mean, m); JavaDoubleRDD rdd2 = exponentialJavaRDD(sc, mean, m, p); JavaDoubleRDD rdd3 = exponentialJavaRDD(sc, mean, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "label":1
    },
    {
        "ins1CurCode":"public void disposedOnCall() { final TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void disposedOnCall() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void disposedOnCall() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"private ConfigurableApplicationContext getContext( Supplier<ConfigurableApplicationContext> supplier) throws Exception { AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { ConfigurableApplicationContext context = supplier.get(); atomicReference.getAndSet(context); }); thread.start();",
        "ins1PreCode":"private ConfigurableApplicationContext getContext( Supplier<ConfigurableApplicationContext> supplier) throws Exception { CountDownLatch latch = new CountDownLatch(1); AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { ConfigurableApplicationContext context = supplier.get(); latch.countDown(); atomicReference.getAndSet(context);",
        "ins2PreCode":"protected ConfigurableApplicationContext getContext( Supplier<ConfigurableApplicationContext> supplier) throws Exception { CountDownLatch latch = new CountDownLatch(1); AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { ConfigurableApplicationContext context = supplier.get(); latch.countDown(); atomicReference.getAndSet(context);",
        "label":1
    },
    {
        "ins1CurCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) { return; }",
        "ins1PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target);",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target);",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@string{bourdieu = {Bourdieu, Pierre}}\"));  BibtexString string = result.getDatabase().getStringValues().iterator().next();  assertEquals(1, result.getDatabase().getStringCount()); assertEquals(\"bourdieu\", string.getName()); assertEquals(\"Bourdieu, Pierre\", string.getContent());",
        "ins1PreCode":"assertEquals(1, result.getDatabase().getStringCount());  BibtexString s = result.getDatabase().getStringValues().iterator().next(); assertEquals(\"bourdieu\", s.getName()); assertEquals(\"Bourdieu, Pierre\", s.getContent());",
        "ins2PreCode":"assertEquals(1, result.getDatabase().getStringCount());  BibtexString s = result.getDatabase().getStringValues().iterator().next(); assertEquals(\"bourdieu\", s.getName()); assertEquals(\"Bourdieu, Pierre\", s.getContent());",
        "label":0
    },
    {
        "ins1CurCode":"Observable<Integer> source = Observable.range(1, 5);  TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"Observable<Integer> source = Observable.range(1, 5);  TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"Observable<Integer> source = Observable.range(1, 5);  TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"this.filter.addErrorPages(new ErrorPage(\"/error\")); this.request.setAsyncStarted(true); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); response.sendError(400, \"BAD\"); }); this.filter.doFilter(this.request, this.response, this.chain);",
        "ins1PreCode":"this.filter.addErrorPages(new ErrorPage(\"/error\")); this.request.setAsyncStarted(true); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); ((HttpServletResponse) response).sendError(400, \"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "ins2PreCode":"this.filter.addErrorPages(new ErrorPage(\"/error\")); setUpAsyncDispatch(); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new RuntimeException(\"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "label":1
    },
    {
        "ins1CurCode":" if (bundle != null) { Locale bundleLocale = bundle.getLocale(); if (bundleLocale.equals(Locale.ROOT)) { this.locale = Locale.ENGLISH; } else {",
        "ins1PreCode":" if (bundle != null) { this.locale = bundle.getLocale(); } else { this.locale = null; }",
        "ins2PreCode":"private StringManager(String packageName) { ResourceBundle b = null;  String bundleName = packageName + \".LocalStrings\"; try { b = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { b = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) {  } } }  this.bundle = b; if (bundle != null) { locale = bundle.getLocale(); } else { locale = null; }",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { SymbolAxis a1 = new SymbolAxis(\"Axis\", new String[] {\"A\", \"B\"}); SymbolAxis a2 = CloneUtils.clone(a1); assertTrue(a1 != a2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { SymbolAxis a1 = new SymbolAxis(\"Axis\", new String[] {\"A\", \"B\"}); SymbolAxis a2 = (SymbolAxis) a1.clone(); assertTrue(a1 != a2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { NumberAxis a1 = new NumberAxis(\"Test\"); NumberAxis a2 = (NumberAxis) a1.clone(); assertTrue(a1 != a2);",
        "label":1
    },
    {
        "ins1CurCode":"if (c == '\\\\' && i + 1 < size) { char c1 = image.charAt(i + 1); if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'') { c = c1;",
        "ins1PreCode":"if (c == '\\\\' && i + 1 < size) { char c1 = image.charAt(i + 1); if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'' || c1 == '#' || c1 == '$') { c = c1;",
        "ins2PreCode":"public void setImage(String image) { if (image.indexOf('\\\\') == -1) { this.image = image; return; } int size = image.length(); StringBuilder buf = new StringBuilder(size); for (int i = 0; i < size; i++) { char c = image.charAt(i); if (c == '\\\\' && i + 2 < size) { char c1 = image.charAt(i + 1); char c2 = image.charAt(i + 2); if ((c1 == '#' || c1 == '$') && c2 == '{')  { c = c1; i++; } } buf.append(c); } this.image = buf.toString(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testJavaPattern() { DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), null, templatize(ZoneId.of(\"Europe/Amsterdam\")), templatize(Locale.ENGLISH), \"date_as_string\", Collections.singletonList(\"yyyy dd MM HH:mm:ss\"), \"date_as_date\");",
        "ins1PreCode":"public void testJavaPattern() { DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), templatize(ZoneId.of(\"Europe/Amsterdam\")), templatize(Locale.ENGLISH), \"date_as_string\", Collections.singletonList(\"yyyy dd MM HH:mm:ss\"), \"date_as_date\");",
        "ins2PreCode":" DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), templatize(ZoneId.of(\"Europe/Amsterdam\")), templatize(Locale.ENGLISH), \"date_as_string\", Collections.singletonList(\"yyyy dd MMMM\"), \"date_as_date\");",
        "label":1
    },
    {
        "ins1CurCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints, RequestMatcherProvider matcherProvider) {",
        "ins1PreCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints, String dispatcherServletPath, RequestMatcherProvider matcherProvider) { StaticWebApplicationContext context = new StaticWebApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context .getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } if (dispatcherServletPath != null) { DispatcherServletPath path = () -> dispatcherServletPath; context.registerBean(DispatcherServletPath.class, () -> path); }",
        "ins2PreCode":"private RequestMatcherAssert assertMatcher(ServerWebExchangeMatcher matcher, PathMappedEndpoints pathMappedEndpoints) { StaticApplicationContext context = new StaticApplicationContext(); context.registerBean(WebEndpointProperties.class); if (pathMappedEndpoints != null) { context.registerBean(PathMappedEndpoints.class, () -> pathMappedEndpoints); WebEndpointProperties properties = context.getBean(WebEndpointProperties.class); if (!properties.getBasePath().equals(pathMappedEndpoints.getBasePath())) { properties.setBasePath(pathMappedEndpoints.getBasePath()); } } return assertThat(new RequestMatcherAssert(context, matcher));",
        "label":0
    },
    {
        "ins1CurCode":"if (SecurityUtil.isPackageProtectionEnabled()) { try { Integer result = AccessController.doPrivileged( new PrivilegedReadArray(ib, b, off, len)); return result.intValue();",
        "ins1PreCode":"if (SecurityUtil.isPackageProtectionEnabled()) { try { Integer result = AccessController .doPrivileged(new PrivilegedExceptionAction<Integer>() {  @Override public Integer run() throws IOException { Integer integer = Integer.valueOf(ib.read(b, off, len)); return integer; }  }); return result.intValue();",
        "ins2PreCode":"if (SecurityUtil.isPackageProtectionEnabled()) { try { Integer result = AccessController .doPrivileged(new PrivilegedExceptionAction<Integer>() {  @Override public Integer run() throws IOException { Integer integer = Integer.valueOf(ib.read(b)); return integer; }  }); return result.intValue();",
        "label":1
    },
    {
        "ins1CurCode":"return (float)value; } else { throw new ClassCastException(\"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + float.class.getCanonicalName()); }",
        "ins1PreCode":"return (float)value; } else { throw new ClassCastException( \"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to float\"); }",
        "ins2PreCode":"return (double)value; } else { throw new ClassCastException(\"cannot implicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); }",
        "label":0
    },
    {
        "ins1CurCode":"void testReadArticleDublinCoreReadXmp() throws IOException, URISyntaxException, ParseException { Path pathPdf = Path.of(XmpUtilShared.class.getResource(\"article_dublinCore.pdf\").toURI()); List<BibEntry> entries = XmpUtilReader.readXmp(pathPdf, xmpPreferences);",
        "ins1PreCode":"void testReadArticleDublinCoreReadXmp() throws IOException, URISyntaxException, ParseException { Path pathPdf = Paths.get(XmpUtilShared.class.getResource(\"article_dublinCore.pdf\").toURI()); List<BibEntry> entries = XmpUtilReader.readXmp(pathPdf, xmpPreferences);",
        "ins2PreCode":"void testReadPDMetadata() throws IOException, URISyntaxException, ParseException { Path pathPdf = Paths.get(XmpUtilShared.class.getResource(\"PD_metadata.pdf\").toURI()); List<BibEntry> entries = XmpUtilReader.readXmp(pathPdf, xmpPreferences);",
        "label":1
    },
    {
        "ins1CurCode":"public static Event randomEvent(String type, int numInstances) { Map<String, Object> values = new LinkedHashMap<>(); values.put(\"count200\", randomIntFrom0to(4000));",
        "ins1PreCode":"public static Event randomEvent(String type, int numInstances) { Map<String, Object> values = new LinkedHashMap<String, Object>(); values.put(\"count200\", randomIntFrom0to(4000));",
        "ins2PreCode":"public static Event randomEvent(String type, int numInstances) { Map<String, Object> values = new LinkedHashMap<String, Object>(); values.put(\"count200\", randomIntFrom0to(4000));",
        "label":1
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_14: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_14; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[37] = jj_gen; ;",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_12: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[29] = jj_gen; break label_12; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[30] = jj_gen; ;",
        "ins2PreCode":"case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[40] = jj_gen; break label_15; }",
        "label":1
    },
    {
        "ins1CurCode":"Observable<Object> fromSupplierObservable = Observable.fromSupplier(func);  verifyNoInteractions(func); ",
        "ins1PreCode":"Observable<Object> fromSupplierObservable = Observable.fromSupplier(func);  verifyZeroInteractions(func); ",
        "ins2PreCode":"Flowable<Object> fromSupplierFlowable = Flowable.fromSupplier(func);  verifyZeroInteractions(func); ",
        "label":1
    },
    {
        "ins1CurCode":"private UnknownFieldSet makeUnknownFieldSet() {  return UnknownFieldSet.newBuilder() .addField(5, UnknownFieldSet.Field.newBuilder() .addVarint(1) .addFixed32(2) .addFixed64(3) .addLengthDelimited(ByteString.copyFromUtf8(\"4\")) .addLengthDelimited(UnknownFieldSet.newBuilder() .addField(12, UnknownFieldSet.Field.newBuilder() .addVarint(6) .build()) .build().toByteString()) .addGroup(",
        "ins1PreCode":"private UnknownFieldSet makeUnknownFieldSet() { return UnknownFieldSet.newBuilder() .addField(5, UnknownFieldSet.Field.newBuilder() .addVarint(1) .addFixed32(2) .addFixed64(3) .addLengthDelimited(ByteString.copyFromUtf8(\"4\")) .addGroup( UnknownFieldSet.newBuilder() .addField(10, UnknownFieldSet.Field.newBuilder() .addVarint(5) .build()) .build()) .build())",
        "ins2PreCode":"private UnknownFieldSet makeUnknownFieldSet() { return UnknownFieldSet.newBuilder() .addField(5, UnknownFieldSet.Field.newBuilder() .addVarint(1) .addFixed32(2) .addFixed64(3) .addLengthDelimited(ByteString.copyFromUtf8(\"4\")) .addGroup( UnknownFieldSet.newBuilder() .addField(10, UnknownFieldSet.Field.newBuilder() .addVarint(5) .build()) .build()) .build()) .addField(8, UnknownFieldSet.Field.newBuilder() .addVarint(1) .addVarint(2) .addVarint(3) .build()) .addField(15, UnknownFieldSet.Field.newBuilder() .addVarint(0xABCDEF1234567890L) .addFixed32(0xABCD1234) .addFixed64(0xABCDEF1234567890L) .build()) .build();",
        "label":0
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,author = {H\\'{e}lne Fiaux}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(\"author\"));",
        "ins1PreCode":"assertFalse(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), e.getField(\"author\"));",
        "ins2PreCode":"assertEquals(Optional.of(\"some text and \\\\latex\"), result.getDatabase().getPreamble());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1CurCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).iteratesOverSequence( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins1PreCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).hasContentsInOrder( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins2PreCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).hasContentsInOrder( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "label":1
    },
    {
        "ins1CurCode":"case \"site\": return SITE_CMD; default: return SEND_FILES; } ",
        "ins1PreCode":"case \"site\": return SITE_CMD; } return SEND_FILES;",
        "ins2PreCode":"public int getAction() { String actionL = getValue().toLowerCase(Locale.ENGLISH); switch (actionL) { case \"send\": case \"put\": return SEND_FILES; case \"recv\": case \"get\": return GET_FILES; case \"del\": case \"delete\": return DEL_FILES; case \"list\": return LIST_FILES; case \"chmod\": return CHMOD; case \"mkdir\": return MK_DIR; case \"rmdir\": return RM_DIR; case \"site\": return SITE_CMD; } return SEND_FILES;",
        "label":0
    },
    {
        "ins1CurCode":"public void customResourceLoaderIsUsedInNonWebApplication() { GenericApplicationContext context = new GenericApplicationContext();",
        "ins1PreCode":"public void customResourceLoaderIsUsedInNonWebApplication() throws Exception { GenericApplicationContext context = new GenericApplicationContext();",
        "ins2PreCode":"public void customResourceLoaderIsUsedInWebApplication() throws Exception { GenericWebApplicationContext context = new GenericWebApplicationContext(",
        "label":1
    },
    {
        "ins1CurCode":"} } fireNodesChanged(path, childIndices, children); }",
        "ins1PreCode":"} } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins2PreCode":"} } fireTreeNodesInserted(this, path, childIndices, children); }",
        "label":1
    },
    {
        "ins1CurCode":"double[][] data = createSampleData1();  XYSeries<String> series = new XYSeries<>(\"Test\"); for (int i = 0; i < 11; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection<String>(series); double[] result = Regression.getPowerRegression(ds, 0);",
        "ins1PreCode":"double[][] data = createSampleData1();  XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 11; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getPowerRegression(ds, 0);",
        "ins2PreCode":"double[][] data = createSampleData2();  XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getOLSRegression(ds, 0);",
        "label":1
    },
    {
        "ins1CurCode":"public List<FieldChange> add(Collection<BibEntry> entriesToAdd) { Objects.requireNonNull(entriesToAdd);  List<FieldChange> changes = new ArrayList<>(); for (BibEntry entry : new ArrayList<>(entriesToAdd)) { if (!contains(entry)) {",
        "ins1PreCode":"public List<FieldChange> add(List<BibEntry> entriesToAdd) { Objects.requireNonNull(entriesToAdd);  List<FieldChange> changes = new ArrayList<>(); for (BibEntry entry : entriesToAdd) { if (!contains(entry)) {",
        "ins2PreCode":"Objects.requireNonNull(entriesToRemove); List<FieldChange> changes = new ArrayList<>(); for (BibEntry entry : entriesToRemove) { if (contains(entry)) {",
        "label":0
    },
    {
        "ins1CurCode":"  ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries();",
        "ins1PreCode":"  ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries();",
        "ins2PreCode":"  ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries();",
        "label":1
    },
    {
        "ins1CurCode":"\"/webdav/WEB-INF/web.xml\", res, null);  Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/WEB-INF/doesntexistanywhere\", res, null); Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/WEB-INF/\", res, null); Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/META-INF/MANIFEST.MF\", res, null); Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/META-INF/doesntexistanywhere\", res, null); Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);    final ByteChunk rootResource = new ByteChunk(); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/index.html\", rootResource, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc);  final ByteChunk subpathResource = new ByteChunk(); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/index.html\", subpathResource, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc);  Assert.assertEquals(rootResource.toString(), subpathResource.toString());  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/static/index.html\", res, null); Assert.assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); ",
        "ins1PreCode":"\"/webdav/WEB-INF/web.xml\", res, null);  assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/WEB-INF/doesntexistanywhere\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/WEB-INF/\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/META-INF/MANIFEST.MF\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/META-INF/doesntexistanywhere\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);    final ByteChunk rootResource = new ByteChunk(); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/index.html\", rootResource, null); assertEquals(HttpServletResponse.SC_OK, rc);  final ByteChunk subpathResource = new ByteChunk(); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/index.html\", subpathResource, null); assertEquals(HttpServletResponse.SC_OK, rc);  assertEquals(rootResource.toString(), subpathResource.toString());  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/webdav/static/index.html\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); ",
        "ins2PreCode":"\"/static/WEB-INF/web.xml\", res, null);  assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/static/WEB-INF/doesntexistanywhere\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/static/WEB-INF/\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/static/META-INF/MANIFEST.MF\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/static/META-INF/doesntexistanywhere\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc);     final ByteChunk rootResource = new ByteChunk(); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/index.html\", rootResource, null); assertEquals(HttpServletResponse.SC_OK, rc);  final ByteChunk subpathResource = new ByteChunk(); rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/servlets/index.html\", subpathResource, null); assertEquals(HttpServletResponse.SC_OK, rc);  assertFalse(rootResource.toString().equals(subpathResource.toString()));  rc =getUrl(\"http://localhost:\" + getPort() + contextPath + \"/static/index.html\", res, null); assertEquals(HttpServletResponse.SC_NOT_FOUND, rc); ",
        "label":1
    },
    {
        "ins1CurCode":"protected void applyThemeSettings(ITheme currentTheme) { curLineColor = currentTheme.getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK); ",
        "ins1PreCode":"protected void applyThemeSettings() { IThemeManager themeManager = controller.getSite().getWorkbenchWindow().getWorkbench().getThemeManager(); curLineColor = themeManager.getCurrentTheme().getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK);  ITheme currentTheme = themeManager.getCurrentTheme(); Font rsFont = currentTheme.getFontRegistry().get(ThemeConstants.FONT_SQL_RESULT_SET);",
        "ins2PreCode":"protected void applyThemeSettings() { IThemeManager themeManager = controller.getSite().getWorkbenchWindow().getWorkbench().getThemeManager(); curLineColor = themeManager.getCurrentTheme().getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK);  ITheme currentTheme = themeManager.getCurrentTheme(); Font rsFont = currentTheme.getFontRegistry().get(ThemeConstants.FONT_SQL_RESULT_SET);",
        "label":1
    },
    {
        "ins1CurCode":"public void testTcpCloseInOnMessage() throws Exception {  Assume.assumeFalse(\"This test currently fails for APR\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Apr\")); ",
        "ins1PreCode":"public void testTcpCloseInOnMessage() throws Exception { startServer(TestEndpointConfig.class);  TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.httpUpgrade(BaseEndpointConfig.PATH);",
        "ins2PreCode":"public void testWsCloseThenTcpCloseWhenOnMessageSends() throws Exception { events.onMessageSends = true;  startServer(TestEndpointConfig.class);  TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.httpUpgrade(BaseEndpointConfig.PATH); client.sendMessage(\"Test\"); awaitLatch(events.onMessageCalled, \"onMessage not called\");  client.sendCloseFrame(CloseCodes.NORMAL_CLOSURE); client.closeSocket(); events.onMessageWait.countDown();  awaitOnClose(CloseCodes.CLOSED_ABNORMALLY);",
        "label":0
    },
    {
        "ins1CurCode":" Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<>(observer); source.subscribe(to);",
        "ins1PreCode":" Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); source.subscribe(to);",
        "ins2PreCode":" Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); source.subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); Iterable<ModelObject> itemList = newRuns(1, 10); ",
        "ins1PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = newRuns(1, 10); ",
        "ins2PreCode":"public void test_newerThan_near_newest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 8L, null); List<ModelObject> itemList = newRuns(1, 10); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":"void inMemoryH2IsShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\",",
        "ins1PreCode":"public void inMemoryH2IsShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\",",
        "ins2PreCode":"public void hsqlServerIsNotShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext(\"org.hsqldb.jdbcDriver\",",
        "label":1
    },
    {
        "ins1CurCode":"exec_task.get(2*TIMEOUT, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { throw new AssertionError(\"Blocking call didn't finish after timeout!\", e); }",
        "ins1PreCode":"exec_task.get(2*TIMEOUT, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { fail(\"Blocking call didn't finish after timeout!\"); }",
        "ins2PreCode":"public void quietDownShouldSuccessWithBlockAndNonExpiredTimeoutAndFinishingExecutor() throws Exception { final int TIMEOUT = 5000; final FreeStyleProject project = j.createFreeStyleProject(\"aProject\"); final ExecutorService threadPool = Executors.newSingleThreadExecutor(); final OneShotEvent beforeCli = new OneShotEvent(); final OneShotEvent finish = new OneShotEvent(); final Future<FreeStyleBuild> build = OnlineNodeCommandTest.startBlockingAndFinishingBuild(project, finish); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1));  final FutureTask exec_task = new FutureTask(new Callable() { @Override public Object call() { assertJenkinsNotInQuietMode(); final long time_before = System.currentTimeMillis(); beforeCli.signal(); final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Jenkins.ADMINISTER) .invokeWithArgs(\"-block\", \"-timeout\", Integer.toString(TIMEOUT)); assertThat(result, succeededSilently()); assertThat(System.currentTimeMillis() > time_before + 1000, equalTo(true)); assertThat(System.currentTimeMillis() < time_before + TIMEOUT, equalTo(true)); assertJenkinsInQuietMode(); return null; } }); threadPool.submit(exec_task); beforeCli.block(); assertJenkinsInQuietMode();  finish.signal(); build.get(); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1)); assertThat(project.isBuilding(), equalTo(false)); j.assertBuildStatusSuccess(build); assertJenkinsInQuietMode(); get(exec_task);",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribe(Observer<? super Integer> observer) { subscriptionCount.incrementAndGet(); observer.onSubscribe(Disposable.fromRunnable(new Runnable() { @Override",
        "ins1PreCode":"public void subscribe(Observer<? super Integer> observer) { subscriptionCount.incrementAndGet(); observer.onSubscribe(Disposables.fromRunnable(new Runnable() { @Override",
        "ins2PreCode":"public void onlyFirstShouldSubscribeAndLastUnsubscribe() { final AtomicInteger subscriptionCount = new AtomicInteger(); final AtomicInteger unsubscriptionCount = new AtomicInteger(); Flowable<Integer> flowable = Flowable.unsafeCreate(new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> subscriber) { subscriptionCount.incrementAndGet(); subscriber.onSubscribe(new Subscription() { @Override public void request(long n) {  }  @Override public void cancel() { unsubscriptionCount.incrementAndGet(); } }); } }); Flowable<Integer> refCounted = flowable.publish().refCount();  Disposable first = refCounted.subscribe(); assertEquals(1, subscriptionCount.get());  Disposable second = refCounted.subscribe(); assertEquals(1, subscriptionCount.get());  first.dispose(); assertEquals(0, unsubscriptionCount.get());  second.dispose(); assertEquals(1, unsubscriptionCount.get());",
        "label":0
    },
    {
        "ins1CurCode":"((Lifecycle) oldCluster).stop(); } catch (LifecycleException e) { log.error(sm.getString(\"containerbase.cluster.stop\"), e); } }   if (cluster != null) cluster.setContainer(this);  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) { try { ((Lifecycle) cluster).start(); } catch (LifecycleException e) { log.error(sm.getString(\"containerbase.cluster.start\"), e); }",
        "ins1PreCode":"((Lifecycle) oldCluster).stop(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: stop: \", e); } }   if (cluster != null) cluster.setContainer(this);  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) { try { ((Lifecycle) cluster).start(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: start: \", e); }",
        "ins2PreCode":"((Lifecycle) oldLoader).stop(); } catch (LifecycleException e) { log.error(\"StandardContext.setLoader: stop: \", e); } }   if (loader != null) loader.setContext(this); if (getState().isAvailable() && (loader != null) && (loader instanceof Lifecycle)) { try { ((Lifecycle) loader).start(); } catch (LifecycleException e) { log.error(\"StandardContext.setLoader: start: \", e); }",
        "label":0
    },
    {
        "ins1CurCode":"public void applyProfile(Object handle, Object profile) { if (profile instanceof Profile) { if (((Profile) profile).isDefined()) { if (handle instanceof Model) {",
        "ins1PreCode":"public void applyProfile(Object handle, Object profile) { if (profile instanceof Profile) { if (handle instanceof Model) { ((Model) handle).applyProfile((Profile) profile);",
        "ins2PreCode":"public void unapplyProfile(Object handle, Object profile) { if (profile instanceof Profile) { if (handle instanceof Package) { ((Model) handle).unapplyProfile((Profile) profile); } else if (handle instanceof Profile) { ((Profile) handle).unapplyProfile((Profile) profile); }  Iterator<Package> iter = ((Profile) profile).getNestedPackages().iterator(); while (iter.hasNext()) { Package p = iter.next(); if (p instanceof Profile) { unapplyProfile(handle, p); } } }",
        "label":0
    },
    {
        "ins1CurCode":"Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);  List<TestSubscriberEx<Long>> list = new ArrayList<>(100); for (int i = 0; i < 100; i++) { TestSubscriberEx<Long> ts = new TestSubscriberEx<>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<>(); for (int i = 0; i < 10; i++) {",
        "ins1PreCode":"Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);  List<TestSubscriberEx<Long>> list = new ArrayList<TestSubscriberEx<Long>>(100); for (int i = 0; i < 100; i++) { TestSubscriberEx<Long> ts = new TestSubscriberEx<Long>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) {",
        "ins2PreCode":"Observable<Long> output = cached.observeOn(Schedulers.computation());  List<TestObserverEx<Long>> list = new ArrayList<TestObserverEx<Long>>(100); for (int i = 0; i < 100; i++) { TestObserverEx<Long> to = new TestObserverEx<Long>(); list.add(to); output.skip(i * 10).take(10).subscribe(to); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"} } catch (RuntimeException e) { LOG.log(Level.WARNING, \"While calling targetRemoved for \" + targetEvent + \" in \" + listeners[i + 1] + \" an error is thrown.\",",
        "ins1PreCode":"} } catch (RuntimeException e) { LOG.warn(\"While calling targetRemoved for \" + targetEvent + \" in \" + listeners[i + 1] + \" an error is thrown.\",",
        "ins2PreCode":"} } catch (RuntimeException e) { LOG.error(\"While calling targetAdded for \" + targetEvent + \" in \" + listeners[i + 1] + \" an error is thrown.\",",
        "label":0
    },
    {
        "ins1CurCode":"void testOldStyleBibtexkeyPattern0() { when(prefs.get(JabRefPreferences.IMPORT_FILENAMEPATTERN)).thenReturn(oldStylePatterns[0]);",
        "ins1PreCode":"public void testOldStyleBibtexkeyPattern0() { when(prefs.get(JabRefPreferences.IMPORT_FILENAMEPATTERN)).thenReturn(oldStylePatterns[0]);",
        "ins2PreCode":"public void testOldStyleBibtexkeyPattern1() { ",
        "label":1
    },
    {
        "ins1CurCode":"ConfigurationPropertyName name = ConfigurationPropertyName.of(\"my.key\"); mapper.addFromConfigurationProperty(name, \"key\"); SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper); assertThat(adapter.getConfigurationProperty(name).getOrigin().toString())",
        "ins1PreCode":"ConfigurationPropertyName name = ConfigurationPropertyName.of(\"my.key\"); mapper.addFromConfigurationProperty(name, \"key\"); SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper, null); assertThat(adapter.getConfigurationProperty(name).getOrigin().toString())",
        "ins2PreCode":"ConfigurationPropertyName name = ConfigurationPropertyName.of(\"my.key\"); mapper.addFromConfigurationProperty(name, \"key\"); SpringConfigurationPropertySource adapter = new SpringConfigurationPropertySource(propertySource, mapper, null); assertThat(adapter.getConfigurationProperty(name).getOrigin().toString()).isEqualTo(\"TestOrigin key\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testAnnotatedInsertTable2WithGeneratedKeyXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins1PreCode":"public void testAnnotatedInsertTable2WithGeneratedKeyXml() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2WithGeneratedKeyXml(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"barney_fred\", name.getGeneratedName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMapXml() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2WithSelectKeyWithKeyMapXml(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"barney_fred\", name.getGeneratedName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryConsumer c = new TestMemoryConsumer(memoryManager, MemoryMode.ON_HEAP); final MemoryBlock page0 = memoryManager.allocatePage(128, c); final MemoryBlock page1 = memoryManager.allocatePage(128, c); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1,",
        "ins1PreCode":"final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1,",
        "ins2PreCode":"final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1,",
        "label":1
    },
    {
        "ins1CurCode":"public int indexOf(Comparable<?> x) { if (this.autoSort) { return Collections.binarySearch(this.data, new ComparableObjectItem( x, null)); } else { for (int i = 0; i < this.data.size(); i++) { ComparableObjectItem item = this.data.get(i); if (item.getComparable().equals(x)) {",
        "ins1PreCode":"public int indexOf(Comparable x) { if (this.autoSort) { return Collections.binarySearch(this.data, new ComparableObjectItem( x, null)); } else { for (int i = 0; i < this.data.size(); i++) { ComparableObjectItem item = (ComparableObjectItem) this.data.get(i); if (item.getComparable().equals(x)) {",
        "ins2PreCode":"public int indexOf(Number x) { if (this.autoSort) { return Collections.binarySearch(this.data, new XYDataItem(x, null)); } else { for (int i = 0; i < this.data.size(); i++) { XYDataItem item = this.data.get(i); if (item.getX().equals(x)) { return i; } } return -1; }",
        "label":0
    },
    {
        "ins1CurCode":"public void sslValidationNotSkippedByDefault() { this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); this.thrown.expectCause(instanceOf(SSLException.class)); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block(); });",
        "ins1PreCode":"public void sslValidationNotSkippedByDefault() { setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping,",
        "ins2PreCode":"public void skipSslValidation() { setupContextWithCloudEnabled(); TestPropertyValues.of(\"management.cloudfoundry.skip-ssl-validation:true\") .applyTo(this.context); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping,",
        "label":0
    },
    {
        "ins1CurCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(\"a string\", results); assertEquals(0, context.getBuffer().position());",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1CurCode":"public void testSimpleCheckNumberOfButtons() throws Exception { HtmlPage p = j.createWebClient().goTo(\"self/testSimpleWithDeleteButton\"); HtmlForm f = p.getFormByName(\"config\");",
        "ins1PreCode":"public void testSimpleCheckNumberOfButtons() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testSimpleWithDeleteButton\"); HtmlForm f = p.getFormByName(\"config\");",
        "ins2PreCode":"public void testSimpleCheckNumberOfButtonsEnabledTopButton() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testSimpleWithDeleteButtonTopButton\"); HtmlForm f = p.getFormByName(\"config\");",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "ins1PreCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":"public void testIterationOrder() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();  assertEquals(Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "label":0
    },
    {
        "ins1CurCode":"assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1PreCode":"assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(\"author\"));",
        "ins2PreCode":"assertEquals(Optional.of(\"some text and \\\\latex\"), result.getDatabase().getPreamble()); assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSelect() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Integer> ids = new ArrayList<Integer>();",
        "ins1PreCode":"public void testSelect() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Integer> ids = new ArrayList<Integer>(); ids.add(1); ids.add(3); ids.add(5); Parameter parameter = new Parameter(); parameter.setEnabled(true); parameter.setSchema(\"ibtest\"); parameter.setIds(ids);  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.select\", parameter);  assertTrue(answer.size() == 3); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testSelectSimple() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Integer> ids = new ArrayList<Integer>(); ids.add(1); ids.add(3); ids.add(5); Parameter parameter = new Parameter(); parameter.setEnabled(true); parameter.setSchema(\"ibtest\"); parameter.setIds(ids);  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.select_simple\", parameter);  assertTrue(answer.size() == 3); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public Range findDomainBounds(XYDataset dataset) { Args.nullNotPermitted(dataset, \"dataset\"); double minimum = Double.POSITIVE_INFINITY;",
        "ins1PreCode":"public Range findDomainBounds(XYDataset dataset) { ParamChecks.nullNotPermitted(dataset, \"dataset\"); double minimum = Double.POSITIVE_INFINITY;",
        "ins2PreCode":"public Range findRangeBounds(XYDataset dataset) { ParamChecks.nullNotPermitted(dataset, \"dataset\"); double minimum = Double.POSITIVE_INFINITY;",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindLiveItemsLowerBound_Ascending() { DefaultXYDataset<String> d = new DefaultXYDataset<String>() { @Override",
        "ins1PreCode":"public void testFindLiveItemsLowerBound_Ascending() { DefaultXYDataset d = new DefaultXYDataset() { @Override",
        "ins2PreCode":"public void testFindLiveItemsLowerBound_Descending() { DefaultXYDataset d = new DefaultXYDataset() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"void errorMessageForRequestWithoutPathInfo(CapturedOutput output) throws IOException, ServletException { this.request.setServletPath(\"/test\"); this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new RuntimeException(); }); this.filter.doFilter(this.request, this.response, this.chain); assertThat(output).contains(\"request [/test]\");",
        "ins1PreCode":"void errorMessageForRequestWithoutPathInfo(CapturedOutput capturedOutput) throws IOException, ServletException { this.request.setServletPath(\"/test\"); this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new RuntimeException(); }); this.filter.doFilter(this.request, this.response, this.chain); assertThat(capturedOutput).contains(\"request [/test]\");",
        "ins2PreCode":"void errorMessageForRequestWithPathInfo(CapturedOutput capturedOutput) throws IOException, ServletException { this.request.setServletPath(\"/test\"); this.request.setPathInfo(\"/alpha\"); this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new RuntimeException(); }); this.filter.doFilter(this.request, this.response, this.chain); assertThat(capturedOutput).contains(\"request [/test/alpha]\");",
        "label":1
    },
    {
        "ins1CurCode":"g1.addURLSeries(u2); CustomXYURLGenerator g2 = (CustomXYURLGenerator) TestUtils.serialised(g1); assertEquals(g1, g2);",
        "ins1PreCode":"g1.addURLSeries(u2); CustomXYURLGenerator g2 = (CustomXYURLGenerator) TestUtilities.serialised(g1); assertEquals(g1, g2);",
        "ins2PreCode":"g1.addURLSeries(u2); CustomCategoryURLGenerator g2 = (CustomCategoryURLGenerator) TestUtilities.serialised(g1); assertEquals(g1, g2);",
        "label":1
    },
    {
        "ins1CurCode":"void additionalMetadataIsLocatedInGradle3Build() throws IOException { File app = new File(this.tempDir, \"app\"); File classesLocation = new File(app, \"build/classes/main\");",
        "ins1PreCode":"public void additionalMetadataIsLocatedInGradle3Build() throws IOException { File app = this.temp.newFolder(\"app\"); File classesLocation = new File(app, \"build/classes/main\");",
        "ins2PreCode":"public void additionalMetadataIsLocatedInGradle4Build() throws IOException { File app = this.temp.newFolder(\"app\"); File classesLocation = new File(app, \"build/classes/java/main\");",
        "label":1
    },
    {
        "ins1CurCode":"Flowable<Integer> f2 = createInfiniteFlowable(generatedB).take(Flowable.bufferSize() * 2);  TestSubscriber<String> ts = new TestSubscriber<>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "ins1PreCode":"Flowable<Integer> f2 = createInfiniteFlowable(generatedB).take(Flowable.bufferSize() * 2);  TestSubscriber<String> ts = new TestSubscriber<String>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "ins2PreCode":"Flowable<Integer> f2 = createInfiniteFlowable(generatedB).subscribeOn(Schedulers.computation());  TestSubscriber<String> ts = new TestSubscriber<String>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "label":1
    },
    {
        "ins1CurCode":"assertActivation( true, profile, newContext( null, newProperties( \"1.6\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0_09\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0_09-b03\" ) ) );",
        "ins1PreCode":"assertActivation( true, profile, newContext( null, newProperties( \"1.6\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0\" ) ) );   ",
        "ins2PreCode":"public void testVersionRangeInclusiveLowerBound() throws Exception { Profile profile = newProfile( \"[1.5,)\" );  assertActivation( false, profile, newContext( null, newProperties( \"1.4\" ) ) ); assertActivation( false, profile, newContext( null, newProperties( \"1.4.2\" ) ) ); assertActivation( false, profile, newContext( null, newProperties( \"1.4.2_09\" ) ) ); assertActivation( false, profile, newContext( null, newProperties( \"1.4.2_09-b03\" ) ) );  assertActivation( true, profile, newContext( null, newProperties( \"1.5\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.5.0\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.5.0_09\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.5.0_09-b03\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.5.1\" ) ) );  assertActivation( true, profile, newContext( null, newProperties( \"1.6\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0_09\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0_09-b03\" ) ) );",
        "label":0
    },
    {
        "ins1CurCode":"ParserResult result = parser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\")); ",
        "ins1PreCode":"ParserResult result = parser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor); ",
        "ins2PreCode":"public void parseRecognizesFieldsWithEscapedQuotationMarks() throws IOException {  ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Test {\\\" Test}\\\"}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), entry.getField(\"author\"));",
        "label":0
    },
    {
        "ins1CurCode":"wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"ftp://\" + getHostName() + \":\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins1PreCode":"wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins2PreCode":"public void testConnectToServerEndpointNoHost() throws Exception { Tomcat tomcat = getTomcatInstance();  Context ctx = tomcat.addContext(\"\", null); ctx.addApplicationListener(TesterEchoServer.Config.class.getName());  tomcat.start();  WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"ws://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":0
    },
    {
        "ins1CurCode":"public void findByPrincipal() { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();",
        "ins1PreCode":"public void findByPrincipal() throws Exception { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();",
        "ins2PreCode":"public void findByPrincipalAndType() throws Exception { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository();",
        "label":1
    },
    {
        "ins1CurCode":"res = resolver.resolveConflicts( graph, ArtifactScopeEnum.compile );  assertNotNull( res, \"null graph after resolver\" ); assertNotNull( res.getVertices(), \"no vertices in the resulting graph after resolver\" );  assertNotNull( res.getExcidentEdges(v1), \"no edges in the resulting graph after resolver\" );  assertEquals( 4, res.getVertices().size(), \"wrong # of vertices in the resulting graph after resolver\" ); assertEquals( 2, res.getExcidentEdges(v1).size(), \"wrong # of excident edges in the resulting graph entry after resolver\" );  assertEquals( 1, res.getIncidentEdges(v2).size(), \"wrong # of v2 incident edges in the resulting graph after resolver\" ); assertEquals( \"1.2\", res.getIncidentEdges(v2).get(0).getVersion(), \"wrong edge v1-v2 in the resulting graph after resolver\" );  assertEquals( 1, res.getIncidentEdges(v3).size(), \"wrong # of edges v1-v3 in the resulting graph after resolver\" ); assertEquals( \"1.1\", res.getIncidentEdges(v3).get(0).getVersion(), \"wrong edge v1-v3 in the resulting graph after resolver\" );  assertEquals( 1, res.getIncidentEdges(v4).size(), \"wrong # of edges v3-v4 in the resulting graph after resolver\" ); assertEquals( \"1.2\", res.getIncidentEdges(v4).get(0).getVersion(), \"wrong edge v3-v4 in the resulting graph after resolver\" );",
        "ins1PreCode":"res = resolver.resolveConflicts( graph, ArtifactScopeEnum.compile );  assertNotNull(\"null graph after resolver\", res ); assertNotNull(\"no vertices in the resulting graph after resolver\", res.getVertices() );  assertNotNull(\"no edges in the resulting graph after resolver\", res.getExcidentEdges(v1) );  assertEquals( \"wrong # of vertices in the resulting graph after resolver\", 4, res.getVertices().size() ); assertEquals( \"wrong # of excident edges in the resulting graph entry after resolver\", 2, res.getExcidentEdges(v1).size() );  assertEquals( \"wrong # of v2 incident edges in the resulting graph after resolver\", 1, res.getIncidentEdges(v2).size() ); assertEquals( \"wrong edge v1-v2 in the resulting graph after resolver\", \"1.2\", res.getIncidentEdges(v2).get(0).getVersion() );  assertEquals( \"wrong # of edges v1-v3 in the resulting graph after resolver\", 1, res.getIncidentEdges(v3).size() ); assertEquals( \"wrong edge v1-v3 in the resulting graph after resolver\", \"1.1\", res.getIncidentEdges(v3).get(0).getVersion() );  assertEquals( \"wrong # of edges v3-v4 in the resulting graph after resolver\", 1, res.getIncidentEdges(v4).size() ); assertEquals( \"wrong edge v3-v4 in the resulting graph after resolver\", \"1.2\", res.getIncidentEdges(v4).get(0).getVersion() );",
        "ins2PreCode":"res = resolver.resolveConflicts( graph, ArtifactScopeEnum.runtime );  assertNotNull(\"null graph after resolver\", res ); assertNotNull(\"no vertices in the resulting graph after resolver\", res.getVertices() ); assertNotNull(\"no edges in the resulting graph after resolver\", res.getExcidentEdges(v1) );  assertEquals( \"wrong # of vertices in the resulting graph after resolver\", 4, res.getVertices().size() ); assertEquals( \"wrong # of excident edges in the resulting graph entry after resolver\", 2, res.getExcidentEdges(v1).size() );  assertEquals( \"wrong # of v2 incident edges in the resulting graph after resolver\", 1, res.getIncidentEdges(v2).size() ); assertEquals( \"wrong edge v1-v2 in the resulting graph after resolver\", \"1.2\", res.getIncidentEdges(v2).get(0).getVersion() );  assertEquals( \"wrong # of edges v1-v3 in the resulting graph after resolver\", 1, res.getIncidentEdges(v3).size() ); assertEquals( \"wrong edge v1-v3 in the resulting graph after resolver\", \"1.1\", res.getIncidentEdges(v3).get(0).getVersion() );  assertEquals( \"wrong # of edges v3-v4 in the resulting graph after resolver\", 1, res.getIncidentEdges(v4).size() ); assertEquals( \"wrong edge v3-v4 in the resulting graph after resolver\", \"1.1\", res.getIncidentEdges(v4).get(0).getVersion() );",
        "label":1
    },
    {
        "ins1CurCode":"if(log.isDebugEnabled()) log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (Session session : sessions) { if (session != null && !session.isValid()) { expireHere++;",
        "ins1PreCode":"if(log.isDebugEnabled()) log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (int i = 0; i < sessions.length; i++) { if (sessions[i]!=null && !sessions[i].isValid()) { expireHere++;",
        "ins2PreCode":"if(log.isDebugEnabled()) log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (int i = 0; i < sessions.length; i++) { if (!sessions[i].isValid()) { expiredSessions.incrementAndGet();",
        "label":1
    },
    {
        "ins1CurCode":"} catch (IllegalAccessException e) { throw new RuntimeException( \"Couldn't use Java reflection to implement protocol message reflection.\", e); } catch (InvocationTargetException e) {",
        "ins1PreCode":"} catch (IllegalAccessException e) { throw new RuntimeException( \"Couldn't use Java reflection to implement protocol message \" + \"reflection.\", e); } catch (InvocationTargetException e) {",
        "ins2PreCode":"private static Object invokeOrDie( final Method method, final Object object, final Object... params) { try { return method.invoke(object, params); } catch (IllegalAccessException e) { throw new RuntimeException( \"Couldn't use Java reflection to implement protocol message \" + \"reflection.\", e); } catch (InvocationTargetException e) { final Throwable cause = e.getCause(); if (cause instanceof RuntimeException) { throw (RuntimeException) cause; } else if (cause instanceof Error) { throw (Error) cause; } else { throw new RuntimeException( \"Unexpected exception thrown by generated accessor method.\", cause); } }",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"public void matchWithIncludeFilter() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter( WithIncludeFilter.class); assertThat(excludes(filter, Controller1.class)).isFalse(); assertThat(excludes(filter, Controller2.class)).isFalse(); assertThat(excludes(filter, ExampleControllerAdvice.class)).isFalse(); assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldSelectDraftTypedPosts() { try (SqlSession session = sqlSessionFactory.openSession()) { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class);",
        "ins1PreCode":"public void shouldSelectDraftTypedPosts() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); List<Post> posts = mapper.selectPosts(); assertEquals(5, posts.size()); assertTrue(posts.get(0) instanceof DraftPost); assertFalse(posts.get(1) instanceof DraftPost); assertTrue(posts.get(2) instanceof DraftPost); assertFalse(posts.get(3) instanceof DraftPost); assertFalse(posts.get(4) instanceof DraftPost); } finally { session.close(); }",
        "ins2PreCode":"public void shouldSelectDraftTypedPostsWithResultMap() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); List<Post> posts = mapper.selectPostsWithResultMap(); assertEquals(5, posts.size()); assertTrue(posts.get(0) instanceof DraftPost); assertFalse(posts.get(1) instanceof DraftPost); assertTrue(posts.get(2) instanceof DraftPost); assertFalse(posts.get(3) instanceof DraftPost); assertFalse(posts.get(4) instanceof DraftPost); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public static long produced(@NonNull AtomicLong requested, long n) { for (;;) {",
        "ins1PreCode":"public static long produced(AtomicLong requested, long n) { for (;;) {",
        "ins2PreCode":"public static long producedCancel(AtomicLong requested, long n) { for (;;) {",
        "label":1
    },
    {
        "ins1CurCode":"public List<Descriptor<ComputerLauncher>> applicableDescriptors(@CheckForNull Slave it, @NonNull Slave.SlaveDescriptor itDescriptor) { List<Descriptor<ComputerLauncher>> r = new ArrayList<>();",
        "ins1PreCode":"public List<Descriptor<ComputerLauncher>> applicableDescriptors(@CheckForNull Slave it, @Nonnull Slave.SlaveDescriptor itDescriptor) { List<Descriptor<ComputerLauncher>> r = new ArrayList<>();",
        "ins2PreCode":"public List<Descriptor<ComputerLauncher>> getApplicableDescriptors() { List<Descriptor<ComputerLauncher>> r = new ArrayList<>(); for (Descriptor<ComputerLauncher> d : Jenkins.get().getDescriptorList(ComputerLauncher.class)) { if (DelegatingComputerLauncher.class.isAssignableFrom(d.getKlass().toJavaClass()))  continue; r.add(d); } return r;",
        "label":0
    },
    {
        "ins1CurCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { NettyReactiveWebServerFactory factory = getFactory(); factory.setShutdown(Shutdown.GRACEFUL); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient(this.webServer.getPort()).build(); this.webServer.shutDownGracefully((result) -> { }); Awaitility.await().atMost(Duration.ofSeconds(30)).until(() -> { blockingHandler.stopBlocking(); try { webClient.get().retrieve().toBodilessEntity().block(); return false; } catch (RuntimeException ex) { return ex.getCause() instanceof ConnectException; } }); this.webServer.stop();",
        "ins1PreCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { NettyReactiveWebServerFactory factory = getFactory(); Shutdown shutdown = new Shutdown(); shutdown.setGracePeriod(Duration.ofSeconds(5)); factory.setShutdown(shutdown); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient(this.webServer.getPort()).build(); webClient.get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown(); AtomicReference<Throwable> errorReference = new AtomicReference<>(); webClient.get().retrieve().toBodilessEntity().doOnError(errorReference::set).subscribe(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); this.webServer.stop(); assertThat(errorReference.get()).hasCauseInstanceOf(ConnectException.class);",
        "ins2PreCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { JettyReactiveWebServerFactory factory = getFactory(); Shutdown shutdown = new Shutdown(); shutdown.setGracePeriod(Duration.ofSeconds(5)); factory.setShutdown(shutdown); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); int port = this.webServer.getPort(); CountDownLatch responseLatch = new CountDownLatch(1); getWebClient(port).build().get().retrieve().toBodilessEntity() .subscribe((response) -> responseLatch.countDown()); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown(); Mono<ResponseEntity<Void>> unconnectableRequest = getWebClient(port).build().get().retrieve() .toBodilessEntity(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> unconnectableRequest.block()) .withCauseInstanceOf(ConnectException.class);",
        "label":1
    },
    {
        "ins1CurCode":"+ \"  year = {2005},\" + \"\\n\" + \"  owner = {oezbek},\" + \"\\n\" + \"  timestamp = {2006.05.29},\" + \"\\n\" + \"  url = {http://james.howison.name/publications.html}\" + \"\\n\" + \"}))\"), importFormatPreferences, fileMonitor); assertEquals(Optional.empty(), result.getMetaData().getEncoding());",
        "ins1PreCode":"+ \"  year = {2005},\" + \"\\n\" + \"  owner = {oezbek},\" + \"\\n\" + \"  timestamp = {2006.05.29},\" + \"\\n\" + \"  url = {http://james.howison.name/publications.html}\" + \"\\n\" + \"}))\"), importFormatPreferences); assertEquals(Optional.empty(), result.getMetaData().getEncoding());",
        "ins2PreCode":"+ \"  year = {2005},\" + \"\\n\" + \"  owner = {oezbek},\" + \"\\n\" + \"  timestamp = {2006.05.29},\" + \"\\n\" + \"  url = {http://james.howison.name/publications.html}\" + \"\\n\" + \"}))\"), importFormatPreferences); Collection<BibEntry> c = result.getDatabase().getEntries();",
        "label":1
    },
    {
        "ins1CurCode":"values.add(100.0); dataset.add(values, \"row\", \"column\"); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), new BoxAndWhiskerRenderer());",
        "ins1PreCode":"values.add(100.0); dataset.add(values, \"row\", \"column\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), new BoxAndWhiskerRenderer());",
        "ins2PreCode":"values.add(100.0); dataset.add(values, \"row\", \"column\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), new BoxAndWhiskerRenderer());",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsInvalid() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1a,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1a,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"aa,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse 'aa,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1,2a,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2a,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1,aa,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,aa,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,3a\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2,3a', expected number\"));  result = command .authorizedTo(Jenkins.READ, Item.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,aa\");",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsInvalid() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1a,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1a,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"aa,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse 'aa,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2a,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2a,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,aa,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,aa,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,3a\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2,3a', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,aa\");",
        "ins2PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsSpace() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1, ,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1, ,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2, \");",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposable.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposable.empty(); ",
        "ins1PreCode":"protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "ins2PreCode":"protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"void testComplexQueryRegex() { String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1PreCode":"public void testComplexQueryRegex() { double textSize = 13; String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testComplexQueryCaseSensitive() { double textSize = 13; String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1CurCode":"public void outEdges_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N1);",
        "ins1PreCode":"public void outEdges_checkReturnedSetMutability() { addNode(N1); Set<String> outEdges = network.outEdges(N1); try {",
        "ins2PreCode":"public void incidentEdges_checkReturnedSetMutability() { addNode(N1); Set<String> incidentEdges = network.incidentEdges(N1); try { incidentEdges.add(E12); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.incidentEdges(N1)).containsExactlyElementsIn(incidentEdges); }",
        "label":0
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"} } if (moveTopAction != null) { popup.add(moveTopAction); popup.add(moveBottomAction); popup.add(moveUpAction); popup.add(moveDownAction); }",
        "ins1PreCode":"} } if (popup.getComponentCount() > 0) { popup.show(this, e.getX(), e.getY()); } e.consume(); }",
        "ins2PreCode":"} } if (popup.getComponentCount() > 0) { popup.show(this, e.getX(), e.getY()); } e.consume(); }",
        "label":1
    },
    {
        "ins1CurCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(new UnknownField(\"a\")));",
        "ins1PreCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins2PreCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"ups  \\tsala\"), parsedEntry.getField(FieldName.ABSTRACT));",
        "label":0
    },
    {
        "ins1CurCode":"public void testAddSeries() { DefaultIntervalXYDataset<String> d = new DefaultIntervalXYDataset<>(); d.addSeries(\"S1\", new double[][] {{1.0}, {0.5}, {1.5}, {2.0}, {2.5}, {1.5}}); assertEquals(1, d.getSeriesCount()); assertEquals(\"S1\", d.getSeriesKey(0));   d.addSeries(\"S1\", new double[][] {{1.1}, {0.6}, {1.6}, {2.1}, {2.6}, {1.6}}); assertEquals(1, d.getSeriesCount()); assertEquals(2.1, d.getYValue(0, 0), EPSILON);   boolean pass = false; try { d.addSeries(null, new double[][] {{1.1}, {0.6}, {1.6}, {2.1}, {2.6}, {1.6}}); } catch (IllegalArgumentException e) { pass = true;",
        "ins1PreCode":"public void testAddSeries() { DefaultIntervalXYDataset d = new DefaultIntervalXYDataset(); d.addSeries(\"S1\", new double[][] {{1.0}, {0.5}, {1.5}, {2.0}, {2.5}, {1.5}}); assertEquals(1, d.getSeriesCount()); assertEquals(\"S1\", d.getSeriesKey(0));   d.addSeries(\"S1\", new double[][] {{1.1}, {0.6}, {1.6}, {2.1}, {2.6}, {1.6}}); assertEquals(1, d.getSeriesCount()); assertEquals(2.1, d.getYValue(0, 0), EPSILON);   boolean pass = false; try { d.addSeries(null, new double[][] {{1.1}, {0.6}, {1.6}, {2.1}, {2.6}, {1.6}}); } catch (IllegalArgumentException e) { pass = true;",
        "ins2PreCode":"public void testAddSeries() { DefaultXYDataset d = new DefaultXYDataset(); d.addSeries(\"S1\", new double[][] {{1.0}, {2.0}});",
        "label":1
    },
    {
        "ins1CurCode":".willReturn(Boolean.TRUE); this.listener.beforeTestMethod(mockTestContext); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "ins1PreCode":".willReturn(Boolean.TRUE); this.listener.beforeTestMethod(mockTestContext); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), (MockDefinition) any()); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "ins2PreCode":"public void prepareTestInstanceShouldInjectMockBean() throws Exception { WithMockBean instance = new WithMockBean(); this.listener.prepareTestInstance(mockTestContext(instance)); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "label":0
    },
    {
        "ins1CurCode":"return exec(project, cmd, env); } throw new IOException( \"Cannot locate antRun script: No project provided\"); }  String antHome = project.getProperty(MagicNames.ANT_HOME); if (antHome == null) { throw new IOException(\"Cannot locate antRun script: Property '\" + MagicNames.ANT_HOME + \"' not found\"); }",
        "ins1PreCode":"return exec(project, cmd, env); } throw new IOException(\"Cannot locate antRun script: \" + \"No project provided\"); }  String antHome = project.getProperty(MagicNames.ANT_HOME); if (antHome == null) { throw new IOException(\"Cannot locate antRun script: \" + \"Property '\" + MagicNames.ANT_HOME + \"' not found\"); }",
        "ins2PreCode":"return exec(project, cmd, env); } throw new IOException(\"Cannot locate antRun script: \" + \"No project provided\"); }  String antHome = project.getProperty(MagicNames.ANT_HOME); if (antHome == null) { throw new IOException(\"Cannot locate antRun script: \" + \"Property '\" + MagicNames.ANT_HOME + \"' not found\"); }",
        "label":1
    },
    {
        "ins1CurCode":"public void extend() { final TestObserver<Object> to = new TestObserver<>(); final Object value = new Object();",
        "ins1PreCode":"public void extend() { final TestObserver<Object> to = new TestObserver<Object>(); final Object value = new Object();",
        "ins2PreCode":"public void asExtend() { final TestObserver<Object> to = new TestObserver<Object>(); final Object value = new Object();",
        "label":1
    },
    {
        "ins1CurCode":"void updateTimestampEnabled() { final String timestampField = \"timestamp\";",
        "ins1PreCode":"public void updateTimestampEnabled() { final String timestampField = \"timestamp\";",
        "ins2PreCode":"public void updateTimestampDisabled() { final String timestampField = \"timestamp\";",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1)); assertThat(project.isBuilding(), equalTo(true)); j.jenkins.doQuietDown(); QuietDownCommandTest.assertJenkinsInQuietMode(j);",
        "ins1PreCode":"assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1)); assertThat(project.isBuilding(), equalTo(true)); j.jenkins.getActiveInstance().doQuietDown(); QuietDownCommandTest.assertJenkinsInQuietMode(j);",
        "ins2PreCode":"public void cancelQuietDownShouldSuccessOnNoQuietDownedJenkinsAndRunningExecutor() throws Exception { final FreeStyleProject project = j.createFreeStyleProject(\"aProject\"); final OneShotEvent finish = new OneShotEvent(); Future<FreeStyleBuild> build = OnlineNodeCommandTest.startBlockingAndFinishingBuild(project, finish); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1));  final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Jenkins.ADMINISTER) .invoke(); assertThat(result, succeededSilently()); QuietDownCommandTest.assertJenkinsNotInQuietMode(j); finish.signal(); build.get(); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1)); assertThat(project.isBuilding(), equalTo(false)); j.assertBuildStatusSuccess(build); QuietDownCommandTest.assertJenkinsNotInQuietMode(j); build = OnlineNodeCommandTest.startBlockingAndFinishingBuild(project, finish); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(2)); assertThat(project.isBuilding(), equalTo(true)); finish.signal(); build.get(); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(2)); assertThat(project.isBuilding(), equalTo(false)); j.assertBuildStatusSuccess(build); QuietDownCommandTest.assertJenkinsNotInQuietMode(j);",
        "label":0
    },
    {
        "ins1CurCode":" try { ms = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"set.add(new DOAJFetcher(importFormatPreferences)); set.add(new IEEE(importFormatPreferences)); set.add(new CompositeSearchBasedFetcher(set, 30)); return set;",
        "ins1PreCode":"set.add(new DOAJFetcher(importFormatPreferences)); set.add(new IEEE(importFormatPreferences)); return set;",
        "ins2PreCode":"public static SortedSet<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { SortedSet<IdBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); set.add(new ArXiv(importFormatPreferences)); set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new IsbnFetcher(importFormatPreferences)); set.add(new DiVA(importFormatPreferences)); set.add(new DoiFetcher(importFormatPreferences)); set.add(new MedlineFetcher()); set.add(new TitleFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); return set;",
        "label":0
    },
    {
        "ins1CurCode":" TestHelper.checkDisposed(Flowable.range(1, 2) .concatMapDelayError(Functions.justFunction(Flowable.just(1)), true, 2, ImmediateThinScheduler.INSTANCE));",
        "ins1PreCode":" TestHelper.checkDisposed(Flowable.range(1, 2) .concatMapDelayError(Functions.justFunction(Flowable.just(1)), 2, true, ImmediateThinScheduler.INSTANCE));",
        "ins2PreCode":"public void dispose() { TestHelper.checkDisposed(Flowable.range(1, 2) .concatMap(Functions.justFunction(Flowable.just(1))));  TestHelper.checkDisposed(Flowable.range(1, 2) .concatMapDelayError(Functions.justFunction(Flowable.just(1))));",
        "label":0
    },
    {
        "ins1CurCode":"public void issue2826() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); final RuntimeException e = new RuntimeException(\"You shall not pass\");",
        "ins1PreCode":"public void issue2826() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final RuntimeException e = new RuntimeException(\"You shall not pass\");",
        "ins2PreCode":"public void issue2826() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); final RuntimeException e = new RuntimeException(\"You shall not pass\");",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"field\", \"field1\"); try { factory.create(null, null, null, config); fail(\"factory create should have failed\");",
        "ins1PreCode":"config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "ins2PreCode":"config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "label":1
    },
    {
        "ins1CurCode":"result.subscribe(o);  List<Integer> list = new ArrayList<>(n); for (int i = 0; i < n; i++) {",
        "ins1PreCode":"result.subscribe(o);  List<Integer> list = new ArrayList<Integer>(n); for (int i = 0; i < n; i++) {",
        "ins2PreCode":"result.subscribe(o);  List<Integer> list = new ArrayList<Integer>(n); for (int i = 0; i < n / 2; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins1PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOffFromSpecificLocation() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> ambArray(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T> Flowable<T> ambArray(Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T> Observable<T> ambArray(@NonNull ObservableSource<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "label":1
    },
    {
        "ins1CurCode":"FigNode figNode = null;  assert node != null;    Diagram diag = ((LayerPerspective) lay).getDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.error(\"TODO: CollabDiagramRenderer getFigNodeFor\"); throw new IllegalArgumentException( \"Node is not a recognised type. Received \" + node.getClass().getName()); }",
        "ins1PreCode":"figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.debug(\"TODO: CollabDiagramRenderer getFigNodeFor\"); return null; }",
        "ins2PreCode":"public FigNode getFigNodeFor(GraphModel gm, Layer lay, Object node, Map styleAttributes) {  FigNode figNode = null;   Diagram diag = ((LayerPerspective) lay).getDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.debug(\"TODO: StateDiagramRenderer getFigNodeFor\"); return null; }  lay.add(figNode); return figNode;",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"trace\")).isFalse();",
        "ins1PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse();",
        "ins2PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"Set<AbstractProject> tups = graph.getTransitiveUpstream(this); for (AbstractProject tup : tups) { if(tup.isBuilding() || tup.isInQueue()) return tup;",
        "ins1PreCode":"DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); tups.add(this); for (AbstractProject tup : tups) { if(tup!=this && (tup.isBuilding() || tup.isInQueue())) return tup;",
        "ins2PreCode":"Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue();  for (AbstractProject tup : tups) { if(tup.isBuilding() || queue.getUnblockedItems().containsKey(tup)) return tup;",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerToolTipGenerator g1 = new BoxAndWhiskerToolTipGenerator(); BoxAndWhiskerToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerToolTipGenerator g1 = new BoxAndWhiskerToolTipGenerator(); BoxAndWhiskerToolTipGenerator g2 = (BoxAndWhiskerToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowItemLabelGenerator g1 = new HighLowItemLabelGenerator(); HighLowItemLabelGenerator g2 = (HighLowItemLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"boolean mustChange = true; if (expression != null) { Object oldValue = Model.getFacade().getBody(expression).toString(); if (oldValue != null && oldValue.equals(body)) {",
        "ins1PreCode":"boolean mustChange = true; if (expression != null) { Object oldValue = Model.getDataTypesHelper().getBody(expression); if (oldValue != null && oldValue.equals(body)) {",
        "ins2PreCode":"public void setBody(String body) { boolean mustChange = true; if (expression != null) { Object oldValue = Model.getDataTypesHelper().getBody(expression); if (oldValue != null && oldValue.equals(body)) { mustChange = false; } } if (mustChange) { String lang = null; if (expression != null) { lang = Model.getDataTypesHelper().getLanguage(expression); } if (lang == null) { lang = EMPTYSTRING; }  setExpression(lang, body); }",
        "label":0
    },
    {
        "ins1CurCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void fusedNoSync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC); ",
        "label":1
    },
    {
        "ins1CurCode":" runBasicDataSourceExample(spark); runGenericFileSourceOptionsExample(spark); runBasicParquetExample(spark);",
        "ins1PreCode":" runBasicDataSourceExample(spark); runBasicParquetExample(spark); runParquetSchemaMergingExample(spark);",
        "ins2PreCode":"public static void main(String[] args) throws AnalysisException {  SparkSession spark = SparkSession .builder() .appName(\"Java Spark SQL basic example\") .config(\"spark.some.config.option\", \"some-value\") .getOrCreate();   runBasicDataFrameExample(spark); runDatasetCreationExample(spark); runInferSchemaExample(spark); runProgrammaticSchemaExample(spark);  spark.stop();",
        "label":0
    },
    {
        "ins1CurCode":"public void onError(Throwable t) { List<GroupedUnicast<K, V>> list = new ArrayList<>(groups.values()); groups.clear();",
        "ins1PreCode":"public void onError(Throwable t) { List<GroupedUnicast<K, V>> list = new ArrayList<GroupedUnicast<K, V>>(groups.values()); groups.clear();",
        "ins2PreCode":"public void onComplete() { List<GroupedUnicast<K, V>> list = new ArrayList<GroupedUnicast<K, V>>(groups.values()); groups.clear();",
        "label":1
    },
    {
        "ins1CurCode":"public void testParseTld21() throws Exception { TaglibXml xml = parse(\"test/tld/tags21.tld\"); Assert.assertEquals(\"1.0\", xml.getTlibVersion());",
        "ins1PreCode":"public void testParseTld21() throws Exception { TaglibXml xml = parse(\"test/webapp-3.1/WEB-INF/tags21.tld\"); Assert.assertEquals(\"1.0\", xml.getTlibVersion());",
        "ins2PreCode":"public void testParseTld11() throws Exception { TaglibXml xml = parse(\"test/webapp-3.1/WEB-INF/tags11.tld\"); Assert.assertEquals(\"1.0\", xml.getTlibVersion());",
        "label":1
    },
    {
        "ins1CurCode":"}  Iterator<SelectionKey> it = selector.selectedKeys().iterator(); while (it.hasNext()) { SelectionKey sk = it.next(); it.remove();",
        "ins1PreCode":"}  Iterator it = selector.selectedKeys().iterator(); while (it.hasNext()) { SelectionKey sk = (SelectionKey) it.next(); it.remove();",
        "ins2PreCode":"}  Iterator it = selector.selectedKeys().iterator(); while (it.hasNext()) { SelectionKey sk = (SelectionKey) it.next(); it.remove();",
        "label":1
    },
    {
        "ins1CurCode":"} try (BufferedReader reader = new BufferedReader(new StringReader(input))) { return reader.lines().collect(Collectors.toList()); }",
        "ins1PreCode":"return Collections.emptyList(); } List<String> lines = new ArrayList<>(); try (BufferedReader reader = new BufferedReader(new StringReader(input))) { String line; while ((line = reader.readLine()) != null) { lines.add(line); } return lines; }",
        "ins2PreCode":"return Collections.emptyList(); } List<String> lines = new ArrayList<>(); try (BufferedReader reader = new BufferedReader(new StringReader(input))) { String line; while ((line = reader.readLine()) != null) { lines.add(line); } return lines; }",
        "label":1
    },
    {
        "ins1CurCode":"  XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); ",
        "ins1PreCode":"  XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); ",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"public void completePartOfWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);",
        "ins1PreCode":"public void completePartOfWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "ins2PreCode":"public void completeReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"public void parseTraceArg() { addPropertiesToEnvironment(this.context, \"trace\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins1PreCode":"public void parseTraceArg() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"trace\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins2PreCode":"public void parseLevels() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=TRACE\");",
        "label":1
    },
    {
        "ins1CurCode":"parseRole(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.association-role\"; Object[] args = {",
        "ins1PreCode":"parseRole(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.association-end-name\"; Object[] args = {",
        "ins2PreCode":"public void parse(final Object modelElement, final String text) { try { parseMessage(modelElement, text); } catch (ParseException pe) { final String msg = \"statusmsg.bar.error.parsing.message\"; final Object[] args = {pe.getLocalizedMessage(), Integer.valueOf(pe.getErrorOffset()), }; ArgoEventPump.fireEvent(new ArgoHelpEvent( ArgoEventTypes.HELP_CHANGED, this, Translator.messageFormat(msg, args))); }",
        "label":0
    },
    {
        "ins1CurCode":"void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { Ssl ssl = new Ssl();",
        "ins1PreCode":"public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { Ssl ssl = new Ssl();",
        "ins2PreCode":"public void sslNeedsClientAuthenticationFailsWithoutClientCertificate() { Ssl ssl = new Ssl();",
        "label":1
    },
    {
        "ins1CurCode":"public final <@NonNull U extends Collection<? super T>> Flowable<U> buffer( long timespan, @NonNull TimeUnit unit,",
        "ins1PreCode":"public final <U extends Collection<? super T>> Flowable<U> buffer( long timespan, @NonNull TimeUnit unit,",
        "ins2PreCode":"public final Flowable<Flowable<T>> window( long timespan, @NonNull TimeUnit unit, @NonNull Scheduler scheduler, long count, boolean restart, int bufferSize) { ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); Objects.requireNonNull(scheduler, \"scheduler is null\"); Objects.requireNonNull(unit, \"unit is null\"); ObjectHelper.verifyPositive(count, \"count\"); return RxJavaPlugins.onAssembly(new FlowableWindowTimed<>(this, timespan, timespan, unit, scheduler, count, bufferSize, restart));",
        "label":0
    },
    {
        "ins1CurCode":"public static synchronized void setDefaultSearchPath(String... domains) throws TextParseException { if (domains == null) {",
        "ins1PreCode":"public static synchronized void setDefaultSearchPath(String[] domains) throws TextParseException { if (domains == null) {",
        "ins2PreCode":"public void setSearchPath(String[] domains) throws TextParseException { if (domains == null) {",
        "label":1
    },
    {
        "ins1CurCode":"void testGetPerson() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testGetPerson() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testGetPersonOrderedByItem() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator(); BubbleXYItemLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator(); BubbleXYItemLabelGenerator g2 = (BubbleXYItemLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StandardCategoryToolTipGenerator g1 = new StandardCategoryToolTipGenerator(); StandardCategoryToolTipGenerator g2 = (StandardCategoryToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator();",
        "ins1PreCode":"public final void blockingForEach(Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator();",
        "ins2PreCode":"public final void blockingForEach(Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator();",
        "label":1
    },
    {
        "ins1CurCode":"this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "ins1PreCode":"this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "ins2PreCode":"this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "label":1
    },
    {
        "ins1CurCode":"private static List<LocalizationEntry> getLanguageKeysInJavaFile(Path path, LocalizationBundleForTest type) { List<String> lines; try { lines = Files.readAllLines(path, StandardCharsets.UTF_8); } catch (IOException exception) { throw new RuntimeException(exception); } String content = String.join(\"\\n\", lines); return JavaLocalizationEntryParser.getLanguageKeysInString(content, type).stream() .map(key -> new LocalizationEntry(path, key, type)) .collect(Collectors.toList());",
        "ins1PreCode":"private static List<LocalizationEntry> getLanguageKeysInJavaFile(Path path, LocalizationBundleForTest type) { List<LocalizationEntry> result = new ArrayList<>();  try { List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); String content = String.join(\"\\n\", lines);  List<String> keys = JavaLocalizationEntryParser.getLanguageKeysInString(content, type);  for (String key : keys) { result.add(new LocalizationEntry(path, key, type)); } } catch (IOException exception) { throw new RuntimeException(exception); }  return result;",
        "ins2PreCode":"private static List<LocalizationEntry> getLocalizationParametersInJavaFile(Path path, LocalizationBundleForTest type) { List<LocalizationEntry> result = new ArrayList<>();  try { List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); String content = String.join(\"\\n\", lines);  List<String> keys = JavaLocalizationEntryParser.getLocalizationParameter(content, type);  for (String key : keys) { result.add(new LocalizationEntry(path, key, type)); } } catch (IOException exception) { throw new RuntimeException(exception); }  return result;",
        "label":1
    },
    {
        "ins1CurCode":"void pomDependencyResolutionViaType() { Map<String, Object> args = new HashMap<>();",
        "ins1PreCode":"public void pomDependencyResolutionViaType() { Map<String, Object> args = new HashMap<>();",
        "ins2PreCode":"public void pomDependencyResolutionViaExt() { Map<String, Object> args = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"return false; } if (!Objects.equals(getToolTipText(), that.getToolTipText())) { return false; } if (!Objects.equals(getURLText(), that.getURLText())) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtils.equal(getURLText(), that.getURLText())) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtils.equal(getURLText(), that.getURLText())) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"public List<FullHttpResponse> get(SocketAddress remoteAddress, String... uris) throws InterruptedException { List<HttpRequest> requests = new ArrayList<>(uris.length); for (int i = 0; i < uris.length; i++) {",
        "ins1PreCode":"public Collection<FullHttpResponse> get(SocketAddress remoteAddress, String... uris) throws InterruptedException { Collection<HttpRequest> requests = new ArrayList<>(uris.length); for (int i = 0; i < uris.length; i++) {",
        "ins2PreCode":"public Collection<FullHttpResponse> get(InetSocketAddress remoteAddress, String... uris) throws InterruptedException { Collection<HttpRequest> requests = new ArrayList<>(uris.length); for (int i = 0; i < uris.length; i++) { final HttpRequest httpRequest = new DefaultFullHttpRequest(HTTP_1_1, HttpMethod.GET, uris[i]); httpRequest.headers().add(HOST, \"localhost\"); httpRequest.headers().add(Task.X_OPAQUE_ID, String.valueOf(i)); requests.add(httpRequest); } return sendRequests(remoteAddress, requests);",
        "label":0
    },
    {
        "ins1CurCode":"String header = \"{\\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\",\\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{\\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; assertThatExceptionOfType(CloudFoundryAuthorizationException.class) .isThrownBy(() -> this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .satisfies(reasonRequirement(Reason.INVALID_KEY_ID));",
        "ins1PreCode":"String header = \"{\\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\",\\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{\\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_KEY_ID)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "ins2PreCode":"String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.TOKEN_EXPIRED)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "label":1
    },
    {
        "ins1CurCode":"public void onNextError() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<>(); Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);",
        "ins1PreCode":"public void onNextError() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>(); Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);",
        "ins2PreCode":"public void onNextErrorAcrossThread() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Throwable> caughtError = new AtomicReference<Throwable>(); Observable<Long> o = Observable.interval(50, TimeUnit.MILLISECONDS);",
        "label":1
    },
    {
        "ins1CurCode":"List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<>(); categoricalFeaturesInfo.put(1, 2);",
        "ins1PreCode":"List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); categoricalFeaturesInfo.put(1, 2);",
        "ins2PreCode":"List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); categoricalFeaturesInfo.put(1, 2);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r2 = (DefaultCategoryItemRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StatisticalLineAndShapeRenderer r1 = new StatisticalLineAndShapeRenderer(); StatisticalLineAndShapeRenderer r2 = (StatisticalLineAndShapeRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"TestMap.EnumValue.BAR.getNumber(), builder.getInt32ToEnumFieldValueOrThrow(1)); builder.putInt32ToEnumFieldValue(1, -1); assertEquals(-1, builder.getInt32ToEnumFieldValueOrThrow(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, builder.getInt32ToEnumFieldOrThrow(1)); ",
        "ins1PreCode":"builder.putInt32ToEnumFieldValue(1, -1); fail(); } catch (IllegalArgumentException e) { ",
        "ins2PreCode":"public void testPut() { TestMap.Builder builder = TestMap.newBuilder(); builder.putInt32ToInt32Field(1, 11); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1));  builder.putInt32ToStringField(1, \"a\"); assertEquals(\"a\", builder.getInt32ToStringFieldOrThrow(1)); try { builder.putInt32ToStringField(1, null); fail(); } catch (NullPointerException e) {  }  builder.putInt32ToBytesField(1, TestUtil.toBytes(\"11\")); assertEquals(TestUtil.toBytes(\"11\"), builder.getInt32ToBytesFieldOrThrow(1)); try { builder.putInt32ToBytesField(1, null); fail(); } catch (NullPointerException e) {  }  builder.putInt32ToEnumField(1, TestMap.EnumValue.FOO); assertEquals(TestMap.EnumValue.FOO, builder.getInt32ToEnumFieldOrThrow(1)); try { builder.putInt32ToEnumField(1, null); fail(); } catch (NullPointerException e) {  }  builder.putStringToInt32Field(\"a\", 1); assertEquals(1, builder.getStringToInt32FieldOrThrow(\"a\")); try { builder.putStringToInt32Field(null, -1); } catch (NullPointerException e) {  }",
        "label":0
    },
    {
        "ins1CurCode":"U u; try { u = Objects.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\"); } catch (Throwable e) {",
        "ins1PreCode":"U u; try { u = ObjectHelper.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\"); } catch (Throwable e) {",
        "ins2PreCode":"U u; try { u = ObjectHelper.requireNonNull(initialSupplier.get(), \"The initialSupplier returned a null value\"); } catch (Throwable e) {",
        "label":1
    },
    {
        "ins1CurCode":"writer.print( \"] \" ); writer.print( problem.getMessage() ); String location = problem.getLocation(); if ( !location.isEmpty() ) { writer.print( \" @ \" ); writer.println( location ); }",
        "ins1PreCode":"writer.print( problem.getMessage() ); writer.print( \" @ \" ); writer.println( problem.getLocation() ); }",
        "ins2PreCode":"private static String toMessage( List<Problem> problems ) { StringWriter buffer = new StringWriter( 1024 );  PrintWriter writer = new PrintWriter( buffer );  writer.print( problems.size() ); writer.print( ( problems.size() == 1 ) ? \" problem was \" : \" problems were \" ); writer.print( \"encountered while building the effective toolchains\" ); writer.println();  for ( Problem problem : problems ) { writer.print( \"[\" ); writer.print( problem.getSeverity() ); writer.print( \"] \" ); writer.print( problem.getMessage() ); String location = problem.getLocation(); if ( !location.isEmpty() ) { writer.print( \" @ \" ); writer.print( location ); } writer.println(); }  return buffer.toString();",
        "label":0
    },
    {
        "ins1CurCode":"FILE_UTILS.createNewFile(tempFile); long localTimeStamp = tempFile.lastModified(); BufferedInputStream instream = new BufferedInputStream(Files.newInputStream(tempFile.toPath())); ftp.storeFile(tempFile.getName(), instream);",
        "ins1PreCode":"FILE_UTILS.createNewFile(tempFile); long localTimeStamp = tempFile.lastModified(); BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile)); ftp.storeFile(tempFile.getName(), instream);",
        "ins2PreCode":"FILE_UTILS.createNewFile(tempFile); long localTimeStamp = tempFile.lastModified(); BufferedInputStream instream = new BufferedInputStream(new FileInputStream(tempFile)); ftp.storeFile(tempFile.getName(), instream);",
        "label":1
    },
    {
        "ins1CurCode":"void shouldGetAUser() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldGetAUser() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetAUserFromAnnotation() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"void shouldConditionallyIncludeWhere() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE ID = ?\";",
        "ins1PreCode":"public void shouldConditionallyIncludeWhere() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE ID = ?\";",
        "ins2PreCode":"public void shouldConditionallyExcludeWhere() throws Exception { final String expected = \"SELECT * FROM BLOG\";",
        "label":1
    },
    {
        "ins1CurCode":"channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ); } TesterUtil.addRandomDomain(channels);",
        "ins1PreCode":"channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ); }",
        "ins2PreCode":"public void setUp() throws Exception { for (int i = 0; i < channels.length; i++) { channels[i] = new GroupChannel(); channels[i].getMembershipService().setPayload( (\"Channel-\" + (i + 1)).getBytes(\"ASCII\")); listeners[i] = new TestMbrListener( (\"Listener-\" + (i + 1))); channels[i].addMembershipListener(listeners[i]); DomainFilterInterceptor filter = new DomainFilterInterceptor(); filter.setDomain(UUIDGenerator.randomUUID(false)); channels[i].addInterceptor(filter); }",
        "label":0
    },
    {
        "ins1CurCode":"entry.setField(StandardField.AUTHOR, \"harrer\"); database.insertEntry(entry); List<BibEntry> matches = new DatabaseSearcher(new SearchQuery(\"whatever\", EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION)), database).getMatches(); assertEquals(Collections.emptyList(), matches);",
        "ins1PreCode":"entry.setField(StandardField.AUTHOR, \"harrer\"); database.insertEntry(entry); List<BibEntry> matches = new DatabaseSearcher(new SearchQuery(\"whatever\", true, true), database).getMatches(); assertEquals(Collections.emptyList(), matches);",
        "ins2PreCode":"entry.setField(StandardField.AUTHOR, \"harrer\"); database.insertEntry(entry); List<BibEntry> matches = new DatabaseSearcher(new SearchQuery(\"harrer\", true, true), database).getMatches(); assertEquals(Collections.singletonList(entry), matches);",
        "label":1
    },
    {
        "ins1CurCode":"void defaultValuesAreConsistent() { GangliaProperties properties = new GangliaProperties();",
        "ins1PreCode":"public void defaultValuesAreConsistent() { GangliaProperties properties = new GangliaProperties();",
        "ins2PreCode":"public void defaultValuesAreConsistent() { GraphiteProperties properties = new GraphiteProperties();",
        "label":1
    },
    {
        "ins1CurCode":"new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .verifyComplete(); assertThat(this.tokenValidator).hasFieldOrPropertyWithValue(\"cachedTokenKeys\", VALID_KEYS); fetchTokenKeys.assertWasSubscribed();",
        "ins1PreCode":"new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .verifyComplete(); Object cachedTokenKeys = ReflectionTestUtils.getField(this.tokenValidator, \"cachedTokenKeys\"); assertThat(cachedTokenKeys).isEqualTo(VALID_KEYS); fetchTokenKeys.assertWasSubscribed();",
        "ins2PreCode":"new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .verifyComplete(); Object cachedTokenKeys = ReflectionTestUtils.getField(this.tokenValidator, \"cachedTokenKeys\"); assertThat(cachedTokenKeys).isEqualTo(VALID_KEYS); fetchTokenKeys.assertWasSubscribed();",
        "label":1
    },
    {
        "ins1CurCode":"void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true));",
        "ins1PreCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true));",
        "ins2PreCode":"public void draggedOnBottomOfGroupAddsAfterItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true));",
        "label":1
    },
    {
        "ins1CurCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot<String> plot = new XYPlot<>(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "ins1PreCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "ins2PreCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "label":1
    },
    {
        "ins1CurCode":"void roundTripWithModification() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author  = {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins1PreCode":"void roundTripWithModification() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author  = {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1CurCode":"@Override public long convert(long d, TimeUnit2 u) { return u.toNanos(d); } @Override public long convert(long d, TimeUnit u) { return u.toNanos(d); } @Override int excessNanos(long d, long m) { return (int)(d - (m*C2)); }",
        "ins1PreCode":"@Override public long convert(long d, TimeUnit2 u) { return u.toNanos(d); } @Override public long convert(long d, TimeUnit u) { return u.toNanos(d); } int excessNanos(long d, long m) { return (int)(d - (m*C2)); }",
        "ins2PreCode":"@Override public long convert(long d, TimeUnit2 u) { return u.toMicros(d); } @Override public long convert(long d, TimeUnit u) { return u.toMicros(d); } int excessNanos(long d, long m) { return (int)((d*C1) - (m*C2)); }",
        "label":1
    },
    {
        "ins1CurCode":"return ((Number)value).longValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + long.class.getCanonicalName()); }",
        "ins1PreCode":"return ((Number)value).longValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to long\"); }",
        "ins2PreCode":"return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to float\"); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testAlternateIncludeExclude() { assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins1PreCode":"public void testAlternateIncludeExclude() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void testAlternateExcludeInclude() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1CurCode":"TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData); BibEntry inAux = new BibEntry(); inAux.setCitationKey(\"Darwin1888\"); ",
        "ins1PreCode":"TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData); BibEntry inAux = new BibEntry(); inAux.setCiteKey(\"Darwin1888\"); ",
        "ins2PreCode":"TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData); BibEntry notInAux = new BibEntry(); notInAux.setCiteKey(\"NotInAux2017\"); ",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposable.empty()); for (int i = 0; i < m; i++) {",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposables.empty()); for (int i = 0; i < m; i++) {",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposables.empty()); for (int i = 0; i < m; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":".andExpect(header(\"Authorization\", \"bearer my-access-token\")) .andRespond(withUnauthorizedRequest()); assertThatExceptionOfType(CloudFoundryAuthorizationException.class).isThrownBy( () -> this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .satisfies(reasonRequirement(Reason.INVALID_TOKEN));",
        "ins1PreCode":".andExpect(header(\"Authorization\", \"bearer my-access-token\")) .andRespond(withUnauthorizedRequest()); this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_TOKEN)); this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\");",
        "ins2PreCode":".andExpect(header(\"Authorization\", \"bearer my-access-token\")) .andRespond(withStatus(HttpStatus.FORBIDDEN)); this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.ACCESS_DENIED)); this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\");",
        "label":1
    },
    {
        "ins1CurCode":"public void onSubscribe() { TestObserverEx<Integer> to = new TestObserverEx<>();  to.onSubscribe(null);  to.assertError(NullPointerException.class);  to = new TestObserverEx<>();  to.onSubscribe(Disposable.empty());  Disposable d1 = Disposable.empty();  to.onSubscribe(d1);  assertTrue(d1.isDisposed());  to.assertError(IllegalStateException.class);  to = new TestObserverEx<>(); to.dispose();",
        "ins1PreCode":"public void onSubscribe() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(null);  to.assertError(NullPointerException.class);  to = new TestObserverEx<Integer>();  to.onSubscribe(Disposable.empty());  Disposable d1 = Disposable.empty();  to.onSubscribe(d1);  assertTrue(d1.isDisposed());  to.assertError(IllegalStateException.class);  to = new TestObserverEx<Integer>(); to.dispose();",
        "ins2PreCode":"public void onSubscribe() { TestObserver<Integer> to = TestObserver.create();  to.onSubscribe(null);  to.assertError(NullPointerException.class);  to = TestObserver.create();  to.onSubscribe(Disposable.empty());  Disposable d1 = Disposable.empty();  to.onSubscribe(d1);  assertTrue(d1.isDisposed());  to.assertError(IllegalStateException.class);  to = TestObserver.create(); to.dispose();  d1 = Disposable.empty();  to.onSubscribe(d1);  assertTrue(d1.isDisposed()); ",
        "label":0
    },
    {
        "ins1CurCode":"TestObserver<Integer> to = TestObserver.create();  Observable.just(Observable.just(1)).concatMapDelayError((Function)Functions.identity(), true, 2, ImmediateThinScheduler.INSTANCE).subscribe(to); ",
        "ins1PreCode":"TestObserver<Integer> to = TestObserver.create();  Observable.just(Observable.just(1)).concatMapDelayError((Function)Functions.identity(), 2, true, ImmediateThinScheduler.INSTANCE).subscribe(to); ",
        "ins2PreCode":"public void concatMapJustJust() { TestObserver<Integer> to = TestObserver.create();  Observable.just(Observable.just(1)).concatMap((Function)Functions.identity(), 2, ImmediateThinScheduler.INSTANCE).subscribe(to);  to.assertValue(1); to.assertNoErrors(); to.assertComplete();",
        "label":0
    },
    {
        "ins1CurCode":"public void timeout() { TestSubscriber<String> ts = new TestSubscriber<>(); Single<String> s1 = Single.<String>unsafeCreate(new SingleSource<String>() {",
        "ins1PreCode":"public void timeout() { TestSubscriber<String> ts = new TestSubscriber<String>(); Single<String> s1 = Single.<String>unsafeCreate(new SingleSource<String>() {",
        "ins2PreCode":"public void timeoutWithFallback() { TestSubscriber<String> ts = new TestSubscriber<String>(); Single<String> s1 = Single.<String>unsafeCreate(new SingleSource<String>() {",
        "label":1
    },
    {
        "ins1CurCode":"} this.observers = s; this.values = new AtomicReferenceArray<>(n); this.upstream = new AtomicReference<>(); this.error = new AtomicThrowable();",
        "ins1PreCode":"} this.observers = s; this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Disposable>(); this.error = new AtomicThrowable();",
        "ins2PreCode":"} this.subscribers = s; this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Subscription>(); this.requested = new AtomicLong();",
        "label":0
    },
    {
        "ins1CurCode":"public void testFullPathMatchesCaseSensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/beta/gamma/GAMMA.XML\"});",
        "ins1PreCode":"public void testFullPathMatchesCaseSensitive() { if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/beta/gamma/GAMMA.XML\"});",
        "ins2PreCode":"public void testExcludeOneFile() { if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {",
        "label":1
    },
    {
        "ins1CurCode":"} catch (PrivilegedActionException ex){ Exception exception = ex.getException(); if (exception instanceof ClassNotFoundException) { throw (ClassNotFoundException)exception; } else if (exception instanceof IOException) { throw (IOException)exception; } if (log.isDebugEnabled()) { log.debug(\"Unreported exception in load() \", exception); }",
        "ins1PreCode":"} catch (PrivilegedActionException ex){ Exception exception = ex.getException(); if (exception instanceof ClassNotFoundException){ throw (ClassNotFoundException)exception; } else if (exception instanceof IOException){ throw (IOException)exception; } if (log.isDebugEnabled()) log.debug(\"Unreported exception in load() \" + exception); }",
        "ins2PreCode":"public void unload() throws IOException { if (SecurityUtil.isPackageProtectionEnabled()){ try{ AccessController.doPrivileged( new PrivilegedDoUnload() ); } catch (PrivilegedActionException ex){ Exception exception = ex.getException(); if (exception instanceof IOException){ throw (IOException)exception; } if (log.isDebugEnabled()) log.debug(\"Unreported exception in unLoad() \" + exception); }",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposable.empty()); calls.getAndIncrement();",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposables.empty()); calls.getAndIncrement();",
        "ins2PreCode":"public void connectIsIdempotent() { final AtomicInteger calls = new AtomicInteger(); Flowable<Integer> source = Flowable.unsafeCreate(new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> t) { t.onSubscribe(new BooleanSubscription()); calls.getAndIncrement(); } });  ConnectableFlowable<Integer> conn = source.publish();  assertEquals(0, calls.get());  conn.connect(); conn.connect();  assertEquals(1, calls.get());  conn.connect().dispose();  conn.connect(); conn.connect();  assertEquals(2, calls.get());",
        "label":0
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1); ",
        "ins1PreCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<String>(series1); ",
        "ins2PreCode":"public void testReplaceDataset() {   XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<>(series1);  LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "label":0
    },
    {
        "ins1CurCode":"private void assertMapValuesUpdated(TestMap message) { assertEquals(3, message.getInt32ToInt32FieldMap().size()); assertEquals(111, message.getInt32ToInt32FieldMap().get(1).intValue()); assertEquals(33, message.getInt32ToInt32FieldMap().get(3).intValue()); assertEquals(44, message.getInt32ToInt32FieldMap().get(4).intValue());  assertEquals(3, message.getInt32ToStringFieldMap().size()); assertEquals(\"111\", message.getInt32ToStringFieldMap().get(1)); assertEquals(\"33\", message.getInt32ToStringFieldMap().get(3)); assertEquals(\"44\", message.getInt32ToStringFieldMap().get(4));  assertEquals(3, message.getInt32ToBytesFieldMap().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesFieldMap().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesFieldMap().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesFieldMap().get(4));  assertEquals(3, message.getInt32ToEnumFieldMap().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumFieldMap().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumFieldMap().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumFieldMap().get(4));  assertEquals(3, message.getInt32ToMessageFieldMap().size()); assertEquals(111, message.getInt32ToMessageFieldMap().get(1).getValue()); assertEquals(33, message.getInt32ToMessageFieldMap().get(3).getValue()); assertEquals(44, message.getInt32ToMessageFieldMap().get(4).getValue());  assertEquals(3, message.getStringToInt32FieldMap().size()); assertEquals(111, message.getStringToInt32FieldMap().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32FieldMap().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32FieldMap().get(\"4\").intValue());",
        "ins1PreCode":"private void assertMapValuesUpdated(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(111, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(4).intValue());  assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"111\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"44\", message.getInt32ToStringField().get(4));  assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesField().get(4));  assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumField().get(4));  assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(111, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(44, message.getInt32ToMessageField().get(4).getValue());  assertEquals(3, message.getStringToInt32Field().size()); assertEquals(111, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32Field().get(\"4\").intValue());",
        "ins2PreCode":"private void assertMapValuesSet(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(11, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(22, message.getInt32ToInt32Field().get(2).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue());  assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"11\", message.getInt32ToStringField().get(1)); assertEquals(\"22\", message.getInt32ToStringField().get(2)); assertEquals(\"33\", message.getInt32ToStringField().get(3));  assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"22\"), message.getInt32ToBytesField().get(2)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3));  assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(2)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3));  assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(11, message.getInt32ToMessageField().get(1).getValue()); assertEquals(22, message.getInt32ToMessageField().get(2).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue());  assertEquals(3, message.getStringToInt32Field().size()); assertEquals(11, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(22, message.getStringToInt32Field().get(\"2\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue());",
        "label":1
    },
    {
        "ins1CurCode":"public void testDataSendASYNCM() throws Exception { final AtomicInteger counter = new AtomicInteger(0); ReceiverBase rb1 = (ReceiverBase)channel1.getChannelReceiver(); ReceiverBase rb2 = (ReceiverBase)channel2.getChannelReceiver(); rb1.setUdpRxBufSize(1024*1024*10); rb2.setUdpRxBufSize(1024*1024*10); rb1.setUdpTxBufSize(1024*1024*10); rb2.setUdpTxBufSize(1024*1024*10); System.err.println(\"Starting NO_ACK\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) { int cnt = counter.getAndAdd(1); channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024,cnt),Channel.SEND_OPTIONS_UDP|Channel.SEND_OPTIONS_ASYNCHRONOUS);  } System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); System.out.println(\"Sent \"+counter.get()+ \" messages. Received \"+listener1.count+\" Highest msg received:\"+listener1.maxIdx); System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins1PreCode":"public void testDataSendASYNCM() throws Exception { System.err.println(\"Starting ASYNC MULTI THREAD\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_UDP); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins2PreCode":"public void testDataSendNO_ACK() throws Exception { final AtomicInteger counter = new AtomicInteger(0); ReceiverBase rb1 = (ReceiverBase)channel1.getChannelReceiver(); ReceiverBase rb2 = (ReceiverBase)channel2.getChannelReceiver(); rb1.setUdpRxBufSize(1024*1024*10); rb2.setUdpRxBufSize(1024*1024*10); rb1.setUdpTxBufSize(1024*1024*10); rb2.setUdpTxBufSize(1024*1024*10); System.err.println(\"Starting NO_ACK\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) { int cnt = counter.getAndAdd(1); channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024,cnt),Channel.SEND_OPTIONS_UDP);  } System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); System.out.println(\"Sent \"+counter.get()+ \" messages. Received \"+listener1.count+\" Highest msg received:\"+listener1.maxIdx); System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "label":0
    },
    {
        "ins1CurCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x100000000000L); default :",
        "ins1PreCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L); default :",
        "ins2PreCode":"{ case 111: return jjMoveStringLiteralDfa9_1(active0, 0x80000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"public void testCalculateColumnTotal() { DefaultKeyedValues2D<String, String> table = new DefaultKeyedValues2D<>(); table.addValue(1.0, \"R0\", \"C0\");",
        "ins1PreCode":"public void testCalculateColumnTotal() { DefaultKeyedValues2D table = new DefaultKeyedValues2D(); table.addValue(1.0, \"R0\", \"C0\");",
        "ins2PreCode":"public void testCalculateRowTotal() { DefaultKeyedValues2D table = new DefaultKeyedValues2D(); table.addValue(1.0, \"R0\", \"C0\");",
        "label":1
    },
    {
        "ins1CurCode":"}  source.subscribe(new UsingObserver<>(observer, resource, disposer, eager));",
        "ins1PreCode":"}  source.subscribe(new UsingObserver<R>(observer, resource, disposer, eager));",
        "ins2PreCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { D resource;  try { resource = resourceSupplier.get(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return; }  MaybeSource<? extends T> source;  try { source = Objects.requireNonNull(sourceSupplier.apply(resource), \"The sourceSupplier returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); if (eager) { try { resourceDisposer.accept(resource); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); EmptyDisposable.error(new CompositeException(ex, exc), observer); return; } }  EmptyDisposable.error(ex, observer);  if (!eager) { try { resourceDisposer.accept(resource); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); RxJavaPlugins.onError(exc); } } return; }  source.subscribe(new UsingObserver<T, D>(observer, resource, resourceDisposer, eager));",
        "label":0
    },
    {
        "ins1CurCode":"protected String getLocalpath() { String lclPath = \"\"; if (localPath != null) {  File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs(); if (!done) { String msg = \"Directory \" + localPath + \" creation was not \" + \"successful for an unknown reason\"; throw new BuildException(msg, getLocation()); } getProject().log(\"Created dir: \" + dir.getAbsolutePath()); } lclPath = FLAG_OVERRIDE_WORKING_DIR + localPath; } return lclPath;",
        "ins1PreCode":"protected String getLocalpath() { if (m_LocalPath == null) { return \"\"; } else {  File dir = getProject().resolveFile(m_LocalPath); if (!dir.exists()) { boolean done = dir.mkdirs(); if (!done) { String msg = \"Directory \" + m_LocalPath + \" creation was not \" + \"successful for an unknown reason\"; throw new BuildException(msg, getLocation()); } getProject().log(\"Created dir: \" + dir.getAbsolutePath()); } return FLAG_OVERRIDE_WORKING_DIR + m_LocalPath; }",
        "ins2PreCode":"protected String getLocalPath() { if (localPath == null) { return getProject().getBaseDir().getAbsolutePath(); } else {  File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs(); if (!done) { String msg = \"Directory \" + localPath + \" creation was not \" + \"successful for an unknown reason\"; throw new BuildException(msg, getLocation()); } getProject().log(\"Created dir: \" + dir.getAbsolutePath()); } return dir.getAbsolutePath(); }",
        "label":0
    },
    {
        "ins1CurCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try { getEndpoint().getHandler().release(this); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.handlerRelease\"), e); } } try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) { getSocket().close(true); } if (getEndpoint().running && !getEndpoint().paused) { if (nioChannels == null || !nioChannels.push(getSocket())) { getSocket().free(); } } } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.channelCloseFail\"), e); } } finally { socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear(); reset(NioChannel.CLOSED_NIO_CHANNEL); } try { SendfileData data = getSendfileData(); if (data != null && data.fchannel != null && data.fchannel.isOpen()) { data.fchannel.close(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.sendfile.closeError\"), e); } }",
        "ins1PreCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try { getEndpoint().getHandler().release(this); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.handlerRelease\"), e); } } try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) { getSocket().close(true); } socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear(); if (getEndpoint().running && !getEndpoint().paused) { if (nioChannels == null || !nioChannels.push(getSocket())) { getSocket().free(); } } } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.channelCloseFail\"), e); } } finally { reset(NioChannel.CLOSED_NIO_CHANNEL); } try { SendfileData data = getSendfileData(); if (data != null && data.fchannel != null && data.fchannel.isOpen()) { data.fchannel.close(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.sendfile.closeError\"), e); } }",
        "ins2PreCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try { getEndpoint().getHandler().release(this); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.handlerRelease\"), e); } } try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) { getSocket().close(true); } socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear(); if (getEndpoint().running && !getEndpoint().paused) { if (nioChannels == null || !nioChannels.push(getSocket())) { getSocket().free(); } } } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.channelCloseFail\"), e); } } finally { reset(Nio2Channel.CLOSED_NIO2_CHANNEL); } try { SendfileData data = getSendfileData(); if (data != null && data.fchannel != null && data.fchannel.isOpen()) { data.fchannel.close(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.sendfile.closeError\"), e); } }",
        "label":1
    },
    {
        "ins1CurCode":"public void assertNeverAtMatchingValue() { assertThrows(AssertionError.class, () -> { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber);  subscriber.assertValues(1, 2);  subscriber.assertNever(2); subscriber.assertValueCount(2); subscriber.assertTerminated(); });",
        "ins1PreCode":"subscriber.assertValues(1, 2);  thrown.expect(AssertionError.class); ",
        "ins2PreCode":"public void assertNeverAtNotMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber);  subscriber.assertNever(3); subscriber.assertValueCount(2); subscriber.assertTerminated();",
        "label":0
    },
    {
        "ins1CurCode":"public void testNullValueWithIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), null, \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), true,",
        "ins1PreCode":"public void testNullValueWithIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), true,",
        "ins2PreCode":"public void testNonExistentWithIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), true,",
        "label":1
    },
    {
        "ins1CurCode":"  Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}}; ",
        "ins1PreCode":"  Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; ",
        "ins2PreCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; ",
        "label":1
    },
    {
        "ins1CurCode":"public void testEmptyCopy() { buildRule.executeTarget(\"emptycopy\"); String d = buildRule.getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsNotPresent(d); String c = buildRule.getProject().getProperty(\"dest\") + \"/a/b/c\"; assertFileIsNotPresent(c); assertTrue(buildRule.getFullLog().indexOf(\"dangling\") == -1);",
        "ins1PreCode":"public void testEmptyCopy() { executeTarget(\"emptycopy\"); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsNotPresent(d); String c = getProject().getProperty(\"dest\") + \"/a/b/c\"; assertFileIsNotPresent(c); assertTrue(getFullLog().indexOf(\"dangling\") == -1);",
        "ins2PreCode":"public void testEmptyDirCopy() { executeTarget(\"emptydircopy\"); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsNotPresent(d); String c = getProject().getProperty(\"dest\") + \"/a/b/c\"; assertFileIsPresent(c); assertTrue(getFullLog().indexOf(\"dangling\") == -1);",
        "label":1
    },
    {
        "ins1CurCode":"set.add(new IEEE(importFormatPreferences)); set.add(new CompositeSearchBasedFetcher(set, 30)); set.add(new CollectionOfComputerScienceBibliographiesFetcher(importFormatPreferences)); return set;",
        "ins1PreCode":"set.add(new IEEE(importFormatPreferences)); set.add(new CompositeSearchBasedFetcher(set, 30)); return set;",
        "ins2PreCode":"public static SortedSet<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { SortedSet<IdBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); set.add(new ArXiv(importFormatPreferences)); set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new IsbnFetcher(importFormatPreferences)); set.add(new DiVA(importFormatPreferences)); set.add(new DoiFetcher(importFormatPreferences)); set.add(new MedlineFetcher()); set.add(new TitleFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); return set;",
        "label":0
    },
    {
        "ins1CurCode":"application.setEnvironment(environment); this.context = application.run(); assertThat(environment.acceptsProfiles(Profiles.of(\"foo\"))).isTrue();",
        "ins1PreCode":"application.setEnvironment(environment); this.context = application.run(); assertThat(environment.acceptsProfiles(\"foo\")).isTrue();",
        "ins2PreCode":"public void addProfilesOrder() { SpringApplication application = new SpringApplication(ExampleConfig.class); application.setWebApplicationType(WebApplicationType.NONE); application.setAdditionalProfiles(\"foo\"); ConfigurableEnvironment environment = new StandardEnvironment(); application.setEnvironment(environment); this.context = application.run(\"--spring.profiles.active=bar,spam\");  assertThat(environment.getActiveProfiles()).containsExactly(\"foo\", \"bar\", \"spam\");",
        "label":0
    },
    {
        "ins1CurCode":"public void testAsReadOnlyByteBufferList() { List<ByteBuffer> byteBuffers = testString.asReadOnlyByteBufferList(); int bytesSeen = 0;",
        "ins1PreCode":"public void testAsReadOnlyByteBufferList() { List<ByteBuffer> byteBuffers = TEST_STRING.asReadOnlyByteBufferList(); int bytesSeen = 0;",
        "ins2PreCode":"public void testAsReadOnlyByteBufferList() { List<ByteBuffer> byteBuffers = stringUnderTest.asReadOnlyByteBufferList(); int bytesSeen = 0; byte[] roundTripBytes = new byte[referenceBytes.length]; for (ByteBuffer byteBuffer : byteBuffers) { int thisLength = byteBuffer.remaining(); assertTrue(byteBuffer.isReadOnly()); assertTrue(bytesSeen + thisLength <= referenceBytes.length); byteBuffer.get(roundTripBytes, bytesSeen, thisLength); bytesSeen += thisLength; } assertTrue(bytesSeen == referenceBytes.length); assertTrue(classUnderTest + \".asReadOnlyByteBufferTest() must give back the same bytes\", Arrays.equals(referenceBytes, roundTripBytes));",
        "label":0
    },
    {
        "ins1CurCode":"public void edges_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  Set<String> edges = network.edges();",
        "ins1PreCode":"public void edges_checkReturnedSetMutability() { Set<String> edges = network.edges(); try { edges.add(E12);",
        "ins2PreCode":"public void edges_checkReturnedSetMutability() { Set<String> edges = network.edges(); try { edges.add(E12); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.edges()).containsExactlyElementsIn(edges); }",
        "label":0
    },
    {
        "ins1CurCode":"assertTrue(meta.hasGetter(\"richType.richList[0]\"));  assertEquals(\"richType.richProperty\", meta.findProperty(\"richType.richProperty\", false)); ",
        "ins1PreCode":"assertTrue(meta.hasGetter(\"richType.richList[0]\"));  assertFalse(meta.hasGetter(\"[0]\"));",
        "ins2PreCode":"public void shouldCheckSetterExistance() { ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory); assertTrue(meta.hasSetter(\"richField\")); assertTrue(meta.hasSetter(\"richProperty\")); assertTrue(meta.hasSetter(\"richList\")); assertTrue(meta.hasSetter(\"richMap\")); assertTrue(meta.hasSetter(\"richList[0]\"));  assertTrue(meta.hasSetter(\"richType\")); assertTrue(meta.hasSetter(\"richType.richField\")); assertTrue(meta.hasSetter(\"richType.richProperty\")); assertTrue(meta.hasSetter(\"richType.richList\")); assertTrue(meta.hasSetter(\"richType.richMap\")); assertTrue(meta.hasSetter(\"richType.richList[0]\"));  assertFalse(meta.hasSetter(\"[0]\"));",
        "label":0
    },
    {
        "ins1CurCode":"break; default: jj_la1[35] = jj_gen; break label_14;",
        "ins1PreCode":"break; default: jj_la1[37] = jj_gen; ;",
        "ins2PreCode":"break; default: jj_la1[42] = jj_gen; ;",
        "label":1
    },
    {
        "ins1CurCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins1PreCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress()); list.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins2PreCode":"public static List<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1CurCode":" String result = (String) ve.getValue(context); Assert.assertEquals(\"Tomcat\", result);   ValueReference vr = ve.getValueReference(context); Assert.assertNotNull(vr);  Assert.assertEquals(beanB, vr.getBase()); Assert.assertEquals(\"name\", vr.getProperty());",
        "ins1PreCode":" String result = (String) ve.getValue(context); assertEquals(\"Tomcat\", result);   ValueReference vr = ve.getValueReference(context); assertNotNull(vr);  assertEquals(beanB, vr.getBase()); assertEquals(\"name\", vr.getProperty());",
        "ins2PreCode":" ValueReference vr = ve.getValueReference(context); assertNotNull(vr);  assertEquals(beanB, vr.getBase()); assertEquals(\"name\", vr.getProperty());",
        "label":1
    },
    {
        "ins1CurCode":"{ case 99: return jjMoveStringLiteralDfa7_1(active0, 0x100000000000L); default :",
        "ins1PreCode":"{ case 99: return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L); default :",
        "ins2PreCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<>(); } }, new BiConsumer<List<Integer>, Integer>() { @Override public void accept(List<Integer> a, Integer b) throws Exception { a.add(b); } }));  TestHelper.checkDisposed(Observable.range(1, 3).collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<>(); }",
        "ins1PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() { @Override public void accept(List<Integer> a, Integer b) throws Exception { a.add(b); } }));  TestHelper.checkDisposed(Observable.range(1, 3).collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); }",
        "ins2PreCode":"public void subscriberCount() { ParallelFlowableTest.checkSubscriberCount(Flowable.range(1, 5).parallel() .collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() { @Override public void accept(List<Integer> a, Integer b) throws Exception { a.add(b); } }));",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribeActual(Observer<? super T> t) { SerializedObserver<T> serial = new SerializedObserver<>(t); if (emitLast) { source.subscribe(new SampleMainEmitLast<>(serial, other)); } else { source.subscribe(new SampleMainNoLast<>(serial, other)); }",
        "ins1PreCode":"public void subscribeActual(Observer<? super T> t) { SerializedObserver<T> serial = new SerializedObserver<T>(t); if (emitLast) { source.subscribe(new SampleMainEmitLast<T>(serial, other)); } else { source.subscribe(new SampleMainNoLast<T>(serial, other)); }",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super T> s) { SerializedSubscriber<T> serial = new SerializedSubscriber<T>(s); if (emitLast) { source.subscribe(new SampleMainEmitLast<T>(serial, other)); } else { source.subscribe(new SampleMainNoLast<T>(serial, other)); }",
        "label":1
    },
    {
        "ins1CurCode":"sb.append(paramType); sb.append(\"]\"); return sb.toString();",
        "ins1PreCode":"public String toString() {  StringBuilder sb = new StringBuilder(\"SetNextRule[\"); sb.append(\"methodName=\"); sb.append(methodName); sb.append(\", paramType=\"); sb.append(paramType); sb.append(\"]\"); return (sb.toString()); ",
        "ins2PreCode":"public String toString() {  StringBuilder sb = new StringBuilder(\"SetNextRule[\"); sb.append(\"methodName=\"); sb.append(methodName); sb.append(\", paramType=\"); sb.append(paramType); sb.append(\"]\"); return (sb.toString()); ",
        "label":1
    },
    {
        "ins1CurCode":"final Subscriber<Object> subscriber = TestHelper.mockSubscriber();  final List<Subscriber<Object>> values = new ArrayList<>(); ",
        "ins1PreCode":"final Subscriber<Object> subscriber = TestHelper.mockSubscriber();  final List<Subscriber<Object>> values = new ArrayList<Subscriber<Object>>(); ",
        "ins2PreCode":"final Subscriber<Object> subscriber = TestHelper.mockSubscriber();  final List<Subscriber<Object>> values = new ArrayList<Subscriber<Object>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindFileInSubdirectory() throws Exception { ",
        "ins1PreCode":"public void testFindFileInSubdirectory() { ",
        "ins2PreCode":"public void testFindFileNonRecursive() { ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XIntervalSeriesCollection<String> c1 = new XIntervalSeriesCollection<>(); XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); XIntervalSeriesCollection<String> c2 = CloneUtils.clone(c1); assertTrue(c1 != c2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XIntervalSeriesCollection c1 = new XIntervalSeriesCollection(); XIntervalSeries s1 = new XIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); XIntervalSeriesCollection c2 = CloneUtils.clone(c1); assertTrue(c1 != c2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { YIntervalSeriesCollection c1 = new YIntervalSeriesCollection(); YIntervalSeries s1 = new YIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); YIntervalSeriesCollection c2 = CloneUtils.clone(c1); assertTrue(c1 != c2);",
        "label":1
    },
    {
        "ins1CurCode":"public void testNullGuardEq() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, new FunctionTable(), MethodHandles.publicLookup(),",
        "ins1PreCode":"public void testNullGuardEq() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, Collections.emptyMap(), MethodHandles.publicLookup(),",
        "ins2PreCode":"public void testNullGuardEqWhenCached() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, Collections.emptyMap(), MethodHandles.publicLookup(),",
        "label":1
    },
    {
        "ins1CurCode":"public CloudFoundryInfoEndpointWebExtension cloudFoundryInfoEndpointWebExtension( GitProperties properties, ObjectProvider<InfoContributor> infoContributors) { List<InfoContributor> contributors = infoContributors.orderedStream() .map((infoContributor) -> {",
        "ins1PreCode":"public CloudFoundryInfoEndpointWebExtension cloudFoundryInfoEndpointWebExtension( InfoEndpoint infoEndpoint, GitProperties properties) { List<InfoContributor> existingContributors = infoEndpoint.getInfoContributors(); List<InfoContributor> contributors = existingContributors.stream() .map((infoContributor) -> {",
        "ins2PreCode":"public CloudFoundryInfoEndpointWebExtension cloudFoundryInfoEndpointWebExtension( InfoEndpoint infoEndpoint, GitProperties properties) { List<InfoContributor> existingContributors = infoEndpoint.getInfoContributors(); List<InfoContributor> contributors = existingContributors.stream() .map((infoContributor) -> {",
        "label":1
    },
    {
        "ins1CurCode":"} catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying group [\" + groupname + \"] MBean\"); iae.initCause(e);",
        "ins1PreCode":"} catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying group \" + group + \" MBean\"); iae.initCause(e);",
        "ins2PreCode":"} catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for group \" + group); iae.initCause(e);",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { Disposable d = Disposable.empty(); observer.onSubscribe(d);",
        "ins1PreCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { Disposable d = Disposables.empty(); observer.onSubscribe(d);",
        "ins2PreCode":"protected void subscribeActual(MaybeObserver<? super T> observer) { Disposable d = Disposables.empty(); observer.onSubscribe(d);",
        "label":1
    },
    {
        "ins1CurCode":" SortProcessor.Factory factory = new SortProcessor.Factory(); SortProcessor processor = factory.create(null, processorTag, null, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins1PreCode":" SortProcessor.Factory factory = new SortProcessor.Factory(); SortProcessor processor = factory.create(null, processorTag, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins2PreCode":" SortProcessor.Factory factory = new SortProcessor.Factory(); SortProcessor processor = factory.create(null, processorTag, config); assertThat(processor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposable.empty()); observer.onNext(1);",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1);",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1);",
        "label":1
    },
    {
        "ins1CurCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, description, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);  Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"processor\", Collections.singletonMap(\"_name\", Collections.emptyMap())); ForEachProcessor forEachProcessor = forEachFactory.create(registry, null, null, config); assertThat(forEachProcessor, Matchers.notNullValue());",
        "ins1PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);  Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"processor\", Collections.singletonMap(\"_name\", Collections.emptyMap())); ForEachProcessor forEachProcessor = forEachFactory.create(registry, null, config); assertThat(forEachProcessor, Matchers.notNullValue());",
        "ins2PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);  Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"processor\", Collections.singletonMap(\"_name\", Collections.emptyMap())); config.put(\"ignore_missing\", true); ForEachProcessor forEachProcessor = forEachFactory.create(registry, null, config); assertThat(forEachProcessor, Matchers.notNullValue());",
        "label":1
    },
    {
        "ins1CurCode":".observeOn(Schedulers.io()); } }, true, 2, Schedulers.single()) .distinct()",
        "ins1PreCode":".observeOn(Schedulers.io()); } }, 2, true, Schedulers.single()) .distinct()",
        "ins2PreCode":".observeOn(Schedulers.io()); } }, 2, false, Schedulers.single()) .distinct()",
        "label":1
    },
    {
        "ins1CurCode":"void loadDefaultYamlDocument() { this.environment.setDefaultProfiles(\"thedefault\");",
        "ins1PreCode":"public void loadDefaultYamlDocument() { this.environment.setDefaultProfiles(\"thedefault\");",
        "ins2PreCode":"public void loadDefaultYamlDocumentNotActivated() { this.environment.setDefaultProfiles(\"thedefault\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetValue() { DefaultKeyedValues2D d = new DefaultKeyedValues2D(); d.addValue(1.0, \"R1\", \"C1\"); assertEquals(1.0, d.getValue(\"R1\", \"C1\")); boolean pass = false;",
        "ins1PreCode":"public void testGetValue() { DefaultKeyedValues2D d = new DefaultKeyedValues2D(); d.addValue(new Double(1.0), \"R1\", \"C1\"); assertEquals(new Double(1.0), d.getValue(\"R1\", \"C1\")); boolean pass = false;",
        "ins2PreCode":"public void testGetValue() { DefaultCategoryDataset d = new DefaultCategoryDataset(); d.addValue(1.0, \"R1\", \"C1\"); assertEquals(new Double(1.0), d.getValue(\"R1\", \"C1\")); boolean pass = false; try { d.getValue(\"XX\", \"C1\"); } catch (UnknownKeyException e) { pass = true; } assertTrue(pass);  pass = false; try { d.getValue(\"R1\", \"XX\"); } catch (UnknownKeyException e) { pass = true; } assertTrue(pass);",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List<ValueTick> ticks) { ",
        "ins1PreCode":"protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea, List ticks) { ",
        "ins2PreCode":"protected void drawRangeGridlines(Graphics2D g2, Rectangle2D area, List ticks) { ",
        "label":1
    },
    {
        "ins1CurCode":"Observable.concatEager(Arrays.asList(source, source, source), 1, -99); } catch (IllegalArgumentException ex) { assertEquals(\"bufferSize > 0 required but it was -99\", ex.getMessage()); }",
        "ins1PreCode":"Observable.concatEager(Arrays.asList(source, source, source), 1, -99); } catch (IllegalArgumentException ex) { assertEquals(\"prefetch > 0 required but it was -99\", ex.getMessage()); }",
        "ins2PreCode":"public void badCapacityHint() throws Exception { Flowable<Integer> source = Flowable.just(1); try { Flowable.concatEager(Arrays.asList(source, source, source), 1, -99); } catch (IllegalArgumentException ex) { assertEquals(\"prefetch > 0 required but it was -99\", ex.getMessage()); } ",
        "label":0
    },
    {
        "ins1CurCode":"sb.append(StringUtil.booleanToBinaryString(isRegex)); sb.append(MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR);  appendGroupDetails(sb, group);  return sb.toString();",
        "ins1PreCode":"sb.append(StringUtil.booleanToBinaryString(isRegex)); sb.append(MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR); return sb.toString();",
        "ins2PreCode":"sb.append(StringUtil.booleanToBinaryString(group.isRegularExpression())); sb.append(MetadataSerializationConfiguration.GROUP_UNIT_SEPARATOR); return sb.toString();",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValuesOnly() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposable.empty()); to.assertValuesOnly();",
        "ins1PreCode":"public void assertValuesOnly() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposables.empty()); to.assertValuesOnly();",
        "ins2PreCode":"public void assertValuesOnlyThrowsOnUnexpectedValue() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposables.empty()); to.assertValuesOnly();",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");  assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "ins1PreCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");  ASSERT.that(m).isEqualTo(expected); ASSERT.that(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "ins2PreCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");  ASSERT.that(m).isEqualTo(expected); ASSERT.that(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "label":1
    },
    {
        "ins1CurCode":"ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ApplicationConfigurationProperties applicationProperties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = applicationProperties .getContexts().get(context.getId()).getBeans().get(\"foo\"); assertThat(foo).isNotNull();",
        "ins1PreCode":"ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull();",
        "ins2PreCode":"ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor fooProperties = properties.getBeans() .get(\"foo\"); assertThat(fooProperties).isNotNull();",
        "label":1
    },
    {
        "ins1CurCode":"} }); Assertions.assertEquals(1, persons.size(), \"Persons must contain 1 persons\"); }",
        "ins1PreCode":"} }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); }",
        "ins2PreCode":"} }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void crossCancel() {  final TestSubscriber<Integer> ts1 = new TestSubscriber<>(); ",
        "ins1PreCode":"public void crossCancel() {  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void crossCancel1() {  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(1); ",
        "label":1
    },
    {
        "ins1CurCode":"public void zipIterable2IteratorNull() { Observable.zip(new Iterable<Observable<Object>>() { @Override",
        "ins1PreCode":"public void zipIterable2IteratorNull() { Observable.zipIterable(new Iterable<Observable<Object>>() { @Override",
        "ins2PreCode":"public void combineLatestDelayErrorIterableIteratorNull() { Flowable.combineLatestDelayError(new Iterable<Flowable<Object>>() { @Override public Iterator<Flowable<Object>> iterator() { return null; } }, new Function<Object[], Object>() { @Override public Object apply(Object[] v) { return 1; } }, 128).blockingLast();",
        "label":0
    },
    {
        "ins1CurCode":"  if(this.getState().equals(LifecycleState.STARTED)) fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);",
        "ins1PreCode":"  postWelcomeFiles(); if(this.getState().equals(LifecycleState.STARTED))",
        "ins2PreCode":"public void removeWatchedResource(String name) {  synchronized (watchedResourcesLock) {   int n = -1; for (int i = 0; i < watchedResources.length; i++) { if (watchedResources[i].equals(name)) { n = i; break; } } if (n < 0) return;   int j = 0; String results[] = new String[watchedResources.length - 1]; for (int i = 0; i < watchedResources.length; i++) { if (i != n) results[j++] = watchedResources[i]; } watchedResources = results;  }  fireContainerEvent(\"removeWatchedResource\", name); ",
        "label":0
    },
    {
        "ins1CurCode":"public void testBuildMissingField() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "ins1PreCode":"public void testBuildMissingField() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"public void testBuildMissingPatterns() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { List<MavenProject> projects = new ArrayList<>(); ",
        "ins1PreCode":"throws Exception { List<MavenProject> projects = new ArrayList<MavenProject>(); ",
        "ins2PreCode":"throws Exception { List<MavenProject> projects = new ArrayList<MavenProject>(); ",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(ObservableEmitter<Object> e) throws Exception { Disposable d = Disposable.empty(); e.setDisposable(d);",
        "ins1PreCode":"@Override public void subscribe(ObservableEmitter<Object> e) throws Exception { Disposable d = Disposables.empty(); e.setDisposable(d);",
        "ins2PreCode":"@Override public void subscribe(FlowableEmitter<Object> e) throws Exception { Disposable d = Disposables.empty(); e.setDisposable(d);",
        "label":1
    },
    {
        "ins1CurCode":"void specifyQueryTimeoutAndTransactionTimeoutMinIsQueryTimeout() throws SQLException { doReturn(10).when(configuration).getDefaultStatementTimeout();",
        "ins1PreCode":"public void specifyQueryTimeoutAndTransactionTimeoutMinIsQueryTimeout() throws SQLException { doReturn(10).when(configuration).getDefaultStatementTimeout();",
        "ins2PreCode":"public void specifyQueryTimeoutAndTransactionTimeoutMinIsTransactionTimeout() throws SQLException { doReturn(10).when(configuration).getDefaultStatementTimeout();",
        "label":1
    },
    {
        "ins1CurCode":"public void observerCheckTerminatedDelayErrorNonEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorNonEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposables.empty(); ",
        "label":0
    },
    {
        "ins1CurCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); Assert.assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { Assert.assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); }",
        "ins1PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); }",
        "ins2PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); ",
        "ins2PreCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, true); ",
        "label":0
    },
    {
        "ins1CurCode":"public void multipleErrors3() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins1PreCode":"public void multipleErrors3() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins2PreCode":"public void multipleErrors4() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "label":1
    },
    {
        "ins1CurCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); }",
        "ins1PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getStartValue(r,",
        "ins2PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getEndValue(r, c + this.firstCategoryIndex);",
        "label":1
    },
    {
        "ins1CurCode":"} else { result = maximum; }",
        "ins1PreCode":"} else { result = new Double(maximum); }",
        "ins2PreCode":"public static Number findMinimumDomainValue(XYDataset dataset) { Args.nullNotPermitted(dataset, \"dataset\"); Number result;  if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return info.getDomainLowerBound(true); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; value = intervalXYData.getStartXValue(series, item); } else { value = dataset.getXValue(series, item); } if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); }  } } if (minimum == Double.POSITIVE_INFINITY) { result = null; } else { result = minimum; } }  return result;",
        "label":0
    },
    {
        "ins1CurCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L); default :",
        "ins1PreCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x40000000000L); default :",
        "ins2PreCode":"{ case 111: return jjMoveStringLiteralDfa9_1(active0, 0x40000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"protected void writeJar(String baseName, File jarFile, Hashtable<String, File> files, String publicId) throws BuildException { if (ejbdeploy) {",
        "ins1PreCode":"protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException { if (ejbdeploy) {",
        "ins2PreCode":"protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException {",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"boolean success; try { DefaultBoxAndWhiskerCategoryDataset<String, String> dataset = new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5,",
        "ins1PreCode":"boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5,",
        "ins2PreCode":"public void testDrawWithNullMaxRegular() { try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null,",
        "label":1
    },
    {
        "ins1CurCode":"configuration.addMapper(ParameterMapReferencePersonMapper.class); configuration.addMapper(ParameterMapReferencePetMapper.class); c.close(); ",
        "ins1PreCode":"configuration.addMapper(ParameterMapReferencePersonMapper.class); configuration.addMapper(ParameterMapReferencePetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"configuration.addMapper(ResultMapReferencePersonMapper.class); configuration.addMapper(ResultMapReferencePetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"public WebFluxEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, WebAnnotationEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebFluxEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, corsConfiguration);",
        "ins1PreCode":"public WebFluxEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, WebAnnotationEndpointDiscoverer endpointDiscoverer) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebFluxEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), endpointDiscoverer.discoverEndpoints(), corsConfiguration);",
        "ins2PreCode":"public WebMvcEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, WebAnnotationEndpointDiscoverer webEndpointDiscoverer) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebMvcEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), webEndpointDiscoverer.discoverEndpoints(), corsConfiguration);",
        "label":1
    },
    {
        "ins1CurCode":"public void bindToArrayShouldReturnPrimitiveArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToArrayShouldReturnPrimitiveArray() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToCollectionShouldReturnPopulatedCollection() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(1); } }, false, 16, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"return Flowable.just(1); } }, 16, false, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"return Flowable.just(1); } }, 16, false) .test()",
        "label":0
    },
    {
        "ins1CurCode":"void createWhenMapHasEntriesShouldAdaptMap() { Map<Object, Object> map = new LinkedHashMap<>();",
        "ins1PreCode":"public void createWhenMapHasEntriesShouldAdaptMap() { Map<Object, Object> map = new LinkedHashMap<>();",
        "ins2PreCode":"public void putAllShouldPutEntries() { Map<Object, Object> map = new LinkedHashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":"public void testSerializeAndParse() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); TestMap message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build();",
        "ins1PreCode":"public void testSerializeAndParse() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build();",
        "ins2PreCode":"public void testSerializeAndParse() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); assertEquals(message.getSerializedSize(), message.toByteString().size()); message = TestMap.parser().parseFrom(message.toByteString()); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build();",
        "label":1
    },
    {
        "ins1CurCode":" StringBuilder sb = new StringBuilder(\"<user username=\\\"\"); sb.append(HttpMessages.filter(username)); sb.append(\"\\\" password=\\\"\"); sb.append(HttpMessages.filter(password)); sb.append(\"\\\"\"); if (fullName != null) { sb.append(\" fullName=\\\"\"); sb.append(HttpMessages.filter(fullName)); sb.append(\"\\\"\"); } synchronized (groups) { if (groups.size() > 0) { sb.append(\" groups=\\\"\"); int n = 0; Iterator<Group> values = groups.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(HttpMessages.filter(values.next().getGroupname())); } sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\" roles=\\\"\"); int n = 0; Iterator<Role> values = roles.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(HttpMessages.filter(values.next().getRolename())); }",
        "ins1PreCode":" StringBuilder sb = new StringBuilder(\"<user username=\\\"\"); sb.append(RequestUtil.filter(username)); sb.append(\"\\\" password=\\\"\"); sb.append(RequestUtil.filter(password)); sb.append(\"\\\"\"); if (fullName != null) { sb.append(\" fullName=\\\"\"); sb.append(RequestUtil.filter(fullName)); sb.append(\"\\\"\"); } synchronized (groups) { if (groups.size() > 0) { sb.append(\" groups=\\\"\"); int n = 0; Iterator<Group> values = groups.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getGroupname())); } sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\" roles=\\\"\"); int n = 0; Iterator<Role> values = roles.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getRolename())); }",
        "ins2PreCode":" StringBuilder sb = new StringBuilder(\"User username=\\\"\"); sb.append(RequestUtil.filter(username)); sb.append(\"\\\"\"); if (fullName != null) { sb.append(\", fullName=\\\"\"); sb.append(RequestUtil.filter(fullName)); sb.append(\"\\\"\"); } synchronized (groups) { if (groups.size() > 0) { sb.append(\", groups=\\\"\"); int n = 0; Iterator<Group> values = groups.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getGroupname())); } sb.append(\"\\\"\"); } } synchronized (roles) { if (roles.size() > 0) { sb.append(\", roles=\\\"\"); int n = 0; Iterator<Role> values = roles.iterator(); while (values.hasNext()) { if (n > 0) { sb.append(','); } n++; sb.append(RequestUtil.filter(values.next().getRolename())); }",
        "label":1
    }
]
