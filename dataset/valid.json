[
    {
        "ins1AddCode":"",
        "ins1DelCode":"addFig(getBorderFig());",
        "ins1PreCode":"   addFig(getBorderFig());  ",
        "ins2PreCode":"addFig(getBorderFig());",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleMessageConverter.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, false, false); JavaRDD<Rating> data = jsc.parallelize(testData._1());",
        "ins1DelCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, false, false); JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "ins1PreCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, false, false);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.train(data.rdd(), features, iterations); validatePrediction(model, users, products, testData._2(), 0.3, false, testData._3());",
        "ins2PreCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, false, false); JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features) validatePrediction(model, users, products, testData._2(), 0.3, false, testData._3());",
        "label":1
    },
    {
        "ins1AddCode":"void matchNotUsingDefaultFilters() throws Exception {",
        "ins1DelCode":"public void matchNotUsingDefaultFilters() throws Exception {",
        "ins1PreCode":"public void matchNotUsingDefaultFilters() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(NotUsingDefaultFilters.class); assertThat(excludes(filter, Controller1.class)).isTrue();",
        "ins2PreCode":"public void matchNotUsingDefaultFilters() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(NotUsingDefaultFilters.class); assertThat(excludes(filter, Controller1.class)).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"prepareResponse((response) -> response.setResponseCode(500)); .consumeErrorWith((throwable) -> { expectRequest((request) -> {",
        "ins1DelCode":"prepareResponse(response -> response.setResponseCode(500)); .consumeErrorWith(throwable -> { expectRequest(request -> {",
        "ins1PreCode":"public void getAccessLevelWhenCloudControllerIsNotReachableThrowsException() throws Exception { prepareResponse(response -> response.setResponseCode(500)); StepVerifier.create( this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeErrorWith(throwable -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.SERVICE_UNAVAILABLE); }).verify(); expectRequest(request -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)) .isEqualTo(\"bearer my-access-token\");",
        "ins2PreCode":"public void getUaaUrlWhenCloudControllerUrlIsNotReachableShouldThrowException() throws Exception { prepareResponse(response -> response.setResponseCode(500)); StepVerifier.create(this.securityService.getUaaUrl()) StepVerifier.create(this.securityService.getUaaUrl()) .consumeErrorWith(throwable -> { assertThat(throwable) .isInstanceOf(CloudFoundryAuthorizationException.class); assertThat( ((CloudFoundryAuthorizationException) throwable).getReason()) .isEqualTo(Reason.SERVICE_UNAVAILABLE); }).verify(); expectRequest(request -> assertThat(request.getPath()) expectRequest(request -> assertThat(request.getPath()) .isEqualTo(Reason.SERVICE_UNAVAILABLE);",
        "label":1
    },
    {
        "ins1AddCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(generateSessionReadQuery(options))) {",
        "ins1DelCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) {",
        "ins1PreCode":"public Collection<PostgreSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new byte[newSize];",
        "ins1DelCode":"if( limit >0 && newSize > limit ) { newSize=limit; } tmp=new byte[newSize]; if( limit > 0 && newSize > limit ) { newSize=limit; } tmp=new byte[newSize];",
        "ins1PreCode":" if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit >0 && newSize > limit ) { newSize=limit; } tmp=new byte[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) { newSize=limit; } tmp=new byte[newSize]; } ",
        "ins2PreCode":"if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit > 0 && newSize > limit ) { newSize=limit; } tmp=new char[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) { newSize=limit; } tmp=new char[newSize]; }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertValue() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void assertValue() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposable.empty());",
        "label":0
    },
    {
        "ins1AddCode":"target.setLineWidth((c instanceof Color) ? ArgoFig.LINE_WIDTH : 0);",
        "ins1DelCode":"target.setLineWidth((c instanceof Color) ? 1 : 0);",
        "ins1PreCode":"if (c instanceof Color) { target.setLineColor((Color) c); } target.setLineWidth((c instanceof Color) ? 1 : 0); target.endTrans();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"connector.setThrowOnFailure(true);",
        "ins1DelCode":"",
        "ins1PreCode":"File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector);",
        "ins2PreCode":"File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector);",
        "label":1
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaKMeansExample\").getOrCreate(); JavaRDD<Row> points = spark.read().text(inputFile).javaRDD().map(new ParsePoint()); Dataset<Row> dataset = spark.createDataFrame(points, schema); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JavaKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc); JavaRDD<Row> points = jsc.textFile(inputFile).map(new ParsePoint()); Dataset<Row> dataset = sqlContext.createDataFrame(points, schema); jsc.stop();",
        "ins1PreCode":"int k = Integer.parseInt(args[1]);   SparkConf conf = new SparkConf().setAppName(\"JavaKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc);    JavaRDD<Row> points = jsc.textFile(inputFile).map(new ParsePoint()); StructField[] fields = {new StructField(\"features\", new VectorUDT(), false, Metadata.empty())}; StructType schema = new StructType(fields); Dataset<Row> dataset = sqlContext.createDataFrame(points, schema);   KMeans kmeans = new KMeans() .setK(k); KMeansModel model = kmeans.fit(dataset);   Vector[] centers = model.clusterCenters(); System.out.println(\"Cluster Centers: \"); for (Vector center: centers) { System.out.println(center); }   jsc.stop();",
        "ins2PreCode":"for (int i = 0; i < clusterCenters.length; i++) { SparkConf conf = new SparkConf().setAppName(\"JavaBisectingKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); JavaRDD<Row> data = jsc.parallelize(Arrays.asList( new StructField(\"features\", new VectorUDT(), false, Metadata.empty()), StructType schema = new StructType(new StructField[]{ Dataset<Row> dataset = jsql.createDataFrame(data, schema); BisectingKMeans bkm = new BisectingKMeans().setK(2); jsc.stop(); BisectingKMeansModel model = bkm.fit(dataset); Vector[] clusterCenters = model.clusterCenters(); System.out.println(\"Cluster Center \" + i + \": \" + clusterCenter); Vector clusterCenter = clusterCenters[i]; System.out.println(\"Cluster Center \" + i + \": \" + clusterCenter); } jsc.stop();",
        "label":0
    },
    {
        "ins1AddCode":"assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));",
        "ins1DelCode":"Assert.assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));",
        "ins1PreCode":"p.setDisplayName(displayName);  Jenkins jenkins = Jenkins.getInstance(); Assert.assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));",
        "ins2PreCode":"p.setDisplayName(displayName); Jenkins jenkins = Jenkins.getInstance(); FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);",
        "label":1
    },
    {
        "ins1AddCode":"DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), templatize(ZoneOffset.UTC), templatize(randomLocale(random())), \"date_as_string\", Collections.singletonList(\"UNIX_MS\"), \"date_as_date\");",
        "ins1DelCode":"DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), templatize(UTC), templatize(randomLocale(random())), \"date_as_string\", Collections.singletonList(\"UNIX_MS\"), \"date_as_date\");",
        "ins1PreCode":"public void testUnixMs() { DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), templatize(UTC), templatize(randomLocale(random())), \"date_as_string\", Collections.singletonList(\"UNIX_MS\"), \"date_as_date\"); Map<String, Object> document = new HashMap<>(); document.put(\"date_as_string\", \"1000500\");",
        "ins2PreCode":"public void testUnix() { DateProcessor dateProcessor = new DateProcessor(randomAlphaOfLength(10), templatize(UTC), \"date_as_string\", Collections.singletonList(\"UNIX\"), \"date_as_date\"); Map<String, Object> document = new HashMap<>(); document.put(\"date_as_string\", \"1000.5\");",
        "label":1
    },
    {
        "ins1AddCode":"filesIncluded = new VectorSet(); filesExcluded = new VectorSet(); dirsIncluded = new VectorSet(); dirsExcluded = new VectorSet();",
        "ins1DelCode":"filesIncluded = new Vector(); filesExcluded = new Vector(); dirsIncluded = new Vector(); dirsExcluded = new Vector();",
        "ins1PreCode":"excludes = new String[0]; }  filesIncluded = new Vector(); filesNotIncluded = new Vector(); filesExcluded = new Vector(); dirsIncluded = new Vector(); dirsNotIncluded = new Vector(); dirsExcluded = new Vector();  try {",
        "ins2PreCode":"excludes = new String[0]; } filesIncluded = new Vector(); filesNotIncluded = new Vector(); filesExcluded = new Vector(); dirsIncluded = new Vector(); dirsNotIncluded = new Vector(); dirsExcluded = new Vector(); try {",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 100; ++i) { String results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertEquals(sb.toString(), results);",
        "ins1DelCode":"for(int i=0; i < 100;++i) { String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]);",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString() + \"\\r\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1AddCode":"List<NodePropertyDescriptor> result = new ArrayList<>();",
        "ins1DelCode":"List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>();",
        "ins1PreCode":"public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class); for (NodePropertyDescriptor npd : list) {",
        "ins2PreCode":"public static List<NodePropertyDescriptor> getGlobalNodePropertyDescriptors() { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class); for (NodePropertyDescriptor npd : list) {",
        "label":1
    },
    {
        "ins1AddCode":"void callbackInvokeAndWhenNoGenericShouldReturnResult() {",
        "ins1DelCode":"public void callbackInvokeAndWhenNoGenericShouldReturnResult() {",
        "ins1PreCode":"public void callbackInvokeAndWhenNoGenericShouldReturnResult() { NonGenericFactory callbackInstance = mock(NonGenericFactory.class); String argument = \"foo\";",
        "ins2PreCode":"public void callbackInvokeAndWhenHasGenericShouldReturnResult() { StringFactory callbackInstance = mock(StringFactory.class); String argument = \"foo\";",
        "label":1
    },
    {
        "ins1AddCode":"PathMapper.useEndpointId(), Collections.emptyList(),",
        "ins1DelCode":"EndpointPathResolver.useEndpointId(), Collections.emptyList(),",
        "ins1PreCode":"WebClient.Builder webClientBuilder) { CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, EndpointPathResolver.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(",
        "ins2PreCode":"RestTemplateBuilder restTemplateBuilder) { CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, EndpointPathResolver.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(",
        "label":1
    },
    {
        "ins1AddCode":"Map<Integer, String> expected = new LinkedHashMap<>();",
        "ins1DelCode":"Map<Integer, String> expected = new LinkedHashMap<Integer, String>();",
        "ins1PreCode":"} }, mapFactory);  Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\"); expected.put(3, \"ccc\");",
        "ins2PreCode":"} }, mapFactory); Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\"); expected.put(3, \"ccc\");",
        "label":1
    },
    {
        "ins1AddCode":"mgr.setContext(new StandardContext());",
        "ins1DelCode":"mgr.setContainer(new StandardContext());",
        "ins1PreCode":"} catch (LifecycleException e) {  } mgr.setContainer(new StandardContext()); mgr.generateSessionId(); while (mgr.sessionCreationTiming.size() <",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"SSLEngine sslEngine = ch.getSslEngine(); if (sslEngine != null) { SSLSession session = sslEngine.getSession(); return ((NioEndpoint) getEndpoint()).getSslImplementation().getSSLSupport(session); } return null;",
        "ins1DelCode":"SSLSession session = ch.getSslEngine().getSession(); return ((NioEndpoint) getEndpoint()).getSslImplementation().getSSLSupport(session); } else { return null;",
        "ins1PreCode":"public SSLSupport getSslSupport(String clientCertProvider) { if (getSocket() instanceof SecureNioChannel) { SecureNioChannel ch = (SecureNioChannel) getSocket(); SSLSession session = ch.getSslEngine().getSession(); return ((NioEndpoint) getEndpoint()).getSslImplementation().getSSLSupport(session); } else { return null; }",
        "ins2PreCode":"public SSLSupport getSslSupport(String clientCertProvider) { if (getSocket() instanceof SecureNio2Channel) { SecureNio2Channel ch = (SecureNio2Channel) getSocket(); SSLSession session = ch.getSslEngine().getSession(); return ((Nio2Endpoint) getEndpoint()).getSslImplementation().getSSLSupport(session); } else { return null; }",
        "label":1
    },
    {
        "ins1AddCode":"if (isCaseSensitive() ? includeNonPatterns.contains(name) : includeNonPatterns.contains(name.toUpperCase())) { return true;",
        "ins1DelCode":"if ((isCaseSensitive() && includeNonPatterns.contains(name)) || (!isCaseSensitive() && includeNonPatterns.contains(name.toUpperCase()))) { return true;",
        "ins1PreCode":"protected boolean isIncluded(String name) { ensureNonPatternSetsReady();  if ((isCaseSensitive() && includeNonPatterns.contains(name)) || (!isCaseSensitive() && includeNonPatterns.contains(name.toUpperCase()))) { return true; }",
        "ins2PreCode":"protected boolean isExcluded(String name) { ensureNonPatternSetsReady(); if ((isCaseSensitive() && excludeNonPatterns.contains(name)) || (!isCaseSensitive() && excludeNonPatterns.contains(name.toUpperCase()))) { return true; }",
        "label":1
    },
    {
        "ins1AddCode":"void readOperationsThatReturnAResourceSupportRangeRequests() {",
        "ins1DelCode":"public void readOperationsThatReturnAResourceSupportRangeRequests() {",
        "ins1PreCode":"public void readOperationsThatReturnAResourceSupportRangeRequests() { load(ResourceEndpointConfiguration.class, (client) -> { byte[] responseBody = client.get().uri(\"/resource\").header(\"Range\", \"bytes=0-3\").exchange().expectStatus()",
        "ins2PreCode":"public void readOperationsThatReturnAResourceSupportRangeRequests() { load(ResourceEndpointConfiguration.class, (client) -> { byte[] responseBody = client.get().uri(\"/resource\").header(\"Range\", \"bytes=0-3\").exchange().expectStatus()",
        "label":1
    },
    {
        "ins1AddCode":"\"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" OBJECT_NAME, STATUS FROM \" +",
        "ins1DelCode":"\"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" * FROM \" +",
        "ins1PreCode":"throws SQLException { JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" * FROM \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), owner.getDataSource(), \"OBJECTS\") + \" WHERE OBJECT_TYPE='PACKAGE' AND OWNER=? \" +",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);",
        "ins1DelCode":"containerLog.warn(sm.getString(\"jndiRealm.exception\"), e); containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);",
        "ins1PreCode":"} catch (CommunicationException e) {   containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);   if (context != null) close(context);   context = open();   principal = getPrincipal(context, username, gssCredential);  } catch (ServiceUnavailableException e) {   containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(initializerBeans.iterator()).toIterable() .hasOnlyElementsOfType(TestServlet.class);",
        "ins1DelCode":"assertThat(initializerBeans.iterator()).hasOnlyElementsOfType(TestServlet.class);",
        "ins1PreCode":"ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans( this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).hasOnlyElementsOfType(TestServlet.class);",
        "ins2PreCode":"ServletContextInitializerBeans initializerBeans = new ServletContextInitializerBeans( this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).hasOnlyElementsOfType(TestFilter.class);",
        "label":1
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(orientation, \"orientation\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(orientation, \"orientation\");",
        "ins1PreCode":"CategoryDataset dataset, PlotOrientation orientation, boolean legend, boolean tooltips, boolean urls) {  ParamChecks.nullNotPermitted(orientation, \"orientation\"); CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel); categoryAxis.setCategoryMargin(0.0);",
        "ins2PreCode":"CategoryDataset dataset, PlotOrientation orientation, boolean legend, boolean tooltips, boolean urls) { ParamChecks.nullNotPermitted(orientation, \"orientation\"); CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel); CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel);",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<String> value1 = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<String> value1 = new AtomicReference<String>();",
        "ins1PreCode":"public void subscribeCompletionRaceCondition() { for (int i = 0; i < 50; i++) { final ReplayProcessor<String> processor = ReplayProcessor.create(); final AtomicReference<String> value1 = new AtomicReference<String>();  processor.subscribe(new Consumer<String>() {",
        "ins2PreCode":"public void subscribeCompletionRaceCondition() { for (int i = 0; i < 50; i++) { final ReplayProcessor<String> processor = ReplayProcessor.createUnbounded(); final AtomicReference<String> value1 = new AtomicReference<String>(); processor.subscribe(new Consumer<String>() {",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(1);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1);",
        "ins1PreCode":"public void unorderedOnNextRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); final QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "ins2PreCode":"public void orderedOnNextRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); final QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "label":1
    },
    {
        "ins1AddCode":"tgt.setRelativePath( null );",
        "ins1DelCode":"",
        "ins1PreCode":"if ( tgt == null ) { tgt = new Parent(); target.setParent( tgt ); } mergeParent( tgt, src, sourceDominant, context );",
        "ins2PreCode":"if ( tgt == null ) { tgt = new IssueManagement(); target.setIssueManagement( tgt ); } mergeIssueManagement( tgt, src, sourceDominant, context );",
        "label":0
    },
    {
        "ins1AddCode":"CombinedRangeXYPlot<S> result = (CombinedRangeXYPlot) super.clone(); for (XYPlot<S> child : result.subplots) {",
        "ins1DelCode":"CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); for (XYPlot child : result.subplots) {",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException {  CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) CloneUtils.cloneList(this.subplots); for (XYPlot child : result.subplots) { child.setParent(result); }",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { CombinedDomainXYPlot result = (CombinedDomainXYPlot) super.clone(); result.subplots = CloneUtils.cloneList(this.subplots); for (XYPlot child : result.subplots) { child.setParent(result); }",
        "label":1
    },
    {
        "ins1AddCode":"label_15: break label_15;",
        "ins1DelCode":"label_14: break label_14;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_14: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_14; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_15; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"null, data + 4L * rowId, count * 4L); long offset = data + 4L * rowId;",
        "ins1DelCode":"null, data + 4 * rowId, count * 4); long offset = data + 4 * rowId;",
        "ins1PreCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 4 * rowId, count * 4); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 4 * rowId; for (int i = 0; i < count; ++i, offset += 4, srcOffset += 4) { Platform.putInt(null, offset,",
        "ins2PreCode":"public void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 8 * rowId, count * 8); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 8 * rowId; for (int i = 0; i < count; ++i, offset += 8, srcOffset += 8) { Platform.putLong(null, offset,",
        "label":1
    },
    {
        "ins1AddCode":"this.requestFactoryCustomizer, this.interceptors);",
        "ins1DelCode":"this.requestFactoryCustomizers, this.interceptors);",
        "ins1PreCode":"new LinkedHashSet<HttpMessageConverter<?>>(messageConverters)), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, this.interceptors);",
        "ins2PreCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, this.interceptors);",
        "label":1
    },
    {
        "ins1AddCode":"defaultServlet.addInitParameter(\"fileEncoding\", \"ISO-8859-1\");",
        "ins1DelCode":"",
        "ins1PreCode":"Wrapper defaultServlet = Tomcat.addServlet(ctxt, \"default\", \"org.apache.catalina.servlets.DefaultServlet\"); defaultServlet.addInitParameter(\"gzip\", \"true\"); ctxt.addServletMappingDecoded(\"/\", \"default\");  ctxt.addMimeMapping(\"html\", \"text/html\");",
        "ins2PreCode":"Wrapper defaultServlet = Tomcat.addServlet(ctxt, \"default\", \"org.apache.catalina.servlets.DefaultServlet\"); defaultServlet.addInitParameter(\"precompressed\", \"true\"); ctxt.addServletMappingDecoded(\"/\", \"default\"); ctxt.addMimeMapping(\"html\", \"text/html\");",
        "label":1
    },
    {
        "ins1AddCode":"willThrow(exception).given(tokenValidator).validate(any());",
        "ins1DelCode":"BDDMockito.willThrow(exception).given(tokenValidator).validate(any());",
        "ins1PreCode":"public void linksToOtherEndpointsForbidden() { CloudFoundryAuthorizationException exception = new CloudFoundryAuthorizationException( Reason.INVALID_TOKEN, \"invalid-token\"); BDDMockito.willThrow(exception).given(tokenValidator).validate(any()); load(TestEndpointConfiguration.class, (client) -> client.get().uri(\"/cfApplication\")",
        "ins2PreCode":"public void linksToOtherEndpointsForbidden() { CloudFoundryAuthorizationException exception = new CloudFoundryAuthorizationException( Reason.INVALID_TOKEN, \"invalid-token\"); willThrow(exception).given(tokenValidator).validate(any()); load(TestEndpointConfiguration.class, (client) -> client.get().uri(\"/cfApplication\")",
        "label":0
    },
    {
        "ins1AddCode":"CategoryStepRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"CategoryStepRenderer r2 = (CategoryStepRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CategoryStepRenderer r1 = new CategoryStepRenderer(false); CategoryStepRenderer r2 = (CategoryStepRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerRenderer r1 = new BoxAndWhiskerRenderer(); BoxAndWhiskerRenderer r2 = (BoxAndWhiskerRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); Assert.assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); Assert.assertFalse(\"Connection got starved:\"+x.getMessage(),true);",
        "ins1DelCode":"init(); assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); assertFalse(\"Connection got starved:\"+x.getMessage(),true);",
        "ins1PreCode":"public void testConnectionStarvation() throws Exception { init(); config(); Connection con1 = datasource.getConnection(); Connection con2 = null; try { con2 = datasource.getConnection(); try { con2.setCatalog(\"mysql\"); }catch (SQLException x) { assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); } assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); }catch (Exception x) { assertFalse(\"Connection got starved:\"+x.getMessage(),true); }finally { if (con2!=null) con2.close();",
        "ins2PreCode":"public void testFairConnectionStarvation() throws Exception { init(); config(); Connection con1 = datasource.getConnection(); Connection con2 = null; try { con2 = datasource.getConnection(); try { con2.setCatalog(\"mysql\"); }catch (SQLException x) { assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); } assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); }catch (Exception x) { assertFalse(\"Connection got starved:\"+x.getMessage(),true); }finally { if (con2!=null) con2.close();",
        "label":1
    },
    {
        "ins1AddCode":"return getImage(DBIcon.TYPE_UNKNOWN); log.error(\"Image '\" + image.getLocation() + \"' not found\"); return getImage(DBIcon.TYPE_UNKNOWN);",
        "ins1DelCode":"return null; throw new IllegalArgumentException(\"Image '\" + image.getLocation() + \"' not found\");",
        "ins1PreCode":"public static Image getImage(@NotNull DBPImage image) { if (image == null) { return null; } if (image instanceof DBIconBinary) { return ((DBIconBinary) image).getImage(); } else { IconDescriptor icon = getIconByLocation(image.getLocation()); if (icon == null) { throw new IllegalArgumentException(\"Image '\" + image.getLocation() + \"' not found\"); } else if (image instanceof DBIconComposite) { return getCompositeIcon(icon, (DBIconComposite) image).image;",
        "ins2PreCode":"public static ImageDescriptor getImageDescriptor(@NotNull DBPImage image) { if (image == null) { return null; } if (image instanceof DBIconBinary) { return ((DBIconBinary) image).getImageDescriptor(); } else { IconDescriptor icon = getIconByLocation(image.getLocation()); if (icon == null) { throw new IllegalArgumentException(\"Image '\" + image.getLocation() + \"' not found\"); } else if (image instanceof DBIconComposite) { return getCompositeIcon(icon, (DBIconComposite) image).imageDescriptor;",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testInsertTable1() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table1.insert\", parms); assertEquals(1, rows); assertEquals(11, parms.get(\"id\"));  } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertTable2() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insert\", parms); assertEquals(1, rows); assertEquals(22, parms.get(\"id\")); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"final HashSet<String> hs = new HashSet<>(nodes);",
        "ins1DelCode":"final HashSet<String> hs = new HashSet<>(); hs.addAll(nodes);",
        "ins1PreCode":"boolean errorOccurred = false; final Jenkins jenkins = Jenkins.getActiveInstance();  final HashSet<String> hs = new HashSet<>(); hs.addAll(nodes);  List<String> names = null;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"failWithMessage(\"Unsupported type for JSON assert {}\", expected.getClass());",
        "ins1DelCode":"failWithMessage(\"Unsupported type for JSON assert {]\", expected.getClass());",
        "ins1PreCode":"if (expected instanceof Resource) { return isNotEqualToJson((Resource) expected); } failWithMessage(\"Unsupported type for JSON assert {]\", expected.getClass()); return null;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/\", \"default2\"); ctx.addServletMappingDecoded(\"/servlets/*\", \"default2\"); ctx.addServletMappingDecoded(\"/static/*\", \"default2\");",
        "ins1DelCode":"ctx.addServletMapping(\"/\", \"default2\"); ctx.addServletMapping(\"/servlets/*\", \"default2\"); ctx.addServletMapping(\"/static/*\", \"default2\");",
        "ins1PreCode":"  Tomcat.addServlet(ctx, \"default2\", new DefaultServlet()); ctx.addServletMapping(\"/\", \"default2\"); ctx.addServletMapping(\"/servlets/*\", \"default2\"); ctx.addServletMapping(\"/static/*\", \"default2\");  tomcat.start();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"int iterCount) throws Exception { mgr.randomFileCurrent = mgr.randomFile; mgr.createRandomIS(); mgr.generateSessionId();",
        "ins1DelCode":"int iterCount) {",
        "ins1PreCode":"public void doTestManagerBaseGenerateSessionId(int threadCount, int iterCount) {  ",
        "ins2PreCode":"public void doTestManagerBaseCreateSession(int threadCount, int iterCount) { for (int i = 0; i < threadCount; i++) {",
        "label":1
    },
    {
        "ins1AddCode":".runOn(this.resourceFactory.getLoopResources()).bindAddress(this::getListenAddress));",
        "ins1DelCode":".runOn(this.resourceFactory.getLoopResources()).addressSupplier(this::getListenAddress));",
        "ins1PreCode":"private ServerTransport<CloseableChannel> createWebSocketTransport() { if (this.resourceFactory != null) { HttpServer httpServer = HttpServer.create().tcpConfiguration((tcpServer) -> tcpServer .runOn(this.resourceFactory.getLoopResources()).addressSupplier(this::getListenAddress)); return WebsocketServerTransport.create(httpServer); }",
        "ins2PreCode":"private ServerTransport<CloseableChannel> createTcpTransport() { if (this.resourceFactory != null) { TcpServer tcpServer = TcpServer.create().runOn(this.resourceFactory.getLoopResources()) .addressSupplier(this::getListenAddress); return TcpServerTransport.create(tcpServer); }",
        "label":1
    },
    {
        "ins1AddCode":"return Objects.equals(appId, appExecId.appId) && Objects.equals(execId, appExecId.execId);",
        "ins1DelCode":"return Objects.equal(appId, appExecId.appId) && Objects.equal(execId, appExecId.execId);",
        "ins1PreCode":"if (o == null || getClass() != o.getClass()) return false;  AppExecId appExecId = (AppExecId) o; return Objects.equal(appId, appExecId.appId) && Objects.equal(execId, appExecId.execId);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".withMessageStartingWith(\"Search location '\").withMessageEndingWith(\"' must end with '*/'\");",
        "ins1DelCode":".withMessage(\"Wildcard patterns must end with '*/'\");",
        "ins1PreCode":"\"spring.config.location=\" + location); assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildcard patterns must end with '*/'\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".parse(new StringReader(\"@article{test,author = {H'{e}lne Fiaux}}\")); assertEquals(Optional.of(\"H'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1DelCode":".parse(new StringReader(\"@article{test,author = {H\\'{e}lne Fiaux}}\")); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1PreCode":"void parseHandlesAccentsCorrectly() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author = {H\\'{e}lne Fiaux}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"void parsePreambleAndEntryWithoutNewLine() throws IOException { ParserResult result = parser .parse(new StringReader(\"@preamble{some text and \\\\latex}@article{test,author = {H\\'{e}lne Fiaux}}\")); Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H\\'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "label":1
    },
    {
        "ins1AddCode":"if (!ftp.changeWorkingDirectory(directory)) { return fileListMap.get(currentPath); FTPFile[] result;",
        "ins1DelCode":"boolean result = ftp.changeWorkingDirectory(directory); if (!result) { return ((FTPFile[]) fileListMap.get(currentPath)); FTPFile[] result = null;",
        "ins1PreCode":"String currentPath = directory; if (changedir) { try { boolean result = ftp.changeWorkingDirectory(directory); if (!result) { return null; } currentPath = ftp.printWorkingDirectory(); } catch (IOException ioe) { throw new BuildException(ioe, task.getLocation()); } } if (fileListMap.containsKey(currentPath)) { task.log(\"filelist map used in listing files\", Project.MSG_DEBUG); return ((FTPFile[]) fileListMap.get(currentPath)); } FTPFile[] result = null; try { result = ftp.listFiles();",
        "ins2PreCode":"String currentPath = directory; if (changedir) { try { boolean result = ftp.changeWorkingDirectory(directory); if (!result) { return null; } currentPath = ftp.printWorkingDirectory(); } catch (IOException ioe) { throw new BuildException(ioe, getLocation()); } } if (fileListMap.containsKey(currentPath)) { getProject().log(\"filelist map used in listing files\", Project.MSG_DEBUG); return ((FTPFile[]) fileListMap.get(currentPath)); } FTPFile[] result = null; try { result = ftp.listFiles();",
        "label":1
    },
    {
        "ins1AddCode":"Iterable<ModelObject> itemList = newRuns(1, 10);",
        "ins1DelCode":"List<ModelObject> itemList = newRuns(1, 10);",
        "ins1PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = newRuns(1, 10);  historyPageFilter.add(itemList);",
        "ins2PreCode":"public void test_newerThan_near_newest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 8L, null); List<ModelObject> itemList = newRuns(1, 10); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1AddCode":"list.add(new RfcFetcher(importFormatPreferences));",
        "ins1DelCode":"",
        "ins1PreCode":"list.add(new CrossRef()); list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"list.add(new CrossRef()); list.add(new DoiFetcher(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1AddCode":"new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, -1);",
        "ins1DelCode":"FileHandler handler = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, -1);",
        "ins1PreCode":"public void testCleanDisabled() throws Exception { generateLogFiles(logsDir, PREFIX_1, SUFIX_1, 3);  FileHandler handler = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, -1);  Thread.sleep(1000);",
        "ins2PreCode":"public void testCleanOnInitOneHandler() throws Exception { generateLogFiles(logsDir, PREFIX_1, SUFIX_1, 3); FileHandler handler = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, 2); Thread.sleep(1000);",
        "label":1
    },
    {
        "ins1AddCode":"ClusteredXYBarRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"ClusteredXYBarRenderer r2 = (ClusteredXYBarRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer(); ClusteredXYBarRenderer r2 = (ClusteredXYBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>(subscriber);",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>(subscriber);",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber(); int numRetries = 2; Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries)); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber); origin.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() { @Override",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver(); int numRetries = 2; Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(numRetries)); TestObserver<String> to = new TestObserver<String>(observer); origin.retryWhen(new Function<Observable<? extends Throwable>, Observable<Object>>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<?> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<?> plot = (XYPlot<?>) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "label":0
    },
    {
        "ins1AddCode":"Set<IdFetcher<?>> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences); Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses());",
        "ins1DelCode":"Set<IdFetcher> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());",
        "ins1PreCode":"void getIdFetchersReturnsAllFetcherDerivingFromIdFetcher() throws Exception { Set<IdFetcher> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(IdFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());  expected.remove(IdParserFetcher.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void getEndpointsShouldDiscoverProxyServletEndpoints() {",
        "ins1DelCode":"public void getEndpointsShouldDiscoverProxyServletEndpoints() {",
        "ins1PreCode":"public void getEndpointsShouldDiscoverProxyServletEndpoints() { this.contextRunner.withUserConfiguration(TestProxyServletEndpoint.class) .withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))",
        "ins2PreCode":"public void getEndpointsShouldIncludeControllerEndpoints() { this.contextRunner.withUserConfiguration(TestControllerEndpoint.class).run(assertDiscoverer((discoverer) -> { this.contextRunner.withUserConfiguration(TestControllerEndpoint.class).run(assertDiscoverer((discoverer) -> {",
        "label":1
    },
    {
        "ins1AddCode":"protected final void addElementListener(PropertyChangeListener listener, LOG.log(Level.WARNING, \"Encountered deleted object during delete of \" + element); LOG.log(Level.FINE, \"Attempted duplicate registration of event listener\" \" - Element: \" + element + \" Listener: \" + listener); + \" - Element: {0} Listener: {1}\", new Object[]{element, listener});",
        "ins1DelCode":"protected final void addElementListener(PropertyChangeListener listener, LOG.warn(\"Encountered deleted object during delete of \" + element); LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener);",
        "ins1PreCode":"protected final void addElementListener(PropertyChangeListener listener, Object element, String property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener); }",
        "ins2PreCode":"protected final void addElementListener(PropertyChangeListener listener, Object element, String[] property) { if (Model.getUmlFactory().isRemoved(element)) { LOG.warn(\"Encountered deleted object during delete of \" + element); return; } Object[] entry = new Object[] {element, property}; if (!listeners.contains(entry)) { listeners.add(entry); Model.getPump().addModelEventListener(listener, element, property); } else { LOG.debug(\"Attempted duplicate registration of event listener\" + \" - Element: \" + element + \" Listener: \" + listener); }",
        "label":0
    },
    {
        "ins1AddCode":"new JspCServletContext(null, appDir.toURI().toURL(), null);",
        "ins1DelCode":"new JspCServletContext(null, appDir.toURI().toURL());",
        "ins1PreCode":"public void testWebapp_2_3() throws Exception { File appDir = new File(\"test/webapp-2.3\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(2, context.getEffectiveMajorVersion()); Assert.assertEquals(3, context.getEffectiveMinorVersion());",
        "ins2PreCode":"public void testWebapp_2_4() throws Exception { File appDir = new File(\"test/webapp-2.4\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(2, context.getEffectiveMajorVersion()); Assert.assertEquals(4, context.getEffectiveMinorVersion());",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testAnnotatedInsertTable2() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2WithSelectKeyWithKeyMap(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"void loadWhenHasConfigurationPropertiesValidatorShouldApplyValidator() {",
        "ins1DelCode":"public void loadWhenHasConfigurationPropertiesValidatorShouldApplyValidator() {",
        "ins1PreCode":"public void loadWhenHasConfigurationPropertiesValidatorShouldApplyValidator() { assertThatExceptionOfType(Exception.class).isThrownBy(() -> load(WithCustomValidatorConfiguration.class)) .satisfies((ex) -> {",
        "ins2PreCode":"public void loadWhenBindingToConstructorParametersShouldValidate() { assertThatExceptionOfType(Exception.class) .isThrownBy(() -> load(ConstructorParameterValidationConfiguration.class)).satisfies((ex) -> {",
        "label":1
    },
    {
        "ins1AddCode":"cmdl.setClassname(JavaCC.getMainClass(classpath, JavaCC.TASKDEF_TYPE_JJTREE));",
        "ins1DelCode":"cmdl.setClassname(JavaCC.getMainClass(javaccHome, JavaCC.TASKDEF_TYPE_JJTREE));",
        "ins1PreCode":" cmdl.createArgument().setValue(target.getAbsolutePath());  cmdl.setClassname(JavaCC.getMainClass(javaccHome, JavaCC.TASKDEF_TYPE_JJTREE)); ",
        "ins2PreCode":"cmdl.createArgument().setValue(target.getAbsolutePath()); cmdl.setClassname(JavaCC.getMainClass(javaccHome, JavaCC.TASKDEF_TYPE_JJDOC));",
        "label":1
    },
    {
        "ins1AddCode":"public final Flowable<@NonNull List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) {",
        "ins1DelCode":"public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) {",
        "ins1PreCode":"public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) { Objects.requireNonNull(comparator, \"comparator is null\"); ObjectHelper.verifyPositive(capacityHint, \"capacityHint\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void incidentEdges_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void incidentEdges_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(\"sys resolved relative to project's basedir\", assertThat(\"sys resolved relative to project's basedir\", assertThat(\"java/lib/rt.jar resolved relative to project's basedir\", assertThat(\"java/lib/classes.zip resolved relative to project's basedir\",",
        "ins1DelCode":"assertThat(\"sys resolved relative to project\\'s basedir\", assertThat(\"sys resolved relative to project\\'s basedir\", assertThat(\"java/lib/rt.jar resolved relative to project\\'s basedir\", assertThat(\"java/lib/classes.zip resolved relative to project\\'s basedir\",",
        "ins1PreCode":"String[] l = p.list(); if (isUnixStyle) { assertEquals(\"no drives on Unix\", 3, l.length); assertThat(\"sys resolved relative to project\\'s basedir\", l[0], endsWith(\"/SYS\")); assertEquals(\"/JAVA/lib/rt.jar\", l[1]); assertEquals(\"/JAVA/lib/classes.zip\", l[2]); } else if (isNetWare) { assertEquals(\"volumes on NetWare\", 2, l.length); assertEquals(\"sys:\\\\java\\\\lib\\\\rt.jar\", l[0].toLowerCase(Locale.US)); assertEquals(\"sys:\\\\java\\\\lib\\\\classes.zip\", l[1].toLowerCase(Locale.US)); } else { assertEquals(\"no multiple character-length volumes on Windows\", 3, l.length); assertThat(\"sys resolved relative to project\\'s basedir\", l[0], endsWith(\"\\\\SYS\")); assertThat(\"java/lib/rt.jar resolved relative to project\\'s basedir\", l[1], endsWith(\"\\\\JAVA\\\\lib\\\\rt.jar\")); assertThat(\"java/lib/classes.zip resolved relative to project\\'s basedir\", l[2], endsWith(\"\\\\JAVA\\\\lib\\\\classes.zip\")); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"case NON_SECURE: netOutBuffer.clear(); netOutBuffer.put(TLSClientHelloExtractor.USE_TLS_RESPONSE); netOutBuffer.flip(); flush(); throw new IOException(sm.getString(\"channel.nio.ssl.foundHttp\"));",
        "ins1DelCode":"",
        "ins1PreCode":"hostName = endpoint.getDefaultSSLHostConfigName(); clientRequestedCiphers = Collections.emptyList(); break; }  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); }  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers, clientRequestedApplicationProtocols);",
        "ins2PreCode":"hostName = endpoint.getDefaultSSLHostConfigName(); clientRequestedCiphers = Collections.emptyList(); break; } if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); } sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers, clientRequestedApplicationProtocols);",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":" LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "label":1
    },
    {
        "ins1AddCode":"XIntervalSeriesCollection<String> c = new XIntervalSeriesCollection<>(); XIntervalSeries<String> s1 = new XIntervalSeries<>(\"s1\");",
        "ins1DelCode":"XIntervalSeriesCollection c = new XIntervalSeriesCollection(); XIntervalSeries s1 = new XIntervalSeries(\"s1\");",
        "ins1PreCode":"public void testRemoveSeries() { XIntervalSeriesCollection c = new XIntervalSeriesCollection(); XIntervalSeries s1 = new XIntervalSeries(\"s1\"); c.addSeries(s1); c.removeSeries(0);",
        "ins2PreCode":"public void testRemoveSeries() { YIntervalSeriesCollection c = new YIntervalSeriesCollection(); YIntervalSeries s1 = new YIntervalSeries(\"s1\"); c.addSeries(s1); c.removeSeries(0);",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> concat(",
        "ins1DelCode":"public static <T> Flowable<T> concat(",
        "ins1PreCode":"public static <T> Flowable<T> concat( @NonNull SingleSource<? extends T> source1, @NonNull SingleSource<? extends T> source2, @NonNull SingleSource<? extends T> source3, @NonNull SingleSource<? extends T> source4",
        "ins2PreCode":"public static <T> Flowable<T> merge( @NonNull SingleSource<? extends T> source1, @NonNull SingleSource<? extends T> source2, @NonNull SingleSource<? extends T> source3, @NonNull SingleSource<? extends T> source4",
        "label":1
    },
    {
        "ins1AddCode":"LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(1.0, 100, 0.0, 1.0);",
        "ins1DelCode":"LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD();",
        "ins1PreCode":"List<LabeledPoint> validationData = LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(); linSGDImpl.setIntercept(true); LinearRegressionModel model = linSGDImpl.run(testRDD.rdd());",
        "ins2PreCode":"List<LabeledPoint> validationData = LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1); LinearRegressionModel model = LinearRegressionWithSGD.train(testRDD.rdd(), 100); Assert.assertTrue(numAccurate > nPoints * 4.0 / 5.0); LinearRegressionModel model = LinearRegressionWithSGD.train(testRDD.rdd(), 100);",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>(subscriber);",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>(subscriber);",
        "ins1PreCode":"public void onCompletedFromNotificationHandler() { Subscriber<String> subscriber = TestHelper.mockSubscriber(); Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(1)); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber); origin.retryWhen(new Function<Flowable<? extends Throwable>, Flowable<Object>>() { @Override",
        "ins2PreCode":"public void onCompletedFromNotificationHandler() { Observer<String> observer = TestHelper.mockObserver(); Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(1)); TestObserver<String> to = new TestObserver<String>(observer); origin.retryWhen(new Function<Observable<? extends Throwable>, Observable<?>>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"protected Set<Field> determineFieldsToShow(BibEntry entry) { return entryType.get().getDeprecatedFields(); return Collections.emptySet();",
        "ins1DelCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { return entryType.get().getDeprecatedFields() .stream() .filter(entry::hasField) .collect(Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(Field::getName)))); return Collections.emptySortedSet();",
        "ins1PreCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) { return entryType.get().getDeprecatedFields() .stream() .filter(entry::hasField) .collect(Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(Field::getName)))); } else {  return Collections.emptySortedSet(); }",
        "ins2PreCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) { return entryType.get().getSecondaryOptionalNotDeprecatedFields(); if (entryType.isPresent()) { if (entryType.isPresent()) { return Collections.emptySortedSet(); } else { return Collections.emptySortedSet(); }",
        "label":0
    },
    {
        "ins1AddCode":"public void specificResourceAsFile() {",
        "ins1DelCode":"public void specificResourceAsFile() throws Exception {",
        "ins1PreCode":"public void specificResourceAsFile() throws Exception { String location = \"file:src/test/resources/specificlocation.properties\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void specificResourceDefaultsToFile() throws Exception { String location = \"src/test/resources/specificlocation.properties\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1AddCode":"for (XYPlot child : result.subplots) {",
        "ins1DelCode":"for (Iterator it = result.subplots.iterator(); it.hasNext();) { Plot child = (Plot) it.next();",
        "ins1PreCode":" CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) ObjectUtils.deepClone(this.subplots); for (Iterator it = result.subplots.iterator(); it.hasNext();) { Plot child = (Plot) it.next(); child.setParent(result); }",
        "ins2PreCode":"= (CombinedRangeCategoryPlot) super.clone(); result.subplots = (List) ObjectUtils.deepClone(this.subplots); for (Iterator it = result.subplots.iterator(); it.hasNext();) { Plot child = (Plot) it.next(); child.setParent(result); }",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true);",
        "ins2PreCode":"public void testDBCPThreads10Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1AddCode":"void exceptionError() throws Exception {",
        "ins1DelCode":"public void exceptionError() throws Exception {",
        "ins1PreCode":"public void exceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new TestFilterChain((request, response, chain) -> {",
        "ins2PreCode":"public void subClassExceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new TestFilterChain((request, response, chain) -> {",
        "label":1
    },
    {
        "ins1AddCode":"Request request = new MockRequest();",
        "ins1DelCode":"Request request = new Request();",
        "ins1PreCode":"RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve(); remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request()); ",
        "ins2PreCode":"RemoteAddrAndHostTrackerValve remoteAddrAndHostTrackerValve = new RemoteAddrAndHostTrackerValve(); remoteIpValve.setNext(remoteAddrAndHostTrackerValve); Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "label":1
    },
    {
        "ins1AddCode":"ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<>(w);",
        "ins1DelCode":"ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(w);",
        "ins1PreCode":"window = w; windows.getAndIncrement();  ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(w); downstream.onNext(intercept); if (intercept.tryAbandon()) {",
        "ins2PreCode":"window = w; windows.getAndIncrement(); FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<T>(w); downstream.onNext(intercept); if (intercept.tryAbandon()) {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"2005\"), entry.getField(StandardField.YEAR));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"2005\"), entry.getField(\"year\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"2005\"), entry.getField(\"year\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"DefaultIntervalXYDataset<String> d = new DefaultIntervalXYDataset<>(); try { catch (IllegalArgumentException e) {",
        "ins1DelCode":"DefaultIntervalXYDataset d = new DefaultIntervalXYDataset(); try { catch (IllegalArgumentException e) {",
        "ins1PreCode":"public void testAddSeries() { DefaultIntervalXYDataset d = new DefaultIntervalXYDataset(); d.addSeries(\"S1\", new double[][] {{1.0}, {0.5}, {1.5}, {2.0}, {2.5}, {1.5}}); assertEquals(1, d.getSeriesCount()); assertEquals(\"S1\", d.getSeriesKey(0));   d.addSeries(\"S1\", new double[][] {{1.1}, {0.6}, {1.6}, {2.1}, {2.6}, {1.6}}); assertEquals(1, d.getSeriesCount()); assertEquals(2.1, d.getYValue(0, 0), EPSILON);   boolean pass = false; try { d.addSeries(null, new double[][] {{1.1}, {0.6}, {1.6}, {2.1}, {2.6}, {1.6}}); } catch (IllegalArgumentException e) { pass = true; }",
        "ins2PreCode":"public void testAddSeries() { DefaultXYZDataset d = new DefaultXYZDataset(); d.addSeries(\"S1\", new double[][] {{1.0}, {2.0}, {3.0}}); d.addSeries(\"S1\", new double[][] {{1.0}, {2.0}, {3.0}}); assertEquals(1, d.getSeriesCount()); assertEquals(\"S1\", d.getSeriesKey(0)); d.addSeries(\"S1\", new double[][] {{1.0}, {2.0}, {3.0}}); d.addSeries(\"S1\", new double[][] {{1.0}, {2.0}, {3.0}}); assertEquals(1, d.getSeriesCount()); assertEquals(12.0, d.getYValue(0, 0), EPSILON); boolean pass = false; try { d.addSeries(null, new double[][] {{1.0}, {2.0}, {3.0}}); d.addSeries(\"S1\", new double[][] {{1.0}, {2.0}, {3.0}}); } catch (IllegalArgumentException e) { pass = true; }",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(expected).hasCauseThat().isInstanceOf(SomeOtherCheckedException.class);",
        "ins1DelCode":"assertThat(expected.getCause()).isInstanceOf(SomeOtherCheckedException.class);",
        "ins1PreCode":"sample.oneDeclared(); fail(); } catch (RuntimeException expected) { assertThat(expected.getCause()).isInstanceOf(SomeOtherCheckedException.class); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"new FetchShuffleBlocks( \"app-id\", \"exec-id\", 0, new long[] { 0 }, new int[][] {{ 0, 1, 2 }}, false),",
        "ins1DelCode":"new FetchShuffleBlocks(\"app-id\", \"exec-id\", 0, new long[] { 0 }, new int[][] {{ 0, 1, 2 }}),",
        "ins1PreCode":"BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new FetchShuffleBlocks(\"app-id\", \"exec-id\", 0, new long[] { 0 }, new int[][] {{ 0, 1, 2 }}), conf); ",
        "ins2PreCode":"BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new OpenBlocks(\"app-id\", \"exec-id\", blockIds), conf);",
        "label":0
    },
    {
        "ins1AddCode":"private CombinedDomainXYPlot<String> createPlot() { CombinedDomainXYPlot<String> plot = new CombinedDomainXYPlot<> (",
        "ins1DelCode":"private CombinedDomainXYPlot createPlot() { CombinedDomainXYPlot plot = new CombinedDomainXYPlot(",
        "ins1PreCode":"private CombinedDomainXYPlot createPlot() {  XYDataset<String> data1 = createDataset1(); XYItemRenderer renderer1 = new StandardXYItemRenderer(); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); XYPlot<String> subplot1 = new XYPlot<>(data1, null, rangeAxis1, renderer1); subplot1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT);  XYTextAnnotation annotation = new XYTextAnnotation(\"Hello!\", 50.0, 10000.0); annotation.setFont(new Font(\"SansSerif\", Font.PLAIN, 9)); annotation.setRotationAngle(Math.PI / 4.0); subplot1.addAnnotation(annotation);   XYDataset<String> data2 = createDataset2(); XYItemRenderer renderer2 = new StandardXYItemRenderer(); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\"); rangeAxis2.setAutoRangeIncludesZero(false); XYPlot<String> subplot2 = new XYPlot<>(data2, null, rangeAxis2, renderer2); subplot2.setRangeAxisLocation(AxisLocation.TOP_OR_LEFT);   CombinedDomainXYPlot plot = new CombinedDomainXYPlot( new NumberAxis(\"Domain\")); plot.setGap(10.0);",
        "ins2PreCode":"private CombinedRangeXYPlot createPlot() { XYDataset<String> data1 = createDataset1(); XYItemRenderer renderer1 = new StandardXYItemRenderer(); NumberAxis xAxis1 = new NumberAxis(\"X1\"); XYPlot<String> subplot1 = new XYPlot<>(data1, xAxis1, null, renderer1); subplot1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT); = new XYTextAnnotation(\"Hello!\", 50.0, 10000.0); plot.setGap(10.0); annotation.setFont(new Font(\"SansSerif\", Font.PLAIN, 9)); annotation.setRotationAngle(Math.PI / 4.0); subplot1.addAnnotation(annotation); XYDataset<String> data2 = createDataset2(); XYItemRenderer renderer2 = new StandardXYItemRenderer(); NumberAxis xAxis2 = new NumberAxis(\"X2\"); xAxis2.setAutoRangeIncludesZero(false); XYPlot<String> subplot2 = new XYPlot<>(data2, xAxis2, null, renderer2); subplot2.setRangeAxisLocation(AxisLocation.TOP_OR_LEFT); CombinedRangeXYPlot plot = new CombinedRangeXYPlot(new NumberAxis( NumberAxis xAxis1 = new NumberAxis(\"X1\"); plot.setGap(10.0);",
        "label":1
    },
    {
        "ins1AddCode":"FileSet fsDestination = buildRule.getProject().getReference(\"fileset-destination-without-selector\");",
        "ins1DelCode":"FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\");",
        "ins1PreCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject()); dsDestination.scan();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( configuration)) {",
        "ins1DelCode":"AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( configuration); try { finally { context.close(); }",
        "ins1PreCode":"private void load(Function<EndpointId, Long> timeToLive, PathMapper endpointPathMapper, Class<?> configuration, Consumer<WebEndpointDiscoverer> consumer) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( configuration); try { ConversionServiceParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper( DefaultConversionService.getSharedInstance()); EndpointMediaTypes mediaTypes = new EndpointMediaTypes( Collections.singletonList(\"application/json\"), Collections.singletonList(\"application/json\")); WebEndpointDiscoverer discoverer = new WebEndpointDiscoverer(context, parameterMapper, mediaTypes, Collections.singletonList(endpointPathMapper), Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)), Collections.emptyList()); consumer.accept(discoverer); } finally { context.close(); }",
        "ins2PreCode":"private void load(Function<EndpointId, Long> timeToLive, PathMapper endpointPathMapper, Class<?> configuration, Consumer<CloudFoundryWebEndpointDiscoverer> consumer) { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext( configuration); try { ConversionServiceParameterValueMapper parameterMapper = new ConversionServiceParameterValueMapper( DefaultConversionService.getSharedInstance()); EndpointMediaTypes mediaTypes = new EndpointMediaTypes( Collections.singletonList(\"application/json\"), Collections.singletonList(\"application/json\")); CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( context, parameterMapper, mediaTypes, Collections.singletonList(endpointPathMapper), Collections.singleton(new CachingOperationInvokerAdvisor(timeToLive)), Collections.emptyList()); consumer.accept(discoverer); } finally { context.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(properties.getGraphiteTagsEnabled()).isEqualTo(config.graphiteTagsEnabled());",
        "ins1DelCode":"assertThat(properties.isGraphiteTagsEnabled()).isEqualTo(config.graphiteTagsEnabled());",
        "ins1PreCode":"assertThat(properties.getHost()).isEqualTo(config.host()); assertThat(properties.getPort()).isEqualTo(config.port()); assertThat(properties.getProtocol()).isEqualTo(config.protocol()); assertThat(properties.isGraphiteTagsEnabled()).isEqualTo(config.graphiteTagsEnabled()); assertThat(properties.getTagsAsPrefix()).isEqualTo(config.tagsAsPrefix());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"merged-plugin-class-path-order/wo-plugin-mgmt/sub\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"merged-plugin-class-path-order/wo-plugin-mngt/sub\" );",
        "ins1PreCode":"public void testOrderOfMergedPluginDependenciesWithoutPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-class-path-order/wo-plugin-mngt/sub\" );  assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/dependencies\" ) ).size() );",
        "ins2PreCode":"public void testOrderOfMergedPluginDependenciesWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-class-path-order/w-plugin-mngt/sub\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/dependencies\" ) ).size() );",
        "label":1
    },
    {
        "ins1AddCode":"DefaultBoxAndWhiskerXYDataset<String> d2 = TestUtils.serialised(d1);",
        "ins1DelCode":"DefaultBoxAndWhiskerXYDataset d2 = TestUtils.serialised(d1);",
        "ins1PreCode":"= new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = TestUtils.serialised(d1); assertEquals(d1, d2); ",
        "ins2PreCode":"= new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset<String> d2 = CloneUtils.clone(d1); assertTrue(d1 != d2);",
        "label":0
    },
    {
        "ins1AddCode":"final TestObserver<Void> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Void> to = new TestObserver<Void>();",
        "ins1PreCode":"public void cancelAfterFirst() { final TestObserver<Void> to = new TestObserver<Void>();  Completable.mergeArray(new Completable() {",
        "ins2PreCode":"public void cancelAfterFirstDelayError() { final TestObserver<Void> to = new TestObserver<Void>(); Completable.mergeArrayDelayError(new Completable() {",
        "label":1
    },
    {
        "ins1AddCode":"\"/test/bug5nnnn/bug53545.jsp\", res, null);",
        "ins1DelCode":"\"/test/bug53545.jsp\", res, null);",
        "ins1PreCode":"ByteChunk res = new ByteChunk();  int rc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug53545.jsp\", res, null);  Assert.assertEquals(HttpServletResponse.SC_OK, rc);",
        "ins2PreCode":"ByteChunk res = new ByteChunk(); int rc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug54012.jsp\", res, null); Assert.assertEquals(HttpServletResponse.SC_OK, rc);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(ExceptionHelper.nullWarning(\"onError called with a null Throwable.\"), ex.getMessage());",
        "ins1DelCode":"assertEquals(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage());",
        "ins1PreCode":"p.onError(null); fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage()); } ",
        "ins2PreCode":"p.onNext(null); fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage()); }",
        "label":1
    },
    {
        "ins1AddCode":"File defaultSnippetsDir = new File(this.generatedSnippets, \"default-snippets\");",
        "ins1DelCode":"File defaultSnippetsDir = new File(\"target/generated-snippets/default-snippets\");",
        "ins1PreCode":"public void defaultSnippetsAreWritten() throws Exception { this.mvc.perform(get(\"/\")).andDo(document(\"default-snippets\")); File defaultSnippetsDir = new File(\"target/generated-snippets/default-snippets\"); assertThat(defaultSnippetsDir).exists(); assertThat(new File(defaultSnippetsDir, \"curl-request.adoc\"))",
        "ins2PreCode":"public void defaultSnippetsAreWritten() throws Exception { .expectBody().consumeWith(document(\"default-snippets\")); File defaultSnippetsDir = new File(\"target/generated-snippets/default-snippets\"); assertThat(defaultSnippetsDir).exists(); assertThat(new File(defaultSnippetsDir, \"curl-request.adoc\"))",
        "label":1
    },
    {
        "ins1AddCode":"b = Objects.requireNonNull(bufferSupplier.get(), \"The buffer supplied is null\");",
        "ins1DelCode":"b = ObjectHelper.requireNonNull(bufferSupplier.get(), \"The buffer supplied is null\");",
        "ins1PreCode":"fastPathOrderedEmit(b, false, this);  try { b = ObjectHelper.requireNonNull(bufferSupplier.get(), \"The buffer supplied is null\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "ins2PreCode":"fastPathOrderedEmitMax(b, false, this); try { b = ObjectHelper.requireNonNull(bufferSupplier.get(), \"The supplied buffer is null\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "label":1
    },
    {
        "ins1AddCode":"rc.set(Disposable.empty());",
        "ins1DelCode":"rc.set(Disposables.empty());",
        "ins1PreCode":"ObservableRefCount<Object> o = (ObservableRefCount<Object>)tco.refCount();  RefConnection rc = new RefConnection(o); rc.set(Disposables.empty()); o.connection = rc; ",
        "ins2PreCode":"FlowableRefCount<Object> o = (FlowableRefCount<Object>)tcf.refCount(); RefConnection rc = new RefConnection(o); rc.set(Disposables.empty()); o.connection = rc;",
        "label":1
    },
    {
        "ins1AddCode":"void customBeanNameGenerator() {",
        "ins1DelCode":"public void customBeanNameGenerator() {",
        "ins1PreCode":"public void customBeanNameGenerator() { TestSpringApplication application = new TestSpringApplication(ExampleWebConfig.class); BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();",
        "ins2PreCode":"public void customBeanNameGeneratorWithNonWebApplication() { TestSpringApplication application = new TestSpringApplication(ExampleWebConfig.class); BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();",
        "label":1
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE));",
        "ins1DelCode":"TextFlow description = createDescription(query, true, false);",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final TestObserver<Void> to2 = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Void> to2 = new TestObserver<Void>();",
        "ins1PreCode":" final TestObserver<Void> to1 = c.test();  final TestObserver<Void> to2 = new TestObserver<Void>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ts.awaitDone(10, TimeUnit.SECONDS);",
        "ins1DelCode":"ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins1PreCode":"public void merge1AsyncStreamOf1() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(1, 1).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors(); assertEquals(1, ts.values().size());",
        "ins2PreCode":"public void merge1AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(1, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors(); assertEquals(1000, ts.values().size());",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ, Run.DELETE) .authorizedTo(Jenkins.READ, Item.READ, Run.DELETE)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE)",
        "ins1PreCode":"assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(2));  CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"1,3\"); assertThat(result, succeeded()); assertThat(result.stdout(), containsString(\"Deleted 1 builds\")); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1));  result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"2-3\"); assertThat(result, succeeded());",
        "ins2PreCode":"assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(2)); CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"1,2\"); assertThat(result, succeeded()); assertThat(result.stdout(), containsString(\"Deleted 1 builds\")); assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1)); result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"2-3\"); assertThat(result, succeeded());",
        "label":1
    },
    {
        "ins1AddCode":"final List<Long> requested = new ArrayList<>();",
        "ins1DelCode":"final List<Long> requested = new ArrayList<Long>();",
        "ins1PreCode":"public void concatObservablePrefetch() { final List<Long> requested = new ArrayList<Long>(); Flowable<Completable> cs = Flowable .just(normal.completable)",
        "ins2PreCode":"public void mergeObservableMaxConcurrent() { final List<Long> requested = new ArrayList<Long>(); Flowable<Completable> cs = Flowable .just(normal.completable)",
        "label":1
    },
    {
        "ins1AddCode":"assertThrowsWithMessage(\"Value 3 (class: Integer) at position 2 did not pass the predicate (latch = 0, values = 3, errors = 0, completions = 1)\", AssertionError.class, () -> {",
        "ins1DelCode":"assertThrows(\"Value not present\", AssertionError.class, () -> {",
        "ins1PreCode":"public void assertValueAtPredicateNoMatch() { assertThrows(\"Value not present\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins2PreCode":"public void assertValueAtPredicateNoMatch() { assertThrows(\"Value not present\", AssertionError.class, () -> { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "label":0
    },
    {
        "ins1AddCode":"HtmlPage p = j.createWebClient().goTo(\"self/testNestedTopButton\"); rootAction.bindClass = FooList.class; j.submit(f); \"FooList:title two:[foo:txt 2.1:false]]\", bindResult.toString()); + \"FooList:title two:[foo:txt 2.1:false]]\", rootAction.bindResult.toString());",
        "ins1DelCode":"HtmlPage p = createWebClient().goTo(\"self/testNestedTopButton\"); bindClass = FooList.class; submit(f); + \"FooList:title two:[foo:txt 2.1:false]]\", bindResult.toString());",
        "ins1PreCode":"public void testNestedEnabledTopButton() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testNestedTopButton\"); HtmlForm f = p.getFormByName(\"config\"); try { clickButton(p, f, \"Add\", true); f.getInputByValue(\"\").setValueAttribute(\"title one\"); clickButton(p,f,\"Add Foo\", true); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); clickButton(p,f,\"Add Foo\", false); f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getInputsByName(\"bool\").get(1).click(); clickButton(p, f, \"Add\", false); f.getInputByValue(\"\").setValueAttribute(\"title two\"); f.getElementsByTagName(\"button\").get(3).click(); f.getInputByValue(\"\").setValueAttribute(\"txt 2.1\"); } catch (Exception e) { System.err.println(\"HTML at time of failure:\\n\" + p.getBody().asXml()); throw e; } bindClass = FooList.class; submit(f); assertEquals(\"[FooList:title one:[foo:txt one:false,foo:txt two:true], \" + \"FooList:title two:[foo:txt 2.1:false]]\", bindResult.toString());",
        "ins2PreCode":"public void testNestedEnabledTopButtonInner() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testNestedTopButtonInner\"); HtmlForm f = p.getFormByName(\"config\"); try { clickButton(p, f, \"Add\", true); f.getInputByValue(\"\").setValueAttribute(\"title one\"); clickButton(p,f,\"Add Foo\", true); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); clickButton(p,f,\"Add Foo\", false); f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getInputsByName(\"bool\").get(1).click(); clickButton(p, f, \"Add\", false); f.getInputByValue(\"\").setValueAttribute(\"title two\"); f.getElementsByTagName(\"button\").get(2).click(); f.getInputByValue(\"\").setValueAttribute(\"txt 2.1\"); } catch (Exception e) { System.err.println(\"HTML at time of failure:\\n\" + p.getBody().asXml()); throw e; } bindClass = FooList.class; submit(f); assertEquals(\"[FooList:title one:[foo:txt one:false,foo:txt two:true], \" + \"FooList:title two:[foo:txt 2.1:false]]\", bindResult.toString());",
        "label":1
    },
    {
        "ins1AddCode":"errors.tryTerminateConsumer(downstream);",
        "ins1DelCode":"if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream); }",
        "ins1PreCode":"disposed = true; upstream.dispose(); set.dispose(); if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream); }",
        "ins2PreCode":"disposed = true; upstream.dispose(); set.dispose(); if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream); }",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> letterCount = stream.map(String::length);",
        "ins1DelCode":"JavaDStream<Integer> letterCount = stream.map(new Function<String, Integer>() { @Override public Integer call(String s) { return s.length(); } });",
        "ins1PreCode":"Arrays.asList(9,4));  JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> letterCount = stream.map(new Function<String, Integer>() { @Override public Integer call(String s) { return s.length(); } }); JavaTestUtils.attachTestOutputStream(letterCount); List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins2PreCode":"Arrays.asList(9, 4)); JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> letterCount = stream.map(String::length); public void testMap() { public void testMap() { Arrays.asList(9, 4)); } } JavaTestUtils.attachTestOutputStream(letterCount); List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "ins1DelCode":"assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins1PreCode":"  assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins2PreCode":"assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "label":1
    },
    {
        "ins1AddCode":"\"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)) .andRespond(withSuccess().body(\"ce8d8b6838ecceb68962b975b18682f4237ccf71\".getBytes()));",
        "ins1DelCode":"\"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)).andRespond(withSuccess());",
        "ins1PreCode":"void artifactsPublishedWhenPublishedShouldReturnTrue() { this.server.expect(requestTo(String.format( \"https://oss.sonatype.org/service/local/repositories/releases/content/org/springframework/boot/spring-boot/%s/spring-boot-%s.jar.sha1\", \"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)).andRespond(withSuccess()); boolean published = this.service.artifactsPublished(getReleaseInfo()); assertThat(published).isTrue();",
        "ins2PreCode":"void artifactsPublishedWhenNotPublishedShouldReturnFalse() { this.server.expect(requestTo(String.format( \"https://oss.sonatype.org/service/local/repositories/releases/content/org/springframework/boot/spring-boot/%s/spring-boot-%s.jar.sha1\", \"1.1.0.RELEASE\", \"1.1.0.RELEASE\"))).andExpect(method(HttpMethod.GET)) boolean published = this.service.artifactsPublished(getReleaseInfo()); assertThat(published).isFalse();",
        "label":0
    },
    {
        "ins1AddCode":"PieDataset<K> that = (PieDataset) obj; K k1 = getKey(i); K k2 = that.getKey(i);",
        "ins1DelCode":"PieDataset that = (PieDataset) obj; Comparable k1 = getKey(i); Comparable k2 = that.getKey(i);",
        "ins1PreCode":"if (!(obj instanceof PieDataset)) { return false; } PieDataset that = (PieDataset) obj; int count = getItemCount(); if (that.getItemCount() != count) { return false; }  for (int i = 0; i < count; i++) { Comparable k1 = getKey(i); Comparable k2 = that.getKey(i); if (!k1.equals(k2)) { return false;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ, Run.DELETE)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ, Run.DELETE)",
        "ins1PreCode":"assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1));  final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"1\"); assertThat(result, succeeded());",
        "ins2PreCode":"assertThat(((FreeStyleProject) j.jenkins.getItem(\"aProject\")).getBuilds(), hasSize(1)); final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"0\"); assertThat(result, succeeded());",
        "label":1
    },
    {
        "ins1AddCode":"ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<>(window);",
        "ins1DelCode":"ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(window);",
        "ins1PreCode":"window = UnicastSubject.create(bufferSize, windowRunnable); this.window = window;  ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(window); downstream.onNext(intercept); ",
        "ins2PreCode":"window = UnicastProcessor.create(bufferSize, windowRunnable); this.window = window; FlowableWindowSubscribeIntercept<T> intercept = new FlowableWindowSubscribeIntercept<T>(window); downstream.onNext(intercept);",
        "label":1
    },
    {
        "ins1AddCode":"XYBubbleRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"XYBubbleRenderer r2 = (XYBubbleRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYBubbleRenderer r1 = new XYBubbleRenderer(); XYBubbleRenderer r2 = (XYBubbleRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final List<String> events = new ArrayList<>();",
        "ins1DelCode":"final List<String> events = new ArrayList<String>();",
        "ins1PreCode":"public void usingDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events); final Consumer<Throwable> onError = createOnErrorAction(events);",
        "ins2PreCode":"public void usingDoesNotDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<String>(); final Supplier<Resource> resourceFactory = createResourceFactory(events); final Consumer<Throwable> onError = createOnErrorAction(events);",
        "label":1
    },
    {
        "ins1AddCode":"public void autoConfiguredExternalDataSourceIsNotShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext( \"org.postgresql.Driver\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));",
        "ins1DelCode":"public void autoConfiguredExternalDataSourceIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.postgresql.Driver\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class);",
        "ins1PreCode":"public void autoConfiguredExternalDataSourceIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.postgresql.Driver\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "ins2PreCode":"public void h2ServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); this.thrown.expectCause(instanceOf(SSLException.class)); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block(); });",
        "ins1DelCode":"setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); this.thrown.expectCause(instanceOf(SSLException.class)); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block();",
        "ins1PreCode":"public void sslValidationNotSkippedByDefault() { setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"File ancestor = new File(System.getProperty(\"protobuf.dir\", \".\")); String initialPath = ancestor.getAbsolutePath(); \"C++ source tree: \" + initialPath);",
        "ins1DelCode":"File ancestor = new File(\".\"); \"C++ source tree.\");",
        "ins1PreCode":"private static File getTestDataDir() {  File ancestor = new File(\".\"); try { ancestor = ancestor.getCanonicalFile(); } catch (IOException e) { throw new RuntimeException( \"Couldn't get canonical name of working directory.\", e); } while (ancestor != null && ancestor.exists()) { if (new File(ancestor, \"src/google/protobuf\").exists()) { return new File(ancestor, \"src/google/protobuf/testdata\"); } ancestor = ancestor.getParentFile(); }  throw new RuntimeException( \"Could not find golden files.  This test must be run from within the \" + \"protobuf source package so that it can read test data files from the \" + \"C++ source tree.\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"SerialUtils.writePaint(this.dialBackgroundPaint, stream); SerialUtils.writePaint(this.dialOutlinePaint, stream); SerialUtils.writePaint(this.needlePaint, stream); SerialUtils.writePaint(this.valuePaint, stream); SerialUtils.writePaint(this.tickPaint, stream); SerialUtils.writePaint(this.tickLabelPaint, stream);",
        "ins1DelCode":"SerialUtilities.writePaint(this.dialBackgroundPaint, stream); SerialUtilities.writePaint(this.dialOutlinePaint, stream); SerialUtilities.writePaint(this.needlePaint, stream); SerialUtilities.writePaint(this.valuePaint, stream); SerialUtilities.writePaint(this.tickPaint, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "ins1PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.dialBackgroundPaint, stream); SerialUtilities.writePaint(this.dialOutlinePaint, stream); SerialUtilities.writePaint(this.needlePaint, stream); SerialUtilities.writePaint(this.valuePaint, stream); SerialUtilities.writePaint(this.tickPaint, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "ins2PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.lastBarPaint, stream); SerialUtilities.writePaint(this.lastBarPaint, stream); SerialUtilities.writePaint(this.negativeBarPaint, stream); SerialUtilities.writePaint(this.lastBarPaint, stream); SerialUtilities.writePaint(this.lastBarPaint, stream); SerialUtilities.writePaint(this.lastBarPaint, stream);",
        "label":0
    },
    {
        "ins1AddCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST);",
        "ins1DelCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST);",
        "ins1PreCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST); Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 44; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null ParallelFailureHandling\");",
        "ins1DelCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"ParallelFailureHandling h;  try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"ParallelFailureHandling h; try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":1
    },
    {
        "ins1AddCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>());",
        "ins1DelCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>());",
        "ins1PreCode":"public void shouldNotLetReadUnloadedPropertyAfterSerialization() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); Assertions.assertThrows(ExecutorException.class, () -> {",
        "ins2PreCode":"public void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); Assertions.assertThrows(ExecutorException.class, () -> {",
        "label":1
    },
    {
        "ins1AddCode":"void yamlProfiles() {",
        "ins1DelCode":"public void yamlProfiles() {",
        "ins1PreCode":"public void yamlProfiles() { this.initializer.setSearchNames(\"testprofiles\"); this.environment.setActiveProfiles(\"dev\");",
        "ins2PreCode":"public void yamlTwoProfiles() { this.initializer.setSearchNames(\"testprofiles\"); this.environment.setActiveProfiles(\"other\", \"dev\");",
        "label":1
    },
    {
        "ins1AddCode":"p.getName() + \"/intermediateFolder/public2.key\", p.getName() + \"/public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/**/*zip*/ws.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( assertThat(entryNames, contains(\"intermediateFolder/public2.key\")); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/**/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage);",
        "ins1DelCode":"",
        "ins1PreCode":" List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( \"intermediateFolder/public2.key\", \"public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"public2.key\")); }",
        "ins2PreCode":"List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( \"intermediateFolder/public2.key\", \"public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK)); List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"public2.key\")); }",
        "label":0
    },
    {
        "ins1AddCode":"getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize());",
        "ins1DelCode":"bufHandler.expand(sslEngine.getSession().getApplicationBufferSize());",
        "ins1PreCode":"   bufHandler.expand(sslEngine.getSession().getApplicationBufferSize()); if (netOutBuffer.capacity() < sslEngine.getSession().getApplicationBufferSize()) { ",
        "ins2PreCode":"bufHandler.expand(sslEngine.getSession().getApplicationBufferSize()); if (netOutBuffer.capacity() < sslEngine.getSession().getApplicationBufferSize()) {",
        "label":1
    },
    {
        "ins1AddCode":"this.values = new AtomicReferenceArray<>(n); this.upstream = new AtomicReference<>();",
        "ins1DelCode":"this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Disposable>();",
        "ins1PreCode":"s[i] = new WithLatestInnerObserver(this, i); } this.observers = s; this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Disposable>(); this.error = new AtomicThrowable();",
        "ins2PreCode":"s[i] = new WithLatestInnerSubscriber(this, i); } this.subscribers = s; this.values = new AtomicReferenceArray<Object>(n); this.upstream = new AtomicReference<Subscription>(); this.error = new AtomicThrowable();",
        "label":0
    },
    {
        "ins1AddCode":"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5) {",
        "ins1DelCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5) {",
        "ins1PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\");",
        "ins2PreCode":"public static <@NonNull T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\");",
        "label":0
    },
    {
        "ins1AddCode":"this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\").run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context .getBean(\"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils .getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(securityInterceptor, \"cloudFoundrySecurityService\"); assertThat(interceptorSecurityService).isNull(); });",
        "ins1DelCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context.getBean( \"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(securityInterceptor, \"cloudFoundrySecurityService\"); assertThat(interceptorSecurityService).isNull(); });",
        "ins1PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context.getBean( \"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(securityInterceptor, \"cloudFoundrySecurityService\");",
        "ins2PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .run(context -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(securityInterceptor, \"cloudFoundrySecurityService\");",
        "label":1
    },
    {
        "ins1AddCode":"if (kind > 54) kind = 54; if (kind > 55) kind = 55; if (kind > 54) kind = 54; if (kind > 54) kind = 54; if (kind > 54) kind = 54; if (kind > 55) kind = 55; if (kind > 54) kind = 54; if (kind > 55) kind = 55; if (kind > 54) kind = 54; if (kind > 54) kind = 54; if (kind > 55) kind = 55; if (kind > 54) kind = 54; if (kind > 54) kind = 54; if (kind > 55) kind = 55; if (kind > 54) kind = 54; if (kind > 55) kind = 55;",
        "ins1DelCode":"if (kind > 52) kind = 52; if (kind > 53) kind = 53; if (kind > 52) kind = 52; if (kind > 52) kind = 52; if (kind > 52) kind = 52; if (kind > 53) kind = 53; if (kind > 52) kind = 52; if (kind > 53) kind = 53; if (kind > 52) kind = 52; if (kind > 52) kind = 52; if (kind > 53) kind = 53; if (kind > 52) kind = 52; if (kind > 52) kind = 52; if (kind > 53) kind = 53; if (kind > 52) kind = 52; if (kind > 53) kind = 53;",
        "ins1PreCode":"} else if ((0x1800000000L & l) != 0L) { if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 53) kind = 53; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 52) kind = 52; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 53) kind = 53; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 53) kind = 53; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 52) kind = 52; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 53) kind = 53; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 52) kind = 52; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 53) kind = 53; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 52) kind = 52; jjCheckNAdd(28); break; case 29: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 53) kind = 53; jjCheckNAdd(29); break;",
        "ins2PreCode":"} else if ((0x1800000000L & l) != 0L) { if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 53) kind = 53; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 52) kind = 52; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 53) kind = 53; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 53) kind = 53; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 52) kind = 52; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 52) kind = 52; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 53) kind = 53; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 52) kind = 52; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 52) kind = 52; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 53) kind = 53; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 52) kind = 52; jjCheckNAdd(28); break; case 29: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 53) kind = 53; jjCheckNAdd(29); break;",
        "label":1
    },
    {
        "ins1AddCode":"String toTest = MoreObjects.toStringHelper(o10).toString();",
        "ins1DelCode":"String toTest = Objects.toStringHelper(o10).toString();",
        "ins1PreCode":"Object o8 = new Object() {}; Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = Objects.toStringHelper(o10).toString(); assertEquals(\"{}\", toTest);",
        "ins2PreCode":"Object o8 = new Object() {}; Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = Objects.toStringHelper(o10).toString(); assertTrue(toTest, toTest.matches(\".*\\\\{\\\\}\"));",
        "label":1
    },
    {
        "ins1AddCode":"\"select s.*,db.name as database_name,r.sql_handle,(select text from sys.dm_exec_sql_text(r.sql_handle)) as sql_text\\n\" +",
        "ins1DelCode":"\"select *,db.name as database_name,r.sql_handle,(select text from sys.dm_exec_sql_text(r.sql_handle)) as sql_text\\n\" +",
        "ins1PreCode":"{ try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"select *,db.name as database_name,r.sql_handle,(select text from sys.dm_exec_sql_text(r.sql_handle)) as sql_text\\n\" + \"from sys.dm_exec_sessions s\\n\" + \"left outer join sys.sysdatabases db on db.dbid=s.database_id\\n\" +",
        "ins2PreCode":"{ try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql.toString())) { \"LEFT JOIN v$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + return sessions; \"LEFT JOIN v$sess_io io ON ( s.sid = io.sid)\\n\" +",
        "label":0
    },
    {
        "ins1AddCode":"public void testCursorIteratorNoSuchElementExceptionWithHasNext() throws IOException { try (SqlSession sqlSession = sqlSessionFactory.openSession(); Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1))) { try { Iterator<User> iterator = usersCursor.iterator(); User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex()); Assert.assertFalse(iterator.hasNext()); iterator.next(); Assert.fail(\"We should have failed since we call next() when hasNext() returned false\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); }",
        "ins1DelCode":"public void testCursorIteratorNoSuchElementExceptionWithHasNext() { SqlSession sqlSession = sqlSessionFactory.openSession(); Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1)); try { Iterator<User> iterator = usersCursor.iterator(); User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex()); Assert.assertFalse(iterator.hasNext()); iterator.next(); Assert.fail(\"We should have failed since we call next() when hasNext() returned false\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); } finally { sqlSession.close();",
        "ins1PreCode":"public void testCursorIteratorNoSuchElementExceptionWithHasNext() { SqlSession sqlSession = sqlSessionFactory.openSession();  Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1)); try { Iterator<User> iterator = usersCursor.iterator();  User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex());  Assert.assertFalse(iterator.hasNext()); iterator.next(); Assert.fail(\"We should have failed since we call next() when hasNext() returned false\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testCursorIteratorNoSuchElementExceptionNoHasNext() { SqlSession sqlSession = sqlSessionFactory.openSession(); Cursor<User> usersCursor = sqlSession.selectCursor(\"getAllUsers\", null, new RowBounds(1, 1)); try { Iterator<User> iterator = usersCursor.iterator(); User user = iterator.next(); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(1, usersCursor.getCurrentIndex()); Assert.assertFalse(usersCursor.isOpen()); iterator.next(); Assert.fail(\"We should have failed since we call next() when is no more items\"); } catch (NoSuchElementException e) { Assert.assertFalse(usersCursor.isOpen()); Assert.assertTrue(usersCursor.isConsumed()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"int len = end - start; if (len != len2 || b1 == null || b2 == null) {",
        "ins1DelCode":"if (b1 == null || b2 == null || end - start != len2) { int len = end - start;",
        "ins1PreCode":"return true; }  if (b1 == null || b2 == null || end - start != len2) { return false; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"list.add(new INSPIREFetcher(importFormatPreferences)); list.add(new ACMPortalFetcher(importFormatPreferences)); list.add(new SpringerFetcher()); list.add(new CiteSeer()); list.add(new DOAJFetcher(importFormatPreferences)); list.add(new IEEE(importFormatPreferences));",
        "ins1DelCode":"",
        "ins1PreCode":"public static List<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"public static List<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<IdBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new MedlineFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new DiVA(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1AddCode":"renderer.setDefaultToolTipGenerator( renderer.setDefaultItemURLGenerator(",
        "ins1DelCode":"renderer.setBaseToolTipGenerator( renderer.setBaseItemURLGenerator(",
        "ins1PreCode":" StackedAreaRenderer renderer = new StackedAreaRenderer(); if (tooltips) { renderer.setBaseToolTipGenerator( new StandardCategoryToolTipGenerator()); } if (urls) { renderer.setBaseItemURLGenerator( new StandardCategoryURLGenerator()); }",
        "ins2PreCode":"LineAndShapeRenderer renderer = new LineAndShapeRenderer(true, false); if (tooltips) { renderer.setBaseToolTipGenerator( new StandardCategoryToolTipGenerator()); } if (urls) { renderer.setBaseItemURLGenerator( new StandardCategoryURLGenerator()); }",
        "label":1
    },
    {
        "ins1AddCode":"void roundTripWithPrecedingCommentTest() throws IOException {",
        "ins1DelCode":"public void roundTripWithPrecedingCommentTest() throws IOException {",
        "ins1PreCode":"public void roundTripWithPrecedingCommentTest() throws IOException {  String bibtexEntry = \"% Some random comment that should stay here\" + OS.NEWLINE +",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ms = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\");",
        "ins1DelCode":"ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\");",
        "ins1PreCode":"MaybeSource<? extends R> ms;  try { ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"SingleSource<? extends R> ms; try { ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTableBase owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options)",
        "ins1DelCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options)",
        "ins1PreCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(monitor, owner, command, options);",
        "ins2PreCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(monitor, owner, command, options);",
        "label":1
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa7_1(active0, 0x40000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L);",
        "ins1PreCode":"switch(curChar) { case 99: return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Row> data = sqlContext.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); Dataset<Row>[] splits = data.randomSplit(new double[] {0.7, 0.3}); Dataset<Row> trainingData = splits[0]; Dataset<Row> testData = splits[1]; Dataset<Row> predictions = model.transform(testData);",
        "ins1DelCode":"DataFrame data = sqlContext.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); DataFrame[] splits = data.randomSplit(new double[] {0.7, 0.3}); DataFrame trainingData = splits[0]; DataFrame testData = splits[1]; DataFrame predictions = model.transform(testData);",
        "ins1PreCode":"   DataFrame data = sqlContext.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\");    VectorIndexerModel featureIndexer = new VectorIndexer() .setInputCol(\"features\") .setOutputCol(\"indexedFeatures\") .setMaxCategories(4) .fit(data);   DataFrame[] splits = data.randomSplit(new double[] {0.7, 0.3}); DataFrame trainingData = splits[0]; DataFrame testData = splits[1];   GBTRegressor gbt = new GBTRegressor() .setLabelCol(\"label\") .setFeaturesCol(\"indexedFeatures\") .setMaxIter(10);   Pipeline pipeline = new Pipeline().setStages(new PipelineStage[] {featureIndexer, gbt});   PipelineModel model = pipeline.fit(trainingData);   DataFrame predictions = model.transform(testData);  ",
        "ins2PreCode":"DataFrame data = sqlContext.read().format(\"libsvm\") VectorIndexerModel featureIndexer = new VectorIndexer() .setInputCol(\"features\") .setOutputCol(\"indexedFeatures\") .setMaxCategories(4) .fit(data); DataFrame[] splits = data.randomSplit(new double[]{0.7, 0.3}); DataFrame trainingData = splits[0]; DataFrame testData = splits[1]; DecisionTreeRegressor dt = new DecisionTreeRegressor() .setLabelCol(\"label\") .setFeaturesCol(\"indexedFeatures\"); .setMaxCategories(4) .setStages(new PipelineStage[]{featureIndexer, dt}); PipelineModel model = pipeline.fit(trainingData); DataFrame predictions = model.transform(testData);",
        "label":1
    },
    {
        "ins1AddCode":"void shouldTrimWHEREInsteadOfORForSecondCondition() throws Exception {",
        "ins1DelCode":"public void shouldTrimWHEREInsteadOfORForSecondCondition() throws Exception {",
        "ins1PreCode":"public void shouldTrimWHEREInsteadOfORForSecondCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  NAME = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimWHEREInsteadOfANDForBothConditions() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  ID = ?   OR NAME = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"q = new SpscArrayQueue<>(bufferSize);",
        "ins1DelCode":"q = new SpscArrayQueue<U>(bufferSize);",
        "ins1PreCode":"} else { SimpleQueue<U> q = inner.queue; if (q == null) { q = new SpscArrayQueue<U>(bufferSize); inner.queue = q; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"public void testReplaceDataset() {   XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1);  LocalListener l = new LocalListener();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertValuesOnly() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(new BooleanSubscription()); ts.assertValuesOnly();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void shouldGetAllUsers_Annotated() {",
        "ins1DelCode":"public void shouldGetAllUsers_Annotated() {",
        "ins1PreCode":"public void shouldGetAllUsers_Annotated() { sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetAUser() { Mapper mapper = sqlSession.getMapper(Mapper.class); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"Map<Integer, String> expected = new LinkedHashMap<>();",
        "ins1DelCode":"Map<Integer, String> expected = new LinkedHashMap<Integer, String>();",
        "ins1PreCode":"} }, mapFactory);  Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\"); expected.put(3, \"ccc\");",
        "ins2PreCode":"} }, mapFactory); Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\"); expected.put(3, \"ccc\");",
        "label":1
    },
    {
        "ins1AddCode":"ContainerRequestCreator.createRequest(jobId, 1, Resource.newInstance(1024, 1), new String[]{\"h1\"}); ContainerRequestCreator.createRequest(jobId, 2, Resource.newInstance(1024, 1), new String[]{\"h2\"}); createRequest(jobId, 3, Resource.newInstance(1024, 1), new String[]{\"h2\"}, false, true); createRequest(jobId, 4, Resource.newInstance(1024, 1), new String[] {\"h3\"}, false, true);",
        "ins1DelCode":"createReq(jobId, 1, 1024, new String[] { \"h1\" }); createReq(jobId, 2, 1024, new String[] { \"h2\" }); createReq(jobId, 3, 1024, new String[] { \"h2\" }, false, true); createReq(jobId, 4, 1024, new String[] { \"h3\" }, false, true);",
        "ins1PreCode":"  ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[] { \"h1\" }); allocator.sendRequest(event1); ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[] { \"h2\" }); allocator.sendRequest(event2); ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[] { \"h2\" }, false, true); allocator.sendRequest(event3);    allocator.schedule(); rm.drainEvents();   clock.setTime(System.currentTimeMillis() + 500000L);   ContainerRequestEvent event4 = createReq(jobId, 4, 1024, new String[] { \"h3\" }, false, true); allocator.sendRequest(event4); ",
        "ins2PreCode":"ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[] { \"h1\" }); allocator.sendRequest(event1); ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[] { \"h2\" }); allocator.sendRequest(event2); ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[] { \"h2\" }, false, true); allocator.sendRequest(event3); allocator.schedule(); rm.drainEvents(); clock.setTime(System.currentTimeMillis() + 500000L); ContainerRequestEvent event4 = createReq(jobId, 4, 1024, new String[] { \"h3\" }, false, true); allocator.sendRequest(event4);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" TakeFirst source = new TakeFirst(to);  Disposable d = Disposables.empty();  source.onSubscribe(d);",
        "ins2PreCode":"TakeFirst source = new TakeFirst(to); Disposable d = Disposables.empty(); source.onSubscribe(d);",
        "label":1
    },
    {
        "ins1AddCode":"r = checkPermissionsAndAddToList(r, p); r = checkPermissionsAndAddToList(r, p); r = checkPermissionsAndAddToList(r, p); r= checkPermissionsAndAddToList(r, p);",
        "ins1DelCode":"r = filterItemListBasedOnPermissions(r, p); r = filterItemListBasedOnPermissions(r, p); r = filterItemListBasedOnPermissions(r, p); r= filterItemListBasedOnPermissions(r, p);",
        "ins1PreCode":"List<Item> r = new ArrayList<Item>();  for(WaitingItem p : s.waitingList) { r = filterItemListBasedOnPermissions(r, p); } for (BlockedItem p : s.blockedProjects){ r = filterItemListBasedOnPermissions(r, p); } for (BuildableItem p : reverse(s.buildables)) { r = filterItemListBasedOnPermissions(r, p); } for (BuildableItem p : reverse(s.pendings)) { r= filterItemListBasedOnPermissions(r, p); } Item[] items = new Item[r.size()];",
        "ins2PreCode":"List<StubItem> r = new ArrayList<StubItem>(); for(WaitingItem p : s.waitingList) { r = filterDiscoverableItemListBasedOnPermissions(r, p); } for (BlockedItem p : s.blockedProjects){ r = filterDiscoverableItemListBasedOnPermissions(r, p); } for (BuildableItem p : reverse(s.buildables)) { r = filterDiscoverableItemListBasedOnPermissions(r, p); } for (BuildableItem p : reverse(s.pendings)) { r = filterDiscoverableItemListBasedOnPermissions(r, p); } StubItem[] items = new StubItem[r.size()];",
        "label":0
    },
    {
        "ins1AddCode":"xContentRegistry(), dispatcher, clusterSettings)) {",
        "ins1DelCode":"xContentRegistry(), dispatcher)) {",
        "ins1PreCode":"} }; try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) { transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());",
        "ins2PreCode":"} }; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) { transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());",
        "label":0
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"SortProcessor.Factory factory = new SortProcessor.Factory(); Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"fail(\"factory create should have failed\"); Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBind() {",
        "ins1DelCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBind() throws Exception {",
        "ins1PreCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBind() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.foo\", \"bar\");",
        "ins2PreCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBindIfPrefixDifferent() MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.foo\", \"bar\");",
        "label":1
    },
    {
        "ins1AddCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry));",
        "ins1DelCode":"ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry));",
        "ins1PreCode":"   ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();",
        "ins2PreCode":"ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();",
        "label":1
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"config.put(\"field\", \"field1\"); config.put(\"value\", null); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"config.put(\"field\", \"field1\"); config.put(\"value\", null); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"File file1 = buildRule.getProject().resolveFile(name1); File file2 = buildRule.getProject().resolveFile(name2);",
        "ins1DelCode":"File file1 = new File(System.getProperty(\"root\"), name1); File file2 = new File(System.getProperty(\"root\"), name2);",
        "ins1PreCode":"private boolean compareFiles(String name1, String name2) throws IOException { File file1 = new File(System.getProperty(\"root\"), name1); File file2 = new File(System.getProperty(\"root\"), name2);  if (!file1.exists() || !file2.exists() || file1.length() != file2.length()) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void writeJar(String baseName, File jarfile, Hashtable<String, File> ejbFiles, String publicId)",
        "ins1DelCode":"protected void writeJar(String baseName, File jarfile, Hashtable ejbFiles, String publicId)",
        "ins1PreCode":"protected void writeJar(String baseName, File jarfile, Hashtable ejbFiles, String publicId) throws BuildException { ",
        "ins2PreCode":"protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException {",
        "label":1
    },
    {
        "ins1AddCode":"void completeLowercaseValueReturnsValue() { database.insertEntry(entry); Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"testvalue\")));",
        "ins1DelCode":"public void completeLowercaseValueReturnsValue() { autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"testvalue\")));",
        "ins1PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testvalue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"test value\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); axisIndices = Arrays.asList(new Integer[] {1, 2});",
        "ins1DelCode":"List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)});",
        "ins1PreCode":"plot.mapDatasetToDomainAxis(0, 1); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));",
        "ins2PreCode":"plot.mapDatasetToRangeAxis(0, 1); assertEquals(yAxis2, plot.getRangeAxisForDataset(0)); List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0)); axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis2, plot.getRangeAxisForDataset(0));",
        "label":1
    },
    {
        "ins1AddCode":"if (theItems.isEmpty()) { return; }",
        "ins1DelCode":"",
        "ins1PreCode":"protected void fireToDoItemsAdded(List<ToDoItem> theItems) {  Object[] listeners = listenerList.getListenerList(); ToDoListEvent e = null; ",
        "ins2PreCode":"protected void fireToDoItemsRemoved(List<ToDoItem> theItems) { Object[] listeners = listenerList.getListenerList(); ToDoListEvent e = null;",
        "label":1
    },
    {
        "ins1AddCode":"final int size = (int) offsetAndSize;",
        "ins1DelCode":"final int size = (int) (offsetAndSize & ((1L << 32) - 1));",
        "ins1PreCode":"} else { final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) (offsetAndSize & ((1L << 32) - 1)); final UnsafeMapData map = new UnsafeMapData(); map.pointTo(baseObject, baseOffset + offset, size);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"\"<b><i>\\\\bibtextype</i><a name=\\\"\\\\bibtexkey\\\">\\\\begin{bibtexkey} (\\\\bibtexkey)</a>\" + \"<b><i>\\\\bibtextype</i><a name=\\\"\\\\citationkey\\\">\\\\begin{citationkey} (\\\\citationkey)</a>\" \"\\\\end{bibtexkey}</b><br>__NEWLINE__\" + \"\\\\end{citationkey}</b><br>__NEWLINE__\"",
        "ins1DelCode":"+ \"<b><i>\\\\bibtextype</i><a name=\\\"\\\\bibtexkey\\\">\\\\begin{bibtexkey} (\\\\bibtexkey)</a>\" + \"\\\\end{bibtexkey}</b><br>__NEWLINE__\"",
        "ins1PreCode":"+ \"</dd>__NEWLINE__<p></p></font>\";  String newPreviewStyle = \"<font face=\\\"sans-serif\\\">\" + \"<b><i>\\\\bibtextype</i><a name=\\\"\\\\bibtexkey\\\">\\\\begin{bibtexkey} (\\\\bibtexkey)</a>\" + \"\\\\end{bibtexkey}</b><br>__NEWLINE__\" + \"\\\\begin{author} \\\\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\\\author}<BR>\\\\end{author}__NEWLINE__\" + \"\\\\begin{editor} \\\\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\\\editor} \"",
        "ins2PreCode":"+ \"</dd>__NEWLINE__<p></p></font>\"; String newPreviewStyle = \"<font face=\\\"sans-serif\\\">\" + \"<b><i>\\\\bibtextype</i><a name=\\\"\\\\bibtexkey\\\">\\\\begin{bibtexkey} (\\\\bibtexkey)</a>\" + \"\\\\end{bibtexkey}</b><br>__NEWLINE__\" + \"\\\\begin{author} \\\\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\\\author}<BR>\\\\end{author}__NEWLINE__\" + \"\\\\begin{editor} \\\\format[Authors(LastFirst,Initials,Semicolon,Amp),HTMLChars]{\\\\editor} \"",
        "label":1
    },
    {
        "ins1AddCode":"runGenericFileSourceOptionsExample(spark);",
        "ins1DelCode":"",
        "ins1PreCode":".getOrCreate();  runBasicDataSourceExample(spark); runBasicParquetExample(spark); runParquetSchemaMergingExample(spark); runJsonDatasetExample(spark);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration.class,",
        "ins1PreCode":"Neo4jRepositoriesAutoConfiguration.class, MongoAutoConfiguration.class, MongoDataAutoConfiguration.class, MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class, HazelcastAutoConfiguration.class, org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration.class, ElasticsearchDataAutoConfiguration.class, org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration.class,",
        "ins2PreCode":"RestTemplateAutoConfiguration.class, WebMvcAutoConfiguration.class, RestTemplateAutoConfiguration.class, WebMvcAutoConfiguration.class, SystemMetricsAutoConfiguration.class, RabbitMetricsAutoConfiguration.class, @ImportAutoConfiguration({ MetricsAutoConfiguration.class, CacheMetricsAutoConfiguration.class, @ImportAutoConfiguration({ MetricsAutoConfiguration.class,",
        "label":0
    },
    {
        "ins1AddCode":".concatMapDelayError(Functions.justFunction(Flowable.just(1)), true, 2, ImmediateThinScheduler.INSTANCE)",
        "ins1DelCode":".concatMapDelayError(Functions.justFunction(Flowable.just(1)), 2, true, ImmediateThinScheduler.INSTANCE)",
        "ins1PreCode":"@Override public Object apply(Integer v) throws Exception { throw new TestException(); } }) .concatMapDelayError(Functions.justFunction(Flowable.just(1)), 2, true, ImmediateThinScheduler.INSTANCE) .test() .assertFailure(TestException.class);",
        "ins2PreCode":"@Override public Object apply(Integer v) throws Exception { throw new TestException(); } }) .concatMapDelayError(Functions.justFunction(Flowable.just(1))) .test() .assertFailure(TestException.class);",
        "label":0
    },
    {
        "ins1AddCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP);",
        "ins1DelCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP);",
        "ins1PreCode":"public void testDataSendACK() throws Exception { System.err.println(\"Starting ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250); System.err.println(\"Finished ACK\");",
        "ins2PreCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\");",
        "label":0
    },
    {
        "ins1AddCode":"\"%nThe use of configuration keys that are no longer supported was found in the environment:%n%n\")); report.append(\"Please refer to the migration guide or reference guide for potential alternatives.\");",
        "ins1DelCode":"\"%nThe use of configuration keys that are no longer \" + \"supported was found in the environment:%n%n\")); report.append(\"Please refer to the migration guide or reference guide for \" + \"potential alternatives.\");",
        "ins1PreCode":"} StringBuilder report = new StringBuilder(); report.append(String.format( \"%nThe use of configuration keys that are no longer \" + \"supported was found in the environment:%n%n\")); append(report, content); report.append(String.format(\"%n\")); report.append(\"Please refer to the migration guide or reference guide for \" + \"potential alternatives.\"); report.append(String.format(\"%n\")); return report.toString();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"label_17: jj_la1[43] = jj_gen; break label_17; jj_la1[44] = jj_gen;",
        "ins1DelCode":"label_16: jj_la1[42] = jj_gen; break label_16; jj_la1[43] = jj_gen;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[42] = jj_gen; break label_16; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: MapEntry(); label_17: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[44] = jj_gen; break label_17; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"void wrap() throws Exception {",
        "ins1DelCode":"public void wrap() throws Exception {",
        "ins1PreCode":"public void wrap() throws Exception { XADataSource dataSource = mock(XADataSource.class); AtomikosXADataSourceWrapper wrapper = new AtomikosXADataSourceWrapper();",
        "ins2PreCode":"public void wrap() throws Exception { XADataSource dataSource = mock(XADataSource.class); BitronixXADataSourceWrapper wrapper = new BitronixXADataSourceWrapper();",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<String> lastValueForSubscriber1 = new AtomicReference<>(); final AtomicReference<String> lastValueForSubscriber2 = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<String> lastValueForSubscriber1 = new AtomicReference<String>(); final AtomicReference<String> lastValueForSubscriber2 = new AtomicReference<String>();",
        "ins1PreCode":"public void newSubscriberDoesntBlockExisting() throws InterruptedException {  final AtomicReference<String> lastValueForSubscriber1 = new AtomicReference<String>(); Observer<String> observer1 = new DefaultObserver<String>() {  @Override public void onComplete() {  }  @Override public void onError(Throwable e) {  }  @Override public void onNext(String v) { System.out.println(\"observer1: \" + v); lastValueForSubscriber1.set(v); }  };  final AtomicReference<String> lastValueForSubscriber2 = new AtomicReference<String>(); final CountDownLatch oneReceived = new CountDownLatch(1); final CountDownLatch makeSlow = new CountDownLatch(1);",
        "ins2PreCode":"public void newSubscriberDoesntBlockExisting() throws InterruptedException { final AtomicReference<String> lastValueForSubscriber1 = new AtomicReference<String>(); Subscriber<String> subscriber1 = new DefaultSubscriber<String>() { @Override public void onComplete() { } @Override public void onError(Throwable e) { } @Override public void onNext(String v) { System.out.println(\"observer1: \" + v); lastValueForSubscriber1.set(v); } }; final AtomicReference<String> lastValueForSubscriber2 = new AtomicReference<String>(); final CountDownLatch oneReceived = new CountDownLatch(1); final CountDownLatch makeSlow = new CountDownLatch(1);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"ex.printStackTrace();",
        "ins1PreCode":"fail(\"No exception thrown\"); } catch (BindException ex) { ex.printStackTrace(); Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex .getCause()).getUnboundProperties();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Collection<String> result = new HashSet<>();",
        "ins1DelCode":"Collection<String> result = new HashSet<String>();",
        "ins1PreCode":"public Collection<String> getServletNameMappings() { Collection<String> result = new HashSet<String>();  FilterMap[] filterMaps = context.findFilterMaps();",
        "ins2PreCode":"public Collection<String> getUrlPatternMappings() { Collection<String> result = new HashSet<String>(); FilterMap[] filterMaps = context.findFilterMaps();",
        "label":1
    },
    {
        "ins1AddCode":"final Computer masterComputer = Jenkins.get().getComputer(\"\");",
        "ins1DelCode":"final Computer masterComputer = Jenkins.getActiveInstance().getComputer(\"\");",
        "ins1PreCode":"public void offlineNodeShouldSucceedOnMaster() throws Exception { final Computer masterComputer = Jenkins.getActiveInstance().getComputer(\"\");  final CLICommandInvoker.Result result = command",
        "ins2PreCode":"public void offlineNodeShouldSucceedOnMasterWithCause() throws Exception { final Computer masterComputer = Jenkins.getActiveInstance().getComputer(\"\"); final CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1AddCode":"if (targetFile == null || !targetFile.isFile()) { throw new BuildException(\"Invalid target: \" + targetFile); javaFile = new File(createOutputFileName(targetFile, outputFile, javaFile = new File(createOutputFileName(targetFile, outputFile, && targetFile.lastModified() < javaFile.lastModified()) { log(\"Target is already built - skipping (\" + targetFile + \")\", cmdl.createArgument().setValue(targetFile.getAbsolutePath());",
        "ins1DelCode":"if (target == null || !target.isFile()) { throw new BuildException(\"Invalid target: \" + target); javaFile = new File(createOutputFileName(target, outputFile, javaFile = new File(createOutputFileName(target, outputFile, && target.lastModified() < javaFile.lastModified()) { log(\"Target is already built - skipping (\" + target + \")\", cmdl.createArgument().setValue(target.getAbsolutePath());",
        "ins1PreCode":"cmdl.createArgument().setValue(\"-\" + name + \":\" + value.toString()); }  if (target == null || !target.isFile()) { throw new BuildException(\"Invalid target: \" + target); }  File javaFile = null;   if (outputDirectory == null) {   cmdl.createArgument().setValue(\"-OUTPUT_DIRECTORY:\" + getDefaultOutputDirectory());  javaFile = new File(createOutputFileName(target, outputFile, null)); } else { if (!outputDirectory.isDirectory()) { throw new BuildException(\"'outputdirectory' \" + outputDirectory + \" is not a directory.\"); }    cmdl.createArgument().setValue(\"-OUTPUT_DIRECTORY:\" + outputDirectory.getAbsolutePath() .replace('\\\\', '/'));  javaFile = new File(createOutputFileName(target, outputFile, outputDirectory .getPath())); }  if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) { log(\"Target is already built - skipping (\" + target + \")\", Project.MSG_VERBOSE); return; }  if (outputFile != null) { cmdl.createArgument().setValue(\"-\" + OUTPUT_FILE + \":\" + outputFile.replace('\\\\', '/')); }  cmdl.createArgument().setValue(target.getAbsolutePath());  final Path classpath = cmdl.createClasspath(getProject());",
        "ins2PreCode":".setValue(\"-\" + name + \":\" + value.toString()); } if (target == null || !target.isFile()) { throw new BuildException(\"Invalid target: \" + target); } if (javaFile.exists() if (outputFile != null) { cmdl.createArgument() .setValue(\"-\" + OUTPUT_FILE + \":\" + outputFile.replace('\\\\', '/')); File javaFile = new File(createOutputFileName(target, outputFile, null); } catch (IOException e) { if (outputFile != null) { throw new BuildException(\"Invalid target: \" + target); return; } cmdl.createArgument() .setValue(\"-\" + OUTPUT_FILE + \":\" arg.setValue(\"-Dinstall.root=\" + javaccHome.getAbsolutePath()); + outputFile.replace('\\\\', '/')); File javaFile = new File(createOutputFileName(target, outputFile, if (outputFile != null) { plainText)); } if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) { log(\"Target is already built - skipping (\" + target + \")\", Project.MSG_VERBOSE); return; } if (outputFile != null) { cmdl.createArgument() .setValue(\"-\" + OUTPUT_FILE + \":\" + outputFile.replace('\\\\', '/')); } cmdl.createArgument().setValue(target.getAbsolutePath()); final Path classpath = cmdl.createClasspath(getProject());",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateTShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateTShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true, false);",
        "ins1DelCode":"Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true);",
        "ins1PreCode":"this.errorAttributes = new DefaultErrorAttributes(true); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); ServerRequest serverRequest = buildServerRequest(request, error); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true); assertThat(attributes.get(\"status\")).isEqualTo(400); assertThat(attributes.get(\"message\")).isEqualTo(\"invalid request\");",
        "ins2PreCode":"this.errorAttributes = new DefaultErrorAttributes(true); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); ServerRequest serverRequest = buildServerRequest(request, error); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true); assertThat(attributes.get(\"status\")).isEqualTo(406); assertThat(attributes.get(\"message\")).isEqualTo(\"could not process request\");",
        "label":1
    },
    {
        "ins1AddCode":"void testMaxHistoryProperty() {",
        "ins1DelCode":"public void testMaxHistoryProperty() {",
        "ins1PreCode":"public void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"test title\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( entry.getField(StandardField.FILE));",
        "ins1DelCode":"entry.setField(\"title\", \"test title\"); entry.setField(\"file\", FileFieldWriter.getStringRepresentation( entry.getField(\"file\"));",
        "ins1PreCode":"Path path = testFolder.resolve(\"Toot.tmp\"); Files.createFile(path);  entry.setField(\"title\", \"test title\"); entry.setField(\"file\", FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"), new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey] - [fulltitle]\"); cleanup.cleanup(entry);  assertEquals( Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"Toot - test title.tmp\", \"\"), new LinkedFile(\"\", \"\", \"\")))), entry.getField(\"file\"));",
        "ins2PreCode":"Path fileAfter = defaultFileFolder.resolve(\"test.pdf\"); assertTrue(Files.exists(fileAfter)); entry.getField(\"file\")); entry.setField(\"file\", FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"test.pdf\", \"\"), new LinkedFile(\"\", \"\", \"\")))), when(filePreferences.getFileDirPattern()).thenReturn(\"\"); cleanup.cleanup(entry); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"test.pdf\", \"\"), new LinkedFile(\"\", \"\", \"\")))), entry.getField(\"file\"));",
        "label":0
    },
    {
        "ins1AddCode":"Builder.create().build(),",
        "ins1DelCode":"ClientEndpointConfigurationBuilder.create().build(),",
        "ins1PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfigurationBuilder.create().build(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins2PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfigurationBuilder.create().build(), new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC)); new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":1
    },
    {
        "ins1AddCode":"ms = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\");",
        "ins1DelCode":"ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\");",
        "ins1PreCode":"MaybeSource<? extends R> ms;  try { ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"MaybeSource<? extends R> ms; try { ms = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d1 = Disposable.empty(); Disposable d2 = Disposable.empty();",
        "ins1DelCode":"Disposable d1 = Disposables.empty(); Disposable d2 = Disposables.empty();",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty();  observer.onSubscribe(d2);",
        "ins2PreCode":"@Override protected void subscribeActual(CompletableObserver observer) { try { Disposable d1 = Disposables.empty(); observer.onSubscribe(d1); Disposable d2 = Disposables.empty(); observer.onSubscribe(d2);",
        "label":1
    },
    {
        "ins1AddCode":"System.out.println(\"Test completed in: \" + delta + \"ms.\");",
        "ins1DelCode":"",
        "ins1PreCode":"this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",this.tDatasource.getNumActive(),10); tearDown();",
        "ins2PreCode":"this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",this.datasource.getSize(),10); tearDown();",
        "label":1
    },
    {
        "ins1AddCode":"nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN, nonloginContext.setSessionTimeout(LONG_SESSION_TIMEOUT_MINS); Tomcat.addServlet(nonloginContext, \"TesterServlet1\", new TesterServlet()); nonloginContext.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); nonloginContext.addConstraint(sc1); Tomcat.addServlet(nonloginContext, \"TesterServlet2\", new TesterServlet()); nonloginContext.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); nonloginContext.addConstraint(sc2); nonloginContext.setLoginConfig(lc); AuthenticatorBase nonloginAuthenticator = new NonLoginAuthenticator(); nonloginContext.getPipeline().addValve(nonloginAuthenticator);",
        "ins1DelCode":"Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, ctxt.setSessionTimeout(LONG_TIMEOUT_MINS); Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); ctxt.addConstraint(sc1); Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); ctxt.addConstraint(sc2); ctxt.setLoginConfig(lc); nonloginAuthenticator = new NonLoginAuthenticator(); ctxt.getPipeline().addValve(nonloginAuthenticator);",
        "ins1PreCode":"private void setUpNonLogin() throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_MINS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); nonloginAuthenticator = new NonLoginAuthenticator(); ctxt.getPipeline().addValve(nonloginAuthenticator);",
        "ins2PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception { Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS); Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1); Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint(); sc2.addCollection(collection2); ctxt.addConstraint(sc2); LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator()); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "label":0
    },
    {
        "ins1AddCode":"}, false, 2, ImmediateThinScheduler.INSTANCE)",
        "ins1DelCode":"}, 2, false, ImmediateThinScheduler.INSTANCE)",
        "ins1PreCode":"} }); } }, 2, false, ImmediateThinScheduler.INSTANCE) .test() .assertFailure(NullPointerException.class, 1, 2, 3);",
        "ins2PreCode":"} }); } throw new NullPointerException(\"test null exp\"); .test() .assertFailure(CompositeException.class, 1, 2, 3, 23, 32);",
        "label":0
    },
    {
        "ins1AddCode":"URL url = new URL(\"jar:\" + this.rootJarFile.toURI().toURL() + \"!/nested.jar!/3.dat\");",
        "ins1DelCode":"URL url = new URL(\"jar:file:\" + getAbsolutePath() + \"!/nested.jar!/3.dat\");",
        "ins1PreCode":"void connectionToEntryUsingAbsoluteUrlForEntryFromNestedJarFile() throws Exception { URL url = new URL(\"jar:file:\" + getAbsolutePath() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) {",
        "ins2PreCode":"void connectionToEntryUsingRelativeUrlForEntryFromNestedJarFile() throws Exception { URL url = new URL(\"jar:file:\" + getRelativePath() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) {",
        "label":0
    },
    {
        "ins1AddCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null ParallelFailureHandling\");",
        "ins1DelCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"ParallelFailureHandling h;  try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"ParallelFailureHandling h; try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = new FlowableDebounceTimed.DebounceEmitter<>(1, 1, null);",
        "ins1DelCode":"Disposable d = new FlowableDebounceTimed.DebounceEmitter<Integer>(1, 1, null);",
        "ins1PreCode":" TestHelper.checkDisposed(PublishProcessor.create().debounce(Functions.justFunction(Flowable.never())));  Disposable d = new FlowableDebounceTimed.DebounceEmitter<Integer>(1, 1, null); assertFalse(d.isDisposed()); ",
        "ins2PreCode":"TestHelper.checkDisposed(PublishSubject.create().debounce(Functions.justFunction(Observable.never()))); Disposable d = new ObservableDebounceTimed.DebounceEmitter<Integer>(1, 1, null); assertFalse(d.isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"protected void subscribeActual(@NonNull Subscriber<? super T> t) {",
        "ins1DelCode":"protected void subscribeActual(@NonNull Subscriber<@NonNull ? super T> t) {",
        "ins1PreCode":"protected void subscribeActual(@NonNull Subscriber<@NonNull ? super T> t) { PublishSubscription<T> ps = new PublishSubscription<>(t, this); t.onSubscribe(ps);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Observable.combineLatestArray(new ObservableSource[] {",
        "ins1DelCode":"Observable.combineLatest(new ObservableSource[] {",
        "ins1PreCode":"public void combineLatestArrayOfSources() {  Observable.combineLatest(new ObservableSource[] { Observable.just(1), Observable.just(2) }, new Function<Object[], Object>() {",
        "ins2PreCode":"public void combineLatestDelayErrorArrayOfSources() { Observable.combineLatestDelayError(new ObservableSource[] { Observable.just(1), Observable.just(2) }, new Function<Object[], Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"long start = System.currentTimeMillis(); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\");",
        "ins1DelCode":"while ( (System.currentTimeMillis()-start)<120000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK\");",
        "ins1PreCode":"for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<120000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins2PreCode":"for (int x=0; x<threads.length; x++ ) { threads[x].join();} long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "label":0
    },
    {
        "ins1AddCode":"void shouldLimitResultsUsingMapperClass() {",
        "ins1DelCode":"public void shouldLimitResultsUsingMapperClass() {",
        "ins1PreCode":"public void shouldLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class);",
        "ins2PreCode":"public void shouldOffsetAndLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) { BlogMapper mapper = session.getMapper(BlogMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(HistoryPageEntry.getEntryId(5), historyPageFilter.newestOnPage); Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);",
        "ins1DelCode":"Assert.assertEquals(5, historyPageFilter.newestOnPage); Assert.assertEquals(1, historyPageFilter.oldestOnPage);",
        "ins1PreCode":"Assert.assertEquals(false, historyPageFilter.hasDownPage); Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(5, historyPageFilter.newestOnPage); Assert.assertEquals(1, historyPageFilter.oldestOnPage);",
        "ins2PreCode":"Assert.assertEquals(false, historyPageFilter.hasUpPage); Assert.assertEquals(5, historyPageFilter.runs.size()); Assert.assertEquals(10, historyPageFilter.newestOnPage); Assert.assertEquals(6, historyPageFilter.oldestOnPage);",
        "label":1
    },
    {
        "ins1AddCode":"}, true, 16)",
        "ins1DelCode":"}, 16, true)",
        "ins1PreCode":"public ObservableSource<Integer> apply(Object v) throws Exception { return Observable.just(1); } }, 16, true) .test() .assertResult(1);",
        "ins2PreCode":"public ObservableSource<Integer> apply(Object v) throws Exception { return Observable.just(1); } }, 16) .test() .assertResult(1);",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaDoubleRDD rdd1 = uniformJavaRDD(jsc, m); JavaDoubleRDD rdd2 = uniformJavaRDD(jsc, m, p); JavaDoubleRDD rdd3 = uniformJavaRDD(jsc, m, p, seed); for (JavaDoubleRDD rdd : Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1DelCode":"JavaDoubleRDD rdd1 = uniformJavaRDD(sc, m); JavaDoubleRDD rdd2 = uniformJavaRDD(sc, m, p); JavaDoubleRDD rdd3 = uniformJavaRDD(sc, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1PreCode":"long m = 1000L; int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = uniformJavaRDD(sc, m); JavaDoubleRDD rdd2 = uniformJavaRDD(sc, m, p); JavaDoubleRDD rdd3 = uniformJavaRDD(sc, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); }",
        "ins2PreCode":"long m = 1000L; int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = normalJavaRDD(sc, m); JavaDoubleRDD rdd2 = normalJavaRDD(sc, m, p); JavaDoubleRDD rdd3 = normalJavaRDD(sc, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); }",
        "label":1
    },
    {
        "ins1AddCode":"XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"s1\"); XYIntervalSeries<String> s2 = CloneUtils.clone(s1);",
        "ins1DelCode":"XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); XYIntervalSeries s2 = CloneUtils.clone(s1);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"File pom = getProject( \"project-basic\" ); assertEquals( \"project-basic\", session.getCurrentProject().getArtifactId() ); assertEquals( \"0.1\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );",
        "ins1DelCode":"File pom = getProject( \"project-with-additional-lifecycle-elements\" ); assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );",
        "ins1PreCode":"{   File pom = getProject( \"project-with-additional-lifecycle-elements\" ); MavenSession session = createMavenSession( pom ); assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\" ).getExecutions(); assertEquals( 1, executionPlan.size() ); MojoExecution mojoExecution = executionPlan.get( 0 ); assertNotNull( mojoExecution ); assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() ); assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() ); assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );",
        "ins2PreCode":"{ File pom = getProject( \"project-with-additional-lifecycle-elements\" ); MavenSession session = createMavenSession( pom ); assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean:clean\" ).getExecutions(); assertEquals( 1, executionPlan.size() ); MojoExecution mojoExecution = executionPlan.get( 0 ); assertNotNull( mojoExecution ); assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() ); assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() ); assertEquals( \"2.3\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getVersion() );",
        "label":1
    },
    {
        "ins1AddCode":"assumeFalse(\"Symlinks don't work well on Windows\", Functions.isWindows());",
        "ins1DelCode":"",
        "ins1PreCode":"@Test public void reverseAfterNewBuilds() throws Exception { File root = dir; dir = new File(dir, \"jobs/someproject/modules/test$test/builds\"); write(\"1/build.xml\", \"<?xml version='1.0' encoding='UTF-8'?>\\n<run>\\n  <stuff>ok</stuff>\\n  <timestamp>1388649845000</timestamp>\\n  <otherstuff>ok</otherstuff>\\n</run>\");",
        "ins2PreCode":"@Test public void reverseMatrixAfterNewBuilds() throws Exception { File root = dir; dir = new File(dir, \"jobs/someproject/Environment=prod/builds\"); write(\"1/build.xml\", \"<?xml version='1.0' encoding='UTF-8'?>\\n<run>\\n  <stuff>ok</stuff>\\n  <timestamp>1388649845000</timestamp>\\n  <otherstuff>ok</otherstuff>\\n</run>\");",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldGetUsersByNameUsingMap() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getUsersByNameUsingMap(\"User\", \"id DESC\"); assertEquals(4, users.size()); assertEquals(\"User4\", users.get(0).getName()); assertEquals(\"User3\", users.get(1).getName()); assertEquals(\"User2\", users.get(2).getName()); assertEquals(\"User1\", users.get(3).getName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldGetUsersByNameWithParamNameAndOrderBy() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getUsersByNameWithParamNameAndOrderBy(\"User\", \"id DESC\"); assertEquals(4, users.size()); assertEquals(\"User4\", users.get(0).getName()); assertEquals(\"User3\", users.get(1).getName()); assertEquals(\"User2\", users.get(2).getName()); assertEquals(\"User1\", users.get(3).getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(c.setProperty(\"bindOnInit\", \"false\"));",
        "ins1DelCode":"c.setProperty(\"bindOnInit\", \"false\");",
        "ins1PreCode":"public void testStartStopBindOnStart() throws Exception { Tomcat tomcat = getTomcatInstance(); Connector c = tomcat.getConnector(); c.setProperty(\"bindOnInit\", \"false\");  File appDir = new File(getBuildDirectory(), \"webapps/examples\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1DelCode":"AUTH_HEADER.getHeader());",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertNull(credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD1, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"private void configureSslKeyStore(SslContextFactory.Server factory, Ssl ssl) {",
        "ins1DelCode":"private void configureSslKeyStore(SslContextFactory factory, Ssl ssl) {",
        "ins1PreCode":"private void configureSslKeyStore(SslContextFactory factory, Ssl ssl) { try { URL url = ResourceUtils.getURL(ssl.getKeyStore());",
        "ins2PreCode":"private void configureSslTrustStore(SslContextFactory factory, Ssl ssl) { try { URL url = ResourceUtils.getURL(ssl.getTrustStore());",
        "label":1
    },
    {
        "ins1AddCode":"ELSupport.equals(null, Long.valueOf(15), result));",
        "ins1DelCode":"ELSupport.equals(Long.valueOf(15), result));",
        "ins1PreCode":"Object.class);  Assert.assertTrue(\"Result: \" + result.toString(), ELSupport.equals(Long.valueOf(15), result));",
        "ins2PreCode":"Object.class); Assert.assertTrue(\"Result: \" + result.toString(), ELSupport.equals(Long.valueOf(0), result));",
        "label":1
    },
    {
        "ins1AddCode":"BibEntry entry = new BibEntry(StandardEntryType.Article); entry.setField(StandardField.AUTHOR, \"harrer\");",
        "ins1DelCode":"BibEntry entry = new BibEntry(); entry.setType(\"article\"); entry.setField(\"author\", \"harrer\");",
        "ins1PreCode":"public void testNoMatchesFromDatabaseWithArticleTypeEntry() { BibEntry entry = new BibEntry(); entry.setType(\"article\"); entry.setField(\"author\", \"harrer\"); database.insertEntry(entry); List<BibEntry> matches = new DatabaseSearcher(new SearchQuery(\"whatever\", true, true), database).getMatches();",
        "ins2PreCode":"public void testCorrectMatchFromDatabaseWithArticleTypeEntry() { BibEntry entry = new BibEntry(); entry.setType(\"article\"); entry.setField(\"author\", \"harrer\"); database.insertEntry(entry); List<BibEntry> matches = new DatabaseSearcher(new SearchQuery(\"harrer\", true, true), database).getMatches();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void raceForTerminalState() { final List<Integer> expected = Arrays.asList(1); for (int i = 0; i < 100000; i++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void raceForTerminalState() { final List<Integer> expected = Arrays.asList(1); for (int i = 0; i < 100000; i++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); Flowable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"o = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");",
        "ins1DelCode":"o = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\");",
        "ins1PreCode":"ObservableSource<? extends U> o;  try { o = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"ObservableSource<? extends U> o; try { o = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"}, true, 16, ImmediateThinScheduler.INSTANCE)",
        "ins1DelCode":"}, 16, true, ImmediateThinScheduler.INSTANCE)",
        "ins1PreCode":"public Flowable<Integer> apply(Object v) throws Exception { return Flowable.just(1); } }, 16, true, ImmediateThinScheduler.INSTANCE) .test() .assertResult(1);",
        "ins2PreCode":"public Flowable<Integer> apply(Object v) throws Exception { return Flowable.just(1); } }, 16, true) .test() .assertResult(1);",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(expected.getCause()).isInstanceOf(SomeCheckedException.class);",
        "ins1DelCode":"assertTrue(expected.getCause() instanceof SomeCheckedException);",
        "ins1PreCode":"sample.noneDeclared(); fail(); } catch (RuntimeException expected) { assertTrue(expected.getCause() instanceof SomeCheckedException); }",
        "ins2PreCode":"sample.oneDeclared(); fail(); } catch (SomeCheckedException expected) { Throwables.propagateIfInstanceOf(t, SomeCheckedException.class); }",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty());  observer.onNext(odds);",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super Flowable<String>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(odds);",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (theItems.isEmpty()) { return; }",
        "ins1PreCode":"protected void fireToDoItemsAdded(List<ToDoItem> theItems) { if (theItems.isEmpty()) { return; } ",
        "ins2PreCode":"protected void fireToDoItemsRemoved(List<ToDoItem> theItems) { if (theItems.isEmpty()) { return; }",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/test\", \"test\"); ctx.addServletMappingDecoded(\"/error\", \"errorPage\");",
        "ins1DelCode":"ctx.addServletMapping(\"/test\", \"test\"); ctx.addServletMapping(\"/error\", \"errorPage\");",
        "ins1PreCode":"  Tomcat.addServlet(ctx, \"test\", new Bug51653ErrorTrigger()); ctx.addServletMapping(\"/test\", \"test\");   Tomcat.addServlet(ctx, \"errorPage\", new Bug51653ErrorPage(trace)); ctx.addServletMapping(\"/error\", \"errorPage\");  ErrorPage errorPage = new ErrorPage();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertMessageEquals( message, parser.parseFrom(message.toByteString().asReadOnlyByteBuffer(), registry));",
        "ins1DelCode":"",
        "ins1PreCode":"new ByteArrayInputStream(data), registry)); assertMessageEquals(message, parser.parseFrom( CodedInputStream.newInstance(data), registry));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('a', 'b'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('a');  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('a'); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd'); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd');",
        "label":1
    },
    {
        "ins1AddCode":"void parseCombinesMultipleEditorFields() throws IOException {",
        "ins1DelCode":"public void parseCombinesMultipleEditorFields() throws IOException {",
        "ins1PreCode":"public void parseCombinesMultipleEditorFields() throws IOException { ParserResult result = parser.parse( new StringReader(\"@article{test,editor={Ed von Test},editor={Second Author},editor={Third Author}}\"));",
        "ins2PreCode":"public void parseCombinesMultipleKeywordsFields() throws IOException { ParserResult result = parser.parse( new StringReader(\"@article{test,Keywords={Test},Keywords={Second Keyword},Keywords={Third Keyword}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"getBufHandler().configureWriteBufferForRead();",
        "ins1DelCode":"getBufHandler().configureWriteBufferForWrite();",
        "ins1PreCode":" netOutBuffer.clear();  getBufHandler().configureWriteBufferForWrite(); SSLEngineResult result = sslEngine.wrap(getBufHandler().getWriteBuffer(), netOutBuffer); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0));",
        "ins1DelCode":"pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0));",
        "ins1PreCode":"public void testFailureAfterMultipleDataBlocks() throws IOException { StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); assertEquals(\"num-chunks\", 0, blockMeta.getNumChunks());",
        "ins2PreCode":"public void testFailureAfterComplete() throws IOException { StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[]{9}, new int[][]{{0}});",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"editor\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), e.getField(\"editor\"));",
        "ins1PreCode":"ParserResult result = parser.parse( new StringReader(\"@article{test,editor={Ed von Test},editor={Second Author},editor={Third Author}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), e.getField(\"editor\"));",
        "ins2PreCode":"ParserResult result = parser.parse( new StringReader(\"@article{test,Keywords={Test},Keywords={Second Keyword},Keywords={Third Keyword}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Test, Second Keyword, Third Keyword\"), e.getField(\"keywords\"));",
        "label":1
    },
    {
        "ins1AddCode":"private static String readLhex(StringReader input) throws IOException { boolean quoted = false; if (c == '\"') { quoted = true; } else if (c == -1 || !isHex(c)) { return null; } else { result.append((char) c); } c = input.read(); if (quoted) { if (c != '\"') { return null; } } else { input.skip(-1); } if (c != -1 && result.length() == 0) {",
        "ins1DelCode":"private static String readLhex(StringReader input) throws IOException { input.skip(-1); if (result.length() == 0) {",
        "ins1PreCode":"private static String readLhex(StringReader input) throws IOException { StringBuilder result = new StringBuilder();  int c = input.read();   while (c == 32 || c == 9) { c = input.read(); }  while (c != -1 && isHex(c)) { result.append((char) c); c = input.read(); }  input.skip(-1);  if (result.length() == 0) { return null; } else {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final UnicastProcessor<Integer> up = UnicastProcessor.create(); TestObserver<Integer> to = up for (int i = 0; up.hasSubscribers(); i++) { up.onNext(i);",
        "ins1DelCode":"final UnicastProcessor<Integer> us = UnicastProcessor.create(); TestObserver<Integer> to = us for (int i = 0; us.hasSubscribers(); i++) { us.onNext(i);",
        "ins1PreCode":"for (int j = 0; j < TestHelper.RACE_LONG_LOOPS; j++) { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final UnicastProcessor<Integer> us = UnicastProcessor.create();  TestObserver<Integer> to = us .observeOn(Schedulers.io()) .map(Functions.<Integer>identity()) .observeOn(Schedulers.single()) .firstOrError() .test();  for (int i = 0; us.hasSubscribers(); i++) { us.onNext(i); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @NotNull OWNER owner, @NotNull OBJECT oldObject) OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null);",
        "ins1DelCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @Nullable OWNER owner, @NotNull OBJECT oldObject) OBJECT newObject = this.reloadObject(monitor, owner, oldObject);",
        "ins1PreCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @Nullable OWNER owner, @NotNull OBJECT oldObject) throws DBException { String objectName = oldObject.getName(); if (!isFullyCached()) { this.loadObjects(monitor, owner); } else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject); removeObject(oldObject); if (newObject != null) {",
        "ins2PreCode":"public OBJECT refreshObject(@NotNull DBRProgressMonitor monitor, @Nullable OWNER owner, @NotNull OBJECT oldObject) throws DBException { String objectName = oldObject.getName(); if (!isFullyCached()) { this.loadObjects(monitor, owner); } else { OBJECT newObject = this.reloadObject(monitor, owner, oldObject); removeObject(oldObject); if (newObject != null) {",
        "label":1
    },
    {
        "ins1AddCode":"gitHandler = mock(SlrGitHandler.class, Answers.RETURNS_DEFAULTS);",
        "ins1DelCode":"gitHandler = mock(GitHandler.class, Answers.RETURNS_DEFAULTS);",
        "ins1PreCode":"when(importFormatPreferences.isKeywordSyncEnabled()).thenReturn(false); when(importFormatPreferences.getEncoding()).thenReturn(StandardCharsets.UTF_8); entryTypesManager = new BibEntryTypesManager(); gitHandler = mock(GitHandler.class, Answers.RETURNS_DEFAULTS);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void getLoggingConfigurations() {",
        "ins1DelCode":"public void getLoggingConfigurations() throws Exception {",
        "ins1PreCode":"public void getLoggingConfigurations() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null);",
        "ins2PreCode":"public void getLoggingConfigurations() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null);",
        "label":1
    },
    {
        "ins1AddCode":"ZipFileSet f = (ZipFileSet) getInstance(); assertEquals(\"Cannot set both dir and src attributes\", be.getMessage()); f = (ZipFileSet) getInstance(); assertEquals(\"Cannot set both dir and src attributes\", be.getMessage()); f = (ZipFileSet) getInstance(); f = (ZipFileSet) getInstance(); f = (ZipFileSet) getInstance(); f = (ZipFileSet) getInstance(); ZipFileSet zid = (ZipFileSet) getInstance(); assertTrue(\"src attribute copied by copy constructor\", zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\", f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertEquals(\"file mode attribute copied by copy constructor\", f.getFileMode(getProject()), zid.getFileMode(getProject())); assertEquals(\"dir mode attribute copied by copy constructor\", f.getDirMode(getProject()), zid.getDirMode(getProject()));",
        "ins1DelCode":"ZipFileSet f = (ZipFileSet)getInstance(); assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); f = (ZipFileSet)getInstance(); assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); f = (ZipFileSet)getInstance(); f = (ZipFileSet)getInstance(); f = (ZipFileSet)getInstance(); f = (ZipFileSet)getInstance(); ZipFileSet zid=(ZipFileSet)getInstance(); assertTrue(\"src attribute copied by copy constructor\",zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\",f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertTrue(\"file mode attribute copied by copy constructor\",f.getFileMode(getProject())==zid.getFileMode(getProject())); assertTrue(\"dir mode attribute copied by copy constructor\",f.getDirMode(getProject())==zid.getDirMode(getProject()));",
        "ins1PreCode":"public final void testAttributes() { ZipFileSet f = (ZipFileSet)getInstance();  f.setSrc(new File(\"example.zip\")); try { f.setDir(new File(\"examples\")); fail(\"can add dir to \" + f.getDataTypeName() + \" when a src is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); } f = (ZipFileSet)getInstance();  f.setDir(new File(\"examples\")); try { f.setSrc(new File(\"example.zip\")); fail(\"can add src to \" + f.getDataTypeName() + \" when a dir is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); }  f = (ZipFileSet)getInstance(); f.setSrc(new File(\"example.zip\")); f.setPrefix(\"/examples\"); try { f.setFullpath(\"/doc/manual/index.html\"); fail(\"Can add fullpath to \" + f.getDataTypeName() + \" when a prefix is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); } f = (ZipFileSet)getInstance(); f.setSrc(new File(\"example.zip\")); f.setFullpath(\"/doc/manual/index.html\"); try { f.setPrefix(\"/examples\"); fail(\"Can add prefix to \" + f.getDataTypeName() + \" when a fullpath is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); }  f = (ZipFileSet)getInstance(); f.setRefid(new Reference(getProject(), \"test\")); try { f.setSrc(new File(\"example.zip\")); fail(\"Can add src to \" + f.getDataTypeName() + \" when a refid is already present\"); } catch (BuildException be) { assertEquals(\"You must not specify more than one \" + \"attribute when using refid\", be.getMessage()); }  f = (ZipFileSet)getInstance(); f.setSrc(new File(\"example.zip\")); f.setPrefix(\"/examples\"); f.setFileMode(\"600\"); f.setDirMode(\"530\"); getProject().addReference(\"test\",f); ZipFileSet zid=(ZipFileSet)getInstance(); zid.setRefid(new Reference(getProject(), \"test\")); assertTrue(\"src attribute copied by copy constructor\",zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\",f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertTrue(\"file mode attribute copied by copy constructor\",f.getFileMode(getProject())==zid.getFileMode(getProject())); assertTrue(\"dir mode attribute copied by copy constructor\",f.getDirMode(getProject())==zid.getDirMode(getProject()));",
        "ins2PreCode":"public final void testAttributes() { TarFileSet f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); try { f.setDir(new File(\"examples\")); fail(\"can add dir to \" + f.getDataTypeName() + \" when a src is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); } f = (TarFileSet)getInstance(); f.setDir(new File(\"examples\")); try { f.setSrc(new File(\"example.tar\")); fail(\"can add src to \" + f.getDataTypeName() + \" when a dir is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both dir and src attributes\",be.getMessage()); } f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); f.setPrefix(\"/examples\"); try { f.setFullpath(\"/doc/manual/index.html\"); fail(\"Can add fullpath to \" + f.getDataTypeName() + \" when a prefix is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); } f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); f.setFullpath(\"/doc/manual/index.html\"); try { f.setPrefix(\"/examples\"); fail(\"Can add prefix to \" + f.getDataTypeName() + \" when a fullpath is already present\"); } catch (BuildException be) { assertEquals(\"Cannot set both fullpath and prefix attributes\", be.getMessage()); } f = (TarFileSet)getInstance(); f.setRefid(new Reference(getProject(), \"test\")); try { f.setSrc(new File(\"example.tar\")); fail(\"Can add src to \" + f.getDataTypeName() + \" when a refid is already present\"); } catch (BuildException be) { assertEquals(\"You must not specify more than one \" + \"attribute when using refid\", be.getMessage()); } f = (TarFileSet)getInstance(); f.setSrc(new File(\"example.tar\")); f.setPrefix(\"/examples\"); f.setFileMode(\"600\"); f.setDirMode(\"530\"); getProject().addReference(\"test\",f); TarFileSet zid=(TarFileSet)getInstance(); zid.setRefid(new Reference(getProject(), \"test\")); assertTrue(\"src attribute copied by copy constructor\",zid.getSrc(getProject()).equals(f.getSrc(getProject()))); assertTrue(\"prefix attribute copied by copy constructor\",f.getPrefix(getProject()).equals(zid.getPrefix(getProject()))); assertTrue(\"file mode attribute copied by copy constructor\",f.getFileMode(getProject())==zid.getFileMode(getProject())); assertTrue(\"dir mode attribute copied by copy constructor\",f.getDirMode(getProject())==zid.getDirMode(getProject()));",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(exception.getMessage(), containsString(\"[dcg] unknown field\"));",
        "ins1DelCode":"assertThat(exception.getMessage(), containsString(\"[dcg_at] unknown field\"));",
        "ins1PreCode":"parser.nextToken(); XContentParseException exception = expectThrows(XContentParseException.class, () -> DiscountedCumulativeGain.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[dcg_at] unknown field\")); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertFalse(\"Subject still has observers!\", ps.hasObservers());",
        "ins1DelCode":"assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins1PreCode":".assertNoErrors() .assertComplete();  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());  inner.get().test().assertResult(1);",
        "ins2PreCode":".assertNoErrors() .assertComplete(); assertFalse(\"Subject still has subscribers!\", ps.hasObservers()); inner.get().test().assertResult(1);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(3, message.getInt32ToInt32FieldMap().size()); assertEquals(111, message.getInt32ToInt32FieldMap().get(1).intValue()); assertEquals(33, message.getInt32ToInt32FieldMap().get(3).intValue()); assertEquals(44, message.getInt32ToInt32FieldMap().get(4).intValue()); assertEquals(3, message.getInt32ToStringFieldMap().size()); assertEquals(\"111\", message.getInt32ToStringFieldMap().get(1)); assertEquals(\"33\", message.getInt32ToStringFieldMap().get(3)); assertEquals(\"44\", message.getInt32ToStringFieldMap().get(4)); assertEquals(3, message.getInt32ToBytesFieldMap().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesFieldMap().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesFieldMap().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesFieldMap().get(4)); assertEquals(3, message.getInt32ToEnumFieldMap().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumFieldMap().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumFieldMap().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumFieldMap().get(4)); assertEquals(3, message.getInt32ToMessageFieldMap().size()); assertEquals(111, message.getInt32ToMessageFieldMap().get(1).getValue()); assertEquals(33, message.getInt32ToMessageFieldMap().get(3).getValue()); assertEquals(44, message.getInt32ToMessageFieldMap().get(4).getValue()); assertEquals(3, message.getStringToInt32FieldMap().size()); assertEquals(111, message.getStringToInt32FieldMap().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32FieldMap().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32FieldMap().get(\"4\").intValue());",
        "ins1DelCode":"assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(111, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(4).intValue()); assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"111\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"44\", message.getInt32ToStringField().get(4)); assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesField().get(4)); assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumField().get(4)); assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(111, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(44, message.getInt32ToMessageField().get(4).getValue()); assertEquals(3, message.getStringToInt32Field().size()); assertEquals(111, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32Field().get(\"4\").intValue());",
        "ins1PreCode":"private void assertMapValuesUpdated(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(111, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(4).intValue());  assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"111\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"44\", message.getInt32ToStringField().get(4));  assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesField().get(4));  assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumField().get(4));  assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(111, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(44, message.getInt32ToMessageField().get(4).getValue());  assertEquals(3, message.getStringToInt32Field().size()); assertEquals(111, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32Field().get(\"4\").intValue());",
        "ins2PreCode":"private void assertMapValuesSet(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(11, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(11, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"11\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"11\", message.getInt32ToStringField().get(1)); assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesField().get(1)); assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(2)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumField().get(1)); assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(11, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(11, message.getInt32ToMessageField().get(1).getValue()); assertEquals(3, message.getStringToInt32Field().size()); assertEquals(11, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(11, message.getStringToInt32Field().get(\"1\").intValue());",
        "label":1
    },
    {
        "ins1AddCode":"void inMemoryHsqlIsShutdown() throws Exception {",
        "ins1DelCode":"public void inMemoryHsqlIsShutdown() throws Exception {",
        "ins1PreCode":"public void inMemoryHsqlIsShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));",
        "ins2PreCode":"public void derbyClientIsNotShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext(\"org.apache.derby.jdbc.ClientDriver\", \"jdbc:derby://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));",
        "label":1
    },
    {
        "ins1AddCode":"oi.subscribe(new TestObserverEx<>(mockSubscriber));",
        "ins1DelCode":"oi.subscribe(new TestObserverEx<Integer>(mockSubscriber));",
        "ins1PreCode":"public void wrappingMockWhenUnsubscribeInvolved() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Observer<Integer> mockSubscriber = TestHelper.mockObserver(); oi.subscribe(new TestObserverEx<Integer>(mockSubscriber));  InOrder inOrder = inOrder(mockSubscriber);",
        "ins2PreCode":"public void wrappingMock() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber(); oi.subscribe(new TestSubscriber<Integer>(mockSubscriber)); InOrder inOrder = inOrder(mockSubscriber);",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, Object> options = new LinkedHashMap<>(command.getOptions()); DBUtils.fireObjectUpdate(command.getObject(), options, DBPEvent.RENAME);",
        "ins1DelCode":"DBUtils.fireObjectUpdate(command.getObject());",
        "ins1PreCode":"cache.renameObject(command.getObject(), command.getNewName(), command.getOldName()); }  DBUtils.fireObjectUpdate(command.getObject()); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals( \"@Comment{jabref-meta: databaseType:bibtex;}\" OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"}\" + OS.NEWLINE, OS.NEWLINE, stringWriter.toString()); stringWriter.toString());",
        "ins1DelCode":"assertEquals(OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE, stringWriter.toString());",
        "ins1PreCode":" databaseWriter.savePartOfDatabase(bibtexContext, Collections.singletonList(entry));  assertEquals(OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE, stringWriter.toString());",
        "ins2PreCode":"databaseWriter.savePartOfDatabase(bibtexContext, Collections.singletonList(entry)); assertEquals(\"% Encoding: US-ASCII\" + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"}\" + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE, stringWriter.toString());",
        "label":1
    },
    {
        "ins1AddCode":"void roundtripWithUserCommentAndEntryChange() throws Exception { when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString());",
        "ins1DelCode":"public void roundtripWithUserCommentAndEntryChange() throws Exception { SavePreferences preferences = new SavePreferences().withEncoding(encoding).withSaveInOriginalOrder(true); StringSaveSession session = databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries(), preferences); try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"),encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), session.getStringValue());",
        "ins1PreCode":"public void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(\"author\", \"Mr. Author\");  SavePreferences preferences = new SavePreferences().withEncoding(encoding).withSaveInOriginalOrder(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  StringSaveSession session = databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries(), preferences);  try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"),encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), session.getStringValue()); }",
        "ins2PreCode":"public void roundtripWithUnknownMetaData() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/unknownMetaData.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding)); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), try (Scanner scanner = new Scanner(testBibtexFile,encoding.name())) { SavePreferences preferences = new SavePreferences().withEncoding(encoding).withSaveInOriginalOrder(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); StringSaveSession session = databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries(), preferences); try (Scanner scanner = new Scanner(testBibtexFile,encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), session.getStringValue()); }",
        "label":1
    },
    {
        "ins1AddCode":"if (showProperties == showem) { return; }",
        "ins1DelCode":"if (showProperties == showem) return;",
        "ins1PreCode":"public void setShowProperties(final boolean showem) { if (showProperties == showem) return;  Memento memento = new Memento() {",
        "ins2PreCode":"public void setShowTypes(final boolean showem) { if (showTypes == showem) return; Memento memento = new Memento() {",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fusedOnErrorCrash() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  final int[] call = { 0 };",
        "ins2PreCode":"public void fusedOnErrorCrashConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); final int[] call = { 0 };",
        "label":1
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable bs = Disposable.empty();",
        "ins1DelCode":"final Disposable bs = Disposables.empty();",
        "ins1PreCode":"public void onSubscribeCrash() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable bs = Disposables.empty();  new Completable() {",
        "ins2PreCode":"public void onSubscribeCrash() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable bs = Disposables.empty(); observer.onComplete();",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 52; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"XIntervalSeries<String> s1 = new XIntervalSeries<>(\"S1\");",
        "ins1DelCode":"XIntervalSeries s1 = new XIntervalSeries(\"S1\");",
        "ins1PreCode":"public void testGetXLowValue() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); s1.add(1.0, 2.0, 3.0, 4.0); assertEquals(2.0, s1.getXLowValue(0), EPSILON);",
        "ins2PreCode":"public void testGetXHighValue() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); s1.add(1.0, 2.0, 3.0, 4.0); assertEquals(3.0, s1.getXHighValue(0), EPSILON);",
        "label":1
    },
    {
        "ins1AddCode":"&& (o == null || \"\".equals(o)))) { if (isClearable && !elements.contains(null)) { addElement(null);",
        "ins1DelCode":"&& (\"\".equals(o) || CLEARED.equals(o)))) { if (isClearable && !elements.contains(CLEARED)) { addElement(CLEARED);",
        "ins1PreCode":"   && (\"\".equals(o) || CLEARED.equals(o)))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements);  if (isClearable && !elements.contains(CLEARED)) { addElement(CLEARED); } if (!objects.contains(selectedObject)) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>>[] customizers = new TomcatProtocolHandlerCustomizer[4];",
        "ins1DelCode":"TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4];",
        "ins1PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatServletWebServerFactory factory = getFactory(); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); factory.setTomcatProtocolHandlerCustomizers(",
        "ins2PreCode":"public void builderCustomizers() { UndertowServletWebServerFactory factory = getFactory(); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class)); public void builderCustomizers() {",
        "label":0
    },
    {
        "ins1AddCode":".appName(\"Java Spark SQL data sources example\") runJdbcDatasetExample(spark);",
        "ins1DelCode":".appName(\"Java Spark SQL Data Sources Example\")",
        "ins1PreCode":"public static void main(String[] args) { SparkSession spark = SparkSession .builder() .appName(\"Java Spark SQL Data Sources Example\") .config(\"spark.some.config.option\", \"some-value\") .getOrCreate();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":" ParserResult result = parser .parse(new StringReader(\"comment{some text and \\\\latex\" + \"@article{test,author={Ed von Test}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test}}\" + \"comment{some text and \\\\latex\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<List<List<Integer>>> sequences = jsc.parallelize(Arrays.asList( model.save(spark.sparkContext(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(spark.sparkContext(), outputPath); for (PrefixSpan.FreqSequence<Integer> freqSeq : localFreqSeqs) {",
        "ins1DelCode":"JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( model.save(sc.sc(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(sc.sc(), outputPath); for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) {",
        "ins1PreCode":"public void runPrefixSpanSaveLoad() { JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences);  File tempDir = Utils.createTempDir( System.getProperty(\"java.io.tmpdir\"), \"JavaPrefixSpanSuite\"); String outputPath = tempDir.getPath();  try { model.save(sc.sc(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(sc.sc(), outputPath); JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size());  for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence(); long freq = freqSeq.freq();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void shouldTrimNoWhereClause() throws Exception {",
        "ins1DelCode":"public void shouldTrimNoWhereClause() throws Exception {",
        "ins1PreCode":"public void shouldTrimNoWhereClause() throws Exception { final String expected = \"SELECT * FROM BLOG\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimSETInsteadOfCOMMAForBothConditions() throws Exception { final String expected = \"UPDATE BLOG SET ID = ?,  NAME = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"throw new RuntimeException( \"descriptor.proto has a new declared type but Descriptors.java \" \"descriptor.proto has a new declared type but Descriptors.java wasn't updated.\"); \"wasn't updated.\");",
        "ins1DelCode":"throw new RuntimeException(\"\" + \"descriptor.proto has a new declared type but Descriptors.java \" + \"wasn't updated.\");",
        "ins1PreCode":"throw new RuntimeException(\"\" + \"descriptor.proto has a new declared type but Descriptors.java \" + \"wasn't updated.\"); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); Dataset<Row> scaledData = scalerModel.transform(dataFrame);",
        "ins1DelCode":"DataFrame dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); DataFrame scaledData = scalerModel.transform(dataFrame);",
        "ins1PreCode":"SQLContext jsql = new SQLContext(jsc);   DataFrame dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   DataFrame scaledData = scalerModel.transform(dataFrame); scaledData.show(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"mn.onSubscribe(Disposable.empty());",
        "ins1DelCode":"mn.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Functions.justFunction(Observable.just(2)), Functions.justSupplier(Observable.just(3)) ); mn.onSubscribe(Disposables.empty()); } });",
        "ins2PreCode":"Functions.justFunction(Flowable.just(2)), Functions.justSupplier(Flowable.just(3)) ); mn.onSubscribe(new BooleanSubscription()); } });",
        "label":0
    },
    {
        "ins1AddCode":"assertThat( projects, hasItem( pluginProject ) ); assertThat( projects, hasItem( pluginLevelDepProject ) );",
        "ins1DelCode":"assertTrue( projects.contains( pluginProject ) ); assertTrue( projects.contains( pluginLevelDepProject ) );",
        "ins1PreCode":"assertEquals( parentProject, projects.get( 0 ) );   assertTrue( projects.contains( pluginProject ) ); assertTrue( projects.contains( pluginLevelDepProject ) );  ",
        "ins2PreCode":"assertEquals( parentProject, projects.get( 0 ) ); assertTrue( projects.contains( pluginProject ) ); assertTrue( projects.contains( pluginLevelDepProject ) );",
        "label":1
    },
    {
        "ins1AddCode":".replace(PATTERN_ITEM_CONSTRAINT, DBUtils.getQuotedIdentifier(command.getObject())))",
        "ins1DelCode":".replace(PATTERN_ITEM_CONSTRAINT, command.getObject().getName()))",
        "ins1PreCode":"ModelMessages.model_jdbc_drop_constraint, getDropConstraintPattern(command.getObject()) .replace(PATTERN_ITEM_TABLE, command.getObject().getTable().getFullyQualifiedName(DBPEvaluationContext.DDL)) .replace(PATTERN_ITEM_CONSTRAINT, command.getObject().getName())) );",
        "ins2PreCode":"ModelMessages.model_jdbc_drop_foreign_key, getDropForeignKeyPattern(command.getObject()) .replace(PATTERN_ITEM_TABLE, command.getObject().getTable().getFullyQualifiedName(DBPEvaluationContext.DDL)) .replace(PATTERN_ITEM_CONSTRAINT, command.getObject().getName())) );",
        "label":1
    },
    {
        "ins1AddCode":"final ArrayList<List<Integer>> lists = new ArrayList<>();",
        "ins1DelCode":"final ArrayList<List<Integer>> lists = new ArrayList<List<Integer>>();",
        "ins1PreCode":"public void window() { final ArrayList<List<Integer>> lists = new ArrayList<List<Integer>>();  Observable.concat(",
        "ins2PreCode":"public void window() { final ArrayList<List<Integer>> lists = new ArrayList<List<Integer>>(); Flowable.concat(",
        "label":1
    },
    {
        "ins1AddCode":"public void yamlProfiles() {",
        "ins1DelCode":"public void yamlProfiles() throws Exception {",
        "ins1PreCode":"public void yamlProfiles() throws Exception { this.initializer.setSearchNames(\"testprofiles\"); this.environment.setActiveProfiles(\"dev\");",
        "ins2PreCode":"public void yamlTwoProfiles() throws Exception { this.initializer.setSearchNames(\"testprofiles\"); this.environment.setActiveProfiles(\"other\", \"dev\");",
        "label":1
    },
    {
        "ins1AddCode":"if ( entry != null && entry.isPrimary() ) { set.add(new MapEntry(key, entry.getValue())); }",
        "ins1DelCode":"if ( entry != null && entry.isPrimary() ) set.add(entry.getValue());",
        "ins1PreCode":"Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry != null && entry.isPrimary() ) set.add(entry.getValue()); } return Collections.unmodifiableSet(set);",
        "ins2PreCode":"Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isPrimary() ) set.add(key); } return Collections.unmodifiableSet(set);",
        "label":0
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"testValue\");",
        "ins1DelCode":"entry.setField(\"field\", \"testValue\");",
        "ins1PreCode":"public void completeBeginnigOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testValue\"); autoCompleter.indexEntry(entry); ",
        "ins2PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testValue\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner .withConfiguration( AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping( context); Object interceptorSecurityService = ReflectionTestUtils .getField(interceptor, \"cloudFoundrySecurityService\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange() .block();",
        "ins1DelCode":"this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block();",
        "ins1PreCode":"public void skipSslValidation() { this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\", \"management.cloudfoundry.skip-ssl-validation:true\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block(); });",
        "ins2PreCode":"public void sslValidationNotSkippedByDefault() { this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") \"cloudFoundrySecurityService\"); .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block(); });",
        "label":1
    },
    {
        "ins1AddCode":"List<Flowable<Integer>> sources = new ArrayList<>(); List<Object> values = new ArrayList<>();",
        "ins1DelCode":"List<Flowable<Integer>> sources = new ArrayList<Flowable<Integer>>(); List<Object> values = new ArrayList<Object>();",
        "ins1PreCode":"}; for (int i = 1; i <= n; i++) { System.out.println(\"test1ToNSources: \" + i + \" sources\"); List<Flowable<Integer>> sources = new ArrayList<Flowable<Integer>>(); List<Object> values = new ArrayList<Object>(); for (int j = 0; j < i; j++) { sources.add(Flowable.just(j));",
        "ins2PreCode":"}; for (int i = 1; i <= n; i++) { System.out.println(\"test1ToNSources: \" + i + \" sources\"); List<Observable<Integer>> sources = new ArrayList<Observable<Integer>>(); List<Object> values = new ArrayList<Object>(); for (int j = 0; j < i; j++) { sources.add(Observable.just(j));",
        "label":1
    },
    {
        "ins1AddCode":"when(filePreferences.getFileDirectoryPattern()).thenReturn(\"\");",
        "ins1DelCode":"when(filePreferences.getFileDirPattern()).thenReturn(\"\");",
        "ins1PreCode":"entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), fileField, new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileDirPattern()).thenReturn(\"\"); cleanup.cleanup(entry); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"List<String> list1 = new ArrayList<>();",
        "ins1DelCode":"List list1 = new java.util.ArrayList();",
        "ins1PreCode":"assertEquals(1, g1.getListCount()); assertEquals(0, g1.getURLCount(0));  List list1 = new java.util.ArrayList(); list1.add(\"URL1\"); g1.addURLSeries(list1);",
        "ins2PreCode":"assertEquals(1, g1.getListCount()); assertEquals(0, g1.getURLCount(0)); List list1 = new java.util.ArrayList(); list1.add(\"URL1\"); g1.addURLSeries(list1);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(numCorrect, rdd.count());",
        "ins1DelCode":"Assert.assertTrue(numCorrect == rdd.count());",
        "ins1PreCode":"DecisionTreeModel model = learner.run(rdd.rdd());  int numCorrect = validatePrediction(arr, model); Assert.assertTrue(numCorrect == rdd.count());",
        "ins2PreCode":"DecisionTreeModel model = DecisionTree$.MODULE$.train(rdd.rdd(), strategy); int numCorrect = validatePrediction(arr, model); Assert.assertTrue(numCorrect == rdd.count());",
        "label":0
    },
    {
        "ins1AddCode":"\"SELECT p.*,c.comment FROM v_catalog.projections p\\n\" + \"LEFT OUTER JOIN v_catalog.comments c ON c.object_type = 'PROJECTION' AND c.object_schema = p.projection_schema AND c.object_name = p.projection_name\\n\" + \"WHERE p.projection_schema=?\" +",
        "ins1DelCode":"\"SELECT * FROM v_catalog.projections WHERE projection_schema=?\" +",
        "ins1PreCode":"public JDBCStatement prepareLookupStatement(@NotNull JDBCSession session, @NotNull VerticaSchema schema, @Nullable VerticaProjection object, @Nullable String objectName) throws SQLException { final JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT * FROM v_catalog.projections WHERE projection_schema=?\" + (object == null && objectName == null ? \"\" : \" AND projection_name=?\") );",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"UnicastSubject<Integer> us = UnicastSubject.create(); us TestHelper.emit(us, 1, 2, 3, 4, 5);",
        "ins1DelCode":"UnicastSubject<Integer> up = UnicastSubject.create(); up TestHelper.emit(up, 1, 2, 3, 4, 5);",
        "ins1PreCode":" final int[] call = { 0, 0 };  UnicastSubject<Integer> up = UnicastSubject.create();  up .doOnNext(new Consumer<Integer>() { @Override public void accept(Integer v) throws Exception { call[0]++; } }) .doOnComplete(new Action() { @Override public void run() throws Exception { call[1]++; } }) .filter(Functions.alwaysTrue()) .subscribe(to);  TestHelper.emit(up, 1, 2, 3, 4, 5);  to.assertFuseable()",
        "ins2PreCode":"final int[] call = { 0, 0 }; UnicastSubject<Integer> up = UnicastSubject.create(); up.hide() .doOnNext(new Consumer<Integer>() { @Override public void accept(Integer v) throws Exception { call[0]++; } }) .doOnComplete(new Action() { @Override public void run() throws Exception { call[1]++; } }) .filter(Functions.alwaysTrue()) .subscribe(to); TestHelper.emit(up, 1, 2, 3, 4, 5); to.assertFuseable()",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(sources, \"sources is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T> Flowable<T> concatArray(MaybeSource<? extends T>... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return Flowable.empty();",
        "ins2PreCode":"public static <T> Flowable<T> mergeArray(MaybeSource<? extends T>... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return Flowable.empty();",
        "label":1
    },
    {
        "ins1AddCode":"return new HashMap<>();",
        "ins1DelCode":"return new HashMap<Integer, Collection<Integer>>();",
        "ins1PreCode":"}, new Supplier<Map<Integer, Collection<Integer>>>() { @Override public Map<Integer, Collection<Integer>> get() { return new HashMap<Integer, Collection<Integer>>(); } }, new Function<Integer, Collection<Integer>>() {",
        "ins2PreCode":"}, new Supplier<Map<Integer, Collection<Integer>>>() { @Override public Map<Integer, Collection<Integer>> get() { return new HashMap<Integer, Collection<Integer>>(); } }, new Function<Integer, Collection<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ALWAYS); this.request.addParameter(\"message\", \"false\");",
        "ins1DelCode":"this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ALWAYS); this.request.addParameter(\"details\", \"false\");",
        "ins1PreCode":"void errorResponseAlwaysDetails() { this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ALWAYS); this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ALWAYS); this.request.addParameter(\"trace\", \"false\"); this.request.addParameter(\"details\", \"false\"); ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties); Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));",
        "ins2PreCode":"void errorResponseParamsTrue() { this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM); this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ON_DETAILS_PARAM); this.request.addParameter(\"trace\", \"true\"); this.request.addParameter(\"details\", \"true\"); ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties); Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));",
        "label":0
    },
    {
        "ins1AddCode":"RMApp app = MockRMAppSubmitter.submitWithMemory(1024, rm);",
        "ins1DelCode":"RMApp app = rm.submitApp(1024);",
        "ins1PreCode":"rm.start();   RMApp app = rm.submitApp(1024); rm.drainEvents(); ",
        "ins2PreCode":"rm.start(); RMApp app = rm.submitApp(1024); rm.drainEvents();",
        "label":1
    },
    {
        "ins1AddCode":"List<Person> personList = new ArrayList<>(2); new Function<Person, Row>() { @Override public Row call(Person person) { return RowFactory.create(person.getName(), person.getAge()); } }); List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"\", DataTypes.StringType, false)); @Override return row.getString(0) + \"_\" + row.get(1); List<String> expected = new ArrayList<>(2);",
        "ins1DelCode":"List<Person> personList = new ArrayList<Person>(2); new Function<Person, Row>() { public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } }); List<StructField> fields = new ArrayList<StructField>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); return row.getString(0) + \"_\" + row.get(1).toString(); List<String> expected = new ArrayList<String>(2);",
        "ins1PreCode":"public void dataFrameRDDOperations() { List<Person> personList = new ArrayList<Person>(2); Person person1 = new Person(); person1.setName(\"Michael\"); person1.setAge(29); personList.add(person1); Person person2 = new Person(); person2.setName(\"Yin\"); person2.setAge(28); personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<StructField>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  DataFrame df = sqlContext.applySchema(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD().map(new Function<Row, String>() {  public String call(Row row) { return row.getString(0) + \"_\" + row.get(1).toString(); } }).collect();  List<String> expected = new ArrayList<String>(2); expected.add(\"Michael_29\"); expected.add(\"Yin_28\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"exception = e;",
        "ins1DelCode":"exception = e;;",
        "ins1PreCode":"object = mbean; m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG); } catch (NoSuchMethodException e) { exception = e;; } if( m== null && resource != null ) {",
        "ins2PreCode":"object = bean; m = object.getClass().getMethod(setMethod, signature); } catch (NoSuchMethodException e) { exception = e;; } if( m== null && resource != null ) {",
        "label":1
    },
    {
        "ins1AddCode":"} if (getUriEncoding() != null) { connector.setURIEncoding(getUriEncoding().name());",
        "ins1DelCode":"",
        "ins1PreCode":"if (connector.getProtocolHandler() instanceof AbstractProtocol) { customizeProtocol((AbstractProtocol<?>) connector.getProtocolHandler()); }  connector.setProperty(\"bindOnInit\", \"false\"); if (getSsl() != null && getSsl().isEnabled()) { customizeSsl(connector);",
        "ins2PreCode":"if (connector.getProtocolHandler() instanceof AbstractProtocol) { customizeProtocol((AbstractProtocol<?>) connector.getProtocolHandler()); } connector.setProperty(\"bindOnInit\", \"false\"); if (getSsl() != null && getSsl().isEnabled()) { customizeSsl(connector);",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testLangXmlWithMapper() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); Mapper m = sqlSession.getMapper(Mapper.class); List<Name> answer = m.selectXmlWithMapper(p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testLangXmlWithMapperAndSqlSymbols() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); Mapper m = sqlSession.getMapper(Mapper.class); List<Name> answer = m.selectXmlWithMapperAndSqlSymbols(p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(client.isResponse501());",
        "ins1DelCode":"assertTrue(client.isResponse501());",
        "ins1PreCode":" client.connect(); client.processRequest(); assertTrue(client.isResponse501());",
        "ins2PreCode":"client.connect(); client.processRequest(); assertTrue(client.isResponse501());",
        "label":1
    },
    {
        "ins1AddCode":"org.apache.catalina.Context ctx = tomcat.addContext(\"\", null);",
        "ins1DelCode":"StandardContext ctx = (StandardContext) tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));",
        "ins1PreCode":"tomcat.enableNaming();   StandardContext ctx = (StandardContext) tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));  ",
        "ins2PreCode":"tomcat.enableNaming(); StandardContext ctx = (StandardContext) tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));",
        "label":1
    },
    {
        "ins1AddCode":"enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface(); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace(); sendLargeGetRequest(3); sendSimpleGetRequest(5); for (int i = 0; i < 9; i++) { } Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace(); sendRst(3, Http2Error.NO_ERROR.getCode()); parser.readFrame(true); Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace()); output.clearTrace(); sendWindowUpdate(0, (1 << 31) - 2); sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "ins1DelCode":"LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.ALL); try { enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface(); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace(); sendLargeGetRequest(3); sendSimpleGetRequest(5); for (int i = 0; i < 9; i++) { parser.readFrame(true); } Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace(); sendRst(3, Http2Error.NO_ERROR.getCode()); parser.readFrame(true); Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace()); output.clearTrace(); sendWindowUpdate(0, (1 << 31) - 2); sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace()); } finally { LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.INFO); }",
        "ins1PreCode":"public void testExceedMaxActiveStreams02() throws Exception {  LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.ALL); try {     enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendRst(3, Http2Error.NO_ERROR.getCode());   parser.readFrame(true); Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace()); output.clearTrace();   sendWindowUpdate(0, (1 << 31) - 2);   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace()); } finally { LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.INFO); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"SwitchMapMaybeObserver<R> observer = new SwitchMapMaybeObserver<>(this);",
        "ins1DelCode":"SwitchMapMaybeObserver<R> observer = new SwitchMapMaybeObserver<R>(this);",
        "ins1PreCode":"return; }  SwitchMapMaybeObserver<R> observer = new SwitchMapMaybeObserver<R>(this);  for (;;) {",
        "ins2PreCode":"return; } SwitchMapMaybeObserver<R> observer = new SwitchMapMaybeObserver<R>(this); for (;;) {",
        "label":1
    },
    {
        "ins1AddCode":"public void onError(@NonNull Throwable t) {",
        "ins1DelCode":"public void onError(Throwable t) {",
        "ins1PreCode":"public void onError(Throwable t) { if (!checkSubscriptionOnce) { checkSubscriptionOnce = true;",
        "ins2PreCode":"public void onError(Throwable t) { if (!checkSubscriptionOnce) { checkSubscriptionOnce = true;",
        "label":1
    },
    {
        "ins1AddCode":"return new SEach(nextIdentifier(), location(ctx), type, name, expression, block);",
        "ins1DelCode":"return new SEach(location(ctx), type, name, expression, block);",
        "ins1PreCode":"AExpression expression = (AExpression)visit(ctx.expression()); SBlock block = (SBlock)visit(ctx.trailer());  return new SEach(location(ctx), type, name, expression, block);",
        "ins2PreCode":"AExpression expression = (AExpression)visit(ctx.expression()); SBlock block = (SBlock)visit(ctx.trailer()); return new SEach(location(ctx), \"def\", name, expression, block);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init(); tearDown();",
        "ins1PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { System.out.println(\"[testPoolThreads20Connections10Fair] Starting fairness - Tomcat JDBC - Fair\"); init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10Fair\",this.datasource.getSize(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "ins2PreCode":"public void testPoolThreads20Connections10FairAsync() throws Exception { System.out.println(\"[testPoolThreads20Connections10FairAsync] Starting fairness - Tomcat JDBC - Fair - Async\"); init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource; } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10FairAsync\",this.datasource.getSize(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "label":1
    },
    {
        "ins1AddCode":"List<Row> actual = sqlContext.sql(\"SELECT * FROM people\").collectAsList(); Assert.assertEquals(expected, actual);",
        "ins1DelCode":"Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collectRows(); Assert.assertEquals(expected, Arrays.asList(actual));",
        "ins1PreCode":" Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collectRows();  List<Row> expected = new ArrayList<>(2); expected.add(RowFactory.create(\"Michael\", 29)); expected.add(RowFactory.create(\"Yin\", 28));  Assert.assertEquals(expected, Arrays.asList(actual));",
        "ins2PreCode":"Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD().map(new Function<Row, String>() { List<String> expected = new ArrayList<>(2); expected.add(\"Michael_29\"); expected.add(\"Yin_28\"); Assert.assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1AddCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); JavaRDD<Rating> data = jsc.parallelize(testData._1());",
        "ins1DelCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "ins1PreCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.trainImplicit(data.rdd(), features, iterations); validatePrediction(model, users, products, testData._2(), 0.4, true, testData._3());",
        "ins2PreCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features) validatePrediction(model, users, products, testData._2(), 0.4, true, testData._3());",
        "label":1
    },
    {
        "ins1AddCode":"XYIntervalSeries<S> series = this.data.get(i);",
        "ins1DelCode":"XYIntervalSeries series = (XYIntervalSeries) this.data.get(i);",
        "ins1PreCode":"  for (int i = 0; i < this.data.size(); i++) { XYIntervalSeries series = (XYIntervalSeries) this.data.get(i); series.removeChangeListener(this); }",
        "ins2PreCode":"for (int i = 0; i < this.data.size(); i++) { XYSeries series = (XYSeries) this.data.get(i); series.removeChangeListener(this); }",
        "label":0
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(marker, \"marker\"); ParamChecks.nullNotPermitted(layer, \"layer\");",
        "ins1PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { ParamChecks.nullNotPermitted(marker, \"marker\"); ParamChecks.nullNotPermitted(layer, \"layer\"); List markers; if (layer == Layer.FOREGROUND) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void matchWithIncludeFilter() throws Exception {",
        "ins1DelCode":"public void matchWithIncludeFilter() throws Exception {",
        "ins1PreCode":"public void matchWithIncludeFilter() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithIncludeFilter.class); assertThat(excludes(filter, Controller1.class)).isFalse();",
        "ins2PreCode":"public void matchWithExcludeFilter() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithExcludeFilter.class); assertThat(excludes(filter, Controller2.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"if (type == List.class || type == Collection.class || type == Iterable.class) {",
        "ins1DelCode":"if (type == List.class || type == Collection.class) {",
        "ins1PreCode":"protected Class<?> resolveInterface(Class<?> type) { Class<?> classToCreate; if (type == List.class || type == Collection.class) { classToCreate = ArrayList.class; } else if (type == Map.class) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Boolean> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Boolean> to = new TestObserverEx<Boolean>();",
        "ins1PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>();  final IllegalArgumentException ex = new IllegalArgumentException();",
        "ins2PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException();",
        "label":1
    },
    {
        "ins1AddCode":"source = Objects.requireNonNull(completableFunction.apply(resource), \"The completableFunction returned a null CompletableSource\");",
        "ins1DelCode":"source = ObjectHelper.requireNonNull(completableFunction.apply(resource), \"The completableFunction returned a null CompletableSource\");",
        "ins1PreCode":"CompletableSource source;  try { source = ObjectHelper.requireNonNull(completableFunction.apply(resource), \"The completableFunction returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"MaybeSource<? extends T> source; try { source = ObjectHelper.requireNonNull(sourceSupplier.apply(resource), \"The sourceSupplier returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void emptyXMap() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  assertTrue(FlowableScalarXMap.tryScalarXMapSubscribe(new EmptyCallablePublisher(), ts, new Function<Integer, Publisher<Integer>>() {",
        "ins2PreCode":"public void mapperCrashes() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); assertTrue(FlowableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), ts, new Function<Integer, Publisher<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<KryoSerializable> ds = spark.createDataset(data, encoder);",
        "ins1DelCode":"Dataset<KryoSerializable> ds = context.createDataset(data, encoder);",
        "ins1PreCode":"Encoder<KryoSerializable> encoder = Encoders.kryo(KryoSerializable.class); List<KryoSerializable> data = Arrays.asList( new KryoSerializable(\"hello\"), new KryoSerializable(\"world\")); Dataset<KryoSerializable> ds = context.createDataset(data, encoder); Assert.assertEquals(data, ds.collectAsList());",
        "ins2PreCode":"Encoder<JavaSerializable> encoder = Encoders.javaSerialization(JavaSerializable.class); List<JavaSerializable> data = Arrays.asList( new JavaSerializable(\"hello\"), new JavaSerializable(\"world\")); Dataset<JavaSerializable> ds = context.createDataset(data, encoder); Assert.assertEquals(data, ds.collectAsList());",
        "label":1
    },
    {
        "ins1AddCode":"c = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null CompletableSource\");",
        "ins1DelCode":"c = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null CompletableSource\");",
        "ins1PreCode":"CompletableSource c;  try { c = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"CompletableSource c; try { c = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Double>> aggregated = grouped.agg( aggregated.collectAsList());",
        "ins1DelCode":"Dataset<Tuple2<String, Double>> agged = grouped.agg( agged.collectAsList());",
        "ins1PreCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.avg(value -> value._2() * 2.0)); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)), agged.collectAsList());",
        "ins2PreCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.avg(v -> (double)(v._2() * 2))); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)), agged.collectAsList());",
        "label":1
    },
    {
        "ins1AddCode":"\" newOffs=\" + newOffs.toString() \" res = \" + res); LOG.log(Level.FINE, \"offs={0} newOffs={1} res = {2}\", new Object[] { offs, newOffs, res });",
        "ins1DelCode":"LOG.debug(\"offs=\" + offs.toString() + \" newOffs=\" + newOffs.toString() + \" res = \" + res);",
        "ins1PreCode":"} ListSet newOffs = computeOffenders(dm); boolean res = offs.equals(newOffs); LOG.debug(\"offs=\" + offs.toString() + \" newOffs=\" + newOffs.toString() + \" res = \" + res); return res;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"factory.setSsl(getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\", null, new String[] { \"TLSv1.2\" }, null));",
        "ins1DelCode":"factory.setSsl(getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\"));",
        "ins1PreCode":"throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\")); this.webServer = factory.getWebServer(); this.webServer.start();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaVectorSlicerExample\").getOrCreate(); List<Row> data = Lists.newArrayList( ); spark.createDataFrame(data, (new StructType()).add(group.toStructField())); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JavaVectorSlicerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); JavaRDD<Row> jrdd = jsc.parallelize(Lists.newArrayList( )); jsql.createDataFrame(jrdd, (new StructType()).add(group.toStructField())); jsc.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaVectorSlicerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Attribute[] attrs = new Attribute[]{ NumericAttribute.defaultAttr().withName(\"f1\"), NumericAttribute.defaultAttr().withName(\"f2\"), NumericAttribute.defaultAttr().withName(\"f3\") }; AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);  JavaRDD<Row> jrdd = jsc.parallelize(Lists.newArrayList( RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})), RowFactory.create(Vectors.dense(-2.0, 2.3, 0.0)) ));  Dataset<Row> dataset = jsql.createDataFrame(jrdd, (new StructType()).add(group.toStructField()));  VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\");  vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});   Dataset<Row> output = vectorSlicer.transform(dataset);  System.out.println(output.select(\"userFeatures\", \"features\").first());  jsc.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(subscriber);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);",
        "ins1PreCode":"final TestScheduler testScheduler = new TestScheduler();  final Subscriber<Integer> subscriber = TestHelper.mockSubscriber(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);  Flowable.just(1, 2, 3)",
        "ins2PreCode":"final TestScheduler testScheduler = new TestScheduler(); final Observer<Integer> observer = TestHelper.mockObserver(); TestObserver<Integer> to = new TestObserver<Integer>(observer); Observable.just(1, 2, 3)",
        "label":1
    },
    {
        "ins1AddCode":"final FutureTask<Object> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, 0);",
        "ins1DelCode":"final FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, 0);",
        "ins1PreCode":"final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set); set.add(run);  final FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, 0);  Runnable r1 = new Runnable() {",
        "ins2PreCode":"final ScheduledRunnable run = new ScheduledRunnable(Functions.EMPTY_RUNNABLE, set); set.add(run); final FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, 0); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"DiagramSettings settings = LOG.log(Level.SEVERE, \"No valid namespace found\");",
        "ins1DelCode":"DiagramSettings settings = LOG.error(\"No valid namespace found\");",
        "ins1PreCode":"ExplorerEventAdaptor.getInstance().modelElementAdded(ns); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "ins2PreCode":"ExplorerEventAdaptor.getInstance().modelElementAdded( TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T, @NonNull R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) {",
        "ins1DelCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<@NonNull ? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) {",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<@NonNull ? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ctx.addApplicationListener(new ApplicationListener( TrackingRequestListener.class.getName(), false));",
        "ins1DelCode":"ctx.addApplicationListener(TrackingRequestListener.class.getName());",
        "ins1PreCode":"wrapper2.setAsyncSupported(true); ctx.addServletMapping(\"/stage2\", \"nonasync\");  ctx.addApplicationListener(TrackingRequestListener.class.getName());  TesterAccessLogValve alv = new TesterAccessLogValve();",
        "ins2PreCode":"wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/stage2\", \"error\"); ctx.addApplicationListener(TrackingRequestListener.class.getName()); TesterAccessLogValve alv = new TesterAccessLogValve();",
        "label":1
    },
    {
        "ins1AddCode":"FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH ); String result = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = format.format( contentLength ); String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0L ) double bytesPerSecond = contentLength / ( duration / 1000.0 ); throughput = \" at \" + format.format( (long) bytesPerSecond ) + \"/s\"; } out.println( result + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len throughput + \")\" ); + throughput + \")\" );",
        "ins1DelCode":"if ( contentLength >= 0 ) String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\"; String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0 ) { DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) ); double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 ); throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\"; } out.println( type + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" ); }",
        "ins1PreCode":"{ TransferResource resource = event.getResource(); long contentLength = event.getTransferredBytes(); if ( contentLength >= 0 ) { String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\";  String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0 ) { DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) ); double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 ); throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\"; }  out.println( type + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" ); }",
        "ins2PreCode":"{ TransferResource resource = event.getResource(); long contentLength = event.getTransferredBytes(); if ( contentLength >= 0 ) { String type = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = contentLength >= 1024 ? toKB( contentLength ) + \" KB\" : contentLength + \" B\"; String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0 ) { DecimalFormat format = new DecimalFormat( \"0.0\", new DecimalFormatSymbols( Locale.ENGLISH ) ); double kbPerSec = ( contentLength / 1024.0 ) / ( duration / 1000.0 ); throughput = \" at \" + format.format( kbPerSec ) + \" KB/sec\"; } out.info( type + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" ); }",
        "label":1
    },
    {
        "ins1AddCode":"void shouldToStringTriggerLazyLoading() {",
        "ins1DelCode":"public void shouldToStringTriggerLazyLoading() {",
        "ins1PreCode":"public void shouldToStringTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldHashCodeTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"systemDefault = p.getProperty(\"ant.regexp.regexpimpl\");",
        "ins1DelCode":"systemDefault = (String) p.getProperties().get(\"ant.regexp.regexpimpl\");",
        "ins1PreCode":"if (p == null) { systemDefault = System.getProperty(\"ant.regexp.regexpimpl\"); } else { systemDefault = (String) p.getProperties().get(\"ant.regexp.regexpimpl\"); } ",
        "ins2PreCode":"if (p == null) { systemDefault = System.getProperty(\"ant.regexp.regexpimpl\"); } else { systemDefault = (String) p.getProperties().get(\"ant.regexp.regexpimpl\"); }",
        "label":1
    },
    {
        "ins1AddCode":"DefaultBoxAndWhiskerCategoryDataset<String, String> dataset = new DefaultBoxAndWhiskerCategoryDataset<>();",
        "ins1DelCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset();",
        "ins1PreCode":"public void testDrawWithNullQ3() { boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\");",
        "ins2PreCode":"public void testDrawWithNullMinRegular() { boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5, -0.5, 5.5, null), \"S1\", \"C1\");",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<Row> rowRDD = jsc.parallelize(personList).map( Dataset<Row> df = spark.createDataFrame(rowRDD, schema); List<Row> actual = spark.sql(\"SELECT * FROM people\").collectAsList();",
        "ins1DelCode":"JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); List<Row> actual = sqlContext.sql(\"SELECT * FROM people\").collectAsList();",
        "ins1PreCode":"person2.setAge(28); personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<Row> actual = sqlContext.sql(\"SELECT * FROM people\").collectAsList();  List<Row> expected = new ArrayList<>(2);",
        "ins2PreCode":"person2.setAge(28); personList.add(person2); JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) { return RowFactory.create(person.getName(), person.getAge()); } }); List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields); Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD() List<String> expected = new ArrayList<>(2);",
        "label":1
    },
    {
        "ins1AddCode":"File file1 = new File(getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProject().getProperty(\"to.dir\")+\"/file3.txt\");",
        "ins1DelCode":"File file1 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file3.txt\");",
        "ins1PreCode":"public void testPathAsResource() { executeTarget(\"testPathAsResource\"); File file1 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists());",
        "ins2PreCode":"public void testZipfileset() { executeTarget(\"testZipfileset\"); File file1 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists());",
        "label":1
    },
    {
        "ins1AddCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();",
        "ins1DelCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "ins1PreCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "ins2PreCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "label":1
    },
    {
        "ins1AddCode":"void multiThreadedWithNPE() {",
        "ins1DelCode":"public void multiThreadedWithNPE() {",
        "ins1PreCode":"public void multiThreadedWithNPE() { TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(\"one\", \"two\", \"three\", null); Observable<String> w = Observable.unsafeCreate(onSubscribe);",
        "ins2PreCode":"public void multiThreadedWithNPE() { TestMultiThreadedObservable onSubscribe = new TestMultiThreadedObservable(\"one\", \"two\", \"three\", null); Flowable<String> w = Flowable.unsafeCreate(onSubscribe);",
        "label":1
    },
    {
        "ins1AddCode":"StickingServlet stickingServlet = new StickingServlet(8000L); stickingServlet); Assert.assertFalse(stickingServlet.wasInterrupted);",
        "ins1DelCode":"StuckingServlet stuckingServlet = new StuckingServlet(8000L); stuckingServlet); Assert.assertFalse(stuckingServlet.wasInterrupted);",
        "ins1PreCode":"public void testDetection() throws Exception {  StuckingServlet stuckingServlet = new StuckingServlet(8000L); Wrapper servlet = Tomcat.addServlet(context, \"myservlet\", stuckingServlet); servlet.addMapping(\"/myservlet\");  StuckThreadDetectionValve valve = new StuckThreadDetectionValve(); valve.setThreshold(2); context.addValve(valve); context.setBackgroundProcessorDelay(1); tomcat.start();  Assert.assertEquals(0, valve.getStuckThreadIds().length);  final ByteChunk result = new ByteChunk(); Thread asyncThread = new Thread() { @Override public void run() { try { getUrl(\"http://localhost:\" + getPort() + \"/myservlet\", result, null); } catch (IOException e) { e.printStackTrace(); } }  }; asyncThread.start(); try { Thread.sleep(500L); Assert.assertEquals(0, valve.getStuckThreadIds().length);  Thread.sleep(5000L); Assert.assertEquals(1, valve.getStuckThreadIds().length); } finally { asyncThread.join(20000);  Assert.assertFalse(asyncThread.isAlive()); } Assert.assertFalse(stuckingServlet.wasInterrupted); Assert.assertTrue(result.toString().startsWith(\"OK\"));",
        "ins2PreCode":"public void testInterruption() throws Exception { StuckingServlet stuckingServlet = new StuckingServlet( Wrapper servlet = Tomcat.addServlet(context, \"myservlet\", stuckingServlet); servlet.addMapping(\"/myservlet\"); StuckThreadDetectionValve valve = new StuckThreadDetectionValve(); valve.setThreshold(2); context.addValve(valve); context.setBackgroundProcessorDelay(1); tomcat.start(); Assert.assertEquals(0, valve.getStuckThreadIds().length); final ByteChunk result = new ByteChunk(); Thread asyncThread = new Thread() { @Override public void run() { try { getUrl(\"http://localhost:\" + getPort() + \"/myservlet\", result, null); } catch (IOException e) { e.printStackTrace(); } } }; asyncThread.start(); try { Thread.sleep(4000L); Assert.assertEquals(0, valve.getStuckThreadIds().length); Thread.sleep(4000L); Assert.assertEquals(1, valve.getStuckThreadIds().length); } finally { asyncThread.join(20000); Assert.assertFalse(asyncThread.isAlive()); } Assert.assertTrue(stuckingServlet.wasInterrupted); Assert.assertTrue(result.toString().startsWith(\"OK\"));",
        "label":1
    },
    {
        "ins1AddCode":"if (ignoreRemoved) { return false; }",
        "ins1DelCode":"",
        "ins1PreCode":"private boolean doFileWasRemoved(Vector entries, String line) { int index = line.indexOf(FILE_WAS_REMOVED); if (index == -1) { return false;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1DelCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) {",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) { final ExasolTableColumn column = command.getObject(); ",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) final DB2TableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"List<Dependency> list = new ArrayList<>( artifacts.size() );",
        "ins1DelCode":"List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );",
        "ins1PreCode":"return Collections.emptyList(); }  List<Dependency> list = new ArrayList<Dependency>( artifacts.size() );  for ( Artifact a : getArtifacts() )",
        "ins2PreCode":"return Collections.emptyList(); } List<Dependency> list = new ArrayList<Dependency>( artifacts.size() ); for ( Artifact a : getArtifacts()  )",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); subscriber.assertValues(1, 3); subscriber.assertValueCount(2); subscriber.assertTerminated(); });",
        "ins1DelCode":"Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); thrown.expect(AssertionError.class); subscriber.assertValues(1, 3); subscriber.assertValueCount(2); subscriber.assertTerminated();",
        "ins1PreCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber);  thrown.expect(AssertionError.class);  ",
        "ins2PreCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); subscriber.assertTerminated();",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Object> o = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Object> o = new AtomicReference<Object>();",
        "ins1PreCode":"} });  final AtomicReference<Object> o = new AtomicReference<Object>();  rs.subscribeOn(s).observeOn(Schedulers.io())",
        "ins2PreCode":"} }); final AtomicReference<Object> o = new AtomicReference<Object>(); rs.subscribeOn(s).observeOn(Schedulers.io())",
        "label":1
    },
    {
        "ins1AddCode":"out = out + in.next().toUpperCase(Locale.ROOT);",
        "ins1DelCode":"out = out + in.next().toUpperCase();",
        "ins1PreCode":"JavaDStream<String> mapped = stream.mapPartitions(in -> { String out = \"\"; while (in.hasNext()) { out = out + in.next().toUpperCase(); } return Arrays.asList(out).iterator();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"), false)) { assertThat(this.archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(this.archive); assertThat(entries.size()).isEqualTo(3); }",
        "ins1DelCode":"public void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), false); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(3);",
        "ins1PreCode":"public void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), false); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(3);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts); ts.assertValues(1, 3); ts.assertValueCount(2); ts.assertTerminated(); });",
        "ins1DelCode":"Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts); thrown.expect(AssertionError.class); ts.assertValues(1, 3); ts.assertValueCount(2); ts.assertTerminated();",
        "ins1PreCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts);  thrown.expect(AssertionError.class);  ts.assertValues(1, 3);",
        "ins2PreCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts); ts.assertTerminated(); ts.assertValueCount(2);",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals('s', exec(\"def d = 's'; char b = (char)d; b\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testdefTocharExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = (char)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; char b = (char)d;\")); assertEquals((char)0, exec(\"def d = (byte)0; char b = (char)d; b\"));",
        "ins2PreCode":"public void testdefToCharacterExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Character b = (Character)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; Character b = (Character)d;\")); assertEquals((char)0, exec(\"def d = (byte)0; Character b = (Character)d; b\"));",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) { DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) + \" TO \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getNewName()))",
        "ins1DelCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) { DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) + \" TO \" + command.getNewName())",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) { final ExasolTableColumn column = command.getObject();  actions.add( new SQLDatabasePersistAction( \"Rename column\", \"ALTER TABLE \" + column.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" RENAME COLUMN \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) + \" TO \" + command.getNewName()) );",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command) { final DB2TableColumn column = command.getObject(); actions.add( new SQLDatabasePersistAction( \"Rename column\", \"ALTER TABLE \" + column.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" RENAME COLUMN \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) + \" TO \" + command.getNewName()) );",
        "label":1
    },
    {
        "ins1AddCode":"XYIntervalSeries s2 = CloneUtils.clone(s1);",
        "ins1DelCode":"XYIntervalSeries s2 = (XYIntervalSeries) s1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries s2 = (XYIntervalSeries) s1.clone(); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"for (MutableBasicGraph<Integer> graph : graphsToTest) {",
        "ins1DelCode":"for (MutableGraph<Integer> graph : graphsToTest) {",
        "ins1PreCode":"public void hasCycle_threeAcyclicEdges() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2); graph.putEdge(2, 3);",
        "ins2PreCode":"public void hasCycle_threeCyclicEdges() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2); graph.putEdge(2, 3);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(1.0, item1.getX());",
        "ins1DelCode":"assertEquals(new Double(1.0), item1.getX());",
        "ins1PreCode":"public void testConstructor1() { XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(new Double(1.0), item1.getX()); assertEquals(2.0, item1.getXLowValue(), EPSILON); assertEquals(3.0, item1.getXHighValue(), EPSILON);",
        "ins2PreCode":"public void testConstructor1() { YIntervalDataItem item1 = new YIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(Double.valueOf(1.0), item1.getX()); assertEquals(3.0, item1.getYLowValue(), EPSILON); assertEquals(4.0, item1.getYHighValue(), EPSILON);",
        "label":0
    },
    {
        "ins1AddCode":"buildRule.configureProject(\"src/etc/testcases/core/include/including_file_task_error/build.xml\"); buildRule.executeTarget(\"test\");",
        "ins1DelCode":"configureProject(\"src/etc/testcases/core/include/including_file_task_error/build.xml\"); executeTarget(\"test\");",
        "ins1PreCode":"public void testTaskErrorInIncluding() { configureProject(\"src/etc/testcases/core/include/including_file_task_error/build.xml\"); try { executeTarget(\"test\"); fail(\"should have cause a build failure\"); } catch (BuildException e) {",
        "ins2PreCode":"public void testTaskErrorInIncluded() { configureProject(\"src/etc/testcases/core/include/included_file_task_error/build.xml\"); try { executeTarget(\"test\"); fail(\"should have cause a build failure\"); } catch (BuildException e) {",
        "label":1
    },
    {
        "ins1AddCode":"public Class<?> getType(EvaluationContext ctx) throws ELException {",
        "ins1DelCode":"public Class getType(EvaluationContext ctx) throws ELException {",
        "ins1PreCode":"public Class getType(EvaluationContext ctx) throws ELException { VariableMapper varMapper = ctx.getVariableMapper(); if (varMapper != null) {",
        "ins2PreCode":"public boolean isReadOnly(EvaluationContext ctx) throws ELException { VariableMapper varMapper = ctx.getVariableMapper(); if (varMapper != null) {",
        "label":0
    },
    {
        "ins1AddCode":"void getValueOrigin() {",
        "ins1DelCode":"public void getValueOrigin() {",
        "ins1PreCode":"public void getValueOrigin() { Map<String, Object> source = new LinkedHashMap<>(); source.put(\"key\", \"value\");",
        "ins2PreCode":"public void getValueWhenOriginCapableShouldIncludeSourceOrigin() { Map<String, Object> source = new LinkedHashMap<>(); source.put(\"key\", \"value\");",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "ins1DelCode":"assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "ins1PreCode":"this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "ins2PreCode":"this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "label":1
    },
    {
        "ins1AddCode":"Hashtable<String, String> files = new Hashtable<>();",
        "ins1DelCode":"Hashtable files = new Hashtable();",
        "ins1PreCode":"FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile);",
        "ins2PreCode":"FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile);",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) {",
        "ins2PreCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); if (this instanceof ScalarSupplier) {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testPoolThreads10Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "ins2PreCode":"public void testPoolThreads10Connections10ValidateFair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "label":1
    },
    {
        "ins1AddCode":"public Publisher<? extends Integer> apply(Integer v) { public Publisher<? extends Integer> apply(Integer v) { public Maybe<? extends Integer> apply(Integer v) {",
        "ins1DelCode":"public Publisher<? extends Integer> apply(Integer v) throws Exception { public Publisher<? extends Integer> apply(Integer v) throws Exception { public Maybe<? extends Integer> apply(Integer v) throws Exception {",
        "ins1PreCode":" flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.empty(); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Maybe.<Integer>empty().toFlowable(); } });  flowableDedicated = source.switchMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.empty(); }",
        "ins2PreCode":"flowablePlain = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.empty(); } }); flowableConvert = source.flatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Maybe.<Integer>empty().toFlowable(); } }); flowableDedicated = source.flatMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.empty(); }",
        "label":1
    },
    {
        "ins1AddCode":"public void textFilesCompressed() {",
        "ins1DelCode":"public void textFilesCompressed() throws IOException {",
        "ins1PreCode":"public void textFilesCompressed() throws IOException { String outputDir = new File(tempDir, \"output\").getAbsolutePath(); JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4));",
        "ins2PreCode":"public void objectFilesOfInts() { String outputDir = new File(tempDir, \"output\").getAbsolutePath(); JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4));",
        "label":0
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertNull(credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"DateTitle t2 = CloneUtils.clone(t1);",
        "ins1DelCode":"DateTitle t2 = (DateTitle) t1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DateTitle t1 = new DateTitle(); DateTitle t2 = (DateTitle) t1.clone(); assertTrue(t1 != t2); assertTrue(t1.getClass() == t2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"} catch (SomeUncheckedException expected) {",
        "ins1DelCode":"} catch (SomeUncheckedException e) {",
        "ins1PreCode":"try { sample.oneDeclared(); fail(); } catch (SomeUncheckedException e) { }",
        "ins2PreCode":"try { sample.oneDeclared(); fail(); throws SomeCheckedException { }",
        "label":0
    },
    {
        "ins1AddCode":"final TestObserver<String> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<String> to = new TestObserver<String>();",
        "ins1PreCode":"public void sourceObservableRetry1() throws InterruptedException { final AtomicInteger subsCount = new AtomicInteger(0);  final TestObserver<String> to = new TestObserver<String>();  ObservableSource<String> onSubscribe = new ObservableSource<String>() {",
        "ins2PreCode":"public void sourceObservableRetry0() throws InterruptedException { final AtomicInteger subsCount = new AtomicInteger(0); final TestObserver<String> to = new TestObserver<String>(); ObservableSource<String> onSubscribe = new ObservableSource<String>() {",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void inDegree_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void degree_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ)",
        "ins1PreCode":"project.isBuilding(), equalTo(false));  final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(\"aProject\", \"1\"); assertThat(result, succeeded());",
        "ins2PreCode":"assertThat(\"Job wasn't scheduled properly - it is running on non-exist node\", project.isBuilding(), equalTo(false)); final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Item.BUILD) .invokeWithArgs(\"aProject\", \"1\"); assertThat(result, failedWith(3));",
        "label":1
    },
    {
        "ins1AddCode":"log.error(sm.getString(\"containerbase.cluster.stop\"), e); log.error(sm.getString(\"containerbase.cluster.start\"), e);",
        "ins1DelCode":"log.error(\"ContainerBase.setCluster: stop: \", e); log.error(\"ContainerBase.setCluster: start: \", e);",
        "ins1PreCode":"try { ((Lifecycle) oldCluster).stop(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: stop: \", e); } }   if (cluster != null) cluster.setContainer(this);  if (getState().isAvailable() && (cluster != null) && (cluster instanceof Lifecycle)) { try { ((Lifecycle) cluster).start(); } catch (LifecycleException e) { log.error(\"ContainerBase.setCluster: start: \", e); } }",
        "ins2PreCode":"try { ((Lifecycle) oldLoader).stop(); } catch (LifecycleException e) { log.error(\"StandardContext.setLoader: stop: \", e); } } if (loader != null) loader.setContext(this); if (getState().isAvailable() && (loader != null) && (loader instanceof Lifecycle)) { try { ((Lifecycle) loader).start(); } catch (LifecycleException e) { log.error(\"StandardContext.setLoader: start: \", e); } }",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void predecessors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"final int size = (int) offsetAndSize;",
        "ins1DelCode":"final int size = (int) (offsetAndSize & ((1L << 32) - 1));",
        "ins1PreCode":"} else { final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) (offsetAndSize & ((1L << 32) - 1)); final byte[] bytes = new byte[size]; Platform.copyMemory(",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"log(\"Read before running into timeout: \" + sb.toString(), Project.MSG_DEBUG);",
        "ins1DelCode":"",
        "ins1PreCode":"Thread.sleep(250); } if (is.available() == 0) { throw new BuildException( \"Response timed-out waiting for \\\"\" + s + '\\\"', getLocation()); }",
        "ins2PreCode":"Thread.sleep(250); } if (is.available() == 0) { throw new BuildException( \"Response timed-out waiting for \\\"\" + s + '\\\"', getLocation()); }",
        "label":0
    },
    {
        "ins1AddCode":"final Object value = extensions == null ? null : extensions.getField(descriptor);",
        "ins1DelCode":"final Object value = extensions.getField(descriptor);",
        "ins1PreCode":" verifyExtensionContainingType(extension); FieldDescriptor descriptor = extension.getDescriptor(); final Object value = extensions.getField(descriptor); if (value == null) { if (descriptor.isRepeated()) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"(aliases, socket) -> \"spring-boot\")",
        "ins1DelCode":"new PrivateKeyStrategy() { @Override public String chooseAlias( Map<String, PrivateKeyDetails> aliases, Socket socket) { return \"spring-boot\"; } })",
        "ins1PreCode":"new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray(), new PrivateKeyStrategy() {  @Override public String chooseAlias( Map<String, PrivateKeyDetails> aliases, Socket socket) { return \"spring-boot\"; } }) .build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory)",
        "ins2PreCode":"new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); .loadTrustMaterial(null, new TrustSelfSignedStrategy()) this.webServer.start(); public void sslWantsClientAuthenticationSucceedsWithClientCertificate() new SSLContextBuilder() throws Exception { new String[] { \"TLSv1.2\" }, null)); } } .build(); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory)",
        "label":0
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":" });  to.onSubscribe(Disposables.empty());  try {",
        "ins2PreCode":"}); to.onSubscribe(Disposables.empty()); try {",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"return new Single<Object>() { @Override protected void subscribeActual(SingleObserver<? super Object> observer) { observer.onSubscribe(Disposables.empty());  assertFalse(((Disposable)observer).isDisposed());",
        "ins2PreCode":"return new Maybe<Object>() { @Override protected void subscribeActual(MaybeObserver<? super Object> observer) { observer.onSubscribe(Disposables.empty()); assertFalse(((Disposable)observer).isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void hasNextCancels() { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  Flowable.fromIterable(new Iterable<Integer>() {",
        "ins2PreCode":"public void hasNextCancels() { final TestObserver<Integer> to = new TestObserver<Integer>(); Observable.fromIterable(new Iterable<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"void getEndpointsShouldDiscoverProxyControllerEndpoints() {",
        "ins1DelCode":"public void getEndpointsShouldDiscoverProxyControllerEndpoints() {",
        "ins1PreCode":"public void getEndpointsShouldDiscoverProxyControllerEndpoints() { this.contextRunner.withUserConfiguration(TestProxyControllerEndpoint.class) .withConfiguration(AutoConfigurations.of(ValidationAutoConfiguration.class))",
        "ins2PreCode":"public void getEndpointsShouldIncludeRestControllerEndpoints() { this.contextRunner.withUserConfiguration(TestRestControllerEndpoint.class) this.contextRunner.withUserConfiguration(TestRestControllerEndpoint.class)",
        "label":1
    },
    {
        "ins1AddCode":"new Timed<>(1, 1000, TIME_UNIT)); new Timed<>(2, 2000, TIME_UNIT)); new Timed<>(3, 3000, TIME_UNIT));",
        "ins1DelCode":"new Timed<Integer>(1, 1000, TIME_UNIT)); new Timed<Integer>(2, 2000, TIME_UNIT)); new Timed<Integer>(3, 3000, TIME_UNIT));",
        "ins1PreCode":"processor.onComplete();  inOrder.verify(subscriber, times(1)).onNext( new Timed<Integer>(1, 1000, TIME_UNIT)); inOrder.verify(subscriber, times(1)).onNext( new Timed<Integer>(2, 2000, TIME_UNIT)); inOrder.verify(subscriber, times(1)).onNext( new Timed<Integer>(3, 3000, TIME_UNIT)); inOrder.verify(subscriber, times(1)).onComplete(); inOrder.verifyNoMoreInteractions();",
        "ins2PreCode":"subject.onComplete(); inOrder.verify(observer, times(1)).onNext( new Timed<Integer>(1, 1000, TIME_UNIT)); inOrder.verify(observer, times(1)).onNext( new Timed<Integer>(2, 2000, TIME_UNIT)); inOrder.verify(observer, times(1)).onNext( new Timed<Integer>(3, 3000, TIME_UNIT)); inOrder.verify(observer, times(1)).onComplete(); inOrder.verifyNoMoreInteractions();",
        "label":1
    },
    {
        "ins1AddCode":"setMapValuesUsingMutableMap(builder);",
        "ins1DelCode":"setMapValues(builder);",
        "ins1PreCode":"public void testMergeFrom() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); ",
        "ins2PreCode":"public void testMergeFrom() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();",
        "label":1
    },
    {
        "ins1AddCode":"Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));",
        "ins1DelCode":"Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 2, 0, 2)));",
        "ins1PreCode":"BlockFetchingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 2, 0, 2)));  verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any());",
        "ins2PreCode":"BlockFetchingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 2, 0, 2))); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any());",
        "label":1
    },
    {
        "ins1AddCode":"SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); initDb(sqlSessionFactory); return sqlSessionFactory;",
        "ins1DelCode":"Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c); c.close(); return new SqlSessionFactoryBuilder().build(configuration);",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(ParameterMapReferencePersonMapper.class); configuration.addMapper(ParameterMapReferencePetMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c); Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment); configuration.addMapper(ResultMapReferencePersonMapper.class); configuration.addMapper(ResultMapReferencePetMapper.class); c.close(); return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1AddCode":"static String readQuotedToken(Reader input) throws IOException {",
        "ins1DelCode":"static String readQuotedToken(StringReader input) throws IOException {",
        "ins1PreCode":"static String readQuotedToken(StringReader input) throws IOException {  StringBuilder result = new StringBuilder();",
        "ins2PreCode":"static String readLhex(StringReader input) throws IOException { StringBuilder result = new StringBuilder();",
        "label":1
    },
    {
        "ins1AddCode":"void wrongJavaType() {",
        "ins1DelCode":"public void wrongJavaType() {",
        "ins1PreCode":"public void wrongJavaType() { Configuration configuration = sqlSessionFactory.getConfiguration(); when(configuration).addMapper(ConstructorWithWrongJavaType.class);",
        "ins2PreCode":"public void missingRequiredJavaType() { Configuration configuration = sqlSessionFactory.getConfiguration(); when(configuration).addMapper(ConstructorMissingRequiresJavaType.class);",
        "label":1
    },
    {
        "ins1AddCode":"void setIgnoreBeanInfoPropertyByDefault(CapturedOutput capturedOutput) {",
        "ins1DelCode":"public void setIgnoreBeanInfoPropertyByDefault() {",
        "ins1PreCode":"public void setIgnoreBeanInfoPropertyByDefault() { SpringApplication application = new SpringApplication(ExampleConfig.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "ins2PreCode":"public void disableIgnoreBeanInfoProperty() { SpringApplication application = new SpringApplication(ExampleConfig.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "label":0
    },
    {
        "ins1AddCode":"protected void channelRead0(final ChannelHandlerContext ctx, HttpPipelinedRequest pipelinedRequest) { final org.elasticsearch.http.HttpRequest request = pipelinedRequest.getDelegateRequest(); final QueryStringDecoder decoder = new QueryStringDecoder(request.uri()); HttpResponse httpResponse = pipelinedRequest.createResponse(RestStatus.OK, content);",
        "ins1DelCode":"protected void channelRead0(final ChannelHandlerContext ctx, HttpPipelinedRequest<FullHttpRequest> pipelinedRequest) { LastHttpContent request = pipelinedRequest.getRequest(); final QueryStringDecoder decoder; if (request instanceof FullHttpRequest) { decoder = new QueryStringDecoder(((FullHttpRequest)request).uri()); } else { decoder = new QueryStringDecoder(AggregateUrisAndHeadersHandler.QUEUE_URI.poll()); } Netty4HttpRequest nioHttpRequest = new Netty4HttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()); Netty4HttpResponse httpResponse = nioHttpRequest.createResponse(RestStatus.OK, content);",
        "ins1PreCode":"protected void channelRead0(final ChannelHandlerContext ctx, HttpPipelinedRequest<FullHttpRequest> pipelinedRequest) { LastHttpContent request = pipelinedRequest.getRequest(); final QueryStringDecoder decoder; if (request instanceof FullHttpRequest) { decoder = new QueryStringDecoder(((FullHttpRequest)request).uri()); } else { decoder = new QueryStringDecoder(AggregateUrisAndHeadersHandler.QUEUE_URI.poll()); }  final String uri = decoder.path().replace(\"/\", \"\"); final BytesReference content = new BytesArray(uri.getBytes(StandardCharsets.UTF_8)); Netty4HttpRequest nioHttpRequest = new Netty4HttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()); Netty4HttpResponse httpResponse = nioHttpRequest.createResponse(RestStatus.OK, content); httpResponse.addHeader(CONTENT_LENGTH.toString(), Integer.toString(content.length())); ",
        "ins2PreCode":"protected void channelRead0(final ChannelHandlerContext ctx, HttpPipelinedRequest<FullHttpRequest> pipelinedRequest) { LastHttpContent request = pipelinedRequest.getRequest(); final QueryStringDecoder decoder; if (request instanceof FullHttpRequest) { decoder = new QueryStringDecoder(((FullHttpRequest)request).uri()); } else { decoder = new QueryStringDecoder(AggregateUrisAndHeadersHandler.QUEUE_URI.poll()); } final String uri = decoder.path().replace(\"/\", \"\"); final BytesReference content = new BytesArray(uri.getBytes(StandardCharsets.UTF_8)); NioHttpRequest nioHttpRequest = new NioHttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()); NioHttpResponse httpResponse = nioHttpRequest.createResponse(RestStatus.OK, content); httpResponse.addHeader(CONTENT_LENGTH.toString(), Integer.toString(content.length()));",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty());  AtomicThrowable ex = new AtomicThrowable();",
        "ins2PreCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); AtomicThrowable ex = new AtomicThrowable();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Object> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>();",
        "ins1PreCode":"public void syncQueueThrows() { TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>(); ts.setInitialFusionMode(QueueFuseable.SYNC); ",
        "ins2PreCode":"public void syncQueueThrows() { TestObserverEx<Object> to = new TestObserverEx<Object>(); to.setInitialFusionMode(QueueFuseable.SYNC);",
        "label":1
    },
    {
        "ins1AddCode":"void completeShortStringReturnsFieldValue() { database.insertEntry(entry); Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"va\")));",
        "ins1DelCode":"public void completeShortStringReturnsFieldValue() { autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"va\")));",
        "ins1PreCode":"public void completeShortStringReturnsFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"val\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"va\"))); assertEquals(Collections.singletonList(\"val\"), result);",
        "ins2PreCode":"public void completeShortStringReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"val\"); autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"va\"))); assertEquals(Collections.singletonList(\"val\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { } catch (IOException x) { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel .getAttachment(); nRead = pool.read(to, channel, selector, att.getReadTimeout()); nRead = channel.read(to);",
        "ins1DelCode":"private int fillReadBuffer(boolean block) throws IOException { socketBufferHandler.configureReadBufferForWrite(); } catch ( IOException x ) { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel.getAttachment(); nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getReadTimeout()); nRead = channel.read(socketBufferHandler.getReadBuffer());",
        "ins1PreCode":"private int fillReadBuffer(boolean block) throws IOException { int nRead; NioChannel channel = getSocket(); socketBufferHandler.configureReadBufferForWrite(); if (block) { Selector selector = null; try { selector = pool.get(); } catch ( IOException x ) {  } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel.getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(socketBufferHandler.getReadBuffer()); if (nRead == -1) { throw new EOFException();",
        "ins2PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { break; selector = pool.get(); if (getSocket().flush(true, selector, writeTimeout)) { if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) { } try { if (getSocket().flush(true, selector, writeTimeout)) { pool.write(from, getSocket(), selector, writeTimeout, block); if (selector != null) { } catch (IOException x) { } pool.put(selector); if (getSocket().flush(true, selector, writeTimeout)) { } finally { if (selector != null) { pool.put(selector); } } } finally { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) { } catch (IOException x) {",
        "label":0
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD1, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(METHOD, USER_NAME, PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + int.class.getCanonicalName());",
        "ins1DelCode":"throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to int\");",
        "ins1PreCode":") { return ((Number)value).intValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to int\"); }",
        "ins2PreCode":") { return ((Number)value).longValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to long\"); }",
        "label":1
    },
    {
        "ins1AddCode":"TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<>();",
        "ins1DelCode":"TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<Integer>();",
        "ins1PreCode":"public void normal() { TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<Integer>();  assertFalse(tc.isDisposed());",
        "ins2PreCode":"public void normal() { TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>(); assertFalse(tc.isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner.withUserConfiguration(Config.class).run((context) -> { Map<String, LiquibaseBean> liquibaseBeans = context .getBean(LiquibaseEndpoint.class).liquibaseBeans().getContexts() .get(context.getId()).getLiquibaseBeans(); assertThat(liquibaseBeans.get(\"liquibase\").getChangeSets()).hasSize(1); });",
        "ins1DelCode":"this.contextRunner.withUserConfiguration(Config.class) .run((context) -> assertThat( context.getBean(LiquibaseEndpoint.class).liquibaseBeans() .getContexts().get(context.getId()).getLiquibaseBeans()) .hasSize(1));",
        "ins1PreCode":"public void liquibaseReportIsReturned() { this.contextRunner.withUserConfiguration(Config.class) .run((context) -> assertThat( context.getBean(LiquibaseEndpoint.class).liquibaseBeans() .getContexts().get(context.getId()).getLiquibaseBeans()) .hasSize(1));",
        "ins2PreCode":"public void invokeWithCustomSchema() { this.contextRunner.withUserConfiguration(Config.class) .run((context) -> assertThat( context.getBean(LiquibaseEndpoint.class).liquibaseBeans() .getContexts().get(context.getId()).getLiquibaseBeans()) .hasSize(1));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, idStrategy.compare(\"user1\", \"user1\"));",
        "ins1DelCode":"assertTrue(idStrategy.compare(\"user1\", \"user1\") == 0);",
        "ins1PreCode":"IdStrategy idStrategy = new IdStrategy.CaseSensitive(); assertTrue(idStrategy.compare(\"user1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"user2\", \"user1\") > 0); assertTrue(idStrategy.compare(\"user1\", \"user1\") == 0); assertTrue(idStrategy.compare(\"USER1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"USER2\", \"user1\") < 0);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"o.onSubscribe(Disposable.empty());",
        "ins1DelCode":"o.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Long> o) { o.onSubscribe(Disposables.empty()); System.out.println(\"********* Start Source Data ***********\"); for (long l = 1; l <= 10000; l++) {",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Long> o) { o.onSubscribe(Disposables.empty()); System.out.println(\"********* Start Source Data ***********\"); for (long l = 1; l <= 10000; l++) {",
        "label":1
    },
    {
        "ins1AddCode":"Observable.just(Observable.just(1)).concatMapDelayError((Function)Functions.identity(), true, 2, ImmediateThinScheduler.INSTANCE).subscribe(to);",
        "ins1DelCode":"Observable.just(Observable.just(1)).concatMapDelayError((Function)Functions.identity(), 2, true, ImmediateThinScheduler.INSTANCE).subscribe(to);",
        "ins1PreCode":"public void concatMapDelayErrorJustJust() { TestObserver<Integer> to = TestObserver.create();  Observable.just(Observable.just(1)).concatMapDelayError((Function)Functions.identity(), 2, true, ImmediateThinScheduler.INSTANCE).subscribe(to);  to.assertValue(1);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"givenScheduleAtFixedRateWithReturnFuture();",
        "ins1DelCode":"",
        "ins1PreCode":"void pushWhenUnknownHostExceptionIsThrownDoesShutdown() throws Exception { new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, null); verify(this.scheduler).scheduleAtFixedRate(this.task.capture(), eq(this.pushRate));",
        "ins2PreCode":"void pushDoesNotThrowException() throws Exception { new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, null); verify(this.scheduler).scheduleAtFixedRate(this.task.capture(), eq(this.pushRate));",
        "label":0
    },
    {
        "ins1AddCode":"result = this.foregroundRangeMarkers.get(index); result = this.backgroundRangeMarkers.get(index);",
        "ins1DelCode":"Integer key = index; result = this.foregroundRangeMarkers.get(key); result = this.backgroundRangeMarkers.get(key);",
        "ins1PreCode":"public Collection<Marker> getRangeMarkers(int index, Layer layer) { Collection<Marker> result = null; Integer key = index; if (layer == Layer.FOREGROUND) { result = this.foregroundRangeMarkers.get(key); } else if (layer == Layer.BACKGROUND) { result = this.backgroundRangeMarkers.get(key); } if (result != null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void roundTripWithPrependingNewlines() throws IOException {",
        "ins1DelCode":"public void roundTripWithPrependingNewlines() throws IOException {",
        "ins1PreCode":"public void roundTripWithPrependingNewlines() throws IOException {  String bibtexEntry = \"\\r\\n@Article{test,\" + OS.NEWLINE +",
        "ins2PreCode":"private String testSingleWrite(String bibtexEntry) throws IOException { StringWriter stringWriter = new StringWriter();",
        "label":0
    },
    {
        "ins1AddCode":"String otype = (String) options.get(LockGraphManager.keyType); case LockGraphManager.typeWait: case LockGraphManager.typeHold:",
        "ins1DelCode":"String otype = (String) options.get(LockManagerViewer.keyType); case LockManagerViewer.typeWait: case LockManagerViewer.typeHold:",
        "ins1PreCode":" try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockManagerViewer.keyType);  switch (otype) {  case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(sidWait)); break;  case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(sidHold)); break;",
        "ins2PreCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) { String otype = (String) options.get(LockManagerViewer.keyType); switch(otype) { case LockManagerViewer.typeWait: dbStat.setBigDecimal(1, new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidWait))); break; case LockManagerViewer.typeHold: dbStat.setBigDecimal(1,  new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidHold))); break;",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7) {",
        "ins1DelCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7) {",
        "ins1PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\");",
        "ins2PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\");",
        "label":1
    },
    {
        "ins1AddCode":"Boolean b = coerceToBoolean(obj, true); b = coerceToBoolean(obj, true);",
        "ins1DelCode":"Boolean b = coerceToBoolean(obj); b = coerceToBoolean(obj);",
        "ins1PreCode":"public Object getValue(EvaluationContext ctx) throws ELException { Object obj = this.children[0].getValue(ctx); Boolean b = coerceToBoolean(obj); if (b.booleanValue()) { return b; } obj = this.children[1].getValue(ctx); b = coerceToBoolean(obj); return b;",
        "ins2PreCode":"public Object getValue(EvaluationContext ctx) throws ELException { Object obj = children[0].getValue(ctx); Boolean b = coerceToBoolean(obj); if (!b.booleanValue()) { return b; } obj = children[1].getValue(ctx); b = coerceToBoolean(obj); return b;",
        "label":1
    },
    {
        "ins1AddCode":"if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); } else {",
        "ins1DelCode":"if (c != -1) { else { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); }",
        "ins1PreCode":"int subinterval) { int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getPercentComplete(r, c + this.firstCategoryIndex, subinterval);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Path auxFile = Paths.get(AuxParserTest.class.getResource(\"nested.aux\").toURI()); ParserResult result = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(originalReader); AuxParser auxParser = new DefaultAuxParser(result.getDatabase()); AuxParserResult auxResult = auxParser.parse(auxFile);",
        "ins1DelCode":"File auxFile = Paths.get(AuxParserTest.class.getResource(\"nested.aux\").toURI()).toFile(); ParserResult result = new BibtexParser(importFormatPreferences).parse(originalReader); AuxParser auxParser = new AuxParser(auxFile.getAbsolutePath(), result.getDatabase()); AuxParserResult auxResult = auxParser.parse();",
        "ins1PreCode":"public void testNestedAux() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\"); File auxFile = Paths.get(AuxParserTest.class.getResource(\"nested.aux\").toURI()).toFile(); try (InputStreamReader originalReader = new InputStreamReader(originalStream, StandardCharsets.UTF_8)) { ParserResult result = new BibtexParser(importFormatPreferences).parse(originalReader);  AuxParser auxParser = new AuxParser(auxFile.getAbsolutePath(), result.getDatabase()); AuxParserResult auxResult = auxParser.parse();  assertTrue(auxResult.getGeneratedBibDatabase().hasEntries());",
        "ins2PreCode":"public void testCrossRef() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\"); File auxFile = Paths.get(AuxParserTest.class.getResource(\"crossref.aux\").toURI()).toFile(); try (InputStreamReader originalReader = new InputStreamReader(originalStream, StandardCharsets.UTF_8)) { ParserResult result = new BibtexParser(importFormatPreferences).parse(originalReader); AuxParser auxParser = new AuxParser(auxFile.getAbsolutePath(), result.getDatabase()); AuxParserResult auxResult = auxParser.parse(); assertTrue(auxResult.getGeneratedBibDatabase().hasEntries());",
        "label":1
    },
    {
        "ins1AddCode":"public void testDirectoryRetaining() {",
        "ins1DelCode":"public void testDirectoryRetaining() throws IOException {",
        "ins1PreCode":"public void testDirectoryRetaining() throws IOException { buildRule.executeTarget(\"testDirectoryRetaining\"); String output = buildRule.getProject().getProperty(\"output\");",
        "ins2PreCode":"private void testCompleteDirectoryMove(String target) throws IOException { buildRule.executeTarget(target); String output = buildRule.getProject().getProperty(\"output\");",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<List<Integer>> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();",
        "ins1PreCode":"public void producerRequestThroughBufferWithSize2() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); final AtomicLong requested = new AtomicLong(); ",
        "ins2PreCode":"public void producerRequestThroughBufferWithSize4() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); final AtomicLong requested = new AtomicLong();",
        "label":1
    },
    {
        "ins1AddCode":"oi.subscribe(new TestSubscriberEx<>(mockSubscriber));",
        "ins1DelCode":"oi.subscribe(new TestSubscriberEx<Integer>(mockSubscriber));",
        "ins1PreCode":"public void wrappingMockWhenUnsubscribeInvolved() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber(); oi.subscribe(new TestSubscriberEx<Integer>(mockSubscriber));  InOrder inOrder = inOrder(mockSubscriber);",
        "ins2PreCode":"public void wrappingMock() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); Observer<Integer> mockSubscriber = TestHelper.mockObserver(); oi.subscribe(new TestObserverEx<Integer>(mockSubscriber)); InOrder inOrder = inOrder(mockSubscriber);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Pool cleaner should not be started yet.\",0,ConnectionPool.getPoolCleaners().size() ); Assert.assertNull(\"Pool timer should be null\", ConnectionPool.getPoolTimer()); Assert.assertEquals(\"Pool cleaner threads should not be present.\",0, countPoolCleanerThreads()); Assert.assertEquals(\"Pool cleaner should have 1 cleaner.\",1,ConnectionPool.getPoolCleaners().size() ); Assert.assertNotNull(\"Pool timer should not be null\", ConnectionPool.getPoolTimer()); Assert.assertEquals(\"Pool cleaner threads should be 1.\",1, countPoolCleanerThreads()); Assert.assertEquals(\"Pool shutdown, no cleaners should be present.\",0,ConnectionPool.getPoolCleaners().size() ); Assert.assertNull(\"Pool timer should be null after shutdown\", ConnectionPool.getPoolTimer()); Assert.assertEquals(\"Pool cleaner threads should not be present after close.\",0, countPoolCleanerThreads());",
        "ins1DelCode":"assertEquals(\"Pool cleaner should not be started yet.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should not be present.\",0, countPoolCleanerThreads()); assertEquals(\"Pool cleaner should have 1 cleaner.\",1,ConnectionPool.getPoolCleaners().size() ); assertNotNull(\"Pool timer should not be null\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should be 1.\",1, countPoolCleanerThreads()); assertEquals(\"Pool shutdown, no cleaners should be present.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null after shutdown\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should not be present after close.\",0, countPoolCleanerThreads());",
        "ins1PreCode":"public void testPoolCleaner() throws Exception { datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(2000); datasource.getPoolProperties().setTestWhileIdle(true); assertEquals(\"Pool cleaner should not be started yet.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should not be present.\",0, countPoolCleanerThreads());  datasource.getConnection().close(); assertEquals(\"Pool cleaner should have 1 cleaner.\",1,ConnectionPool.getPoolCleaners().size() ); assertNotNull(\"Pool timer should not be null\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should be 1.\",1, countPoolCleanerThreads());  datasource.close(); assertEquals(\"Pool shutdown, no cleaners should be present.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null after shutdown\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should not be present after close.\",0, countPoolCleanerThreads());  ",
        "ins2PreCode":"public void test2PoolCleaners() throws Exception { datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(2000); datasource.getPoolProperties().setTestWhileIdle(true); assertEquals(\"Pool cleaner should not be started yet.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should not be present.\",0, countPoolCleanerThreads()); datasource.getConnection().close(); assertEquals(\"Pool cleaner should have 1 cleaner.\",1,ConnectionPool.getPoolCleaners().size() ); assertNotNull(\"Pool timer should not be null\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should be 1.\",1, countPoolCleanerThreads()); datasource.close(); assertEquals(\"Pool shutdown, no cleaners should be present.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null after shutdown\", ConnectionPool.getPoolTimer()); assertEquals(\"Pool cleaner threads should not be present after close.\",0, countPoolCleanerThreads());",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable bs = Disposable.empty();",
        "ins1DelCode":"final Disposable bs = Disposables.empty();",
        "ins1PreCode":"public void onSubscribeCrash() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable bs = Disposables.empty();  new Observable<Integer>() {",
        "ins2PreCode":"public void onSubscribeCrash() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable bs = Disposables.empty(); new Maybe<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"DataFrame df = sqlContext.createDataFrame(rowRDD, schema);",
        "ins1DelCode":"DataFrame df = sqlContext.applySchema(rowRDD, schema);",
        "ins1PreCode":"fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  DataFrame df = sqlContext.applySchema(rowRDD, schema); df.registerTempTable(\"people\"); Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collect();",
        "ins2PreCode":"fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields); DataFrame df = sqlContext.applySchema(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD().map(new Function<Row, String>() {",
        "label":1
    },
    {
        "ins1AddCode":"List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1DelCode":"List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1PreCode":"JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(Tuple2::_2); JavaTestUtils.attachTestOutputStream(reversed); List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final DoubleValuesSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.needsScores(); bindings.add(variable, valueSource);",
        "ins1DelCode":"final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource());",
        "ins1PreCode":"} else {   final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {",
        "ins2PreCode":"} else { final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {",
        "label":1
    },
    {
        "ins1AddCode":"Health health = healthIndicator.health().block(Duration.ofSeconds(30));",
        "ins1DelCode":"Health health = healthIndicator.health().block();",
        "ins1PreCode":"DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics); Health health = healthIndicator.health().block(); assertThat(health.getStatus()).isEqualTo(Status.UP); assertThat(health.getDetails()).containsEntry(\"sdk\", \"test-sdk\");",
        "ins2PreCode":"DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics); Health health = healthIndicator.health().block(); assertThat(health.getStatus()).isEqualTo(Status.DOWN); assertThat(health.getDetails()).containsEntry(\"sdk\", \"test-sdk\");",
        "label":1
    },
    {
        "ins1AddCode":"List<List<Class<?>>> typesLists = new ArrayList<>();",
        "ins1DelCode":"List<List<Class<?>>> typesLists = new ArrayList<List<Class<?>>>();",
        "ins1PreCode":"allOverloads.add(ImmutableList.<Class<?>>of(predicateType)); allOverloads.add(ImmutableList.<Class<?>>of(predicateType, Object.class));  List<List<Class<?>>> typesLists = new ArrayList<List<Class<?>>>(); for (int i = 0; i < 2; i++) { typesLists.add(possibleParamTypes);",
        "ins2PreCode":"allOverloads.add(ImmutableList.<Class<?>>of(predicateType)); allOverloads.add(ImmutableList.<Class<?>>of(predicateType, Object.class)); List<List<Class<?>>> typesLists = new ArrayList<List<Class<?>>>(); for (int i = 0; i < 2; i++) { typesLists.add(possibleParamTypes);",
        "label":1
    },
    {
        "ins1AddCode":"sb.append(']');",
        "ins1DelCode":"sb.append(\"]\");",
        "ins1PreCode":"sb.append(methodName); sb.append(\", paramType=\"); sb.append(paramType); sb.append(\"]\"); return sb.toString();",
        "ins2PreCode":"sb.append(methodName); sb.append(\", paramType=\"); sb.append(paramType); sb.append(\"]\"); return sb.toString();",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>(); TestSubscriber<List<Integer>> ts = new TestSubscriber<>();",
        "ins1DelCode":"return new ArrayList<Integer>(); TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();",
        "ins1PreCode":"Supplier<List<Integer>> as = new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();  Flowable.range(1, 100000).hide()",
        "ins2PreCode":"Supplier<List<Integer>> as = new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); Flowable.range(1, 100000)",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void emptyXMap() { TestObserver<Integer> to = new TestObserver<Integer>();  assertTrue(ObservableScalarXMap.tryScalarXMapSubscribe(new EmptyCallablePublisher(), to, new Function<Integer, ObservableSource<Integer>>() {",
        "ins2PreCode":"public void mapperCrashes() { TestObserver<Integer> to = new TestObserver<Integer>(); assertTrue(ObservableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), to, new Function<Integer, ObservableSource<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"}  }).take(1); TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<Integer>(); f.subscribe(subscriber); subscriber.assertValue(0);",
        "ins2PreCode":"} }).take(1); TestObserverEx<Integer> observer = new TestObserverEx<Integer>(); o.subscribe(observer); observer.assertValue(0);",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldGetFirstFourUsers() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getAllUsers(new RowBounds(0, 4)); Assert.assertEquals(4, users.size()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldGetFirstFourUsers_Annotated() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); List<User> users = mapper.getAllUsers(new RowBounds(0, 4)); Assert.assertEquals(4, users.size()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>(subscriber);",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>(subscriber);",
        "ins1PreCode":"Flowable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, testScheduler, other);  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber); source.subscribe(ts); ",
        "ins2PreCode":"Observable<String> source = underlyingSubject.timeout(TIMEOUT, TIME_UNIT, testScheduler, other); Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); source.subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series = new XYSeries<>(\"Test\"); XYDataset ds = new XYSeriesCollection<String>(series);",
        "ins1DelCode":"XYSeries series = new XYSeries(\"Test\"); XYDataset ds = new XYSeriesCollection(series);",
        "ins1PreCode":" double[][] data = createSampleData2();  XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getOLSRegression(ds, 0); ",
        "ins2PreCode":"double[][] data = createSampleData2(); XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getPowerRegression(ds, 0);",
        "label":1
    },
    {
        "ins1AddCode":"throws Exception List depResults = (List) new PluginParameterExpressionEvaluator( session, exec ).evaluate( \"${plugin.artifacts}\" );",
        "ins1DelCode":"throws ExpressionEvaluationException, CycleDetectedException, DuplicateProjectException Logger logger = new ConsoleLogger( Logger.LEVEL_INFO, \"test\" ); List depResults = (List) new PluginParameterExpressionEvaluator( session, exec, pathTranslator, logger, new Properties() ).evaluate( \"${plugin.artifacts}\" );",
        "ins1PreCode":"public void testPluginArtifactsExpressionReference() throws ExpressionEvaluationException, CycleDetectedException, DuplicateProjectException { MojoExecution exec = newMojoExecution();  Artifact depArtifact = factory.createDependencyArtifact( \"group\", \"artifact\", VersionRange.createFromVersion( \"1\" ), \"jar\", null, Artifact.SCOPE_COMPILE );  List<Artifact> deps = new ArrayList<Artifact>(); deps.add( depArtifact );  exec.getMojoDescriptor().getPluginDescriptor().setArtifacts( deps );  MavenSession session = newMavenSession();  Logger logger = new ConsoleLogger( Logger.LEVEL_INFO, \"test\" );  List depResults = (List) new PluginParameterExpressionEvaluator( session, exec, pathTranslator, logger, new Properties() ).evaluate( \"${plugin.artifacts}\" );  System.out.println( \"Result: \" + depResults );",
        "ins2PreCode":"public void testPluginArtifactMapExpressionReference() throws ExpressionEvaluationException, CycleDetectedException, DuplicateProjectException { MojoExecution exec = newMojoExecution(); Artifact depArtifact = factory.createDependencyArtifact( \"group\", \"artifact\", VersionRange.createFromVersion( \"1\" ), \"jar\", null, Artifact.SCOPE_COMPILE ); List<Artifact> deps = new ArrayList<Artifact>(); deps.add( depArtifact ); exec.getMojoDescriptor().getPluginDescriptor().setArtifacts( deps ); MavenSession session = newMavenSession(); Logger logger = new ConsoleLogger( Logger.LEVEL_INFO, \"test\" ); Map depResults = (Map) new PluginParameterExpressionEvaluator( session, exec, new Properties() ).evaluate( \"${plugin.artifactMap}\" ); System.out.println( \"Result: \" + depResults );",
        "label":1
    },
    {
        "ins1AddCode":"String insertIntoEntryQuery = \"INSERT INTO \" + escape(\"ENTRY\") + \"(\" + escape(\"TYPE\") + \") VALUES(?)\"; try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery,",
        "ins1DelCode":"StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\"); try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery.toString(),",
        "ins1PreCode":"protected void insertIntoEntryTable(BibEntry bibEntry) {  StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\");   try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery.toString(), new String[] {\"SHARED_ID\"})) { ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"}, (inputs) -> {",
        "ins1PreCode":".run(assertProperties(\"test\", (properties) -> { assertThat(properties.get(\"dbPassword\")).isEqualTo(\"******\"); assertThat(properties.get(\"myTestProperty\")).isEqualTo(\"654321\"); }, (inputs) -> { }));",
        "ins2PreCode":".withPropertyValues(\"test.keys-to-sanitize=.*pass.*\").run(assertProperties(\"test\", (properties) -> { assertThat(properties.get(\"dbPassword\")).isEqualTo(\"******\"); assertThat(properties.get(\"myTestProperty\")).isEqualTo(\"654321\"); }, (inputs) -> { }));",
        "label":1
    },
    {
        "ins1AddCode":"public Publisher<? extends Integer> apply(Integer v) { public Publisher<? extends Integer> apply(Integer v) { public Completable apply(Integer v) {",
        "ins1DelCode":"public Publisher<? extends Integer> apply(Integer v) throws Exception { public Publisher<? extends Integer> apply(Integer v) throws Exception { public Completable apply(Integer v) throws Exception {",
        "ins1PreCode":" flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.empty(); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Completable.complete().toFlowable(); } });  flowableDedicated = source.switchMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) throws Exception { return Completable.complete(); }",
        "ins2PreCode":"flowablePlain = source.concatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.empty(); } }); flowableConvert = source.concatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Completable.complete().toFlowable(); } }); flowableDedicated = source.concatMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) throws Exception { return Completable.complete(); }",
        "label":1
    },
    {
        "ins1AddCode":"context.notifyBeforeEvaluation(getExpressionString()); MethodInfo result = this.target.getMethodInfo(context); context.notifyAfterEvaluation(getExpressionString()); return result;",
        "ins1DelCode":"return this.target.getMethodInfo(context);",
        "ins1PreCode":"throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException { try { return this.target.getMethodInfo(context); } catch (MethodNotFoundException e) { if (e instanceof JspMethodNotFoundException) throw e;",
        "ins2PreCode":"throws NullPointerException, PropertyNotFoundException, MethodNotFoundException, ELException { try { return this.target.invoke(context, params); } catch (MethodNotFoundException e) { if (e instanceof JspMethodNotFoundException) throw e;",
        "label":0
    },
    {
        "ins1AddCode":"if (c1 == '#' || c1 == '$')  {",
        "ins1DelCode":"if ((c1 == '#' || c1 == '$'))  {",
        "ins1PreCode":"char c = image.charAt(i); if (c == '\\\\' && i + 1 < size) { char c1 = image.charAt(i + 1); if ((c1 == '#' || c1 == '$'))  { c = c1; i++;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (Object o : ticks) { ValueTick tick = (ValueTick) o;",
        "ins1DelCode":"Iterator iterator = ticks.iterator(); while (iterator.hasNext()) { ValueTick tick = (ValueTick) iterator.next();",
        "ins1PreCode":"Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL); g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE); Iterator iterator = ticks.iterator(); while (iterator.hasNext()) { ValueTick tick = (ValueTick) iterator.next(); double v = this.domainAxis.valueToJava2D(tick.getValue(), dataArea, RectangleEdge.BOTTOM);",
        "ins2PreCode":"Object saved = g2.getRenderingHint(RenderingHints.KEY_STROKE_CONTROL); g2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE); Iterator iterator = ticks.iterator(); while (iterator.hasNext()) { ValueTick tick = (ValueTick) iterator.next(); double v = this.rangeAxis.valueToJava2D(tick.getValue(), dataArea, RectangleEdge.LEFT);",
        "label":1
    },
    {
        "ins1AddCode":"void matchWhenHasController() throws Exception {",
        "ins1DelCode":"public void matchWhenHasController() throws Exception {",
        "ins1PreCode":"public void matchWhenHasController() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithController.class); assertThat(excludes(filter, Controller1.class)).isFalse();",
        "ins2PreCode":"public void matchWithIncludeFilter() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithIncludeFilter.class); assertThat(excludes(filter, Controller1.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"if (done || emitter.isDisposed()) {",
        "ins1DelCode":"if (emitter.isDisposed() || done) {",
        "ins1PreCode":"public boolean tryOnError(Throwable t) { if (emitter.isDisposed() || done) { return false; }",
        "ins2PreCode":"public boolean tryOnError(Throwable t) { if (emitter.isCancelled() || done) { return false; }",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result, failedWith(3)); assertThat(result.stderr(), containsString(\"ERROR: No such node 'never_created'\"));",
        "ins1DelCode":"assertThat(result, failedWith(-1)); assertThat(result.stderr(), containsString(\"No such node 'never_created'\"));",
        "ins1PreCode":".invokeWithArgs(\"never_created\") ;  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"No such node 'never_created'\"));",
        "ins2PreCode":".invokeWithArgs(\"never_created\"); .invokeWithArgs(\"never_created\"); assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"No such job 'never_created'\"));",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> firstParts = pairStream.transform(in -> in.map(in2 -> in2._1()));",
        "ins1DelCode":"JavaDStream<Integer> firstParts = pairStream.transform( new Function<JavaPairRDD<Integer, Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaPairRDD<Integer, Integer> in) { return in.map(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> in2) { return in2._1(); } }); } });",
        "ins1PreCode":"ssc, inputData, 1); JavaPairDStream<Integer, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream);  JavaDStream<Integer> firstParts = pairStream.transform( new Function<JavaPairRDD<Integer, Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaPairRDD<Integer, Integer> in) { return in.map(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> in2) { return in2._1(); } }); } });  JavaTestUtils.attachTestOutputStream(firstParts);",
        "ins2PreCode":"ssc, inputData, 1); JavaPairDStream<Integer, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> firstParts = pairStream.transform(in -> in.map(x -> x._1())); JavaPairDStream<Integer, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); Arrays.asList( public void testPairToNormalRDDTransform() { List<List<Tuple2<Integer, Integer>>> inputData = Arrays.asList( Arrays.asList( List<List<Tuple2<Integer, Integer>>> inputData = Arrays.asList( new Tuple2<>(1, 5))); } } } } JavaTestUtils.attachTestOutputStream(firstParts);",
        "label":0
    },
    {
        "ins1AddCode":"void printBannerShouldPrintMargin() {",
        "ins1DelCode":"public void printBannerShouldPrintMargin() {",
        "ins1PreCode":"public void printBannerShouldPrintMargin() { AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\");",
        "ins2PreCode":"public void printBannerWhenHasMarginPropertyShouldPrintSizedMargin() { AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\", \"spring.banner.image.margin=4\");",
        "label":1
    },
    {
        "ins1AddCode":"when(view.getOwner().getItemGroup()).thenReturn(parent);",
        "ins1DelCode":"when(view.getOwnerItemGroup()).thenReturn(parent);",
        "ins1PreCode":"mockStatic(Stapler.class); when(Stapler.getCurrentRequest()).thenReturn(req); View view = mock(View.class); when(view.getOwnerItemGroup()).thenReturn(parent); createMockAncestors(req, createAncestor(j, \"../..\"), createAncestor(view, \".\")); TopLevelItem i = createMockItem(parent, \"job/i/\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Session s = sessions.get(sessionId); if (s == null) { if (log.isInfoEnabled()) { log.info(sm.getString(\"managerBase.sessionNotFound\", sessionId)); }",
        "ins1DelCode":"Session s=sessions.get(sessionId); if( s==null ) { if(log.isInfoEnabled()) log.info(\"Session not found \" + sessionId);",
        "ins1PreCode":"public String getLastAccessedTime( String sessionId ) { Session s=sessions.get(sessionId); if( s==null ) { if(log.isInfoEnabled()) log.info(\"Session not found \" + sessionId); return \"\"; }",
        "ins2PreCode":"public String getCreationTime( String sessionId ) { Session s=sessions.get(sessionId); if( s==null ) { if(log.isInfoEnabled()) log.info(\"Session not found \" + sessionId); return \"\"; }",
        "label":1
    },
    {
        "ins1AddCode":"Answers.CALLS_REAL_METHODS);",
        "ins1DelCode":"withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS));",
        "ins1PreCode":"public void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); given(source.containsDescendantOf(name)) .willReturn(ConfigurationPropertyState.ABSENT);",
        "ins2PreCode":"public void containsDescendantOfWhenAnyIsPresentShouldReturnPresent() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); given(source.containsDescendantOf(name)) .willReturn(ConfigurationPropertyState.ABSENT);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs = Disposable.empty();",
        "ins1DelCode":"Disposable bs = Disposables.empty();",
        "ins1PreCode":"UnicastSubject<Object> p = UnicastSubject.create(); p.onComplete();  Disposable bs = Disposables.empty(); p.onSubscribe(bs); ",
        "ins2PreCode":"UnicastProcessor<Object> p = UnicastProcessor.create(); p.onComplete(); BooleanSubscription bs = new BooleanSubscription(); p.onSubscribe(bs);",
        "label":0
    },
    {
        "ins1AddCode":"void allFieldsPresentDefault() {",
        "ins1DelCode":"public void allFieldsPresentDefault() {",
        "ins1PreCode":"public void allFieldsPresentDefault() { BibEntry e = new BibEntry(StandardEntryType.Article); e.setField(StandardField.AUTHOR, \"abc\");",
        "ins2PreCode":"public void allFieldsPresentOr() { BibEntry e = new BibEntry(StandardEntryType.Article); e.setField(StandardField.AUTHOR, \"abc\");",
        "label":1
    },
    {
        "ins1AddCode":"void specifyQueryTimeoutZeroAndTransactionTimeout() throws SQLException {",
        "ins1DelCode":"public void specifyQueryTimeoutZeroAndTransactionTimeout() throws SQLException {",
        "ins1PreCode":"public void specifyQueryTimeoutZeroAndTransactionTimeout() throws SQLException { doReturn(0).when(configuration).getDefaultStatementTimeout(); ",
        "ins2PreCode":"public void specifyQueryTimeoutAndTransactionTimeoutMinIsQueryTimeout() throws SQLException { doReturn(10).when(configuration).getDefaultStatementTimeout();",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(this.output.toString()).contains( assertThat(this.output.toString())",
        "ins1DelCode":"assertThat(this.out.toString()).contains( assertThat(this.out.toString())",
        "ins1PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.out.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .contains(\"Are you using 'uriVariables'?\"); });",
        "ins2PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.out.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .contains(\"Are you using 'uriVariables'?\"); });",
        "label":0
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.REGULAR_EXPRESSION));",
        "ins1DelCode":"TextFlow description = createDescription(query, false, true);",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public String getTriggerDDL(@NotNull DBRProgressMonitor monitor, @NotNull GenericTrigger sourceObject) throws DBException { if (sourceObject instanceof HANATrigger) { return ((HANATrigger) sourceObject).getDefinition(); }",
        "ins1DelCode":"public String getTriggerDDL(DBRProgressMonitor monitor, GenericTrigger sourceObject) throws DBException {",
        "ins1PreCode":"public String getTriggerDDL(DBRProgressMonitor monitor, GenericTrigger sourceObject) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, sourceObject, \"Read HANA trigger source\")) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<?> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0);",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void assertValueAtInvalidIndex() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  Flowable.just(1, 2).subscribe(ts);",
        "ins2PreCode":"public void assertNeverAtMatchingPredicate() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); Flowable.just(1, 2).subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<>(3); final List<Integer> out = new ArrayList<>();",
        "ins1DelCode":"AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(3); final List<Integer> out = new ArrayList<Integer>();",
        "ins1PreCode":"public void appendOnlyLinkedArrayListForEachWhileBiExact() throws Throwable { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(3);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>();  list.forEachWhile(2, new BiPredicate<Integer, Integer>() {",
        "ins2PreCode":"public void appendOnlyLinkedArrayListForEachWhileBiAll() throws Throwable { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2); list.add(1); list.add(2); list.add(3); final List<Integer> out = new ArrayList<Integer>(); list.forEachWhile(3, new BiPredicate<Integer, Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(expected, bc.toString());",
        "ins1DelCode":"assertEquals(expected, bc.toString());",
        "ins1PreCode":"} else { expected = \"NOTEQUAL\"; } assertEquals(expected, bc.toString()); ",
        "ins2PreCode":"} ctx.addServletMappingDecoded(\"/\", \"bug23950Servlet\"); } assertEquals(\"org.apache.naming.resources.TesterObject\", bc.toString());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"shuffleMemoryManager = ShuffleMemoryManager.create(Long.MAX_VALUE, pageSizeBytes);",
        "ins1PreCode":"MockitoAnnotations.initMocks(this); sparkConf = new SparkConf(); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); shuffleMemoryManager = ShuffleMemoryManager.create(Long.MAX_VALUE, pageSizeBytes); spillFilesCreated.clear(); taskContext = mock(TaskContext.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"(metadata) -> \"Reason: \"",
        "ins1DelCode":"metadata -> \"Reason: \"",
        "ins1PreCode":"report.append(String.format(\"%nThe use of configuration keys that are no longer \" + \"supported was found in the environment:%n%n\")); append(report, content, metadata -> \"Reason: \" + (StringUtils.hasText(metadata.getDeprecation().getReason()) ? metadata.getDeprecation().getReason() : \"none\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair(in -> { List<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) { Tuple2<String, Integer> next = in.next(); out.add(next.swap()); } return out.iterator(); });",
        "ins1DelCode":"JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair( new PairFlatMapFunction<Iterator<Tuple2<String, Integer>>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Iterator<Tuple2<String, Integer>> in) { List<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) { Tuple2<String, Integer> next = in.next(); out.add(next.swap()); } return out.iterator(); } });",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair( new PairFlatMapFunction<Iterator<Tuple2<String, Integer>>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Iterator<Tuple2<String, Integer>> in) { List<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) {",
        "ins2PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair(in -> { Tuple2<String, Integer> next = in.next(); Arrays.asList( LinkedList<Tuple2<Integer, String>> out = new LinkedList<>(); LinkedList<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) {",
        "label":0
    },
    {
        "ins1AddCode":"Map<String, Object> values = new LinkedHashMap<>();",
        "ins1DelCode":"Map<String, Object> values = new LinkedHashMap<String, Object>();",
        "ins1PreCode":"public static Event randomEvent(String type, int numInstances) { Map<String, Object> values = new LinkedHashMap<String, Object>(); values.put(\"count200\", randomIntFrom0to(4000)); values.put(\"count4xx\", randomIntFrom0to(300));",
        "ins2PreCode":"public static Event randomEvent(String type, int numInstances) { Map<String, Object> values = new LinkedHashMap<String, Object>(); values.put(\"count200\", randomIntFrom0to(4000)); values.put(\"count4xx\", randomIntFrom0to(300));",
        "label":1
    },
    {
        "ins1AddCode":"Exceptions.throwIfFatal(ex);",
        "ins1DelCode":"",
        "ins1PreCode":"void drain() { if (getAndIncrement() != 0) { return; }  int missed = 1; final Observer<? super Observable<T>> downstream = this.downstream; final SimplePlainQueue<Object> queue = this.queue; final List<UnicastSubject<T>> windows = this.windows;  for (;;) { if (upstreamCanceled) { queue.clear(); windows.clear(); } else { boolean isDone = upstreamDone; Object o = queue.poll(); boolean isEmpty = o == null;  if (isDone) { if (isEmpty || error.get() != null) { terminateDownstream(downstream); upstreamCanceled = true; continue; } }  if (!isEmpty) { if (o instanceof WindowStartItem) { if (!downstreamDisposed.get()) { @SuppressWarnings(\"unchecked\") B startItem = ((WindowStartItem<B>)o).item;  ObservableSource<V> endSource; try { endSource = Objects.requireNonNull(closingIndicator.apply(startItem), \"The closingIndicator returned a null ObservableSource\"); } catch (Throwable ex) { upstream.dispose(); startObserver.dispose(); resources.dispose(); Exceptions.throwIfFatal(ex); error.tryAddThrowableOrReport(ex); upstreamDone = true; continue; }  windowCount.getAndIncrement(); UnicastSubject<T> newWindow = UnicastSubject.create(bufferSize, this); WindowEndObserverIntercept<T, V> endObserver = new WindowEndObserverIntercept<T, V>(this, newWindow);  downstream.onNext(endObserver);  if (endObserver.tryAbandon()) { newWindow.onComplete(); } else { windows.add(newWindow); resources.add(endObserver); endSource.subscribe(endObserver); } } } else if (o instanceof WindowEndObserverIntercept) { @SuppressWarnings(\"unchecked\") UnicastSubject<T> w = ((WindowEndObserverIntercept<T, V>)o).window;  windows.remove(w); resources.delete((Disposable)o); w.onComplete(); } else { @SuppressWarnings(\"unchecked\") T item = (T)o;  for (UnicastSubject<T> w : windows) { w.onNext(item); } }  continue; } else if (openDone && windows.size() == 0) { upstream.dispose(); startObserver.dispose(); resources.dispose(); terminateDownstream(downstream); upstreamCanceled = true; continue; } }  missed = addAndGet(-missed); if (missed == 0) { break; } }",
        "ins2PreCode":"void drain() { if (getAndIncrement() != 0) { return; } int missed = 1; final Subscriber<? super Flowable<T>> downstream = this.downstream; final SimplePlainQueue<Object> queue = this.queue; final List<UnicastProcessor<T>> windows = this.windows; for (;;) { if (upstreamCanceled) { queue.clear(); windows.clear(); } else { boolean isDone = upstreamDone; Object o = queue.poll(); boolean isEmpty = o == null; if (isDone) { if (isEmpty || error.get() != null) { terminateDownstream(downstream); upstreamCanceled = true; continue; } } if (!isEmpty) { if (o instanceof WindowStartItem) { if (!downstreamCancelled.get()) { @SuppressWarnings(\"unchecked\") B startItem = ((WindowStartItem<B>)o).item; Publisher<V> endSource; try { endSource = Objects.requireNonNull(closingIndicator.apply(startItem), \"The closingIndicator returned a null Publisher\"); } catch (Throwable ex) { upstream.cancel(); resources.dispose(); resources.dispose(); Exceptions.throwIfFatal(ex); error.tryAddThrowableOrReport(ex); upstreamDone = true; continue; } windowCount.getAndIncrement(); UnicastProcessor<T> newWindow = UnicastProcessor.create(bufferSize, this); WindowEndSubscriberIntercept<T, V> endSubscriber = new WindowEndSubscriberIntercept<T, V>(this, newWindow); downstream.onNext(endSubscriber); if (endSubscriber.tryAbandon()) { newWindow.onComplete(); } else { windows.add(newWindow); resources.add(endSubscriber); endSource.subscribe(endSubscriber); } } } else if (o instanceof WindowEndSubscriberIntercept) { @SuppressWarnings(\"unchecked\") UnicastProcessor<T> w = ((WindowEndSubscriberIntercept<T, V>)o).window; windows.remove(w); resources.delete((Disposable)o); w.onComplete(); } else { @SuppressWarnings(\"unchecked\") T item = (T)o; for (UnicastProcessor<T> w : windows) { w.onNext(item); } } continue; } else if (openDone && windows.size() == 0) { upstream.cancel(); resources.dispose(); resources.dispose(); terminateDownstream(downstream); upstreamCanceled = true; continue; } } missed = addAndGet(-missed); if (missed == 0) { break; } }",
        "label":1
    },
    {
        "ins1AddCode":"AbstractProject<?, ?> p = (AbstractProject<?,?>) j.jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"));",
        "ins1DelCode":"AbstractProject<?, ?> p = (AbstractProject) j.jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"));",
        "ins1PreCode":"public void addTriggerSameType() throws Exception { AbstractProject<?, ?> p = (AbstractProject) j.jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\"));  SCMTrigger newTrigger = new SCMTrigger(\"H/5 * * * *\");",
        "ins2PreCode":"public void addTriggerDifferentType() throws Exception { AbstractProject<?, ?> p = (AbstractProject) j.jenkins.createProjectFromXML(\"foo\", getClass().getResourceAsStream(\"AbstractProjectTest/vectorTriggers.xml\")); TimerTrigger newTrigger = new TimerTrigger(\"20 * * * *\");",
        "label":1
    },
    {
        "ins1AddCode":"public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) {",
        "ins1DelCode":"public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) {",
        "ins1PreCode":"}  @Override public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError(); }",
        "ins2PreCode":"} @Override public void dispatchBadRequest(RestRequest request, RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError(); }",
        "label":1
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner .withPropertyValues(\"management.metrics.export.newrelic.api-key=abcde\",",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { context.close(); this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<String>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"public void testReplaceDataset() {   XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1);  LocalListener l = new LocalListener();",
        "ins2PreCode":"public void testReplaceDataset() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1); LocalListener l = new LocalListener();",
        "label":0
    },
    {
        "ins1AddCode":"void shouldNotCacheAllAuthors() {",
        "ins1DelCode":"public void shouldNotCacheAllAuthors() throws Exception {",
        "ins1PreCode":"public void shouldNotCacheAllAuthors() throws Exception { int first; try (SqlSession session = sqlMapper.openSession()) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public static TableXYDataset<String> createTestTableXYDataset() { DefaultTableXYDataset<String> result = new DefaultTableXYDataset<>();",
        "ins1DelCode":"public static TableXYDataset createTestTableXYDataset() { DefaultTableXYDataset result = new DefaultTableXYDataset();",
        "ins1PreCode":"public static TableXYDataset createTestTableXYDataset() { DefaultTableXYDataset result = new DefaultTableXYDataset(); XYSeries<String> series1 = new XYSeries<>(\"Series 1\", false, false); series1.add(1.0, 2.0);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> dataset0 = new DefaultCategoryDataset<>(); DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>();",
        "ins1DelCode":"DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset();",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"set.add(new GrobidCitationFetcher(importFormatPreferences));",
        "ins1PreCode":"set.add(new CiteSeer()); set.add(new DOAJFetcher(importFormatPreferences)); set.add(new IEEE(importFormatPreferences)); set.add(new GrobidCitationFetcher(importFormatPreferences)); return set;",
        "ins2PreCode":"set.add(new Medra()); set.add(new DoiFetcher(importFormatPreferences)); set.add(new DiVA(importFormatPreferences)); set.add(new DoiFetcher(importFormatPreferences)); return set;",
        "label":1
    },
    {
        "ins1AddCode":"System.setProperty(\"loader.path\", \"nested-jars/nested-jar-app.jar!/BOOT-INF/classes/\"); assertThat(ReflectionTestUtils.getField(this.launcher, \"paths\").toString()) .isEqualTo(\"[nested-jars/nested-jar-app.jar!/BOOT-INF/classes/]\"); this.launcher.launch(new String[0]); waitFor(\"Hello World\");",
        "ins1DelCode":"System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); List<Archive> archives = new ArrayList<>(); this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins1PreCode":"void testUserSpecifiedNestedJarPath() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); this.launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"int resultSize = Math.toIntExact((long)numBytes + pad.numBytes * count + remain.numBytes); byte[] data = new byte[resultSize];",
        "ins1DelCode":"byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes];",
        "ins1PreCode":" UTF8String remain = pad.substring(0, spaces - padChars * count);  byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes); int offset = this.numBytes;",
        "ins2PreCode":"UTF8String remain = pad.substring(0, spaces - padChars * count); byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET + offset, numBytes()); offset += pad.numBytes;",
        "label":1
    },
    {
        "ins1AddCode":"void ignoresInvalidSecretInRequest() throws Exception {",
        "ins1DelCode":"public void ignoresInvalidSecretInRequest() throws Exception {",
        "ins1PreCode":"public void ignoresInvalidSecretInRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins2PreCode":"public void invokeRestartWithDefaultSetup() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "label":1
    },
    {
        "ins1AddCode":"if (idx >= 0 && m.javadoc.indexOf(\"Single#\", jdx) != idx) { .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
        "ins1DelCode":"if (idx >= 0) { .append(\"Maybe(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
        "ins1PreCode":"int k = m.javadoc.indexOf(\"{@code Single\", jdx); if (!m.signature.contains(\"Single\") && (j + 3 != idx && k + 7 != idx)) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6;",
        "ins2PreCode":"int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6;",
        "label":0
    },
    {
        "ins1AddCode":"void shouldConditionallyIncludeWhere() throws Exception {",
        "ins1DelCode":"public void shouldConditionallyIncludeWhere() throws Exception {",
        "ins1PreCode":"public void shouldConditionallyIncludeWhere() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldConditionallyExcludeWhere() throws Exception { final String expected = \"SELECT * FROM BLOG\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"SVCBBase.ParameterEch ech = new SVCBBase.ParameterEch(data); assertEquals(HTTPSRecord.ECH, ech.getKey()); assertEquals(data, ech.getData());",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals(ipv4List, ipv4hint.getAddresses());  byte[] data = {'a', 'b', 'c'}; HTTPSRecord.ParameterEchConfig echconfig = new HTTPSRecord.ParameterEchConfig(data); assertEquals(HTTPSRecord.ECHCONFIG, echconfig.getKey()); assertEquals(data, echconfig.getData());  List<Inet6Address> ipv6List =",
        "ins2PreCode":"assertEquals(ipv4List, ipv4hint.getAddresses()); byte[] data = {'a', 'b', 'c'}; SVCBRecord.ParameterEchConfig echconfig = new SVCBRecord.ParameterEchConfig(data); assertEquals(SVCBRecord.ECHCONFIG, echconfig.getKey()); assertEquals(data, echconfig.getData()); List<Inet6Address> ipv6List =",
        "label":1
    },
    {
        "ins1AddCode":"public Observable<? extends Integer> apply(Integer v) { public Observable<? extends Integer> apply(Integer v) { public Maybe<? extends Integer> apply(Integer v) {",
        "ins1DelCode":"public Observable<? extends Integer> apply(Integer v) throws Exception { public Observable<? extends Integer> apply(Integer v) throws Exception { public Maybe<? extends Integer> apply(Integer v) throws Exception {",
        "ins1PreCode":" observablePlain = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } });  observableConvert = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v).toObservable(); } });  observableDedicated = source.concatMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v); }",
        "ins2PreCode":"observablePlain = source.switchMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } }); observableConvert = source.switchMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v).toObservable(); } }); observableDedicated = source.switchMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v); }",
        "label":1
    },
    {
        "ins1AddCode":"Set<Task> unblockedTasks = Hudson.getInstance().getQueue().getUnblockedTasks(); for (AbstractProject tup : Hudson.getInstance().getDependencyGraph().getTransitiveUpstream(this)) { if (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))",
        "ins1DelCode":"DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); for (AbstractProject tup : tups) { if(tup.isBuilding() || tup.isInQueue())",
        "ins1PreCode":"protected AbstractProject getBuildingUpstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); for (AbstractProject tup : tups) { if(tup.isBuilding() || tup.isInQueue()) return tup; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"(sm.getString(\"namingContext.nameNotBound\", name, name.get(0)));",
        "ins1DelCode":"(sm.getString(\"namingContext.nameNotBound\", name.get(0)));",
        "ins1PreCode":" if (entry == null) { throw new NameNotFoundException (sm.getString(\"namingContext.nameNotBound\", name.get(0))); } ",
        "ins2PreCode":"if (entry == null) { throw new NameNotFoundException (sm.getString(\"namingContext.nameNotBound\", name.get(0))); }",
        "label":1
    },
    {
        "ins1AddCode":"} else if (state == AsyncState.READ_WRITE_OP) { state = AsyncState.MUST_COMPLETE;",
        "ins1DelCode":"",
        "ins1PreCode":"} else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\",",
        "ins2PreCode":"state == AsyncState.TIMING_OUT) { state == AsyncState.TIMING_OUT) { state = AsyncState.MUST_DISPATCH; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\",",
        "label":0
    },
    {
        "ins1AddCode":"void findByPrincipal() {",
        "ins1DelCode":"public void findByPrincipal() {",
        "ins1PreCode":"public void findByPrincipal() { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository(); repository.add(new AuditEvent(\"dave\", \"a\"));",
        "ins2PreCode":"public void findByPrincipalAndType() { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository(); repository.add(new AuditEvent(\"dave\", \"a\"));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(2, vm.getStack().pop()); assertEquals(0, vm.getStack().size());",
        "ins1DelCode":"Assert.assertEquals(2, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "ins1PreCode":" List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(2, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "ins2PreCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(1, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "label":1
    },
    {
        "ins1AddCode":"void defaultSnippetsAreWritten() throws Exception {",
        "ins1DelCode":"public void defaultSnippetsAreWritten() throws Exception {",
        "ins1PreCode":"public void defaultSnippetsAreWritten() throws Exception { this.mvc.perform(get(\"/\")).andDo(document(\"default-snippets\")); File defaultSnippetsDir = new File(this.generatedSnippets, \"default-snippets\");",
        "ins2PreCode":"public void defaultSnippetsAreWritten() throws Exception { .consumeWith(document(\"default-snippets\")); File defaultSnippetsDir = new File(this.generatedSnippets, \"default-snippets\");",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Object> to = new TestObserver<>(); FutureTask<Object> ft = new FutureTask<>(new Runnable() {",
        "ins1DelCode":"final TestObserver<Object> to = new TestObserver<Object>(); FutureTask<Object> ft = new FutureTask<Object>(new Runnable() {",
        "ins1PreCode":"public void cancelWhileRunning() { final TestObserver<Object> to = new TestObserver<Object>();  FutureTask<Object> ft = new FutureTask<Object>(new Runnable() { @Override public void run() {",
        "ins2PreCode":"public void cancelAndCrashWhileRunning() { final TestObserver<Object> to = new TestObserver<Object>(); FutureTask<Object> ft = new FutureTask<Object>(new Runnable() { @Override public void run() {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType());",
        "ins1DelCode":"assertEquals(\"article\", entry.getType());",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Tick tick = new NumberTick(currentTickValue, tickLabel, anchor, rotationAnchor, angle);",
        "ins1DelCode":"Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle);",
        "ins1PreCode":"rotationAnchor = TextAnchor.TOP_CENTER; } } Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); ticks.add(tick); }",
        "ins2PreCode":"rotationAnchor = TextAnchor.BOTTOM_CENTER; } } Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); ticks.add(tick); }",
        "label":1
    },
    {
        "ins1AddCode":"TesterLogValidationFilter f = TesterLogValidationFilter.add(null, \"The web application [ROOT] created a ThreadLocal with key of\", null, \"org.apache.catalina.loader.WebappClassLoaderBase\"); (WebappClassLoaderBase) ctx.getLoader().getClassLoader()); (WebappClassLoaderBase) ctx.getLoader().getClassLoader());",
        "ins1DelCode":"TesterLogValidationFilter f = new TesterLogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger( \"org.apache.catalina.loader.WebappClassLoaderBase\").setFilter(f); (WebappClassLoader) ctx.getLoader().getClassLoader()); (WebappClassLoader) ctx.getLoader().getClassLoader());",
        "ins1PreCode":"((ThreadPoolExecutor) executor).setThreadRenewalDelay(-1);   TesterLogValidationFilter f = new TesterLogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger( \"org.apache.catalina.loader.WebappClassLoaderBase\").setFilter(f);    loadClass(\"TesterCounter\", (WebappClassLoader) ctx.getLoader().getClassLoader()); loadClass(\"TesterLeakingServlet1\", (WebappClassLoader) ctx.getLoader().getClassLoader());  ",
        "ins2PreCode":"((ThreadPoolExecutor) executor).setThreadRenewalDelay(-1); TesterLogValidationFilter f = new TesterLogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger( \"org.apache.catalina.loader.WebappClassLoaderBase\").setFilter(f); loadClass(\"TesterCounter\", (WebappClassLoader) ctx.getLoader().getClassLoader()); loadClass(\"TesterLeakingServlet2\", (WebappClassLoader) ctx.getLoader().getClassLoader());",
        "label":1
    },
    {
        "ins1AddCode":"File file = Path.of(",
        "ins1DelCode":"File file = Paths.get(",
        "ins1PreCode":"void testReadProtectedTermsListFromFileReadsDescription() throws URISyntaxException, FileNotFoundException { File file = Paths.get( ProtectedTermsLoader.class.getResource(\"/org/jabref/logic/protectedterms/namedterms.terms\").toURI()) .toFile();",
        "ins2PreCode":"throws URISyntaxException, FileNotFoundException { File file = Paths.get( ProtectedTermsLoader.class.getResource(\"/org/jabref/logic/protectedterms/unnamedterms.terms\") .toFile();",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(expected, res.toString());",
        "ins1DelCode":"assertEquals(expected, res.toString());",
        "ins1PreCode":"tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + path); assertEquals(expected, res.toString());",
        "ins2PreCode":"tomcat.start(); ByteChunk res = getUrl(\"http://localhost:\" + getPort()); Assert.assertTrue(res.toString().contains(\"<p><b>message</b> <u>\" +",
        "label":0
    },
    {
        "ins1AddCode":"void testPropertyContext() {",
        "ins1DelCode":"public void testPropertyContext() {",
        "ins1PreCode":"public void testPropertyContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyContext\");",
        "ins2PreCode":"public void testParametersInAttribute() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyInAttribute\");",
        "label":1
    },
    {
        "ins1AddCode":"label_14: jj_la1[36] = jj_gen; break label_14; jj_la1[37] = jj_gen;",
        "ins1DelCode":"label_12: jj_la1[29] = jj_gen; break label_12; jj_la1[30] = jj_gen;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_12: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[29] = jj_gen; break label_12; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[30] = jj_gen; ; }",
        "ins2PreCode":"case MINUS: case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[40] = jj_gen; break label_15; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[40] = jj_gen; ; }",
        "label":1
    },
    {
        "ins1AddCode":"List<Author> authors = session.selectList(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors\"); List<Author> authors = session.selectList(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors\");",
        "ins1DelCode":"List<Author> authors = session.selectList(\"domain.blog.mappers.AuthorMapper.selectAllAuthors\"); List<Author> authors = session.selectList(\"domain.blog.mappers.AuthorMapper.selectAllAuthors\");",
        "ins1PreCode":"int second = -1; SqlSession session = sqlMapper.openSession(); try { List<Author> authors = session.selectList(\"domain.blog.mappers.AuthorMapper.selectAllAuthors\"); first = System.identityHashCode(authors); } finally { session.close(); } session = sqlMapper.openSession(); try { List<Author> authors = session.selectList(\"domain.blog.mappers.AuthorMapper.selectAllAuthors\"); second = System.identityHashCode(authors); } finally {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return joinWithForwardSlashes(relativePath);",
        "ins1DelCode":"return String.join(File.separator, relativePath) + File.separator;",
        "ins1PreCode":"current = current.getParentFile(); }  return String.join(File.separator, relativePath) + File.separator;",
        "ins2PreCode":"current = current.getParent(); } return String.join(File.separator, relativePath) + File.separator;",
        "label":1
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, \"clean\", \"install\" ) ); assertEquals( \"jar:jar\", executionPlan.get( 8 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"install:install\", executionPlan.get( 9 ).getMojoDescriptor().getFullGoalName() );",
        "ins1DelCode":"List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\", \"install\" ).getExecutions(); assertEquals( \"jar:jar\", executionPlan.get( 8 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"install:install\", executionPlan.get( 9 ).getMojoDescriptor().getFullGoalName() );",
        "ins1PreCode":"MavenSession session = createMavenSession( pom ); assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\", \"install\" ).getExecutions();  ",
        "ins2PreCode":"MavenSession session = createMavenSession( pom ); assertEquals( \"project-with-additional-lifecycle-elements\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"package\" ).getExecutions();",
        "label":1
    },
    {
        "ins1AddCode":"File plugin = new File(dir, \"htmlpublisher.jpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/htmlpublisher.jpi\"),plugin); assertTrue( new File(r.jenkins.getRootDir(),\"plugins/htmlpublisher.jpi\").exists() );",
        "ins1DelCode":"File plugin = new File(dir, \"tasks.jpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/tasks.jpi\"),plugin); assertTrue( new File(r.jenkins.getRootDir(),\"plugins/tasks.jpi\").exists() );",
        "ins1PreCode":"HtmlPage page = r.createWebClient().goTo(\"pluginManager/advanced\"); HtmlForm f = page.getFormByName(\"uploadPlugin\"); File dir = tmp.newFolder(); File plugin = new File(dir, \"tasks.jpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/tasks.jpi\"),plugin); f.getInputByName(\"name\").setValueAttribute(plugin.getAbsolutePath()); r.submit(f);  assertTrue( new File(r.jenkins.getRootDir(),\"plugins/tasks.jpi\").exists() );",
        "ins2PreCode":"HtmlPage page = r.createWebClient().goTo(\"pluginManager/advanced\"); HtmlForm f = page.getFormByName(\"uploadPlugin\"); File dir = tmp.newFolder(); File plugin = new File(dir, \"legacy.hpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/legacy.hpi\"),plugin); f.getInputByName(\"name\").setValueAttribute(plugin.getAbsolutePath()); r.submit(f); assertTrue( new File(r.jenkins.getRootDir(),\"plugins/legacy.jpi\").exists() );",
        "label":0
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\") CategoryPlot<String, String> plot = (CategoryPlot) chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) chart.getPlot();",
        "ins1PreCode":"JFreeChart chart = ChartFactory.createBarChart( \"Test Chart\", \"Category Axis\", \"Value Axis\", dataset, PlotOrientation.VERTICAL, true, true, false); CategoryPlot plot = (CategoryPlot) chart.getPlot(); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private static <K, V> Message newMapEntry(Message.Builder builder, String name, K key, V value) {",
        "ins1DelCode":"Message newMapEntry(Message.Builder builder, String name, KeyType key, ValueType value) {",
        "ins1PreCode":"Message newMapEntry(Message.Builder builder, String name, KeyType key, ValueType value) { FieldDescriptor field = builder.getDescriptorForType().findFieldByName(name); Message.Builder entryBuilder = builder.newBuilderForField(field);",
        "ins2PreCode":"Message newMapEntry(Message.Builder builder, String name, KeyType key, ValueType value) { FieldDescriptor field = builder.getDescriptorForType().findFieldByName(name); Message.Builder entryBuilder = builder.newBuilderForField(field);",
        "label":1
    },
    {
        "ins1AddCode":"BlockPushingListener listener = pushBlocks( verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_2_0\"), any());",
        "ins1DelCode":"BlockFetchingListener listener = pushBlocks( verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"shufflePush_0_2_0\"), any());",
        "ins1PreCode":"blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockFetchingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"shufflePush_0_2_0\"), any());",
        "ins2PreCode":"blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]); BlockFetchingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"shufflePush_0_1_0\"), any());",
        "label":0
    },
    {
        "ins1AddCode":"final FlowableProcessor<Integer> pp = PublishProcessor.<Integer>create(); pp.onNext(2); pp.onComplete(); pp.window(BehaviorProcessor.createDefault(1), Functions.justFunction(Flowable.never())) pp.onNext(1);",
        "ins1DelCode":"final FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create(); ps.onNext(2); ps.onComplete(); ps.window(BehaviorProcessor.createDefault(1), Functions.justFunction(Flowable.never())) ps.onNext(1);",
        "ins1PreCode":"public void reentrant() { final FlowableProcessor<Integer> ps = PublishProcessor.<Integer>create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>() { @Override public void onNext(Integer t) { super.onNext(t); if (t == 1) { ps.onNext(2); ps.onComplete(); } } };  ps.window(BehaviorProcessor.createDefault(1), Functions.justFunction(Flowable.never())) .flatMap(new Function<Flowable<Integer>, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Flowable<Integer> v) throws Exception { return v; } }) .subscribe(ts);  ps.onNext(1);  ts",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (XZInputStream zIn = new XZInputStream(srcResource.getInputStream()); OutputStream out = Files.newOutputStream(dest.toPath())) {",
        "ins1DelCode":"OutputStream out = null; XZInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new XZInputStream(fis); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn);",
        "ins1PreCode":"log(\"Expanding \" + srcResource.getName() + \" to \" + dest.getAbsolutePath());  OutputStream out = null; XZInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new XZInputStream(fis); byte[] buffer = new byte[BUFFER_SIZE]; int count = 0; do { out.write(buffer, 0, count); count = zIn.read(buffer, 0, buffer.length); } while (count != -1); } catch (IOException ioe) { String msg = \"Problem expanding xz \" + ioe.getMessage(); throw new BuildException(msg, ioe, getLocation()); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn); } }",
        "ins2PreCode":"log(\"Expanding \" + srcResource.getName() + \" to \" + dest.getAbsolutePath()); OutputStream out = null; GZIPInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new GZIPInputStream(fis); byte[] buffer = new byte[BUFFER_SIZE]; int count = 0; do { out.write(buffer, 0, count); count = zIn.read(buffer, 0, buffer.length); } while (count != -1); } catch (IOException ioe) { String msg = \"Problem expanding gzip \" + ioe.getMessage(); throw new BuildException(msg, ioe, getLocation()); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn); } }",
        "label":0
    },
    {
        "ins1AddCode":"void parseLevelsTrimsWhitespace() { assertThat(this.output).contains(\"testatdebug\"); assertThat(this.output).contains(\"testattrace\");",
        "ins1DelCode":"public void parseLevelsTrimsWhitespace() { assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "ins1PreCode":"public void parseLevelsTrimsWhitespace() { addPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot= trace \"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "ins2PreCode":"public void parseLevelsWithPlaceholder() { addPropertiesToEnvironment(this.context, \"foo=TRACE\", \"logging.level.org.springframework.boot=${foo}\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "label":1
    },
    {
        "ins1AddCode":"void autoConfiguredHikariDataSourceIsInstrumented() {",
        "ins1DelCode":"public void autoConfiguredHikariDataSourceIsInstrumented() {",
        "ins1PreCode":"public void autoConfiguredHikariDataSourceIsInstrumented() { this.contextRunner.withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class)) .run((context) -> {",
        "ins2PreCode":"public void autoConfiguredHikariDataSourceIsInstrumentedWhenUsingDataSourceInitialization() { .withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class)).run((context) -> { .withConfiguration(AutoConfigurations.of(DataSourceAutoConfiguration.class)).run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"batisConfigReader.close(); batisConfigReader.close(); createScriptReader.close(); conn.close(); session.close();",
        "ins1DelCode":"",
        "ins1PreCode":"try { sqlSessionFactory = new SqlSessionFactoryBuilder().build(batisConfigReader); } catch(Exception anException) { throw new RuntimeException(\"Mapper configuration failed, expected this to work: \" + anException.getMessage(), anException); }  SqlSession session = sqlSessionFactory.openSession();  Connection conn = session.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); Reader createScriptReader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/inline_association_with_dot/create.sql\"); runner.runScript(createScriptReader);  sqlSession = sqlSessionFactory.openSession();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"BibEntry entry1 = new BibEntry() .withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.TITLE, \"Green Scheduling of Whatever\"); assertEquals(\"GreenSchedulingWhatever\", generateKey(entry1, \"[shorttitle]\",",
        "ins1DelCode":"BibEntry entry1 = new BibEntry(); BibEntry entry2 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.TITLE, \"Green Scheduling of Whatever\"); assertEquals(\"GreenSchedulingWhatever\", generateKey(entry1, \"shorttitle\",",
        "ins1PreCode":"void testcrossrefShorttitle() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); BibEntry entry2 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); entry2.setCitationKey(\"entry2\"); database.insertEntry(entry2); database.insertEntry(entry1); entry2.setField(StandardField.TITLE, \"Green Scheduling of Whatever\");  assertEquals(\"GreenSchedulingWhatever\", generateKey(entry1, \"shorttitle\", database));",
        "ins2PreCode":"void testcrossrefShorttitleInitials() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); BibEntry entry2 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); entry2.setCitationKey(\"entry2\"); database.insertEntry(entry2); database.insertEntry(entry1); entry2.setField(StandardField.TITLE, \"Green Scheduling of Whatever\"); assertEquals(\"GSo\", generateKey(entry1, \"shorttitleINI\", database)); database.insertEntry(entry2);",
        "label":1
    },
    {
        "ins1AddCode":"assert (mee.getPropertyName().equals(\"region\")); setSize(Math.max(getMinimumSize().width, getWidth()), Math.max(getMinimumSize().height, getHeight()));",
        "ins1DelCode":"assert(mee.getPropertyName().equals(\"region\")); setSize(getMinimumSize());",
        "ins1PreCode":"protected void modelChanged(PropertyChangeEvent mee) { super.modelChanged(mee);  assert(mee.getPropertyName().equals(\"region\"));  if (mee instanceof AddAssociationEvent) {     Object newRegion = mee.getNewValue(); FigRegion rg = new FigRegion(newRegion); rg.setBounds( regionCompartment.getX(), regionCompartment.getY(), rg.getMinimumSize().width, rg.getMinimumSize().height);         regionCompartment.addFig(rg); setSize(getMinimumSize()); } if (mee instanceof RemoveAssociationEvent) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.paint = SerialUtils.readPaint(stream); this.stroke = SerialUtils.readStroke(stream); this.outlinePaint = SerialUtils.readPaint(stream); this.outlineStroke = SerialUtils.readStroke(stream); this.labelPaint = SerialUtils.readPaint(stream);",
        "ins1DelCode":"this.paint = SerialUtilities.readPaint(stream); this.stroke = SerialUtilities.readStroke(stream); this.outlinePaint = SerialUtilities.readPaint(stream); this.outlineStroke = SerialUtilities.readStroke(stream); this.labelPaint = SerialUtilities.readPaint(stream);",
        "ins1PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.paint = SerialUtilities.readPaint(stream); this.stroke = SerialUtilities.readStroke(stream); this.outlinePaint = SerialUtilities.readPaint(stream); this.outlineStroke = SerialUtilities.readStroke(stream); this.labelPaint = SerialUtilities.readPaint(stream); this.listenerList = new EventListenerList();",
        "ins2PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.labelPaint = SerialUtilities.readPaint(stream); this.axisLineStroke = SerialUtilities.readStroke(stream); this.labelPaint = SerialUtilities.readPaint(stream); this.axisLineStroke = SerialUtilities.readStroke(stream); this.labelPaint = SerialUtilities.readPaint(stream); this.listenerList = new EventListenerList();",
        "label":0
    },
    {
        "ins1AddCode":"this.environment.setProperty(\"logging.file.max-size\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment); initialize(loggingInitializationContext, null, logFile);",
        "ins1DelCode":"MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-size\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); this.loggingSystem.initialize(loggingInitializationContext, null, logFile);",
        "ins1PreCode":"private void testMaxFileSizeProperty(String sizeValue, String expectedFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-size\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\");",
        "ins2PreCode":"void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\");",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd'); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a'); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('h');  assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a');   assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a');",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"buffer.append( \" > \" ); appendForkInfo( buffer, event.getMojoExecution().getMojoDescriptor() );",
        "ins1DelCode":"",
        "ins1PreCode":" buffer.append( \">>> \" ); append( buffer, event.getMojoExecution() ); append( buffer, event.getProject() ); buffer.append( \" >>>\" );  logger.info( \"\" );",
        "ins2PreCode":"buffer.append( \"<<< \" ); append( buffer, event.getMojoExecution() ); append( buffer, event.getProject() ); buffer.append( \"<<< \" ); logger.info( \"\" );",
        "label":1
    },
    {
        "ins1AddCode":".awaitDone(20, TimeUnit.SECONDS)",
        "ins1DelCode":".awaitDone(5, TimeUnit.SECONDS)",
        "ins1PreCode":".subscribeOn(Schedulers.single()) .observeOn(Schedulers.computation()) .test() .awaitDone(5, TimeUnit.SECONDS) .assertValueCount(Flowable.bufferSize()) .assertNoErrors()",
        "ins2PreCode":".subscribeOn(Schedulers.single(), true) .observeOn(Schedulers.computation()) .test() .awaitDone(5, TimeUnit.SECONDS) .assertValueCount(Flowable.bufferSize()) .assertNoErrors()",
        "label":1
    },
    {
        "ins1AddCode":"ObservableWindowSubscribeIntercept<T> intercept = new ObservableWindowSubscribeIntercept<T>(w); downstream.onNext(intercept); if (intercept.tryAbandon()) { w.onComplete(); }",
        "ins1DelCode":"downstream.onNext(w);",
        "ins1PreCode":"window = w; windows.getAndIncrement();  downstream.onNext(w); } }",
        "ins2PreCode":"window = w; windows.getAndIncrement(); downstream.onNext(w); } }",
        "label":1
    },
    {
        "ins1AddCode":"ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference",
        "ins1DelCode":"ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference",
        "ins1PreCode":" assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON));  IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0];  ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject()",
        "ins2PreCode":"assertEquals(mapping, mapper.mappingSource().toString()); ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON)); IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0]; ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject()",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); t = new Thread(new Runnable() { ",
        "ins2PreCode":"public void subscribe(final Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); t = new Thread(new Runnable() {",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<String>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\", \"Range\", dataset);",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createXYStepChart( \"Range\",",
        "label":0
    },
    {
        "ins1AddCode":"protected void registerClusterValve() { container.getPipeline().addValve(valve);",
        "ins1DelCode":"protected void registerClusterValve() throws Exception { IntrospectionUtils.callMethodN(getContainer(), \"addValve\", new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });",
        "ins1PreCode":"protected void registerClusterValve() throws Exception { if(container != null ) { for (Iterator<Valve> iter = valves.iterator(); iter.hasNext();) { ClusterValve valve = (ClusterValve) iter.next(); if (log.isDebugEnabled()) log.debug(\"Invoking addValve on \" + getContainer() + \" with class=\" + valve.getClass().getName()); if (valve != null) { IntrospectionUtils.callMethodN(getContainer(), \"addValve\", new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class });  valve.setCluster(this); }",
        "ins2PreCode":"protected void unregisterClusterValve() throws Exception { if (valve != null) { for (Iterator<Valve> iter = valves.iterator(); iter.hasNext();) { ClusterValve valve = (ClusterValve) iter.next(); if (log.isDebugEnabled()) log.debug(\"Invoking removeValve on \" + getContainer() + \" with class=\" + valve.getClass().getName()); if (valve != null) { IntrospectionUtils.callMethodN(getContainer(), \"removeValve\", new Object[] { valve }, new Class[] { org.apache.catalina.Valve.class }); valve.setCluster(this); }",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\"); KMeans kmeans = new KMeans().setK(2).setSeed(1L); double WSSSE = model.computeCost(dataset); System.out.println(\"Within Set Sum of Squared Errors = \" + WSSSE);",
        "ins1DelCode":"if (args.length != 2) { System.err.println(\"Usage: ml.JavaKMeansExample <file> <k>\"); System.exit(1); } String inputFile = args[0]; int k = Integer.parseInt(args[1]); JavaRDD<Row> points = spark.read().text(inputFile).javaRDD().map(new ParsePoint()); StructField[] fields = {new StructField(\"features\", new VectorUDT(), false, Metadata.empty())}; StructType schema = new StructType(fields); Dataset<Row> dataset = spark.createDataFrame(points, schema); KMeans kmeans = new KMeans() .setK(k);",
        "ins1PreCode":"public static void main(String[] args) { if (args.length != 2) { System.err.println(\"Usage: ml.JavaKMeansExample <file> <k>\"); System.exit(1); } String inputFile = args[0]; int k = Integer.parseInt(args[1]);   SparkSession spark = SparkSession .builder() .appName(\"JavaKMeansExample\") .getOrCreate();    JavaRDD<Row> points = spark.read().text(inputFile).javaRDD().map(new ParsePoint()); StructField[] fields = {new StructField(\"features\", new VectorUDT(), false, Metadata.empty())}; StructType schema = new StructType(fields); Dataset<Row> dataset = spark.createDataFrame(points, schema);   KMeans kmeans = new KMeans() .setK(k); KMeansModel model = kmeans.fit(dataset); ",
        "ins2PreCode":"public static void main(String[] args) { for (Vector center : centers) { System.out.println(\"Cluster Centers: \"); System.out.println(center); } System.out.println(center); spark.stop(); SparkSession spark = SparkSession .builder() .appName(\"JavaBisectingKMeansExample\") .getOrCreate(); Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\"); BisectingKMeans bkm = new BisectingKMeans().setK(2).setSeed(1); BisectingKMeans bkm = new BisectingKMeans().setK(2).setSeed(1); Dataset<Row> dataset = spark.read().format(\"libsvm\").load(\"data/mllib/sample_kmeans_data.txt\"); BisectingKMeans bkm = new BisectingKMeans().setK(2).setSeed(1); spark.stop(); BisectingKMeansModel model = bkm.fit(dataset);",
        "label":0
    },
    {
        "ins1AddCode":"Map<Integer, String> expected = new HashMap<>();",
        "ins1DelCode":"Map<Integer, String> expected = new HashMap<Integer, String>();",
        "ins1PreCode":" Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toObservable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\"); expected.put(2, \"bb\");",
        "ins2PreCode":"Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toObservable(); Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\"); expected.put(2, \"bbbb\");",
        "label":1
    },
    {
        "ins1AddCode":"if (len != len2 || b1 == null || b2 == null) {",
        "ins1DelCode":"if (len2 != len || b1 == null || b2 == null) {",
        "ins1PreCode":"}  int len = end - start; if (len2 != len || b1 == null || b2 == null) { return false; }",
        "ins2PreCode":"} int len = end - start; if (b1 == null && b2 == null) { return false; }",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.runs.get(0).getEntryId());",
        "ins1DelCode":"Assert.assertEquals(10, historyPageFilter.runs.get(0).getEntryId());",
        "ins1PreCode":" Assert.assertEquals(12, historyPageFilter.queueItems.get(0).getEntryId()); Assert.assertEquals(12, historyPageFilter.newestOnPage); Assert.assertEquals(10, historyPageFilter.runs.get(0).getEntryId());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Path texFile = Path.of(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI());",
        "ins1DelCode":"Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI());",
        "ins1PreCode":"public void testFileEncodingIso88591() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI());  LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "ins2PreCode":"public void testFileEncodingIso885915() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-15.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "label":1
    },
    {
        "ins1AddCode":"Integer result = AccessController.doPrivileged( new PrivilegedReadArray(ib, b, off, len));",
        "ins1DelCode":"Integer result = AccessController .doPrivileged(new PrivilegedExceptionAction<Integer>() { @Override public Integer run() throws IOException { Integer integer = Integer.valueOf(ib.read(b, off, len)); return integer; } });",
        "ins1PreCode":" if (SecurityUtil.isPackageProtectionEnabled()) { try { Integer result = AccessController .doPrivileged(new PrivilegedExceptionAction<Integer>() {  @Override public Integer run() throws IOException { Integer integer = Integer.valueOf(ib.read(b, off, len)); return integer; }  }); return result.intValue(); } catch (PrivilegedActionException pae) {",
        "ins2PreCode":"if (SecurityUtil.isPackageProtectionEnabled()) { try { Integer result = AccessController .doPrivileged(new PrivilegedExceptionAction<Integer>() { @Override public Integer run() throws IOException { Integer integer = Integer.valueOf(ib.read(b)); return integer; } }); return result.intValue(); } catch (PrivilegedActionException pae) {",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testSelectLike() { SqlSession sqlSession = sqlSessionFactory.openSession(); try {  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.selectLike\", \"Ba\");  assertTrue(answer.size() == 2); assertEquals(new Integer(4), answer.get(0).get(\"ID\")); assertEquals(new Integer(6), answer.get(1).get(\"ID\"));  } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testOgnlStaticMethodCall() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.ognlStaticMethodCall\", \"Rock 'n Roll\"); assertTrue(answer.size() == 1); assertEquals(new Integer(7), answer.get(0).get(\"ID\")); assertEquals(new Integer(7), answer.get(0).get(\"ID\")); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"public void exceptionsIncludeClassPackaging() { String fileContents = contentOf(new File(tmpDir() + \"/spring.log\"));",
        "ins1DelCode":"public void exceptionsIncludeClassPackaging() throws Exception { String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\")));",
        "ins1PreCode":"public void exceptionsIncludeClassPackaging() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins2PreCode":"public void exceptionsIncludeClassPackaging() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs = Disposable.empty();",
        "ins1DelCode":"Disposable bs = Disposables.empty();",
        "ins1PreCode":"} s.onComplete();  Disposable bs = Disposables.empty(); s.onSubscribe(bs); assertTrue(bs.isDisposed());",
        "ins2PreCode":"} s.onComplete(); BooleanSubscription bs = new BooleanSubscription(); s.onSubscribe(bs); assertTrue(bs.isCancelled());",
        "label":0
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":"CategoryDataset<String, String> newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "ins2PreCode":"= DatasetUtils.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "label":1
    },
    {
        "ins1AddCode":"final DummyMailServer testMailServer = DummyMailServer.startMailServer(this.local); final ClientThread testMailClient; try { testMailClient = new ClientThread(testMailServer.getPort()); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\"); Thread client = new Thread(testMailClient); client.start(); client.join(30 * 1000); } finally { testMailServer.disconnect(); }",
        "ins1DelCode":"final int port = TEST_PORT + 4; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start(); ClientThread testMailClient = new ClientThread(port); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\"); Thread client = new Thread(testMailClient); client.start(); server.join(60 * 1000); client.join(30 * 1000);",
        "ins1PreCode":"public void testBccOnly() throws InterruptedException { final int port = TEST_PORT + 4; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread(port);  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000); ",
        "ins2PreCode":"public void testNoSubject() throws InterruptedException { final int port = TEST_PORT + 5; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start(); ClientThread testMailClient = new ClientThread(port); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.to(\"to@you.com\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\"); Thread client = new Thread(testMailClient); client.start(); server.join(60 * 1000); client.join(30 * 1000);",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairRDD<Integer, int[]> pairRDD = rdd.mapToPair(x -> new Tuple2<>(x, new int[]{x}));",
        "ins1DelCode":"JavaPairRDD<Integer, int[]> pairRDD = rdd.mapToPair( new PairFunction<Integer, Integer, int[]>() { @Override public Tuple2<Integer, int[]> call(Integer x) { return new Tuple2<>(x, new int[]{x}); } });",
        "ins1PreCode":"public void collectAsMapWithIntArrayValues() {  JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1)); JavaPairRDD<Integer, int[]> pairRDD = rdd.mapToPair( new PairFunction<Integer, Integer, int[]>() { @Override public Tuple2<Integer, int[]> call(Integer x) { return new Tuple2<>(x, new int[]{x}); } }); pairRDD.collect(); pairRDD.collectAsMap();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (InputStream inExpect = new BufferedInputStream(Files.newInputStream(expect.toPath())); InputStream inResult = new BufferedInputStream(Files.newInputStream(result.toPath()))) {",
        "ins1DelCode":"try (InputStream inExpect = new BufferedInputStream(new FileInputStream(expect)); InputStream inResult = new BufferedInputStream(new FileInputStream(result))) {",
        "ins1PreCode":"public void assertEqualContent(File expect, File result) throws IOException { assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists());  try (InputStream inExpect = new BufferedInputStream(new FileInputStream(expect)); InputStream inResult = new BufferedInputStream(new FileInputStream(result))) { int expectedByte = inExpect.read(); while (expectedByte != -1) {",
        "ins2PreCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { assertTrue(\"Expected file \" + result + \" doesn\\'t exist\", result.exists()); try (InputStream inExpect = new BufferedInputStream(new FileInputStream(expect)); InputStream inResult = new BufferedInputStream(new FileInputStream(result))) { int expectedByte = inExpect.read(); while (expectedByte != -1) {",
        "label":1
    },
    {
        "ins1AddCode":"protected void insertIntoEntryTable(List<BibEntry> bibEntries) { StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\"); for (int i = 0; i < bibEntries.size() - 1; i++) { insertIntoEntryQuery.append(\", (?)\"); } try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery.toString(), for (int i = 0; i < bibEntries.size(); i++) { preparedEntryStatement.setString(i + 1, bibEntries.get(i).getType().getName()); } for (BibEntry bibEntry : bibEntries) { generatedKeys.next(); bibEntry.getSharedBibEntryData().setSharedID(generatedKeys.getInt(1)); } LOGGER.error(\"Error: Some shared IDs left unassigned\");",
        "ins1DelCode":"protected void insertIntoEntryTable(BibEntry bibEntry) { String insertIntoEntryQuery = \"INSERT INTO \" + escape(\"ENTRY\") + \"(\" + escape(\"TYPE\") + \") VALUES(?)\"; try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery, preparedEntryStatement.setString(1, bibEntry.getType().getName()); bibEntry.getSharedBibEntryData().setSharedID(generatedKeys.getInt(1));",
        "ins1PreCode":"protected void insertIntoEntryTable(BibEntry bibEntry) {  String insertIntoEntryQuery = \"INSERT INTO \" + escape(\"ENTRY\") + \"(\" + escape(\"TYPE\") + \") VALUES(?)\";  try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery, new String[]{\"SHARED_ID\"})) {  preparedEntryStatement.setString(1, bibEntry.getType().getName()); preparedEntryStatement.executeUpdate(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession session = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession session = sqlSessionFactory.openSession(); try { } finally { session.close();",
        "ins1PreCode":"public void shouldExecuteBoundSelectOneBlogStatementWithConstructor() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); Blog blog = mapper.selectBlogUsingConstructor(1); assertEquals(1, blog.getId()); assertEquals(\"Jim Business\", blog.getTitle()); assertNotNull(\"author should not be null\", blog.getAuthor()); List<Post> posts = blog.getPosts(); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldExecuteBoundSelectOneBlogStatementWithConstructorUsingXMLConfig() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); Blog blog = mapper.selectBlogByIdUsingConstructor(1); assertEquals(1, blog.getId()); assertEquals(\"Jim Business\", blog.getTitle()); assertNotNull(\"author should not be null\", blog.getAuthor()); List<Post> posts = blog.getPosts(); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"} else if (value instanceof Float) { return (float)value; throw new ClassCastException( \"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to float\");",
        "ins1DelCode":"return (float)value;",
        "ins1PreCode":"return (int)value; } else if (value instanceof Long) { return (long)value; } else { return (float)value; }",
        "ins2PreCode":"return (int)value; } else if (value instanceof Long) { return (long)value; } else { return (float)value; }",
        "label":1
    },
    {
        "ins1AddCode":"assert (Model.getFacade().isAElement(target)); Collection bases = Model.getFacade().getBases(getTarget()); Iterator it = bases.iterator(); while (it.hasNext()) { Object base = it.next(); base, \"feature\"); } Model.getPump().addModelEventListener( this, getTarget(), \"base\"); removeAllElements(); setBuildingModel(true); buildModelList(); setBuildingModel(false); if (getSize() > 0) { fireIntervalAdded(this, 0, getSize() - 1);",
        "ins1DelCode":"assert (!(getTarget() instanceof Fig)); target = target instanceof Fig ? ((Fig) target).getOwner() : target; if (!Model.getFacade().isAModelElement(target)) return; if (getTarget() != null) { Collection bases = Model.getFacade().getBases(getTarget()); Iterator it = bases.iterator(); while (it.hasNext()) { Object base = it.next(); Model.getPump().addModelEventListener( this, base, \"feature\"); } getTarget(), \"base\"); removeAllElements(); setBuildingModel(true); buildModelList(); setBuildingModel(false); if (getSize() > 0) { fireIntervalAdded(this, 0, getSize() - 1); }",
        "ins1PreCode":"protected void setTarget(Object target) { assert (getTarget() == null); assert (!(getTarget() instanceof Fig));  target = target instanceof Fig ? ((Fig) target).getOwner() : target; if (!Model.getFacade().isAModelElement(target))   return;  setListTarget(target); if (getTarget() != null) { Collection bases = Model.getFacade().getBases(getTarget()); Iterator it = bases.iterator();",
        "ins2PreCode":"protected void setTarget(Object theNewTarget) { assert (getTarget() == null); assert (!(getTarget() instanceof Fig)); ? ((Fig) theNewTarget).getOwner() : theNewTarget; if (Model.getFacade().isAModelElement(theNewTarget) setBuildingModel(true); setListTarget(theNewTarget); if (getTarget() != null) { Collection bases = Model.getFacade().getBases(getTarget()); Iterator it = bases.iterator();",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts = new TestSubscriber<>(2L);",
        "ins1DelCode":"final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(2L);",
        "ins1PreCode":"public void syncFusedCancelAfterRequest2() { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(2L);  Flowable.range(1, 2)",
        "ins2PreCode":"public void syncFusedCancelAfterRequestConditional2() { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(2L); Flowable.range(1, 2)",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\"); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\"));",
        "ins1DelCode":"if (!supportsSymlinks) { return; } if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } getProject().executeTarget(\"symlink-setup\"); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\"));",
        "ins1PreCode":"public void testAllowSymlinks() { if (!supportsSymlinks) { return; } if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } getProject().executeTarget(\"symlink-setup\"); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/beta/gamma/\"}); ds.setFollowSymlinks(true);",
        "ins2PreCode":"public void testProhibitSymlinks() { if (!supportsSymlinks) { return; } if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } getProject().executeTarget(\"symlink-setup\"); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/beta/gamma/\"}); ds.setFollowSymlinks(false);",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmptyError() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() {",
        "ins2PreCode":"public void observerCheckTerminatedNonDelayErrorError() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty()); ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name ok\", res.toString()); Assert.assertEquals(\"Cookie name ok\", res.toString()); Assert.assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader);",
        "ins1DelCode":"assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader);",
        "ins1PreCode":"tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "ins2PreCode":"tomcat.start(); ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); tomcat.start(); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); public void testCookiesInstance() throws Exception { assertEquals(\"Cookie name fail\", res.toString()); }",
        "label":1
    },
    {
        "ins1AddCode":"Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication());",
        "ins1DelCode":"Hudson.getInstance().checkPermission(Hudson.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Hudson.getAuthentication());",
        "ins1PreCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { requirePOST(); Hudson.getInstance().checkPermission(Hudson.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Hudson.getAuthentication()); if(!Lifecycle.get().canRewriteHudsonWar()) { sendError(\"Jenkins upgrade not supported in this running mode\");",
        "ins2PreCode":"public void doRestart(StaplerResponse rsp) throws IOException, ServletException { rsp.sendRedirect2(\".\"); Hudson.getInstance().checkPermission(Hudson.ADMINISTER); HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Hudson.getAuthentication()); LOGGER.info(\"Scheduling the core downgrade\"); HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Hudson.getAuthentication());",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"5.0\", desc.getVersion());",
        "ins1DelCode":"Assert.assertEquals(\"4.0\", desc.getVersion());",
        "ins1PreCode":"digester.push(new WebXml()); WebXml desc = (WebXml) digester.parse( new File(\"test/webapp/WEB-INF/web.xml\")); Assert.assertEquals(\"4.0\", desc.getVersion()); Assert.assertEquals(0, handler.getErrors().size()); Assert.assertEquals(0, handler.getWarnings().size());",
        "ins2PreCode":"digester.push(new WebXml()); WebXml desc = (WebXml) digester.parse( new File(\"test/webapp-2.5/WEB-INF/web.xml\")); Assert.assertEquals(\"2.5\", desc.getVersion()); Assert.assertEquals(0, handler.getErrors().size()); Assert.assertEquals(0, handler.getWarnings().size());",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.NONE);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.NONE);",
        "ins1PreCode":"public void nonfusedError() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.NONE);  TakeLast source = new TakeLast(to);",
        "ins2PreCode":"public void fusedError() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); TakeLast source = new TakeLast(to);",
        "label":1
    },
    {
        "ins1AddCode":"String otype = (String) options.get(LockGraphManager.keyType); case LockGraphManager.typeWait: case LockGraphManager.typeHold:",
        "ins1DelCode":"String otype = (String) options.get(LockManagerViewer.keyType); case LockManagerViewer.typeWait: case LockManagerViewer.typeHold:",
        "ins1PreCode":" try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockManagerViewer.keyType);  switch(otype) { case LockManagerViewer.typeWait: dbStat.setBigDecimal(1, new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidWait))); break; case LockManagerViewer.typeHold: dbStat.setBigDecimal(1,  new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidHold))); break;",
        "ins2PreCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) { String otype = (String) options.get(LockManagerViewer.keyType); switch (otype) { case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(PostgreLockEditor.pidWait)); break; case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(PostgreLockEditor.pidHold)); break;",
        "label":0
    },
    {
        "ins1AddCode":"verify(factory, times(1)).createMetadataReader(any(Resource.class));",
        "ins1DelCode":"verify(factory, times(1)).createMetadataReader((Resource) any());",
        "ins1PreCode":"MetadataReader metadataReader1 = factory.getMetadataReader(getClass().getName()); MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isSameAs(metadataReader2); verify(factory, times(1)).createMetadataReader((Resource) any());",
        "ins2PreCode":"MetadataReader metadataReader1 = factory.getMetadataReader(getClass().getName()); MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isNotEqualTo(sameInstance(metadataReader2)); verify(factory, times(2)).createMetadataReader((Resource) any());",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Subscriber<?>> subscriber = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Subscriber<?>> subscriber = new AtomicReference<Subscriber<?>>();",
        "ins1PreCode":"public void onErrorMainOverflow() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<?>> subscriber = new AtomicReference<Subscriber<?>>(); TestSubscriber<Integer> ts = new Flowable<Integer>() { @Override",
        "ins2PreCode":"public void onErrorMainOverflow() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<?>> subscriber = new AtomicReference<Subscriber<?>>(); TestSubscriber<Integer> ts = new Flowable<Integer>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"void testNamingResults() {",
        "ins1DelCode":"public void testNamingResults() {",
        "ins1PreCode":"public void testNamingResults() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins2PreCode":"public void testResultsOnlyForNaming() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"\"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Float.class.getCanonicalName());",
        "ins1DelCode":"\"def [\" + value.getClass().getCanonicalName() + \"] to \" + Float.class.getCanonicalName());",
        "ins1PreCode":"return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Float.class.getCanonicalName()); }",
        "ins2PreCode":"return ((Number)value).doubleValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Double.class.getCanonicalName()); }",
        "label":1
    },
    {
        "ins1AddCode":"StandardXYToolTipGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"StandardXYToolTipGenerator g2 = (StandardXYToolTipGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StandardXYToolTipGenerator g1 = new StandardXYToolTipGenerator(); StandardXYToolTipGenerator g2 = (StandardXYToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerToolTipGenerator g1 = new BoxAndWhiskerToolTipGenerator(); BoxAndWhiskerToolTipGenerator g2 = (BoxAndWhiskerToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"this.bootstrapRegistry, Arrays.asList(contributor));",
        "ins1DelCode":"Arrays.asList(contributor));",
        "ins1PreCode":"propertySource.setProperty(\"test\", \"springboot\"); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext); assertThat(binder.bind(\"test\", String.class).get()).isEqualTo(\"springboot\");",
        "ins2PreCode":"propertySource.setProperty(\"other\", \"springboot\"); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext); assertThat(binder.bind(\"test\", String.class).get()).isEqualTo(\"springboot\");",
        "label":1
    },
    {
        "ins1AddCode":"if ( src != null ) tgt.setLocation( \"\", src.getLocation( \"\" ) );",
        "ins1DelCode":"if ( source.getOrganization() != null )",
        "ins1PreCode":"Map<Object, Object> context ) { Organization src = source.getOrganization(); if ( source.getOrganization() != null ) { Organization tgt = target.getOrganization();",
        "ins2PreCode":"Map<Object, Object> context ) { Organization src = source.getOrganization(); if ( source.getOrganization() != null ) { Organization tgt = target.getOrganization();",
        "label":1
    },
    {
        "ins1AddCode":"protected void doWrite(boolean block, ByteBuffer buffer) throws IOException { int n = 0; do { n = socket.write(buffer); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) { } writeBlocking = false; throw new SocketTimeoutException(); writeBlocking = false; } } while (buffer.hasRemaining()); n = socket.write(buffer); } while (n > 0 && buffer.hasRemaining());",
        "ins1DelCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { try { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) { } if (writeBlocking) { throw new SocketTimeoutException(); } } while (from.hasRemaining()); } finally { writeBlocking = false; } int n = 0; n = socket.write(from); } while (n > 0 && from.hasRemaining());",
        "ins1PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { long timeout = getWriteTimeout(); try { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { writeBlocking = false; }     } else { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } } while (n > 0 && from.hasRemaining()); } updateLastWrite();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 30000,",
        "ins1DelCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 3000,",
        "ins1PreCode":"private void assertPageContains(String pageUrl, String expectedBody, int expectedStatus) throws IOException { ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 3000, null, null); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result.block(Duration.ofSeconds(30))).isEqualTo(\"Hello World\");",
        "ins1DelCode":"assertThat(result.block()).isEqualTo(\"Hello World\");",
        "ins1PreCode":"Mono<String> result = client.post().uri(\"/test\").contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(\"Hello World\")).exchange() .flatMap((response) -> response.bodyToMono(String.class)); assertThat(result.block()).isEqualTo(\"Hello World\");",
        "ins2PreCode":"Mono<String> result = client.post().uri(\"/test\").contentType(MediaType.TEXT_PLAIN) .body(BodyInserters.fromObject(\"Hello World\")).exchange() .flatMap((response) -> response.bodyToMono(String.class)); .body(BodyInserters.fromObject(\"Hello World\")).exchange()",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(dataset,",
        "ins1DelCode":"XYPlot plot = new XYPlot(dataset,",
        "ins1PreCode":"s2.add(15.0, 9.5); s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new StackedXYAreaRenderer());",
        "ins2PreCode":"s2.add(15.0, 9.5); s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new XYAreaRenderer2());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertSame(Flowable.empty(), Maybe.mergeArrayDelayError());",
        "ins1PreCode":".test() .assertFailure(TestException.class, 1);  assertSame(Flowable.empty(), Maybe.mergeArrayDelayError());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (++calls == 2) { throw new TestException(); } return new ArrayList<Integer>(); } }).test();",
        "ins2PreCode":"if (++calls == 2) { throw new TestException(); } return new ArrayList<Integer>(); } }).test();",
        "label":1
    },
    {
        "ins1AddCode":"LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.ALL); try { enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface(); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace(); sendLargeGetRequest(3); sendSimpleGetRequest(5); for (int i = 0; i < 9; i++) { parser.readFrame(true); } Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace(); sendRst(3, Http2Error.NO_ERROR.getCode()); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace(); sendWindowUpdate(0, (1 << 31) - 2); sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace()); } finally { LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.INFO);",
        "ins1DelCode":"enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface(); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace(); sendLargeGetRequest(3); sendSimpleGetRequest(5); for (int i = 0; i < 9; i++) { Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace(); sendRst(3, Http2Error.NO_ERROR.getCode()); parser.readFrame(true); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace(); sendWindowUpdate(0, (1 << 31) - 2); sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "ins1PreCode":"public void testExceedMaxActiveStreams02() throws Exception {   enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendRst(3, Http2Error.NO_ERROR.getCode());   parser.readFrame(true); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace();   sendWindowUpdate(0, (1 << 31) - 2);   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Dataset<Row> dataset = jsql.createDataFrame(data, schema);",
        "ins1DelCode":"DataFrame dataset = jsql.createDataFrame(data, schema);",
        "ins1PreCode":"StructType schema = new StructType(new StructField[] { new StructField(\"raw\", DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty()) }); DataFrame dataset = jsql.createDataFrame(data, schema);  remover.transform(dataset).collect();",
        "ins2PreCode":"StructType schema = new StructType(new StructField[]{ \"raw\", DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty()) }); DataFrame dataset = jsql.createDataFrame(rdd, schema); remover.transform(dataset).show();",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"sqlSession.clearCache();",
        "ins1PreCode":"assertEquals((Integer) 5, parameter.getSum());   sqlSession.clearCache();  parameter = new Parameter();",
        "ins2PreCode":"assertEquals((Integer) 5, parameter.getSum()); sqlSession.close(); parameter = new Parameter();",
        "label":0
    },
    {
        "ins1AddCode":"XYSeriesCollection<String> d1 = new XYSeriesCollection<>(); XYSeries<String> s1 = new XYSeries<>(\"S1\"); XYSeries<String> s2 = new XYSeries<>(\"S2\"); XYSeriesCollection<String> d2 = new XYSeriesCollection<>(); XYSeries<String> s3 = new XYSeries<>(\"S3\"); XYSeries<String> s4 = new XYSeries<>(\"S4\"); XYSeries<String> s5 = new XYSeries<>(\"S5\");",
        "ins1DelCode":"XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); XYSeries s2 = new XYSeries(\"S2\"); XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); XYSeries s4 = new XYSeries(\"S4\"); XYSeries s5 = new XYSeries(\"S5\");",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); XYSeries s2 = new XYSeries(\"S2\"); s2.add(1.0, 1.1); d1.addSeries(s1); d1.addSeries(s2);  XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); s3.add(1.0, 1.1); XYSeries s4 = new XYSeries(\"S4\"); s4.add(1.0, 1.1); XYSeries s5 = new XYSeries(\"S5\"); s5.add(1.0, 1.1); d2.addSeries(s3);",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); XYSeries s2 = new XYSeries(\"S2\"); s2.add(1.0, 1.1); d1.addSeries(s1); d1.addSeries(s2); XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); s3.add(1.0, 1.1); XYSeries s4 = new XYSeries(\"S4\"); s4.add(1.0, 1.1); XYSeries s5 = new XYSeries(\"S5\"); s5.add(1.0, 1.1); d2.addSeries(s3);",
        "label":1
    },
    {
        "ins1AddCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1DelCode":"h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"ParallelFailureHandling h; try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":1
    },
    {
        "ins1AddCode":"protected SendfileState processSendfile(SendfileData sendfile) { if (sendfile != null) { try (FileChannel channel = FileChannel.open(sendfile.path, StandardOpenOption.READ)) { sendfile.streamReservation  = sendfile.stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation); boolean finished = (frameSize == sendfile.left) && sendfile.stream.getCoyoteResponse().getTrailerFields() == null; boolean writeable = sendfile.stream.canWrite(); sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue());",
        "ins1DelCode":"protected SendfileState processSendfile(Stream stream) { String fileName = (String) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR); if (fileName != null) { java.nio.file.Path path = new File(fileName).toPath(); SendfileData sendfile = new SendfileData(); sendfile.pos = ((Long) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue(); sendfile.end = ((Long) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue(); sendfile.left = sendfile.end - sendfile.pos; try (FileChannel channel = FileChannel.open(path, StandardOpenOption.READ)) { sendfile.stream = stream; sendfile.streamReservation  = stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(stream, sendfile.streamReservation); boolean finished = (frameSize == sendfile.left) && stream.getCoyoteResponse().getTrailerFields() == null; boolean writeable = stream.canWrite(); stream.sentEndOfStream(); if (!stream.isActive()) { ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue());",
        "ins1PreCode":"protected SendfileState processSendfile(Stream stream) { String fileName = (String) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR); if (fileName != null) { java.nio.file.Path path = new File(fileName).toPath(); SendfileData sendfile = new SendfileData(); sendfile.pos = ((Long) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue(); sendfile.end = ((Long) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue(); sendfile.left = sendfile.end - sendfile.pos; try { try (FileChannel channel = FileChannel.open(path, StandardOpenOption.READ)) { sendfile.mappedBuffer = channel.map(MapMode.READ_ONLY, sendfile.pos, sendfile.end - sendfile.pos); sendfile.stream = stream; }  int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation  = stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(stream, sendfile.streamReservation); } catch (IOException e) { return SendfileState.ERROR; }  int frameSize = Integer.min(getMaxFrameSize(), sendfile.connectionReservation); boolean finished = (frameSize == sendfile.left) && stream.getCoyoteResponse().getTrailerFields() == null;   boolean writeable = stream.canWrite(); byte[] header = new byte[9]; ByteUtil.setThreeBytes(header, 0, frameSize); header[3] = FrameType.DATA.getIdByte(); if (finished) { header[4] = FLAG_END_OF_STREAM; stream.sentEndOfStream(); if (!stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } } if (writeable) { ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue()); sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize); socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),",
        "ins2PreCode":"public void completed(Long nBytes, SendfileData sendfile) { boolean finished = (frameSize == sendfile.left) && sendfile.stream.getCoyoteResponse().getTrailerFields() == null; activeRemoteStreamCount.decrementAndGet(); if (sendfile.left == 0) { sendfile.stream.sentEndOfStream(); sendfile.stream.sentEndOfStream(); sendfile.stream.getOutputBuffer().close(); long bytesWritten = nBytes.longValue() - 9; sendfile.stream.getOutputBuffer().close(); long bytesWritten = nBytes.longValue() - 9; sendfile.left -= bytesWritten; try { activeRemoteStreamCount.decrementAndGet(); sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize); sendfile.stream.sentEndOfStream(); } int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation = sendfile.stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation); } catch (IOException e) { return; } int frameSize = Integer.min(getMaxFrameSize(), sendfile.streamReservation); boolean finished = (frameSize == sendfile.left) && sendfile.stream.getCoyoteResponse().getTrailerFields() == null; boolean writeable = sendfile.stream.canWrite(); byte[] header = new byte[9]; ByteUtil.setThreeBytes(header, 0, frameSize); header[3] = FrameType.DATA.getIdByte(); if (finished) { header[4] = FLAG_END_OF_STREAM; sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } } if (writeable) { ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue()); sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize); socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(),",
        "label":0
    },
    {
        "ins1AddCode":"void parseIgnoresAndWarnsAboutEntryWithUnmatchedOpenBracket() throws IOException {",
        "ins1DelCode":"public void parseIgnoresAndWarnsAboutEntryWithUnmatchedOpenBracket() throws IOException {",
        "ins1PreCode":"public void parseIgnoresAndWarnsAboutEntryWithUnmatchedOpenBracket() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={author missing bracket}\"));",
        "ins2PreCode":"public void parseIgnoresAndWarnsAboutEntryWithUnmatchedOpenBracketInQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"author {missing bracket\\\"}\"));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void shouldNotEmitUntilAfterSubscription() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(1, 100).scan(0, new BiFunction<Integer, Integer, Integer>() { ",
        "ins2PreCode":"public void shouldNotEmitUntilAfterSubscription() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(1, 100).scan(0, new BiFunction<Integer, Integer, Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"String expectedDDL = \"ALTER TABLE TEST_SCHEMA.TEST_TABLE ADD COLUMN4 INTEGER;\" + lineBreak;",
        "ins1DelCode":"String expectedDDL = \"ALTER TABLE TEST_SCHEMA.TEST_TABLE ADD Column4 INTEGER;\" + lineBreak;",
        "ins1PreCode":"List<DBEPersistAction> actions = DBExecUtils.getActionsListFromCommandContext(monitor, commandContext, executionContext, Collections.emptyMap(), null); String script = SQLUtils.generateScript(testDataSource, actions.toArray(new DBEPersistAction[0]), false);  String expectedDDL = \"ALTER TABLE TEST_SCHEMA.TEST_TABLE ADD Column4 INTEGER;\" + lineBreak;  Assert.assertEquals(script, expectedDDL);",
        "ins2PreCode":"List<DBEPersistAction> actions = DBExecUtils.getActionsListFromCommandContext(monitor, commandContext, executionContext, Collections.emptyMap(), null); String script = SQLUtils.generateScript(testDataSource, actions.toArray(new DBEPersistAction[0]), false); String expectedDDL = \"ALTER TABLE TEST_SCHEMA.TEST_TABLE DROP COLUMN COLUMN1;\" + lineBreak; Assert.assertEquals(script, expectedDDL);",
        "label":0
    },
    {
        "ins1AddCode":"failWithMessage(\"Unsupport type for JSON assert {]\", expected.getClass()); return null;",
        "ins1DelCode":"throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "ins1PreCode":"if (expected instanceof Resource) { return isNotEqualToJson((Resource) expected); } throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);",
        "ins1DelCode":"fireContainerEvent(\"removeWelcomeFile\", name);",
        "ins1PreCode":"  postWelcomeFiles(); fireContainerEvent(\"removeWelcomeFile\", name); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Processor processor = new SortProcessor(randomAlphaOfLength(10), null, fieldName,",
        "ins1DelCode":"Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName,",
        "ins1PreCode":" String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); String targetFieldName = fieldName + \"foo\"; Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, SortOrder.DESCENDING, targetFieldName); processor.execute(ingestDocument);",
        "ins2PreCode":"String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); String targetFieldName = fieldName + \"foo\"; Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, SortOrder.ASCENDING, targetFieldName); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1AddCode":"try (JDBCSession session = DBUtils.openMetaSession(monitor, sourceObject, \"Read HSQLDB view source\")) {",
        "ins1DelCode":"try (JDBCSession session = DBUtils.openMetaSession(monitor, dataSource, \"Read HSQLDB view source\")) {",
        "ins1PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, dataSource, \"Read HSQLDB view source\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT VIEW_DEFINITION FROM INFORMATION_SCHEMA.VIEWS \" +",
        "ins2PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, dataSource, \"Read H2 view source\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT VIEW_DEFINITION FROM INFORMATION_SCHEMA.VIEWS \" +",
        "label":1
    },
    {
        "ins1AddCode":"StringBuilder code = digester.getGeneratedCode(); if (code != null) { code.append(System.lineSeparator()); code.append(digester.toVariableName(webXml)).append(\".setDistributable(true);\"); code.append(System.lineSeparator()); }",
        "ins1DelCode":"",
        "ins1PreCode":"digester.getLogger().debug (webXml.getClass().getName() + \".setDistributable(true)\"); }",
        "ins2PreCode":"if (digester.getLogger().isDebugEnabled()) { digester.getLogger().debug(webXml.getClass().getName() + }",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isNull(); assertThat(transpose.edgeValueOrDefault(N1, N2, null)).isEqualTo(E21);",
        "ins1DelCode":"assertThat(transpose.edgeValueOrNull(N1, N2)).isNull(); assertThat(transpose.edgeValueOrNull(N1, N2)).isEqualTo(E21);",
        "ins1PreCode":"assertThat(transpose(transpose)).isSameAs(directedGraph); AbstractGraphTest.validateGraph(transpose.asGraph());  assertThat(transpose.edgeValueOrNull(N1, N2)).isNull(); directedGraph.putEdgeValue(N2, N1, E21);  assertThat(transpose.edgeValueOrNull(N1, N2)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "ins2PreCode":"assertThat(transpose(transpose)).isSameAs(directedGraph); AbstractGraphTest.validateGraph(transpose.asGraph()); assertThat(transpose.edgeValueOrNull(N1, N2)).isNull(); directedGraph.putEdgeValue(N2, N1, E21); assertThat(transpose.edgeValueOrNull(N1, N2)).isEqualTo(E21); AbstractGraphTest.validateGraph(transpose.asGraph());",
        "label":1
    },
    {
        "ins1AddCode":"MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build(); MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();",
        "ins1DelCode":"MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build();",
        "ins1PreCode":"public void transitiveClosure_directedGraph() { MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N1, N3); directedGraph.putEdge(N2, N3); directedGraph.addNode(N4);  MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "ins2PreCode":"public void transitiveClosure_undirectedGraph() { MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().allowsSelfLoops(false).build(); undirectedGraph.putEdge(N1, N2); undirectedGraph.putEdge(N1, N3); undirectedGraph.putEdge(N2, N3); undirectedGraph.addNode(N4); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.undirected().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "label":1
    },
    {
        "ins1AddCode":"Health health = healthIndicator.health().block(Duration.ofSeconds(30));",
        "ins1DelCode":"Health health = healthIndicator.health().block();",
        "ins1PreCode":"DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics); Health health = healthIndicator.health().block(); assertThat(health.getStatus()).isEqualTo(Status.DOWN); assertThat(health.getDetails()).containsEntry(\"sdk\", \"test-sdk\");",
        "ins2PreCode":"DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics); Health health = healthIndicator.health(); assertThat(health.getStatus()).isEqualTo(Status.UP); assertThat(health.getDetails()).containsEntry(\"sdk\", \"test-sdk\");",
        "label":0
    },
    {
        "ins1AddCode":"DocumentMapper documentMapper = mapperService.documentMapper();",
        "ins1DelCode":"DocumentMapper documentMapper = mapperService.documentMapper(\"doc\");",
        "ins1PreCode":"public void testExtractTermsAndRanges_failed() throws Exception { addQueryFieldMappings(); TermRangeQuery query = new TermRangeQuery(\"field1\", new BytesRef(\"a\"), new BytesRef(\"z\"), true, true); DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\")",
        "ins2PreCode":"public void testExtractTermsAndRanges_partial() throws Exception { addQueryFieldMappings(); PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\"); DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\")",
        "label":1
    },
    {
        "ins1AddCode":"current = new SpscLinkedArrayQueue<>(Observable.bufferSize());",
        "ins1DelCode":"current = new SpscLinkedArrayQueue<R>(Observable.bufferSize());",
        "ins1PreCode":"if (current != null) { return current; } current = new SpscLinkedArrayQueue<R>(Observable.bufferSize()); if (queue.compareAndSet(null, current)) { return current;",
        "ins2PreCode":"if (current != null) { return current; } current = new SpscLinkedArrayQueue<R>(Observable.bufferSize()); if (queue.compareAndSet(null, current)) { return current;",
        "label":1
    },
    {
        "ins1AddCode":"final Computer masterComputer = j.jenkins.getComputer(\"\");",
        "ins1DelCode":"final Computer masterComputer = j.jenkins.getActiveInstance().getComputer(\"\");",
        "ins1PreCode":"@Test public void connectNodeShouldSucceedOnMaster() throws Exception { final Computer masterComputer = j.jenkins.getActiveInstance().getComputer(\"\");  CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void onlineNodeShouldSucceedOnMaster() throws Exception { final Computer masterComputer = j.jenkins.getActiveInstance().getComputer(\"\"); CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1AddCode":"void postProcessAfterShouldCallInterfaceCustomizers() {",
        "ins1DelCode":"public void postProcessAfterShouldCallInterfaceCustomizers() {",
        "ins1PreCode":"public void postProcessAfterShouldCallInterfaceCustomizers() { Map<String, Object> beans = addInterfaceBeans(); addMockBeans(beans);",
        "ins2PreCode":"public void postProcessAfterWhenWebServerFactoryOneShouldCallInterfaceCustomizers() { Map<String, Object> beans = addInterfaceBeans(); addMockBeans(beans);",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner.run((context) -> { CloudFoundryInfoEndpointWebExtension extension = context .getBean(CloudFoundryInfoEndpointWebExtension.class); Map<String, Object> git = (Map<String, Object>) extension.info().get(\"git\"); Map<String, Object> commit = (Map<String, Object>) git.get(\"commit\"); assertThat(commit).hasSize(4); });",
        "ins1DelCode":"this.contextRunner.withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO)) .run((context) -> { CloudFoundryInfoEndpointWebExtension extension = context .getBean(CloudFoundryInfoEndpointWebExtension.class); Map<String, Object> git = (Map<String, Object>) extension.info().get(\"git\"); Map<String, Object> commit = (Map<String, Object>) git.get(\"commit\"); assertThat(commit).hasSize(4); });",
        "ins1PreCode":"void gitFullDetailsAlwaysPresent() { this.contextRunner.withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO)) .run((context) -> { CloudFoundryInfoEndpointWebExtension extension = context .getBean(CloudFoundryInfoEndpointWebExtension.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try { adjacentEdges.add(E23);",
        "ins2PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try { adjacentEdges.add(E23);",
        "label":0
    },
    {
        "ins1AddCode":"try (ACLContext as = ACL.as(user)) {",
        "ins1DelCode":"SecurityContextHolder.getContext().setAuthentication(user.impersonate()); try{",
        "ins1PreCode":"HudsonPrivateSecurityRealm realm = new HudsonPrivateSecurityRealm(false); j.jenkins.setSecurityRealm(realm); User user = realm.createAccount(\"John Smith\", \"password\"); SecurityContextHolder.getContext().setAuthentication(user.impersonate()); try{ project.doDisable(); fail(\"User should not have permission to build project\");",
        "ins2PreCode":"HudsonPrivateSecurityRealm realm = new HudsonPrivateSecurityRealm(false); j.jenkins.setSecurityRealm(realm); User user = realm.createAccount(\"John Smith\", \"password\"); SecurityContextHolder.getContext().setAuthentication(user.impersonate()); try{ project.disable(); fail(\"User should not have permission to build project\");",
        "label":0
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD, \"    \"); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, \" \" + USER_NAME + \" \", PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(ex).hasCauseThat().isInstanceOf(java.io.NotSerializableException.class);",
        "ins1DelCode":"assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass());",
        "ins1PreCode":"reserialize(memoizedSupplier); fail(); } catch (RuntimeException ex) { assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass()); }",
        "ins2PreCode":"reserialize(memoizedSupplier); fail(); } catch (RuntimeException ex) { assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass()); }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void mapperToJust() { TestObserver<Integer> to = new TestObserver<Integer>();  assertTrue(ObservableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), to, new Function<Integer, ObservableSource<Integer>>() {",
        "ins2PreCode":"public void mapperToEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); assertTrue(ObservableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), to, new Function<Integer, ObservableSource<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha/beta/gamma\"});",
        "ins1DelCode":"if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha/beta/gamma\"}); } }",
        "ins1PreCode":"public void test2bisButCaseInsensitive() { if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"}); ds.setCaseSensitive(false);",
        "ins2PreCode":"public void testPatternsDifferInCaseScanningSensitive() { if (!loginSuceeded) { if (!changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"}); ds.scan();",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void putEdge_existingSelfLoopEdgeBetweenSameNodes() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue();  graphAsMutableGraph.putEdge(N1, N1);",
        "ins2PreCode":"public void putEdge_existingSelfLoopEdgeBetweenSameNodes() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); graphAsMutableGraph.putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(-631123200000L, y.getFirstMillisecond(cal)); y.getFirstMillisecond((Calendar) null);",
        "ins1DelCode":"assertEquals(-631123200000L, y.getFirstMillisecond(zone)); y.getFirstMillisecond((TimeZone) null);",
        "ins1PreCode":"public void testGetFirstMillisecondWithTimeZone() { Year y = new Year(1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-631123200000L, y.getFirstMillisecond(zone));   boolean pass = false; try { y.getFirstMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "ins2PreCode":"public void testGetLastMillisecondWithTimeZone() { Year y = new Year(1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-599587200001L, y.getLastMillisecond(zone)); boolean pass = false; try { y.getLastMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "label":1
    },
    {
        "ins1AddCode":"@NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4) {",
        "ins1DelCode":"ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) {",
        "ins1PreCode":"public static <T> Observable<T> concat( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\");",
        "ins2PreCode":"public static <T> Observable<T> merge( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Color.WHITE, r.getBaseFillPaint()); assertEquals(Color.WHITE, r.lookupSeriesFillPaint(0));",
        "ins1DelCode":"assertEquals(Color.white, r.getBaseFillPaint()); assertEquals(Color.white, r.lookupSeriesFillPaint(0));",
        "ins1PreCode":"public void testFillPaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.white, r.getBaseFillPaint());   r.setAutoPopulateSeriesFillPaint(false); assertEquals(Color.white, r.lookupSeriesFillPaint(0)); assertNull(r.getSeriesFillPaint(0)); ",
        "ins2PreCode":"public void testOutlinePaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.gray, r.getBaseOutlinePaint()); r.setAutoPopulateSeriesOutlinePaint(false); assertEquals(Color.gray, r.lookupSeriesOutlinePaint(0)); assertNull(r.getSeriesOutlinePaint(0));",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(buildRule.getFullLog(), not(containsString(\"dangling\")));",
        "ins1DelCode":"assertFalse(buildRule.getFullLog().contains(\"dangling\"));",
        "ins1PreCode":"assertFileIsNotPresent(d); String c = buildRule.getProject().getProperty(\"dest\") + \"/a/b/c\"; assertFileIsNotPresent(c); assertFalse(buildRule.getFullLog().contains(\"dangling\"));",
        "ins2PreCode":"assertFileIsNotPresent(d); String c = buildRule.getProject().getProperty(\"dest\") + \"/a/b/c\"; assertFileIsNotPresent(d); assertFalse(buildRule.getFullLog().contains(\"dangling\"));",
        "label":1
    },
    {
        "ins1AddCode":"tableTriggerCache.clearCache();",
        "ins1DelCode":"",
        "ins1PreCode":"packageCache.clearCache(); proceduresCache.clearCache(); triggerCache.clearCache(); dataTypeCache.clearCache(); sequenceCache.clearCache(); synonymCache.clearCache();",
        "ins2PreCode":"languageCache.clearCache(); roleCache.clearCache(); roleCache.clearCache(); tablespaceCache.clearCache(); encodingCache.clearCache(); encodingCache.clearCache();",
        "label":0
    },
    {
        "ins1AddCode":"final WeakReference<Disposable> wr = new WeakReference<>(d);",
        "ins1DelCode":"final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "ins1PreCode":"public void errorDetaches() throws Exception { Disposable d = Disposable.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);  TestObserver<Integer> to = new Single<Integer>() {",
        "ins2PreCode":"public void errorDetaches() throws Exception { Disposable d = Disposable.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d); TestObserver<Integer> to = new Maybe<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"Session s=sessions.get(sessionId);",
        "ins1DelCode":"Session s=(Session)sessions.get(sessionId);",
        "ins1PreCode":"public String getLastAccessedTime( String sessionId ) { Session s=(Session)sessions.get(sessionId); if( s==null ) { if(log.isInfoEnabled())",
        "ins2PreCode":"public String getCreationTime( String sessionId ) { Session s=(Session)sessions.get(sessionId); if( s==null ) { if(log.isInfoEnabled())",
        "label":1
    },
    {
        "ins1AddCode":"List<Observable<?>> sources = new ArrayList<>(); List<String> expected = new ArrayList<>(); TestObserver<String> to = new TestObserver<>();",
        "ins1DelCode":"List<Observable<?>> sources = new ArrayList<Observable<?>>(); List<String> expected = new ArrayList<String>(); TestObserver<String> to = new TestObserver<String>();",
        "ins1PreCode":"for (String val : new String[] { \"1\"  }) { int n = 35; for (int i = 0; i < n; i++) { List<Observable<?>> sources = new ArrayList<Observable<?>>(); List<String> expected = new ArrayList<String>(); expected.add(val);  for (int j = 0; j < i; j++) { sources.add(Observable.just(val)); expected.add(String.valueOf(val)); }  TestObserver<String> to = new TestObserver<String>();  PublishSubject<String> main = PublishSubject.create();",
        "ins2PreCode":"for (String val : new String[] { \"1\"  }) { int n = 35; for (int i = 0; i < n; i++) { List<Flowable<?>> sources = new ArrayList<>(); List<String> expected = new ArrayList<>(); expected.add(val); for (int j = 0; j < i; j++) { sources.add(Flowable.just(val)); expected.add(String.valueOf(val)); } TestSubscriber<String> ts = new TestSubscriber<>(); PublishProcessor<String> main = PublishProcessor.create();",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(\"Expecting to have received \"+(2*count)+\" notifications.\",2*count, listener.notificationCount.get());",
        "ins1DelCode":"assertEquals(\"Expecting to have received \"+(2*count)+\" notifications.\",2*count, listener.notificationCount);",
        "ins1PreCode":"st.close(); } System.out.println(\"Stats:\"+stats); assertEquals(\"Expecting to have received \"+(2*count)+\" notifications.\",2*count, listener.notificationCount); con.close(); tearDown();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(1078099199999L, d1.getLastMillisecond(cal)); assertEquals(1078099200000L, d2.getFirstMillisecond(cal));",
        "ins1DelCode":"assertEquals(1078099199999L, d1.getLastMillisecond(zone)); assertEquals(1078099200000L, d2.getFirstMillisecond(zone));",
        "ins1PreCode":"Day d2 = new Day(new Date(1078099200000L), zone, locale);  assertEquals(MonthConstants.FEBRUARY, d1.getMonth()); assertEquals(1078099199999L, d1.getLastMillisecond(zone));  assertEquals(MonthConstants.MARCH, d2.getMonth()); assertEquals(1078099200000L, d2.getFirstMillisecond(zone));",
        "ins2PreCode":"Day d2 = new Day(new Date(1078092000000L), zone, locale); assertEquals(MonthConstants.FEBRUARY, d1.getMonth()); assertEquals(1078091999999L, d1.getLastMillisecond(zone)); assertEquals(MonthConstants.MARCH, d2.getMonth()); assertEquals(1078092000000L, d2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(\"Should have not followed links\", IOException.class, () -> link.open(true));",
        "ins1DelCode":"try { link.open(true); fail(\"Should have not followed links.\"); } catch (IOException ioe) { }",
        "ins1PreCode":"Util.createSymlink(ws, childString, linkString, TaskListener.NULL);  VirtualFile link = VirtualFile.forFile(ws).child(linkString); try { link.open(true); fail(\"Should have not followed links.\"); } catch (IOException ioe) {  }",
        "ins2PreCode":"Util.createSymlink(ws, childString, linkString, TaskListener.NULL); VirtualFile link = VirtualFile.forFilePath(new FilePath(ws)).child(linkString); try { link.open(true); fail(\"Should have not followed links.\"); } catch (IOException ioe) { }",
        "label":1
    },
    {
        "ins1AddCode":"Map<Integer, Collection<String>> expected = new HashMap<>();",
        "ins1DelCode":"Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>();",
        "ins1PreCode":" Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\")); expected.put(2, Arrays.asList(\"cc\", \"dd\"));",
        "ins2PreCode":"Observable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicate).toObservable(); Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\")); expected.put(2, Arrays.asList(\"cccc\", \"dddd\"));",
        "label":1
    },
    {
        "ins1AddCode":"void applyPropertyValueOnXmlMapper() throws IOException {",
        "ins1DelCode":"public void applyPropertyValueOnXmlMapper() throws IOException {",
        "ins1PreCode":"public void applyPropertyValueOnXmlMapper() throws IOException {  Properties props = new Properties();",
        "ins2PreCode":"public void applyPropertyValueOnAnnotationMapper() throws IOException { Properties props = new Properties();",
        "label":1
    },
    {
        "ins1AddCode":"final GeoIpProcessor city = factory.create(null, \"_tag\", null, config); final GeoIpProcessor country = factory.create(null, \"_tag\", null, config); final GeoIpProcessor asn = factory.create(null, \"_tag\", null, config);",
        "ins1DelCode":"final GeoIpProcessor city = factory.create(null, \"_tag\", config); final GeoIpProcessor country = factory.create(null, \"_tag\", config); final GeoIpProcessor asn = factory.create(null, \"_tag\", config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoLite2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config);   assertNull(databaseReaders.get(\"GeoLite2-City.mmdb\").databaseReader.get()); city.execute(document);  assertNotNull(databaseReaders.get(\"GeoLite2-City.mmdb\").databaseReader.get());  config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoLite2-Country.mmdb\"); final GeoIpProcessor country = factory.create(null, \"_tag\", config);   assertNull(databaseReaders.get(\"GeoLite2-Country.mmdb\").databaseReader.get()); country.execute(document);  assertNotNull(databaseReaders.get(\"GeoLite2-Country.mmdb\").databaseReader.get());  config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoLite2-ASN.mmdb\"); final GeoIpProcessor asn = factory.create(null, \"_tag\", config);  ",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config); assertNull(databaseReaders.get(\"GeoIP2-City.mmdb\").databaseReader.get()); city.execute(document); assertNotNull(databaseReaders.get(\"GeoIP2-City.mmdb\").databaseReader.get()); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config); assertNull(databaseReaders.get(\"GeoIP2-City.mmdb\").databaseReader.get()); city.execute(document); assertNotNull(databaseReaders.get(\"GeoIP2-City.mmdb\").databaseReader.get()); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config);",
        "label":0
    },
    {
        "ins1AddCode":"private void setUpNonLogin() throws Exception { ctxt.setSessionTimeout(LONG_TIMEOUT_MINS); nonloginAuthenticator = new NonLoginAuthenticator(); ctxt.getPipeline().addValve(nonloginAuthenticator);",
        "ins1DelCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception { ctxt.setSessionTimeout(LONG_TIMEOUT_SECS); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "ins1PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "ins2PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception { Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS); Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1); Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint(); sc2.addCollection(collection2); ctxt.addConstraint(sc2); LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "label":0
    },
    {
        "ins1AddCode":"void shouldCheckTypeForEachGetter() {",
        "ins1DelCode":"public void shouldCheckTypeForEachGetter() {",
        "ins1PreCode":"public void shouldCheckTypeForEachGetter() { ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory);",
        "ins2PreCode":"public void shouldCheckTypeForEachSetter() { ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory);",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.FINE, \"Removing region {0}\", oldRegion);",
        "ins1DelCode":"LOG.debug(\"Removing region \" + oldRegion);",
        "ins1PreCode":"damage(); } } LOG.debug(\"Removing region \" + oldRegion); }",
        "ins2PreCode":"damage(); } } LOG.debug(\"Removing region \" + oldRegion); }",
        "label":1
    },
    {
        "ins1AddCode":"ps.onNext(1);",
        "ins1DelCode":"ps.onComplete();",
        "ins1PreCode":"Runnable r1 = new Runnable() { @Override public void run() { ps.onComplete(); } };",
        "ins2PreCode":"Runnable r1 = new Runnable() { @Override public void run() { ps.onComplete(); } };",
        "label":0
    },
    {
        "ins1AddCode":"JavaPairDStream<String, String> flatMapped = pairStream.flatMapValues(in -> { List<String> out = new ArrayList<>(); out.add(in + \"1\"); out.add(in + \"2\"); return out; });",
        "ins1DelCode":"JavaPairDStream<String, String> flatMapped = pairStream.flatMapValues( new Function<String, Iterable<String>>() { @Override public Iterable<String> call(String in) { List<String> out = new ArrayList<>(); out.add(in + \"1\"); out.add(in + \"2\"); return out; } });",
        "ins1PreCode":"JavaPairDStream<String, String> pairStream = JavaPairDStream.fromJavaDStream(stream);   JavaPairDStream<String, String> flatMapped = pairStream.flatMapValues( new Function<String, Iterable<String>>() { @Override public Iterable<String> call(String in) { List<String> out = new ArrayList<>(); out.add(in + \"1\");",
        "ins2PreCode":"JavaPairDStream<String, String> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<String, String> flatMapped = JavaPairDStream<String, String> flatMapped = Assert.assertEquals(expected, result); public void testFlatMapValues() { List<List<Tuple2<String, String>>> expected = Arrays.asList( ssc, inputData, 1);",
        "label":0
    },
    {
        "ins1AddCode":"sql.append(\"\\nORDER BY i.object_id,i.index_id,ic.key_ordinal\");",
        "ins1DelCode":"sql.append(\"\\nORDER BY i.object_id,i.index_id,ic.index_column_id\");",
        "ins1PreCode":"} else { sql.append(\" AND t.schema_id = ?\"); } sql.append(\"\\nORDER BY i.object_id,i.index_id,ic.index_column_id\");  JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString());",
        "ins2PreCode":"} else { sql.append(\" AND t.schema_id=?\"); } sql.append(\"\\nORDER BY fkc.constraint_object_id, fkc.constraint_column_id\"); JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString());",
        "label":0
    },
    {
        "ins1AddCode":"if (txnManager != null && txnManager.isSupportsTransactions() && !txnManager.isAutoCommit()) {",
        "ins1DelCode":"if (txnManager != null && !txnManager.isAutoCommit()) {",
        "ins1PreCode":"private void commitChanges(DBCSession session) { try { DBCTransactionManager txnManager = DBUtils.getTransactionManager(session.getExecutionContext()); if (txnManager != null && !txnManager.isAutoCommit()) { txnManager.commit(session); }",
        "ins2PreCode":"private void commitChanges(DBCSession session) { try { DBCTransactionManager txnManager = DBUtils.getTransactionManager(session.getExecutionContext()); if (txnManager != null && !txnManager.isAutoCommit()) { txnManager.commit(session); }",
        "label":0
    },
    {
        "ins1AddCode":"final TestObserver<Integer> to1 = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Integer> to1 = new TestObserver<Integer>();",
        "ins1PreCode":" final ConnectableObservable<Integer> co = ps.replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"final ConnectableObservable<Integer> co = ps.replay(); final TestObserver<Integer> to1 = new TestObserver<Integer>(); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"builder.putInt32ToEnumFieldValue(1, -1); assertEquals(-1, builder.getInt32ToEnumFieldValueOrThrow(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, builder.getInt32ToEnumFieldOrThrow(1));",
        "ins1DelCode":"try { builder.putInt32ToEnumFieldValue(1, -1); fail(); } catch (IllegalArgumentException e) { }",
        "ins1PreCode":"try { builder.putInt32ToEnumFieldValue(1, -1); fail(); } catch (IllegalArgumentException e) {  }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final long value = Platform.getLong(baseObject, baseOffset + offset);",
        "ins1DelCode":"final long value = PlatformDependent.UNSAFE.getLong(baseObject, baseOffset + offset);",
        "ins1PreCode":"if (offset < 0) return null;  if (precision <= Decimal.MAX_LONG_DIGITS()) { final long value = PlatformDependent.UNSAFE.getLong(baseObject, baseOffset + offset); return Decimal.apply(value, precision, scale); } else {",
        "ins2PreCode":"return null; if (precision <= Decimal.MAX_LONG_DIGITS()) { PlatformDependent.copyMemory(baseObject, baseOffset + offset, return Decimal.apply(getLong(ordinal), precision, scale); } else {",
        "label":0
    },
    {
        "ins1AddCode":"SwitchMapSingleObserver<R> observer = new SwitchMapSingleObserver<>(this);",
        "ins1DelCode":"SwitchMapSingleObserver<R> observer = new SwitchMapSingleObserver<R>(this);",
        "ins1PreCode":"return; }  SwitchMapSingleObserver<R> observer = new SwitchMapSingleObserver<R>(this);  for (;;) {",
        "ins2PreCode":"return; } SwitchMapSingleObserver<R> observer = new SwitchMapSingleObserver<R>(this); for (;;) {",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>07-hello world</p>\") > 0);",
        "ins1DelCode":"",
        "ins1PreCode":"Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void parentContextCreationThatIsRunDirectly() {",
        "ins1DelCode":"public void parentContextCreationThatIsRunDirectly() {",
        "ins1PreCode":"public void parentContextCreationThatIsRunDirectly() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class) .contextClass(SpyApplicationContext.class);",
        "ins2PreCode":"public void parentContextCreationThatIsBuiltThenRun() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class) .contextClass(SpyApplicationContext.class);",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\") PrefixSpanModel<Integer> newModel = (PrefixSpanModel<Integer>) PrefixSpanModel.load(spark.sparkContext(), outputPath);",
        "ins1DelCode":"PrefixSpanModel newModel = PrefixSpanModel.load(spark.sparkContext(), outputPath);",
        "ins1PreCode":" try { model.save(spark.sparkContext(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(spark.sparkContext(), outputPath); JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DateTickUnit unit = new DateTickUnit(DateTickUnitType.HOUR, 1); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault());",
        "ins1DelCode":"DateTickUnit unit = new DateTickUnit(DateTickUnit.HOUR, 1); Date nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd);",
        "ins1PreCode":" Date end = new Date(h1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.HOUR, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "ins2PreCode":"Date end = new Date(h1.getLastMillisecond()); DateTickUnit unit = new DateTickUnit(DateTickUnit.HOUR, 6); axis.setTickUnit(unit); axis.setTickMarkPosition(DateTickMarkPosition.START); axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime()); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime()); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.END); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "label":1
    },
    {
        "ins1AddCode":"SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<>();",
        "ins1DelCode":"SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<Integer>();",
        "ins1PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<Integer>();  buf.next(1);",
        "ins2PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false); Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError()); List<Integer> values = new ArrayList<Integer>(); buf.next(1);",
        "label":1
    },
    {
        "ins1AddCode":"JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, null, config);",
        "ins1DelCode":"JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", randomField); config.put(\"add_to_root\", true); JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, config); assertThat(jsonProcessor.getTag(), equalTo(processorTag)); assertThat(jsonProcessor.getField(), equalTo(randomField));",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", randomField); config.put(\"field\", randomField); JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, config); assertThat(jsonProcessor.getTag(), equalTo(processorTag)); assertThat(jsonProcessor.getField(), equalTo(randomField));",
        "label":1
    },
    {
        "ins1AddCode":"throws JasperException { Method result = null; if (GRAAL) { String setter = \"set\" + capitalize(prop); Method methods[] = beanClass.getMethods(); for (Method method : methods) { if (setter.equals(method.getName())) { return method; } else { try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { result = pd[i].getWriteMethod(); type = pd[i].getPropertyType(); break; } } } catch (Exception ex) { throw new JasperException (ex); } if (result == null) { return result;",
        "ins1DelCode":"throws JasperException { Method method = null; try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { method = pd[i].getWriteMethod(); type = pd[i].getPropertyType(); break; } catch (Exception ex) { throw new JasperException (ex); if (method == null) { return method;",
        "ins1PreCode":"public static Method getWriteMethod(Class<?> beanClass, String prop) throws JasperException { Method method = null; Class<?> type = null; try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { method = pd[i].getWriteMethod(); type = pd[i].getPropertyType(); break; } } } catch (Exception ex) { throw new JasperException (ex); } if (method == null) { if (type == null) { throw new JasperException(Localizer.getMessage(",
        "ins2PreCode":"public static Method getReadMethod(Class<?> beanClass, String prop) throws JasperException { Method method = null; Class<?> type = null; try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if (pd[i].getName().equals(prop)) { method = pd[i].getReadMethod(); type = pd[i].getPropertyType(); break; } } } catch (Exception ex) { throw new JasperException (ex); } if (method == null) { if (type == null) { throw new JasperException(Localizer.getMessage(",
        "label":1
    },
    {
        "ins1AddCode":"getDiagram().getModelAdapter().installPartEditPolicies(this);",
        "ins1DelCode":"getDiagram().getModelAdapter().installPartEditPolicies(this);",
        "ins1PreCode":"protected void createEditPolicies() { getDiagram().getModelAdapter().installPartEditPolicies(this);  final boolean layoutEnabled = isLayoutEnabled(); if (layoutEnabled) { installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new EntityConnectionEditPolicy());   installEditPolicy(EditPolicy.COMPONENT_ROLE, new NoteEditPolicy()); installEditPolicy(EditPolicy.DIRECT_EDIT_ROLE, new NoteDirectEditPolicy());    }",
        "ins2PreCode":"protected void createEditPolicies() { if (layoutEnabled) { getDiagram().getModelAdapter().installPartEditPolicies(this); final boolean layoutEnabled = isLayoutEnabled(); if (layoutEnabled) { installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new EntityConnectionEditPolicy()); installEditPolicy(EditPolicy.COMPONENT_ROLE, new EntityEditPolicy()); installEditPolicy(EditPolicy.COMPONENT_ROLE, new EntityEditPolicy()); }",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false);",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"Series 1\", true, false); XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
        "ins1PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "ins2PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1); XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateTShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateTShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"Statement statement = configureDataSourceBehavior(",
        "ins1DelCode":"Statement statement = configureDataSourceBehaviour(",
        "ins1PreCode":"public void autoConfiguredExternalDataSourceIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.postgresql.Driver\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "ins2PreCode":"public void h2ServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < count; ++i, srcOffset += 4) { if (bigEndianPlatform) { intData[i + rowId] = java.lang.Integer.reverseBytes(intData[i + rowId]); }",
        "ins1DelCode":"for (int i = 0; i < count; ++i) { srcIndex += 4; srcOffset += 4;",
        "ins1PreCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { intData[i + rowId] = Platform.getInt(src, srcOffset); srcIndex += 4; srcOffset += 4; }",
        "ins2PreCode":"public void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { longData[i + rowId] = Platform.getLong(src, srcOffset); srcIndex += 8; srcOffset += 8; }",
        "label":1
    },
    {
        "ins1AddCode":"BehaviorDisposable<T>[] a = observers.get(); if (observers.compareAndSet(a, b)) {",
        "ins1DelCode":"BehaviorDisposable<T>[] a = subscribers.get(); if (subscribers.compareAndSet(a, b)) {",
        "ins1PreCode":"boolean add(BehaviorDisposable<T> rs) { for (;;) { BehaviorDisposable<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int len = a.length; @SuppressWarnings(\"unchecked\") BehaviorDisposable<T>[] b = new BehaviorDisposable[len + 1]; System.arraycopy(a, 0, b, 0, len); b[len] = rs; if (subscribers.compareAndSet(a, b)) { return true; }",
        "ins2PreCode":"boolean add(BehaviorSubscription<T> rs) { for (;;) { BehaviorSubscription<T>[] a = subscribers.get(); if (a == TERMINATED) { return false; } int len = a.length; @SuppressWarnings(\"unchecked\") BehaviorSubscription<T>[] b = new BehaviorSubscription[len + 1]; System.arraycopy(a, 0, b, 0, len); b[len] = rs; if (subscribers.compareAndSet(a, b)) { return true; }",
        "label":0
    },
    {
        "ins1AddCode":"long startNanos = 0; if (startNanos > 0) { long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos); if (elapsedMillis == 0) { elapsedMillis = 1; } timeout -= elapsedMillis; if (timeout <= 0) { throw new SocketTimeoutException(); } } } else if (n == 0) { startNanos = System.nanoTime(); } else if (startNanos > 0) { timeout = getWriteTimeout(); startNanos = 0;",
        "ins1DelCode":"} if (n == 0) { if (writeBlocking) { writeBlocking = false; throw new SocketTimeoutException(); }",
        "ins1PreCode":"if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void testComplexQueryRegex() { TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1DelCode":"public void testComplexQueryRegex() { double textSize = 13; assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins1PreCode":"public void testComplexQueryRegex() { double textSize = 13; String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testComplexQueryCaseSensitive() { double textSize = 13; String query = \"not a=b and c=e or e=\\\"x\\\"\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(decorated.isUnix()); assertTrue(decorated.isUnix());",
        "ins1DelCode":"assertEquals(false, decorated.isUnix()); assertEquals(true, decorated.isUnix());",
        "ins1PreCode":"TaskListener listener = new StreamBuildListener(output); Launcher remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, false); Launcher decorated = remoteLauncher.decorateByEnv(new EnvVars()); assertEquals(false, decorated.isUnix()); remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, true); decorated = remoteLauncher.decorateByEnv(new EnvVars()); assertEquals(true, decorated.isUnix());",
        "ins2PreCode":"TaskListener listener = new StreamBuildListener(output); Launcher remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, false); Launcher decorated = remoteLauncher.decorateByPrefix(\"test\"); assertEquals(false, decorated.isUnix()); remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, true); decorated = remoteLauncher.decorateByPrefix(\"test\"); assertEquals(true, decorated.isUnix());",
        "label":1
    },
    {
        "ins1AddCode":"\"Host: localhost:8080\" + CRLF +",
        "ins1DelCode":"",
        "ins1PreCode":"String[] request = new String[1]; request[0] = \"GET http://localhost:8080/test HTTP/1.1\" + CRLF + \"X-Bug48839: abcd\" + CRLF + \"\\tefgh\" + CRLF + \"Connection: close\" + CRLF +",
        "ins2PreCode":"String[] request = new String[2]; request[1] = LF + request[0] = \"GET http://localhost:8080/test HTTP/1.1\" + CR; \"Connection: close\" + CRLF + \"Connection: close\" + CRLF + \"Connection: close\" + CRLF +",
        "label":1
    },
    {
        "ins1AddCode":"tgt = new Parent(); target.setParent( tgt );",
        "ins1DelCode":"target.setParent( tgt = new Parent() );",
        "ins1PreCode":"Parent tgt = target.getParent(); if ( tgt == null ) { target.setParent( tgt = new Parent() ); } mergeParent( tgt, src, sourceDominant, context );",
        "ins2PreCode":"IssueManagement tgt = target.getIssueManagement(); if ( tgt == null ) { target.setIssueManagement( tgt = new IssueManagement() ); } mergeIssueManagement( tgt, src, sourceDominant, context );",
        "label":0
    },
    {
        "ins1AddCode":"BibEntry entry = parsed.iterator().next(); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1DelCode":"BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional());",
        "ins1PreCode":"List<BibEntry> parsed = result.getDatabase().getEntries(); assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional());",
        "ins2PreCode":"List<BibEntry> parsed = result.getDatabase().getEntries(); assertEquals(1, parsed.size()); BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional());",
        "label":0
    },
    {
        "ins1AddCode":"File appDir = new File(\"test/webapp\");",
        "ins1DelCode":"File appDir = new File(\"test/webapp-3.0\");",
        "ins1PreCode":" Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "label":1
    },
    {
        "ins1AddCode":"for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); }",
        "ins1DelCode":"",
        "ins1PreCode":"tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); TomcatHttpHandlerAdapter servlet = new TomcatHttpHandlerAdapter(httpHandler); prepareContext(tomcat.getHost(), servlet); return new TomcatWebServer(tomcat, getPort() >= 0);",
        "ins2PreCode":"tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); Tomcat tomcat = new Tomcat(); prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat);",
        "label":0
    },
    {
        "ins1AddCode":"Path auxFile = Path.of(AuxParserTest.class.getResource(\"badpaper.aux\").toURI());",
        "ins1DelCode":"Path auxFile = Paths.get(AuxParserTest.class.getResource(\"badpaper.aux\").toURI());",
        "ins1PreCode":"void testNotAllFound() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\"); Path auxFile = Paths.get(AuxParserTest.class.getResource(\"badpaper.aux\").toURI()); try (InputStreamReader originalReader = new InputStreamReader(originalStream, StandardCharsets.UTF_8)) { ParserResult result = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(originalReader);",
        "ins2PreCode":"void testNestedAux() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\"); Path auxFile = Paths.get(AuxParserTest.class.getResource(\"nested.aux\").toURI()); try (InputStreamReader originalReader = new InputStreamReader(originalStream, StandardCharsets.UTF_8)) { ParserResult result = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(originalReader);",
        "label":1
    },
    {
        "ins1AddCode":"void shutdownChild() throws Exception {",
        "ins1DelCode":"public void shutdownChild() throws Exception {",
        "ins1PreCode":"public void shutdownChild() throws Exception { ConfigurableApplicationContext context = new SpringApplicationBuilder(EmptyConfig.class) .child(EndpointConfig.class).web(WebApplicationType.NONE).run();",
        "ins2PreCode":"public void shutdownParent() throws Exception { ConfigurableApplicationContext context = new SpringApplicationBuilder(EndpointConfig.class) .child(EmptyConfig.class).web(WebApplicationType.NONE).run();",
        "label":1
    },
    {
        "ins1AddCode":"ph.setLayoutData(new GridData(GridData.HORIZONTAL_ALIGN_BEGINNING)); passwordText.setLayoutData(makeAuthControlLayoutData(ph));",
        "ins1DelCode":"ph.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); passwordText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));",
        "ins1PreCode":"UIUtils.createControlLabel(parent, label); } Composite ph = UIUtils.createPlaceholder(parent, 1); ph.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); passwordText = new Text(ph, SWT.BORDER | SWT.PASSWORD); passwordText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); return passwordText;",
        "ins2PreCode":"UIUtils.createControlLabel(parent, label); } Composite ph = UIUtils.createPlaceholder(parent, 1); ph.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); passwordText = new Text(ph, SWT.BORDER | SWT.PASSWORD); passwordText.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); return passwordText;",
        "label":0
    },
    {
        "ins1AddCode":"public void cloudFoundryPlatformActive() {",
        "ins1DelCode":"public void cloudFoundryPlatformActive() throws Exception {",
        "ins1PreCode":"public void cloudFoundryPlatformActive() throws Exception { setupContextWithCloudEnabled(); this.context.refresh();",
        "ins2PreCode":"public void cloudFoundryPlatformActive() throws Exception { assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(handlerMapping.getEndpointMapping().getPath())",
        "label":1
    },
    {
        "ins1AddCode":"Computer c = addTestAgent(launcher);",
        "ins1DelCode":"Computer c = addTestSlave(launcher);",
        "ins1PreCode":" ComputerLauncher launcher = new JNLPLauncher(\"\", \"\", new RemotingWorkDirSettings(false, workDir.getAbsolutePath(), \"internalDir\", false)); launcher = new DelegatingComputerLauncherImpl(launcher); Computer c = addTestSlave(launcher); launchJnlpAndVerify(c, buildJnlpArgs(c)); assertTrue(\"Remoting work dir should have been created\", new File(workDir, \"internalDir\").exists());",
        "ins2PreCode":"ComputerLauncher launcher = new JNLPLauncher(\"\", \"\", new RemotingWorkDirSettings(false, workDir.getAbsolutePath(), \"internalDir\", false)); launcher = new ComputerLauncherFilterImpl(launcher); Computer c = addTestSlave(launcher); launchJnlpAndVerify(c, buildJnlpArgs(c)); assertTrue(\"Remoting work dir should have been created\", new File(workDir, \"internalDir\").exists());",
        "label":1
    },
    {
        "ins1AddCode":"try { pp.offer(null); fail(\"Should have thrown NPE!\"); } catch (NullPointerException expected) { } ts.assertValuesOnly(2);",
        "ins1DelCode":"assertTrue(pp.offer(null)); ts.assertFailure(NullPointerException.class, 2); assertTrue(pp.hasThrowable()); assertTrue(pp.getThrowable().toString(), pp.getThrowable() instanceof NullPointerException);",
        "ins1PreCode":" ts = pp.test(1);  assertTrue(pp.offer(null));  ts.assertFailure(NullPointerException.class, 2);  assertTrue(pp.hasThrowable()); assertTrue(pp.getThrowable().toString(), pp.getThrowable() instanceof NullPointerException);",
        "ins2PreCode":"ts = pp.test(0); assertTrue(pp.offer(null)); ts.assertFailure(NullPointerException.class); assertTrue(pp.hasThrowable()); assertTrue(pp.getThrowable().toString(), pp.getThrowable() instanceof NullPointerException);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0); Assert. assertTrue(\"Checking no client issuer has been requested\", TesterSupport.getLastClientAuthRequestedIssuerCount() == 0);",
        "ins1DelCode":"assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0); assertTrue(\"Checking no client issuer has been requested\", TesterSupport.getLastClientAuthRequestedIssuerCount() == 0);",
        "ins1PreCode":"tomcat.start(); ByteChunk res = getUrl(\"https://localhost:\" + getPort() + \"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0); assertTrue(\"Checking no client issuer has been requested\", TesterSupport.getLastClientAuthRequestedIssuerCount() == 0);",
        "ins2PreCode":"tomcat.start(); ByteChunk res = getUrl(\"https://localhost:\" + getPort() + \"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0); assertTrue(\"Checking no client issuer has been requested\", TesterSupport.getLastClientAuthRequestedIssuerCount() == 0);",
        "label":1
    },
    {
        "ins1AddCode":"assumeNotNull(\"JPEG codec is unavailable in classpath\", buildRule.getProject().getProperty(\"jpeg.codec.available\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testOverwriteFalse() { buildRule.executeTarget(\"testSimpleScale\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); File f = new File(buildRule.getOutputDir(), LARGEIMAGE); long lastModified = f.lastModified(); buildRule.executeTarget(\"testOverwriteFalse\");",
        "ins2PreCode":"public void testOverwriteFalse() { buildRule.executeTarget(\"testSimpleScale\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); File f = new File(buildRule.getOutputDir(), LARGEIMAGE); long lastModified = f.lastModified(); buildRule.executeTarget(\"testOverwriteFalse\");",
        "label":0
    },
    {
        "ins1AddCode":"= genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');",
        "ins1DelCode":"= genericEntry.getName().replace(File.separatorChar, '.');",
        "ins1PreCode":"if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(ExceptionHelper.nullWarning(\"onSuccess called with a null value.\"), ex.getMessage());",
        "ins1DelCode":"assertEquals(\"onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage());",
        "ins1PreCode":"ss.onSuccess(null); fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(\"onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage()); } ",
        "ins2PreCode":"ss.onError(null); fail(\"No NullPointerException thrown\"); } catch (NullPointerException ex) { assertEquals(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\", ex.getMessage()); }",
        "label":0
    },
    {
        "ins1AddCode":"Dataset<Row> dataset = jsql.createDataFrame(data, (new StructType()).add(group.toStructField())); Dataset<Row> output = vectorSlicer.transform(dataset); for (Row r : output.select(\"userFeatures\", \"features\").takeRows(2)) {",
        "ins1DelCode":"DataFrame dataset = jsql.createDataFrame(data, (new StructType()).add(group.toStructField())); DataFrame output = vectorSlicer.transform(dataset); for (Row r : output.select(\"userFeatures\", \"features\").take(2)) {",
        "ins1PreCode":"RowFactory.create(Vectors.dense(-2.0, 2.3, 0.0)) );  DataFrame dataset = jsql.createDataFrame(data, (new StructType()).add(group.toStructField()));  VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\");  vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});  DataFrame output = vectorSlicer.transform(dataset);  for (Row r : output.select(\"userFeatures\", \"features\").take(2)) { Vector features = r.getAs(1); Assert.assertEquals(features.size(), 2);",
        "ins2PreCode":"RowFactory.create(Vectors.dense(-2.0, 2.3, 0.0)) )); DataFrame dataset = jsql.createDataFrame(jrdd, (new StructType()).add(group.toStructField())); VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\"); vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"}); DataFrame output = vectorSlicer.transform(dataset); System.out.println(output.select(\"userFeatures\", \"features\").first()); VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\");",
        "label":1
    },
    {
        "ins1AddCode":"LongArray array, long numRecords, int startByteIndex, int endByteIndex, long inIndex = 0; long outIndex = numRecords; long tmp = inIndex; return Ints.checkedCast(inIndex);",
        "ins1DelCode":"LongArray array, int numRecords, int startByteIndex, int endByteIndex, int inIndex = 0; int outIndex = numRecords; int tmp = inIndex; return inIndex;",
        "ins1PreCode":"public static int sort( LongArray array, int numRecords, int startByteIndex, int endByteIndex, boolean desc, boolean signed) { assert startByteIndex >= 0 : \"startByteIndex (\" + startByteIndex + \") should >= 0\"; assert endByteIndex <= 7 : \"endByteIndex (\" + endByteIndex + \") should <= 7\"; assert endByteIndex > startByteIndex; assert numRecords * 2 <= array.size(); int inIndex = 0; int outIndex = numRecords; if (numRecords > 0) { long[][] counts = getCounts(array, numRecords, startByteIndex, endByteIndex); for (int i = startByteIndex; i <= endByteIndex; i++) { if (counts[i] != null) { sortAtByte( array, numRecords, counts[i], i, inIndex, outIndex, desc, signed && i == endByteIndex); int tmp = inIndex; inIndex = outIndex; outIndex = tmp; } } } return inIndex;",
        "ins2PreCode":"public static int sortKeyPrefixArray( array, startIndex, numRecords, startByteIndex, endByteIndex); boolean signed) { assert startByteIndex >= 0 : \"startByteIndex (\" + startByteIndex + \") should >= 0\"; assert endByteIndex <= 7 : \"endByteIndex (\" + endByteIndex + \") should <= 7\"; assert endByteIndex > startByteIndex; assert numRecords * 4 <= array.size(); int tmp = inIndex; int outIndex = startIndex + numRecords * 2; if (numRecords > 0) { array, startIndex, numRecords, startByteIndex, endByteIndex); for (int i = startByteIndex; i <= endByteIndex; i++) { if (counts[i] != null) { sortKeyPrefixArrayAtByte( array, numRecords, counts[i], i, inIndex, outIndex, desc, signed && i == endByteIndex); int tmp = inIndex; inIndex = outIndex; outIndex = tmp; } } } return inIndex;",
        "label":1
    },
    {
        "ins1AddCode":"currentPathElement = findPathElementCaseUnsensitive(this.curpwd,",
        "ins1DelCode":"currentPathElement = findPathElementCaseInsensitive(this.curpwd,",
        "ins1PreCode":"if (!this.client.changeWorkingDirectory(currentPathElement)) { if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseInsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) {",
        "ins2PreCode":".changeWorkingDirectory(currentPathElement)) { if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { findPathElementCaseInsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) {",
        "label":1
    },
    {
        "ins1AddCode":"public void testGetNamesAndItemsLinked() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"public void testGetNamesAndItemsLinked() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testGetNamesAndItemsLinked() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  List<Name> names = spMapper.getNamesAndItemsLinked(); assertEquals(4, names.size()); assertEquals(2, names.get(0).getItems().size()); assertEquals(1, names.get(1).getItems().size()); assertNull(names.get(2).getItems()); assertNull(names.get(3).getItems()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testGetNamesAndItemsLinkedWithNoMatchingInfo() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class); List<Name> names = spMapper.getNamesAndItemsLinkedById(0); assertEquals(1, names.size()); assertEquals(2, names.get(0).getItems().size()); assertEquals(2, names.get(0).getItems().size()); assertEquals(2, names.get(0).getItems().size()); assertEquals(2, names.get(0).getItems().size()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"}, false, 2, Schedulers.single())",
        "ins1DelCode":"}, 2, false, Schedulers.single())",
        "ins1PreCode":"public Observable<String> apply(Integer t) throws Throwable { return Observable.just(Thread.currentThread().getName()); } }, 2, false, Schedulers.single()) .test() .awaitDone(5, TimeUnit.SECONDS)",
        "ins2PreCode":"public Observable<String> apply(Integer t) throws Throwable { return Observable.just(Thread.currentThread().getName()); } }, 2, true, Schedulers.single()) .test() .awaitDone(5, TimeUnit.SECONDS)",
        "label":1
    },
    {
        "ins1AddCode":"JspCServletContext context = new JspCServletContext( null, appDir.toURI().toURL(), null, false, false);",
        "ins1DelCode":"JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null);",
        "ins1PreCode":"public void testWebapp_2_2() throws Exception { File appDir = new File(\"test/webapp-2.2\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion()); Assert.assertEquals(2, context.getEffectiveMinorVersion());",
        "ins2PreCode":"public void testWebapp_2_3() throws Exception { File appDir = new File(\"test/webapp-2.3\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion()); Assert.assertEquals(3, context.getEffectiveMinorVersion());",
        "label":1
    },
    {
        "ins1AddCode":"Font font = UIUtils.getMonospaceFont();",
        "ins1DelCode":"Font font = JFaceResources.getFont(JFaceResources.TEXT_FONT);",
        "ins1PreCode":"Font rsFont = currentTheme.getFontRegistry().get(ThemeConstants.FONT_SQL_RESULT_SET); if (rsFont != null) { int fontHeight = rsFont.getFontData()[0].getHeight(); Font font = JFaceResources.getFont(JFaceResources.TEXT_FONT);  FontData[] fontData = font.getFontData();",
        "ins2PreCode":"Font rsFont = currentTheme.getFontRegistry().get(ThemeConstants.FONT_SQL_RESULT_SET); if (rsFont != null) { int fontHeight = rsFont.getFontData()[0].getHeight(); Font font = JFaceResources.getFont(JFaceResources.TEXT_FONT); FontData[] fontData = font.getFontData();",
        "label":1
    },
    {
        "ins1AddCode":"public R poll() {",
        "ins1DelCode":"public R poll() throws Exception {",
        "ins1PreCode":"public R poll() throws Exception { Iterator<? extends R> iterator = it; ",
        "ins2PreCode":"public R poll() throws Exception { Iterator<? extends R> iterator = it;",
        "label":1
    },
    {
        "ins1AddCode":"new SlowQueryReportJmx().getObjectName(SlowQueryReportJmx.class, pool.getName()),",
        "ins1DelCode":"SlowQueryReportJmx.getObjectName(SlowQueryReportJmx.class, pool.getName()),",
        "ins1PreCode":"ClientListener listener = new ClientListener(); ConnectionPool pool = datasource.getPool(); ManagementFactory.getPlatformMBeanServer().addNotificationListener( SlowQueryReportJmx.getObjectName(SlowQueryReportJmx.class, pool.getName()), listener, null,",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(this.launcher, \"paths\").toString()).isEqualTo(\"[jars/]\"); this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);",
        "ins1DelCode":"PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/]\"); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);",
        "ins1PreCode":"void testUserSpecifiedSlashPath() throws Exception { System.setProperty(\"loader.path\", \"jars/\"); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/]\"); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"app.jar\"));",
        "ins2PreCode":"void testUserSpecifiedRootOfJarPath() throws Exception { System.setProperty(\"loader.path\", \"jar:file:./src/test/resources/nested-jars/app.jar!/\"); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()) List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"app.jar\"));",
        "label":1
    },
    {
        "ins1AddCode":".putAllInt32ToInt32Field(source.getInt32ToInt32FieldMap()) .putAllInt32ToStringField(source.getInt32ToStringFieldMap()) .putAllInt32ToBytesField(source.getInt32ToBytesFieldMap()) .putAllInt32ToEnumField(source.getInt32ToEnumFieldMap()) .putAllInt32ToMessageField(source.getInt32ToMessageFieldMap()) .putAllStringToInt32Field(source.getStringToInt32FieldMap());",
        "ins1DelCode":".putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "ins1PreCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "ins2PreCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "label":1
    },
    {
        "ins1AddCode":"txnManager.commit(monitor);",
        "ins1DelCode":"txnManager.commit();",
        "ins1PreCode":"DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.commit(); } catch (DBCException e) { throw new InvocationTargetException(e);",
        "ins2PreCode":"DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.rollback(null); } catch (DBCException e) { throw new InvocationTargetException(e);",
        "label":1
    },
    {
        "ins1AddCode":"StandardXYSeriesLabelGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"StandardXYSeriesLabelGenerator g2 = (StandardXYSeriesLabelGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StandardXYSeriesLabelGenerator g1 = new StandardXYSeriesLabelGenerator(\"Series {0}\"); StandardXYSeriesLabelGenerator g2 = (StandardXYSeriesLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { SymbolicXYItemLabelGenerator g1 = new SymbolicXYItemLabelGenerator(); SymbolicXYItemLabelGenerator g1 = new SymbolicXYItemLabelGenerator(); SymbolicXYItemLabelGenerator g2 = (SymbolicXYItemLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"jreCompat.canAccess(null, field)) {",
        "ins1DelCode":"jreCompat.canAcccess(null, field)) {",
        "ins1PreCode":"JreCompat jreCompat = JreCompat.getInstance(); if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && jreCompat.canAcccess(null, field)) { return field.get(null); }",
        "ins2PreCode":"JreCompat jreCompat = JreCompat.getInstance(); if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && jreCompat.canAcccess(null, field)) { return field.getType(); }",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d1 = Disposable.empty(); Disposable d2 = Disposable.empty();",
        "ins1DelCode":"Disposable d1 = Disposables.empty(); Disposable d2 = Disposables.empty();",
        "ins1PreCode":"@Override protected void subscribeActual(MaybeObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty();  observer.onSubscribe(d2);",
        "ins2PreCode":"@Override protected void subscribeActual(MaybeObserver<? super T> observer) { try { Disposable d1 = Disposables.empty(); observer.onSubscribe(d1); Disposable d2 = Disposables.empty(); observer.onSubscribe(d2);",
        "label":1
    },
    {
        "ins1AddCode":"if (!isFullyCached()) {",
        "ins1DelCode":"if (!isCached()) {",
        "ins1PreCode":"throws DBException { String objectName = oldObject.getName(); if (!isCached()) { this.loadObjects(monitor, owner); } else {",
        "ins2PreCode":"throws DBException { String objectName = oldObject.getName(); if (!isCached()) { this.loadObjects(monitor, owner); } else {",
        "label":1
    },
    {
        "ins1AddCode":"String lname = name.toLowerCase(Locale.ENGLISH);",
        "ins1DelCode":"String lname = name.toLowerCase();",
        "ins1PreCode":"public void addHeader(String name, String value) { super.addHeader(name, value); String lname = name.toLowerCase(); if (lname.equals(LAST_MODIFIED)) { try {",
        "ins2PreCode":"public void setHeader(String name, String value) { super.setHeader(name, value); String lname = name.toLowerCase(); if (lname.equals(LAST_MODIFIED)) { try {",
        "label":1
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); assertTrue(checkIndependence(r1, r2));",
        "ins2PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); assertTrue(checkIndependence(r1, r2));",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createTimeSeriesChart(\"XY Line Chart\", \"Domain\", \"Range\", dataset, true, true, true);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createTimeSeriesChart( \"XY Line Chart\", \"Domain\", \"Range\", dataset, true, true, true );",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createTimeSeriesChart( \"XY Line Chart\", \"Domain\", \"Range\", dataset, true, true, true ); ",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\", \"Range\", dataset); \"Range\", dataset); \"Range\", dataset); \"Range\", dataset); series1.add(1.0, 1.0); series1.add(1.0, 1.0); \"Range\", dataset); \"Range\", dataset);",
        "label":0
    },
    {
        "ins1AddCode":"void draggedOnBottomOfGroupAddsAfterIt() throws Exception {",
        "ins1DelCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception {",
        "ins1PreCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true);",
        "ins2PreCode":"public void draggedOnBottomOfGroupAddsAfterItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true);",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<Vector> rdd1 = uniformJavaVectorRDD(jsc, m, n); JavaRDD<Vector> rdd2 = uniformJavaVectorRDD(jsc, m, n, p); JavaRDD<Vector> rdd3 = uniformJavaVectorRDD(jsc, m, n, p, seed); for (JavaRDD<Vector> rdd : Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1DelCode":"JavaRDD<Vector> rdd1 = uniformJavaVectorRDD(sc, m, n); JavaRDD<Vector> rdd2 = uniformJavaVectorRDD(sc, m, n, p); JavaRDD<Vector> rdd3 = uniformJavaVectorRDD(sc, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1PreCode":"int n = 10; int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = uniformJavaVectorRDD(sc, m, n); JavaRDD<Vector> rdd2 = uniformJavaVectorRDD(sc, m, n, p); JavaRDD<Vector> rdd3 = uniformJavaVectorRDD(sc, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); Assert.assertEquals(n, rdd.first().size());",
        "ins2PreCode":"int n = 10; int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = normalJavaVectorRDD(sc, m, n); JavaRDD<Vector> rdd2 = normalJavaVectorRDD(sc, m, n, p); JavaRDD<Vector> rdd3 = normalJavaVectorRDD(sc, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); Assert.assertEquals(n, rdd.first().size());",
        "label":1
    },
    {
        "ins1AddCode":"\"SELECT s.*, sq.SQL_TEXT\\n\" + \"FROM V$SESSION s, V$SQL sq\\n\" + \"WHERE sq.ADDRESS(+) = s.SQL_ADDRESS AND s.TYPE = 'USER'\")) {",
        "ins1DelCode":"\"SELECT s.*,sq.SQL_TEXT FROM V$SESSION s\\n\" + \"LEFT OUTER JOIN V$SQL sq ON sq.SQL_ID=s.SQL_ID\\n\" + \"WHERE s.TYPE='USER'\")) {",
        "ins1PreCode":"{ try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"SELECT s.*,sq.SQL_TEXT FROM V$SESSION s\\n\" + \"LEFT OUTER JOIN V$SQL sq ON sq.SQL_ID=s.SQL_ID\\n\" + \"WHERE s.TYPE='USER'\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<OracleServerSession> sessions = new ArrayList<>();",
        "ins2PreCode":"{ try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { sessions.add(new PostgreSession(dbResult)); while (dbResult.next()) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>();",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"return new Completable() { @Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty());  assertFalse(((Disposable)observer).isDisposed());",
        "ins2PreCode":"return new Completable() { @Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty()); assertFalse(((Disposable)observer).isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"public void refCountAsync() throws InterruptedException { for (int i = 0; i < 10; i++) { refCountAsyncActual(); return; } catch (AssertionError ex) { if (i == 9) { throw ex; } Thread.sleep((int)(200 * (Math.random() * 10 + 1)));",
        "ins1DelCode":"public void refCountAsync() { final AtomicInteger subscribeCount = new AtomicInteger(); final AtomicInteger nextCount = new AtomicInteger(); Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS) .doOnSubscribe(new Consumer<Subscription>() { @Override public void accept(Subscription s) { subscribeCount.incrementAndGet(); } }) .doOnNext(new Consumer<Long>() { @Override public void accept(Long l) { nextCount.incrementAndGet(); } }) .publish().refCount(); final AtomicInteger receivedCount = new AtomicInteger(); Disposable d1 = r.subscribe(new Consumer<Long>() { @Override public void accept(Long l) { receivedCount.incrementAndGet(); } }); Disposable d2 = r.subscribe(); try { Thread.sleep(10); } catch (InterruptedException e) { } for (;;) { int a = nextCount.get(); int b = receivedCount.get(); if (a > 10 && a < 20 && a == b) { break; } if (a >= 20) { break; } Thread.sleep(20); } catch (InterruptedException e) { d2.dispose(); d1.dispose(); System.out.println(\"onNext: \" + nextCount.get()); assertEquals(nextCount.get(), receivedCount.get()); assertEquals(1, subscribeCount.get());",
        "ins1PreCode":"public void refCountAsync() { final AtomicInteger subscribeCount = new AtomicInteger(); final AtomicInteger nextCount = new AtomicInteger(); Flowable<Long> r = Flowable.interval(0, 20, TimeUnit.MILLISECONDS) .doOnSubscribe(new Consumer<Subscription>() { @Override public void accept(Subscription s) { subscribeCount.incrementAndGet(); } }) .doOnNext(new Consumer<Long>() { @Override public void accept(Long l) { nextCount.incrementAndGet(); } }) .publish().refCount();  final AtomicInteger receivedCount = new AtomicInteger(); Disposable d1 = r.subscribe(new Consumer<Long>() { @Override public void accept(Long l) { receivedCount.incrementAndGet(); } });  Disposable d2 = r.subscribe();  try { Thread.sleep(10); } catch (InterruptedException e) { }  for (;;) { int a = nextCount.get(); int b = receivedCount.get(); if (a > 10 && a < 20 && a == b) { break; } if (a >= 20) { break; } try { Thread.sleep(20); } catch (InterruptedException e) { } }    d2.dispose(); d1.dispose();  System.out.println(\"onNext: \" + nextCount.get());   assertEquals(nextCount.get(), receivedCount.get());  assertEquals(1, subscribeCount.get());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"new BasicStroke(1.2f), Color.RED, Color.BLUE));",
        "ins1DelCode":"new BasicStroke(1.2f), Color.red, Color.blue));",
        "ins1PreCode":"new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new XYLineAndShapeRenderer()); plot.addAnnotation(new XYBoxAnnotation(10.0, 12.0, 3.0, 4.0, new BasicStroke(1.2f), Color.red, Color.blue)); JFreeChart chart = new JFreeChart(plot); chart.createBufferedImage(300, 200,",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void runWithSystemPropertiesShouldRestoreOriginalProperties() {",
        "ins1DelCode":"public void runWithSystemPropertiesShouldRestoreOriginalProperties() throws Exception {",
        "ins1PreCode":"public void runWithSystemPropertiesShouldRestoreOriginalProperties() throws Exception { String key = \"test.\" + UUID.randomUUID(); System.setProperty(key, \"value\");",
        "ins2PreCode":"public void runWithSystemPropertiesWhenValueIsNullShouldRemoveProperty() throws Exception { String key = \"test.\" + UUID.randomUUID(); System.setProperty(key, \"value\");",
        "label":1
    },
    {
        "ins1AddCode":"for (Thread value : threads) { value.start(); } for (Thread thread : threads) { thread.join(); }",
        "ins1DelCode":"for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}",
        "ins1PreCode":"} }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis();",
        "ins2PreCode":"} }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} long start = System.currentTimeMillis();",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addApplicationListener(WsListener.class.getName());",
        "ins1DelCode":"",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\");  tomcat.start(); ",
        "ins2PreCode":"Tomcat.addServlet(ctx, \"default2\", new DefaultServlet()); ctx.addServletMapping(\"/servlets/*\", \"default2\"); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"if (FTPReply.isPositiveCompletion(ftp.getReplyCode())) {",
        "ins1DelCode":"boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode()); if (success) {",
        "ins1PreCode":"BufferedInputStream instream = new BufferedInputStream(Files.newInputStream(tempFile.toPath())); ftp.storeFile(tempFile.getName(), instream); instream.close(); boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode()); if (success) { FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName()); if (ftpFiles.length == 1) {",
        "ins2PreCode":"BufferedInputStream instream = new BufferedInputStream(Files.newInputStream(tempFile.toPath())); ftp.storeFile(tempFile.getName(), instream); instream.close(); boolean success = FTPReply.isPositiveCompletion(ftp.getReplyCode()); if (success) { FTPFile [] ftpFiles = ftp.listFiles(tempFile.getName()); if (ftpFiles.length == 1) {",
        "label":0
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"public void errorDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d); ",
        "ins2PreCode":"public void errorDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "label":1
    },
    {
        "ins1AddCode":"assertThrowsWithMessage(\"Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> {",
        "ins1DelCode":"assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> {",
        "ins1PreCode":"public void assertValueAtInvalidIndex() { assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"initialize(this.initializationContext, null, getLogFile(null, tmpDir()));",
        "ins1DelCode":"this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir()));",
        "ins1PreCode":"void exceptionsIncludeClassPackaging(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\"));",
        "ins2PreCode":"void exceptionsIncludeClassPackaging(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, getRelativeClasspathLocation(\"log4j2-file.xml\"), this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\"));",
        "label":0
    },
    {
        "ins1AddCode":"}, false, 2);",
        "ins1DelCode":"}, 2, false);",
        "ins1PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, false); } });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"public void insertRecord( Object recordBase, long recordOffset, int length, long prefix, boolean prefixIsNull) inMemSorter.insertRecord(recordAddress, prefix, prefixIsNull);",
        "ins1DelCode":"public void insertRecord(Object recordBase, long recordOffset, int length, long prefix) inMemSorter.insertRecord(recordAddress, prefix);",
        "ins1PreCode":"public void insertRecord(Object recordBase, long recordOffset, int length, long prefix) throws IOException {  growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required);  final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length; assert(inMemSorter != null); inMemSorter.insertRecord(recordAddress, prefix);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".withMessageStartingWith(\"Search location '\") .withMessageEndingWith(\"' cannot contain multiple wildcards\");",
        "ins1DelCode":".withMessage(\"Wildard pattern with multiple '*'s cannot be used as search location\");",
        "ins1PreCode":"\"spring.config.location=\" + location); assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildard pattern with multiple '*'s cannot be used as search location\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(loc.append(",
        "ins1DelCode":"Assert.assertTrue(loc.putNewKey(",
        "ins1PreCode":"key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, Platform.BYTE_ARRAY_OFFSET,",
        "ins2PreCode":"key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, Platform.BYTE_ARRAY_OFFSET,",
        "label":1
    },
    {
        "ins1AddCode":"if ( basedir == null ) { return; }",
        "ins1DelCode":"",
        "ins1PreCode":"public void alignToBaseDirectory( Model model, File basedir ) { Build build = model.getBuild();  if ( build != null ) { build.setDirectory( alignToBaseDirectory( build.getDirectory(), basedir ) );",
        "ins2PreCode":"public void unalignFromBaseDirectory( Model model, File basedir ) { Build build = model.getBuild(); if ( build != null ) { build.setDirectory( unalignFromBaseDirectory( build.getDirectory(), basedir ) );",
        "label":1
    },
    {
        "ins1AddCode":"void fromPropertySourceShouldFlattenPropertySources() {",
        "ins1DelCode":"public void fromPropertySourceShouldFlattenPropertySources() {",
        "ins1PreCode":"public void fromPropertySourceShouldFlattenPropertySources() { StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.singletonMap(\"foo\", \"bar\")));",
        "ins2PreCode":"MutablePropertySources sources = new MutablePropertySources(); StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.singletonMap(\"foo\", \"bar\")));",
        "label":1
    },
    {
        "ins1AddCode":"ExampleCustomNoDefaultConstructorBean result = this.binder .bind(\"foo\", ExampleCustomNoDefaultConstructorBean.class).get();",
        "ins1DelCode":"ExampleCustomBean result = this.binder.bind(\"foo\", ExampleCustomBean.class).get();",
        "ins1PreCode":"MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.items\", \"a,b,c,c\"); this.sources.add(source); ExampleCustomBean result = this.binder.bind(\"foo\", ExampleCustomBean.class).get(); assertThat(result.getItems()).hasSize(4); assertThat(result.getItems()).containsExactly(\"a\", \"b\", \"c\", \"c\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private boolean compareFiles(File file1, File file2) throws IOException { if (!file1.exists() || !file2.exists()) { return false; } if (file1.length() != file2.length()) { return false; } byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE]; FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { return false; return true;",
        "ins1DelCode":"private boolean compareFiles(File file1, File file2) { try { if (!file1.exists() || !file2.exists()) { System.out.println(\"One or both files do not exist:\" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile()); return false; } if (file1.length() != file2.length()) { System.out.println(\"File size mismatch:\" + file1.getAbsoluteFile() + \"(\" + file1.length() + \"), \" + file2.getAbsoluteFile()  + \"(\" + file2.length() + \")\"); return false; } byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE]; FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { System.out.println(\"Bytes mismatch:\" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile() + \" at byte \" + index); return false; } return true; catch (IOException e) { System.out.println(\"IOException comparing files: \" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile()); return false; }",
        "ins1PreCode":"private boolean compareFiles(File file1, File file2) { try { if (!file1.exists() || !file2.exists()) { System.out.println(\"One or both files do not exist:\" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile()); return false; }  if (file1.length() != file2.length()) { System.out.println(\"File size mismatch:\" + file1.getAbsoluteFile() + \"(\" + file1.length() + \"), \" + file2.getAbsoluteFile()  + \"(\" + file2.length() + \")\"); return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { System.out.println(\"Bytes mismatch:\" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile() + \" at byte \" + index); return false; } } } return true; } catch (IOException e) { System.out.println(\"IOException comparing files: \" + file1.getAbsoluteFile() + \", \" + file2.getAbsoluteFile()); return false; }",
        "ins2PreCode":"private boolean compareFiles(String name1, String name2) { try { if (!file1.exists() || !file2.exists()) { System.out.println(\"One or both files do not exist:\" + name1 + \", \" + name2); return false; } if (file1.length() != file2.length()) { System.out.println(\"File size mismatch:\" + name1 + \"(\" + file1.length() + \"), \" + name2  + \"(\" + file2.length() + \")\"); return false; } byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE]; FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { System.out.println(\"Bytes mismatch:\" + name1 + \", \" + name2 + \" at byte \" + index); return false; } } } return true; } catch (IOException e) { System.out.println(\"IOException comparing files: \" + name1 + \", \" + name2); return false; }",
        "label":1
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"plugin-config-attributes/wo-plugin-mgmt\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"plugin-config-attributes/wo-plugin-mngt\" );",
        "ins1PreCode":"public void testPluginConfigurationUsingAttributesWithoutPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"plugin-config-attributes/wo-plugin-mngt\" ); assertEquals( \"src\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@todir\" ) ); assertEquals( \"true\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@overwrite\" ) );",
        "ins2PreCode":"public void testPluginConfigurationUsingAttributesWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"plugin-config-attributes/w-plugin-mngt\" ); assertEquals( \"src\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@todir\" ) ); assertEquals( \"true\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@overwrite\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"private static void cleanDirectoryOnExit(final File directory) throws IOException {",
        "ins1DelCode":"private static void cleanDirectoryOnExit(File directory) throws IOException {",
        "ins1PreCode":"private static void cleanDirectoryOnExit(File directory) throws IOException { if (!directory.exists()) { String message = directory + \" does not exist\";",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"plugin-exec-config-order/wo-plugin-mgmt\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"plugin-exec-config-order/wo-plugin-mngt\" );",
        "ins1PreCode":"public void testOrderOfPluginExecutionConfigurationElementsWithoutPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-config-order/wo-plugin-mngt\" ); String prefix = \"build/plugins[1]/executions[1]/configuration/\"; assertEquals( \"one\", pom.getValue( prefix + \"stringParams/stringParam[1]\" ) );",
        "ins2PreCode":"public void testOrderOfPluginExecutionConfigurationElementsWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"plugin-exec-config-order/w-plugin-mngt\" ); String prefix = \"build/plugins[1]/executions[1]/configuration/\"; assertEquals( \"one\", pom.getValue( prefix + \"stringParams/stringParam[1]\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"socketWrapper.write(BlockingMode.BLOCK, protocol.getWriteTimeout(), TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE, applicationErrorCompletion, ByteBuffer.wrap(header), data);",
        "ins1DelCode":"socketWrapper.write(BlockingMode.BLOCK, getWriteTimeout(), TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE, applicationErrorCompletion, ByteBuffer.wrap(header), data);",
        "ins1PreCode":"ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue()); int orgLimit = data.limit(); data.limit(data.position() + len); socketWrapper.write(BlockingMode.BLOCK, getWriteTimeout(), TimeUnit.MILLISECONDS, null, SocketWrapperBase.COMPLETE_WRITE, applicationErrorCompletion, ByteBuffer.wrap(header), data); data.limit(orgLimit); handleAsyncException();",
        "ins2PreCode":"ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue()); int orgLimit = data.limit(); data.limit(data.position() + len); socketWrapper.write(true, data); socketWrapper.write(true, data); socketWrapper.write(true, data); data.limit(orgLimit); handleAppInitiatedIOException(ioe);",
        "label":0
    },
    {
        "ins1AddCode":"getContextRunner().withPropertyValues(\"spring.security.user.password=password\").run((context) -> { WebTestClient webTestClient = getWebTestClient(context); webTestClient.get().uri(\"/actuator/e2\").exchange().expectStatus().isUnauthorized(); webTestClient.get().uri(\"/actuator/e2\").header(\"Authorization\", getBasicAuth()).exchange().expectStatus() .isOk(); });",
        "ins1DelCode":"getContextRunner().withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO)) .withPropertyValues(\"spring.security.user.password=password\").run((context) -> { WebTestClient webTestClient = getWebTestClient(context); webTestClient.get().uri(\"/actuator/e2\").exchange().expectStatus().isUnauthorized(); webTestClient.get().uri(\"/actuator/e2\").header(\"Authorization\", getBasicAuth()).exchange() .expectStatus().isOk(); });",
        "ins1PreCode":"void toAllEndpointsShouldMatch() { getContextRunner().withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO)) .withPropertyValues(\"spring.security.user.password=password\").run((context) -> { WebTestClient webTestClient = getWebTestClient(context); webTestClient.get().uri(\"/actuator/e2\").exchange().expectStatus().isUnauthorized(); webTestClient.get().uri(\"/actuator/e2\").header(\"Authorization\", getBasicAuth()).exchange() .expectStatus().isOk(); });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(unit, \"unit is null\"); Objects.requireNonNull(scheduler, \"scheduler is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");",
        "ins1PreCode":"public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); ",
        "ins2PreCode":"public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  UnicastSubject<Integer> us = UnicastSubject.create();",
        "ins2PreCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); UnicastSubject<Integer> us = UnicastSubject.create();",
        "label":1
    },
    {
        "ins1AddCode":"AnnotatedBeanDefinition definition = createBeanDefinition(CustomNameFilter.class); this.handler.handle(definition, this.registry);",
        "ins1DelCode":"ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(CustomNameFilter.class.getName())); this.handler.handle(scanned, this.registry);",
        "ins1PreCode":"void filterWithCustomName() throws IOException { ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(CustomNameFilter.class.getName())); this.handler.handle(scanned, this.registry); BeanDefinition filterRegistrationBean = this.registry.getBeanDefinition(\"custom\"); MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues();",
        "ins2PreCode":"void servletWithCustomName() throws IOException { ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(CustomNameServlet.class.getName())); this.handler.handle(scanned, this.registry); BeanDefinition servletRegistrationBean = this.registry.getBeanDefinition(\"custom\"); MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues();",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void incidentEdges_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void incidentEdges_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"Hashtable<String, JarEntry> genericEntries = StreamUtils.enumerationAsStream(genericJar.entries()) Hashtable<String, JarEntry> wasEntries = StreamUtils.enumerationAsStream(wasJar.entries()) .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));",
        "ins1DelCode":"Hashtable<String, JarEntry> genericEntries = Collections.list(genericJar.entries()).stream() Hashtable<String, JarEntry> wasEntries = Collections.list(wasJar.entries()).stream() .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));",
        "ins1PreCode":"wasJar = new JarFile(websphereJarFile);   Hashtable<String, JarEntry> genericEntries = Collections.list(genericJar.entries()).stream() .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b, Hashtable::new));   Hashtable<String, JarEntry> wasEntries = Collections.list(wasJar.entries()).stream() .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));  ",
        "ins2PreCode":"wlJar = new JarFile(weblogicJarFile); Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); genericEntries.put(je.getName().replace('\\\\', '/'), je); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); log(\"Non class file \" + genericEntry.getName()",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType());",
        "ins1DelCode":"assertEquals(\"article\", entry.getType());",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "label":0
    },
    {
        "ins1AddCode":"void parseRecognizesEntryWithWhitespaceAtBegining() throws IOException {",
        "ins1DelCode":"public void parseRecognizesEntryWithWhitespaceAtBegining() throws IOException {",
        "ins1PreCode":"public void parseRecognizesEntryWithWhitespaceAtBegining() throws IOException { ParserResult result = parser .parse(new StringReader(\" @article{test,author={Ed von Test}}\"));",
        "ins2PreCode":"public void parseRecognizesEntryWithWhitespace() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article { test,author={Ed von Test}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testDBCPThreads10Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.threadcount = 10;",
        "ins2PreCode":"public void testPoolThreads10Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.threadcount = 10;",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"super.setUp();",
        "ins1PreCode":"public void setUp() throws Exception { super.setUp();  graph = new MetadataGraph( 4, 3 );",
        "ins2PreCode":"public void setUp() throws Exception { super.setUp(); graph = new MetadataGraph( 4, 3 );",
        "label":1
    },
    {
        "ins1AddCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(generateSessionReadQuery(options))) {",
        "ins1DelCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { boolean atLeastV11 = dataSource.isAtLeastV11(); StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, \"); if (atLeastV11) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\"); if (atLeastV11) { sql.append(\" AND s.sql_child_number = sq.child_number (+)\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) { sql.append(\" AND s.TYPE = 'USER'\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_INACTIVE)) { sql.append(\" AND s.STATUS <> 'INACTIVE'\"); } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql.toString())) {",
        "ins1PreCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { boolean atLeastV11 = dataSource.isAtLeastV11(); try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, \"); if (atLeastV11) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\");    if (atLeastV11) { sql.append(\" AND s.sql_child_number = sq.child_number (+)\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) { sql.append(\" AND s.TYPE = 'USER'\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_INACTIVE)) { sql.append(\" AND s.STATUS <> 'INACTIVE'\"); } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<OracleServerSession> sessions = new ArrayList<>();",
        "ins2PreCode":"public Collection<PostgreSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { throw new DBException(e, session.getDataSource()); try { while (dbResult.next()) { while (dbResult.next()) { } catch (SQLException e) { } catch (SQLException e) { } catch (SQLException e) { { } catch (SQLException e) { } return sessions; return sessions; sessions.add(new PostgreSession(dbResult)); throw new DBException(e, session.getDataSource()); return sessions; sessions.add(new PostgreSession(dbResult)); } catch (SQLException e) { while (dbResult.next()) { } throw new DBException(e, session.getDataSource()); sessions.add(new PostgreSession(dbResult)); } throw new DBException(e, session.getDataSource()); sessions.add(new PostgreSession(dbResult)); } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>();",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\"));",
        "ins1PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created1: No such node 'never_created1'\")); assertThat(result.stderr(), containsString(\"never_created2: No such node 'never_created2'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\"));  assertThat(j.jenkins.getView(\"aNode1\"), nullValue());",
        "ins2PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created1: No view named never_created1 inside view Jenkins\")); assertThat(result.stderr(), containsString(\"never_created2: No view named never_created2 inside view Jenkins\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); assertThat(j.jenkins.getView(\"aView1\"), nullValue());",
        "label":1
    },
    {
        "ins1AddCode":"void callbacksInvokeWhenNoGenericShouldInvokeCallbacks() {",
        "ins1DelCode":"public void callbacksInvokeWhenNoGenericShouldInvokeCallbacks() {",
        "ins1PreCode":"public void callbacksInvokeWhenNoGenericShouldInvokeCallbacks() { NonGenericCallback callbackInstance = mock(NonGenericCallback.class); String argument = \"foo\";",
        "ins2PreCode":"public void callbacksInvokeWhenHasGenericShouldInvokeCallback() { StringCallback callbackInstance = mock(StringCallback.class); String argument = \"foo\";",
        "label":1
    },
    {
        "ins1AddCode":".compose(TestHelper.conditional())",
        "ins1DelCode":".filter(Functions.alwaysTrue())",
        "ins1PreCode":" up .doFinally(this) .filter(Functions.alwaysTrue()) .subscribe(ts); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"\"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Integer.class.getCanonicalName());",
        "ins1DelCode":"\"def [\" + value.getClass().getCanonicalName() + \"] to \" + Integer.class.getCanonicalName());",
        "ins1PreCode":"return ((Number)value).intValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Integer.class.getCanonicalName()); }",
        "ins2PreCode":"return ((Number)value).longValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Long.class.getCanonicalName()); }",
        "label":1
    },
    {
        "ins1AddCode":"for (Thread thread : threads) { thread.start();",
        "ins1DelCode":"for (Thread value : threads) { value.start();",
        "ins1PreCode":"} }; } for (Thread value : threads) { value.start(); } for (Thread thread : threads) {",
        "ins2PreCode":"} }; } for (Thread value : threads) { value.start(); } for (Thread thread : threads) {",
        "label":1
    },
    {
        "ins1AddCode":"@NonNull Publisher<@NonNull ? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<@NonNull TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<@NonNull TRightEnd>> rightEnd,",
        "ins1DelCode":"@NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super TRight, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins2PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> join( @NonNull ObservableSource<? extends TRight> other, @NonNull Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super TRight, ? extends R> resultSelector Objects.requireNonNull(other, \"other is null\");",
        "label":1
    },
    {
        "ins1AddCode":"void getResourceAsStream() throws Exception {",
        "ins1DelCode":"public void getResourceAsStream() throws Exception {",
        "ins1PreCode":"public void getResourceAsStream() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\")); assertThat(archive.getManifest()).isNotNull();",
        "ins2PreCode":"public void getResourceAsStreamNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), false); assertThat(archive.getManifest()).isNotNull();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, stopwatch.elapsed(NANOSECONDS)); assertEquals(3, stopwatch.elapsed(NANOSECONDS));",
        "ins1DelCode":"assertEquals(0, stopwatch.elapsedTime(NANOSECONDS)); assertEquals(3, stopwatch.elapsedTime(NANOSECONDS));",
        "ins1PreCode":"stopwatch.reset(); assertFalse(stopwatch.isRunning()); ticker.advance(2); assertEquals(0, stopwatch.elapsedTime(NANOSECONDS)); stopwatch.start(); ticker.advance(3); assertEquals(3, stopwatch.elapsedTime(NANOSECONDS));",
        "ins2PreCode":"stopwatch.reset(); assertFalse(stopwatch.isRunning()); ticker.advance(2); assertEquals(0, stopwatch.elapsedTime(NANOSECONDS)); stopwatch.start(); ticker.advance(3); assertEquals(0, stopwatch.elapsedTime(NANOSECONDS));",
        "label":0
    },
    {
        "ins1AddCode":"application.setApplicationContextFactory(ApplicationContextFactory.ofContextClass(SpyApplicationContext.class));",
        "ins1DelCode":"application .setApplicationContextFactory(ApplicationContextFactory.forContextClass(SpyApplicationContext.class));",
        "ins1PreCode":"void registerListener() { SpringApplication application = new SpringApplication(ExampleConfig.class, ListenerConfig.class); application .setApplicationContextFactory(ApplicationContextFactory.forContextClass(SpyApplicationContext.class)); Set<ApplicationEvent> events = new LinkedHashSet<>(); application.addListeners((ApplicationListener<ApplicationEvent>) events::add);",
        "ins2PreCode":"void registerListenerWithCustomMulticaster() { SpringApplication application = new SpringApplication(ExampleConfig.class, ListenerConfig.class, application .setApplicationContextFactory(ApplicationContextFactory.forContextClass(SpyApplicationContext.class)); Set<ApplicationEvent> events = new LinkedHashSet<>(); application.addListeners((ApplicationListener<ApplicationEvent>) events::add);",
        "label":1
    },
    {
        "ins1AddCode":"public void parse(final Object umlMessage, final String text) { parseMessage(umlMessage, text);",
        "ins1DelCode":"public void parse(final Object modelElement, final String text) { parseMessage(modelElement, text);",
        "ins1PreCode":"public void parse(final Object modelElement, final String text) { try { parseMessage(modelElement, text); } catch (ParseException pe) { final String msg = \"statusmsg.bar.error.parsing.message\";",
        "ins2PreCode":"public void parse(Object modelElement, String text) { try { modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.attribute\";",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(\"Initially the rolling queue length for the label is 0.\", 0f, label.loadStatistics.queueLength.getLatest(TimeScale.SEC10), 0.0);",
        "ins1DelCode":"assertTrue( \"Initially the rolling queue length for the label is 0.\", label.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f);",
        "ins1PreCode":"FreeStyleProject project = createTestProject();   assertTrue( \"Initially the rolling queue length for the label is 0.\", label.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f);  ",
        "ins2PreCode":"FreeStyleProject project = createTestProject(); assertTrue( \"Initially the rolling queue length for the label is 0.\", label.loadStatistics.queueLength.getLatest(TimeScale.SEC10) == 0f);",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue(error);",
        "ins1DelCode":"assertEquals(true,error);",
        "ins1PreCode":"}catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; } assertEquals(true,error);",
        "ins2PreCode":"}catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; } assertEquals(false,error);",
        "label":0
    },
    {
        "ins1AddCode":"fireTreeNodesChanged(this, path, childIndices, children);",
        "ins1DelCode":"fireNodesChanged(path, childIndices, children);",
        "ins1PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins2PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesInserted(path, childIndices, children); }",
        "label":1
    },
    {
        "ins1AddCode":"SerializedObserver<T> serial = new SerializedObserver<>(t); source.subscribe(new SampleMainEmitLast<>(serial, other)); source.subscribe(new SampleMainNoLast<>(serial, other));",
        "ins1DelCode":"SerializedObserver<T> serial = new SerializedObserver<T>(t); source.subscribe(new SampleMainEmitLast<T>(serial, other)); source.subscribe(new SampleMainNoLast<T>(serial, other));",
        "ins1PreCode":"public void subscribeActual(Observer<? super T> t) { SerializedObserver<T> serial = new SerializedObserver<T>(t); if (emitLast) { source.subscribe(new SampleMainEmitLast<T>(serial, other)); } else { source.subscribe(new SampleMainNoLast<T>(serial, other)); }",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super T> s) { SerializedSubscriber<T> serial = new SerializedSubscriber<T>(s); if (emitLast) { source.subscribe(new SampleMainEmitLast<T>(serial, other)); } else { source.subscribe(new SampleMainNoLast<T>(serial, other)); }",
        "label":1
    },
    {
        "ins1AddCode":"DefaultPieDataset<String> d2 = TestUtils.serialised(d1);",
        "ins1DelCode":"DefaultPieDataset<String> d2 = (DefaultPieDataset) TestUtils.serialised(d1);",
        "ins1PreCode":"d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7);  DefaultPieDataset<String> d2 = (DefaultPieDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JenkinsRule.WebClient wc = j.createWebClient(); wc.withBasicCredentials(user.getId(), \"password\"); HtmlPage p = wc.goTo(project.getUrl()); List<HtmlForm> forms = p.getForms();",
        "ins1DelCode":"List<HtmlForm> forms = j.createWebClient().login(user.getId(), \"password\").goTo(project.getUrl()).getForms();",
        "ins1PreCode":"auth.add(Job.READ, user.getId()); auth.add(Job.CONFIGURE, user.getId()); auth.add(Jenkins.READ, user.getId()); List<HtmlForm> forms = j.createWebClient().login(user.getId(), \"password\").goTo(project.getUrl()).getForms(); for(HtmlForm form:forms){ if(\"disable\".equals(form.getAttribute(\"action\"))){",
        "ins2PreCode":"auth.add(Job.READ, user.getId()); auth.add(Job.CONFIGURE, user.getId()); auth.add(Jenkins.READ, user.getId()); List<HtmlForm> forms = j.createWebClient().login(user.getId(), \"password\").goTo(project.getUrl()).getForms(); for(HtmlForm form:forms){ if(\"enable\".equals(form.getAttribute(\"action\"))){",
        "label":1
    },
    {
        "ins1AddCode":"void testUserSpecifiedWildcardPath() throws Exception {",
        "ins1DelCode":"public void testUserSpecifiedWildcardPath() throws Exception {",
        "ins1PreCode":"public void testUserSpecifiedWildcardPath() throws Exception { System.setProperty(\"loader.path\", \"jars/*\"); System.setProperty(\"loader.main\", \"demo.Application\");",
        "ins2PreCode":"public void testUserSpecifiedJarPath() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\"); System.setProperty(\"loader.main\", \"demo.Application\");",
        "label":1
    },
    {
        "ins1AddCode":"assertMatcher(matcher, \"/actuator\").matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator\"); assertMatcher(matcher, \"/actuator\").doesNotMatch(\"/actuator/baz\");",
        "ins1DelCode":"assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator\"); assertMatcher(matcher, \"/actuator\", null).doesNotMatch(\"/actuator/baz\");",
        "ins1PreCode":"public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator\"); assertMatcher(matcher, \"/actuator\", null).doesNotMatch(\"/actuator/baz\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try ( Reader in = input )",
        "ins1DelCode":"try ( final Reader in = input )",
        "ins1PreCode":"{ Objects.requireNonNull( input, \"input cannot be null\" );  try ( final Reader in = input ) { return new SettingsXpp3Reader().read( in, isStrict( options ) );",
        "ins2PreCode":"{ Objects.requireNonNull( input, \"input cannot be null\" ); try ( final InputStream in = input ) { return new SettingsXpp3Reader().read( in, isStrict( options ) );",
        "label":1
    },
    {
        "ins1AddCode":"TypeDescriptor typeDescriptor = typeUtils.resolveTypeDescriptor( roundEnv.getRootElement(SimpleGenericProperties.class)); assertThat( typeDescriptor.getGenerics().keySet().stream().map(Object::toString)) .containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\")) .hasToString(String.class.getName()); assertThat(typeDescriptor.resolveGeneric(\"B\")) .hasToString(Integer.class.getName()); assertThat(typeDescriptor.resolveGeneric(\"C\")) .hasToString(Duration.class.getName());",
        "ins1DelCode":"for (Element rootElement : roundEnv.getRootElements()) { TypeDescriptor typeDescriptor = typeUtils .resolveTypeDescriptor((TypeElement) rootElement); assertThat(typeDescriptor.getGenerics().keySet().stream() .map(Object::toString)).containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\")) .hasToString(String.class.getName()); assertThat(typeDescriptor.resolveGeneric(\"B\")) .hasToString(Integer.class.getName()); assertThat(typeDescriptor.resolveGeneric(\"C\")) .hasToString(Duration.class.getName()); }",
        "ins1PreCode":"public void resolveTypeDescriptorOnConcreteClass() throws IOException { process(SimpleGenericProperties.class, (roundEnv, typeUtils) -> { for (Element rootElement : roundEnv.getRootElements()) { TypeDescriptor typeDescriptor = typeUtils .resolveTypeDescriptor((TypeElement) rootElement); assertThat(typeDescriptor.getGenerics().keySet().stream() .map(Object::toString)).containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\")) .hasToString(String.class.getName());",
        "ins2PreCode":"public void resolveTypeDescriptorOnIntermediateClass() throws IOException { process(AbstractIntermediateGenericProperties.class, (roundEnv, typeUtils) -> { for (Element rootElement : roundEnv.getRootElements()) { TypeDescriptor typeDescriptor = typeUtils .resolveTypeDescriptor((TypeElement) rootElement); assertThat(typeDescriptor.getGenerics().keySet().stream() .map(Object::toString)).containsOnly(\"A\", \"B\", \"C\"); assertThat(typeDescriptor.resolveGeneric(\"A\")) .hasToString(String.class.getName());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"} finally { threadCounter++;",
        "ins1PreCode":"}catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } }",
        "ins2PreCode":"}catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } }",
        "label":1
    },
    {
        "ins1AddCode":"void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception {",
        "ins1DelCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception {",
        "ins1PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"RRset<TXTRecord> rrset = new RRset<>();",
        "ins1DelCode":"RRset rrset = new RRset();",
        "ins1PreCode":"RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600, \"TXT 13 0 3600 19700101000003 19700101000000 25719 . m6sD/b0ZbfBXsQruhq5dYTnHGaA+PRTL5Y1W36rMdnGBb7eOJRRzDS5Wk5hZlrS4RUKQ/tKMCn7lsl9fn4U2lw==\", Name.root);  RRset rrset = new RRset(); rrset.addRR(txt); rrset.addRR(rrsig);",
        "ins2PreCode":"RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600L, \"TXT 3 0 3600 19700101000003 19700101000000 36714 . AAAycZeIdBGB7vjlFzd5+ZgV8IxGRLpLierdV1KO4SGIy707hKUXJRc=\", Name.root); RRset set = new RRset(); set.addRR(txt); set.addRR(rrsig);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); push(observer, \"one\", 10); push(observer, \"two\", 90);",
        "ins2PreCode":"Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); push(subscriber, \"one\", 10); push(subscriber, \"two\", 90);",
        "label":0
    },
    {
        "ins1AddCode":"}, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1DelCode":"}, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1PreCode":"public Flowable<Integer> apply(Integer v) { throw new TestException(); } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);  ts.assertNoValues();",
        "ins2PreCode":"public Flowable<Integer> apply(Integer v) { throw new TestException(); } }).subscribe(ts); ts.assertNoValues();",
        "label":0
    },
    {
        "ins1AddCode":".withCitationKey(DARWIN) .withCitationKey(EINSTEIN) .withCitationKey(NEWTON) .withCitationKey(EINSTEIN_A) .withCitationKey(EINSTEIN_B) .withCitationKey(EINSTEIN_C)",
        "ins1DelCode":".withCiteKey(DARWIN) .withCiteKey(EINSTEIN) .withCiteKey(NEWTON) .withCiteKey(EINSTEIN_A) .withCiteKey(EINSTEIN_B) .withCiteKey(EINSTEIN_C)",
        "ins1PreCode":"database2 = new BibDatabase();  BibEntry darwin = new BibEntry(StandardEntryType.Book) .withCiteKey(DARWIN) .withField(StandardField.TITLE, \"The descent of man, and selection in relation to sex\") .withField(StandardField.PUBLISHER, \"J. Murray\") .withField(StandardField.YEAR, \"1888\") .withField(StandardField.AUTHOR, \"Darwin, Charles\"); database.insertEntry(darwin);  BibEntry einstein = new BibEntry(StandardEntryType.Book) .withCiteKey(EINSTEIN) .withField(StandardField.TITLE, \"Relativity: The special and general theory\") .withField(StandardField.PUBLISHER, \"Penguin\") .withField(StandardField.YEAR, \"1920\") .withField(StandardField.AUTHOR, \"Einstein, Albert\"); database.insertEntry(einstein);  BibEntry newton = new BibEntry(StandardEntryType.Book) .withCiteKey(NEWTON) .withField(StandardField.TITLE, \"The Principia: mathematical principles of natural philosophy\") .withField(StandardField.PUBLISHER, \"Univ of California Press\") .withField(StandardField.YEAR, \"1999\") .withField(StandardField.AUTHOR, \"Newton, Isaac\"); database.insertEntry(newton); database2.insertEntry(newton);  BibEntry einsteinA = new BibEntry(StandardEntryType.InBook) .withCiteKey(EINSTEIN_A) .withField(StandardField.CROSSREF, \"Einstein1920\") .withField(StandardField.PAGES, \"22--23\"); database.insertEntry(einsteinA);  BibEntry einsteinB = new BibEntry(StandardEntryType.InBook) .withCiteKey(EINSTEIN_B) .withField(StandardField.CROSSREF, \"Einstein1921\") .withField(StandardField.PAGES, \"22--23\"); database.insertEntry(einsteinB);  BibEntry einsteinC = new BibEntry(StandardEntryType.InBook) .withCiteKey(EINSTEIN_C) .withField(StandardField.CROSSREF, \"Einstein1920\") .withField(StandardField.PAGES, \"25--33\");",
        "ins2PreCode":"database2 = new BibDatabase(); BibEntry darwin = new BibEntry(StandardEntryType.Book) .withCiteKey(DARWIN) .withField(StandardField.TITLE, \"The descent of man, and selection in relation to sex\") .withField(StandardField.PUBLISHER, \"J. Murray\") .withField(StandardField.YEAR, \"1888\") .withField(StandardField.AUTHOR, \"Darwin, Charles\"); database.insertEntry(darwin); BibEntry einstein = new BibEntry(StandardEntryType.Book) .withCiteKey(EINSTEIN) .withField(StandardField.TITLE, \"Relativity: The special and general theory\") .withField(StandardField.PUBLISHER, \"Penguin\") .withField(StandardField.YEAR, \"1920\") .withField(StandardField.AUTHOR, \"Einstein, Albert\"); database.insertEntry(einstein); BibEntry newton = new BibEntry(StandardEntryType.Book) .withCiteKey(NEWTON) .withField(StandardField.TITLE, \"The Principia: mathematical principles of natural philosophy\") .withField(StandardField.PUBLISHER, \"Univ of California Press\") .withField(StandardField.YEAR, \"1999\") .withField(StandardField.AUTHOR, \"Newton, Isaac\"); database.insertEntry(newton); database.insertEntry(newton); BibEntry einsteinA = new BibEntry(StandardEntryType.InBook) .withCiteKey(EINSTEIN_A) .withField(StandardField.CROSSREF, \"Einstein1920\") .withField(StandardField.PAGES, \"22--23\"); database2.insertEntry(einsteinA); BibEntry einsteinB = new BibEntry(StandardEntryType.InBook) .withCiteKey(EINSTEIN_B) .withField(StandardField.CROSSREF, \"Einstein1921\") .withField(StandardField.PAGES, \"22--23\"); database.insertEntry(einsteinB); BibEntry einsteinC = new BibEntry(StandardEntryType.InBook) .withCiteKey(EINSTEIN_C) .withField(StandardField.CROSSREF, \"Einstein1920\") .withField(StandardField.PAGES, \"25--33\");",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"return new Maybe<Object>() { @Override protected void subscribeActual(MaybeObserver<? super Object> observer) { observer.onSubscribe(Disposables.empty());  assertFalse(((Disposable)observer).isDisposed());",
        "ins2PreCode":"return new Maybe<Object>() { @Override protected void subscribeActual(MaybeObserver<? super Object> observer) { observer.onSubscribe(Disposables.empty()); assertFalse(((Disposable)observer).isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"if (context.getState().isAvailable())",
        "ins1DelCode":"if (context.getAvailable())",
        "ins1PreCode":"return; } context.start(); if (context.getAvailable()) writer.println(smClient.getString(\"managerServlet.started\", displayPath));",
        "ins2PreCode":"return; } context.stop(); if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", RequestUtil.filter(displayPath)));",
        "label":0
    },
    {
        "ins1AddCode":"Author expected = new Author(501, \"lmeadors\", \"******\", \"lmeadors@somewhere.com\", \"Something...\", null); Author actual = mapper.selectAuthor(501);",
        "ins1DelCode":"Author expected = new Author(500, \"cbegin\", \"******\", \"cbegin@somewhere.com\", \"Something...\", null); Author actual = mapper.selectAuthor(500);",
        "ins1PreCode":"try { manager.startManagedSession(); AuthorMapper mapper = manager.getMapper(AuthorMapper.class); Author expected = new Author(500, \"cbegin\", \"******\", \"cbegin@somewhere.com\", \"Something...\", null); mapper.insertAuthor(expected); manager.rollback(); Author actual = mapper.selectAuthor(500); assertNull(actual); } finally {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes); copyMemory(pad.base, pad.offset, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); copyMemory(remain.base, remain.offset, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes);",
        "ins1DelCode":"base.writeTo(0, data, BYTE_ARRAY_OFFSET, this.numBytes); pad.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); remain.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes);",
        "ins1PreCode":"UTF8String remain = pad.substring(0, spaces - padChars * count);  byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; base.writeTo(0, data, BYTE_ARRAY_OFFSET, this.numBytes); int offset = this.numBytes; int idx = 0; while (idx < count) { pad.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); ++ idx; offset += pad.numBytes; } remain.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes);  return UTF8String.fromBytes(data);",
        "ins2PreCode":"UTF8String remain = pad.substring(0, spaces - padChars * count); byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, numBytes()); offset += pad.numBytes; int idx = 0; while (idx < count) { pad.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); ++ idx; offset += pad.numBytes; } remain.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes); return UTF8String.fromBytes(data);",
        "label":1
    },
    {
        "ins1AddCode":"TimeSeries series = this.data.get(i);",
        "ins1DelCode":"TimeSeries series = (TimeSeries) this.data.get(i);",
        "ins1PreCode":"Args.nullNotPermitted(key, \"key\"); int seriesCount = getSeriesCount(); for (int i = 0; i < seriesCount; i++) { TimeSeries series = (TimeSeries) this.data.get(i); if (key.equals(series.getKey())) { return i;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() {",
        "ins1DelCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() throws Exception {",
        "ins1PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.location=classpath:enabletwoprofiles.properties,\"",
        "ins2PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOffFromSpecificLocation() TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.location=classpath:enableprofile.properties\");",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(BUG53792, actual);",
        "ins1DelCode":"assertEquals(BUG53792, actual);",
        "ins1PreCode":"ValueExpression ve = factory.createValueExpression(context, \"#{beanA.getBean().name}\", java.lang.String.class); String actual = (String) ve.getValue(context); assertEquals(BUG53792, actual);",
        "ins2PreCode":"ValueExpression ve = factory.createValueExpression(context, \"#{beanA.getBean().name.length()}\", java.lang.Integer.class); Integer actual = (Integer) ve.getValue(context); assertEquals(Integer.valueOf(BUG53792.length()), actual);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(principal instanceof GenericPrincipal); Assert.assertEquals(PASSWORD, ((GenericPrincipal)principal).getPassword());",
        "ins1DelCode":"assertThat(principal, is(instanceOf(GenericPrincipal.class))); assertThat( ((GenericPrincipal)principal).getPassword(), equalTo(PASSWORD));",
        "ins1PreCode":"realm.authenticate(USER, expectedResponse, NONCE, null, null, null, REALM, HA2);   assertThat(principal, is(instanceOf(GenericPrincipal.class))); assertThat( ((GenericPrincipal)principal).getPassword(), equalTo(PASSWORD));",
        "ins2PreCode":"realm.authenticate(USER, expectedResponse, NONCE, null, null, null, REALM, HA2); assertThat(principal, is(instanceOf(GenericPrincipal.class))); assertThat( ((GenericPrincipal)principal).getPassword(), equalTo(ha1()));",
        "label":0
    },
    {
        "ins1AddCode":"when(mapperService.fieldType(\"join_field\")).thenReturn(joinFieldMapper.fieldType()); when(mapperService.fieldType(\"join_field#\" + PARENT_TYPE)) .thenReturn(new ParentIdFieldMapper.ParentIdFieldType(\"join_field#\" + PARENT_TYPE, false));",
        "ins1DelCode":"MappingLookup fieldMappers = new MappingLookup(Collections.singleton(joinFieldMapper), Collections.emptyList(), Collections.emptyList(), 0, null); DocumentMapper mockMapper = mock(DocumentMapper.class); when(mockMapper.mappers()).thenReturn(fieldMappers); when(mapperService.documentMapper()).thenReturn(mockMapper);",
        "ins1PreCode":"MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getJoinField()).thenReturn(\"join_field\"); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); MappingLookup fieldMappers = new MappingLookup(Collections.singleton(joinFieldMapper), Collections.emptyList(), Collections.emptyList(), 0, null); DocumentMapper mockMapper = mock(DocumentMapper.class); when(mockMapper.mappers()).thenReturn(fieldMappers); when(mapperService.documentMapper()).thenReturn(mockMapper); return mapperService;",
        "ins2PreCode":"MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getJoinField()).thenReturn(\"join_field\"); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); MappingLookup fieldMappers = new MappingLookup(Collections.singleton(joinFieldMapper), Collections.emptyList(), Collections.emptyList(), 0, null); DocumentMapper mockMapper = mock(DocumentMapper.class); when(mockMapper.mappers()).thenReturn(fieldMappers); when(mapperService.documentMapper()).thenReturn(mockMapper); return mapperService;",
        "label":1
    },
    {
        "ins1AddCode":"ss = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\");",
        "ins1DelCode":"ss = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\");",
        "ins1PreCode":"SingleSource<? extends R> ss;  try { ss = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"SingleSource<? extends R> ss; try { ss = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null SingleSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"if (npSettings.isShowProperties() == showem) { npSettings.setShowProperties(showem); npSettings.setShowProperties(!showem);",
        "ins1DelCode":"if (diaDefault.isShowProperties() == showem) { diaDefault.setShowProperties(showem); diaDefault.setShowProperties(!showem);",
        "ins1PreCode":"public void setShowProperties(final boolean showem) { if (diaDefault.isShowProperties() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES;  public void redo() { diaDefault.setShowProperties(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { diaDefault.setShowProperties(!showem); fireNotationEvent(key, showem, !showem); }",
        "ins2PreCode":"public void setShowTypes(final boolean showem) { if (diaDefault.isShowTypes() == showem) { return; } Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_TYPES; private final ConfigurationKey key = Notation.KEY_SHOW_TYPES; public void redo() { diaDefault.setShowTypes(showem); fireNotationEvent(key, !showem, showem); } public void undo() { diaDefault.setShowTypes(!showem); fireNotationEvent(key, showem, !showem); }",
        "label":1
    },
    {
        "ins1AddCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) StringBuilder decl = super.getNestedDeclaration(monitor, owner, command, options);",
        "ins1DelCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) StringBuilder decl = super.getNestedDeclaration(owner, command, options);",
        "ins1PreCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(owner, command, options); final GenericTableColumn column = command.getObject(); if (column.isAutoIncrement()) {",
        "ins2PreCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(owner, command, options); final GenericTableColumn column = command.getObject(); if (column.isAutoIncrement()) {",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.FINE, \"toDoItemsChanged\");",
        "ins1DelCode":"LOG.debug(\"toDoItemsChanged\");",
        "ins1PreCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.debug(\"toDoItemsChanged\"); Object[] path = new Object[2]; path[0] = Designer.theDesigner().getToDoList();",
        "ins2PreCode":"public void toDoItemsAdded(ToDoListEvent tde) { LOG.debug(\"toDoItemAdded\"); Object[] path = new Object[2]; path[0] = Designer.theDesigner().getToDoList();",
        "label":1
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ObservableDoOnEach<>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins1PreCode":"Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins2PreCode":"Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "label":0
    },
    {
        "ins1AddCode":"verifyNoInteractions(factory);",
        "ins1DelCode":"verifyZeroInteractions(factory);",
        "ins1PreCode":" Observable<String> deferred = Observable.defer(factory);  verifyZeroInteractions(factory);  Observer<String> firstObserver = TestHelper.mockObserver();",
        "ins2PreCode":"Flowable<String> deferred = Flowable.defer(factory); verifyZeroInteractions(factory); Subscriber<String> firstSubscriber = TestHelper.mockSubscriber();",
        "label":1
    },
    {
        "ins1AddCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1DelCode":"h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"ParallelFailureHandling h; try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":1
    },
    {
        "ins1AddCode":"DefaultXYDataset<String> d = createSampleDataset1();",
        "ins1DelCode":"DefaultXYDataset d = createSampleDataset1();",
        "ins1PreCode":"public void testGetSeriesKey() { DefaultXYDataset d = createSampleDataset1(); assertEquals(\"S1\", d.getSeriesKey(0)); assertEquals(\"S2\", d.getSeriesKey(1));",
        "ins2PreCode":"public void testGetSeriesKey() { DefaultWindDataset d = createSampleDataset1(); assertEquals(\"Series 1\", d.getSeriesKey(0)); assertEquals(\"Series 2\", d.getSeriesKey(1));",
        "label":0
    },
    {
        "ins1AddCode":"IndexMetadata build = IndexMetadata.builder(\"\") .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT))",
        "ins1DelCode":"IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))",
        "ins1PreCode":"TermRangeQuery query = new TermRangeQuery(\"field1\", new BytesRef(\"a\"), new BytesRef(\"z\"), true, true); DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY);",
        "ins2PreCode":"PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\"); DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY);",
        "label":1
    },
    {
        "ins1AddCode":"final DummyMailServer testMailServer = DummyMailServer.startMailServer(this.local); final ClientThread testMailClient; try { testMailClient = new ClientThread(testMailServer.getPort()); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.cc(\"cc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\"); Thread client = new Thread(testMailClient); client.start(); client.join(30 * 1000); } finally { testMailServer.disconnect(); }",
        "ins1DelCode":"final int port = TEST_PORT + 3; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start(); ClientThread testMailClient = new ClientThread(port); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.cc(\"cc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\"); Thread client = new Thread(testMailClient); client.start(); server.join(60 * 1000); client.join(30 * 1000);",
        "ins1PreCode":"public void testCcOnly() throws InterruptedException { final int port = TEST_PORT + 3; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread(port);  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.cc(\"cc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000); ",
        "ins2PreCode":"public void testBccOnly() throws InterruptedException { final int port = TEST_PORT + 4; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start(); ClientThread testMailClient = new ClientThread(port); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\"); Thread client = new Thread(testMailClient); client.start(); server.join(60 * 1000); client.join(30 * 1000);",
        "label":1
    },
    {
        "ins1AddCode":"DefaultDrawingSupplier r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"DefaultDrawingSupplier r2 = (DefaultDrawingSupplier) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultDrawingSupplier r1 = new DefaultDrawingSupplier(); DefaultDrawingSupplier r2 = (DefaultDrawingSupplier) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { LevelRenderer r1 = new LevelRenderer(); LevelRenderer r2 = (LevelRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"Statement statement = configureDataSourceBehavior(",
        "ins1DelCode":"Statement statement = configureDataSourceBehaviour(",
        "ins1PreCode":"ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "ins2PreCode":"ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 100; ++i) { String results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertEquals(sb.toString(), results);",
        "ins1DelCode":"for(int i=0; i < 100;++i) { String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]);",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(\"No values\", AssertionError.class, () -> { TestObserver<Object> to = new TestObserver<>(); Observable.empty().subscribe(to); to.assertValue(new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception { return false; } });",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<>(); Observable.empty().subscribe(to); thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); to.assertValue(new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception { return false; }",
        "ins1PreCode":" Observable.empty().subscribe(to);  thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); to.assertValue(new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception {",
        "ins2PreCode":"Observable.empty().subscribe(to); thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); to.assertValueAt(0, new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"for (MBeanAttributeInfo mBeanAttributeInfo : attInfo) { if (attName.equals(mBeanAttributeInfo.getName())) { type = mBeanAttributeInfo.getType();",
        "ins1DelCode":"for (int i = 0; i < attInfo.length; i++) { if (attName.equals(attInfo[i].getName())) { type = attInfo[i].getType();",
        "ins1PreCode":"}  MBeanAttributeInfo attInfo[] = info.getAttributes(); for (int i = 0; i < attInfo.length; i++) { if (attName.equals(attInfo[i].getName())) { type = attInfo[i].getType(); return type; }",
        "ins2PreCode":"} MBeanOperationInfo attInfo[] = info.getOperations(); for (int i = 0; i < attInfo.length; i++) { if (opName.equals(attInfo[i].getName())) { if (opName.equals(attInfo[i].getName())) { return null; }",
        "label":1
    },
    {
        "ins1AddCode":"StackedXYAreaRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"StackedXYAreaRenderer r2 = (StackedXYAreaRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYAreaRenderer r1 = new StackedXYAreaRenderer(); StackedXYAreaRenderer r2 = (StackedXYAreaRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer(); ClusteredXYBarRenderer r2 = (ClusteredXYBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"void shouldTrimWHEREORWithCRLFForFirstCondition() throws Exception {",
        "ins1DelCode":"public void shouldTrimWHEREORWithCRLFForFirstCondition() throws Exception {",
        "ins1PreCode":"public void shouldTrimWHEREORWithCRLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\r\\n ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimWHEREORWithTABForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\t ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"putNotationArgument(\"pathVisible\", Boolean.valueOf(isPathVisible()));",
        "ins1DelCode":"npArguments.put(\"pathVisible\", Boolean.valueOf(isPathVisible())); Project p = getProject(); if (p != null) { npArguments.put(\"rightGuillemot\", p.getProjectSettings().getRightGuillemot()); npArguments.put(\"leftGuillemot\", p.getProjectSettings().getLeftGuillemot()); }",
        "ins1PreCode":"notationProviderName = NotationProviderFactory2.getInstance().getNotationProvider( getNotationProviderType(), own, this); npArguments.put(\"pathVisible\", Boolean.valueOf(isPathVisible())); Project p = getProject(); if (p != null) { npArguments.put(\"rightGuillemot\", p.getProjectSettings().getRightGuillemot()); npArguments.put(\"leftGuillemot\", p.getProjectSettings().getLeftGuillemot()); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertNotNull(result); assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", projectName)));",
        "ins1DelCode":"Assert.assertNotNull(result); Assert.assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", projectName)));",
        "ins1PreCode":"j.createFreeStyleProject(projectName);  Page result = j.search(projectName); Assert.assertNotNull(result); j.assertGoodStatus(result);   String contents = result.getWebResponse().getContentAsString(); Assert.assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", projectName)));",
        "ins2PreCode":"FreeStyleProject project = j.createFreeStyleProject(\"testSearchByDisplayName\"); Page result = j.search(displayName); Assert.assertNotNull(result); j.assertGoodStatus(result); String contents = result.getWebResponse().getContentAsString(); Assert.assertTrue(contents.contains(String.format(\"<title>%s [Jenkins]</title>\", displayName)));",
        "label":1
    },
    {
        "ins1AddCode":"String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"_doc\") DocumentMapper mapper = parser.parse(\"_doc\", new CompressedXContent(mapping));",
        "ins1DelCode":"String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));",
        "ins1PreCode":"public void testNotIndexed() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"index\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject());  DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));  assertEquals(mapping, mapper.mappingSource().toString());",
        "ins2PreCode":"public void testNoDocValues() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"doc_values\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject()); DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping)); assertEquals(mapping, mapper.mappingSource().toString());",
        "label":1
    },
    {
        "ins1AddCode":"private static void assertWriteLittleEndian32(byte[] data, int value) throws Exception { for (OutputType outputType : OutputType.values()) { Coder coder = outputType.newCoder(data.length); coder.stream().writeFixed32NoTag(value); coder.stream().flush(); assertEqualBytes(outputType, data, coder.toByteArray()); } Coder coder = OutputType.STREAM.newCoder(blockSize); coder.stream().writeFixed32NoTag(value); coder.stream().flush(); assertEqualBytes(OutputType.STREAM, data, coder.toByteArray());",
        "ins1DelCode":"private void assertWriteLittleEndian32(byte[] data, int value) throws Exception { ByteArrayOutputStream rawOutput = new ByteArrayOutputStream(); CodedOutputStream output = CodedOutputStream.newInstance(rawOutput); output.writeRawLittleEndian32(value); output.flush(); assertEqualBytes(data, rawOutput.toByteArray()); rawOutput = new ByteArrayOutputStream(); output = CodedOutputStream.newInstance(rawOutput, blockSize); output.writeRawLittleEndian32(value); output.flush(); assertEqualBytes(data, rawOutput.toByteArray());",
        "ins1PreCode":"private void assertWriteLittleEndian32(byte[] data, int value) throws Exception { ByteArrayOutputStream rawOutput = new ByteArrayOutputStream(); CodedOutputStream output = CodedOutputStream.newInstance(rawOutput); output.writeRawLittleEndian32(value); output.flush(); assertEqualBytes(data, rawOutput.toByteArray());   for (int blockSize = 1; blockSize <= 16; blockSize *= 2) { rawOutput = new ByteArrayOutputStream(); output = CodedOutputStream.newInstance(rawOutput, blockSize); output.writeRawLittleEndian32(value); output.flush(); assertEqualBytes(data, rawOutput.toByteArray()); }",
        "ins2PreCode":"private void assertWriteLittleEndian64(byte[] data, long value) throws Exception { ByteArrayOutputStream rawOutput = new ByteArrayOutputStream(); CodedOutputStream output = CodedOutputStream.newInstance(rawOutput); output.writeRawLittleEndian64(value); output.flush(); assertEqualBytes(data, rawOutput.toByteArray()); for (int blockSize = 1; blockSize <= 16; blockSize *= 2) { rawOutput = new ByteArrayOutputStream(); output = CodedOutputStream.newInstance(rawOutput, blockSize); output.writeRawLittleEndian64(value); output.flush(); assertEqualBytes(data, rawOutput.toByteArray()); }",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); push(observer, \"one\", 97); push(observer, \"two\", 98);",
        "ins2PreCode":"Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); push(subscriber, \"one\", 97); push(subscriber, \"two\", 98);",
        "label":0
    },
    {
        "ins1AddCode":"if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) { tasks(); }",
        "ins1DelCode":"if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks();",
        "ins1PreCode":"netOutBuffer.flip();  if (result.getStatus() == Status.OK) { if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks(); } else { throw new IOException(sm.getString(\"channel.nio.ssl.wrapFail\", result.getStatus()));",
        "ins2PreCode":"netOutBuffer.flip(); if (result.getStatus() == Status.OK) { if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks(); } else { throw new IOException(sm.getString(\"channel.nio.ssl.wrapFail\", result.getStatus()));",
        "label":0
    },
    {
        "ins1AddCode":"set.add(new ZbMATH(importFormatPreferences));",
        "ins1DelCode":"",
        "ins1PreCode":"set.add(new MedlineFetcher()); set.add(new TitleFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"BibEntry custom = new BibEntry(UNKNOWN_TYPE); BibEntry bibtex = new BibEntry(StandardEntryType.Article); BibEntry biblatex = new BibEntry(StandardEntryType.Article);",
        "ins1DelCode":"BibEntry custom = new BibEntry(new CustomEntryType(\"unknowntype\", new ArrayList<>(0), new ArrayList<>(0))); BibEntry bibtex = new BibEntry(BibtexEntryTypes.ARTICLE); BibEntry biblatex = new BibEntry(BiblatexEntryTypes.ARTICLE);",
        "ins1PreCode":"public void ignoreUnknownTypesForBibtexDecision() { BibEntry custom = new BibEntry(new CustomEntryType(\"unknowntype\", new ArrayList<>(0), new ArrayList<>(0))); BibEntry bibtex = new BibEntry(BibtexEntryTypes.ARTICLE); BibEntry biblatex = new BibEntry(BiblatexEntryTypes.ARTICLE); Collection<BibEntry> entries = Arrays.asList(custom, bibtex, biblatex); ",
        "ins2PreCode":"public void ignoreUnknownTypesForBiblatexDecision() { BibEntry custom = new BibEntry(new CustomEntryType(\"unknowntype\", new ArrayList<>(0), new ArrayList<>(0))); BibEntry bibtex = new BibEntry(BibtexEntryTypes.ARTICLE); BibEntry bibtex = new BibEntry(BibtexEntryTypes.ARTICLE); Collection<BibEntry> entries = Arrays.asList(custom, bibtex, biblatex);",
        "label":1
    },
    {
        "ins1AddCode":"@NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) {",
        "ins1DelCode":"Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3, Publisher<? extends T> source4) {",
        "ins1PreCode":"public static <T> Flowable<T> mergeDelayError( Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3, Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> concat( MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4) { MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\");",
        "label":1
    },
    {
        "ins1AddCode":"newProtocols.add(MockOptInProtocol1.NAME); newProtocols.add(MockOptInProtocol2.NAME); assertProtocolEnabled(MockOptInProtocol1.NAME, \"before the roundtrip\"); assertProtocolEnabled(MockOptInProtocol2.NAME, \"before the roundtrip\"); assertThat(\"There should be two additional enabled protocols\", assertProtocolEnabled(MockOptInProtocol1.NAME, \"after the roundtrip\"); assertProtocolEnabled(MockOptInProtocol2.NAME, \"after the roundtrip\");",
        "ins1DelCode":"Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\"))); Assume.assumeThat(\"We assume that JNLP4-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP4-connect\"))); newProtocols.add(\"JNLP3-connect\"); newProtocols.add(\"JNLP4-connect\"); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\")); assertThat(\"JNLP4-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP4-connect\")); assertThat(\"We should have two additional enabled protocols\", assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\")); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP4-connect\"));",
        "ins1PreCode":"public void agentProtocols_multipleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\"))); Assume.assumeThat(\"We assume that JNLP4-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP4-connect\")));  final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); newProtocols.add(\"JNLP4-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\")); assertThat(\"JNLP4-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP4-connect\"));  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have two additional enabled protocols\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 2)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\")); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP4-connect\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(\"[inner_hits] already contains an entry for key [some_name]\", e.getMessage());",
        "ins1DelCode":"",
        "ins1PreCode":"queryBuilder.innerHit(new InnerHitBuilder(\"some_name\")); IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> InnerHitContextBuilder.extractInnerHits(queryBuilder, Collections.singletonMap(\"some_name\", null)));",
        "ins2PreCode":"queryBuilder.innerHit(new InnerHitBuilder(\"some_name\")); IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> InnerHitContextBuilder.extractInnerHits(queryBuilder, Collections.singletonMap(\"some_name\", null)));",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairDStream<String, String> flatMapped = pairStream.flatMapValues(in -> { List<String> out = new ArrayList<>(); out.add(in + \"1\"); out.add(in + \"2\"); return out; });",
        "ins1DelCode":"JavaPairDStream<String, String> flatMapped = pairStream.flatMapValues( new Function<String, Iterable<String>>() { @Override public Iterable<String> call(String in) { List<String> out = new ArrayList<>(); out.add(in + \"1\"); out.add(in + \"2\"); return out; } });",
        "ins1PreCode":"JavaPairDStream<String, String> pairStream = JavaPairDStream.fromJavaDStream(stream);   JavaPairDStream<String, String> flatMapped = pairStream.flatMapValues( new Function<String, Iterable<String>>() { @Override public Iterable<String> call(String in) { List<String> out = new ArrayList<>(); out.add(in + \"1\");",
        "ins2PreCode":"JavaPairDStream<String, String> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<String, String> flatMapped = JavaPairDStream<String, String> flatMapped = Assert.assertEquals(expected, result); public void testFlatMapValues() { List<List<Tuple2<String, String>>> expected = Arrays.asList( ssc, inputData, 1);",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd'); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('h', 'd'); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'd');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('h');  assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'd');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('h'); assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'd', 'a'); assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'd', 'a');",
        "label":1
    },
    {
        "ins1AddCode":"List<EndpointId> ids = endpoints.stream().map(ExposableControllerEndpoint::getEndpointId)",
        "ins1DelCode":"List<EndpointId> ids = endpoints.stream().map(ExposableEndpoint::getEndpointId)",
        "ins1PreCode":"this.contextRunner.withUserConfiguration(WithRegularEndpointConfiguration.class) .run(assertDiscoverer((discoverer) -> { Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints(); List<EndpointId> ids = endpoints.stream().map(ExposableEndpoint::getEndpointId) .collect(Collectors.toList()); assertThat(ids).containsOnly(EndpointId.of(\"testcontroller\"), EndpointId.of(\"testrestcontroller\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(0, 100000) .onErrorReturn(new Function<Throwable, Integer>() {",
        "ins2PreCode":"public void backpressure() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(0, 100000) .onErrorReturn(new Function<Throwable, Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"private static JUnitTaskMirror createMirror(final JUnitTask task, final ClassLoader loader) { } catch (final ClassNotFoundException e) { final Class c = loader.loadClass(JUnitTaskMirror.class.getName() + \"Impl\"); final Constructor cons = c.getConstructor(new Class[] {JUnitTask.class}); } catch (final Exception e) {",
        "ins1DelCode":"private static JUnitTaskMirror createMirror(JUnitTask task, ClassLoader loader) { } catch (ClassNotFoundException e) { Class c = loader.loadClass(JUnitTaskMirror.class.getName() + \"Impl\"); Constructor cons = c.getConstructor(new Class[] {JUnitTask.class}); } catch (Exception e) {",
        "ins1PreCode":"private static JUnitTaskMirror createMirror(JUnitTask task, ClassLoader loader) { try { loader.loadClass(\"junit.framework.Test\"); } catch (ClassNotFoundException e) { throw new BuildException( \"The <classpath> for <junit> must include junit.jar \" + \"if not in Ant's own classpath\", e, task.getLocation()); } try { Class c = loader.loadClass(JUnitTaskMirror.class.getName() + \"Impl\"); if (c.getClassLoader() != loader) { throw new BuildException(\"Overdelegating loader\", task.getLocation()); } Constructor cons = c.getConstructor(new Class[] {JUnitTask.class}); return (JUnitTaskMirror) cons.newInstance(new Object[] {task}); } catch (Exception e) { throw new BuildException(e, task.getLocation()); }",
        "ins2PreCode":"private static FTPTaskMirror createMirror(FTPTask task, try { loader.loadClass(\"org.apache.commons.net.ftp.FTP\"); } catch (ClassNotFoundException e) { throw new BuildException(e, task.getLocation()); throw new BuildException(\"The <classpath> for <ftp> must include\" + \" commons-net.jar if not in Ant's own \" task.getLocation()); } try { Class c = loader.loadClass(FTPTaskMirror.class.getName() + \"Impl\"); if (c.getClassLoader() != loader) { throw new BuildException(\"Overdelegating loader\", } Constructor cons = c.getConstructor(new Class[] {FTPTask.class}); return (FTPTaskMirror) cons.newInstance(new Object[] {task}); } catch (Exception e) { throw new BuildException(e, task.getLocation()); }",
        "label":0
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"unknown\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"unknown\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@unknown{test,author={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"unknown\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser.parse( new StringReader(\"@thisIsALongStringToTestMaybeItIsToLongWhoKnowsNOTme{test,author={Ed von Test}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(1, c.size()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(((TestMRApp)appMaster).getTestIsLastAMRetry());",
        "ins1DelCode":"Assert.assertEquals(true, ((TestMRApp)appMaster).getTestIsLastAMRetry());",
        "ins1PreCode":"appMaster.start(); appMaster.shutDownJob();  Assert.assertEquals(true, ((TestMRApp)appMaster).getTestIsLastAMRetry()); verify(fs).delete(stagingJobPath, true);",
        "ins2PreCode":"appMaster.start(); appMaster.shutDownJob(); Assert.assertEquals(true, ((TestMRApp) appMaster).getTestIsLastAMRetry()); verify(fs, times(0)).delete(stagingJobPath, true);",
        "label":1
    },
    {
        "ins1AddCode":"public void updateTimestampDisabled() { assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\"); assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"New timestamp set after entry changed even though updates were disabled\");",
        "ins1DelCode":"public void updateTimestampDisabled(){ assertEquals(\"Initial timestamp not set correctly\", Optional.of(baseDate), bibEntry.getField(timestampField)); assertEquals(\"New timestamp set after entry changed even though updates were disabled\", Optional.of(baseDate), bibEntry.getField(timestampField));",
        "ins1PreCode":"public void updateTimestampDisabled(){ final String timestampField = \"timestamp\"; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = false;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.includeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(\"Initial timestamp not set correctly\", Optional.of(baseDate), bibEntry.getField(timestampField));  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(\"test\", \"some value\");  assertEquals(\"New timestamp set after entry changed even though updates were disabled\", Optional.of(baseDate), bibEntry.getField(timestampField));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void cloudFoundryPlatformActiveSetsApplicationId() {",
        "ins1DelCode":"public void cloudFoundryPlatformActiveSetsApplicationId() {",
        "ins1PreCode":"public void cloudFoundryPlatformActiveSetsApplicationId() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:https://my-cloud-controller.com\").run((context) -> {",
        "ins2PreCode":"public void cloudFoundryPlatformActiveSetsApplicationId() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:https://my-cloud-controller.com\").run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.INFO, \"allAvailableFeatures start\"); for (ModelElement genElem LOG.log(Level.INFO, \"allAvailableFeatures {0}\", returnList.size());",
        "ins1DelCode":"LOG.info(\"allAvailableFeatures start\"); for (ModelElement genElem LOG.info(\"allAvailableFeatures \" + returnList.size());",
        "ins1PreCode":"public Collection<Feature> allAvailableFeatures(Object arole) { LOG.info(\"allAvailableFeatures start\");  if (arole instanceof ClassifierRole) { try { List<Feature> returnList = new ArrayList<Feature>(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableFeatures(genElem)); } } for (Classifier classifier : role.getBase()) { returnList.addAll(classifier.getFeature()); } LOG.info(\"allAvailableFeatures \" + returnList.size()); return returnList; } catch (InvalidObjectException e) {",
        "ins2PreCode":"public Collection allAvailableContents(Object arole) { LOG.info(\"allAvailableContents start\"); if (arole instanceof ClassifierRole) { try { List returnList = new ArrayList(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableContents(genElem)); } } for (Classifier baseClassifier : role.getBase()) { returnList.addAll(baseClassifier.getOwnedElement()); } LOG.info(\"allAvailableContents \" + returnList.size()); return returnList; } catch (InvalidObjectException e) {",
        "label":0
    },
    {
        "ins1AddCode":"for (String blockId : blockIds) {",
        "ins1DelCode":"for (int chunkIndex = 0; chunkIndex < blockIds.length; chunkIndex++) { String blockId = blockIds[chunkIndex];",
        "ins1PreCode":"new long[]{0, 2, 10}, new int[][]{{0}, {1}, {2}}, false), conf);  for (int chunkIndex = 0; chunkIndex < blockIds.length; chunkIndex++) { String blockId = blockIds[chunkIndex]; verify(listener).onBlockFetchSuccess(blockId, blocks.get(blockId)); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"verifyNoInteractions(func);",
        "ins1DelCode":"verifyZeroInteractions(func);",
        "ins1PreCode":" Observable<Object> fromSupplierObservable = Observable.fromSupplier(func);  verifyZeroInteractions(func);  fromSupplierObservable.subscribe();",
        "ins2PreCode":"Flowable<Object> fromSupplierFlowable = Flowable.fromSupplier(func); verifyZeroInteractions(func); fromSupplierFlowable.subscribe();",
        "label":1
    },
    {
        "ins1AddCode":"ensureNonPatternSetsReady();",
        "ins1DelCode":"if (!areNonPatternSetsReady) { includePatterns = fillNonPatternSet(includeNonPatterns, includes); excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes); areNonPatternSetsReady = true; }",
        "ins1PreCode":"protected boolean isIncluded(String name) { if (!areNonPatternSetsReady) { includePatterns = fillNonPatternSet(includeNonPatterns, includes); excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes); areNonPatternSetsReady = true; } ",
        "ins2PreCode":"protected boolean isExcluded(String name) { if (!areNonPatternSetsReady) { includePatterns = fillNonPatternSet(includeNonPatterns, includes); excludePatterns = fillNonPatternSet(excludeNonPatterns, excludes); areNonPatternSetsReady = true; }",
        "label":1
    },
    {
        "ins1AddCode":"public static <T> Flowable<T> ambArray(@NonNull Publisher<@NonNull ? extends T>... sources) {",
        "ins1DelCode":"public static <T> Flowable<T> ambArray(Publisher<@NonNull ? extends T>... sources) {",
        "ins1PreCode":"public static <T> Flowable<T> ambArray(Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); int len = sources.length;",
        "ins2PreCode":"public static <T> Observable<T> ambArray(@NonNull ObservableSource<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); int len = sources.length;",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 36; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 33; i++) jj_la1[i] = -1;",
        "ins1PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"CategoryTableXYDataset d2 = CloneUtils.clone(d1);",
        "ins1DelCode":"CategoryTableXYDataset d2 = (CategoryTableXYDataset) d1.clone();",
        "ins1PreCode":"d1.add(1.0, 1.1, \"Series 1\"); d1.add(2.0, 2.2, \"Series 1\");  CategoryTableXYDataset d2 = (CategoryTableXYDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass());",
        "ins2PreCode":"d1.add(1.0, 1.1, \"Series 1\"); d1.add(2.0, 2.2, \"Series 1\"); CategoryTableXYDataset d2 = (CategoryTableXYDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":" });  to.onSubscribe(Disposables.empty());  try {",
        "ins2PreCode":"}); to.onSubscribe(Disposables.empty()); try {",
        "label":1
    },
    {
        "ins1AddCode":"if (vpath.isEmpty()) { completePath = rootPath; } else {",
        "ins1DelCode":"if (!\"\".equals(vpath)) { } else { completePath = rootPath;",
        "ins1PreCode":"return; } String completePath; if (!\"\".equals(vpath)) { completePath = rootPath + task.getSeparator() + vpath.replace(File.separatorChar, task.getSeparator().charAt(0));",
        "ins2PreCode":"return; } String completePath = null; if (!vpath.isEmpty()) { completePath = rootPath + remoteFileSep + vpath.replace(File.separatorChar, remoteFileSep.charAt(0));",
        "label":0
    },
    {
        "ins1AddCode":"String results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertEquals(\"a string\", results);",
        "ins1DelCode":"String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertEquals(1, results.length); assertEquals(\"a string\", results[0]);",
        "ins1PreCode":"public void testThatWindowsLineTerminatedStringReturnsNonEmptyResult() { TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"public void testThatUnixLineTerminatedStringReturnsNonEmptyResult() { TextLineDecoder decoder = new TextLineDecoder(); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1AddCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 10000,",
        "ins1DelCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 30000,",
        "ins1PreCode":"private void assertPageContains(String pageUrl, String expectedBody, int expectedStatus) throws IOException { ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 30000, null, null); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); } else {",
        "ins1DelCode":"if (c != -1) { else { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); }",
        "ins1PreCode":"public int getSubIntervalCount(Comparable rowKey, Comparable columnKey) { int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getSubIntervalCount(r, c + this.firstCategoryIndex);",
        "ins2PreCode":"public Number getStartValue(Comparable rowKey, Comparable columnKey) { int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getStartValue(r, c + this.firstCategoryIndex);",
        "label":1
    },
    {
        "ins1AddCode":"@Override",
        "ins1DelCode":"",
        "ins1PreCode":"private static FormFillFailure _errorWithMarkup(@NonNull final String message, final FormValidation.Kind kind) { return new FormFillFailure(kind, message) { public String renderHtml() { StaplerRequest req = Stapler.getCurrentRequest(); if (req == null) { return message; }  return \"<div class=\" + getKind().name().toLowerCase(Locale.ENGLISH) + \"><img src='\" + req.getContextPath() + Jenkins.RESOURCE_PATH + \"/images/none.gif' height=16 width=1>\" + message + \"</div>\"; }  @Override public String toString() { return kind + \": \" + message; } };",
        "ins2PreCode":"private static FormValidation _errorWithMarkup(final String message, final Kind kind) { return new FormValidation(kind, message) { public String renderHtml() { StaplerRequest req = Stapler.getCurrentRequest(); if (req == null) { return message; } return \"<div class=\"+ kind.name().toLowerCase(Locale.ENGLISH) +\"><img src='\"+ req.getContextPath()+ Jenkins.RESOURCE_PATH+\"/images/none.gif' height=16 width=1>\"+ message+\"</div>\"; } @Override public String toString() { @Override public String toString() { return kind + \": \" + message; } };",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"59;\", bitset(x.bits[0])); assertEquals(\"8;\", bitset(x.bits[1]));",
        "ins1DelCode":"assertEquals(x.bits[0],1L<<59); assertEquals(x.bits[1],1L<<8);",
        "ins1PreCode":"} });  assertEquals(x.bits[0],1L<<59); assertEquals(x.bits[1],1L<<8);",
        "ins2PreCode":"} }); assertEquals(x.bits[0],1L<<1); assertEquals(x.bits[1],1L<<6);",
        "label":0
    },
    {
        "ins1AddCode":"XContentParseException exception = expectThrows(XContentParseException.class, assertThat(exception.getMessage(), containsString(\"[reciprocal_rank] unknown field\"));",
        "ins1DelCode":"IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, assertThat(exception.getMessage(), startsWith(\"[reciprocal_rank] unknown field\"));",
        "ins1PreCode":"try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { parser.nextToken(); parser.nextToken(); IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> MeanReciprocalRank.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[reciprocal_rank] unknown field\")); }",
        "ins2PreCode":"try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { parser.nextToken(); parser.nextToken(); IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> DiscountedCumulativeGain.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[dcg_at] unknown field\")); }",
        "label":1
    },
    {
        "ins1AddCode":"}), true, 2, ImmediateThinScheduler.INSTANCE)",
        "ins1DelCode":"}), 2, true, ImmediateThinScheduler.INSTANCE)",
        "ins1PreCode":"o.onSubscribe(Disposables.empty()); o.onError(new TestException(\"First\")); } }), 2, true, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer()); ",
        "ins2PreCode":"s.onSubscribe(new BooleanSubscription()); s.onError(new TestException(\"First\")); } }), 2, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer());",
        "label":0
    },
    {
        "ins1AddCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedAreaChart(",
        "ins2PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart(",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(-1, project.getEstimatedDuration());",
        "ins1DelCode":"Assert.assertEquals(-1, project.getEstimatedDuration());",
        "ins1PreCode":"TestBuild lastBuild = new TestBuild(project, Result.FAILURE, 42, null); runs.put(1, lastBuild);  Assert.assertEquals(-1, project.getEstimatedDuration());",
        "ins2PreCode":"TestBuild lastBuild = new TestBuild(project, Result.FAILURE, 50, null); runs.put(1, lastBuild); Assert.assertEquals(50, project.getEstimatedDuration());",
        "label":1
    },
    {
        "ins1AddCode":"s -> Arrays.asList(s.split(\"(?!^)\")).iterator());",
        "ins1DelCode":"s -> Lists.newArrayList(s.split(\"(?!^)\")).iterator());",
        "ins1PreCode":" JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> flatMapped = stream.flatMap( s -> Lists.newArrayList(s.split(\"(?!^)\")).iterator()); JavaTestUtils.attachTestOutputStream(flatMapped); List<List<String>> result = JavaTestUtils.runStreams(ssc, 3, 3);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void setCookieHeaderIsNotIncludedByDefault() {",
        "ins1DelCode":"public void setCookieHeaderIsNotIncludedByDefault() {",
        "ins1PreCode":"public void setCookieHeaderIsNotIncludedByDefault() { HttpTrace trace = new HttpTrace(createRequest()); new HttpExchangeTracer(EnumSet.of(Include.RESPONSE_HEADERS)).sendingResponse(trace,",
        "ins2PreCode":"public void mixedCaseSetCookieHeaderIsNotIncludedByDefault() { HttpTrace trace = new HttpTrace(createRequest()); new HttpExchangeTracer(EnumSet.of(Include.RESPONSE_HEADERS)).sendingResponse(trace,",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<List<Integer>> ts = new TestSubscriber<>(3L);",
        "ins1DelCode":"TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(3L);",
        "ins1PreCode":"public void producerRequestThroughBufferWithSize1() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(3L);  final AtomicLong requested = new AtomicLong();",
        "ins2PreCode":"public void producerRequestThroughBufferWithSize3() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(3L); final AtomicLong requested = new AtomicLong();",
        "label":1
    },
    {
        "ins1AddCode":"public void tomcatCustomizers() {",
        "ins1DelCode":"public void tomcatCustomizers() throws Exception {",
        "ins1PreCode":"public void tomcatCustomizers() throws Exception { TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4];",
        "ins2PreCode":"public void tomcatListeners() throws Exception { TomcatReactiveWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4];",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYLineChart(\"XY Line Chart\", \"Domain\", \"Range\", dataset);",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1AddCode":"List<String> u1 = new ArrayList<>(); List<String> u2 = new ArrayList<>();",
        "ins1DelCode":"List u1 = new java.util.ArrayList(); List u2 = new java.util.ArrayList();",
        "ins1PreCode":"public void testSerialization() { List u1 = new java.util.ArrayList(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\");  List u2 = new java.util.ArrayList(); u2.add(\"URL B1\"); u2.add(\"URL B2\");",
        "ins2PreCode":"public void testSerialization() { List u1 = new java.util.ArrayList(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\"); List u2 = new java.util.ArrayList(); u2.add(\"URL B1\"); u2.add(\"URL B2\");",
        "label":1
    },
    {
        "ins1AddCode":"setMapValuesUsingAccessors(builder);",
        "ins1DelCode":"setMapValuesUsingMutableMap(builder);",
        "ins1PreCode":"public void testRemove() { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1)); for (int times = 0; times < 2; times++) {",
        "ins2PreCode":"public void testRemove() { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1)); for (int times = 0; times < 2; times++) {",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(other, \"other is null\"); Objects.requireNonNull(leftEnd, \"leftEnd is null\"); Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");",
        "ins1PreCode":"Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd, BiFunction<? super T, ? super Observable<TRight>, ? extends R> resultSelector ) { ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "ins2PreCode":"Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) { BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) { ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "label":1
    },
    {
        "ins1AddCode":"Class<?>[] interfaces = type.getInterfaces(); for (Class<?> iface : interfaces) { mp = iface.getMethod(m.getName(), m.getParameterTypes());",
        "ins1DelCode":"Class<?>[] inf = type.getInterfaces(); for (Class<?> aClass : inf) { mp = aClass.getMethod(m.getName(), m.getParameterTypes());",
        "ins1PreCode":"(jreCompat.canAcccess(base, m) || base != null && jreCompat.canAcccess(null, m)))) { return m; } Class<?>[] inf = type.getInterfaces(); Method mp = null; for (Class<?> aClass : inf) { try { mp = aClass.getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp); if (mp != null) {",
        "ins2PreCode":"(jreCompat.canAcccess(base, m) || base != null && jreCompat.canAcccess(null, m)))) { return m; } Class<?>[] inf = type.getInterfaces(); Method mp = null; for (Class<?> aClass : inf) { try { mp = aClass.getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp); if (mp != null) {",
        "label":1
    },
    {
        "ins1AddCode":"BufferCloseObserver<T, C> bc = new BufferCloseObserver<>(this, idx);",
        "ins1DelCode":"BufferCloseObserver<T, C> bc = new BufferCloseObserver<T, C>(this, idx);",
        "ins1PreCode":"bufs.put(idx, buf); }  BufferCloseObserver<T, C> bc = new BufferCloseObserver<T, C>(this, idx); observers.add(bc); p.subscribe(bc);",
        "ins2PreCode":"bufs.put(idx, buf); } BufferCloseSubscriber<T, C> bc = new BufferCloseSubscriber<T, C>(this, idx); subscribers.add(bc); p.subscribe(bc);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(output).isEqualTo(expectedOutput.toString());",
        "ins1DelCode":"Assert.assertEquals(output, expectedOutput.toString());",
        "ins1PreCode":"expectedOutput.append(key1).append(\"\\n\"); expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); Assert.assertEquals(output, expectedOutput.toString());",
        "ins2PreCode":"expectedOutput.append(key1).append(\"\\n\"); expectedOutput.append(key2).append('\\t').append(val2).append(\"\\n\"); String output = slurp(expectedFile); assertEquals(output, expectedOutput.toString());",
        "label":0
    },
    {
        "ins1AddCode":"Throwable cause = null; cause = orCause(cause, be, JavaEnvUtils.getJavaVersionNumber() < 14); cause = orCause(cause, be, true); cause = orCause(cause, be, true); throw new BuildException(\"No supported regular expression matcher found\" + (cause != null ? \": \" + cause : \"\"), cause);",
        "ins1DelCode":"throw new BuildException(\"No supported regular expression matcher found\");",
        "ins1PreCode":" }  throw new BuildException(\"No supported regular expression matcher found\");",
        "ins2PreCode":"} throw new BuildException(\"No supported regular expression matcher found\");",
        "label":1
    },
    {
        "ins1AddCode":"Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}};",
        "ins1DelCode":"Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};",
        "ins1PreCode":"public void testReplaceDataset() {   Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "ins2PreCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; CategoryDataset newData = DatasetUtils.createCategoryDataset(",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriber<Object> ts = new TestSubscriber<>();",
        "ins1DelCode":"final TestSubscriber<Object> ts = new TestSubscriber<Object>();",
        "ins1PreCode":"} });  final TestSubscriber<Object> ts = new TestSubscriber<Object>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"} }); final TestSubscriber<Object> ts = new TestSubscriber<Object>(); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", new Author(101));",
        "ins1DelCode":"\"domain.blog.mappers.AuthorMapper.selectAuthor\", new Author(101));",
        "ins1PreCode":"SqlSession session = sqlMapper.openSession(); try { Author author = session.selectOne( \"domain.blog.mappers.AuthorMapper.selectAuthor\", new Author(101)); assertEquals(101, author.getId()); assertEquals(Section.NEWS, author.getFavouriteSection());",
        "ins2PreCode":"SqlSession session = sqlMapper.openSession(); try { ImmutableAuthor author = session.selectOne( \"domain.blog.mappers.AuthorMapper.selectImmutableAuthor\", new Author(101)); assertEquals(101, author.getId()); assertEquals(Section.NEWS, author.getFavouriteSection());",
        "label":1
    },
    {
        "ins1AddCode":"buildRule.executeTarget(target); String output = buildRule.getProject().getProperty(\"output\"); assertTrue(new File(output,\"E\").exists()); assertTrue(new File(output,\"E/1\").exists()); assertTrue(!new File(output,\"A/1\").exists());",
        "ins1DelCode":"executeTarget(target); assertTrue(new File(getOutputDir(),\"E\").exists()); assertTrue(new File(getOutputDir(),\"E/1\").exists()); assertTrue(!new File(getOutputDir(),\"A/1\").exists());",
        "ins1PreCode":"private void testCompleteDirectoryMove(String target) throws IOException { executeTarget(target); assertTrue(new File(getOutputDir(),\"E\").exists()); assertTrue(new File(getOutputDir(),\"E/1\").exists()); assertTrue(!new File(getOutputDir(),\"A/1\").exists());  ",
        "ins2PreCode":"public void testPathElementMove() throws IOException { executeTarget(\"testPathElementMove\"); assertTrue(new File(getOutputDir(),\"E\").exists()); assertTrue(new File(getOutputDir(),\"E/1\").exists()); assertTrue(!new File(getOutputDir(),\"A/1\").exists());",
        "label":1
    },
    {
        "ins1AddCode":"if (!ObjectUtils.equal(this.arrowStroke, that.arrowStroke)) {",
        "ins1DelCode":"if (!ObjectUtilities.equal(this.arrowStroke, that.arrowStroke)) {",
        "ins1PreCode":"if (!this.arrowPaint.equals(that.arrowPaint)) { return false; } if (!ObjectUtilities.equal(this.arrowStroke, that.arrowStroke)) { return false; }",
        "ins2PreCode":"if (!this.arrowPaint.equals(that.arrowPaint)) { return false; } if (!ObjectUtilities.equal(this.arrowStroke, that.arrowStroke)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"Path auxFile = Path.of(TexGroupTest.class.getResource(\"paper.aux\").toURI());",
        "ins1DelCode":"Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI());",
        "ins1PreCode":"public void containsReturnsTrueForEntryInAux() throws Exception { Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData); BibEntry inAux = new BibEntry();",
        "ins2PreCode":"public void containsReturnsTrueForEntryNotInAux() throws Exception { Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData); BibEntry notInAux = new BibEntry();",
        "label":1
    },
    {
        "ins1AddCode":"int limit = getLimitInternal(); long newSize; long desiredSize = end + count; if (desiredSize > limit) { buff = new byte[(int) desiredSize]; if (desiredSize < 2L * buff.length) { newSize = buff.length * 2L; newSize = buff.length * 2L + count; if (newSize > limit) { tmp = new byte[(int) newSize];",
        "ins1DelCode":"int newSize; int desiredSize = end + count; if (limit > 0 && desiredSize > limit) { buff = new byte[desiredSize]; if (desiredSize < 2 * buff.length) { newSize = buff.length * 2; newSize = buff.length * 2 + count; if (limit > 0 && newSize > limit) { tmp = new byte[newSize];",
        "ins1PreCode":"public void makeSpace(int count) { byte[] tmp = null;  int newSize; int desiredSize = end + count;   if (limit > 0 && desiredSize > limit) { desiredSize = limit; }  if (buff == null) { if (desiredSize < 256) { desiredSize = 256; } buff = new byte[desiredSize]; }    if (desiredSize <= buff.length) { return; }  if (desiredSize < 2 * buff.length) { newSize = buff.length * 2; } else { newSize = buff.length * 2 + count; }  if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new byte[newSize];  ",
        "ins2PreCode":"public void makeSpace(int count) { tmp = null; int newSize; int desiredSize = end + count; if (limit > 0 && desiredSize > limit) { desiredSize = limit; } if (buff == null) { if (desiredSize < 256) { desiredSize = 256; } buff = new char[desiredSize]; } if (desiredSize <= buff.length) { return; } if (desiredSize < 2 * buff.length) { newSize = buff.length * 2; } else { newSize = buff.length * 2 + count; } if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new char[newSize];",
        "label":1
    },
    {
        "ins1AddCode":"public void bindToArrayWhenNestedShouldReturnPopulatedArray() {",
        "ins1DelCode":"public void bindToArrayWhenNestedShouldReturnPopulatedArray() throws Exception {",
        "ins1PreCode":"public void bindToArrayWhenNestedShouldReturnPopulatedArray() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0][0]\", \"1\");",
        "ins2PreCode":"public void bindToArrayWhenNestedListShouldReturnPopulatedArray() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0][0]\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"if (vr == null || cancelled) {",
        "ins1DelCode":"if (vr == null) {",
        "ins1PreCode":"vr = null; }  if (vr == null) { continue; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(dispatch.isAsyncStartedCorrect());",
        "ins1DelCode":"",
        "ins1PreCode":"count ++; } Assert.assertEquals(expectedTrack, getTrack());   alv.validateAccessLog(1, 200, 0, REQUEST_TIME);",
        "ins2PreCode":"count ++; } Assert.assertEquals(expectedTrack, getTrack()); alv.validateAccessLog(1, 500, 0, REQUEST_TIME);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertValuePredicateMatchButMore() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  Observable.just(1, 2).subscribe(to);",
        "ins2PreCode":"public void assertValueAtPredicateMatch() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.just(1, 2).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue();",
        "ins1PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"trace\")).isTrue();",
        "ins2PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"trace\")).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(new UnknownEntryType(\"unknown\"), entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(new UnknownEntryType(\"thisisalongstringtotestmaybeitistolongwhoknowsnotme\"), entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) chart.getPlot();",
        "ins1PreCode":"XYSeriesCollection<String> dataset = new XYSeriesCollection<>(); JFreeChart chart = ChartFactory.createXYLineChart(\"Test Chart\", \"Domain Axis\", \"Range Axis\", dataset); XYPlot plot = (XYPlot) chart.getPlot(); plot.addDomainMarker(new ValueMarker(1.0), Layer.FOREGROUND); plot.addDomainMarker(new IntervalMarker(2.0, 3.0), Layer.BACKGROUND);",
        "ins2PreCode":"DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>(); JFreeChart chart = ChartFactory.createBarChart( \"Test Chart\", \"Category Axis\", \"Value Axis\", CategoryPlot<String, String> plot = (CategoryPlot) chart.getPlot(); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND);",
        "label":0
    },
    {
        "ins1AddCode":"List<LabeledPoint> trainingBatch = Arrays.asList( attachTestInputStream(ssc, Arrays.asList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Arrays.asList( attachTestInputStream(ssc, Arrays.asList(testBatch, testBatch), 2));",
        "ins1DelCode":"List<LabeledPoint> trainingBatch = Lists.newArrayList( attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2));",
        "ins1PreCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Lists.newArrayList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2)); StreamingLogisticRegressionWithSGD slr = new StreamingLogisticRegressionWithSGD() .setNumIterations(2)",
        "ins2PreCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Lists.newArrayList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2)); StreamingLinearRegressionWithSGD slr = new StreamingLinearRegressionWithSGD() .setNumIterations(2)",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateStarShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateStarShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"fireNodesInserted(path, childIndices, children);",
        "ins1DelCode":"fireTreeNodesInserted(this, path, childIndices, children);",
        "ins1PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireTreeNodesInserted(this, path, childIndices, children); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"never_created1: No such item \u2018never_created1\u2019 exists.\")); assertThat(result.stderr(), containsString(\"never_created2: No such item \u2018never_created2\u2019 exists.\"));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"never_created1: No such job \\u2018never_created1\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"never_created2: No such job \\u2018never_created2\\u2019 exists.\"));",
        "ins1PreCode":" assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created1: No such job \\u2018never_created1\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"never_created2: No such job \\u2018never_created2\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"blocks.put(\"shufflePush_0_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"shufflePush_0_0_2_0\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_1_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_2_0\"), any());",
        "ins1DelCode":"blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"shufflePush_0_2_0\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_2_0\"), any());",
        "ins1PreCode":"public void testPushThree() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"shufflePush_0_2_0\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_2_0\"), any());",
        "ins2PreCode":"public void testServerFailures() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]); BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any());",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void inputOutputAsyncFusedError() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  UnicastSubject<Integer> us = UnicastSubject.create();",
        "ins2PreCode":"public void inputOutputAsyncFusedErrorDelayed() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); UnicastSubject<Integer> us = UnicastSubject.create();",
        "label":1
    },
    {
        "ins1AddCode":"MutableNetwork<String, String> mutableNetwork = NetworkBuilder.directed().build(); mutableNetwork.addEdge(\"A\", \"A\", \"AA\"); mutableNetwork.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> network = ImmutableNetwork.copyOf(mutableNetwork); assertThat(network.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(network.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(network.edgesConnecting(\"B\", \"A\")).isEmpty();",
        "ins1DelCode":"MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdge(\"A\", \"A\", \"AA\"); mutableGraph.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph); assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(graph.edgesConnecting(\"B\", \"A\")).isEmpty();",
        "ins1PreCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdge(\"A\", \"A\", \"AA\"); mutableGraph.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);  assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(graph.edgesConnecting(\"B\", \"A\")).isEmpty();",
        "ins2PreCode":"public void edgesConnecting_undirected() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.undirected().build(); mutableGraph.addEdge(\"A\", \"A\", \"AA\"); mutableGraph.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph); assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(graph.edgesConnecting(\"B\", \"A\")).containsExactly(\"AB\");",
        "label":1
    },
    {
        "ins1AddCode":"NumberFieldType fieldType = new NumberFieldType(\"field\", NumberType.DOUBLE);",
        "ins1DelCode":"NumberFieldType fieldType = new NumberFieldType(NumberType.DOUBLE);",
        "ins1PreCode":"public void setUp() throws Exception { super.setUp();  NumberFieldType fieldType = new NumberFieldType(NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType);",
        "ins2PreCode":"public void setUp() throws Exception { super.setUp(); NumberFieldMapper.NumberFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType);",
        "label":1
    },
    {
        "ins1AddCode":"DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>();",
        "ins1DelCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false);",
        "ins2PreCode":"public void testBug1593156() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false);",
        "label":1
    },
    {
        "ins1AddCode":"Statement statement = configureDataSourceBehavior(",
        "ins1DelCode":"Statement statement = configureDataSourceBehaviour(",
        "ins1PreCode":"ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "ins2PreCode":"ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "label":1
    },
    {
        "ins1AddCode":"boolean tillTheEnd, int prefetch) {",
        "ins1DelCode":"int prefetch, boolean tillTheEnd) {",
        "ins1PreCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch, boolean tillTheEnd) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"S1\"); XYSeries<String> s2 = new XYSeries<>(\"S2\"); XYSeriesCollection<String> dataset = new XYSeriesCollection<>(); XYSeries<String> s2b = new XYSeries<>(\"S2\");",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"S1\"); XYSeries s2 = new XYSeries(\"S2\"); XYSeriesCollection dataset = new XYSeriesCollection(); XYSeries s2b = new XYSeries(\"S2\");",
        "ins1PreCode":"public void testIndexOf() { XYSeries s1 = new XYSeries(\"S1\"); XYSeries s2 = new XYSeries(\"S2\"); XYSeriesCollection dataset = new XYSeriesCollection(); assertEquals(-1, dataset.indexOf(s1)); assertEquals(-1, dataset.indexOf(s2));  dataset.addSeries(s1); assertEquals(0, dataset.indexOf(s1)); assertEquals(-1, dataset.indexOf(s2));  dataset.addSeries(s2); assertEquals(0, dataset.indexOf(s1)); assertEquals(1, dataset.indexOf(s2));  dataset.removeSeries(s1); assertEquals(-1, dataset.indexOf(s1)); assertEquals(0, dataset.indexOf(s2));  XYSeries s2b = new XYSeries(\"S2\"); assertEquals(0, dataset.indexOf(s2b));",
        "ins2PreCode":"public void testIndexOf() { TimeSeries s1 = new TimeSeries(\"S1\"); TimeSeries s2 = new TimeSeries(\"S2\"); TimeSeriesCollection dataset = new TimeSeriesCollection(); assertEquals(-1, dataset.indexOf(s1)); assertEquals(-1, dataset.indexOf(s2)); dataset.addSeries(s1); assertEquals(0, dataset.indexOf(s1)); assertEquals(-1, dataset.indexOf(s2)); dataset.addSeries(s2); assertEquals(0, dataset.indexOf(s1)); assertEquals(1, dataset.indexOf(s2)); dataset.removeSeries(s1); assertEquals(-1, dataset.indexOf(s1)); assertEquals(0, dataset.indexOf(s2)); TimeSeries s2b = new TimeSeries(\"S2\"); assertEquals(0, dataset.indexOf(s2b));",
        "label":1
    },
    {
        "ins1AddCode":"\"  number  = {1},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  number  = {1},\" + OS.NEWLINE +",
        "ins1PreCode":"public void saveAlsoSavesSecondModification() throws Exception {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\";    ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS); ParserResult firstParse = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = firstParse.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");  BibDatabaseContext context = new BibDatabaseContext(firstParse.getDatabase(), firstParse.getMetaData()); context.setMode(BibDatabaseMode.BIBTEX);  databaseWriter.savePartOfDatabase(context, firstParse.getDatabase().getEntries());   entry.setField(StandardField.AUTHOR, \"Test\");   stringWriter = new StringWriter(); databaseWriter = new BibtexDatabaseWriter(stringWriter, preferences, entryTypesManager); databaseWriter.savePartOfDatabase(context, firstParse.getDatabase().getEntries());  assertEquals(OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author  = {Test},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + \"\" + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE, stringWriter.toString());",
        "ins2PreCode":"public void saveReturnsToOriginalEntryWhenEntryIsFlaggedUnchanged() throws Exception { String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\"; ImportFormatPreferences importFormatPreferences = mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS); ParserResult firstParse = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = firstParse.getDatabase().getEntries(); BibEntry entry = entries.iterator().next(); entry.setField(StandardField.AUTHOR, \"BlaBla\"); BibDatabaseContext context = new BibDatabaseContext(firstParse.getDatabase(), firstParse.getMetaData()); entry.setField(StandardField.AUTHOR, \"BlaBla\"); databaseWriter.savePartOfDatabase(context, firstParse.getDatabase().getEntries()); entry.setField(StandardField.AUTHOR, \"BlaBla\"); stringWriter = new StringWriter(); databaseWriter = new BibtexDatabaseWriter(stringWriter, preferences, entryTypesManager); databaseWriter.savePartOfDatabase(context, firstParse.getDatabase().getEntries()); \"  Number                   = {1},\" + OS.NEWLINE + String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + assertEquals(bibtexEntry, stringWriter.toString());",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(onNext, \"onNext is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(onNext, \"onNext is null\");",
        "ins1PreCode":"public final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext) { ObjectHelper.requireNonNull(onNext, \"onNext is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, onNext,",
        "ins2PreCode":"public final ParallelFlowable<T> doAfterNext(@NonNull Consumer<? super T> onAfterNext) { ObjectHelper.requireNonNull(onAfterNext, \"onAfterNext is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, onAfterNext,",
        "label":1
    },
    {
        "ins1AddCode":".withLatestFrom(new CrashingMappedIterable<>(1, 100, 100, new Function<Integer, Flowable<Integer>>() {",
        "ins1DelCode":".withLatestFrom(new CrashingMappedIterable<Flowable<Integer>>(1, 100, 100, new Function<Integer, Flowable<Integer>>() {",
        "ins1PreCode":"public void manyIteratorThrows() { Flowable.just(1) .withLatestFrom(new CrashingMappedIterable<Flowable<Integer>>(1, 100, 100, new Function<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Integer v) throws Exception {",
        "ins2PreCode":"public void manyIteratorThrows() { Observable.just(1) .withLatestFrom(new CrashingMappedIterable<Observable<Integer>>(1, 100, 100, new Function<Integer, Observable<Integer>>() { @Override public Observable<Integer> apply(Integer v) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"setConnectionTimeoutForStreamCount(activeRemoteStreamCount.decrementAndGet());",
        "ins1DelCode":"activeRemoteStreamCount.decrementAndGet();",
        "ins1PreCode":"header[4] = FLAG_END_OF_STREAM; stream.sentEndOfStream(); if (!stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } }",
        "ins2PreCode":"header[4] = FLAG_END_OF_STREAM; stream.sentEndOfStream(); if (!stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } }",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0);",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void merge10AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(10, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1000AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() {",
        "ins1DelCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() {",
        "ins1PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOff() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.location=classpath:enabletwoprofiles.properties,\"",
        "ins2PreCode":"public void loadTwoPropertiesFilesWithProfilesAndSwitchOneOffFromSpecificLocation() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.name=enabletwoprofiles\", \"spring.config.location=classpath:enableprofile.properties\");",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Observable<Integer>> inner = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>();",
        "ins1PreCode":"public void windowAbandonmentCancelsUpstreamExactTimeAndSize() { PublishSubject<Integer> ps = PublishSubject.create();  final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>();  TestObserver<Observable<Integer>> to = ps.window(10, TimeUnit.MINUTES, 100)",
        "ins2PreCode":"public void windowAbandonmentCancelsUpstreamExactTimeSkip() { PublishSubject<Integer> ps = PublishSubject.create(); final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>(); TestObserver<Observable<Integer>> to = ps.window(10, 15, TimeUnit.MINUTES)",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void blockingSubscribeConsumerConsumerError() { final List<Object> list = new ArrayList<Object>();  TestException ex = new TestException();",
        "ins2PreCode":"public void blockingSubscribeConsumerConsumerError() { final List<Object> list = new ArrayList<Object>(); TestException ex = new TestException();",
        "label":1
    },
    {
        "ins1AddCode":"request.addHeader(\"x-forwarded-for\", \"140.211.11.130\"); request.addHeader(\"x-forwarded-for\", \"proxy1\"); request.addHeader(\"x-forwarded-for\", \"proxy2\");",
        "ins1DelCode":"request.setHeader(\"x-forwarded-for\", \"140.211.11.130, proxy1, proxy2\");",
        "ins1PreCode":"MockHttpServletRequest request = new MockHttpServletRequest(); request.setRemoteAddr(\"192.168.0.10\"); request.setRemoteHost(\"remote-host-original-value\"); request.setHeader(\"x-forwarded-for\", \"140.211.11.130, proxy1, proxy2\");  ",
        "ins2PreCode":"MockHttpServletRequest request = new MockHttpServletRequest(); request.setRemoteAddr(\"192.168.0.10\"); request.setRemoteHost(\"remote-host-original-value\"); request.setHeader(\"x-forwarded-for\", \"140.211.11.130, proxy1, proxy2, 192.168.0.10, 192.168.0.11\");",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(d1, new NumberAxis(\"x\"), JFreeChart chart = new JFreeChart(plot);",
        "ins1DelCode":"XYPlot plot = new XYPlot(d1, new NumberAxis(\"x\"), new JFreeChart(plot);",
        "ins1PreCode":"d2.addSeries(s5);  StandardXYItemRenderer r = new StandardXYItemRenderer(); XYPlot plot = new XYPlot(d1, new NumberAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, d2); new JFreeChart(plot); LegendItem li = r.getLegendItem(1, 2); assertEquals(\"S5\", li.getLabel());",
        "ins2PreCode":"d2.addSeries(s5); XYAreaRenderer r = new XYAreaRenderer(); XYPlot plot = new XYPlot(d1, new NumberAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, d2); new JFreeChart(plot); LegendItem li = r.getLegendItem(1, 2); assertEquals(\"S5\", li.getLabel());",
        "label":1
    },
    {
        "ins1AddCode":"BibEntry localEntry = new BibEntry(StandardEntryType.Article).withCitationKey(\"pdfInDatabase\"); List<Path> result = fileFinder.findAssociatedFiles(localEntry, List.of(directory), PDF_EXTENSION); List<Path> expected = List.of(directory.resolve(\"pdfInDatabase.pdf\")); assertEquals(expected, result);",
        "ins1DelCode":"BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCitationKey(\"pdfInDatabase\"); localEntry.setField(StandardField.YEAR, \"2001\"); List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions); assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/pdfInDatabase.pdf\")), result);",
        "ins1PreCode":"void testFindFiles() throws Exception {  BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCitationKey(\"pdfInDatabase\"); localEntry.setField(StandardField.YEAR, \"2001\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[citationkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);   assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/pdfInDatabase.pdf\")), result);",
        "ins2PreCode":"void testYearAuthFirstPageFindFiles() throws Exception { RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[year]_[auth]_[firstpage].*\\\\\\\\.[extension]\", ','); List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> result = fileFinder.findAssociatedFiles(entry, dirs, extensions); List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[year]_[auth]_[firstpage].*\\\\\\\\.[extension]\", ','); List<Path> result = fileFinder.findAssociatedFiles(entry, dirs, extensions); assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/2003_Hippel_209.pdf\")), result);",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(json).isEqualTo(\"{\\\"status\\\":\\\"UP\\\",\\\"components\\\":{\\\"db1\\\":{\\\"status\\\":\\\"UP\\\"},\"",
        "ins1DelCode":"assertThat(json).isEqualTo(\"{\\\"status\\\":\\\"UP\\\",\\\"components\\\":{\" + \"\\\"db1\\\":{\\\"status\\\":\\\"UP\\\"},\"",
        "ins1PreCode":"CompositeHealth health = new CompositeHealth(ApiVersion.V3, Status.UP, components); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(health); assertThat(json).isEqualTo(\"{\\\"status\\\":\\\"UP\\\",\\\"components\\\":{\" + \"\\\"db1\\\":{\\\"status\\\":\\\"UP\\\"},\" + \"\\\"db2\\\":{\\\"status\\\":\\\"DOWN\\\",\\\"details\\\":{\\\"a\\\":\\\"b\\\"}}}}\");",
        "ins2PreCode":"CompositeHealth health = new CompositeHealth(ApiVersion.V2, Status.UP, components); ObjectMapper mapper = new ObjectMapper(); String json = mapper.writeValueAsString(health); assertThat(json).isEqualTo(\"{\\\"status\\\":\\\"UP\\\",\\\"details\\\":{\" + \"\\\"db1\\\":{\\\"status\\\":\\\"UP\\\"},\" + \"\\\"db2\\\":{\\\"status\\\":\\\"DOWN\\\",\\\"details\\\":{\\\"a\\\":\\\"b\\\"}}}}\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(expected, new TreeSet<>(keySet).toString());",
        "ins1DelCode":"assertEquals(expected, new TreeSet<String>(keySet).toString());",
        "ins1PreCode":"assertNotNull(file, resource); JSONObject json = JSONObject.fromObject(DownloadService.loadJSONHTML(resource)); @SuppressWarnings(\"unchecked\") Set<String> keySet = json.keySet(); assertEquals(expected, new TreeSet<String>(keySet).toString());",
        "ins2PreCode":"assertNotNull(file, resource); JSONObject json = JSONObject.fromObject(DownloadService.loadJSON(resource)); @SuppressWarnings(\"unchecked\") Set<String> keySet = json.keySet(); assertEquals(expected, new TreeSet<String>(keySet).toString());",
        "label":1
    },
    {
        "ins1AddCode":"buildRule.getProject().executeTarget(\"extended-setup\"); String tmpdir = buildRule.getProject().getProperty(\"output\").replace(",
        "ins1DelCode":"getProject().executeTarget(\"extended-setup\"); String tmpdir = getProject().getProperty(\"output\").replace(",
        "ins1PreCode":"public void testAbsolute1() { getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getProperty(\"output\").replace( File.separatorChar, '/'); ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "ins2PreCode":"public void testAbsolute3() { getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getProperty(\"output\").replace( File.separatorChar, '/'); ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (count++ == 1) { throw new TestException(); } else { return new ArrayList<Integer>(); } }",
        "ins2PreCode":"if (count++ == 1) { throw new TestException(); } else { return new ArrayList<Integer>(); } }",
        "label":1
    },
    {
        "ins1AddCode":"configureLocalTestStorage(fp); FingerprintCleanupThread cleanupThread = new FingerprintCleanupThread();",
        "ins1DelCode":"FingerprintCleanupThread cleanupThread = new TestFingerprintCleanupThread(fp);",
        "ins1PreCode":"fp.facets.setOwner(Saveable.NOOP); TestFingperprintFacet facet = new TestFingperprintFacet(fp, System.currentTimeMillis(), true); fp.facets.add(facet); FingerprintCleanupThread cleanupThread = new TestFingerprintCleanupThread(fp); cleanupThread.execute(testTaskListener); String logOutput = testTaskListener.outputStream.toString();",
        "ins2PreCode":"fp.facets.setOwner(Saveable.NOOP); TestFingperprintFacet facet = new TestFingperprintFacet(fp, System.currentTimeMillis(), false); fp.facets.add(facet); FingerprintCleanupThread cleanupThread = new TestFingerprintCleanupThread(fp); cleanupThread.execute(testTaskListener); cleanupThread.execute(testTaskListener);",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void eagerDisposedOnComplete() { final TestObserver<Integer> to = new TestObserver<Integer>();  Observable.using(Functions.justSupplier(1), Functions.justFunction(new Observable<Integer>() {",
        "ins2PreCode":"public void eagerDisposedOnError() { final TestObserver<Integer> to = new TestObserver<Integer>(); Observable.using(Functions.justSupplier(1), Functions.justFunction(new Observable<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"setState(426); switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) { setState(413); setState(414); setState(419); setState(415); setState(416); setState(421); setState(422); setState(424); setState(425);",
        "ins1DelCode":"setState(424); switch ( getInterpreter().adaptivePredict(_input,38,_ctx) ) { setState(411); setState(412); setState(417); setState(413); setState(414); setState(419); setState(420); setState(422); setState(423);",
        "ins1PreCode":"try { setState(424); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,38,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(411); match(LBRACE); setState(412); expression(0); setState(417); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(413); match(COMMA); setState(414); expression(0); } } setState(419); _errHandler.sync(this); _la = _input.LA(1); } setState(420); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(422); match(LBRACE); setState(423); match(RBRACE); }",
        "ins2PreCode":"try { setState(440); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(440); match(LBRACE); setState(426); exitRule(); setState(427); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(432); match(COMMA); setState(440); exitRule(); } } setState(429); _errHandler.sync(this); _la = _input.LA(1); } setState(440); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(426); match(LBRACE); setState(426); match(RBRACE); }",
        "label":0
    },
    {
        "ins1AddCode":"protected synchronized int doWrite(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException { if (bytebuffer.remaining() == 0) {",
        "ins1DelCode":"private synchronized int doWrite(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException { if (block || bytebuffer.remaining() == 0) {",
        "ins1PreCode":"private synchronized int doWrite(ByteBuffer bytebuffer, boolean block, boolean flip) throws IOException { if (flip) { bytebuffer.flip(); writeBufferFlipped = true; }  int written = 0; long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { written = pool.write(bytebuffer, getSocket(), selector, writeTimeout, block);  do { if (getSocket().flush(true, selector, writeTimeout)) break; } while (true); } finally { if (selector != null) { pool.put(selector); } } if (block || bytebuffer.remaining() == 0) {  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".has(matchingPropertySource(\"applicationConfig: [classpath:specificlocation.properties]\")); .doesNotHave(matchingPropertySource(\"applicationConfig: [classpath:/application.properties]\"));",
        "ins1DelCode":".has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:specificlocation.properties]\")); .doesNotHave(matchingPropertySource(\"applicationConfig: \" + \"[classpath:/application.properties]\"));",
        "ins1PreCode":"String property = this.environment.getProperty(\"the.property\"); assertThat(property).isEqualTo(\"fromspecificlocation\"); assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:specificlocation.properties]\"));  assertThat(this.environment) .doesNotHave(matchingPropertySource(\"applicationConfig: \" + \"[classpath:/application.properties]\")); assertThat(this.environment.getProperty(\"foo\")).isNull();",
        "ins2PreCode":"String property = this.environment.getProperty(\"the.property\"); assertThat(property).isEqualTo(\"fromspecificlocation\"); assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:specificlocation.properties]\")); assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:/application.properties]\")); assertThat(this.environment.getProperty(\"foo\")).isEqualTo(\"bucket\");",
        "label":1
    },
    {
        "ins1AddCode":"AnnotatedBeanDefinition definition = createBeanDefinition(DefaultConfigurationFilter.class); this.handler.handle(definition, this.registry); assertThat(propertyValues.get(\"filter\")).isEqualTo(definition);",
        "ins1DelCode":"ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(DefaultConfigurationFilter.class.getName())); this.handler.handle(scanned, this.registry); assertThat(propertyValues.get(\"filter\")).isEqualTo(scanned);",
        "ins1PreCode":"void defaultFilterConfiguration() throws IOException { ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(DefaultConfigurationFilter.class.getName())); this.handler.handle(scanned, this.registry); BeanDefinition filterRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationFilter.class.getName()); MutablePropertyValues propertyValues = filterRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat((EnumSet<DispatcherType>) propertyValues.get(\"dispatcherTypes\")) .containsExactly(DispatcherType.REQUEST); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((String[]) propertyValues.get(\"servletNames\")).isEmpty(); assertThat((String[]) propertyValues.get(\"urlPatterns\")).isEmpty(); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationFilter.class.getName()); assertThat(propertyValues.get(\"filter\")).isEqualTo(scanned);",
        "ins2PreCode":"void defaultServletConfiguration() throws IOException { ScannedGenericBeanDefinition scanned = new ScannedGenericBeanDefinition( new SimpleMetadataReaderFactory().getMetadataReader(DefaultConfigurationServlet.class.getName())); this.handler.handle(scanned, this.registry); BeanDefinition servletRegistrationBean = this.registry .getBeanDefinition(DefaultConfigurationServlet.class.getName()); MutablePropertyValues propertyValues = servletRegistrationBean.getPropertyValues(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat(propertyValues.get(\"asyncSupported\")).isEqualTo(false); assertThat(((Map<String, String>) propertyValues.get(\"initParameters\"))).isEmpty(); assertThat((String[]) propertyValues.get(\"urlMappings\")).isEmpty(); assertThat((String[]) propertyValues.get(\"urlMappings\")).isEmpty(); assertThat(propertyValues.get(\"name\")).isEqualTo(DefaultConfigurationServlet.class.getName()); assertThat(propertyValues.get(\"servlet\")).isEqualTo(scanned);",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(1, database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\")); assertEquals(0, database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"));",
        "ins1DelCode":"assertEquals(database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"), 1); assertEquals(database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"), 0);",
        "ins1PreCode":"BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"), 1); database.removeEntry(entry); assertEquals(database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"), 0);",
        "ins2PreCode":"BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"), 1); database.removeEntry(entry); assertEquals(database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"), 0);",
        "label":1
    },
    {
        "ins1AddCode":"List<LocalizationEntry> result = new ArrayList<>();",
        "ins1DelCode":"List<LocalizationEntry> result = new LinkedList<>();",
        "ins1PreCode":"private static List<LocalizationEntry> getLanguageKeysInJavaFile(Path path, LocalizationBundleForTest type) { List<LocalizationEntry> result = new LinkedList<>();  try {",
        "ins2PreCode":"private static List<LocalizationEntry> getLocalizationParametersInJavaFile(Path path, LocalizationBundleForTest type) { List<LocalizationEntry> result = new LinkedList<>(); try {",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset<String> dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYDataset dataset = new XYSeriesCollection<String>(series1);",
        "ins1PreCode":"series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<String>(series1);  LocalListener l = new LocalListener();",
        "ins2PreCode":"series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<>(series1); LocalListener l = new LocalListener();",
        "label":0
    },
    {
        "ins1AddCode":"JFreeChart chart2 = (JFreeChart) TestUtils.serialised(chart);",
        "ins1DelCode":"JFreeChart chart2 = (JFreeChart) TestUtilities.serialised(chart);",
        "ins1PreCode":"plot.addDomainMarker(new IntervalMarker(2.0, 3.0), Layer.BACKGROUND); plot.addRangeMarker(new ValueMarker(4.0), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(5.0, 6.0), Layer.BACKGROUND); JFreeChart chart2 = (JFreeChart) TestUtilities.serialised(chart); assertEquals(chart, chart2); try {",
        "ins2PreCode":"plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND); plot.addRangeMarker(new ValueMarker(1.1), Layer.FOREGROUND); plot.addRangeMarker(new IntervalMarker(2.2, 3.3), Layer.BACKGROUND); JFreeChart chart2 = (JFreeChart) TestUtilities.serialised(chart); assertEquals(chart, chart2); try {",
        "label":1
    },
    {
        "ins1AddCode":"source.onSubscribe(Disposable.empty());",
        "ins1DelCode":"source.onSubscribe(Disposables.empty());",
        "ins1PreCode":"} });  source.onSubscribe(Disposables.empty()); source.onNext(1); source.onComplete();",
        "ins2PreCode":"} }); source.onSubscribe(Disposables.empty()); source.onNext(1); source.onComplete();",
        "label":1
    },
    {
        "ins1AddCode":"else if (DOUBLE.matches(obj0, obj1)) { if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGDECIMAL; else delegate = DOUBLE; } else if (BIGINTEGER.matches(obj0, obj1))",
        "ins1DelCode":"else if (DOUBLE.matches(obj0, obj1)) delegate = DOUBLE; else if (BIGINTEGER.matches(obj0, obj1))",
        "ins1PreCode":"final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) delegate = DOUBLE; else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER; else",
        "ins2PreCode":"final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) delegate = DOUBLE; else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER; else",
        "label":1
    },
    {
        "ins1AddCode":"void pomDependencyResolutionViaExt() {",
        "ins1DelCode":"public void pomDependencyResolutionViaExt() {",
        "ins1PreCode":"public void pomDependencyResolutionViaExt() { Map<String, Object> args = new HashMap<>(); Map<String, Object> dependency = createDependency(\"org.springframework\", \"spring-framework-bom\",",
        "ins2PreCode":"public void resolutionWithClassifier() { Map<String, Object> args = new HashMap<>(); Map<String, Object> dependency = createDependency(\"org.springframework\", \"spring-jdbc\", \"3.2.4.RELEASE\", false);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3); assertThat(network.edges()).containsExactly(E15, E41, E23);",
        "ins1DelCode":"assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();",
        "ins1PreCode":"assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15)); assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder(); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15); assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);",
        "ins2PreCode":"assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15)); assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder(); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15); assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);",
        "label":1
    },
    {
        "ins1AddCode":"final long value = Platform.getLong(baseObject, baseOffset + offset);",
        "ins1DelCode":"final long value = PlatformDependent.UNSAFE.getLong(baseObject, baseOffset + offset);",
        "ins1PreCode":"if (offset < 0) return null;  if (precision <= Decimal.MAX_LONG_DIGITS()) { final long value = PlatformDependent.UNSAFE.getLong(baseObject, baseOffset + offset); return Decimal.apply(value, precision, scale); } else {",
        "ins2PreCode":"return null; if (precision <= Decimal.MAX_LONG_DIGITS()) { PlatformDependent.copyMemory(baseObject, baseOffset + offset, return Decimal.apply(getLong(ordinal), precision, scale); } else {",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(historyPageFilter.hasUpPage); Assert.assertTrue(historyPageFilter.hasDownPage);",
        "ins1DelCode":"Assert.assertEquals(true, historyPageFilter.hasUpPage); Assert.assertEquals(true, historyPageFilter.hasDownPage);",
        "ins1PreCode":" historyPageFilter.add(itemList);  Assert.assertEquals(true, historyPageFilter.hasUpPage); Assert.assertEquals(true, historyPageFilter.hasDownPage); Assert.assertEquals(5, historyPageFilter.runs.size()); ",
        "ins2PreCode":"historyPageFilter.add(itemList); Assert.assertEquals(true, historyPageFilter.hasUpPage); Assert.assertEquals(true, historyPageFilter.hasDownPage); Assert.assertEquals(5, historyPageFilter.runs.size());",
        "label":1
    },
    {
        "ins1AddCode":"TimeSeries clone = CloneUtils.clone(series);",
        "ins1DelCode":"TimeSeries clone; clone = (TimeSeries) series.clone();",
        "ins1PreCode":"RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42);  TimeSeries clone; clone = (TimeSeries) series.clone(); clone.setKey(\"Clone Series\"); clone.update(jan1st2002, 10);",
        "ins2PreCode":"RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42); assertEquals(\"Clone Series\", clone.getKey()); TimePeriodValues clone = (TimePeriodValues) series.clone(); clone.setKey(\"Clone Series\"); clone.update(0, 10);",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals((Integer)1, person.getId());",
        "ins1DelCode":"assertEquals(1, person.getId());",
        "ins1PreCode":"try { MultipleIncludePersonMapper personMapper = sqlSession.getMapper(MultipleIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals(1, person.getId()); assertEquals(\"John\", person.getName()); ",
        "ins2PreCode":"try { MultipleReverseIncludePersonMapper personMapper = sqlSession.getMapper(MultipleReverseIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals(1, person.getId()); assertEquals(\"John\", person.getName());",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"Series 1\", false, true);",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"Series 1\", false, true);",
        "ins1PreCode":"public void testIndexOf2() { XYSeries s1 = new XYSeries(\"Series 1\", false, true); s1.add(1.0, 1.0); s1.add(3.0, 3.0);",
        "ins2PreCode":"public void testIndexOf3() { XYSeries s1 = new XYSeries(\"Series 1\"); s1.add(1.0, 1.0); s1.add(2.0, 3.0);",
        "label":1
    },
    {
        "ins1AddCode":"void parseConvertsNewlineToSpace() throws IOException {",
        "ins1DelCode":"public void parseConvertsNewlineToSpace() throws IOException {",
        "ins1PreCode":"public void parseConvertsNewlineToSpace() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\nb}}\"));",
        "ins2PreCode":"public void parseConvertsTabToSpace() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\tb}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Boolean> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Boolean> ts = new TestSubscriberEx<Boolean>();",
        "ins1PreCode":"public void predicateThrowsExceptionAndValueInCauseMessageFlowable() { TestSubscriberEx<Boolean> ts = new TestSubscriberEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException(); ",
        "ins2PreCode":"public void predicateThrowsExceptionAndValueInCauseMessageFlowable() { TestSubscriberEx<Boolean> ts = new TestSubscriberEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException();",
        "label":1
    },
    {
        "ins1AddCode":"assertActivation( true, profile, newContext( null, newProperties( \"1.6.0_09\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0_09-b03\" ) ) );",
        "ins1DelCode":"",
        "ins1PreCode":" assertActivation( true, profile, newContext( null, newProperties( \"1.6\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0\" ) ) );   ",
        "ins2PreCode":"assertActivation( true, profile, newContext( null, newProperties( \"1.6\" ) ) ); assertActivation( true, profile, newContext( null, newProperties( \"1.6.0\" ) ) );",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(items, \"items is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(items, \"items is null\");",
        "ins1PreCode":"public static <T> Observable<T> fromArray(T... items) { ObjectHelper.requireNonNull(items, \"items is null\"); if (items.length == 0) { return empty();",
        "ins2PreCode":"public static <T> Flowable<T> fromArray(T... items) { ObjectHelper.requireNonNull(items, \"items is null\"); if (items.length == 0) { return empty();",
        "label":1
    },
    {
        "ins1AddCode":"void propertyWithPlaceholderNotResolved() {",
        "ins1DelCode":"public void propertyWithPlaceholderNotResolved() {",
        "ins1PreCode":"public void propertyWithPlaceholderNotResolved() { ConfigurableEnvironment environment = emptyEnvironment(); TestPropertyValues.of(\"my.foo: ${bar.blah}\").applyTo(environment);",
        "ins2PreCode":"public void propertyWithSensitivePlaceholderResolved() { ConfigurableEnvironment environment = emptyEnvironment(); TestPropertyValues.of(\"my.foo: http://${bar.password}://hello\", \"bar.password: hello\").applyTo(environment);",
        "label":1
    },
    {
        "ins1AddCode":"Jenkins.getInstance().rebuildDependencyGraph();",
        "ins1DelCode":"Hudson.getInstance().rebuildDependencyGraph();",
        "ins1PreCode":" upstreamBuild.delete();  Hudson.getInstance().rebuildDependencyGraph();  List<AbstractProject> upstreamProjects = downstream.getUpstreamProjects();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>();",
        "ins1DelCode":"DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset();",
        "ins1PreCode":"public void testFindDomainBounds2() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] x1Start = new double[] {0.9, 1.9, 2.9};",
        "ins2PreCode":"public void testFindDomainBounds3() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] x1Start = new double[] {0.9, 1.9, 2.9};",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles);",
        "ins1DelCode":"ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles);",
        "ins1PreCode":"void processAndApplySetsActiveProfiles(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply(); assertThat(this.environment.getActiveProfiles()).containsExactly(\"one\", \"two\", \"three\");",
        "ins2PreCode":"void processAndApplySetsActiveProfilesAndProfileGroups(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply(); assertThat(this.environment.getActiveProfiles()).containsExactly(\"one\", \"four\", \"five\", \"two\", \"three\");",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d1 = Disposable.empty(); Disposable d2 = Disposable.empty();",
        "ins1DelCode":"Disposable d1 = Disposables.empty(); Disposable d2 = Disposables.empty();",
        "ins1PreCode":"@Override protected void subscribeActual(MaybeObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty();  observer.onSubscribe(d2);",
        "ins2PreCode":"@Override protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposables.empty(); observer.onSubscribe(d1); Disposable d2 = Disposables.empty(); observer.onSubscribe(d2);",
        "label":1
    },
    {
        "ins1AddCode":"boolean done = dir.mkdirs() || dir.isDirectory();",
        "ins1DelCode":"boolean done = dir.mkdirs();",
        "ins1PreCode":" File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs(); if (!done) { String msg = \"Directory \" + localPath + \" creation was not \"",
        "ins2PreCode":"File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs(); if (!done) { String msg = \"Directory \" + localPath + \" creation was not \"",
        "label":0
    },
    {
        "ins1AddCode":"assumeThat(\"Regex not present\",",
        "ins1DelCode":"assertThat(\"Regex not present\",",
        "ins1PreCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assertThat(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\"), containsString(\"bye world\"));",
        "ins2PreCode":"public void testFilterContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeThat(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\"), containsString(\"bye world\"));",
        "label":0
    },
    {
        "ins1AddCode":"public void bindToArrayShouldReturnPrimitiveArray() {",
        "ins1DelCode":"public void bindToArrayShouldReturnPrimitiveArray() throws Exception {",
        "ins1PreCode":"public void bindToArrayShouldReturnPrimitiveArray() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0]\", \"1\");",
        "ins2PreCode":"public void bindToCollectionShouldReturnPopulatedCollection() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0]\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"void activeProfilesFromDefaultPropertiesShouldNotTakePrecedence() {",
        "ins1DelCode":"public void activeProfilesFromDefaultPropertiesShouldNotTakePrecedence() {",
        "ins1PreCode":"public void activeProfilesFromDefaultPropertiesShouldNotTakePrecedence() { this.initializer.setSearchNames(\"enableprofile\"); this.environment.getPropertySources().addLast(",
        "ins2PreCode":"public void includedProfilesFromDefaultPropertiesShouldNotTakePrecedence() { this.initializer.postProcessEnvironment(this.environment, this.application); this.environment.getPropertySources().addLast(",
        "label":1
    },
    {
        "ins1AddCode":"try { result.append(req.isAsyncStarted()); } catch (NullPointerException npe) { result.append(\"false\"); }",
        "ins1DelCode":"result.append(req.isAsyncStarted());",
        "ins1PreCode":"t.start(); } });   req.getMethod();",
        "ins2PreCode":"result.append(e); } }); req.getMethod();",
        "label":1
    },
    {
        "ins1AddCode":"BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>(false) { private static final long serialVersionUID = -9081211580719235896L; @Override void truncate() { } };",
        "ins1DelCode":"BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(false);",
        "ins1PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(false); buf.addLast(new Node(1, 0)); buf.addLast(new Node(2, 1));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"UnicastProcessor<Integer> up = UnicastProcessor.create(false); TestSubscriberEx<Integer> ts = up.to(TestHelper.<Integer>testSubscriber(1, QueueFuseable.ANY, false)); up.drainFused(ts);",
        "ins1DelCode":"UnicastProcessor<Integer> us = UnicastProcessor.create(false); TestSubscriberEx<Integer> ts = us.to(TestHelper.<Integer>testSubscriber(1, QueueFuseable.ANY, false)); us.drainFused(ts);",
        "ins1PreCode":"public void drainFusedFailFastEmpty() { UnicastProcessor<Integer> us = UnicastProcessor.create(false);  TestSubscriberEx<Integer> ts = us.to(TestHelper.<Integer>testSubscriber(1, QueueFuseable.ANY, false));  us.drainFused(ts);  ts.assertEmpty();",
        "ins2PreCode":"public void checkTerminatedFailFastEmpty() { UnicastProcessor<Integer> us = UnicastProcessor.create(false); TestSubscriberEx<Integer> ts = us.to(TestHelper.<Integer>testSubscriber(1, QueueFuseable.ANY, false)); ts.assertEmpty(); ts.assertEmpty();",
        "label":1
    },
    {
        "ins1AddCode":"assertThatExceptionOfType(CloudFoundryAuthorizationException.class) .isThrownBy(() -> this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .satisfies(reasonRequirement(Reason.INVALID_KEY_ID));",
        "ins1DelCode":"this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_KEY_ID)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "ins1PreCode":"given(this.securityService.fetchTokenKeys()).willReturn(INVALID_KEYS); String header = \"{\\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\",\\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{\\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_KEY_ID)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "ins2PreCode":"given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.TOKEN_EXPIRED)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\"));",
        "ins1DelCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "ins1PreCode":"   tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");  ",
        "ins2PreCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"text.setFont(UIUtils.getMonospaceFont());",
        "ins1DelCode":"text.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT));",
        "ins1PreCode":"text.setBackground(UIStyles.getDefaultTextBackground()); text.setTabs(controller.getPreferenceStore().getInt(ResultSetPreferences.RESULT_TEXT_TAB_SIZE)); text.setTabStops(null); text.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT)); text.setLayoutData(new GridData(GridData.FILL_BOTH)); text.addCaretListener(event -> onCursorChange(event.caretOffset));",
        "ins2PreCode":"text.setBackground(UIStyles.getDefaultTextBackground()); text.setTabs(controller.getPreferenceStore().getInt(ResultSetPreferences.RESULT_TEXT_TAB_SIZE)); text.setTabStops(null); text.setFont(JFaceResources.getFont(JFaceResources.TEXT_FONT)); text.setLayoutData(new GridData(GridData.FILL_BOTH)); text.addCaretListener(event -> onCursorChange(event.caretOffset));",
        "label":1
    },
    {
        "ins1AddCode":"try (OutputStream os = tar.write()) {",
        "ins1DelCode":"OutputStream os = tar.write(); try { } finally { os.close();",
        "ins1PreCode":"dir.mkdirs(); dir.child(\"stuff\").write(\"hello\", null); FilePath tar = root.child(\"dir.tar\"); OutputStream os = tar.write(); try { dir.tar(os, new DirScanner.Full()); } finally { os.close(); } tar.untar(remote, FilePath.TarCompression.NONE);",
        "ins2PreCode":"dir.mkdirs(); dir.child(\"stuff\").write(\"hello\", null); FilePath tar = root.child(\"dir.tar\"); OutputStream os = tar.write(); try { dir.tar(os, new DirScanner.Full()); } finally { os.close(); } tar.untar(root, FilePath.TarCompression.NONE);",
        "label":1
    },
    {
        "ins1AddCode":"synchronized (wrapperLifecyclesLock) {",
        "ins1DelCode":"synchronized (wrapperLifecycles) {",
        "ins1PreCode":"public void removeWrapperLifecycle(String listener) {   synchronized (wrapperLifecycles) {  ",
        "ins2PreCode":"public void removeAlias(String alias) { synchronized (aliases) {",
        "label":1
    },
    {
        "ins1AddCode":"} catch (CommunicationException | ServiceUnavailableException e) {",
        "ins1DelCode":"} catch (CommunicationException e) { containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } catch (ServiceUnavailableException e) {",
        "ins1PreCode":" principal = getPrincipal(context, username, gssCredential);  } catch (CommunicationException e) {   containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = getPrincipal(context, username, gssCredential);  } catch (ServiceUnavailableException e) {  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 35; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 34; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"List<Marker> markers; markers = this.foregroundDomainMarkers.get(index); } else { markers = this.backgroundDomainMarkers.get(index);",
        "ins1DelCode":"ArrayList markers; markers = (ArrayList) this.foregroundDomainMarkers.get( new Integer(index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get( new Integer(index));",
        "ins1PreCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get( new Integer(index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get( new Integer(index)); } if (markers == null) {",
        "ins2PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { List markers; if (layer == Layer.FOREGROUND) { markers = (List) this.foregroundRangeMarkers.get( new Integer(index)); } else { markers = (List) this.backgroundRangeMarkers.get( new Integer(index)); } if (markers == null) {",
        "label":0
    },
    {
        "ins1AddCode":"addPropertiesToEnvironment(this.context, \"logging.config=-Djava.util.logging.config.file=\\\"d:\\\\home\\\\site\\\\wwwroot\\\\bin\\\\apache-tomcat-7.0.52\\\\conf\\\\logging.properties\\\"\");",
        "ins1DelCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config: -Djava.util.logging.config.file=\\\"d:\\\\home\\\\site\\\\wwwroot\\\\bin\\\\apache-tomcat-7.0.52\\\\conf\\\\logging.properties\\\"\");",
        "ins1PreCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config: -Djava.util.logging.config.file=\\\"d:\\\\home\\\\site\\\\wwwroot\\\\bin\\\\apache-tomcat-7.0.52\\\\conf\\\\logging.properties\\\"\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader());",
        "ins2PreCode":"public void tomcatNopLoggingConfigDoesNotCauseAFailure() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, public void tomcatNopLoggingConfigDoesNotCauseAFailure() { this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader());",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestObserverEx<Integer> to = new TestObserverEx<>(); Observable.just(1, 2).subscribe(to); to.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; } });",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<>(); Observable.just(1, 2).subscribe(to); thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); to.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; }",
        "ins1PreCode":" Observable.just(1, 2).subscribe(to);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); to.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception {",
        "ins2PreCode":"Observable.just(1, 2).subscribe(to); to.assertValueAt(1, new Predicate<Integer>() { to.assertValueAt(1, new Predicate<Integer>() { to.assertValueAt(1, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception {",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader);",
        "ins1DelCode":"assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); if (cookieHeader.contains(\"name=\")) { assertTrue(cookieHeader.contains(\"name=val?ue\")); }",
        "ins1PreCode":"getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { if (cookieHeader.contains(\"name=\")) { assertTrue(cookieHeader.contains(\"name=val?ue\")); } }",
        "ins2PreCode":"res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING\", public void testCookiesInstance() throws Exception { assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); } }",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false);",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"Series 1\", true, false); XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
        "ins1PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "ins2PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1); XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":".collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() {",
        "ins2PreCode":".collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(tasks.getCustom()).isEmpty();",
        "ins1DelCode":"",
        "ins1PreCode":"run(FixedRateScheduledMethod.class, (tasks) -> { assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedDelay()).isEmpty(); assertThat(tasks.getFixedRate()).hasSize(1); FixedRateTaskDescription description = (FixedRateTaskDescription) tasks .getFixedRate().get(0);",
        "ins2PreCode":"run(FixedRateTriggerTask.class, (tasks) -> { assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedDelay()).isEmpty(); assertThat(tasks.getFixedRate()).hasSize(1); FixedRateTaskDescription description = (FixedRateTaskDescription) tasks .getFixedRate().get(0);",
        "label":1
    },
    {
        "ins1AddCode":"notification = Objects.requireNonNull(selector.apply(item), \"The selector returned a null Notification\");",
        "ins1DelCode":"notification = ObjectHelper.requireNonNull(selector.apply(item), \"The selector returned a null Notification\");",
        "ins1PreCode":"Notification<R> notification;  try { notification = ObjectHelper.requireNonNull(selector.apply(item), \"The selector returned a null Notification\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"Notification<R> notification; try { notification = ObjectHelper.requireNonNull(selector.apply(item), \"The selector returned a null Notification\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>(); TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<Integer>(); TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void async() { Flowable<Integer> source = Flowable.range(1, 10000); for (int i = 0; i < 100; i++) { TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<Integer>();  Flowable<Integer> cached = source.replay().autoConnect();  cached.observeOn(Schedulers.computation()).subscribe(ts1);  ts1.awaitDone(2, TimeUnit.SECONDS); ts1.assertNoErrors(); ts1.assertTerminated(); assertEquals(10000, ts1.values().size());  TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<Integer>(); cached.observeOn(Schedulers.computation()).subscribe(ts2); ",
        "ins2PreCode":"public void async() { Flowable<Integer> source = Flowable.range(1, 10000); for (int i = 0; i < 100; i++) { TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<Integer>(); Flowable<Integer> cached = source.replay().autoConnect(); cached.observeOn(Schedulers.computation()).subscribe(ts1); ts1.awaitDone(2, TimeUnit.SECONDS); ts1.assertNoErrors(); ts1.assertTerminated(); assertEquals(10000, ts1.values().size()); TestSubscriberEx<Integer> ts2 = new TestSubscriberEx<Integer>(); cached.observeOn(Schedulers.computation()).subscribe(ts2);",
        "label":1
    },
    {
        "ins1AddCode":"static void setUp() throws Exception {",
        "ins1DelCode":"public static void setUp() throws Exception {",
        "ins1PreCode":"public static void setUp() throws Exception {  String url = postgres.start(EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"postgres_genkeys\", \"postgres\", \"root\", Collections.emptyList());",
        "ins2PreCode":"public static void setUp() throws Exception { String url = postgres.start(EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"refcursor\", \"postgres\", \"root\", Collections.emptyList());",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); try { timeoutSetuped.countDown();",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); try { timeoutSetuped.countDown();",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertNull(\"Unlimited upload with swallow enabled generates client exception\", Assert.assertTrue(\"Unlimited upload with swallow enabled returns error status code\",",
        "ins1DelCode":"assertNull(\"Unlimited upload with swallow enabled generates client exception\", assertTrue(\"Unlimited upload with swallow enabled returns error status code\",",
        "ins1PreCode":"log.info(\"Aborted (OK), swallow enabled\"); AbortedPOSTClient client = new AbortedPOSTClient(); Exception ex = doAbortedPOSTTest(client, HttpServletResponse.SC_OK, true); assertNull(\"Unlimited upload with swallow enabled generates client exception\", ex); assertTrue(\"Unlimited upload with swallow enabled returns error status code\", client.isResponse200()); client.reset();",
        "ins2PreCode":"log.info(\"Aborted (OK), swallow disabled\"); AbortedPOSTClient client = new AbortedPOSTClient(); Exception ex = doAbortedPOSTTest(client, HttpServletResponse.SC_OK, false); assertNull(\"Unlimited upload with swallow disabled generates client exception\", ex); assertTrue(\"Unlimited upload with swallow disabled returns error status code\", client.isResponse200()); client.reset();",
        "label":1
    },
    {
        "ins1AddCode":"ApplicationConfigurationProperties applicationProperties = endpoint ConfigurationPropertiesBeanDescriptor foo = applicationProperties .getContexts().get(context.getId()).getBeans().get(\"foo\");",
        "ins1DelCode":"ConfigurationPropertiesDescriptor properties = endpoint ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\");",
        "ins1PreCode":"contextRunner.run((context) -> { ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull(); Map<String, Object> map = foo.getProperties();",
        "ins2PreCode":"contextRunner.run((context) -> { ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor fooProperties = properties.getBeans() assertThat(map).isNotNull(); Map<String, Object> map = fooProperties.getProperties();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>();",
        "ins1PreCode":"public void timeout() { TestSubscriber<String> ts = new TestSubscriber<String>(); Single<String> s1 = Single.<String>unsafeCreate(new SingleSource<String>() { @Override",
        "ins2PreCode":"public void timeoutWithFallback() { TestSubscriber<String> ts = new TestSubscriber<String>(); Single<String> s1 = Single.<String>unsafeCreate(new SingleSource<String>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"void persistAndGetIdShouldPersistAndGetId() {",
        "ins1DelCode":"public void persistAndGetIdShouldPersistAndGetId() {",
        "ins1PreCode":"public void persistAndGetIdShouldPersistAndGetId() { bindEntityManager(); TestEntity entity = new TestEntity();",
        "ins2PreCode":"public void persistAndGetIdForTypeShouldPersistAndGetId() { bindEntityManager(); TestEntity entity = new TestEntity();",
        "label":1
    },
    {
        "ins1AddCode":"list = new ArrayList<>();",
        "ins1DelCode":"list = new ArrayList<ParamOverride>();",
        "ins1PreCode":"String key = ignore.toString(); List<ParamOverride> list = overrides.get(key); if (list == null) { list = new ArrayList<ParamOverride>(); overrides.put(key, list); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(1016729759122L, m1.getLastMillisecond(cal)); assertEquals(1016729759123L, m2.getFirstMillisecond(cal));",
        "ins1DelCode":"assertEquals(1016729759122L, m1.getLastMillisecond(zone)); assertEquals(1016729759123L, m2.getFirstMillisecond(zone));",
        "ins1PreCode":"locale);  assertEquals(122, m1.getMillisecond()); assertEquals(1016729759122L, m1.getLastMillisecond(zone));  assertEquals(123, m2.getMillisecond()); assertEquals(1016729759123L, m2.getFirstMillisecond(zone));",
        "ins2PreCode":"locale); assertEquals(122, m1.getMillisecond()); assertEquals(1016722559122L, m1.getLastMillisecond(zone)); assertEquals(123, m2.getMillisecond()); assertEquals(1016722559123L, m2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1AddCode":"void parseRecognizesEntryWithAtSymbolInQuotationMarks() throws IOException {",
        "ins1DelCode":"public void parseRecognizesEntryWithAtSymbolInQuotationMarks() throws IOException {",
        "ins1PreCode":"public void parseRecognizesEntryWithAtSymbolInQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"author @ good\\\"}\"));",
        "ins2PreCode":"public void parseRecognizesFieldsWithBracketsEnclosedInQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Test {Ed {von} Test}\\\"}\"));",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded); ds.setIncludes(new String[] {\"alpha/**\"}); ds.setExcludes(new String[] {\"alpha/**\"}); compareFiles(ds, new String[] {}, new String[] {});",
        "ins1DelCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded); ds.setIncludes(new String[] { \"alpha/**\" }); ds.setExcludes(new String[] { \"alpha/**\" }); compareFiles(ds, new String[] {}, new String[] {});",
        "ins1PreCode":"public void testExcludeHasPrecedence() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/**\" }); ds.setExcludes(new String[] { \"alpha/**\" }); ds.scan(); compareFiles(ds, new String[] {}, new String[] {}); ",
        "ins2PreCode":"public void testAlternateIncludeExclude() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/**\", }); ds.setExcludes(new String[] { \"alpha/**\", }); ds.scan(); compareFiles(ds, new String[] {}, new String[] {\"alpha\"});",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(dataset,",
        "ins1DelCode":"XYPlot plot = new XYPlot(dataset,",
        "ins1PreCode":"s2.add(15.0, 9.5); s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new XYLineAndShapeRenderer());",
        "ins2PreCode":"s2.add(15.0, 9.5); s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new XYLineAndShapeRenderer());",
        "label":1
    },
    {
        "ins1AddCode":"DebounceInnerObserver<T, U> dis = new DebounceInnerObserver<>(this, idx, t);",
        "ins1DelCode":"DebounceInnerObserver<T, U> dis = new DebounceInnerObserver<T, U>(this, idx, t);",
        "ins1PreCode":"return; }  DebounceInnerObserver<T, U> dis = new DebounceInnerObserver<T, U>(this, idx, t);  if (debouncer.compareAndSet(d, dis)) {",
        "ins2PreCode":"return; } DebounceInnerSubscriber<T, U> dis = new DebounceInnerSubscriber<T, U>(this, idx, t); if (debouncer.compareAndSet(d, dis)) {",
        "label":1
    },
    {
        "ins1AddCode":"void testLangRaw() {",
        "ins1DelCode":"public void testLangRaw() {",
        "ins1PreCode":"public void testLangRaw() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins2PreCode":"public void testLangXmlTags() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "label":1
    },
    {
        "ins1AddCode":"for (Entry<Integer, CategoryDataset> entry : this.datasets.entrySet()) { CategoryDataset dataset = entry.getValue(); Integer datasetIndex = entry.getKey(); datasetIndex); if (axisIndex == 0) { if (mappedAxes.contains(axisIndex)) {",
        "ins1DelCode":"Integer key = new Integer(axisIndex); for (CategoryDataset dataset : this.datasets.values()) { int i = indexOf(dataset); new Integer(i)); if (key.equals(ZERO)) { if (mappedAxes.contains(key)) {",
        "ins1PreCode":"private List<CategoryDataset> datasetsMappedToDomainAxis(int axisIndex) { Integer key = new Integer(axisIndex); List<CategoryDataset> result = new ArrayList<CategoryDataset>(); for (CategoryDataset dataset : this.datasets.values()) { if (dataset == null) { continue; } int i = indexOf(dataset); List mappedAxes = (List) this.datasetToDomainAxesMap.get( new Integer(i)); if (mappedAxes == null) { if (key.equals(ZERO)) { result.add(dataset); } } else { if (mappedAxes.contains(key)) { result.add(dataset); }",
        "ins2PreCode":"private List datasetsMappedToRangeAxis(int index) { Integer key = new Integer(index); List result = new ArrayList(); for (CategoryDataset dataset : this.datasets.values()) { if (mappedAxes == null) { int i = indexOf(dataset); } int i = indexOf(dataset); List mappedAxes = (List) this.datasetToRangeAxesMap.get( new Integer(i)); if (mappedAxes == null) { if (key.equals(ZERO)) { result.add(this.datasets.get(i)); } } else { if (mappedAxes.contains(key)) { result.add(this.datasets.get(i)); }",
        "label":0
    },
    {
        "ins1AddCode":"if (action == LIST_FILES && listing == null) {",
        "ins1DelCode":"if ((action == LIST_FILES) && (listing == null)) {",
        "ins1PreCode":"throw new BuildException(\"password attribute must be set!\"); }  if ((action == LIST_FILES) && (listing == null)) { throw new BuildException( \"listing attribute must be set for list action!\");",
        "ins2PreCode":"throw new BuildException(\"password attribute must be set!\"); } if ((action == LIST_FILES) && (listing == null)) { throw new BuildException( \"listing attribute must be set for list action!\");",
        "label":1
    },
    {
        "ins1AddCode":"void shouldFindPostsWithBlogIdUsingDynamicSql() {",
        "ins1DelCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() {",
        "ins1PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\",",
        "ins2PreCode":"public void shouldFindPostsWithAuthorIdUsingDynamicSql() throws Exception { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\",",
        "label":0
    },
    {
        "ins1AddCode":"JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2));",
        "ins1DelCode":"JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });",
        "ins1PreCode":"Arrays.asList(9,10,11));  JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });  JavaTestUtils.attachTestOutputStream(transformed);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void diskSpaceIsUp() {",
        "ins1DelCode":"public void diskSpaceIsUp() {",
        "ins1PreCode":"public void diskSpaceIsUp() { long freeSpace = THRESHOLD.toBytes() + 10; given(this.fileMock.getUsableSpace()).willReturn(freeSpace);",
        "ins2PreCode":"public void diskSpaceIsDown() { long freeSpace = THRESHOLD.toBytes() - 10; given(this.fileMock.getUsableSpace()).willReturn(freeSpace);",
        "label":1
    },
    {
        "ins1AddCode":"Map<Integer, Integer> categoricalFeaturesInfo = new HashMap<>(); return new Tuple2<>(model.predict(p.features()), p.label());",
        "ins1DelCode":"Map<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); return new Tuple2<Double, Double>(model.predict(p.features()), p.label());",
        "ins1PreCode":"  Integer numClasses = 2; Map<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); String impurity = \"gini\"; Integer maxDepth = 5; Integer maxBins = 32;   final DecisionTreeModel model = DecisionTree.trainClassifier(trainingData, numClasses, categoricalFeaturesInfo, impurity, maxDepth, maxBins);   JavaPairRDD<Double, Double> predictionAndLabel = testData.mapToPair(new PairFunction<LabeledPoint, Double, Double>() { @Override public Tuple2<Double, Double> call(LabeledPoint p) { return new Tuple2<Double, Double>(model.predict(p.features()), p.label()); } });",
        "ins2PreCode":"boostingStrategy.getTreeStrategy().setNumClasses(2); Map<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); String datapath = \"data/mllib/sample_libsvm_data.txt\"; boostingStrategy.getTreeStrategy().setMaxDepth(5); boostingStrategy.setNumIterations(3); GradientBoostedTrees.train(trainingData, boostingStrategy); Map<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); JavaPairRDD<Double, Double> predictionAndLabel = testData.mapToPair(new PairFunction<LabeledPoint, Double, Double>() { @Override public Tuple2<Double, Double> call(LabeledPoint p) { return new Tuple2<Double, Double>(model.predict(p.features()), p.label()); } });",
        "label":1
    },
    {
        "ins1AddCode":".set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\"));",
        "ins1DelCode":".set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeapSize\", \"256mb\"));",
        "ins1PreCode":"memoryManager = new TestMemoryManager( new SparkConf() .set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeapSize\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0); ",
        "ins2PreCode":"when(blockManager.getDiskWriter( new CompressStream(), sparkConf = new SparkConf(); .then(returnsSecondArg()); sparkConf = new SparkConf(); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager);",
        "label":0
    },
    {
        "ins1AddCode":"Assertions.assertThat(cache.getName()).isEqualTo(\"default\"); Assertions.assertThat(mapper.ping()).isEqualTo(\"Hello\");",
        "ins1DelCode":"Assert.assertThat(cache.getName(), Is.is(\"default\")); Assert.assertThat(mapper.ping(), Is.is(\"Hello\"));",
        "ins1PreCode":"configuration.addMapper(AnnotationMapper.class); SupportClasses.CustomCache cache = SupportClasses.Utils.unwrap(configuration.getCache(AnnotationMapper.class.getName()));  Assert.assertThat(cache.getName(), Is.is(\"default\"));  SqlSession sqlSession = factory.openSession(); try { AnnotationMapper mapper = sqlSession.getMapper(AnnotationMapper.class);  Assert.assertThat(mapper.ping(), Is.is(\"Hello\"));  } finally {",
        "ins2PreCode":"configuration.addMapper(XmlMapper.class); SupportClasses.CustomCache cache = SupportClasses.Utils.unwrap(configuration.getCache(XmlMapper.class.getName())); Assert.assertThat(cache.getName(), Is.is(\"default\")); SqlSession sqlSession = factory.openSession(); try { XmlMapper mapper = sqlSession.getMapper(XmlMapper.class); Assert.assertThat(mapper.ping(), Is.is(\"Hello\")); } finally {",
        "label":0
    },
    {
        "ins1AddCode":"MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name); if (getter != null) { return getter; } throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\"); throw new IllegalArgumentException( \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");",
        "ins1DelCode":"for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { PainlessClass struct = painlessLookup.lookupPainlessClass(clazz); if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } } for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.lookupPainlessClass(iface); if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } } } } throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\"); throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" + \"for class [\" + receiverClass.getCanonicalName() + \"].\");",
        "ins1PreCode":"static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {  for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);  if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.lookupPainlessClass(iface);  if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } } } }  if (receiverClass.isArray() && \"length\".equals(name)) {  return arrayLengthGetter(receiverClass); } else if (Map.class.isAssignableFrom(receiverClass)) {   return MethodHandles.insertArguments(MAP_GET, 1, name); } else if (List.class.isAssignableFrom(receiverClass)) {    try { int index = Integer.parseInt(name); return MethodHandles.insertArguments(LIST_GET, 1, index); } catch (NumberFormatException exception) { throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\"); } }  throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" + \"for class [\" + receiverClass.getCanonicalName() + \"].\");",
        "ins2PreCode":"static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) { for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { PainlessClass struct = painlessLookup.lookupPainlessClass(clazz); if (struct != null) { MethodHandle handle = struct.setterMethodHandles.get(name); if (handle != null) { return handle; } } for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.lookupPainlessClass(iface); if (struct != null) { MethodHandle handle = struct.setterMethodHandles.get(name); if (handle != null) { return handle; } } } } \"for class [\" + receiverClass.getCanonicalName() + \"].\"); } else if (List.class.isAssignableFrom(receiverClass)) { if (Map.class.isAssignableFrom(receiverClass)) { return MethodHandles.insertArguments(MAP_PUT, 1, name); } else if (List.class.isAssignableFrom(receiverClass)) { try { int index = Integer.parseInt(name); return MethodHandles.insertArguments(LIST_SET, 1, index); } catch (final NumberFormatException exception) { throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\"); } } throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" + \"for class [\" + receiverClass.getCanonicalName() + \"].\");",
        "label":1
    },
    {
        "ins1AddCode":"return (compare(ctx, obj0, obj1) > 0) ? Boolean.TRUE : Boolean.FALSE;",
        "ins1DelCode":"return (compare(obj0, obj1) > 0) ? Boolean.TRUE : Boolean.FALSE;",
        "ins1PreCode":"if (obj1 == null) { return Boolean.FALSE; } return (compare(obj0, obj1) > 0) ? Boolean.TRUE : Boolean.FALSE;",
        "ins2PreCode":"if (obj1 == null) { return Boolean.FALSE; } return (compare(obj0, obj1) < 0) ? Boolean.TRUE : Boolean.FALSE;",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot p2 = TestUtils.serialised(p1);",
        "ins1DelCode":"CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1);",
        "ins1PreCode":"CategoryPlot p1 = new CategoryPlot(dataset, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.HORIZONTAL); CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1); assertTrue(p1.equals(p2));",
        "ins2PreCode":"CategoryPlot p1 = new CategoryPlot(data, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.VERTICAL); CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1AddCode":"Set<Artifact> dependencies = new HashSet<>();",
        "ins1DelCode":"Set dependencies = new HashSet();",
        "ins1PreCode":"public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories ) throws ArtifactMetadataRetrievalException { Set dependencies = new HashSet();  if ( \"g\".equals( artifact.getArtifactId() ) )",
        "ins2PreCode":"public ResolutionGroup retrieve( Artifact artifact, ArtifactRepository localRepository, List<ArtifactRepository> remoteRepositories ) throws ArtifactMetadataRetrievalException { Set dependencies = new HashSet(); if ( \"g\".equals( artifact.getArtifactId() ) )",
        "label":1
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> d = new DefaultCategoryDataset<>();",
        "ins1DelCode":"DefaultCategoryDataset d = new DefaultCategoryDataset();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryDataset d = new DefaultCategoryDataset(); d.addValue(1.0, \"R1\", \"C1\"); d.addValue(2.0, \"R1\", \"C2\");",
        "ins2PreCode":"public void testSerialization() { DefaultCategoryDataset d = new DefaultCategoryDataset(); d.addValue(1.0, \"R1\", \"C1\"); d.addValue(2.0, \"R1\", \"C2\");",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void inEdges_checkReturnedSetMutability() { addNode(N2); Set<String> inEdges = network.inEdges(N2); try { inEdges.add(E12);",
        "ins2PreCode":"public void inEdges_checkReturnedSetMutability() { addNode(N2); Set<String> inEdges = network.inEdges(N2); try { inEdges.add(E12);",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(compare(0, 1) > 0);",
        "ins1DelCode":"assert(compare(0, 1) > 0);",
        "ins1PreCode":"insertRow(row1); insertRow(row2);  assert(compare(0, 1) > 0);",
        "ins2PreCode":"insertRow(row1); insertRow(row2); assert(compare(0, 1) < 0);",
        "label":1
    },
    {
        "ins1AddCode":"TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<>();",
        "ins1DelCode":"TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>();",
        "ins1PreCode":"List<Throwable> error = TestHelper.trackPluginErrors();  try { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>();  tc.onSubscribe(new BooleanSubscription());",
        "ins2PreCode":"List<Throwable> error = TestHelper.trackPluginErrors(); try { TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>(); tc.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" assertFalse(rso.isDisposed());  Disposable d = Disposables.empty();  rso.add(d);",
        "ins2PreCode":"assertFalse(rso.isDisposed()); Disposable d = Disposables.empty(); rso.add(d);",
        "label":1
    },
    {
        "ins1AddCode":"p = Objects.requireNonNull(onNextMapper.apply(t), \"The onNext ObservableSource returned is null\");",
        "ins1DelCode":"p = ObjectHelper.requireNonNull(onNextMapper.apply(t), \"The onNext ObservableSource returned is null\");",
        "ins1PreCode":"ObservableSource<? extends R> p;  try { p = ObjectHelper.requireNonNull(onNextMapper.apply(t), \"The onNext ObservableSource returned is null\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "ins2PreCode":"downstream.onNext(p); try { p = ObjectHelper.requireNonNull(onNextMapper.apply(t), \"The onNext publisher returned is null\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"when(rs.wasNull()).thenReturn(false);",
        "ins1PreCode":"public void shouldGetResultFromResultSetByName() throws Exception { byte[] byteArray = new byte[]{1, 2}; when(rs.getBlob(\"column\")).thenReturn(blob); when(rs.wasNull()).thenReturn(false); when(blob.length()).thenReturn((long)byteArray.length); when(blob.getBytes(1, 2)).thenReturn(byteArray);",
        "ins2PreCode":"public void shouldGetResultFromResultSetByPosition() throws Exception { byte[] byteArray = new byte[]{1, 2}; when(rs.getBlob(1)).thenReturn(blob); when(rs.wasNull()).thenReturn(false); when(blob.length()).thenReturn((long)byteArray.length); when(blob.getBytes(1, 2)).thenReturn(byteArray);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(context.getBean(DefaultWebFluxTagsProvider.class)).extracting(\"ignoreTrailingSlash\") .isEqualTo(false);",
        "ins1DelCode":"assertThat(ReflectionTestUtils.getField(context.getBean(DefaultWebFluxTagsProvider.class), \"ignoreTrailingSlash\")).isEqualTo(false);",
        "ins1PreCode":"this.contextRunner.withPropertyValues(\"management.metrics.web.server.request.ignore-trailing-slash=false\") .run((context) -> { assertThat(context).hasSingleBean(DefaultWebFluxTagsProvider.class); assertThat(ReflectionTestUtils.getField(context.getBean(DefaultWebFluxTagsProvider.class), \"ignoreTrailingSlash\")).isEqualTo(false); });",
        "ins2PreCode":"this.contextRunner.withPropertyValues(\"management.metrics.web.server.request.ignore-trailing-slash=false\") .run((context) -> { assertThat(context).hasSingleBean(DefaultWebMvcTagsProvider.class); assertThat(ReflectionTestUtils.getField(context.getBean(DefaultWebMvcTagsProvider.class), \"ignoreTrailingSlash\")).isEqualTo(false); });",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(context).getBeans(HandlerAdapter.class).hasSize(4);",
        "ins1DelCode":"assertThat(context).getBeans(HandlerAdapter.class).hasSize(3);",
        "ins1PreCode":"public void handlerAdaptersCreated() { this.contextRunner.run((context) -> { assertThat(context).getBeans(HandlerAdapter.class).hasSize(3); assertThat(context.getBean(RequestMappingHandlerAdapter.class) .getMessageConverters()).isNotEmpty().isEqualTo(",
        "ins2PreCode":"public void primaryExporterIsAllowed() { this.contextRunner.withPropertyValues(\"spring.jmx.enabled=true\") assertThat(context).getBeans(MBeanExporter.class).hasSize(2); assertThat(context.getBean(MBeanExporter.class)) assertThat(context).getBeans(MBeanExporter.class).hasSize(2);",
        "label":0
    },
    {
        "ins1AddCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 's'; Character b = d;\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testdefToCharacterImplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Character b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; Character b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; Character b = d;\"));",
        "ins2PreCode":"public void testdefToBooleanExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Boolean b = (Boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (char)0; Boolean b = (Boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; Boolean b = (Boolean)d;\"));",
        "label":0
    },
    {
        "ins1AddCode":"Map<String, Object> parms = new HashMap<>(); parms = new HashMap<>();",
        "ins1DelCode":"Map<String, Object> parms = new HashMap<String, Object>(); parms = new HashMap<String, Object>();",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 3); names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class); Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotatedWithXMLResultMap(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size()); parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); names = spMapper.getNamesAnnotatedWithXMLResultMap(parms);",
        "label":1
    },
    {
        "ins1AddCode":"URL url = new URL(\"jar:\" + this.rootJarFile.toURI().toURL() + \"!/nested.jar!/3.dat\");",
        "ins1DelCode":"URL url = new URL(\"jar:file:\" + getAbsolutePath() + \"!/nested.jar!/3.dat\");",
        "ins1PreCode":"void getContentLengthReturnsLengthOfUnderlyingEntry() throws Exception { URL url = new URL(\"jar:file:\" + getAbsolutePath() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { JarURLConnection connection = JarURLConnection.get(url, nested);",
        "ins2PreCode":"void getContentLengthLongReturnsLengthOfUnderlyingEntry() throws Exception { URL url = new URL(\"jar:file:\" + getAbsolutePath() + \"!/nested.jar!/3.dat\"); try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { JarURLConnection connection = JarURLConnection.get(url, nested);",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testNamingResults() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserByName(\"User2\"); assertEquals(Integer.valueOf(2), user.getId()); assertEquals(\"User2\", user.getName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testResultsOnlyForNaming() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserByNameConstructor(\"User2\"); assertEquals(Integer.valueOf(2), user.getId()); assertEquals(\"User2\", user.getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"long arrayOffset = Platform.LONG_ARRAY_OFFSET + 4;",
        "ins1DelCode":"long arrayOffset = 12;",
        "ins1PreCode":"public void testCompareLongsAsLittleEndian() { long arrayOffset = 12;  long[] arr1 = new long[2];",
        "ins2PreCode":"public void testCompareLongsAsUnsigned() { long arrayOffset = 12; long[] arr1 = new long[2];",
        "label":1
    },
    {
        "ins1AddCode":"DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>();",
        "ins1DelCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false);",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void tryTerminateConsumerObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerMaybeObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"} else if (value instanceof BigInteger) { return ((BigInteger)value).doubleValue();",
        "ins1PreCode":"return (float)value; } else if (value instanceof Double) { return (double)value; } else if (value instanceof BigInteger) { return ((BigInteger)value).doubleValue(); } else { throw new ClassCastException(\"cannot implicitly cast \" +",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(tomcat.getConnector().setProperty(\"useAsyncIO\", \"true\"));",
        "ins1DelCode":"tomcat.getConnector().setProperty(\"useAsyncIO\", \"true\");",
        "ins1PreCode":"Class<? extends HttpUpgradeHandler> upgradeHandlerClass) throws Exception {  Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().setProperty(\"useAsyncIO\", \"true\");  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TaskSeriesCollection<String, String> c = createCollection2(); TaskSeriesCollection<String, String> c3 = createCollection3();",
        "ins1DelCode":"TaskSeriesCollection c = createCollection2(); TaskSeriesCollection c3 = createCollection3();",
        "ins1PreCode":"public void testGetStartValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(10L, c.getStartValue(\"S1\", \"Task 1\", 0)); assertEquals(16L, c.getStartValue(\"S1\", \"Task 1\", 1)); assertEquals(30L, c.getStartValue(\"S1\", \"Task 2\", 0)); assertEquals(36L, c.getStartValue(\"S1\", \"Task 2\", 1)); assertEquals(50L, c.getStartValue(\"S2\", \"Task 3\", 0)); assertEquals(56L, c.getStartValue(\"S2\", \"Task 3\", 1));  assertEquals(10L, c.getStartValue(0, 0, 0)); assertEquals(16L, c.getStartValue(0, 0, 1)); assertEquals(30L, c.getStartValue(0, 1, 0)); assertEquals(36L, c.getStartValue(0, 1, 1)); assertEquals(50L, c.getStartValue(1, 2, 0)); assertEquals(56L, c.getStartValue(1, 2, 1));  TaskSeriesCollection c3 = createCollection3(); assertEquals(11L, c3.getStartValue(0, 0, 0)); assertEquals(22L, c3.getStartValue(0, 1, 0));",
        "ins2PreCode":"public void testGetEndValue2() { TaskSeriesCollection c = createCollection2(); assertEquals(15L, c.getEndValue(\"S1\", \"Task 1\", 0)); assertEquals(15L, c.getEndValue(\"S1\", \"Task 1\", 0)); assertEquals(35L, c.getEndValue(\"S1\", \"Task 2\", 0)); assertEquals(35L, c.getEndValue(\"S1\", \"Task 2\", 0)); assertEquals(55L, c.getEndValue(\"S2\", \"Task 3\", 0)); assertEquals(60L, c.getEndValue(\"S2\", \"Task 3\", 1)); assertEquals(15L, c.getEndValue(0, 0, 0)); assertEquals(15L, c.getEndValue(0, 0, 0)); assertEquals(35L, c.getEndValue(0, 1, 0)); assertEquals(333L, c3.getEndValue(0, 1, 1)); assertEquals(55L, c.getEndValue(1, 2, 0)); assertEquals(60L, c.getEndValue(1, 2, 1)); TaskSeriesCollection c3 = createCollection3(); assertEquals(111L, c3.getEndValue(0, 0, 0)); assertEquals(222L, c3.getEndValue(0, 1, 0));",
        "label":1
    },
    {
        "ins1AddCode":"FileHandler fh1 = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, 2); fh1.close();",
        "ins1DelCode":"new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, 2);",
        "ins1PreCode":"public void testCleanOnInitOneHandler() throws Exception { generateLogFiles(logsDir, PREFIX_1, SUFIX_1, 3);  new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, 2);  Thread.sleep(1000);",
        "ins2PreCode":"public void testCleanDisabled() throws Exception { generateLogFiles(logsDir, PREFIX_1, SUFIX_1, 3); new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, -1); Thread.sleep(1000);",
        "label":1
    },
    {
        "ins1AddCode":"CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(\"*\"));",
        "ins1DelCode":"CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\"));",
        "ins1PreCode":"corsFilter.doFilter(request, response, filterChain);  Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\")); Assert.assertTrue(((Boolean) request.getAttribute( CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());",
        "ins2PreCode":"corsFilter.doFilter(request, response, filterChain); Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\")); Assert.assertTrue(((Boolean) request.getAttribute( CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());",
        "label":1
    },
    {
        "ins1AddCode":"q = new AppendOnlyLinkedArrayList<>(4);",
        "ins1DelCode":"q = new AppendOnlyLinkedArrayList<Object>(4);",
        "ins1PreCode":"if (emitting) { AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(4); queue = q; }",
        "ins2PreCode":"if (emitting) { AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(4); queue = q; }",
        "label":1
    },
    {
        "ins1AddCode":"assertThatExceptionOfType(CloudFoundryAuthorizationException.class) .isThrownBy(() -> new Token(Base64Utils.encodeToString(header.getBytes()) Base64Utils.encodeToString(claims.getBytes())); + \".\" + Base64Utils.encodeToString(claims.getBytes()))) .satisfies(reasonRequirement(Reason.INVALID_TOKEN));",
        "ins1DelCode":"this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_TOKEN)); new Token(Base64Utils.encodeToString(header.getBytes()) + \".\" + Base64Utils.encodeToString(claims.getBytes()));",
        "ins1PreCode":"public void invalidJwtClaimsShouldThrowException() { String header = \"{\\\"alg\\\": \\\"RS256\\\", \\\"kid\\\": \\\"key-id\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"invalid-claims\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_TOKEN)); new Token(Base64Utils.encodeToString(header.getBytes()) + \".\" + Base64Utils.encodeToString(claims.getBytes()));",
        "ins2PreCode":"public void invalidJwtHeaderShouldThrowException() { String header = \"invalid-header\"; String header = \"invalid-header\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.INVALID_TOKEN)); new Token(Base64Utils.encodeToString(header.getBytes()) + \".\" + Base64Utils.encodeToString(claims.getBytes()));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "ins1DelCode":"assertTrue(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));",
        "ins1PreCode":"j.assertLogContains(\"Threw AbortException from publisher!\", b); File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertTrue(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));",
        "ins2PreCode":"j.assertLogContains(\"Threw IOException from publisher!\", b); File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertTrue(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));",
        "label":1
    },
    {
        "ins1AddCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb; q =1\\t\")); Assert.assertEquals(Q1_000, actual.get(0).getQuality(), 0.0001);",
        "ins1DelCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.50\")); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testSingle11() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.50\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testSingle12() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.500\")); Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "label":1
    },
    {
        "ins1AddCode":"Path texFile = Path.of(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI());",
        "ins1DelCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI());",
        "ins1PreCode":"public void testSingleFile() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); ",
        "ins2PreCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue(); EndpointPair<Integer> unused = networkAsMutableNetwork.incidentNodes(E12); assertTrue(networkAsMutableNetwork.removeEdge(E12)); networkAsMutableNetwork.incidentNodes(E12);",
        "ins1DelCode":"EndpointPair<Integer> unused = network.incidentNodes(E12); assertTrue(network.removeEdge(E12)); network.incidentNodes(E12);",
        "ins1PreCode":"public void removeEdge_queryAfterRemoval() { addEdge(N1, N2, E12); @SuppressWarnings(\"unused\") EndpointPair<Integer> unused = network.incidentNodes(E12); assertTrue(network.removeEdge(E12)); try { network.incidentNodes(E12); fail(ERROR_EDGE_NOT_IN_GRAPH); } catch (IllegalArgumentException e) {",
        "ins2PreCode":"public void removeEdge_queryAfterRemoval() { addEdge(N1, N2, E12); @SuppressWarnings(\"unused\") EndpointPair<Integer> unused = network.incidentNodes(E12); assertTrue(network.removeEdge(E12)); try { network.incidentNodes(E12); fail(ERROR_EDGE_NOT_IN_GRAPH); } catch (IllegalArgumentException e) {",
        "label":1
    },
    {
        "ins1AddCode":"void getEndpointsWhenHasWebExtensionShouldOverrideStandardEndpoint() {",
        "ins1DelCode":"public void getEndpointsWhenHasWebExtensionShouldOverrideStandardEndpoint() {",
        "ins1PreCode":"public void getEndpointsWhenHasWebExtensionShouldOverrideStandardEndpoint() { load(OverriddenOperationWebEndpointExtensionConfiguration.class, (discoverer) -> { Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());",
        "ins2PreCode":"public void getEndpointsWhenExtensionAddsOperationShouldHaveBothOperations() { load(AdditionalOperationWebEndpointConfiguration.class, (discoverer) -> { Map<EndpointId, ExposableWebEndpoint> endpoints = mapEndpoints(discoverer.getEndpoints());",
        "label":1
    },
    {
        "ins1AddCode":"void tomcatConnectorCustomizers() {",
        "ins1DelCode":"public void tomcatConnectorCustomizers() {",
        "ins1PreCode":"public void tomcatConnectorCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatConnectorCustomizer[] customizers = new TomcatConnectorCustomizer[4];",
        "ins2PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatServletWebServerFactory factory = getFactory(); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>>[] customizers = new TomcatProtocolHandlerCustomizer[4];",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void assertValuesOnlyThrowsWhenErrored() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposables.empty());  to.onError(new TestException());",
        "ins2PreCode":"public void assertValuesOnlyThrowsWhenErrored() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposables.empty()); to.onError(new TestException());",
        "label":1
    },
    {
        "ins1AddCode":"ValueMarker m2 = CloneUtils.clone(m1);",
        "ins1DelCode":"ValueMarker m2 = (ValueMarker) m1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { ValueMarker m1 = new ValueMarker(25.0); ValueMarker m2 = (ValueMarker) m1.clone(); assertTrue(m1 != m2); assertTrue(m1.getClass() == m2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void findByPrincipal() {",
        "ins1DelCode":"public void findByPrincipal() throws Exception {",
        "ins1PreCode":"public void findByPrincipal() throws Exception { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository(); repository.add(new AuditEvent(\"dave\", \"a\"));",
        "ins2PreCode":"public void findByPrincipalAndType() throws Exception { InMemoryAuditEventRepository repository = new InMemoryAuditEventRepository(); repository.add(new AuditEvent(\"dave\", \"a\"));",
        "label":1
    },
    {
        "ins1AddCode":"resetQueueState(); assertEquals(0, Queue.WaitingItem.getCurrentCounterValue()); assertEquals(1, q.getItems().length); assertEquals(1, Queue.WaitingItem.getCurrentCounterValue());",
        "ins1DelCode":"assertEquals(1,q.getItems().length);",
        "ins1PreCode":" System.out.println(FileUtils.readFileToString(new File(r.jenkins.getRootDir(), \"queue.xml\")));  assertEquals(1,q.getItems().length); q.clear(); assertEquals(0,q.getItems().length);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"@Override protected String doForward(StringWrapper object) { @Override protected StringWrapper doBackward(String object) {",
        "ins1DelCode":"@Override public String doForward(StringWrapper object) { @Override public StringWrapper doBackward(String object) {",
        "ins1PreCode":"public void testAndThen() { Converter<StringWrapper, String> first = new Converter<StringWrapper, String>() { @Override public String doForward(StringWrapper object) { return object.value; }  @Override public StringWrapper doBackward(String object) { return new StringWrapper(object); }",
        "ins2PreCode":"public void testAndThen() { Converter<StringWrapper, String> first = new Converter<StringWrapper, String>() { @Override public String doForward(StringWrapper object) { return object.value; } @Override public StringWrapper doBackward(String object) { return new StringWrapper(object); }",
        "label":1
    },
    {
        "ins1AddCode":"List<Integer> result = new ArrayList<>();",
        "ins1DelCode":"List<Integer> result = new ArrayList<Integer>();",
        "ins1PreCode":"private List<Integer> getRendererIndices(DatasetRenderingOrder order) { List<Integer> result = new ArrayList<Integer>(); for (Entry<Integer, XYItemRenderer> entry : this.renderers.entrySet()) { if (entry.getValue() != null) {",
        "ins2PreCode":"private List<Integer> getDatasetIndices(DatasetRenderingOrder order) { List<Integer> result = new ArrayList<Integer>(); for (Map.Entry<Integer, CategoryDataset> entry : if (entry.getValue() != null) {",
        "label":1
    },
    {
        "ins1AddCode":"TimeSeries<String> s1 = new TimeSeries<>(\"A test\"); TimeSeries<String> s2 = TestUtils.serialised(s1);",
        "ins1DelCode":"TimeSeries s1 = new TimeSeries(\"A test\"); TimeSeries s2 = TestUtils.serialised(s1);",
        "ins1PreCode":"public void testSerialization() { TimeSeries s1 = new TimeSeries(\"A test\"); s1.add(new Year(2000), 13.75); s1.add(new Year(2001), 11.90); s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimeSeries s2 = TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "ins2PreCode":"public void testSerialization() { TimePeriodValues s1 = new TimePeriodValues(\"A test\"); s1.add(new Year(2000), 13.75); s1.add(new Year(2001), 11.90); s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimePeriodValues s2 = TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "label":1
    },
    {
        "ins1AddCode":"String localUrl = getLocalUrl(\"https\", \"/test.txt\"); assertThatIOException().isThrownBy(() -> getResponse(localUrl, requestFactory));",
        "ins1DelCode":"getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory);",
        "ins1PreCode":".build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public String toString() { final StringBuilder buf = new StringBuilder(\"{presentselector targetdir: \");",
        "ins1DelCode":"public String toString() { StringBuilder buf = new StringBuilder(\"{presentselector targetdir: \");",
        "ins1PreCode":"public String toString() { StringBuilder buf = new StringBuilder(\"{presentselector targetdir: \"); if (targetdir == null) { buf.append(\"NOT YET SET\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"getCoyoteResponse().addHeader(name, value, charset);",
        "ins1DelCode":"coyoteResponse.addHeader(name, value, charset);",
        "ins1PreCode":"return; }  coyoteResponse.addHeader(name, value, charset);",
        "ins2PreCode":"return; } coyoteResponse.setHeader(name, value);",
        "label":1
    },
    {
        "ins1AddCode":"final ArrayList<String> list = new ArrayList<>();",
        "ins1DelCode":"final ArrayList<String> list = new ArrayList<String>();",
        "ins1PreCode":"} });  final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new DefaultSubscriber<String>() { ",
        "ins2PreCode":"} }); final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new DefaultObserver<String>() {",
        "label":1
    },
    {
        "ins1AddCode":"PublishDisposable<T> ps = new PublishDisposable<>(t, this);",
        "ins1DelCode":"PublishDisposable<T> ps = new PublishDisposable<T>(t, this);",
        "ins1PreCode":"protected void subscribeActual(Observer<? super T> t) { PublishDisposable<T> ps = new PublishDisposable<T>(t, this); t.onSubscribe(ps); if (add(ps)) {",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super T> t) { PublishSubscription<T> ps = new PublishSubscription<T>(t, this); t.onSubscribe(ps); if (add(ps)) {",
        "label":1
    },
    {
        "ins1AddCode":"Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Flowable\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } Pattern p = Pattern.compile(\"@see\\\\s+#[A-Za-z0-9 _.,()]*Observable\"); if (!p.matcher(m.javadoc).find()) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }",
        "ins1DelCode":"e.append(\"java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
        "ins1PreCode":"int idx = m.javadoc.indexOf(\"Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Single\", jdx); if (idx >= 0) { int j = m.javadoc.indexOf(\"#toSingle\", jdx); int k = m.javadoc.indexOf(\"{@code Single\", jdx); if (!m.signature.contains(\"Single\") && (j + 3 != idx && k + 7 != idx)) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"SingleSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"SingleSource\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; }",
        "ins2PreCode":"int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"onNext\", jdx); if (idx >= 0) { int idx = m.javadoc.indexOf(\" Flowable\", jdx); int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" MaybeSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"MaybeSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; }",
        "label":0
    },
    {
        "ins1AddCode":"DefaultKeyedValuesDataset<String> d1 = new DefaultKeyedValuesDataset<>(); DefaultKeyedValuesDataset<String> d2 = CloneUtils.clone(d1);",
        "ins1DelCode":"DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); DefaultKeyedValuesDataset d2 = (DefaultKeyedValuesDataset) d1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); d1.setValue(\"V1\", 1); d1.setValue(\"V2\", null); d1.setValue(\"V3\", 3); DefaultKeyedValuesDataset d2 = (DefaultKeyedValuesDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultPieDataset<String> d1 = new DefaultPieDataset<>(); d1.setValue(\"V1\", 1); d1.setValue(\"V2\", null); d1.setValue(\"V3\", 3); DefaultPieDataset<String> d1 = new DefaultPieDataset<>(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"Object element = entries.get(i);",
        "ins1DelCode":"Object element = entries.elementAt(i);",
        "ins1PreCode":" final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i);  if (element instanceof InterfaceMethodRefCPInfo) {",
        "ins2PreCode":"final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i); if (element instanceof FieldRefCPInfo) {",
        "label":1
    },
    {
        "ins1AddCode":"wsContainer.connectToServer(TesterProgrammaticEndpoint.class,",
        "ins1DelCode":"wsContainer.connectToServer(TesterEndpoint.class,",
        "ins1PreCode":" WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() +",
        "ins2PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) chart.getPlot();",
        "ins1PreCode":"DefaultXYDataset<String> dataset = new DefaultXYDataset<>(); JFreeChart chart = ChartFactory.createXYLineChart(\"Title\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, true, false, false); XYPlot plot = (XYPlot) chart.getPlot(); plot.setRenderer(1, new XYLineAndShapeRenderer()); try {",
        "ins2PreCode":"DefaultXYDataset<String> dataset = new DefaultXYDataset<>(); JFreeChart chart = ChartFactory.createXYLineChart(\"Title\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, true, false, false); XYPlot plot = (XYPlot) chart.getPlot(); plot.setRenderer(null); try {",
        "label":1
    },
    {
        "ins1AddCode":"lookup = new SearchLookup(field -> field.equals(\"field\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "ins1DelCode":"lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "ins1PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(); lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "ins2PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData); service = new ExpressionScriptEngine(); lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "label":1
    },
    {
        "ins1AddCode":"ObjectRenameCommand command, Map<String, Object> options)",
        "ins1DelCode":"SQLObjectEditor<ExasolTableForeignKey, ExasolTable>.ObjectRenameCommand command)",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, SQLObjectEditor<ExasolTableForeignKey, ExasolTable>.ObjectRenameCommand command) { final ExasolTableForeignKey key = command.getObject();",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, SQLObjectEditor<ExasolTableUniqueKey, ExasolTable>.ObjectRenameCommand command) { final ExasolTableUniqueKey key = command.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"Observable.create(new ObservableOnSubscribe<Object>() { @Override public void subscribe(ObservableEmitter<Object> e) throws Exception { Disposable d = Disposables.empty(); e.setDisposable(d); try {",
        "ins2PreCode":"Flowable.create(new FlowableOnSubscribe<Object>() { @Override public void subscribe(FlowableEmitter<Object> e) throws Exception { Disposable d = Disposables.empty(); e.setDisposable(d); try {",
        "label":1
    },
    {
        "ins1AddCode":"assertThatIllegalStateException() .isThrownBy(() -> customizer.getKeyManagerFactory(ssl, null)) .withCauseInstanceOf(NoSuchProviderException.class) .withMessageContaining(\"com.example.KeyStoreProvider\");",
        "ins1DelCode":"try { customizer.getKeyManagerFactory(ssl, null); fail(); } catch (IllegalStateException ex) { Throwable cause = ex.getCause(); assertThat(cause).isInstanceOf(NoSuchProviderException.class); assertThat(cause).hasMessageContaining(\"com.example.KeyStoreProvider\"); }",
        "ins1PreCode":"ssl.setKeyStore(\"src/test/resources/test.jks\"); ssl.setKeyStoreProvider(\"com.example.KeyStoreProvider\"); SslServerCustomizer customizer = new SslServerCustomizer(ssl, null, null); try { customizer.getKeyManagerFactory(ssl, null); fail(); } catch (IllegalStateException ex) { Throwable cause = ex.getCause(); assertThat(cause).isInstanceOf(NoSuchProviderException.class); assertThat(cause).hasMessageContaining(\"com.example.KeyStoreProvider\"); }",
        "ins2PreCode":"ssl.setTrustStore(\"src/test/resources/test.jks\"); ssl.setTrustStoreProvider(\"com.example.TrustStoreProvider\"); SslServerCustomizer customizer = new SslServerCustomizer(ssl, null, null); try { customizer.getTrustManagerFactory(ssl, null); fail(); } catch (IllegalStateException ex) { Throwable cause = ex.getCause(); assertThat(cause).isInstanceOf(NoSuchProviderException.class); assertThat(cause).hasMessageContaining(\"com.example.TrustStoreProvider\"); }",
        "label":1
    },
    {
        "ins1AddCode":"List<Object> classifiers = new ArrayList<Object>();",
        "ins1DelCode":"List classifiers = new ArrayList();",
        "ins1PreCode":" tokenizer = new StringTokenizer(bases, \",\");  List classifiers = new ArrayList(); Object ns = Model.getFacade().getNamespace(modelElement); if (ns != null) {",
        "ins2PreCode":"tokenizer = new StringTokenizer(bases, \",\"); List classifiers = new ArrayList(); Object ns = Model.getFacade().getNamespace(modelElement); if (ns != null) {",
        "label":1
    },
    {
        "ins1AddCode":"repro.append(\" \").append((int) sb.charAt(j));",
        "ins1DelCode":"repro.append(\" \" + (int) sb.charAt(j));",
        "ins1PreCode":"if (utf8Length != Utf8.encodedLength(sb)) { StringBuilder repro = new StringBuilder(); for (int j = 0; j < sb.length(); j++) { repro.append(\" \" + (int) sb.charAt(j)); } assertEquals(repro.toString(), utf8Length, Utf8.encodedLength(sb));",
        "ins2PreCode":"if (utf8Length != Utf8.encodedLength(sb)) { StringBuilder repro = new StringBuilder(); for (int j = 0; j < sb.length(); j++) { repro.append(\" \" + (int) sb.charAt(j)); } assertEquals(repro.toString(), utf8Length, Utf8.encodedLength(sb));",
        "label":1
    },
    {
        "ins1AddCode":"public boolean toLong(LongWrapper toLongResult) { return false; return false; int digit; if (b >= '0' && b <= '9') { digit = b - '0'; } else { return false; } return false; return false; byte currentByte = getByte(offset); if (currentByte < '0' || currentByte > '9') { return false; return false; toLongResult.value = result; return true;",
        "ins1DelCode":"public long toLong() { throw new NumberFormatException(\"Empty string\"); throw new NumberFormatException(toString()); int digit = getDigit(b); throw new NumberFormatException(toString()); throw new NumberFormatException(toString()); if (getDigit(getByte(offset)) == -1) { throw new NumberFormatException(toString()); throw new NumberFormatException(toString()); return result;",
        "ins1PreCode":"public long toLong() { if (numBytes == 0) { throw new NumberFormatException(\"Empty string\"); }  byte b = getByte(0); final boolean negative = b == '-'; int offset = 0; if (negative || b == '+') { offset++; if (numBytes == 1) { throw new NumberFormatException(toString()); } }  final byte separator = '.'; final int radix = 10; final long stopValue = Long.MIN_VALUE / radix; long result = 0;  while (offset < numBytes) { b = getByte(offset); offset++; if (b == separator) {    break; }  int digit = getDigit(b);    if (result < stopValue) { throw new NumberFormatException(toString()); }  result = result * radix - digit;    if (result > 0) { throw new NumberFormatException(toString()); } }     while (offset < numBytes) { if (getDigit(getByte(offset)) == -1) { throw new NumberFormatException(toString()); } offset++; }  if (!negative) { result = -result; if (result < 0) { throw new NumberFormatException(toString()); } }  return result;",
        "ins2PreCode":"public int toInt() { if (numBytes == 0) { throw new NumberFormatException(\"Empty string\"); } byte b = getByte(0); final boolean negative = b == '-'; int offset = 0; if (negative || b == '+') { offset++; if (numBytes == 1) { throw new NumberFormatException(toString()); } } final byte separator = '.'; final int radix = 10; final int stopValue = Integer.MIN_VALUE / radix; int result = 0; while (offset < numBytes) { b = getByte(offset); offset++; if (b == separator) { break; } int digit = getDigit(b); if (result < stopValue) { throw new NumberFormatException(toString()); } result = result * radix - digit; if (result > 0) { throw new NumberFormatException(toString()); } } while (offset < numBytes) { if (getDigit(getByte(offset)) == -1) { throw new NumberFormatException(toString()); } offset++; } if (!negative) { result = -result; if (result < 0) { throw new NumberFormatException(toString()); } } return result;",
        "label":1
    },
    {
        "ins1AddCode":"connectToNode(serviceA, new DiscoveryNode(\"C\", new TransportAddress(InetAddress.getByName(\"localhost\"), 9876),",
        "ins1DelCode":"serviceA.connectToNode(new DiscoveryNode(\"C\", new TransportAddress(InetAddress.getByName(\"localhost\"), 9876),",
        "ins1PreCode":"public void testConnectException() throws UnknownHostException { try { serviceA.connectToNode(new DiscoveryNode(\"C\", new TransportAddress(InetAddress.getByName(\"localhost\"), 9876), emptyMap(), emptySet(),Version.CURRENT)); fail(\"Expected ConnectTransportException\");",
        "ins2PreCode":"public void testConnectException() throws UnknownHostException { try { serviceA.connectToNode(new DiscoveryNode(\"C\", new TransportAddress(InetAddress.getByName(\"localhost\"), 9876), emptyMap(), emptySet(), Version.CURRENT)); fail(\"Expected ConnectTransportException\");",
        "label":1
    },
    {
        "ins1AddCode":"lines = Long.parseLong(params[i].getValue()); skip = Long.parseLong(params[i].getValue());",
        "ins1DelCode":"lines = new Long(params[i].getValue()).longValue(); skip = new Long(params[i].getValue()).longValue();",
        "ins1PreCode":"if (params != null) { for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { lines = new Long(params[i].getValue()).longValue(); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = new Long(params[i].getValue()).longValue(); continue; }",
        "ins2PreCode":"if (params != null) { for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { skip = new Long(params[i].getValue()).longValue(); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = new Long(params[i].getValue()).longValue(); continue; }",
        "label":1
    },
    {
        "ins1AddCode":"void parseConvertsMultipleNewlinesToSpace() throws IOException {",
        "ins1DelCode":"public void parseConvertsMultipleNewlinesToSpace() throws IOException {",
        "ins1PreCode":"public void parseConvertsMultipleNewlinesToSpace() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\n\\nb},\" + \"b = {a\\n \\nb},\" + \"c = {a \\n \\n b}}\"));",
        "ins2PreCode":"public void parseConvertsMultipleTabsToSpace() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\t\\tb},\" + \"b = {a\\t \\tb},\" + \"c = {a \\t \\t b}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE); spillFilesCreated.clear(); spillFilesCreated.add(file);",
        "ins1DelCode":"when(shuffleMemoryManager.tryToAcquire(anyLong())).then(returnsFirstArg());",
        "ins1PreCode":"tempDir = new File(Utils.createTempDir$default$1()); taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(shuffleMemoryManager.tryToAcquire(anyLong())).then(returnsFirstArg()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult);",
        "ins1DelCode":"TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN);",
        "ins1PreCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"nested.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN);  assertEquals(expectedCrossingResult, crossingResult);",
        "ins2PreCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"crossref.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.insertEntry(database, EINSTEIN); assertEquals(expectedCrossingResult, crossingResult);",
        "label":0
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); Flowable.just(1, 2).subscribe(ts); ts.assertValues(1, 2); ts.assertNever(new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; } });",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); Flowable.just(1, 2).subscribe(ts); ts.assertValues(1, 2); thrown.expect(AssertionError.class); ts.assertNever(new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; }",
        "ins1PreCode":" ts.assertValues(1, 2);  thrown.expect(AssertionError.class);  ts.assertNever(new Predicate<Integer>() {",
        "ins2PreCode":"ts.assertNever(new Predicate<Integer>() { Flowable.just(2, 3).subscribe(ts); ts.assertNever(new Predicate<Integer>() {",
        "label":0
    },
    {
        "ins1AddCode":"JavaPairDStream<String, String> mapped = pairStream.mapValues(s -> s.toUpperCase(Locale.ENGLISH));",
        "ins1DelCode":"JavaPairDStream<String, String> mapped = pairStream.mapValues(new Function<String, String>() { @Override public String call(String s) { return s.toUpperCase(Locale.ENGLISH); } });",
        "ins1PreCode":"ssc, inputData, 1); JavaPairDStream<String, String> pairStream = JavaPairDStream.fromJavaDStream(stream);  JavaPairDStream<String, String> mapped = pairStream.mapValues(new Function<String, String>() { @Override public String call(String s) { return s.toUpperCase(Locale.ENGLISH); } });  JavaTestUtils.attachTestOutputStream(mapped);",
        "ins2PreCode":"ssc, inputData, 1); JavaPairDStream<String, String> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<String, String> mapped = pairStream.mapValues(String::toUpperCase); public void testMapValues() { public void testMapValues() { JavaPairDStream<String, String> mapped = pairStream.mapValues(String::toUpperCase); } } JavaTestUtils.attachTestOutputStream(mapped);",
        "label":0
    },
    {
        "ins1AddCode":"label_16: break label_16;",
        "ins1DelCode":"label_17: break label_17;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_17: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[43] = jj_gen; break label_17; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: MapEntry(); label_18: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[45] = jj_gen; break label_18; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"public void bindToClassWhenHasNoSetterShouldBindToList() {",
        "ins1DelCode":"public void bindToClassWhenHasNoSetterShouldBindToList() throws Exception {",
        "ins1PreCode":"public void bindToClassWhenHasNoSetterShouldBindToList() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.list[0]\", \"foo-bar\");",
        "ins2PreCode":"public void bindToClassWhenHasNoSetterShouldBindToSet() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.set[0]\", \"foo-bar\");",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Thread> thread = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Thread> thread = new AtomicReference<Thread>();",
        "ins1PreCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<Thread>();  Observable.<String>error(new Exception())",
        "ins2PreCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<Thread>(); Single.<String>error(new Exception())",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (count++ == 1) { return null; } else { return new ArrayList<Integer>(); } }",
        "ins2PreCode":"if (count++ == 1) { int count; } else { return new ArrayList<Integer>(); } }",
        "label":1
    },
    {
        "ins1AddCode":"HistogramDataset d2 = TestUtils.serialised(d1);",
        "ins1DelCode":"HistogramDataset d2 = (HistogramDataset) TestUtils.serialised(d1);",
        "ins1PreCode":"double[] values = {1.0, 2.0, 3.0, 4.0, 6.0, 12.0, 5.0, 6.3, 4.5}; HistogramDataset d1 = new HistogramDataset(); d1.addSeries(\"Series 1\", values, 5); HistogramDataset d2 = (HistogramDataset) TestUtils.serialised(d1); assertEquals(d1, d2); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Object> exception = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Object> exception = new AtomicReference<Object>();",
        "ins1PreCode":"public void interrupt() throws InterruptedException { final AtomicReference<Object> exception = new AtomicReference<Object>(); final CountDownLatch latch = new CountDownLatch(1); Flowable.just(1).subscribeOn(Schedulers.computation()).take(1)",
        "ins2PreCode":"public void interrupt() throws InterruptedException { final AtomicReference<Object> exception = new AtomicReference<Object>(); final CountDownLatch latch = new CountDownLatch(1); Observable.just(1).subscribeOn(Schedulers.computation()).take(1)",
        "label":1
    },
    {
        "ins1AddCode":"assert (start < document.getLength());",
        "ins1DelCode":"assert (start < _document.getLength());",
        "ins1PreCode":"public int findOpeningPeer(int start, int openingPeer, int closingPeer) { assert (start < _document.getLength());  int depth = 1;",
        "ins2PreCode":"public int findClosingPeer(int start, int openingPeer, int closingPeer) { assert (start <= _document.getLength()); int depth = 1;",
        "label":0
    },
    {
        "ins1AddCode":"\"VCAP_APPLICATION={\\\"application_users\\\":[],\\\"instance_id\\\":\\\"bb7935245adf3e650dfb7c58a06e9ece\\\",\" \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"started_at_timestamp\\\":1369795079,\" \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\"); + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"state_timestamp\\\":1369795079}\");",
        "ins1DelCode":"\"VCAP_APPLICATION={\\\"application_users\\\":[],\" + \"\\\"instance_id\\\":\\\"bb7935245adf3e650dfb7c58a06e9ece\\\",\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\");",
        "ins1PreCode":"void testApplicationProperties() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"VCAP_APPLICATION={\\\"application_users\\\":[],\" + \"\\\"instance_id\\\":\\\"bb7935245adf3e650dfb7c58a06e9ece\\\",\" + \"\\\"instance_index\\\":0,\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"foo\\\",\\\"uris\\\":[\\\"foo.cfapps.io\\\"],\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"host\\\":\\\"0.0.0.0\\\",\\\"port\\\":61034,\" + \"\\\"limits\\\":{\\\"mem\\\":128,\\\"disk\\\":1024,\\\"fds\\\":16384},\" + \"\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"dsyerenv\\\",\\\"uris\\\":[\\\"dsyerenv.cfapps.io\\\"],\" + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\"); this.initializer.postProcessEnvironment(this.context.getEnvironment(), null); assertThat(this.context.getEnvironment().getProperty(\"vcap.application.instance_id\"))",
        "ins2PreCode":"void testNullApplicationProperties() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, + \"\\\"instance_id\\\":\\\"bb7935245adf3e650dfb7c58a06e9ece\\\",\" + \"\\\"instance_index\\\":0,\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"foo\\\",\\\"uris\\\":[\\\"foo.cfapps.io\\\"],\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"host\\\":\\\"0.0.0.0\\\",\\\"port\\\":61034,\" + \"\\\"limits\\\":{\\\"mem\\\":128,\\\"disk\\\":1024,\\\"fds\\\":16384},\" + \"\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"dsyerenv\\\",\\\"uris\\\":[\\\"dsyerenv.cfapps.io\\\"],\" + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\"); this.initializer.postProcessEnvironment(this.context.getEnvironment(), null); assertThat(getProperty(\"vcap\")).isNull();",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(String.format(\"<root>%n  <cdataElement><![CDATA[content]]></cdataElement>%n\" \"  <cdataElement><![CDATA[content]]></cdataElement>\" StringUtils.LINE_SEP \"</root>\" + StringUtils.LINE_SEP, + \"</root>%n\"), sw.toString());",
        "ins1DelCode":"assertEquals(\"<root>\" + StringUtils.LINE_SEP + \"  <cdataElement><![CDATA[content]]></cdataElement>\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "ins1PreCode":"StringWriter sw = new StringWriter(); DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(\"<root>\" + StringUtils.LINE_SEP + \"  <cdataElement><![CDATA[content]]></cdataElement>\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "ins2PreCode":"StringWriter sw = new StringWriter(); DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(\"<root>\" + StringUtils.LINE_SEP DOMUtils.createChildElement(root, \"emptyElement\"); + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue(); assertTrue(networkAsMutableNetwork.removeNode(N1)); assertFalse(networkAsMutableNetwork.removeNode(N1)); assertThat(networkAsMutableNetwork.nodes()).containsExactly(N2, N4); assertThat(networkAsMutableNetwork.edges()).doesNotContain(E12); assertThat(networkAsMutableNetwork.edges()).doesNotContain(E41);",
        "ins1DelCode":"assertTrue(network.removeNode(N1)); assertFalse(network.removeNode(N1)); assertThat(network.nodes()).containsExactly(N2, N4); assertThat(network.edges()).doesNotContain(E12); assertThat(network.edges()).doesNotContain(E41);",
        "ins1PreCode":"public void removeNode_existingNode() { addEdge(N1, N2, E12); addEdge(N4, N1, E41); assertTrue(network.removeNode(N1)); assertFalse(network.removeNode(N1)); assertThat(network.nodes()).containsExactly(N2, N4); assertThat(network.edges()).doesNotContain(E12); assertThat(network.edges()).doesNotContain(E41);",
        "ins2PreCode":"public void removeNode_existingNode() { addEdge(N1, N2, E12); addEdge(N4, N1, E41); assertTrue(network.removeNode(N1)); assertFalse(network.removeNode(N1)); assertThat(network.nodes()).containsExactly(N2, N4); assertThat(network.edges()).doesNotContain(E12); assertThat(network.edges()).doesNotContain(E41);",
        "label":1
    },
    {
        "ins1AddCode":"private static TermsSetQueryScript.LeafFactory newTermsSetQueryScript(Expression expr, SearchLookup lookup,",
        "ins1DelCode":"private TermsSetQueryScript.LeafFactory newTermsSetQueryScript(Expression expr, SearchLookup lookup,",
        "ins1PreCode":"private TermsSetQueryScript.LeafFactory newTermsSetQueryScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) { ",
        "ins2PreCode":"private FieldScript.LeafFactory newFieldScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) { private FieldScript.LeafFactory newFieldScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {",
        "label":1
    },
    {
        "ins1AddCode":"\"server: \", ftpcce);",
        "ins1DelCode":"} catch (FTPConnectionClosedException ftpcce) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", ftpcce);",
        "ins1PreCode":" } ftp.changeToParentDirectory(); } catch (FTPConnectionClosedException ftpcce) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", ftpcce); } catch (IOException e) { throw new BuildException(\"Error while communicating with FTP \"",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> error = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> error = new AtomicReference<Throwable>();",
        "ins1PreCode":"public void customObservableWithErrorInObserverAsynchronous() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>();  ",
        "ins2PreCode":"public void customObservableWithErrorInObserverAsynchronous() throws InterruptedException { final CountDownLatch latch = new CountDownLatch(1); final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>();",
        "label":1
    },
    {
        "ins1AddCode":"this.launcher = new PropertiesLauncher(); this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);",
        "ins1DelCode":"PropertiesLauncher launcher = new PropertiesLauncher(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);",
        "ins1PreCode":"void testUserSpecifiedRootOfJarPathWithDot() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar!/./\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\")); assertThat(archives).areExactly(1, endingWith(\"app.jar\"));",
        "ins2PreCode":"void testUserSpecifiedRootOfJarPathWithDotAndJarPrefix() throws Exception { System.setProperty(\"loader.path\", \"jar:file:./src/test/resources/nested-jars/app.jar!/./\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\")); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\"));",
        "label":1
    },
    {
        "ins1AddCode":"\"app0\", \"exec1\", 0, new long[] { 0 }, new int[][] {{ 0, 1 }});",
        "ins1DelCode":"\"app0\", \"exec1\", 0, new int[] { 0 }, new int[][] {{ 0, 1 }});",
        "ins1PreCode":"when(blockResolver.getBlockData(\"app0\", \"exec1\", 0, 0, 1)).thenReturn(blockMarkers[1]);  FetchShuffleBlocks fetchShuffleBlocks = new FetchShuffleBlocks( \"app0\", \"exec1\", 0, new int[] { 0 }, new int[][] {{ 0, 1 }}); checkOpenBlocksReceive(fetchShuffleBlocks, blockMarkers); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) {",
        "ins1DelCode":"state == AsyncState.TIMING_OUT) {",
        "ins1PreCode":"if (state == AsyncState.STARTING) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state == AsyncState.TIMING_OUT) { state = AsyncState.DISPATCHING; doDispatch = true;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"checkAtReturnAndSignatureMatch(\"Completable\", m, e, \"Flowable\", \"Observable\", \"Maybe\", \"Single\", \"Completable\");",
        "ins1DelCode":"",
        "ins1PreCode":"} } aOrAn(e, m, \"Completable\"); missingClosingDD(e, m, \"Completable\"); backpressureMentionedWithoutAnnotation(e, m, \"Completable\"); }",
        "ins2PreCode":"} } aOrAn(e, m, \"Single\"); missingClosingDD(e, m, \"Single\"); backpressureMentionedWithoutAnnotation(e, m, \"Single\"); }",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, Object> metadata) throws IOException { parentFilter, valuesSource, maxOrd, pipelineAggregators, metadata);",
        "ins1DelCode":"Map<String, Object> metaData) throws IOException { parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData);",
        "ins1PreCode":"SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {  if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData); } else { return asMultiBucketAggregator(this, searchContext, parent);",
        "ins2PreCode":"SearchContext searchContext, Aggregator children, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException { if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ChildrenToParentAggregator(name, factories, searchContext, children, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData); } else { return asMultiBucketAggregator(this, searchContext, children);",
        "label":1
    },
    {
        "ins1AddCode":"public void setUp() throws IOException { super.setUp();",
        "ins1DelCode":"public void setUp() { spark = SparkSession.builder() .master(\"local\") .appName(\"JavaLogisticRegressionSuite\") .getOrCreate(); jsc = new JavaSparkContext(spark.sparkContext());",
        "ins1PreCode":"public void setUp() { spark = SparkSession.builder() .master(\"local\") .appName(\"JavaLogisticRegressionSuite\") .getOrCreate(); jsc = new JavaSparkContext(spark.sparkContext());  List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2);",
        "ins2PreCode":"public void setUp() { spark = SparkSession.builder() .master(\"local\") .appName(\"JavaLinearRegressionSuite\") .getOrCreate(); jsc = new JavaSparkContext(spark.sparkContext()); List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2);",
        "label":1
    },
    {
        "ins1AddCode":".schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>, \" + \"ints array<int>\")",
        "ins1DelCode":".schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>\")",
        "ins1PreCode":"Dataset<ArrayRecord> dataset = spark .read() .format(\"json\") .schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>\") .load(\"src/test/resources/test-data/with-array-fields.json\") .as(encoder);",
        "ins2PreCode":"Dataset<MapRecord> dataset = spark .read() .format(\"json\") .schema(\"id int, intervals map<string, struct<startTime: bigint, endTime: bigint>>\") .load(\"src/test/resources/test-data/with-map-fields.json\") .as(encoder);",
        "label":0
    },
    {
        "ins1AddCode":"return UTF8String.fromAddress(baseObject, baseOffset + offset, size);",
        "ins1DelCode":"MemoryBlock mb = MemoryBlock.allocateFromObject(baseObject, baseOffset + offset, size); return new UTF8String(mb);",
        "ins1PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; MemoryBlock mb = MemoryBlock.allocateFromObject(baseObject, baseOffset + offset, size); return new UTF8String(mb);",
        "ins2PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; MemoryBlock mb = MemoryBlock.allocateFromObject(baseObject, baseOffset + offset, size); return new UTF8String(mb);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(fields[0], instanceOf(FeatureField.class));",
        "ins1DelCode":"assertThat(fields[0], Matchers.instanceOf(FeatureField.class));",
        "ins1PreCode":"ParsedDocument doc1 = mapper.parse(source(b -> b.field(\"field\", 10))); IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0]; ",
        "ins2PreCode":"ParsedDocument doc1 = mapper.parse(source(b -> b.field(\"field\", 10))); IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0];",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":".collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() {",
        "ins2PreCode":".collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestMultiThreadedObservable subscribed to ...\"); final NullPointerException npe = new NullPointerException();",
        "ins2PreCode":"public void subscribe(final Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); System.out.println(\"TestMultiThreadedObservable subscribed to ...\"); final NullPointerException npe = new NullPointerException();",
        "label":0
    },
    {
        "ins1AddCode":"List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session );",
        "ins1DelCode":"List<TaskSegment> taskSegments = buildListCalculator.calculateTaskSegments( session );",
        "ins1PreCode":"PluginVersionResolutionException {  List<TaskSegment> taskSegments = buildListCalculator.calculateTaskSegments( session );  TaskSegment mergedSegment = new TaskSegment( false );",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void bindToClassShouldBindToSet() {",
        "ins1DelCode":"public void bindToClassShouldBindToSet() throws Exception {",
        "ins1PreCode":"public void bindToClassShouldBindToSet() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.set[0]\", \"foo-bar\");",
        "ins2PreCode":"public void bindToClassShouldBindToCollection() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.collection[0]\", \"foo-bar\");",
        "label":1
    },
    {
        "ins1AddCode":"OneofDescriptor oneof = descriptor.getOneofs().get(0); assertNotNull(oneof); assertTrue( oneof.getOptions().hasExtension(UnittestCustomOptions.oneofOpt1)); assertEquals(Integer.valueOf(-99), oneof.getOptions().getExtension(UnittestCustomOptions.oneofOpt1));",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals(Long.valueOf(8765432109L), field.getOptions().getExtension(UnittestCustomOptions.fieldOpt1));  EnumDescriptor enumType = UnittestCustomOptions.TestMessageWithCustomOptions.AnEnum.getDescriptor();  assertTrue( enumType.getOptions().hasExtension(UnittestCustomOptions.enumOpt1)); assertEquals(Integer.valueOf(-789), enumType.getOptions().getExtension(UnittestCustomOptions.enumOpt1));  ServiceDescriptor service =",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(this.output.toString()).doesNotContain( assertThat(this.output.toString())",
        "ins1DelCode":"assertThat(this.out.toString()).doesNotContain( assertThat(this.out.toString())",
        "ins1PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.out.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .doesNotContain(\"Are you using 'uriVariables'?\"); });",
        "ins2PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.out.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .doesNotContain(\"Are you using 'uriVariables'?\"); });",
        "label":0
    },
    {
        "ins1AddCode":"lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "ins1DelCode":"lookup = new SearchLookup(mapperService, ignored -> fieldData);",
        "ins1PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, ignored -> fieldData);",
        "ins2PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData); service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, ignored -> fieldData);",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"S1\");",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"S1\");",
        "ins1PreCode":"public void testGetMinX() { XYSeries s1 = new XYSeries(\"S1\"); assertTrue(Double.isNaN(s1.getMinX())); ",
        "ins2PreCode":"public void testGetMinY() { XYSeries s1 = new XYSeries(\"S1\"); assertTrue(Double.isNaN(s1.getMinY()));",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(numFeatures, features.size());",
        "ins1DelCode":"Assert.assertEquals(features.size(), numFeatures);",
        "ins1PreCode":"Dataset<Row> rescaledData = idfModel.transform(featurizedData); for (Row r : rescaledData.select(\"features\", \"label\").takeAsList(3)) { Vector features = r.getAs(0); Assert.assertEquals(features.size(), numFeatures); }",
        "ins2PreCode":"Dataset<Row> rescaledData = idfModel.transform(featurizedData); rescaledData.select(\"label\", \"features\").show(); .setNumFeatures(numFeatures); .setNumFeatures(numFeatures); }",
        "label":0
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> dataset0 = new DefaultCategoryDataset<>(); DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>();",
        "ins1DelCode":"DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset();",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "label":1
    },
    {
        "ins1AddCode":"entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( entry.getField(StandardField.FILE));",
        "ins1DelCode":"entry.setField(\"file\", FileFieldWriter.getStringRepresentation( entry.getField(\"file\"));",
        "ins1PreCode":"void movesFileWithMulitpleLinked() throws Exception { LinkedFile fileField = new LinkedFile(\"\", fileBefore.toAbsolutePath().toString(), \"\"); entry.setField(\"file\", FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), fileField, new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileDirPattern()).thenReturn(\"\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"test.pdf\", \"\"), new LinkedFile(\"\", \"\", \"\")))), entry.getField(\"file\")); assertFalse(Files.exists(fileBefore)); assertTrue(Files.exists(fileAfter));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"double prediction = model.predict(point.features());",
        "ins1DelCode":"Double prediction = model.predict(point.features());",
        "ins1PreCode":"List<LabeledPoint> validationData, LinearRegressionModel model) { int numAccurate = 0; for (LabeledPoint point : validationData) { Double prediction = model.predict(point.features());  if (Math.abs(prediction - point.label()) <= 0.5) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final BytesToBytesMap map = new BytesToBytesMap(taskMemoryManager, size, PAGE_SIZE_BYTES);",
        "ins1DelCode":"final BytesToBytesMap map = new BytesToBytesMap( taskMemoryManager, shuffleMemoryManager, size, PAGE_SIZE_BYTES);",
        "ins1PreCode":"  final Map<ByteBuffer, byte[]> expected = new HashMap<ByteBuffer, byte[]>(); final BytesToBytesMap map = new BytesToBytesMap( taskMemoryManager, shuffleMemoryManager, size, PAGE_SIZE_BYTES);  try {",
        "ins2PreCode":"final Map<ByteBuffer, byte[]> expected = new HashMap<ByteBuffer, byte[]>(); final BytesToBytesMap map = new BytesToBytesMap( taskMemoryManager, shuffleMemoryManager, 64, pageSizeBytes); try {",
        "label":1
    },
    {
        "ins1AddCode":"BibEntry e = new BibEntry(StandardEntryType.InProceedings); e.setField(StandardField.BOOKTITLE, \"Super Conference (SC)\"); SearchQuery searchQuery = new SearchQuery(\"booktitle=\\\"(\\\"\", EnumSet.noneOf(SearchFlags.class));",
        "ins1DelCode":"BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS.getName()); e.setField(FieldName.BOOKTITLE, \"Super Conference (SC)\"); SearchQuery searchQuery = new SearchQuery(\"booktitle=\\\"(\\\"\", false, false);",
        "ins1PreCode":"public void testSearchingForOpenBraketInBooktitle() { BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS.getName()); e.setField(FieldName.BOOKTITLE, \"Super Conference (SC)\");  SearchQuery searchQuery = new SearchQuery(\"booktitle=\\\"(\\\"\", false, false); assertTrue(searchQuery.isMatch(e));",
        "ins2PreCode":"public void testSearchAllFields() { BibEntry e = new BibEntry(StandardEntryType.InProceedings); e.setField(StandardField.TITLE, \"Fruity features\"); SearchQuery searchQuery = new SearchQuery(\"anyfield==\\\"fruity features\\\"\", false, false); assertTrue(searchQuery.isMatch(e));",
        "label":0
    },
    {
        "ins1AddCode":"if(tup.isBuilding() || tup.isInQueue())",
        "ins1DelCode":"tups.add(this); if(tup!=this && (tup.isBuilding() || tup.isInQueue()))",
        "ins1PreCode":"protected AbstractProject getBuildingUpstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); tups.add(this); for (AbstractProject tup : tups) { if(tup!=this && (tup.isBuilding() || tup.isInQueue())) return tup; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public static <T> Flowable<T> concatArray(@NonNull MaybeSource<? extends T>... sources) { @SuppressWarnings(\"unchecked\") MaybeSource<T> source = (MaybeSource<T>)sources[0]; return RxJavaPlugins.onAssembly(new MaybeToFlowable<>(source)); return RxJavaPlugins.onAssembly(new MaybeConcatArray<>(sources));",
        "ins1DelCode":"public static <T> Flowable<T> concatArray(MaybeSource<? extends T>... sources) { return RxJavaPlugins.onAssembly(new MaybeToFlowable<T>((MaybeSource<T>)sources[0])); return RxJavaPlugins.onAssembly(new MaybeConcatArray<T>(sources));",
        "ins1PreCode":"public static <T> Flowable<T> concatArray(MaybeSource<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return Flowable.empty(); } if (sources.length == 1) { return RxJavaPlugins.onAssembly(new MaybeToFlowable<T>((MaybeSource<T>)sources[0])); } return RxJavaPlugins.onAssembly(new MaybeConcatArray<T>(sources));",
        "ins2PreCode":"public static <T> Flowable<T> mergeArray(MaybeSource<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return Flowable.empty(); } if (sources.length == 1) { return RxJavaPlugins.onAssembly(new MaybeToFlowable<T>((MaybeSource<T>)sources[0])); } return RxJavaPlugins.onAssembly(new MaybeMergeArray<T>(sources));",
        "label":1
    },
    {
        "ins1AddCode":"t = ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\"); if (errors.tryAddThrowable(t)) {",
        "ins1DelCode":"t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (error.addThrowable(t)) {",
        "ins1PreCode":"return false; } if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); } if (error.addThrowable(t)) { done = true; drain();",
        "ins2PreCode":"return false; } if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); } if (error.addThrowable(t)) { done = true; drain();",
        "label":1
    },
    {
        "ins1AddCode":"c.close();",
        "ins1DelCode":"",
        "ins1PreCode":" configuration.addMapper(PersonMapper.class); configuration.addMapper(PetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"configuration.addMapper(MultipleCrossIncludePersonMapper.class); configuration.addMapper(MultipleCrossIncludePetMapper.class); return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1AddCode":"new ObservableMap<>(source, new SingletonArrayFunc()).subscribeActual(observer); WithLatestFromObserver<T, R> parent = new WithLatestFromObserver<>(observer, combiner, n);",
        "ins1DelCode":"new ObservableMap<T, R>(source, new SingletonArrayFunc()).subscribeActual(observer); WithLatestFromObserver<T, R> parent = new WithLatestFromObserver<T, R>(observer, combiner, n);",
        "ins1PreCode":"}  if (n == 0) { new ObservableMap<T, R>(source, new SingletonArrayFunc()).subscribeActual(observer); return; }  WithLatestFromObserver<T, R> parent = new WithLatestFromObserver<T, R>(observer, combiner, n); observer.onSubscribe(parent); parent.subscribe(others, n);",
        "ins2PreCode":"} if (n == 0) { new FlowableMap<T, R>(source, new SingletonArrayFunc()).subscribeActual(s); return; } WithLatestFromSubscriber<T, R> parent = new WithLatestFromSubscriber<T, R>(s, combiner, n); s.onSubscribe(parent); parent.subscribe(others, n);",
        "label":1
    },
    {
        "ins1AddCode":"public void registerListener() {",
        "ins1DelCode":"public void registerListener() throws Exception {",
        "ins1PreCode":"public void registerListener() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class, ListenerConfig.class);",
        "ins2PreCode":"public void registerListenerWithCustomMulticaster() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class, ListenerConfig.class, Multicaster.class);",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldEqualsTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); user.equals(null); assertEquals(3, user.setterCounter); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldCloneTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); user.clone(); assertEquals(3, user.setterCounter); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"DialPointer i2 = CloneUtils.clone(i1);",
        "ins1DelCode":"DialPointer i2 = (DialPointer) i1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DialPointer i1 = new DialPointer.Pin(1); DialPointer i2 = (DialPointer) i1.clone(); assertTrue(i1 != i2); assertTrue(i1.getClass() == i2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins1PreCode":"); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"testValue\");",
        "ins1DelCode":"entry.setField(\"field\", \"testValue\");",
        "ins1PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testValue\"); autoCompleter.indexEntry(entry); ",
        "ins2PreCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(2, parsedEntry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1DelCode":"assertEquals(\"article\", parsedEntry.getType()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins1PreCode":"BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins2PreCode":"BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"DateTickUnit unit = new DateTickUnit(DateTickUnitType.MILLISECOND, 1); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault());",
        "ins1DelCode":"DateTickUnit unit = new DateTickUnit(DateTickUnit.MILLISECOND, 1); Date nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd);",
        "ins1PreCode":"Date d0 = new Date(m0.getFirstMillisecond()); Date end = new Date(m1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.MILLISECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());",
        "ins2PreCode":"Date d0 = new Date(m0.getFirstMillisecond()); Date end = new Date(m1.getLastMillisecond()); DateTickUnit unit = new DateTickUnit(DateTickUnit.MILLISECOND, 10); axis.setTickUnit(unit); axis.setTickMarkPosition(DateTickMarkPosition.START); axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE); axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.END); axis.setRange(d0, end); psd = axis.previousStandardDate(d0, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":" assertFalse(to.hasSubscription());  to.onSubscribe(Disposables.empty());  try {",
        "ins2PreCode":"assertFalse(to.hasSubscription()); to.onSubscribe(Disposables.empty()); try {",
        "label":1
    },
    {
        "ins1AddCode":"void parseRecognizesEntryWhereLastFieldIsFinishedWithComma() throws IOException {",
        "ins1DelCode":"public void parseRecognizesEntryWhereLastFieldIsFinishedWithComma() throws IOException {",
        "ins1PreCode":"public void parseRecognizesEntryWhereLastFieldIsFinishedWithComma() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},}\"));",
        "ins2PreCode":"public void parseCombinesMultipleAuthorFields() throws IOException { ParserResult result = parser.parse( new StringReader(\"@article{test,author={Ed von Test},author={Second Author},author={Third Author}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"try ( final Reader in = input ) return new MavenToolchainsXpp3Reader().read( in, isStrict( options ) );",
        "ins1DelCode":"try MavenToolchainsXpp3Reader r = new MavenToolchainsXpp3Reader(); return r.read( input, isStrict( options ) ); finally { IOUtil.close( input ); }",
        "ins1PreCode":"{ Validate.notNull( input, \"input cannot be null\" );  try { MavenToolchainsXpp3Reader r = new MavenToolchainsXpp3Reader(); return r.read( input, isStrict( options ) ); } catch ( XmlPullParserException e ) { throw new ToolchainsParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e ); } finally { IOUtil.close( input ); }",
        "ins2PreCode":"{ Validate.notNull( input, \"input cannot be null\" ); try { MavenToolchainsXpp3Reader r = new MavenToolchainsXpp3Reader(); return r.read( input, isStrict( options ) ); } catch ( XmlPullParserException e ) { throw new ToolchainsParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e ); } finally { IOUtil.close( input ); }",
        "label":1
    },
    {
        "ins1AddCode":"containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);",
        "ins1DelCode":"containerLog.warn(sm.getString(\"jndiRealm.exception\"), e); containerLog.warn(sm.getString(\"jndiRealm.exception\"), e); containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);",
        "ins1PreCode":"   containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials);  } catch (CommunicationException e) {   containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials);  } catch (ServiceUnavailableException e) {   containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);  ",
        "ins2PreCode":"containerLog.warn(sm.getString(\"jndiRealm.exception\"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } catch (CommunicationException e) { containerLog.warn(sm.getString(\"jndiRealm.exception\"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } catch (ServiceUnavailableException e) { containerLog.warn(sm.getString(\"jndiRealm.exception\"), e);",
        "label":0
    },
    {
        "ins1AddCode":"if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { if (!ObjectUtils.equal(getURLText(), that.getURLText())) {",
        "ins1DelCode":"if (!ObjectUtilities.equal(getToolTipText(), that.getToolTipText())) { if (!ObjectUtilities.equal(getURLText(), that.getURLText())) {",
        "ins1PreCode":"if (!getArea().equals(that.getArea())) { return false; } if (!ObjectUtilities.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtilities.equal(getURLText(), that.getURLText())) { return false; }",
        "ins2PreCode":"if (!getArea().equals(that.getArea())) { return false; } if (!ObjectUtilities.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtilities.equal(getURLText(), that.getURLText())) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"public List<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor)",
        "ins1DelCode":"public Collection<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor)",
        "ins1PreCode":"public Collection<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor) throws DBException {",
        "ins2PreCode":"public Collection<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor) throws DBException {",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<String> filtered = stream.filter(s -> s.contains(\"a\"));",
        "ins1DelCode":"JavaDStream<String> filtered = stream.filter(new Function<String, Boolean>() { @Override public Boolean call(String s) { return s.contains(\"a\"); } });",
        "ins1PreCode":"Arrays.asList(\"yankees\"));  JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> filtered = stream.filter(new Function<String, Boolean>() { @Override public Boolean call(String s) { return s.contains(\"a\"); } }); JavaTestUtils.attachTestOutputStream(filtered); List<List<String>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins2PreCode":"Arrays.asList(\"yankees\")); JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> filtered = stream.filter(s -> s.contains(\"a\")); Arrays.asList(\"yankees\")); public void testFilter() { JavaDStream<String> filtered = stream.filter(s -> s.contains(\"a\")); } } JavaTestUtils.attachTestOutputStream(filtered); List<List<String>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue(e.getMessage().contains(\"Error invoking SqlProvider method 'public java.lang.String org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameQuery(java.lang.String,java.lang.String)' with specify parameter 'class java.lang.Object'.  Cause: java.lang.IllegalArgumentException: wrong number of arguments\"));",
        "ins1DelCode":"assertTrue(e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameQuery). Cannot invoke a method that holds multiple arguments using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\"));",
        "ins1PreCode":".getBoundSql(new Object()); fail(); } catch (BuilderException e) { assertTrue(e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameQuery). Cannot invoke a method that holds multiple arguments using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\")); }",
        "ins2PreCode":".getBoundSql(new Object()); fail(); } catch (BuilderException e) { assertTrue(e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameWithParamNameQuery). Cannot invoke a method that holds named argument(@Param) using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\")); }",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, SHORT_USER_NAME, PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, SHORT_PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(SHORT_PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1DelCode":"AUTH_HEADER.getHeader());",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"entry2.setCitationKey(\"entry2\");",
        "ins1DelCode":"entry2.setCiteKey(\"entry2\");",
        "ins1PreCode":"BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"Simon Holland\"); database.insertEntry(entry1);",
        "ins2PreCode":"BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry1.setField(StandardField.CROSSREF, \"entry2\"); database.insertEntry(entry1);",
        "label":1
    },
    {
        "ins1AddCode":"if (c1 == '#' || c1 == '$') { }",
        "ins1DelCode":"if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'' || c1 == '#' || c1 == '$') {",
        "ins1PreCode":"char c = image.charAt(i); if (c == '\\\\' && i + 1 < size) { char c1 = image.charAt(i + 1); if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'' || c1 == '#' || c1 == '$') { c = c1; i++;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"linkedFile = new LinkedFile(\"\", tempFile, \"\"); any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));",
        "ins1DelCode":"linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\"); any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));",
        "ins1PreCode":"void deleteWhenRemoveChosenReturnsTrueButDoesNotDeletesFile() { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\"); when(dialogService.showCustomButtonDialogAndWait( any(AlertType.class),",
        "ins2PreCode":"void deleteWhenDeleteChosenReturnsTrueAndDeletesFile() { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\"); when(dialogService.showCustomButtonDialogAndWait( any(AlertType.class),",
        "label":1
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ObservableGroupJoin<>(",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ObservableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>(",
        "ins1PreCode":"Objects.requireNonNull(leftEnd, \"leftEnd is null\"); Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "ins2PreCode":"Objects.requireNonNull(leftEnd, \"leftEnd is null\"); Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new FlowableGroupJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "label":1
    },
    {
        "ins1AddCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5\"));",
        "ins1DelCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5009\"));",
        "ins1PreCode":"public void testSingle13() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5009\"));  Assert.assertEquals(1, actual.size());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (genericEntry.getCrc() != wasEntry.getCrc() || genericEntry.getSize() != wasEntry.getSize()) {",
        "ins1DelCode":"if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {",
        "ins1PreCode":"JarEntry genericEntry = genericEntries.get(filepath); JarEntry wasEntry = wasEntries.get(filepath);  if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {",
        "ins2PreCode":"JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath); if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) { if (genericEntry.getName().endsWith(\".class\")) {",
        "label":1
    },
    {
        "ins1AddCode":"void getEndpointsShouldIncludeServletEndpoints() {",
        "ins1DelCode":"public void getEndpointsShouldIncludeServletEndpoints() {",
        "ins1PreCode":"public void getEndpointsShouldIncludeServletEndpoints() { this.contextRunner.withUserConfiguration(TestServletEndpoint.class).run(assertDiscoverer((discoverer) -> { Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints();",
        "ins2PreCode":"public void getEndpointsShouldDiscoverProxyServletEndpoints() { this.contextRunner.withUserConfiguration(TestProxyServletEndpoint.class) Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints();",
        "label":1
    },
    {
        "ins1AddCode":"\"SELECT ROUTINE_DEFINITION FROM QSYS2.SYSROUTINES \" +",
        "ins1DelCode":"\"SELECT ROUTINE_DEFINITION FROM SYSROUTINES \" +",
        "ins1PreCode":"GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, sourceObject, \"Read DB2 for i procedure source\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement( \"SELECT ROUTINE_DEFINITION FROM SYSROUTINES \" + \"WHERE ROUTINE_SCHEMA=? AND ROUTINE_NAME=?\")) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void edgeOrder_insertion() {",
        "ins1DelCode":"public void edgeOrder_insertion() throws Exception {",
        "ins1PreCode":"public void edgeOrder_insertion() throws Exception { MutableNetwork<Integer, String> graph = NetworkBuilder .directed()",
        "ins2PreCode":"public void edgeOrder_default() throws Exception { MutableNetwork<Integer, String> graph = NetworkBuilder .directed()",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  final int[] call = { 0, 0 };",
        "ins2PreCode":"public void fusedConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); final int[] call = { 0, 0 };",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty());  observer.onNext(Observable.unsafeCreate(w1));",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super Flowable<String>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(Flowable.unsafeCreate(w1));",
        "label":0
    },
    {
        "ins1AddCode":"public void shouldUpdateAuthorImplicitRollback() { try (SqlSession session = sqlMapper.openSession()) { Author original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); Author updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); try (SqlSession session = sqlMapper.openSession()) { Author updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1DelCode":"public void shouldUpdateAuthorImplicitRollback() throws Exception { SqlSession session = sqlMapper.openSession(); Author original; Author updated; try { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); } finally { session.close(); try { session = sqlMapper.openSession(); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); } finally { session.close();",
        "ins1PreCode":"public void shouldUpdateAuthorImplicitRollback() throws Exception { SqlSession session = sqlMapper.openSession(); Author original; Author updated; try { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(\"jim@ibatis.apache.org\", updated.getEmail()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldUpdateAuthorCommit() throws Exception { SqlSession session = sqlMapper.openSession(); Author original; Author updated; try { original = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"\"  note    = {some note},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  note    = {some note},\" + OS.NEWLINE +",
        "ins1PreCode":"void roundTripWithModification() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author  = {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException { String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\"; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next(); entry.setField(StandardField.AUTHOR, \"BlaBla\"); StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString(); String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE; assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1AddCode":"seriesPaint = this.defaultPaint;",
        "ins1DelCode":"seriesPaint = this.basePaint;",
        "ins1PreCode":"} } if (seriesPaint == null) { seriesPaint = this.basePaint; } return seriesPaint;",
        "ins2PreCode":"} } if (seriesFillPaint == null) { seriesFillPaint = this.baseFillPaint; } return seriesFillPaint;",
        "label":1
    },
    {
        "ins1AddCode":"public void bindToMapNonScalarCollectionShouldPopulateMap() {",
        "ins1DelCode":"public void bindToMapNonScalarCollectionShouldPopulateMap() throws Exception {",
        "ins1PreCode":"public void bindToMapNonScalarCollectionShouldPopulateMap() throws Exception { Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class); Bindable<Map<String, List<JavaBean>>> target = getMapBindable(String.class,",
        "ins2PreCode":"public void bindToMapNonScalarCollectionWithDotKeysShouldBind() throws Exception { Bindable<List<JavaBean>> valueType = Bindable.listOf(JavaBean.class); Bindable<Map<String, List<JavaBean>>> target = getMapBindable(String.class,",
        "label":1
    },
    {
        "ins1AddCode":"readBlocking = true; synchronized (readLock) { if (readBlocking) { readLock.wait(timeout); readLock.wait(); if (readBlocking) { readBlocking = false;",
        "ins1DelCode":"blockReadDone = new AtomicBoolean(false); synchronized (blockReadDone) { if (!blockReadDone.get()) { blockReadDone.wait(timeout); blockReadDone.wait(); if (!blockReadDone.get()) { blockReadDone = null;",
        "ins1PreCode":"if (block && nRead == 0) { long timeout = getReadTimeout(); try { blockReadDone = new AtomicBoolean(false); registerReadInterest(); synchronized (blockReadDone) { if (!blockReadDone.get()) { try { if (timeout > 0) { blockReadDone.wait(timeout); } else { blockReadDone.wait(); } } catch (InterruptedException e) {  } if (!blockReadDone.get()) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { blockReadDone = null; } }",
        "ins2PreCode":"if (block) { long timeout = getWriteTimeout(); try { blockWriteDone = new AtomicBoolean(false); registerWriteInterest(); synchronized (blockWriteDone) { if (!blockWriteDone.get()) { try { if (timeout > 0) { blockWriteDone.wait(timeout); } else { blockWriteDone.wait(); } } catch (InterruptedException e) { } if (!blockWriteDone.get()) { throw new SocketTimeoutException(); } } } n = socket.write(from); if (n == -1) { throw new EOFException(); } } finally { blockWriteDone = null; } }",
        "label":0
    },
    {
        "ins1AddCode":"buildRule.executeTarget(\"lastModifiedSetup\"); File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5))); long ts1 = testFile.lastModified(); buildRule.executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(buildRule.getOutputDir(), \"test.txt\").lastModified());",
        "ins1DelCode":"executeTarget(\"lastModifiedSetup\"); long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(getOutputDir(), \"test.txt\").lastModified());",
        "ins1PreCode":"public void testNoPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(getOutputDir(), \"test.txt\").lastModified());",
        "ins2PreCode":"public void testPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testPreserve\"); assertTrue(ts1 == new File(getOutputDir(), \"test.txt\").lastModified());",
        "label":1
    },
    {
        "ins1AddCode":"public void testMaxFileSizeProperty() {",
        "ins1DelCode":"public void testMaxFileSizeProperty() throws Exception {",
        "ins1PreCode":"public void testMaxFileSizeProperty() throws Exception { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-size\", \"100MB\");",
        "ins2PreCode":"public void testMaxHistoryProperty() throws Exception { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\");",
        "label":1
    },
    {
        "ins1AddCode":"Processor processor = new ConvertProcessor(randomAlphaOfLength(10), null, \"field\", \"field\", Type.AUTO, false);",
        "ins1DelCode":"Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false);",
        "ins1PreCode":"int randomInt = randomInt(); String randomString = Integer.toString(randomInt); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument); Object convertedValue = ingestDocument.getFieldValue(\"field\", Object.class);",
        "ins2PreCode":"long randomLong = randomLong(); String randomString = Long.toString(randomLong); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument); Object convertedValue = ingestDocument.getFieldValue(\"field\", Object.class);",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/\", \"servlet\");",
        "ins1DelCode":"ctx.addServletMapping(\"/\", \"servlet\");",
        "ins1PreCode":"Context ctx = tomcat.addContext(\"\", null);  Tomcat.addServlet(ctx, \"servlet\", new CharsetServlet()); ctx.addServletMapping(\"/\", \"servlet\");  tomcat.start();",
        "ins2PreCode":"Context ctx = tomcat.addContext(\"\", null); Tomcat.addServlet(ctx, \"servlet\", new Bug52811Servlet()); ctx.addServletMapping(\"/\", \"servlet\"); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts(), \"Check artifact list\" );",
        "ins1DelCode":"assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "ins1PreCode":"b.addDependency( \"c\", \"3.0\", true );  ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "ins2PreCode":"b.addDependency( \"c\", \"3.0\", Artifact.SCOPE_TEST ); ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "label":1
    },
    {
        "ins1AddCode":"List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); axisIndices = Arrays.asList(new Integer[] {1, 2});",
        "ins1DelCode":"List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)});",
        "ins1PreCode":"plot.mapDatasetToDomainAxis(0, 1); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));",
        "ins2PreCode":"plot.mapDatasetToRangeAxis(0, 1); assertEquals(yAxis2, plot.getRangeAxisForDataset(0)); List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0)); axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis2, plot.getRangeAxisForDataset(0));",
        "label":1
    },
    {
        "ins1AddCode":"GeoIpProcessor processor = factory.create(null, null, null, config);",
        "ins1DelCode":"GeoIpProcessor processor = factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"target_field\", \"_field\"); GeoIpProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\")); assertThat(processor.getTargetField(), equalTo(\"_field\"));",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"target_field\", \"_target_field\"); UserAgentProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\")); assertThat(processor.getField(), equalTo(\"_field\"));",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot subplot1 = plot.getSubplots().get(0);",
        "ins1DelCode":"XYPlot subplot1 = (XYPlot) plot.getSubplots().get(0);",
        "ins1PreCode":"CombinedDomainXYPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = (XYPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero());",
        "ins2PreCode":"CombinedDomainCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero());",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> p1 = new CategoryPlot<>(); CategoryPlot<String, String> p2 = new CategoryPlot<>();",
        "ins1DelCode":"CategoryPlot p1 = new CategoryPlot(); CategoryPlot p2 = new CategoryPlot();",
        "ins1PreCode":"public void testEquals_ObjectList() { CategoryPlot p1 = new CategoryPlot(); p1.setDomainAxis(new CategoryAxis(\"A\")); CategoryPlot p2 = new CategoryPlot(); p2.setDomainAxis(new CategoryAxis(\"A\")); assertEquals(p1, p2);",
        "ins2PreCode":"public void testEquals_ObjectList3() { CategoryPlot p1 = new CategoryPlot(); p1.setRangeAxis(new NumberAxis(\"A\")); CategoryPlot p2 = new CategoryPlot(); p2.setRangeAxis(new NumberAxis(\"A\")); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1AddCode":"void constructorParameterMetadataNestedGroup() throws IOException {",
        "ins1DelCode":"public void constructorParameterMetadataNestedGroup() throws IOException {",
        "ins1PreCode":"public void constructorParameterMetadataNestedGroup() throws IOException { process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(ImmutableInnerClassProperties.class);",
        "ins2PreCode":"public void javaBeanMetadataNestedGroup() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(InnerClassProperties.class);",
        "label":1
    },
    {
        "ins1AddCode":"public Map<Object, ExasolLock> getLocks(DBCSession session,Map<String, Object> options) throws DBException Map<Object, ExasolLock> locks = new HashMap<>(10);",
        "ins1DelCode":"public Map<BigInteger, ExasolLock> getLocks(DBCSession session,Map<String, Object> options) throws DBException Map<BigInteger, ExasolLock> locks = new HashMap<BigInteger,ExasolLock>(10);",
        "ins1PreCode":"public Map<BigInteger, ExasolLock> getLocks(DBCSession session,Map<String, Object> options) throws DBException { try { Map<BigInteger, ExasolLock> locks = new HashMap<BigInteger,ExasolLock>(10);  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_QUERY)) {",
        "ins2PreCode":"public Map<Integer,PostgreLock> getLocks(DBCSession session, Map<String, Object> options) throws DBException { try { Map<Integer,PostgreLock> locks = new HashMap<Integer,PostgreLock>(10); try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_QUERY)) {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"@SuppressWarnings(\"unchecked\")",
        "ins1PreCode":"public void combineLatestObject() { @SuppressWarnings(\"unchecked\") final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3)); Observable.combineLatest(observables, new Function<Object[], Object>() {",
        "ins2PreCode":"public void combineLatestObject() { @SuppressWarnings(\"unchecked\") final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3)); Flowable.combineLatest(flowables, new Function<Object[], Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"if (USE_STREAM_MONITOR && settings.getFormat() != PostgreBackupRestoreSettings.ExportFormat.DIRECTORY) {",
        "ins1DelCode":"if (settings.getFormat() != PostgreBackupRestoreSettings.ExportFormat.DIRECTORY) {",
        "ins1PreCode":"throw new IOException(\"File '\" + inputFile.getAbsolutePath() + \"' doesn't exist\"); } super.startProcessHandler(monitor, task, settings, arg, processBuilder, process, log); if (settings.getFormat() != PostgreBackupRestoreSettings.ExportFormat.DIRECTORY) { new BinaryFileTransformerJob(monitor, task, inputFile, process.getOutputStream(), log).start(); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (numFields == 0) { return; } for (int i = 0; i < (numFields - 1); i++) {",
        "ins1DelCode":"for (int i = 0; i < numFields - 1; i++) {",
        "ins1PreCode":"numFields += entryFields.size(); }  for (int i = 0; i < numFields - 1; i++) { insertFieldQuery.append(\", (?, ?, ?)\"); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final List<Integer> list = new ArrayList<>();",
        "ins1DelCode":"final List<Integer> list = new ArrayList<Integer>();",
        "ins1PreCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<Integer>();  Observable.<Integer>error(new TestException()).subscribe(new Consumer<Integer>() {",
        "ins2PreCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<Integer>(); Flowable.<Integer>error(new TestException()).subscribe(new Consumer<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"\"Reached the maximum number of URI tags for 'http.client.requests'.\")",
        "ins1DelCode":"\"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output.toString())",
        "ins1PreCode":"MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.output.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output.toString()) .doesNotContain(\"Are you using 'uriVariables'?\"); });",
        "ins2PreCode":"MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.output.toString()).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output.toString()) .doesNotContain(\"Are you using 'uriVariables'?\"); });",
        "label":1
    },
    {
        "ins1AddCode":"Context ctx = tomcat.addContext(\"\", null);",
        "ins1DelCode":"File docBase = new File(System.getProperty(\"java.io.tmpdir\")); Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();   File docBase = new File(System.getProperty(\"java.io.tmpdir\")); Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());  Tomcat.addServlet(ctx, \"servlet\", new CharsetServlet());",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty(\"java.io.tmpdir\")); Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath()); Tomcat.addServlet(ctx, \"servlet\", new Bug52811Servlet());",
        "label":1
    },
    {
        "ins1AddCode":"final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters, allFilters); @Override public TokenFilterFactory getSynonymFilter() { return IDENTITY_FILTER; }",
        "ins1DelCode":"final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters);",
        "ins1PreCode":"public TokenFilterFactory getChainAwareTokenFilterFactory(TokenizerFactory tokenizer, List<CharFilterFactory> charFilters, List<TokenFilterFactory> previousTokenFilters, Function<String, TokenFilterFactory> allFilters) { final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters); final SynonymMap synonyms = buildSynonyms(analyzer, getRulesFromSettings(environment)); final String name = name();",
        "ins2PreCode":"public TokenFilterFactory getChainAwareTokenFilterFactory(TokenizerFactory tokenizer, List<CharFilterFactory> charFilters, List<TokenFilterFactory> previousTokenFilters, Function<String, TokenFilterFactory> allFilters) { final Analyzer analyzer = buildSynonymAnalyzer(tokenizer, charFilters, previousTokenFilters); final SynonymMap synonyms = buildSynonyms(analyzer, getRulesFromSettings(environment)); final String name = name();",
        "label":0
    },
    {
        "ins1AddCode":"void invokeWhenOperationFailedShouldTranslateException() throws MBeanException, ReflectionException {",
        "ins1DelCode":"public void invokeWhenOperationFailedShouldTranslateException() throws MBeanException, ReflectionException {",
        "ins1PreCode":"public void invokeWhenOperationFailedShouldTranslateException() throws MBeanException, ReflectionException { TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(new TestJmxOperation((arguments) -> { throw new FatalBeanException(\"test failure\");",
        "ins2PreCode":"public void invokeWhenOperationFailedWithJdkExceptionShouldReuseException() TestExposableJmxEndpoint endpoint = new TestExposableJmxEndpoint(new TestJmxOperation((arguments) -> { throw new UnsupportedOperationException(\"test failure\");",
        "label":1
    },
    {
        "ins1AddCode":"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {",
        "ins1DelCode":"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {",
        "ins1PreCode":"public void timerInterruptible() throws Exception { ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor(); try { for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) { final AtomicBoolean interrupted = new AtomicBoolean(); TestObserver<Long> to = Observable.timer(1, TimeUnit.MILLISECONDS, s)",
        "ins2PreCode":"public void timerInterruptible() throws Exception { ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor(); try { for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) { final AtomicBoolean interrupted = new AtomicBoolean(); TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)",
        "label":1
    },
    {
        "ins1AddCode":"void referenceClearingIsDisabled() {",
        "ins1DelCode":"public void referenceClearingIsDisabled() {",
        "ins1PreCode":"public void referenceClearingIsDisabled() { TomcatServletWebServerFactory factory = getFactory(); this.webServer = factory.getWebServer();",
        "ins2PreCode":"public void referenceClearingIsDisabled() { TomcatReactiveWebServerFactory factory = getFactory(); this.webServer = factory.getWebServer(mock(HttpHandler.class));",
        "label":1
    },
    {
        "ins1AddCode":"TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > Bug49528Servlet.THREAD_SLEEP_TIME); assertTrue(entry.toString(), entry.getTime() < Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins1DelCode":"",
        "ins1PreCode":"wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/\", \"servlet\");  tomcat.start();   ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\"); assertEquals(\"OK\", bc.toString());   int counter = 0; while (!servlet.isDone() && counter < 10) { Thread.sleep(1000); counter++; }  assertEquals(\"1false2true3true4true5false\", servlet.getResult());",
        "ins2PreCode":"wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/\", \"servlet\"); tomcat.start(); ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\"); assertEquals(\"OK\", bc.toString()); int counter = 0; while (!servlet.isDone() && counter < 10) { Thread.sleep(1000); counter++; } assertEquals(\"1false2true3true4true5false\", servlet.getResult());",
        "label":1
    },
    {
        "ins1AddCode":"checkNotNull(collection);",
        "ins1DelCode":"if (collection == null) { throw new NullPointerException(); }",
        "ins1PreCode":"public boolean addAll(Collection<? extends Double> collection) { ensureIsMutable();  if (collection == null) { throw new NullPointerException(); } ",
        "ins2PreCode":"public boolean addAll(Collection<? extends Float> collection) { ensureIsMutable(); if (collection == null) { throw new NullPointerException(); }",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testSelectWithTeacher() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { StudentConstructorMapper studentConstructorMapper = sqlSession.getMapper(StudentConstructorMapper.class); StudentConstructor testStudent = studentConstructorMapper.selectWithTeacherById(1); assertEquals(1, testStudent.getConstructors().size()); assertTrue(testStudent.getConstructors().contains(StudentConstructor.Constructor.ID_NAME)); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testSelectNoName() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { StudentConstructorMapper studentConstructorMapper = sqlSession.getMapper(StudentConstructorMapper.class); StudentConstructor testStudent = studentConstructorMapper.selectNoNameById(1); assertEquals(1, testStudent.getConstructors().size()); assertTrue(testStudent.getConstructors().contains(StudentConstructor.Constructor.ID)); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull R> Maybe<R> zip(",
        "ins1DelCode":"public static <T1, T2, T3, T4, T5, R> Maybe<R> zip(",
        "ins1PreCode":"public static <T1, T2, T3, T4, T5, R> Maybe<R> zip( @NonNull MaybeSource<? extends T1> source1, @NonNull MaybeSource<? extends T2> source2, @NonNull MaybeSource<? extends T3> source3, @NonNull MaybeSource<? extends T4> source4, @NonNull MaybeSource<? extends T5> source5,",
        "ins2PreCode":"public static <T1, T2, T3, T4, T5, R> Single<R> zip( @NonNull SingleSource<? extends T1> source1, @NonNull SingleSource<? extends T2> source2, @NonNull SingleSource<? extends T1> source1, @NonNull SingleSource<? extends T2> source2,",
        "label":1
    },
    {
        "ins1AddCode":"public void contextIsAddedToHostBeforeCustomizersAreCalled() { ArgumentCaptor<Context> contextCaptor = ArgumentCaptor.forClass(Context.class); verify(customizer).customize(contextCaptor.capture()); assertThat(contextCaptor.getValue().getParent()).isNotNull();",
        "ins1DelCode":"public void contextIsAddedToHostBeforeCustomizersAreCalled() throws Exception { willAnswer(new Answer<Void>() { @Override public Void answer(InvocationOnMock invocation) throws Throwable { assertThat(((Context) invocation.getArguments()[0]).getParent()) .isNotNull(); return null; } }).given(customizer).customize(any(Context.class)); verify(customizer).customize(any(Context.class));",
        "ins1PreCode":"public void contextIsAddedToHostBeforeCustomizersAreCalled() throws Exception { TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer customizer = mock(TomcatContextCustomizer.class); willAnswer(new Answer<Void>() {  @Override public Void answer(InvocationOnMock invocation) throws Throwable { assertThat(((Context) invocation.getArguments()[0]).getParent()) .isNotNull(); return null; }  }).given(customizer).customize(any(Context.class)); factory.addContextCustomizers(customizer); this.webServer = factory.getWebServer(); verify(customizer).customize(any(Context.class));",
        "ins2PreCode":"public void contextIsAddedToHostBeforeCustomizersAreCalled() throws Exception { TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer customizer = mock(TomcatContextCustomizer.class); willAnswer(new Answer<Void>() { @Override public Void answer(InvocationOnMock invocation) throws Throwable { assertThat(((Context) invocation.getArguments()[0]).getParent()) .isNotNull(); return null; } }).given(customizer).customize(any(Context.class)); factory.addContextCustomizers(customizer); this.webServer = factory.getWebServer(mock(HttpHandler.class)); verify(customizer).customize(any(Context.class));",
        "label":0
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ParallelPeek<>(this,",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "ins1PreCode":"public final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) { Objects.requireNonNull(onRequest, \"onRequest is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(), Functions.emptyConsumer(),",
        "ins2PreCode":"public final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) { Objects.requireNonNull(onCancel, \"onCancel is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(), Functions.emptyConsumer(),",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateTShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateStarShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"String getText(QMMetaEvent event, boolean briefInfo) {",
        "ins1DelCode":"String getText(QMMetaEvent event) {",
        "ins1PreCode":"private static LogColumn COLUMN_DATA_SOURCE = new LogColumn(\"datasource\", SQLEditorMessages.controls_querylog_column_connection_name, SQLEditorMessages.controls_querylog_column_connection_tooltip, 150) { @Override String getText(QMMetaEvent event) { QMMObject object = event.getObject(); String containerName = null;",
        "ins2PreCode":"private static LogColumn COLUMN_CONTEXT = new LogColumn(\"context\", SQLEditorMessages.controls_querylog_column_context_name, SQLEditorMessages.controls_querylog_column_context_tooltip, 150) { @Override String getText(QMMetaEvent event) { QMMObject object = event.getObject(); String contextName = null;",
        "label":1
    },
    {
        "ins1AddCode":"void specifyMappedStatementTimeoutOnly() throws SQLException {",
        "ins1DelCode":"public void specifyMappedStatementTimeoutOnly() throws SQLException {",
        "ins1PreCode":"public void specifyMappedStatementTimeoutOnly() throws SQLException { mappedStatementBuilder.timeout(10); ",
        "ins2PreCode":"public void specifyDefaultTimeoutOnly() throws SQLException { verify(statement).setQueryTimeout(20);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" assertFalse(ro.isDisposed());  Disposable d = Disposables.empty();  ro.add(d);",
        "ins2PreCode":"assertFalse(ro.isDisposed()); Disposable d = Disposables.empty(); ro.add(d);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph2).isSameInstanceAs(graph1);",
        "ins1DelCode":"assertThat(graph2).isSameAs(graph1);",
        "ins1PreCode":"ImmutableValueGraph.copyOf(ValueGraphBuilder.directed().<String, Integer>build()); ValueGraph<String, Integer> graph2 = ImmutableValueGraph.copyOf(graph1);  assertThat(graph2).isSameAs(graph1);",
        "ins2PreCode":"ImmutableValueGraph.copyOf(ValueGraphBuilder.directed().<String, Integer>build()); ValueGraph<String, Integer> graph2 = ImmutableValueGraph.copyOf(graph1); assertThat(graph2).isSameAs(graph1);",
        "label":1
    },
    {
        "ins1AddCode":"List<Row> data = Arrays.asList( RowFactory.create(0, Vectors.dense(1.0, 0.1, -8.0)), RowFactory.create(1, Vectors.dense(2.0, 1.0, -4.0)), RowFactory.create(2, Vectors.dense(4.0, 10.0, 8.0)) ); StructType schema = new StructType(new StructField[]{ new StructField(\"id\", DataTypes.IntegerType, false, Metadata.empty()), new StructField(\"features\", new VectorUDT(), false, Metadata.empty()) }); Dataset<Row> dataFrame = spark.createDataFrame(data, schema); scaledData.select(\"features\", \"scaledFeatures\").show();",
        "ins1DelCode":"Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); scaledData.show();",
        "ins1PreCode":".getOrCreate();   Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  spark.stop();",
        "ins2PreCode":".getOrCreate(); Dataset<Row> dataFrame = .getOrCreate(); lInfNormData.show(); spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); Normalizer normalizer = new Normalizer() .setInputCol(\"features\") .setOutputCol(\"normFeatures\") Dataset<Row> l1NormData = normalizer.transform(dataFrame); Dataset<Row> l1NormData = normalizer.transform(dataFrame); l1NormData.show(); spark.stop();",
        "label":1
    },
    {
        "ins1AddCode":"6.0, 7.0, 8.0, new ArrayList<>())); 6.0, 7.0, 8.0, new ArrayList<>()));",
        "ins1DelCode":"6.0, 7.0, 8.0, new ArrayList())); 6.0, 7.0, 8.0, new ArrayList()));",
        "ins1PreCode":"DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   d1.add(new Date(2L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertFalse(d1.equals(d2));",
        "ins2PreCode":"DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) assertFalse(d1.equals(d2)); assertTrue(d1 != d2); d1.add(new Date(2L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertFalse(d1.equals(d2));",
        "label":1
    },
    {
        "ins1AddCode":"\"handle must be instance of Generalization\"); \"child must be instance of Classifier\"); \"Set the # as the specific classifier \" + \"of the generalization #\",",
        "ins1DelCode":"\"handle must be instance of Generalization\"); \"child must be instance of Classifier\"); \"Set the # as the specific classifier of the generalization #\",",
        "ins1PreCode":"new ChangeCommand( modelImpl, run, \"Set the # as the specific classifier of the generalization #\", child, handle));",
        "ins2PreCode":"new ChangeCommand( modelImpl, run, \"Set the # as the general classifier of the generalization #\", parent, handle));",
        "label":1
    },
    {
        "ins1AddCode":"List<NodePropertyDescriptor> result = new ArrayList<>();",
        "ins1DelCode":"List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>();",
        "ins1PreCode":"public final List<NodePropertyDescriptor> nodePropertyDescriptors(@CheckForNull Slave it) { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);",
        "ins2PreCode":"public static List<NodePropertyDescriptor> getGlobalNodePropertyDescriptors() { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); for (NodePropertyDescriptor npd : list) { Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(2, pm.findAll().size()); Assertions.assertEquals(3, pm.findAll().size());",
        "ins1DelCode":"Assert.assertEquals(2, pm.findAll().size()); Assert.assertEquals(3, pm.findAll().size());",
        "ins1PreCode":"public void shouldInsertWithOptionsFlushesCache() { try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); Person p = new Person(3, \"hello\", \"world\"); pm.createWithOptions(p); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(3, pm.findAll().size()); }",
        "ins2PreCode":"public void shouldApplyFlushCacheOptions() { try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); } try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); Person p = new Person(3, \"hello\", \"world\"); pm.createWithoutFlushCache(p); } try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }",
        "label":0
    },
    {
        "ins1AddCode":"void shouldFailOverToMostApplicableSimpleName() { Assertions.assertThrows(IllegalArgumentException.class, () -> c.getCache(invalidName));",
        "ins1DelCode":"public void shouldFailOverToMostApplicableSimpleName() { Assertions.assertThrows(IllegalArgumentException.class, () -> { c.getCache(invalidName); });",
        "ins1PreCode":"public void shouldFailOverToMostApplicableSimpleName() { Configuration c = new Configuration(); final String fullName = \"com.mycache.MyCache\"; final String invalidName = \"unknown.namespace.MyCache\"; final PerpetualCache cache = new PerpetualCache(fullName); c.addCache(cache); assertEquals(cache, c.getCache(fullName)); Assertions.assertThrows(IllegalArgumentException.class, () -> { c.getCache(invalidName); });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (Iterator i = getNested().iterator(); i.hasNext();) {",
        "ins1DelCode":"for (Iterator i = rc.iterator(); i.hasNext();) {",
        "ins1PreCode":"if (isReference()) { super.dieOnCircularReference(stk, p); } else { for (Iterator i = rc.iterator(); i.hasNext();) { Object o = i.next(); if (o instanceof DataType) {",
        "ins2PreCode":"if (isReference()) { super.dieOnCircularReference(stk, p); } else { for (Iterator i = rc.iterator(); i.hasNext();) { Object o = i.next(); if (o instanceof DataType) {",
        "label":0
    },
    {
        "ins1AddCode":"DefaultPieDataset<String> d1 = new DefaultPieDataset<>(); DefaultPieDataset<String> d2 = (DefaultPieDataset) d1.clone();",
        "ins1DelCode":"DefaultPieDataset d1 = new DefaultPieDataset(); DefaultPieDataset d2 = (DefaultPieDataset) d1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultPieDataset d1 = new DefaultPieDataset(); d1.setValue(\"V1\", 1); d1.setValue(\"V2\", null); d1.setValue(\"V3\", 3); DefaultPieDataset d2 = (DefaultPieDataset) d1.clone();  assertTrue(d1 != d2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void incidentEdges_checkReturnedSetMutability() { addNode(N1); Set<String> incidentEdges = network.incidentEdges(N1); try { incidentEdges.add(E12);",
        "ins2PreCode":"public void outEdges_checkReturnedSetMutability() { addNode(N1); Set<String> outEdges = network.outEdges(N1); try { outEdges.add(E12);",
        "label":1
    },
    {
        "ins1AddCode":"UIUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() {",
        "ins1DelCode":"DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() {",
        "ins1PreCode":"public boolean performFinish() { try { DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException {",
        "ins2PreCode":"public boolean performFinish() { try { DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(100, eventCounter.get());",
        "ins1DelCode":"assertEquals(2, eventCounter.get());",
        "ins1PreCode":"if (!latch.await(500, TimeUnit.MILLISECONDS)) { fail(\"timed out - never got completion\"); } assertEquals(2, eventCounter.get());",
        "ins2PreCode":"if (!latch.await(500, TimeUnit.MILLISECONDS)) { fail(\"timed out - never got completion\"); } assertEquals(2, eventCounter.get());",
        "label":1
    },
    {
        "ins1AddCode":"for (java.beans.PropertyDescriptor propertyDescriptor : pd) { if (propertyDescriptor.getName().equals(prop)) { result = propertyDescriptor.getWriteMethod(); type = propertyDescriptor.getPropertyType();",
        "ins1DelCode":"for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { result = pd[i].getWriteMethod(); type = pd[i].getPropertyType();",
        "ins1PreCode":"try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { result = pd[i].getWriteMethod(); type = pd[i].getPropertyType(); break; }",
        "ins2PreCode":"try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if (pd[i].getName().equals(prop)) { result = pd[i].getReadMethod(); type = pd[i].getPropertyType(); break; }",
        "label":1
    },
    {
        "ins1AddCode":"for (String forwardedProtocol : forwardedProtocols) { if (!protocolHeaderHttpsValue.equalsIgnoreCase(forwardedProtocol)) {",
        "ins1DelCode":"for (int i = 0; i < forwardedProtocols.length; i++) { if (!protocolHeaderHttpsValue.equalsIgnoreCase(forwardedProtocols[i])) {",
        "ins1PreCode":"if (forwardedProtocols.length == 0) { return false; } for (int i = 0; i < forwardedProtocols.length; i++) { if (!protocolHeaderHttpsValue.equalsIgnoreCase(forwardedProtocols[i])) { return false; }",
        "ins2PreCode":"if (forwardedProtocols.length == 0) { return false; } for (int i = 0; i < forwardedProtocols.length; i++) { if (!protocolHeaderHttpsValue.equalsIgnoreCase(forwardedProtocols[i])) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"logger.error(new ParameterizedMessage(\"--> Unexpected bad request [{}]\", FakeRestRequest.requestToString(channel.request())), cause);",
        "ins1DelCode":"",
        "ins1PreCode":" @Override public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError(); } }; try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool,",
        "ins2PreCode":"@Override public void dispatchBadRequest(RestChannel channel, ThreadContext threadContext, Throwable cause) { throw new AssertionError(); } }; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool,",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(10, users.size());",
        "ins1DelCode":"Assert.assertEquals(10, users.size());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); List<User> users = mapper.getAllUsers(); Assert.assertEquals(10, users.size()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getUsers(); Assert.assertEquals(\"Inactive\", users.get(0).getName()); }",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(2, result.getPosts().size()); Assertions.assertEquals(1, firstPost.getBlog().getId()); Assertions.assertEquals(2, firstPost.getComments().size()); Assertions.assertEquals(1, secondPost.getComments().size()); Assertions.assertEquals(2, secondPost.getComments().get(0).getPost().getId());",
        "ins1DelCode":"Assert.assertEquals(2, result.getPosts().size()); Assert.assertEquals(1, firstPost.getBlog().getId()); Assert.assertEquals(2, firstPost.getComments().size()); Assert.assertEquals(1, secondPost.getComments().size()); Assert.assertEquals(2, secondPost.getComments().get(0).getPost().getId());",
        "ins1PreCode":"Blog result = mapper.selectBlogByPrimaryKey(1); assertNotNull(result); assertEquals(\"Blog with posts\", result.getTitle()); Assert.assertEquals(2, result.getPosts().size()); Post firstPost = result.getPosts().get(0); Assert.assertEquals(1, firstPost.getBlog().getId()); Assert.assertEquals(2, firstPost.getComments().size()); Post secondPost = result.getPosts().get(1); Assert.assertEquals(1, secondPost.getComments().size()); Assert.assertEquals(2, secondPost.getComments().get(0).getPost().getId()); }",
        "ins2PreCode":"Blog result = mapper.selectBlogByPrimaryKeyColumnPrefix(1); assertNotNull(result); assertEquals(\"Blog with posts\", result.getTitle()); Assert.assertEquals(2, result.getPosts().size()); Post firstPost = result.getPosts().get(0); Assert.assertEquals(1, firstPost.getBlog().getId()); Assert.assertEquals(2, firstPost.getComments().size()); Post secondPost = result.getPosts().get(1); Assert.assertEquals(1, secondPost.getComments().size()); Assert.assertEquals(2, secondPost.getComments().get(0).getPost().getId()); }",
        "label":1
    },
    {
        "ins1AddCode":"plugins = new LinkedHashSet<>();",
        "ins1DelCode":"plugins = new LinkedHashSet<Plugin>();",
        "ins1PreCode":" if ( \"JAR\".equals( packaging ) ) { plugins = new LinkedHashSet<Plugin>();  plugins.add( newPlugin( \"maven-compiler-plugin\", \"compile\", \"testCompile\" ) );",
        "ins2PreCode":"if ( \"JAR\".equals( packaging ) ) { plugins = new LinkedHashSet<Plugin>(); plugins.add( newPlugin( \"maven-compiler-plugin\", \"compile\", \"testCompile\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"logger.debug(\"Running 'promote' command\");",
        "ins1DelCode":"",
        "ins1PreCode":"public void run(ApplicationArguments args) throws Exception { List<String> nonOptionArgs = args.getNonOptionArgs(); Assert.state(!nonOptionArgs.isEmpty(), \"No command argument specified\"); Assert.state(nonOptionArgs.size() == 3, \"Release type or build info location not specified\");",
        "ins2PreCode":"public void run(ApplicationArguments args) throws Exception { List<String> nonOptionArgs = args.getNonOptionArgs(); Assert.state(!nonOptionArgs.isEmpty(), \"No command argument specified\"); Assert.state(nonOptionArgs.size() == 3, \"Release type or build info not specified\");",
        "label":1
    },
    {
        "ins1AddCode":"Dimension size = new Dimension(0, 0); addChildDimensions(size, getStereotypeFig()); addChildDimensions(size, getNameFig()); addChildDimensions(size, getOperationsFig()); setBounds(X0, Y0, size.width, size.height);",
        "ins1DelCode":"setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "ins1PreCode":"  enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "ins2PreCode":"enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "label":0
    },
    {
        "ins1AddCode":"final List<Observer<Object>> values = new ArrayList<>();",
        "ins1DelCode":"final List<Observer<Object>> values = new ArrayList<Observer<Object>>();",
        "ins1PreCode":" final Observer<Object> o = TestHelper.mockObserver();  final List<Observer<Object>> values = new ArrayList<Observer<Object>>();  Observer<Observable<Integer>> wo = new DefaultObserver<Observable<Integer>>() {",
        "ins2PreCode":"final Observer<Object> o = TestHelper.mockObserver(); final List<Observer<Object>> values = new ArrayList<Observer<Object>>(); Observer<Observable<Integer>> wo = new DefaultObserver<Observable<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses());",
        "ins1DelCode":"Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());",
        "ins1PreCode":"try (ScanResult scanResult = classGraph.scan()) {  ClassInfoList controlClasses = scanResult.getClassesImplementing(IdBasedFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());  expected.remove(AbstractIsbnFetcher.class);",
        "ins2PreCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(SearchBasedFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); expected.remove(ACMPortalFetcher.class);",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairDStream<Integer, String> flatMapped = stream.flatMapToPair(in -> { List<Tuple2<Integer, String>> out = new ArrayList<>(); for (String letter : in.split(\"(?!^)\")) { out.add(new Tuple2<>(in.length(), letter)); return out.iterator();",
        "ins1DelCode":"JavaPairDStream<Integer, String> flatMapped = stream.flatMapToPair( new PairFlatMapFunction<String, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(String in) { List<Tuple2<Integer, String>> out = new ArrayList<>(); for (String letter: in.split(\"(?!^)\")) { out.add(new Tuple2<>(in.length(), letter)); } return out.iterator();",
        "ins1PreCode":"new Tuple2<>(9, \"s\")));  JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<Integer, String> flatMapped = stream.flatMapToPair( new PairFlatMapFunction<String, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(String in) { List<Tuple2<Integer, String>> out = new ArrayList<>(); for (String letter: in.split(\"(?!^)\")) { out.add(new Tuple2<>(in.length(), letter)); }",
        "ins2PreCode":"new Tuple2<>(9, \"s\"))); JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<Integer, String> flatMapped = stream.flatMapToPair(s -> { JavaPairDStream<Integer, String> flatMapped = stream.flatMapToPair(s -> { Arrays.asList( List<Tuple2<Integer, String>> out = Lists.newArrayList(); List<Tuple2<Integer, String>> out = Lists.newArrayList(); for (String letter : s.split(\"(?!^)\")) { out.add(new Tuple2<>(s.length(), letter)); }",
        "label":0
    },
    {
        "ins1AddCode":"public RefreshResult refreshPart(Object source, boolean force) return RefreshResult.REFRESHED; return RefreshResult.IGNORED;",
        "ins1DelCode":"public void refreshPart(Object source, boolean force)",
        "ins1PreCode":"public void refreshPart(Object source, boolean force) { if (force ||",
        "ins2PreCode":"public void refreshPart(Object source, boolean force) { if (force ||",
        "label":1
    },
    {
        "ins1AddCode":"void ofNameWhenDoubleRunOnAndAssociative() {",
        "ins1DelCode":"public void ofNameWhenDoubleRunOnAndAssociative() {",
        "ins1PreCode":"public void ofNameWhenDoubleRunOnAndAssociative() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo[bar]baz\"); assertThat(name.toString()).isEqualTo(\"foo[bar].baz\");",
        "ins2PreCode":"public void ofNameWhenDoubleDotAndAssociative() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.[bar].baz\"); assertThat(name.toString()).isEqualTo(\"foo[bar].baz\");",
        "label":1
    },
    {
        "ins1AddCode":"new FunctionTable(),",
        "ins1DelCode":"Collections.emptyMap(),",
        "ins1PreCode":"public void testNullGuardEq() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, Collections.emptyMap(), MethodHandles.publicLookup(), \"eq\",",
        "ins2PreCode":"public void testNullGuardEqWhenCached() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, Collections.emptyMap(), MethodHandles.publicLookup(), \"eq\",",
        "label":1
    },
    {
        "ins1AddCode":"TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<>();",
        "ins1DelCode":"TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>();",
        "ins1PreCode":"public void normal() { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>();  assertFalse(tc.isDisposed());",
        "ins2PreCode":"public void normal() { TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>(); assertFalse(tc.isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(subplot, \"subplot\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(subplot, \"subplot\");",
        "ins1PreCode":"public void add(CategoryPlot subplot, int weight) { ParamChecks.nullNotPermitted(subplot, \"subplot\"); if (weight <= 0) { throw new IllegalArgumentException(\"Require weight >= 1.\");",
        "ins2PreCode":"public void add(CategoryPlot subplot, int weight) { ParamChecks.nullNotPermitted(subplot, \"subplot\"); if (weight < 1) { throw new IllegalArgumentException(\"Require weight >= 1.\");",
        "label":1
    },
    {
        "ins1AddCode":"void parseRegularCommentBeforeEntry() throws IOException {",
        "ins1DelCode":"public void parseRegularCommentBeforeEntry() throws IOException {",
        "ins1PreCode":"public void parseRegularCommentBeforeEntry() throws IOException {  String bibtexEntry = \"@Comment{someComment} \" + OS.NEWLINE +",
        "ins2PreCode":"public void parseCommentWithoutBracketsBeforeEntry() throws IOException { String bibtexEntry = \"@Comment someComment  \" + OS.NEWLINE +",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue(); assertThat(graphAsMutableGraph.removeNode(N1)).isTrue(); assertThat(graphAsMutableGraph.removeNode(N2)).isTrue();",
        "ins1DelCode":"assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.removeNode(N2)).isTrue();",
        "ins1PreCode":"putEdge(N1, N2); putEdge(N2, N1);  assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.nodes()).containsExactly(N2); assertThat(graph.edges()).isEmpty();  assertThat(graph.removeNode(N2)).isTrue(); assertThat(graph.nodes()).isEmpty(); assertThat(graph.edges()).isEmpty();",
        "ins2PreCode":"putEdge(N1, N2); putEdge(N2, N1); assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.nodes()).containsExactly(N2); assertThat(graph.edges()).isEmpty(); assertThat(graph.removeNode(N2)).isTrue(); assertThat(graph.nodes()).isEmpty(); assertThat(graph.edges()).isEmpty();",
        "label":1
    },
    {
        "ins1AddCode":"try ( InputStream in = input )",
        "ins1DelCode":"try ( final InputStream in = input )",
        "ins1PreCode":"{ Objects.requireNonNull( input, \"input cannot be null\" );  try ( final InputStream in = input ) { return new SettingsXpp3Reader().read( in, isStrict( options ) );",
        "ins2PreCode":"{ Objects.requireNonNull( input, \"input cannot be null\" ); try ( final Reader in = input ) { return new MavenToolchainsXpp3Reader().read( in, isStrict( options ) );",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Collections.singletonList(a2), thing.getActions()); assertEquals(Collections.singletonList(a2), thing.getActions()); assertEquals(Collections.singletonList(a2), thing.getActions());",
        "ins1DelCode":"assertEquals(Arrays.asList(a2), thing.getActions()); assertEquals(Arrays.asList(a2), thing.getActions()); assertEquals(Arrays.asList(a2), thing.getActions());",
        "ins1PreCode":"thing.addAction(a2); assertEquals(Arrays.asList(a1, a2), thing.getActions()); assertThat(thing.removeAction(a1), is(true)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeAction(a1), is(false)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeAction(null), is(false)); assertEquals(Arrays.asList(a2), thing.getActions());",
        "ins2PreCode":"thing.addAction(a2); assertEquals(Arrays.asList(a1, a2), thing.getActions()); assertThat(thing.removeActions(CauseAction.class), is(true)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeActions(CauseAction.class), is(false)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeActions(CauseAction.class), is(false)); assertEquals(Arrays.asList(a2), thing.getActions());",
        "label":0
    },
    {
        "ins1AddCode":"request.addHeader(\"x-forwarded-for\", \"140.211.11.130\"); request.addHeader(\"x-forwarded-for\", \"proxy1\"); request.addHeader(\"x-forwarded-for\", \"proxy2\");",
        "ins1DelCode":"request.setHeader(\"x-forwarded-for\", \"140.211.11.130, proxy1, proxy2\");",
        "ins1PreCode":"MockHttpServletRequest request = new MockHttpServletRequest(); request.setRemoteAddr(\"192.168.0.10\"); request.setRemoteHost(\"remote-host-original-value\"); request.setHeader(\"x-forwarded-for\", \"140.211.11.130, proxy1, proxy2\");  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.contextRunner.run(withWebTestClient((client) -> client.options() .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\")));",
        "ins1DelCode":"load(TestEndpointConfiguration.class, (client) -> client.options() .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "ins1PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class, (client) -> client.options() .uri(\"/cfApplication/test\").accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus().isOk() .expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "ins2PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class, .accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus() .expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "label":0
    },
    {
        "ins1AddCode":"label_17: break label_17;",
        "ins1DelCode":"label_16: break label_16;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[43] = jj_gen; break label_16; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: MapEntry(); label_17: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[45] = jj_gen; break label_17; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"if (s.endsWith(\".xmi\") || s.endsWith(\".uml\")",
        "ins1DelCode":"if (s.endsWith(\".xmi\") || s.endsWith(\".xml\")",
        "ins1PreCode":"} } else { String s = curFile.getName().toLowerCase(); if (s.endsWith(\".xmi\") || s.endsWith(\".xml\") || s.endsWith(\".xmi.zip\") || s.endsWith(\".xml.zip\")) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> p1 = new XYPlot<>(); XYPlot<String> p2 = new XYPlot<>();",
        "ins1DelCode":"XYPlot p1 = new XYPlot(); XYPlot p2 = new XYPlot();",
        "ins1PreCode":"public void testEquals_ObjectList4() { XYPlot p1 = new XYPlot(); p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); XYPlot p2 = new XYPlot(); p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); assertEquals(p1, p2);",
        "ins2PreCode":"public void testEquals_ObjectList2() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); assertEquals(p1, p2);",
        "label":0
    },
    {
        "ins1AddCode":"ArrayValuesSourceAggregationBuilder<?> other = (ArrayValuesSourceAggregationBuilder<?>) obj; && Objects.equals(userValueTypeHint, other.userValueTypeHint);",
        "ins1DelCode":"ArrayValuesSourceAggregationBuilder<?, ?> other = (ArrayValuesSourceAggregationBuilder<?, ?>) obj; && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(valueType, other.valueType) && Objects.equals(valuesSourceType, other.valuesSourceType);",
        "ins1PreCode":"if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ArrayValuesSourceAggregationBuilder<?, ?> other = (ArrayValuesSourceAggregationBuilder<?, ?>) obj; return Objects.equals(fields, other.fields) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(valueType, other.valueType) && Objects.equals(valuesSourceType, other.valuesSourceType);",
        "ins2PreCode":"if (this == obj) return true; if (obj == null || getClass() != obj.getClass()) return false; if (super.equals(obj) == false) return false; ValuesSourceAggregationBuilder<?, ?> other = (ValuesSourceAggregationBuilder<?, ?>) obj; && Objects.equals(field, other.field) && Objects.equals(format, other.format) && Objects.equals(missing, other.missing) && Objects.equals(targetValueType, other.targetValueType) && Objects.equals(valueType, other.valueType); return Objects.equals(valuesSourceType, other.valuesSourceType)",
        "label":0
    },
    {
        "ins1AddCode":"assertFalse(\"should not have had prop.beta\", s.contains(\"prop.beta\")); assertFalse(\"should not have had prop.beta's comment\", s.contains(\"! more comment\"));",
        "ins1DelCode":"assertTrue(\"should not have had prop.beta\", !s.contains(\"prop.beta\")); assertTrue(\"should not have had prop.beta's comment\", !s.contains(\"! more comment\"));",
        "ins1PreCode":" String s = readFile(tmp);  assertTrue(\"should not have had prop.beta\", !s.contains(\"prop.beta\")); assertTrue(\"should not have had prop.beta's comment\", !s.contains(\"! more comment\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"exporter.export(databaseContext, tempFile, charset, entries); assertEquals( String.join(\"\\n\", Files.readAllLines(xmlFile)), String.join(\"\\n\", Files.readAllLines(tempFile)));",
        "ins1DelCode":"Path tempFilename = tempFile.toAbsolutePath(); modsExportFormat.export(databaseContext, tempFile, charset, entries); Builder control = Input.from(Files.newInputStream(xmlFile)); Builder test = Input.from(Files.newInputStream(tempFilename)); assertThat(test, CompareMatcher.isSimilarTo(control) .withNodeMatcher(new DefaultNodeMatcher(ElementSelectors.byNameAndText)).throwComparisonFailure());",
        "ins1PreCode":"public final void testPerformExport(String filename) throws Exception { importFile = Paths.get(ModsExportFormatTestFiles.class.getResource(filename).toURI()); String xmlFileName = filename.replace(\".bib\", \".xml\"); Path tempFilename = tempFile.toAbsolutePath(); List<BibEntry> entries = bibtexImporter.importDatabase(importFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI());  modsExportFormat.export(databaseContext, tempFile, charset, entries);  Builder control = Input.from(Files.newInputStream(xmlFile)); Builder test = Input.from(Files.newInputStream(tempFilename)); assertThat(test, CompareMatcher.isSimilarTo(control) .withNodeMatcher(new DefaultNodeMatcher(ElementSelectors.byNameAndText)).throwComparisonFailure());",
        "ins2PreCode":"public final void testImportAsModsAndExportAsMods(String filename) throws Exception { importFile = Paths.get(ModsExportFormatTestFiles.class.getResource(filename).toURI()); String xmlFileName = filename.replace(\".bib\", \".xml\"); Path tempFilename = tempFile.toAbsolutePath(); List<BibEntry> entries = modsImporter.importDatabase(xmlFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI()); modsExportFormat.export(databaseContext, tempFile, charset, entries); Builder control = Input.from(Files.newInputStream(xmlFile)); Builder test = Input.from(Files.newInputStream(tempFilename)); assertThat(test, CompareMatcher.isSimilarTo(control) .withNodeMatcher(new DefaultNodeMatcher(ElementSelectors.byNameAndText)).throwComparisonFailure());",
        "label":1
    },
    {
        "ins1AddCode":"void testNotNullColumnWithChildrenNoFid() {",
        "ins1DelCode":"public void testNotNullColumnWithChildrenNoFid() {",
        "ins1PreCode":"public void testNotNullColumnWithChildrenNoFid() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);",
        "ins2PreCode":"public void testNotNullColumnWithoutChildrenNoFid() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { FatherMapper fatherMapper = sqlSession.getMapper(FatherMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"Maybe.zip(new CrashingMappedIterable<>(100, 20, 100, new Function<Integer, Maybe<Integer>>() {",
        "ins1DelCode":"Maybe.zip(new CrashingMappedIterable<Maybe<Integer>>(100, 20, 100, new Function<Integer, Maybe<Integer>>() {",
        "ins1PreCode":"public void hasNextThrows() { Maybe.zip(new CrashingMappedIterable<Maybe<Integer>>(100, 20, 100, new Function<Integer, Maybe<Integer>>() { @Override public Maybe<Integer> apply(Integer v) throws Exception {",
        "ins2PreCode":"public void nextThrows() { Maybe.zip(new CrashingMappedIterable<Maybe<Integer>>(100, 100, 5, new Function<Integer, Maybe<Integer>>() { @Override public Maybe<Integer> apply(Integer v) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1DelCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(paddedBytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1PreCode":"byte[] strBytes = String.valueOf(i).getBytes(StandardCharsets.UTF_8); byte[] paddedBytes = new byte[byteArrSize]; System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(paddedBytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 35; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 34; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ)",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsSpace() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1, ,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1, ,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2, \"); assertThat(result, failedWith(3));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertNotMatchValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>(); oi.subscribe(subscriber); ",
        "ins2PreCode":"public void assertNeverAtNotMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1AddCode":"ApplicationConfigurationProperties applicationProperties = endpoint ConfigurationPropertiesBeanDescriptor foo = applicationProperties .getContexts().get(context.getId()).getBeans().get(\"foo\");",
        "ins1DelCode":"ConfigurationPropertiesDescriptor properties = endpoint ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\");",
        "ins1PreCode":"contextRunner.run((context) -> { ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull(); assertThat(foo.getPrefix()).isEqualTo(\"foo\");",
        "ins2PreCode":"contextRunner.run((context) -> { ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull(); assertThat(foo.getPrefix()).isEqualTo(\"foo\");",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testAdderAsSelectDoubleCallAnnotated1() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3);  SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  spMapper.adderAsSelectAnnotated(parameter); assertEquals((Integer) 5, parameter.getSum());  parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); spMapper.adderAsSelectAnnotated(parameter); assertEquals((Integer) 5, parameter.getSum());  } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testAdderAsSelectDoubleCallAnnotated2() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); SPMapper spMapper = sqlSession.getMapper(SPMapper.class); spMapper.adderAsSelectAnnotated(parameter); assertEquals((Integer) 5, parameter.getSum()); parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); spMapper.adderAsSelectAnnotated(parameter); assertEquals((Integer) 5, parameter.getSum()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"DefaultBoxAndWhiskerXYDataset<String> d1 = new DefaultBoxAndWhiskerXYDataset<>(\"Series\"); DefaultBoxAndWhiskerXYDataset<String> d2 = new DefaultBoxAndWhiskerXYDataset<>(\"Series\");",
        "ins1DelCode":"DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); DefaultBoxAndWhiskerXYDataset d2 = new DefaultBoxAndWhiskerXYDataset( \"Series\");",
        "ins1PreCode":"public void testEquals() { DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); DefaultBoxAndWhiskerXYDataset d2 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); assertTrue(d1.equals(d2)); ",
        "ins2PreCode":"public void testSerialization() { DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); assertFalse(d1.equals(d2));",
        "label":1
    },
    {
        "ins1AddCode":"BufferedReader reader = new BufferedReader(new InputStreamReader(is, StandardCharsets.UTF_8)); Writer writer = new OutputStreamWriter(os, StandardCharsets.UTF_8);",
        "ins1DelCode":"BufferedReader reader = new BufferedReader(new InputStreamReader(is)); Writer writer = new OutputStreamWriter(os);",
        "ins1PreCode":"throw new IllegalArgumentException(ioe); }  BufferedReader reader = new BufferedReader(new InputStreamReader(is)); Writer writer = new OutputStreamWriter(os);  this.writer = writer;",
        "ins2PreCode":"throw new IllegalArgumentException(ioe); } BufferedReader reader = new BufferedReader(new InputStreamReader(is)); Writer writer = new OutputStreamWriter(os); this.writer = writer;",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(names).containsExactlyInAnyOrder(\"simple\", \"additional\", \"ping\", \"reactive\");",
        "ins1DelCode":"assertThat(names).containsExactlyInAnyOrder(\"simple\", \"additional\", \"ping\");",
        "ins1PreCode":"this.contextRunner.run((context) -> { HealthContributorRegistry registry = context.getBean(HealthContributorRegistry.class); Object[] names = registry.stream().map(NamedContributor::getName).toArray(); assertThat(names).containsExactlyInAnyOrder(\"simple\", \"additional\", \"ping\"); });",
        "ins2PreCode":"this.reactiveContextRunner.run((context) -> { ReactiveHealthContributorRegistry registry = context.getBean(ReactiveHealthContributorRegistry.class); Object[] names = registry.stream().map(NamedContributor::getName).toArray(); assertThat(names).containsExactlyInAnyOrder(\"simple\", \"additional\", \"reactive\", \"ping\"); });",
        "label":0
    },
    {
        "ins1AddCode":"ScatterRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"ScatterRenderer r2 = (ScatterRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { ScatterRenderer r1 = new ScatterRenderer(); ScatterRenderer r2 = (ScatterRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (buffers.size() == 1) { return buffers.get(0); } else { CompositeByteBuf composite = Unpooled.compositeBuffer(buffers.size()); composite.addComponents(true, buffers); return composite; }",
        "ins1DelCode":"final CompositeByteBuf composite = Unpooled.compositeBuffer(buffers.size()); composite.addComponents(true, buffers); return composite;",
        "ins1PreCode":"while ((slice = iterator.next()) != null) { buffers.add(Unpooled.wrappedBuffer(slice.bytes, slice.offset, slice.length)); } final CompositeByteBuf composite = Unpooled.compositeBuffer(buffers.size()); composite.addComponents(true, buffers); return composite;",
        "ins2PreCode":"while ((slice = iterator.next()) != null) { buffers.add(Unpooled.wrappedBuffer(slice.bytes, slice.offset, slice.length)); } final CompositeByteBuf composite = Unpooled.compositeBuffer(buffers.size()); composite.addComponents(true, buffers); return composite;",
        "label":1
    },
    {
        "ins1AddCode":"int port = getPort();",
        "ins1DelCode":"int port = getPort();",
        "ins1PreCode":"public void testStartStopBindOnStart() throws Exception { Tomcat tomcat = getTomcatInstance(); Connector c = tomcat.getConnector(); c.setProperty(\"bindOnInit\", \"false\");  File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());  int port = getPort();  tomcat.start();  tomcat.getConnector().stop(); Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\"); try {  if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) {  } } assertNull(e); tomcat.getConnector().start();",
        "ins2PreCode":"public void testStartStopBindOnInit() throws Exception { Tomcat tomcat = getTomcatInstance(); tomcat.getConnector().stop(); public void testStartStopBindOnInit() throws Exception { File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath()); int port = getPort(); tomcat.start(); tomcat.getConnector().stop(); Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\"); try { if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) {  } } assertNotNull(e); tomcat.getConnector().start();",
        "label":1
    },
    {
        "ins1AddCode":"builder.putInt32ToEnumFieldValue(1, -1); assertEquals(-1, builder.getInt32ToEnumFieldValueOrThrow(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, builder.getInt32ToEnumFieldOrThrow(1));",
        "ins1DelCode":"try { builder.putInt32ToEnumFieldValue(1, -1); fail(); } catch (IllegalArgumentException e) { }",
        "ins1PreCode":"try { builder.putInt32ToEnumFieldValue(1, -1); fail(); } catch (IllegalArgumentException e) {  }",
        "ins2PreCode":"try { builder.putInt32ToEnumField(1, null); fail(); } catch (NullPointerException e) { }",
        "label":0
    },
    {
        "ins1AddCode":"private void initialize(Rectangle bounds) { getStereotypeFig().setKeyword(\"interface\"); getStereotypeFig().setVisible(true); getNameFig().setTopMargin( getStereotypeFig().getMinimumSize().height); addFig(getNameFig()); addFig(getBorderFig()); if (bounds != null) { setLocation(bounds.x, bounds.y); } setBounds(getBounds());",
        "ins1DelCode":"private void initialize() { getStereotypeFig().setKeyword(\"interface\"); Dimension size = new Dimension(0, 0); addChildDimensions(size, getStereotypeFig()); addFig(getNameFig()); addChildDimensions(size, getNameFig()); addChildDimensions(size, getOperationsFig()); addFig(borderFig); setBounds(X0, Y0, size.width, size.height);",
        "ins1PreCode":"private void initialize() { getStereotypeFig().setKeyword(\"interface\");    enableSizeChecking(false); setSuppressCalcBounds(true);  Dimension size = new Dimension(0, 0);  addFig(getBigPort()); addFig(getStereotypeFig()); addChildDimensions(size, getStereotypeFig()); addFig(getNameFig()); addChildDimensions(size, getNameFig()); addFig(getOperationsFig()); addChildDimensions(size, getOperationsFig()); addFig(borderFig);  setSuppressCalcBounds(false);   enableSizeChecking(true); setBounds(X0, Y0, size.width, size.height);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (oldValue == getSelectedItem()) { }",
        "ins1DelCode":"if (oldValue == getSelectedItem())",
        "ins1PreCode":"   if (oldValue == getSelectedItem()) getEditor().setItem(getSelectedItem()); }",
        "ins2PreCode":"if (oldValue == getSelectedItem()) getEditor().setItem(getSelectedItem()); }",
        "label":1
    },
    {
        "ins1AddCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop());",
        "ins1DelCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop());",
        "ins1PreCode":"public void testBuildMissingField() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>(); config.put(\"patterns\", Collections.singletonList(\"(?<foo>\\\\w+)\"));",
        "ins2PreCode":"public void testBuildMissingPatterns() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"foo\");",
        "label":1
    },
    {
        "ins1AddCode":"FieldFormatterCleanup cleanup = new FieldFormatterCleanup(InternalField.INTERNAL_ALL_TEXT_FIELDS_FIELD, new UnicodeToLatexFormatter()); entry.setField(InternalField.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); assertEquals(\"Fran\u00e7ois-Marie Arouet\", entry.getField(InternalField.KEY_FIELD).get());",
        "ins1DelCode":"FieldFormatterCleanup cleanup = new FieldFormatterCleanup(FieldName.INTERNAL_ALL_TEXT_FIELDS_FIELD, new UnicodeToLatexFormatter()); entry.setField(BibEntry.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); assertEquals(\"Fran\u00e7ois-Marie Arouet\", entry.getField(BibEntry.KEY_FIELD).get());",
        "ins1PreCode":"public void testCleanupAllTextFieldsIgnoresKeyField() throws Exception { FieldFormatterCleanup cleanup = new FieldFormatterCleanup(FieldName.INTERNAL_ALL_TEXT_FIELDS_FIELD, new UnicodeToLatexFormatter()); entry.setField(BibEntry.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); cleanup.cleanup(entry);  assertEquals(\"Fran\u00e7ois-Marie Arouet\", entry.getField(BibEntry.KEY_FIELD).get());",
        "ins2PreCode":"public void testCleanupKeyFieldCleansUpKeyField() throws Exception { FieldFormatterCleanup cleanup = new FieldFormatterCleanup(BibEntry.KEY_FIELD, new UnicodeToLatexFormatter()); entry.setField(BibEntry.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); cleanup.cleanup(entry); assertEquals(\"Fran{\\\\c{c}}ois-Marie Arouet\", entry.getField(BibEntry.KEY_FIELD).get());",
        "label":0
    },
    {
        "ins1AddCode":"Processor processor = new ConvertProcessor(randomAlphaOfLength(10), null, \"field\", \"field\", Type.AUTO, false);",
        "ins1DelCode":"Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false);",
        "ins1PreCode":"String booleanString = Boolean.toString(randomBoolean); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", booleanString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument); Object convertedValue = ingestDocument.getFieldValue(\"field\", Object.class);",
        "ins2PreCode":"String randomString = Integer.toString(randomInt); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument); Object convertedValue = ingestDocument.getFieldValue(\"field\", Object.class);",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"public final <R> Observable<R> switchMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":1
    },
    {
        "ins1AddCode":"FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<>(subscriber);",
        "ins1DelCode":"FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber);",
        "ins1PreCode":".unsafeCreate(so) .retry(retry5);  FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber);  f.subscribe(async);",
        "ins2PreCode":".unsafeCreate(so) .retry(retry5); ObservableRetryTest.AsyncObserver<Long> async = new ObservableRetryTest.AsyncObserver<Long>(observer); o.subscribe(async);",
        "label":1
    },
    {
        "ins1AddCode":"if (parameterMapping.typeHandler == null && parameterMapping.javaType != null) { Configuration configuration = parameterMapping.configuration; TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); parameterMapping.typeHandler = typeHandlerRegistry.getTypeHandler(parameterMapping.javaType, parameterMapping.jdbcType);",
        "ins1DelCode":"if (parameterMapping.typeHandler == null) { if (parameterMapping.javaType != null) { Configuration configuration = parameterMapping.configuration; TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); parameterMapping.typeHandler = typeHandlerRegistry.getTypeHandler(parameterMapping.javaType, parameterMapping.jdbcType); }",
        "ins1PreCode":"private void resolveTypeHandler() { if (parameterMapping.typeHandler == null) { if (parameterMapping.javaType != null) { Configuration configuration = parameterMapping.configuration; TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();",
        "ins2PreCode":"private void resolveTypeHandler() { if (resultMapping.typeHandler == null) { if (resultMapping.javaType != null) { Configuration configuration = resultMapping.configuration; TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();",
        "label":1
    },
    {
        "ins1AddCode":"Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses());",
        "ins1DelCode":"Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());",
        "ins1PreCode":" try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(fullTextFetchers)); }",
        "ins2PreCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(IdFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(idFetchers)); }",
        "label":0
    },
    {
        "ins1AddCode":"TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); expectedCrossingResult.addEntry(bibEntry);",
        "ins1DelCode":"TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); expectedCrossingResult.insertEntry(database, EINSTEIN_B); expectedCrossingResult.insertEntry(database, EINSTEIN_A); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.insertEntry(database, EINSTEIN_C); expectedCrossingResult.addUnresolvedKey(EINSTEIN_21); expectedCrossingResult.addUnresolvedKey(UNRESOLVED); expectedCrossingResult.increaseCrossRefsCount();",
        "ins1PreCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"crossref.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, EINSTEIN_B); expectedCrossingResult.insertEntry(database, EINSTEIN_A); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.insertEntry(database, EINSTEIN_C); expectedCrossingResult.addUnresolvedKey(EINSTEIN_21); expectedCrossingResult.addUnresolvedKey(UNRESOLVED); expectedCrossingResult.increaseCrossRefsCount();  assertEquals(expectedCrossingResult, crossingResult);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"String utf8Pass = \"123\u00a3\";",
        "ins1DelCode":"String utf8Pass = \"123\ufffd\";",
        "ins1PreCode":"SecurityCollection collection = new SecurityCollection(); collection.addPatternDecoded(\"/\"); String utf8User = \"test\"; String utf8Pass = \"123\ufffd\";  tomcat.addUser(utf8User, utf8Pass);",
        "ins2PreCode":"SecurityCollection collection = new SecurityCollection(); collection.addPatternDecoded(\"/*\"); ctx.addConstraint(sc); ctx.addConstraint(sc); tomcat.addUser(USER, PWD);",
        "label":0
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); subscriber.assertValue(1); subscriber.assertValueCount(2); subscriber.assertTerminated(); });",
        "ins1DelCode":"Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); thrown.expect(AssertionError.class); subscriber.assertValue(1); subscriber.assertValueCount(2); subscriber.assertTerminated();",
        "ins1PreCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber);  thrown.expect(AssertionError.class);  ",
        "ins2PreCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); thrown.expect(AssertionError.class);",
        "label":1
    },
    {
        "ins1AddCode":"void bindToCollectionWithNoDefaultConstructor() {",
        "ins1DelCode":"public void bindToCollectionWithNoDefaultConstructor() {",
        "ins1PreCode":"public void bindToCollectionWithNoDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.items\", \"a,b,c,c\");",
        "ins2PreCode":"public void bindToCollectionWithDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.items\", \"a,b,c,c\");",
        "label":1
    },
    {
        "ins1AddCode":"void commandLineWins() {",
        "ins1DelCode":"public void commandLineWins() {",
        "ins1PreCode":"public void commandLineWins() { this.environment.getPropertySources() .addFirst(new SimpleCommandLinePropertySource(\"--the.property=fromcommandline\"));",
        "ins2PreCode":"public void systemPropertyWins() { String property = this.environment.getProperty(\"the.property\"); System.setProperty(\"the.property\", \"fromsystem\");",
        "label":1
    },
    {
        "ins1AddCode":"try (OutputStream out = new BufferedOutputStream(new FileOutputStream(file))) {",
        "ins1DelCode":"OutputStream out = new BufferedOutputStream(new FileOutputStream(file)); try { finally { out.close(); }",
        "ins1PreCode":"BufferedImage.TYPE_INT_ARGB); Graphics2D g2 = image.createGraphics(); drawable.draw(g2, new Rectangle(w, h)); OutputStream out = new BufferedOutputStream(new FileOutputStream(file)); try { ImageIO.write(image, \"png\", out); } finally { out.close(); }",
        "ins2PreCode":"BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); drawable.draw(g2, new Rectangle(w, h)); OutputStream out = new BufferedOutputStream(new FileOutputStream(file)); try { ImageIO.write(image, \"jpg\", out); } finally { out.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"return minValue;",
        "ins1DelCode":"return new Double(minValue);",
        "ins1PreCode":"} } } return new Double(minValue);",
        "ins2PreCode":"} } } return new Double(maxValue);",
        "label":1
    },
    {
        "ins1AddCode":"ReplayObserver<T> u = new ReplayObserver<>(buf, current);",
        "ins1DelCode":"ReplayObserver<T> u = new ReplayObserver<>(buf);",
        "ins1PreCode":" ReplayBuffer<T> buf = bufferFactory.call();  ReplayObserver<T> u = new ReplayObserver<>(buf);  if (!current.compareAndSet(ps, u)) {",
        "ins2PreCode":"buf = bufferFactory.get(); ReplaySubscriber<T> u = new ReplaySubscriber<>(buf); if (!current.compareAndSet(ps, u)) {",
        "label":1
    },
    {
        "ins1AddCode":"assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1DelCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1PreCode":"public void testAlternateIncludeExclude() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\"));",
        "ins2PreCode":"public void testAlternateExcludeInclude() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\"));",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"@SuppressWarnings(\"unchecked\")",
        "ins1PreCode":"PublishProcessor<Integer> pp2 = PublishProcessor.create(); PublishProcessor<Integer> pp3 = PublishProcessor.create();  @SuppressWarnings(\"unchecked\") TestSubscriber<Integer> ts = Flowable.concatArrayEagerDelayError(2, 2, pp1, pp2, pp3) .test();",
        "ins2PreCode":"PublishProcessor<Integer> pp2 = PublishProcessor.create(); PublishProcessor<Integer> pp3 = PublishProcessor.create(); @SuppressWarnings(\"unchecked\") TestSubscriber<Integer> ts = Flowable.concatArrayEagerDelayError(2, 2, pp1, pp2, pp3) .test();",
        "label":1
    },
    {
        "ins1AddCode":"if ( src != null )",
        "ins1DelCode":"if ( source.getDependencyManagement() != null )",
        "ins1PreCode":"Map<Object, Object> context ) { DependencyManagement src = source.getDependencyManagement(); if ( source.getDependencyManagement() != null ) { DependencyManagement tgt = target.getDependencyManagement();",
        "ins2PreCode":"boolean sourceDominant, Map<Object, Object> context ) { PluginManagement src = source.getPluginManagement(); if ( source.getPluginManagement() != null ) { PluginManagement tgt = target.getPluginManagement();",
        "label":1
    },
    {
        "ins1AddCode":"expected.remove(ACMPortalFetcher.class); expected.remove(GoogleScholar.class);",
        "ins1DelCode":"",
        "ins1PreCode":" expected.remove(IdParserFetcher.class); assertEquals(expected, getClasses(idFetchers)); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"File localFile = FILE_UTILS.createTempFile(task.getProject(),",
        "ins1DelCode":"File localFile = FILE_UTILS.createTempFile(",
        "ins1PreCode":"FTPFile[] files = null; final int maxIterations = 1000; for (int counter = 1; counter < maxIterations; counter++) { File localFile = FILE_UTILS.createTempFile( \"ant\" + Integer.toString(counter), \".tmp\", null, false, false);",
        "ins2PreCode":"FTPFile[] files = null; final int maxIterations = 1000; for (int counter = 1; counter < maxIterations; counter++) { File localFile = FILE_UTILS.createTempFile( \"ant\" + Integer.toString(counter), \".tmp\", null, false, false);",
        "label":1
    },
    {
        "ins1AddCode":"List<Double> values = new ArrayList<>(); values.add(1.0); values.add(10.0); values.add(100.0);",
        "ins1DelCode":"List values = new ArrayList(); values.add(new Double(1.0)); values.add(new Double(10.0)); values.add(new Double(100.0));",
        "ins1PreCode":"return null; } }; List values = new ArrayList(); values.add(new Double(1.0)); values.add(new Double(10.0)); values.add(new Double(100.0)); dataset.add(values, \"row\", \"column\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"x\"),",
        "ins2PreCode":"return null; } }; List values = new ArrayList(); values.add(new Double(1.0)); values.add(new Double(10.0)); values.add(new Double(100.0)); dataset.add(values, \"row\", \"column\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"x\"),",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull R> Maybe<R> zip(",
        "ins1DelCode":"public static <T1, T2, T3, R> Maybe<R> zip(",
        "ins1PreCode":"public static <T1, T2, T3, R> Maybe<R> zip( @NonNull MaybeSource<? extends T1> source1, @NonNull MaybeSource<? extends T2> source2, @NonNull MaybeSource<? extends T3> source3, @NonNull Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper) {",
        "ins2PreCode":"public static <T1, T2, T3, R> Single<R> zip( @NonNull SingleSource<? extends T1> source1, @NonNull SingleSource<? extends T2> source2, @NonNull Function3<? super T1, ? super T2, ? super T3, ? extends R> zipper",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable d1 = Disposable.empty();",
        "ins1DelCode":"final Disposable d1 = Disposables.empty();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty();  cd.add(d1);",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final CompositeDisposable cd = new CompositeDisposable(); final Disposable d1 = Disposables.empty(); cd.add(d1);",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\"));",
        "ins1DelCode":"if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\"));",
        "ins1PreCode":"public void testFullpathDiffersInCaseScanningSensitive() { if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/beta/gamma/gamma.xml\",",
        "ins2PreCode":"public void testFullpathDiffersInCaseScanningInsensitive() { if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/beta/gamma/gamma.xml\",",
        "label":1
    },
    {
        "ins1AddCode":"entry.setCitationKey(\"test\");",
        "ins1DelCode":"entry.setCiteKey(\"test\");",
        "ins1PreCode":" BibEntry entry = new BibEntry(new UnknownEntryType(\"other\")); entry.setField(StandardField.COMMENT, \"testentry\"); entry.setCiteKey(\"test\");  ",
        "ins2PreCode":"BibEntry entry = new BibEntry(); entry.setField(StandardField.COMMENT, \"testentry\"); entry.setCiteKey(\"test\");",
        "label":1
    },
    {
        "ins1AddCode":"List<Cipher> clientRequestedCiphers = null; clientRequestedCiphers = extractor.getClientRequestedCiphers(); sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers);",
        "ins1DelCode":"sslEngine = endpoint.createSSLEngine(hostName);",
        "ins1PreCode":"log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); }  sslEngine = endpoint.createSSLEngine(hostName);  ",
        "ins2PreCode":"log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); } sslEngine = endpoint.createSSLEngine(hostName);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Object> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Object> to = new TestObserverEx<Object>();",
        "ins1PreCode":"public void errorInPredicate() { TestObserverEx<Object> to = new TestObserverEx<Object>(); to.onError(new RuntimeException()); try {",
        "ins2PreCode":"public void errorInPredicate() { TestObserver<Object> to = new TestObserver<Object>(); to.onError(new RuntimeException()); try {",
        "label":1
    },
    {
        "ins1AddCode":"SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<>();",
        "ins1DelCode":"SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<Integer>();",
        "ins1PreCode":"public void timedAndSizedTruncation() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<Integer>();  buf.next(1);",
        "ins2PreCode":"public void timedAndSizedTruncation() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false); List<Integer> values = new ArrayList<Integer>(); buf.next(1);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateStarShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateTShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper,",
        "ins1DelCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper,",
        "ins1PreCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins2PreCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "label":1
    },
    {
        "ins1AddCode":"RowFactory.create(0.0, \"Hi I heard about Spark\"), RowFactory.create(0.0, \"I wish Java could use case classes\"), RowFactory.create(1.0, \"Logistic regression models are neat\")",
        "ins1DelCode":"RowFactory.create(0, \"Hi I heard about Spark\"), RowFactory.create(0, \"I wish Java could use case classes\"), RowFactory.create(1, \"Logistic regression models are neat\")",
        "ins1PreCode":"  List<Row> data = Arrays.asList( RowFactory.create(0, \"Hi I heard about Spark\"), RowFactory.create(0, \"I wish Java could use case classes\"), RowFactory.create(1, \"Logistic regression models are neat\") ); StructType schema = new StructType(new StructField[]{",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DescribableList r = (DescribableList) context.getRequiredType().asSubclass(DescribableList.class).getDeclaredConstructor().newInstance(); } catch (NoSuchMethodException e) { NoSuchMethodError x = new NoSuchMethodError(); x.initCause(e); throw x; } catch (InvocationTargetException e) { Throwable t = e.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof IOException) { throw new UncheckedIOException((IOException) t); } else if (t instanceof Exception) { throw new RuntimeException(t); } else if (t instanceof Error) { throw (Error) t; } else { throw new Error(e); }",
        "ins1DelCode":"DescribableList r = (DescribableList) context.getRequiredType().asSubclass(DescribableList.class).newInstance();",
        "ins1PreCode":"public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) { try { DescribableList r = (DescribableList) context.getRequiredType().asSubclass(DescribableList.class).newInstance(); CopyOnWriteList core = copyOnWriteListConverter.unmarshal(reader, context); r.data.replaceBy(core);",
        "ins2PreCode":"public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) { try { PersistedList r = (PersistedList)context.getRequiredType().newInstance(); CopyOnWriteList core = copyOnWriteListConverter.unmarshal(reader, context); r.data.replaceBy(core);",
        "label":1
    },
    {
        "ins1AddCode":"void subClassExceptionError() throws Exception {",
        "ins1DelCode":"public void subClassExceptionError() throws Exception {",
        "ins1PreCode":"public void subClassExceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new TestFilterChain((request, response, chain) -> {",
        "ins2PreCode":"public void nestedServletExceptionIsUnwrapped() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new TestFilterChain((request, response, chain) -> {",
        "label":1
    },
    {
        "ins1AddCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = (String)o;\"));",
        "ins1DelCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((byte)0); String n = (String)o;\"));",
        "ins1PreCode":" expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = (String)o;\")); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"FileHandler fh1 = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, Integer.valueOf(2));",
        "ins1DelCode":"FileHandler fh1 = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, 2);",
        "ins1PreCode":"public void testCleanOnInitOneHandler() throws Exception { generateLogFiles(logsDir, PREFIX_1, SUFIX_1, 3);  FileHandler fh1 = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, 2);  Thread.sleep(1000);",
        "ins2PreCode":"public void testCleanDisabled() throws Exception { generateLogFiles(logsDir, PREFIX_1, SUFIX_1, 3); FileHandler fh1 = new FileHandler(logsDir.getAbsolutePath(), PREFIX_1, SUFIX_1, -1); Thread.sleep(1000);",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(e).hasMessageThat().contains(ERROR_SELF_LOOP);",
        "ins1DelCode":"assertThat(e.getMessage()).contains(ERROR_SELF_LOOP);",
        "ins1PreCode":"undirectedGraph.addEdge(N1, N1, E11); fail(ERROR_ADDED_SELF_LOOP); } catch (IllegalArgumentException e) { assertThat(e.getMessage()).contains(ERROR_SELF_LOOP); }",
        "ins2PreCode":"undirectedGraph.addEdge(N1, N1, E11); fail(ERROR_ADDED_SELF_LOOP); } catch (IllegalArgumentException e) { assertThat(e.getMessage()).contains(ERROR_SELF_LOOP); }",
        "label":1
    },
    {
        "ins1AddCode":"final int memory = (int) (maxContainerSupported.getMemorySize() + 10); ContainerRequestEvent mapRequestEvt = createRequest(jobId, 0, Resource.newInstance(memory, maxContainerSupported.getVirtualCores()),",
        "ins1DelCode":"ContainerRequestEvent mapRequestEvt = createReq(jobId, 0, (int) (maxContainerSupported.getMemorySize() + 10), maxContainerSupported.getVirtualCores(),",
        "ins1PreCode":"} };  ContainerRequestEvent mapRequestEvt = createReq(jobId, 0, (int) (maxContainerSupported.getMemorySize() + 10), maxContainerSupported.getVirtualCores(), new String[0], false, false); allocator.sendRequests(Arrays.asList(mapRequestEvt));",
        "ins2PreCode":"} }; ContainerRequestEvent reduceRequestEvt = createReq(jobId, 0, (int) (maxContainerSupported.getMemorySize() + 10), maxContainerSupported.getVirtualCores(), new String[0], false, true); allocator.sendRequests(Arrays.asList(reduceRequestEvt));",
        "label":1
    },
    {
        "ins1AddCode":"remover.transform(dataset).show(false);",
        "ins1DelCode":"remover.transform(dataset).show();",
        "ins1PreCode":"});  Dataset<Row> dataset = spark.createDataFrame(data, schema); remover.transform(dataset).show();  spark.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Object stereo = getTarget(); Set<Object> oldSet = new HashSet<Object>(getSelected()); Set toBeRemoved = new HashSet<Object>(oldSet); if (oldSet.contains(o)) { Model.getExtensionMechanismsHelper() .addBaseClass(stereo, o); Model.getExtensionMechanismsHelper().removeBaseClass(stereo, o);",
        "ins1DelCode":"Object state = getTarget(); assert (Model.getFacade().isAState(state)); Collection oldOnes = new ArrayList(Model.getFacade() .getDeferrableEvents(state)); Collection toBeRemoved = new ArrayList(oldOnes); if (oldOnes.contains(o)) { Model.getStateMachinesHelper().addDeferrableEvent(state, o); Model.getStateMachinesHelper().removeDeferrableEvent(state, o);",
        "ins1PreCode":"protected void doIt(Collection selected) { Object state = getTarget(); assert (Model.getFacade().isAState(state));  Collection oldOnes = new ArrayList(Model.getFacade() .getDeferrableEvents(state)); Collection toBeRemoved = new ArrayList(oldOnes); for (Object o : selected) { if (oldOnes.contains(o)) { toBeRemoved.remove(o); } else { Model.getStateMachinesHelper().addDeferrableEvent(state, o); } } for (Object o : toBeRemoved) { Model.getStateMachinesHelper().removeDeferrableEvent(state, o); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(input).hasBinaryContent(new byte[] { 3 });",
        "ins1DelCode":"assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 }));",
        "ins1PreCode":"URL url = new URL(\"jar:file:\" + getRelativePath() + \"!/space nested.jar!/3.dat\"); JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); } connection.getJarFile().close();",
        "ins2PreCode":"URL url = new URL(\"jar:file:\" + getRelativePath() + \"!/space%20nested.jar!/3.dat\"); JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); } connection.getJarFile().close();",
        "label":1
    },
    {
        "ins1AddCode":"return Long.valueOf(0);",
        "ins1DelCode":"return new Long(0);",
        "ins1PreCode":"public static final Number subtract(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return new Long(0); } ",
        "ins2PreCode":"public static final Number multiply(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return new Long(0); }",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 100; ++i) { String results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNull(results);",
        "ins1DelCode":"for(int i=0; i < 100;++i) { String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNotNull(results); assertEquals(0, results.length);",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNotNull(results); assertEquals(0, results.length); assertEquals(801, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(0, context.getBuffer().position());",
        "label":0
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.subplots, that.subplots)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.subplots, that.subplots)) {",
        "ins1PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false; }",
        "ins2PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); subscriber.assertValues(1, 2); subscriber.assertNever(2); subscriber.assertValueCount(2); subscriber.assertTerminated(); });",
        "ins1DelCode":"Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<>(); oi.subscribe(subscriber); subscriber.assertValues(1, 2); thrown.expect(AssertionError.class); subscriber.assertNever(2); subscriber.assertValueCount(2); subscriber.assertTerminated();",
        "ins1PreCode":" subscriber.assertValues(1, 2);  thrown.expect(AssertionError.class);  subscriber.assertNever(2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>();",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot();",
        "ins1PreCode":"public void testAddDomainMarker() { CategoryPlot plot = new CategoryPlot(); CategoryMarker m = new CategoryMarker(\"C1\"); plot.addDomainMarker(m);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue(\"There should be no unresolved items.\", resolver.unresolvedItems.isEmpty());",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals(3, checker.calls); assertTrue(\"All the items should have been resolved.\", checker.resolved.containsAll(items));",
        "ins2PreCode":"checker.resolved.containsAll(items)); assertTrue(\"All the items should have been resolved.\", checker.resolved.containsAll(items));",
        "label":1
    },
    {
        "ins1AddCode":"DateTickUnit unit = new DateTickUnit(DateTickUnitType.YEAR, 1); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault());",
        "ins1DelCode":"DateTickUnit unit = new DateTickUnit(DateTickUnit.YEAR, 1); Date nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd);",
        "ins1PreCode":" Date end = new Date(y2007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.YEAR, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "ins2PreCode":"Date end = new Date(y2007.getLastMillisecond()); DateTickUnit unit = new DateTickUnit(DateTickUnit.YEAR, 10); axis.setTickUnit(unit); axis.setTickMarkPosition(DateTickMarkPosition.START); axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime()); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime()); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.END); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "label":1
    },
    {
        "ins1AddCode":"origin.retry().subscribe(new TestSubscriber<>(subscriber));",
        "ins1DelCode":"origin.retry().subscribe(new TestSubscriber<String>(subscriber));",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber(); int numRetries = 20; Flowable<String> origin = Flowable.unsafeCreate(new FuncWithErrors(numRetries)); origin.retry().subscribe(new TestSubscriber<String>(subscriber));  InOrder inOrder = inOrder(subscriber);",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver(); int numRetries = 20; Observable<String> origin = Observable.unsafeCreate(new FuncWithErrors(numRetries)); origin.retry().subscribe(new TestObserver<String>(observer)); InOrder inOrder = inOrder(observer);",
        "label":1
    },
    {
        "ins1AddCode":"getTomcatInstanceTestWebapp(false, true);",
        "ins1DelCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start();",
        "ins1PreCode":"public void testBug49297NoSpaceNotStrict() throws Exception {  Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = new ByteChunk();",
        "ins2PreCode":"public void testBug49297MultipleImport1() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = new ByteChunk();",
        "label":1
    },
    {
        "ins1AddCode":"report.append(\"Please refer to the release notes or reference guide for potential alternatives.\");",
        "ins1DelCode":"report.append(\"Please refer to the migration guide or reference guide for potential alternatives.\");",
        "ins1PreCode":"\"%nThe use of configuration keys that are no longer supported was found in the environment:%n%n\")); append(report, content); report.append(String.format(\"%n\")); report.append(\"Please refer to the migration guide or reference guide for potential alternatives.\"); report.append(String.format(\"%n\")); return report.toString();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32);",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  QueueDrainHelper.checkTerminated(true, true, to, true, q, null, qd);",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty()); ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; } @Override public boolean done() { return false; } @Override public Throwable error() { return null; } @Override public boolean enter() { return true; } @Override public int leave(int m) { return 0; } @Override public void accept(Observer<? super Integer> a, Integer v) { } }; SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); QueueDrainHelper.checkTerminated(true, true, to, true, q, d, qd);",
        "label":1
    },
    {
        "ins1AddCode":"assertThatExceptionOfType(BindException.class) .isThrownBy(() -> this.binder.bind(\"example\", Bindable.of(Example.class), new IgnoreTopLevelConverterNotFoundBindHandler())) .withCauseInstanceOf(IllegalStateException.class);",
        "ins1DelCode":"this.thrown.expectCause(instanceOf(IllegalStateException.class)); this.binder.bind(\"example\", Bindable.of(Example.class), new IgnoreTopLevelConverterNotFoundBindHandler());",
        "ins1PreCode":"MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.foo\", \"1\"); this.sources.add(source); this.thrown.expectCause(instanceOf(IllegalStateException.class)); this.binder.bind(\"example\", Bindable.of(Example.class), new IgnoreTopLevelConverterNotFoundBindHandler());",
        "ins2PreCode":"MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.map\", \"hello\"); this.sources.add(source); this.thrown.expectCause(instanceOf(ConverterNotFoundException.class)); this.binder.bind(\"example\", Bindable.of(Example.class), new IgnoreTopLevelConverterNotFoundBindHandler());",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<String> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<String> to = new TestObserver<String>();",
        "ins1PreCode":"PublishSubject<String> ps3 = PublishSubject.create(); PublishSubject<String> main = PublishSubject.create();  TestObserver<String> to = new TestObserver<String>();  main.withLatestFrom(new Observable[] { ps1, ps2, ps3 }, toArray)",
        "ins2PreCode":"PublishSubject<String> ps3 = PublishSubject.create(); PublishSubject<String> main = PublishSubject.create(); TestObserver<String> to = new TestObserver<String>(); main.withLatestFrom(Arrays.<Observable<?>>asList(ps1, ps2, ps3), toArray)",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assumeFalse(\"windows deletion behavior is asinine\", Constants.WINDOWS);",
        "ins1PreCode":"public void testCountryBuildDefaults() throws Exception {   assumeFalse(\"windows deletion behavior is asinine\", Constants.WINDOWS); GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)); ",
        "ins2PreCode":"public void testAsnBuildDefaults() throws Exception { assumeFalse(\"windows deletion behavior is asinine\", Constants.WINDOWS); GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000));",
        "label":1
    },
    {
        "ins1AddCode":"TestMap.Builder builder = TestMap.newBuilder() .putInt32ToInt32Field(1, 2) .putInt32ToInt32Field(3, 4) .putInt32ToMessageField(11, MessageValue.newBuilder().setValue(22).build()) .putInt32ToMessageField(33, MessageValue.newBuilder().setValue(44).build());",
        "ins1DelCode":"TestMap.Builder builder = TestMap.newBuilder(); builder.getMutableInt32ToInt32Field().put(1, 2); builder.getMutableInt32ToInt32Field().put(3, 4); builder.getMutableInt32ToMessageField().put( 11, MessageValue.newBuilder().setValue(22).build()); builder.getMutableInt32ToMessageField().put( 33, MessageValue.newBuilder().setValue(44).build());",
        "ins1PreCode":"public void testReflectionApi() throws Exception {  TestMap.Builder builder = TestMap.newBuilder(); builder.getMutableInt32ToInt32Field().put(1, 2); builder.getMutableInt32ToInt32Field().put(3, 4); builder.getMutableInt32ToMessageField().put( 11, MessageValue.newBuilder().setValue(22).build()); builder.getMutableInt32ToMessageField().put( 33, MessageValue.newBuilder().setValue(44).build()); TestMap message = builder.build(); ",
        "ins2PreCode":"public void testReflectionApi() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); builder.getMutableInt32ToInt32Field().put(1, 2); builder.getMutableInt32ToInt32Field().put(3, 4); builder.getMutableInt32ToMessageField().put( 11, MessageValue.newBuilder().setValue(22).build()); builder.getMutableInt32ToMessageField().put( 33, MessageValue.newBuilder().setValue(44).build()); TestMap message = builder.build();",
        "label":1
    },
    {
        "ins1AddCode":"VectorSeries<String> s1 = new VectorSeries<>(\"Series\");",
        "ins1DelCode":"VectorSeries s1 = new VectorSeries(\"Series\");",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { VectorSeries s1 = new VectorSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); VectorSeriesCollection c1 = new VectorSeriesCollection();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) { } if (writeBlocking) { throw new SocketTimeoutException(); } } while (from.hasRemaining()); } finally { writeBlocking = false; }",
        "ins1DelCode":"int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { try { writeBlock = new CountDownLatch(1); if (timeout > 0) { if (!writeBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } else { writeBlock.await(); } catch (InterruptedException e) { throw new EOFException(); } finally { writeBlock = null; } } while (from.hasRemaining());",
        "ins1PreCode":"} if (n == 0) { try { writeBlock = new CountDownLatch(1); registerWriteInterest(); if (timeout > 0) { if (!writeBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { writeBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { writeBlock = null; } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Object> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Object> to = new TestObserverEx<Object>();",
        "ins1PreCode":"public void errorReceivedObservable() { TestObserverEx<Object> to = new TestObserverEx<Object>(); TestException ex = new TestException(\"boo\"); Observable.error(ex).ignoreElements().toObservable().subscribe(to);",
        "ins2PreCode":"public void errorReceived() { TestObserverEx<Object> to = new TestObserverEx<Object>(); TestException ex = new TestException(\"boo\"); Observable.error(ex).ignoreElements().subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"String xml = wc.goToXml(\"view/v/config.xml\").getWebResponse().getContentAsString();",
        "ins1DelCode":"String xml = wc.goToXml(\"view/v/config.xml\").getContent();",
        "ins1PreCode":"ListView view = listView(\"v\"); view.description = \"one\"; WebClient wc = j.createWebClient(); String xml = wc.goToXml(\"view/v/config.xml\").getContent(); assertTrue(xml, xml.contains(\"<description>one</description>\")); xml = xml.replace(\"<description>one</description>\", \"<description>two</description>\");",
        "ins2PreCode":"ListView view = listView(\"v\"); view.description = \"one\"; WebClient wc = j.createWebClient(); String xml = wc.goToXml(\"view/v/config.xml\").getWebResponse().getContentAsString(); assertThat(xml, containsString(\"<description>one</description>\")); xml = xml.replace(\"<description>one</description>\", \"\");",
        "label":0
    },
    {
        "ins1AddCode":"public E pollFirst(final long timeout, final TimeUnit unit)",
        "ins1DelCode":"public E pollFirst(long timeout, TimeUnit unit)",
        "ins1PreCode":"public E pollFirst(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout);",
        "ins2PreCode":"public E pollLast(long timeout, TimeUnit unit) throws InterruptedException { long nanos = unit.toNanos(timeout);",
        "label":1
    },
    {
        "ins1AddCode":"public void testPerformExportForSingleEditor(@TempDir Path testFolder) throws Exception {",
        "ins1DelCode":"public void testPerformExportForSingleEditor(@TempDirectory.TempDir Path testFolder) throws Exception {",
        "ins1PreCode":"public void testPerformExportForSingleEditor(@TempDirectory.TempDir Path testFolder) throws Exception { Path path = testFolder.resolve(\"ThisIsARandomlyNamedFile\"); File tmpFile = path.toFile();",
        "ins2PreCode":"public void testPerformExportForMultipleEditors(@TempDirectory.TempDir Path testFolder) throws Exception { Path path = testFolder.resolve(\"ThisIsARandomlyNamedFile\"); File tmpFile = path.toFile();",
        "label":1
    },
    {
        "ins1AddCode":"ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);",
        "ins1DelCode":"ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory();",
        "ins1PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory();  Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"final List<AbandonedTrace> resultSets = getTrace(); final ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]); for (final ResultSet element : set) {",
        "ins1DelCode":"List<AbandonedTrace> resultSets = getTrace(); ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]); for (ResultSet element : set) {",
        "ins1PreCode":"   List<AbandonedTrace> resultSets = getTrace(); if(resultSets != null) { ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]); for (ResultSet element : set) { element.close(); }",
        "ins2PreCode":"List<AbandonedTrace> resultSets = getTrace(); if( resultSets != null) { ResultSet[] set = resultSets.toArray(new ResultSet[resultSets.size()]); for (ResultSet element : set) { element.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"for (Integer otherNode : graph.nodes()) { boolean hasEdge = graph.hasEdge(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdge(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); }",
        "ins1PreCode":"assertThat(graph.inDegree(node)).isEqualTo(asGraph.inDegree(node)); assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node));  for (Integer otherNode : graph.nodes()) { boolean hasEdge = graph.hasEdge(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdge(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); } }",
        "ins2PreCode":"assertThat(graph.inDegree(node)).isEqualTo(asGraph.inDegree(node)); assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node)); for (Integer otherNode : graph.nodes()) { boolean hasEdge = graph.hasEdge(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdge(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); } }",
        "label":1
    },
    {
        "ins1AddCode":"t.onSubscribe(Disposable.empty());",
        "ins1DelCode":"t.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<Integer> firehose = Observable.unsafeCreate(new ObservableSource<Integer>() { @Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposables.empty()); for (int i = 0; i < m; i++) { t.onNext(i);",
        "ins2PreCode":"Observable<Integer> firehose = Observable.unsafeCreate(new ObservableSource<Integer>() { @Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposables.empty()); for (int i = 0; i < m; i++) { t.onNext(i);",
        "label":1
    },
    {
        "ins1AddCode":"Set<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences);",
        "ins1DelCode":"List<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences);",
        "ins1PreCode":"void getSearchBasedFetchersReturnsAllFetcherDerivingFromSearchBasedFetcher() throws Exception { List<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences); try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(SearchBasedFetcher.class.getCanonicalName());",
        "ins2PreCode":"void getFullTextFetchersReturnsAllFetcherDerivingFromFullTextFetcher() throws Exception { List<FulltextFetcher> fullTextFetchers = WebFetchers.getFullTextFetchers(importFormatPreferences); try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName());",
        "label":1
    },
    {
        "ins1AddCode":"super(actual, new MpscLinkedQueue<>());",
        "ins1DelCode":"super(actual, new MpscLinkedQueue<U>());",
        "ins1PreCode":"Supplier<U> bufferSupplier, long timespan, TimeUnit unit, int maxSize, boolean restartOnMaxSize, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan;",
        "ins2PreCode":"Supplier<U> bufferSupplier, long timespan, TimeUnit unit, int maxSize, boolean restartOnMaxSize, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan;",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable d = Disposable.empty();",
        "ins1DelCode":"final Disposable d = Disposables.empty();",
        "ins1PreCode":" @Override public void subscribe(final Observer<? super Observable<String>> observer) { final Disposable d = Disposables.empty(); observer.onSubscribe(d); parent.set(new Thread(new Runnable() {",
        "ins2PreCode":"@Override public void subscribe(final Subscriber<? super Flowable<String>> subscriber) { final Disposable d = Disposables.empty(); subscriber.onSubscribe(new Subscription() { parent.set(new Thread(new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"for (Object o : objects) { if (!elements.contains(o) && !(isClearable && (\"\".equals(o) || CLEARED.equals(o)))) { if (isClearable && !elements.contains(CLEARED)) { addElement(CLEARED); } \"elements to null collection\"); + \"elements to null collection\"); }",
        "ins1DelCode":"for (int i = 0; i < objects.size(); i++) { Object o = objects.get(i); if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { if (isClearable && !elements.contains(\"\")) { addElement(\"\"); } + \"elements to null collection\"); }",
        "ins1PreCode":"protected void setElements(Collection elements) { if (elements != null) { ArrayList toBeRemoved = new ArrayList(); for (int i = 0; i < objects.size(); i++) { Object o = objects.get(i); if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements);  if (!objects.contains(selectedObject)) { selectedObject = null; } if (isClearable && !elements.contains(\"\")) { addElement(\"\"); } } else {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, null, config);",
        "ins1DelCode":"JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", randomField); config.put(\"target_field\", randomTargetField); JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, config); assertThat(jsonProcessor.getTag(), equalTo(processorTag)); assertThat(jsonProcessor.getField(), equalTo(randomField));",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", randomField); config.put(\"field\", randomField); JsonProcessor jsonProcessor = FACTORY.create(null, processorTag, config); assertThat(jsonProcessor.getTag(), equalTo(processorTag)); assertThat(jsonProcessor.getField(), equalTo(randomField));",
        "label":1
    },
    {
        "ins1AddCode":"public void addSeries(S seriesKey, double[][] data) {",
        "ins1DelCode":"public void addSeries(Comparable seriesKey, double[][] data) {",
        "ins1PreCode":"public void addSeries(Comparable seriesKey, double[][] data) { if (seriesKey == null) { throw new IllegalArgumentException(",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() {",
        "ins1DelCode":"public void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() throws Exception {",
        "ins1PreCode":"public void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class,",
        "ins2PreCode":"public void containsDescendantOfWhenAnyIsPresentShouldReturnPresent() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class,",
        "label":1
    },
    {
        "ins1AddCode":"ErrorAttributeOptions.defaults());",
        "ins1DelCode":"false, false, false);",
        "ins1PreCode":"Exception error = new CustomException(); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, false, false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); assertThat(attributes.get(\"message\")).isEqualTo(\"\");",
        "ins2PreCode":"Exception error = new Custom2Exception(); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, true, false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); assertThat(attributes.get(\"message\")).isEqualTo(\"Nope!\");",
        "label":0
    },
    {
        "ins1AddCode":"while (windowStart < 0 windowStart++; while (windowStart < 0 windowStart++;",
        "ins1DelCode":"while (windowStart++ < 0 while (windowStart++ < 0",
        "ins1PreCode":"StringBuffer sb = new StringBuffer(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart++ < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart++ < 0 || !sb.substring(windowStart).equals(s)) { while (Calendar.getInstance().before(endTime)",
        "ins2PreCode":"StringBuffer sb = new StringBuffer(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart++ < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart++ < 0 || !sb.substring(windowStart).equals(s)) { while (Calendar.getInstance().before(endTime)",
        "label":1
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"Peptidomics of the larval {\\\\protect{{D}rosophila melanogaster}} central nervous system.\");",
        "ins1DelCode":"entry.setField(\"title\", \"Peptidomics of the larval {\\\\protect{{D}rosophila melanogaster}} central nervous system.\");",
        "ins1PreCode":"Path tmpFile = testFolder.resolve(\"testBraces\");  BibEntry entry = new BibEntry(); entry.setField(\"title\", \"Peptidomics of the larval {\\\\protect{{D}rosophila melanogaster}} central nervous system.\");  List<BibEntry> entries = Arrays.asList(entry);",
        "ins2PreCode":"Path tmpFile = testFolder.resolve(\"testBraces\"); BibEntry entry = new BibEntry(); entry.setField(\"title\", \"Insect neuropeptide bursicon homodimers induce innate immune and stress genes during molting by activating the {NF}-$\\\\kappa$B transcription factor Relish.\"); List<BibEntry> entries = Arrays.asList(entry);",
        "label":1
    },
    {
        "ins1AddCode":"FILE_UTILS.rename(newwasJarFile, websphereJarFile);",
        "ins1DelCode":"FileUtils.newFileUtils().rename(newwasJarFile, websphereJarFile);",
        "ins1PreCode":"}  try { FileUtils.newFileUtils().rename(newwasJarFile, websphereJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN);",
        "ins2PreCode":"} try { fileUtils.rename(newWLJarFile, weblogicJarFile); genericJar.close(); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN);",
        "label":0
    },
    {
        "ins1AddCode":"protected void start(PrintWriter writer, String name, StringManager smClient) { writer.println(smClient.getString( \"hostManagerServlet.invalidHostName\", name)); writer.println(smClient.getString( \"hostManagerServlet.noHost\", name)); writer.println(smClient.getString( \"hostManagerServlet.cannotStartOwnHost\", name)); writer.println(smClient.getString( \"hostManagerServlet.alreadyStarted\", name)); writer.println(smClient.getString( \"hostManagerServlet.started\", name)); writer.println(smClient.getString( \"hostManagerServlet.startFailed\", name)); writer.println(smClient.getString( \"hostManagerServlet.exception\", e.toString()));",
        "ins1DelCode":"protected void start(PrintWriter writer, String name) { writer.println(sm.getString(\"hostManagerServlet.invalidHostName\", name)); writer.println (sm.getString(\"hostManagerServlet.noHost\", name)); writer.println (sm.getString(\"hostManagerServlet.cannotStartOwnHost\", name)); writer.println (sm.getString(\"hostManagerServlet.alreadyStarted\", name)); writer.println (sm.getString(\"hostManagerServlet.started\", name)); writer.println (sm.getString(\"hostManagerServlet.startFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", e.toString()));",
        "ins1PreCode":"protected void start(PrintWriter writer, String name) {  if (debug >= 1) { log(sm.getString(\"hostManagerServlet.start\", name)); }   if ((name == null) || name.length() == 0) { writer.println(sm.getString(\"hostManagerServlet.invalidHostName\", name)); return; }  Container host = engine.findChild(name);   if (host == null) { writer.println (sm.getString(\"hostManagerServlet.noHost\", name)); return; }   if (host == installedHost) { writer.println (sm.getString(\"hostManagerServlet.cannotStartOwnHost\", name)); return; }   if (host.getState().isAvailable()) { writer.println (sm.getString(\"hostManagerServlet.alreadyStarted\", name)); return; }   try { host.start(); writer.println (sm.getString(\"hostManagerServlet.started\", name)); } catch (Exception e) { getServletContext().log (sm.getString(\"hostManagerServlet.startFailed\", name), e); writer.println (sm.getString(\"hostManagerServlet.startFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", e.toString())); return; }",
        "ins2PreCode":"protected void stop(PrintWriter writer, String name) { if (debug >= 1) { log(sm.getString(\"hostManagerServlet.stop\", name)); } if ((name == null) || name.length() == 0) { writer.println(sm.getString(\"hostManagerServlet.invalidHostName\", name)); return; } Container host = engine.findChild(name); if (host == null) { writer.println (sm.getString(\"hostManagerServlet.noHost\", name)); return; } if (host == installedHost) { writer.println (sm.getString(\"hostManagerServlet.cannotStopOwnHost\", name)); return; } if (!host.getState().isAvailable()) { writer.println (sm.getString(\"hostManagerServlet.alreadyStopped\", name)); return; } try { host.stop(); writer.println (sm.getString(\"hostManagerServlet.stopped\", name)); } catch (Exception e) { getServletContext().log (sm.getString(\"hostManagerServlet.stopFailed\", name), e); writer.println (sm.getString(\"hostManagerServlet.stopFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", e.toString())); return; }",
        "label":1
    },
    {
        "ins1AddCode":"public boolean removeFirstOccurrence(final Object o) {",
        "ins1DelCode":"public boolean removeFirstOccurrence(Object o) {",
        "ins1PreCode":"public boolean removeFirstOccurrence(Object o) { if (o == null) { return false;",
        "ins2PreCode":"public boolean removeLastOccurrence(Object o) { if (o == null) { return false;",
        "label":1
    },
    {
        "ins1AddCode":"TestUtils.serialised(d1);",
        "ins1DelCode":"TestUtilities.serialised(d1);",
        "ins1PreCode":"SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset( u1, 0, 5); SlidingGanttCategoryDataset d2 = (SlidingGanttCategoryDataset) TestUtilities.serialised(d1); assertEquals(d1, d2); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"int result = run(commandLine); throw new BuildException(\"Failed executing: \" + commandLine, getLocation());",
        "ins1DelCode":"int result = 0; result = run(commandLine); String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation());",
        "ins1PreCode":"public void execute() throws BuildException { Commandline commandLine = new Commandline(); Project aProj = getProject(); int result = 0;   if (getViewPath() == null) { setViewPath(aProj.getBaseDir().getPath()); }     commandLine.setExecutable(getClearToolCommand()); commandLine.createArgument().setValue(COMMAND_MKDIR);  checkOptions(commandLine);  if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getViewPathBasename(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "ins2PreCode":"public void execute() throws BuildException { Commandline commandLine = new Commandline(); Project aProj = getProject(); int result = 0; if (getViewPath() == null) { setViewPath(aProj.getBaseDir().getPath()); } commandLine.setExecutable(getClearToolCommand()); commandLine.createArgument().setValue(COMMAND_UNCHECKOUT); checkOptions(commandLine); if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getViewPathBasename(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Long>> aggregated = grouped.agg( aggregated.collectAsList());",
        "ins1DelCode":"Dataset<Tuple2<String, Long>> agged = grouped.agg( agged.collectAsList());",
        "ins1PreCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(value -> (long) value._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), agged.collectAsList());",
        "ins2PreCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(v -> (long)v._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), agged.collectAsList());",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { TestSubscriber<Object> ts = new TestSubscriber<>(); Flowable.empty().subscribe(ts); ts.assertValue(new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception { return false; } });",
        "ins1DelCode":"TestSubscriber<Object> ts = new TestSubscriber<>(); Flowable.empty().subscribe(ts); thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); ts.assertValue(new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception { return false; }",
        "ins1PreCode":" Flowable.empty().subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); ts.assertValue(new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception {",
        "ins2PreCode":"Flowable.empty().subscribe(ts); thrown.expect(AssertionError.class); thrown.expectMessage(\"No values\"); ts.assertValueAt(0, new Predicate<Object>() { @Override public boolean test(final Object o) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"if (e == null) { return null; }",
        "ins1DelCode":"",
        "ins1PreCode":"private Element getChild(String name, Element e) { NodeList children = e.getChildNodes();  int j = children.getLength();",
        "ins2PreCode":"private List<Element> getChildren(String name, Element e) { NodeList children = e.getChildNodes(); int j = children.getLength();",
        "label":0
    },
    {
        "ins1AddCode":"void builderCustomizers() {",
        "ins1DelCode":"public void builderCustomizers() {",
        "ins1PreCode":"public void builderCustomizers() { UndertowServletWebServerFactory factory = getFactory(); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4];",
        "ins2PreCode":"public void deploymentInfo() { UndertowServletWebServerFactory factory = getFactory(); UndertowDeploymentInfoCustomizer[] customizers = new UndertowDeploymentInfoCustomizer[4];",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final PublishProcessor<Integer> pp = PublishProcessor.create();  Disposable d = Disposables.empty();  final TestObserver<Integer> to = Single.using(Functions.justSupplier(d), new Function<Disposable, SingleSource<Integer>>() {",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final PublishProcessor<Integer> pp = PublishProcessor.create(); Disposable d = Disposables.empty(); final TestObserver<Integer> to = Single.using(Functions.justSupplier(d), new Function<Disposable, SingleSource<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"public Project makeEmptyProject(final boolean addDefaultDiagrams) { LOG.log(Level.INFO, \"making empty project\");",
        "ins1DelCode":"public Project makeEmptyProject(final boolean addDefaultDiagrams) { LOG.info(\"making empty project\");",
        "ins1PreCode":"Model.getPump().stopPumpingEvents();  creatingCurrentProject = true; LOG.info(\"making empty project\"); Project newProject = new ProjectImpl(); createDefaultModel(newProject);",
        "ins2PreCode":"Model.getPump().stopPumpingEvents(); creatingCurrentProject = true; LOG.info(\"making empty profile project\"); Project newProject = new ProjectImpl(Project.PROFILE_PROJECT); createDefaultProfile(newProject);",
        "label":1
    },
    {
        "ins1AddCode":"if (!isActive()) { return false; } if (!predicate(dm, dsgr)) { return false; }",
        "ins1DelCode":"if (!isActive()) return false; if (!predicate(dm, dsgr)) return false;",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders(); Object dm =  offs.get(0); if (!predicate(dm, dsgr)) return false; ListSet newOffs = computeOffenders(dm); boolean res = offs.equals(newOffs);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void loadGroovyResource() {",
        "ins1DelCode":"public void loadGroovyResource() {",
        "ins1PreCode":"public void loadGroovyResource() { ClassPathResource resource = new ClassPathResource(\"sample-beans.groovy\", getClass()); BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource);",
        "ins2PreCode":"public void loadGroovyResourceWithNamespace() { ClassPathResource resource = new ClassPathResource(\"sample-namespace.groovy\", getClass()); BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource);",
        "label":1
    },
    {
        "ins1AddCode":"Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);",
        "ins1DelCode":"Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class);",
        "ins1PreCode":"public static List<NodePropertyDescriptor> getNodePropertyDescriptors(Class<? extends Node> clazz) { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class); for (NodePropertyDescriptor npd : list) { if (npd.isApplicable(clazz)) {",
        "ins2PreCode":"public static List<NodePropertyDescriptor> getGlobalNodePropertyDescriptors() { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.getInstance().getDescriptorList(NodeProperty.class); for (NodePropertyDescriptor npd : list) { if (npd.isApplicableAsGlobal()) {",
        "label":1
    },
    {
        "ins1AddCode":"Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wasEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>(); for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); for (Enumeration<JarEntry> e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement(); JarEntry genericEntry = genericEntries.get(filepath); JarEntry wasEntry = wasEntries.get(filepath); Class<?> genclass = genericLoader.loadClass(classname); replaceEntries.put(filepath, genericEntry); for (Enumeration<JarEntry> e = wasEntries.elements(); e.hasMoreElements();) { JarEntry je = e.nextElement(); InputStream is; je = replaceEntries.get(je.getName()); byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; throw new BuildException( \"ClassNotFoundException while processing ejb-jar file. Details: \" \". Details: \" cnfe.getMessage(); + cnfe.getMessage(), cnfe); throw new BuildException( \"IOException while processing ejb-jar file . Details: \" \". Details: \" ioe.getMessage(); + ioe.getMessage(), ioe); @SuppressWarnings(\"resource\")",
        "ins1DelCode":"Hashtable genericEntries = new Hashtable(); Hashtable wasEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable(); for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement(); for (Enumeration e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement(); for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement(); JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wasEntry = (JarEntry) wasEntries.get(filepath); Class genclass = genericLoader.loadClass(classname); } else { replaceEntries.put(filepath, genericEntry); for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement(); je = (JarEntry) replaceEntries.get(je.getName()); String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage(); throw new BuildException(cnfmsg, cnfe); String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage(); throw new BuildException(msg, ioe);",
        "ins1PreCode":"genericJar = new JarFile(genericJarFile); wasJar = new JarFile(websphereJarFile);  Hashtable genericEntries = new Hashtable(); Hashtable wasEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable();   for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  wasEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wasEntries.containsKey(filepath)) {   JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);  if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; } break; } } } else {   log(\"File \" + filepath + \" not present in websphere jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newwasJarFile = new File(websphereJarFile.getAbsolutePath() + \".temp\"); if (newwasJarFile.exists()) { newwasJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newwasJarFile.toPath())); newJarStream.setLevel(0);   for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wasJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"websphere Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage();  throw new BuildException(msg, ioe); } finally { ",
        "ins2PreCode":"genericJar = new JarFile(genericJarFile); wlJar = new JarFile(weblogicJarFile); Hashtable genericEntries = new Hashtable(); Hashtable wlEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable(); for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); } for (Enumeration e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement(); wlEntries.put(je.getName(), je); } genericLoader = getClassLoaderFromJar(genericJarFile); for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement(); if (wlEntries.containsKey(filepath)) { JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wlEntry = (JarEntry) wlEntries.get(filepath); if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) { if (genericEntry.getName().endsWith(\".class\")) { String classname .replace(File.separatorChar, '.') classname = classname.substring(0, classname.lastIndexOf(\".class\")); Class genclass = genericLoader.loadClass(classname); if (genclass.isInterface()) { log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else { replaceEntries.put(filepath, genericEntry); } } else { if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) { log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; } break; } } } else { log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } } if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); } newJarStream = new JarOutputStream(Files.newOutputStream(newWLJarFile.toPath())); newJarStream.setLevel(0); for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement(); if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); } if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" Project.MSG_VERBOSE); je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else { is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName())); while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage(); throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage(); throw new BuildException(msg, ioe); } finally {",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\"));  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPostOrder('a'); assertEqualCharNodes(Iterables.limit(result, 2), \"db\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd'); assertEqualCharNodes(Iterables.limit(result, 2), \"db\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');",
        "label":0
    },
    {
        "ins1AddCode":"final TestSubscriberEx<String> subscriber = new TestSubscriberEx<>();",
        "ins1DelCode":"final TestSubscriberEx<String> subscriber = new TestSubscriberEx<String>();",
        "ins1PreCode":"final CountDownLatch exit = new CountDownLatch(1); final CountDownLatch timeoutSetuped = new CountDownLatch(1);  final TestSubscriberEx<String> subscriber = new TestSubscriberEx<String>();  new Thread(new Runnable() {",
        "ins2PreCode":"final CountDownLatch exit = new CountDownLatch(1); final CountDownLatch timeoutSetuped = new CountDownLatch(1); final TestObserverEx<String> observer = new TestObserverEx<String>(); new Thread(new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"void tomcatListeners() {",
        "ins1DelCode":"public void tomcatListeners() {",
        "ins1PreCode":"public void tomcatListeners() { TomcatServletWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4];",
        "ins2PreCode":"public void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] customizers = new TomcatContextCustomizer[4];",
        "label":1
    },
    {
        "ins1AddCode":"enterRule(_localctx, 64, RULE_mapinitializer); setState(509); switch ( getInterpreter().adaptivePredict(_input,50,_ctx) ) { setState(495); setState(496); setState(501); setState(497); setState(498); setState(503); setState(504); setState(506); setState(507); setState(508);",
        "ins1DelCode":"enterRule(_localctx, 54, RULE_mapinitializer); setState(448); switch ( getInterpreter().adaptivePredict(_input,42,_ctx) ) { setState(434); setState(435); setState(440); setState(436); setState(437); setState(442); setState(443); setState(445); setState(446); setState(447);",
        "ins1PreCode":"public final MapinitializerContext mapinitializer() throws RecognitionException { MapinitializerContext _localctx = new MapinitializerContext(_ctx, getState()); enterRule(_localctx, 54, RULE_mapinitializer); int _la; try { setState(448); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,42,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(434); match(LBRACE); setState(435); maptoken(); setState(440); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(436); match(COMMA); setState(437); maptoken(); } } setState(442); _errHandler.sync(this); _la = _input.LA(1); } setState(443); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(445); match(LBRACE); setState(446); match(COLON); setState(447); match(RBRACE); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"? includeNonPatterns.containsKey(path.toString()) : includeNonPatterns.containsKey(path.toString().toUpperCase())) {",
        "ins1DelCode":"? includeNonPatterns.contains(path.toString()) : includeNonPatterns.contains(path.toString().toUpperCase())) {",
        "ins1PreCode":"ensureNonPatternSetsReady();  if (isCaseSensitive() ? includeNonPatterns.contains(path.toString()) : includeNonPatterns.contains(path.toString().toUpperCase())) { return true; }",
        "ins2PreCode":"ensureNonPatternSetsReady(); if (isCaseSensitive() ? excludeNonPatterns.contains(name.toString()) : excludeNonPatterns.contains(name.toString().toUpperCase())) { return true; }",
        "label":1
    },
    {
        "ins1AddCode":"DocumentMapper mapper = createDocumentMapper(fieldMapping(this::minimalMapping)); assertEquals(Strings.toString(fieldMapping(this::minimalMapping)), mapper.mappingSource().toString()); ParsedDocument doc1 = mapper.parse(source(b -> b.field(\"field\", 10))); ParsedDocument doc2 = mapper.parse(source(b -> b.field(\"field\", 12)));",
        "ins1DelCode":"String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"rank_feature\").endObject().endObject() .endObject().endObject()); DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping)); assertEquals(mapping, mapper.mappingSource().toString()); ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON)); ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 12) .endObject()), XContentType.JSON));",
        "ins1PreCode":"public void testDefaults() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"rank_feature\").endObject().endObject() .endObject().endObject());  DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));  assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON));  IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0];  ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 12) .endObject()), XContentType.JSON));  FeatureField featureField2 = (FeatureField) doc2.rootDoc().getFields(\"_feature\")[0];",
        "ins2PreCode":"public void testNegativeScoreImpact() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"rank_feature\") .endObject().endObject()); DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping)); assertEquals(mapping, mapper.mappingSource().toString()); ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON)); IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0]; ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 12) .endObject()), XContentType.JSON)); FeatureField featureField2 = (FeatureField) doc2.rootDoc().getFields(\"_feature\")[0];",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);",
        "ins1PreCode":"public void checkTerminatedDelayErrorEmpty() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  QueueDrainHelper.checkTerminated(true, true, ts, true, q, qd);",
        "ins2PreCode":"public void checkTerminatedDelayErrorNonEmpty() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription()); QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; } @Override public boolean done() { return false; } @Override public Throwable error() { return null; } @Override public boolean enter() { return true; } @Override public long requested() { return 0; } @Override public long produced(long n) { return 0; } @Override public int leave(int m) { return 0; } @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } }; SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); QueueDrainHelper.checkTerminated(true, false, ts, true, q, qd);",
        "label":1
    },
    {
        "ins1AddCode":"data.setValue(\"Java\", 43.2); data.setValue(\"Visual Basic\", 0.0); data.setValue(\"C/C++\", 17.5);",
        "ins1DelCode":"data.setValue(\"Java\", new Double(43.2)); data.setValue(\"Visual Basic\", new Double(0.0)); data.setValue(\"C/C++\", new Double(17.5));",
        "ins1PreCode":"private static JFreeChart createPieChart() { DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", new Double(43.2)); data.setValue(\"Visual Basic\", new Double(0.0)); data.setValue(\"C/C++\", new Double(17.5)); return ChartFactory.createPieChart(\"Pie Chart\", data);",
        "ins2PreCode":"this.pieChart = ChartFactory.createPieChart(\"Pie Chart\", data); DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", new Double(43.2)); data.setValue(\"Visual Basic\", new Double(0.0)); data.setValue(\"C/C++\", new Double(17.5)); this.pieChart = ChartFactory.createPieChart(\"Pie Chart\", data);",
        "label":1
    },
    {
        "ins1AddCode":"AsyncProcessor<Integer> ap = new AsyncProcessor<>();",
        "ins1DelCode":"AsyncProcessor<Integer> ap = new AsyncProcessor<Integer>();",
        "ins1PreCode":"public void fusionOfflie() { AsyncProcessor<Integer> ap = new AsyncProcessor<Integer>(); ap.onNext(1); ap.onComplete();",
        "ins2PreCode":"public void fusionOfflie() { UnicastProcessor<Integer> ap = UnicastProcessor.create(); ap.onNext(1); ap.onComplete();",
        "label":0
    },
    {
        "ins1AddCode":"ctx.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false));",
        "ins1DelCode":"ctx.addApplicationListener(WsListener.class.getName());",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(WsListener.class.getName());  tomcat.start();",
        "ins2PreCode":"Tomcat.addServlet(ctx, \"default2\", new DefaultServlet()); ctx.addServletMapping(\"/servlets/*\", \"default2\"); ctx.addApplicationListener(WsListener.class.getName()); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"if (diaDefault.isShowVisibility() == showem) { diaDefault.setShowVisibility(showem); diaDefault.setShowVisibility(!showem); doUndoable(memento);",
        "ins1DelCode":"if (showVisibility == showem) { showVisibility = showem; showVisibility = !showem; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "ins1PreCode":"public void setShowVisibility(final boolean showem) { if (showVisibility == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_VISIBILITY;  public void redo() { showVisibility = showem; fireNotationEvent(key, !showem, showem); }  public void undo() { showVisibility = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "ins2PreCode":"public void setShowMultiplicity(final boolean showem) { if (showMultiplicity == showem) { return; } Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_MULTIPLICITY; public void redo() { showMultiplicity = showem; fireNotationEvent(key, !showem, showem); } public void undo() { showMultiplicity = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "label":1
    },
    {
        "ins1AddCode":".set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), useOffHeapMemoryAllocator()) .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 256 * 1024 * 1024L)",
        "ins1DelCode":".set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\")",
        "ins1PreCode":"memoryManager = new TestMemoryManager( new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\") .set(package$.MODULE$.SHUFFLE_SPILL_COMPRESS(), false) .set(package$.MODULE$.SHUFFLE_COMPRESS(), false));",
        "ins2PreCode":"serializerManager, serializerManager, anyInt(), File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); return Tuple2$.MODULE$.apply(blockId, file); return Tuple2$.MODULE$.apply(blockId, file);",
        "label":0
    },
    {
        "ins1AddCode":"void invalidJwtClaimsShouldThrowException() {",
        "ins1DelCode":"public void invalidJwtClaimsShouldThrowException() {",
        "ins1PreCode":"public void invalidJwtClaimsShouldThrowException() { String header = \"{\\\"alg\\\": \\\"RS256\\\", \\\"kid\\\": \\\"key-id\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"invalid-claims\";",
        "ins2PreCode":"public void invalidJwtHeaderShouldThrowException() { String header = \"invalid-header\"; String header = \"invalid-header\";",
        "label":1
    },
    {
        "ins1AddCode":"private void testTotalSizeCapProperty(String sizeValue, String expectedFileSize) { .toString()).isEqualTo(expectedFileSize);",
        "ins1DelCode":"private void testTotalSizeCapProperty(String sizeValue, String expectFileSize) { .toString()).isEqualTo(expectFileSize);",
        "ins1PreCode":"private void testTotalSizeCapProperty(String sizeValue, String expectFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext( environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\"); assertThat(ReflectionTestUtils.getField(getRollingPolicy(), \"totalSizeCap\") .toString()).isEqualTo(expectFileSize);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article(test,author={Ed von Test})\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void tryTerminateConsumerObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerMaybeObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"UnsafeUtil.putByte(buffer, pos++, (byte) value); UnsafeUtil.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80));",
        "ins1DelCode":"UNSAFE.putByte(buffer, pos++, (byte) value); UNSAFE.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80));",
        "ins1PreCode":"long pos = originalPos; while (true) { if ((value & ~0x7F) == 0) { UNSAFE.putByte(buffer, pos++, (byte) value); break; } else { UNSAFE.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertNotNull(e);",
        "ins1DelCode":"assertNotNull(e);",
        "ins1PreCode":"} catch (ELException ele) { e = ele; } assertNotNull(e);",
        "ins2PreCode":"} catch (ELException ele) { e = ele; } assertNotNull(e);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"1-4~#nov#\"), entry.getField(StandardField.DATE));",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(1, parsed.size()); assertEquals(Optional.of(\"escaped \\\\{ bracket\"), entry.getField(StandardField.REVIEW));",
        "label":1
    },
    {
        "ins1AddCode":"\"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,rc.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"JOIN SYS.ALL_CONSTRAINTS rc ON rc.OWNER=c.r_OWNER AND rc.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME \\n\" +",
        "ins1DelCode":"\"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,ref.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"JOIN SYS.ALL_CONSTRAINTS ref ON ref.OWNER=c.r_OWNER AND ref.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME \\n\" +",
        "ins1PreCode":"StringBuilder sql = new StringBuilder(500); sql.append( \"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" \\r\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,ref.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM SYS.ALL_CONSTRAINTS c\\n\" + \"JOIN SYS.ALL_CONS_COLUMNS col ON c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"JOIN SYS.ALL_CONSTRAINTS ref ON ref.OWNER=c.r_OWNER AND ref.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME \\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\"); if (forTable != null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".contextFactory(ApplicationContextFactory.forContextClass(SpyApplicationContext.class));",
        "ins1DelCode":".contextClass(SpyApplicationContext.class);",
        "ins1PreCode":"void parentContextCreationThatIsRunDirectly() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class) .contextClass(SpyApplicationContext.class); application.parent(ExampleConfig.class); this.context = application.run(\"foo.bar=baz\");",
        "ins2PreCode":"void parentContextCreationThatIsBuiltThenRun() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class) .contextClass(SpyApplicationContext.class); application.parent(ExampleConfig.class); this.context = application.build(\"a=alpha\").run(\"b=bravo\");",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<String> to = new TestObserver<>(observer);",
        "ins1DelCode":"TestObserver<String> to = new TestObserver<String>(observer);",
        "ins1PreCode":" Observer<String> observer = TestHelper.mockObserver();  TestObserver<String> to = new TestObserver<String>(observer); o.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); observable.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"when(metaJoinFieldType.getJoinField()).thenReturn(\"join_field\"); DocumentFieldMappers fieldMappers = new DocumentFieldMappers(Collections.singleton(joinFieldMapper), Collections.emptyList(), null, null, null); DocumentMapper mockMapper = mock(DocumentMapper.class); when(mockMapper.mappers()).thenReturn(fieldMappers); when(mapperService.documentMapper()).thenReturn(mockMapper);",
        "ins1DelCode":"when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper);",
        "ins1PreCode":"ParentJoinFieldMapper joinFieldMapper = createJoinFieldMapper(); MapperService mapperService = mock(MapperService.class); MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); return mapperService;",
        "ins2PreCode":"ParentJoinFieldMapper joinFieldMapper = createJoinFieldMapper(); MapperService mapperService = mock(MapperService.class); MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); return mapperService;",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, JarEntry> replaceEntries = new HashMap<>(); Map<String, JarEntry> genericEntries = genericJar.stream() .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b)); Map<String, JarEntry> wlEntries = wlJar.stream().collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b)); for (String filepath : genericEntries.keySet()) { if (!wlEntries.containsKey(filepath)) { log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath); if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) { if (genericEntry.getName().endsWith(\".class\")) { String classname = genericEntry.getName() classname = classname.substring(0, classname.lastIndexOf(\".class\")); Class<?> genclass = genericLoader.loadClass(classname); if (genclass.isInterface()) { \" has changed\", Project.MSG_VERBOSE); log(\"Interface \" + genclass.getName() replaceEntries.put(filepath, genericEntry); } else if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) { log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break;",
        "ins1DelCode":"Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>(); for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); } for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wlEntries.put(je.getName(), je); } for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement(); if (wlEntries.containsKey(filepath)) { JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath); if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) { if (genericEntry.getName().endsWith(\".class\")) { String classname = genericEntry.getName() classname = classname.substring(0, classname.lastIndexOf(\".class\")); Class<?> genclass = genericLoader.loadClass(classname); if (genclass.isInterface()) { log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) { log(\"Non class file \" + genericEntry.getName() } else { log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break;",
        "ins1PreCode":"genericJar = new JarFile(genericJarFile); wlJar = new JarFile(weblogicJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath);  if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) {  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public CategoryDataset<String, String> createDataset1() { DefaultCategoryDataset<String, String> result = new DefaultCategoryDataset<>();",
        "ins1DelCode":"public CategoryDataset createDataset1() { DefaultCategoryDataset result = new DefaultCategoryDataset();",
        "ins1PreCode":"public CategoryDataset createDataset1() {  DefaultCategoryDataset result = new DefaultCategoryDataset();  ",
        "ins2PreCode":"public CategoryDataset createDataset2() { DefaultCategoryDataset result = new DefaultCategoryDataset();",
        "label":1
    },
    {
        "ins1AddCode":"\"3-Header-[content-length]-[2]\\n\" +",
        "ins1DelCode":"",
        "ins1PreCode":"\"3-Header-[:status]-[200]\\n\" + \"3-Header-[x-ignore]-[...]\\n\" + \"3-Header-[content-type]-[text/plain;charset=UTF-8]\\n\" + \"3-Header-[date]-[Wed, 11 Nov 2015 19:18:42 GMT]\\n\" + \"3-HeadersEnd\\n\" + \"3-Body-2\\n\" +",
        "ins2PreCode":"\"3-Header-[:status]-[200]\\n\" + \"3-Header-[:status]-[200]\\n\" + \"3-Header-[content-type]-[text/plain;charset=UTF-8]\\n\" + \"3-Header-[date]-[Wed, 11 Nov 2015 19:18:42 GMT]\\n\" + \"3-HeadersEnd\\n\" + \"3-Body-8\\n\" +",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) ); assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) ); assertNull( updateCheckManager.readLastUpdated( touchFile, updateCheckManager.getRepositoryKey( remoteRepository ) ) );",
        "ins1DelCode":"assertTrue( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) ); assertFalse( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) ); assertNull( updateCheckManager.readLastUpdated( touchFile, remoteRepository.getId() ) );",
        "ins1PreCode":"File touchFile = updateCheckManager.getTouchfile( a ); touchFile.delete();  assertTrue( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) );  file.getParentFile().mkdirs(); file.createNewFile(); updateCheckManager.touch( a, remoteRepository );  assertFalse( updateCheckManager.isPomUpdateRequired( a, remoteRepository ) );  assertNull( updateCheckManager.readLastUpdated( touchFile, remoteRepository.getId() ) );  assertFalse( updateCheckManager.getTouchfile( a ).exists() );",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"}, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1DelCode":"}, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1PreCode":"public Flowable<Integer> apply(Integer v) { return null; } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);  ts.assertNoValues();",
        "ins2PreCode":"public Flowable<Integer> apply(Integer v) { return null; } }).subscribe(ts); ts.assertNoValues();",
        "label":0
    },
    {
        "ins1AddCode":"long offsetAndSize = getLong(ordinal); long offset = offsetAndSize >>> 32; int signum = ((int) (offsetAndSize & 0xfff) >> 8); assert signum >=0 && signum <= 2 : \"invalid signum \" + signum; int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; PlatformDependent.copyMemory(baseObject, baseOffset + offset, mag, PlatformDependent.INT_ARRAY_OFFSET, size * 4); BigInteger v = new BigInteger(0, EMPTY); PlatformDependent.UNSAFE.putInt(v, PlatformDependent.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); PlatformDependent.UNSAFE.putObjectVolatile(v, PlatformDependent.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale);",
        "ins1DelCode":"byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(new scala.math.BigDecimal(javaDecimal), precision, scale);",
        "ins1PreCode":"if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.apply(getLong(ordinal), precision, scale); } else { byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(new scala.math.BigDecimal(javaDecimal), precision, scale); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final String script = \"{{#toJson}}{{foo}}{{bar}}{{/toJson}}\"; ScriptException e = expectThrows(ScriptException.class, () -> compile(script)); assertEquals(MustacheScriptEngine.NAME, e.getLang()); assertEquals(script, e.getScript()); final String script2 = \"{{#toJson}}{{/toJson}}\"; e = expectThrows(ScriptException.class, () -> compile(script2)); assertEquals(MustacheScriptEngine.NAME, e.getLang()); assertEquals(script2, e.getScript());",
        "ins1DelCode":"MustacheException e = expectThrows(MustacheException.class, () -> compile(\"{{#toJson}}{{foo}}{{bar}}{{/toJson}}\")); e = expectThrows(MustacheException.class, () -> compile(\"{{#toJson}}{{/toJson}}\"));",
        "ins1PreCode":"public void testsUnsupportedTagsToJson() { MustacheException e = expectThrows(MustacheException.class, () -> compile(\"{{#toJson}}{{foo}}{{bar}}{{/toJson}}\")); assertThat(e.getMessage(), containsString(\"Mustache function [toJson] must contain one and only one identifier\"));  e = expectThrows(MustacheException.class, () -> compile(\"{{#toJson}}{{/toJson}}\")); assertThat(e.getMessage(), containsString(\"Mustache function [toJson] must contain one and only one identifier\"));",
        "ins2PreCode":"public void testsUnsupportedTagsJoin() { MustacheException e = expectThrows(MustacheException.class, () -> compile(\"{{#join}}{{/join}}\")); assertThat(e.getMessage(), containsString(\"Mustache function [join] must contain one and only one identifier\")); MustacheException e = expectThrows(MustacheException.class, () -> compile(\"{{#join}}{{/join}}\")); assertThat(e.getMessage(), containsString(\"Mustache function [join] must contain one and only one identifier\"));",
        "label":0
    },
    {
        "ins1AddCode":"void callbacksInvokeAndWhenNoGenericShouldReturnResult() {",
        "ins1DelCode":"public void callbacksInvokeAndWhenNoGenericShouldReturnResult() {",
        "ins1PreCode":"public void callbacksInvokeAndWhenNoGenericShouldReturnResult() { NonGenericFactory callbackInstance = mock(NonGenericFactory.class); String argument = \"foo\";",
        "ins2PreCode":"public void callbacksInvokeAndWhenHasGenericShouldReturnResult() { StringFactory callbackInstance = mock(StringFactory.class); String argument = \"foo\";",
        "label":1
    },
    {
        "ins1AddCode":"public void heap() throws IOException { new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null);",
        "ins1DelCode":"public void heap() { new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128);",
        "ins1PreCode":"public void heap() { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1, page1.getBaseOffset() + 42);",
        "ins2PreCode":"public void offHeap() { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1, page1.getBaseOffset() + 42);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); List<Flowable<Integer>> sourceList = new ArrayList<>(i); Set<Integer> expected = new HashSet<>(i); Set<Integer> actual = new HashSet<>(ts.values());",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); Set<Integer> actual = new HashSet<Integer>(ts.values());",
        "ins1PreCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(ts.values());  assertEquals(expected, actual);",
        "ins2PreCode":"public void simpleOneLessAsync() { for (int i = 2; i < 50; i++) { TestObserver<Integer> to = new TestObserver<Integer>(); List<Observable<Integer>> sourceList = new ArrayList<Observable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Observable.just(j).subscribeOn(Schedulers.io())); expected.add(j); } Observable.merge(sourceList, i - 1).subscribe(to); to.awaitDone(1, TimeUnit.SECONDS); to.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(to.values()); assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1AddCode":"channel1.addInterceptor(new MessageDispatchInterceptor()); channel2.addInterceptor(new MessageDispatchInterceptor());",
        "ins1DelCode":"channel1.addInterceptor(new MessageDispatch15Interceptor()); channel2.addInterceptor(new MessageDispatch15Interceptor());",
        "ins1PreCode":"public void setUp() throws Exception { channel1 = new GroupChannel(); channel1.addInterceptor(new MessageDispatch15Interceptor()); channel2 = new GroupChannel(); channel2.addInterceptor(new MessageDispatch15Interceptor()); ThroughputInterceptor tint = new ThroughputInterceptor(); tint.setInterval(500);",
        "ins2PreCode":"public void setUp() throws Exception { channel1 = new GroupChannel(); channel1.addInterceptor(new MessageDispatch15Interceptor()); channel2 = new GroupChannel(); channel2.addInterceptor(new MessageDispatch15Interceptor()); ThroughputInterceptor tint = new ThroughputInterceptor(); tint.setInterval(500);",
        "label":1
    },
    {
        "ins1AddCode":"double prediction = model.predict(point.features());",
        "ins1DelCode":"Double prediction = model.predict(point.features());",
        "ins1PreCode":"List<LabeledPoint> validationData, LinearRegressionModel model) { int numAccurate = 0; for (LabeledPoint point : validationData) { Double prediction = model.predict(point.features());  if (Math.abs(prediction - point.label()) <= 0.5) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"collection = ExceptionHelper.nullCheck(collectionSupplier.get(), \"The collectionSupplier returned a null Collection.\");",
        "ins1DelCode":"collection = ObjectHelper.requireNonNull(collectionSupplier.get(), \"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins1PreCode":"Collection<? super K> collection;  try { collection = ObjectHelper.requireNonNull(collectionSupplier.get(), \"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"Collection<? super K> collection; try { collection = ObjectHelper.requireNonNull(collectionSupplier.get(), \"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testSelect() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Integer> ids = new ArrayList<Integer>(); ids.add(1); ids.add(3); ids.add(5); Parameter parameter = new Parameter(); parameter.setEnabled(true); parameter.setSchema(\"ibtest\"); parameter.setIds(ids);  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.select\", parameter);  assertTrue(answer.size() == 3); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testSelectSimple() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Integer> ids = new ArrayList<Integer>(); ids.add(1); ids.add(3); ids.add(5); Parameter parameter = new Parameter(); parameter.setEnabled(true); parameter.setSchema(\"ibtest\"); parameter.setIds(ids); List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.select_simple\", parameter); assertTrue(answer.size() == 3); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"a b\"), parsedEntry.getField(new UnknownField(\"a\")));",
        "ins1DelCode":"assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins1PreCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins2PreCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(new File(getOutputDir(),\"E\").exists()); assertTrue(new File(getOutputDir(),\"E/1\").exists()); assertTrue(!new File(getOutputDir(),\"A/1\").exists()); assertTrue(new File(getOutputDir(),\"A\").exists());",
        "ins1DelCode":"assertTrue(getProject().resolveFile(\"E\").exists()); assertTrue(getProject().resolveFile(\"E/1\").exists()); assertTrue(!getProject().resolveFile(\"A/1\").exists()); assertTrue(getProject().resolveFile(\"A\").exists());",
        "ins1PreCode":"public void testDirectoryRetaining() throws IOException { executeTarget(\"testDirectoryRetaining\"); assertTrue(getProject().resolveFile(\"E\").exists()); assertTrue(getProject().resolveFile(\"E/1\").exists()); assertTrue(!getProject().resolveFile(\"A/1\").exists()); assertTrue(getProject().resolveFile(\"A\").exists());",
        "ins2PreCode":"private void testCompleteDirectoryMove(String target) throws IOException { executeTarget(target); assertTrue(getProject().resolveFile(\"E\").exists()); assertTrue(getProject().resolveFile(\"E/1\").exists()); assertTrue(!getProject().resolveFile(\"A/1\").exists()); assertTrue(getProject().resolveFile(\"E\").exists());",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T, @NonNull R> Observable<R> combineLatest(",
        "ins1DelCode":"public static <T, R> Observable<R> combineLatest(",
        "ins1PreCode":"public static <T, R> Observable<R> combineLatest( @NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) {",
        "ins2PreCode":"public static <T, R> Observable<R> combineLatestDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, public static <T, R> Observable<R> combineLatestDelayError(@NonNull Iterable<@NonNull ? extends ObservableSource<? extends T>> sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) {",
        "label":1
    },
    {
        "ins1AddCode":".block(Duration.ofSeconds(30));",
        "ins1DelCode":".block();",
        "ins1PreCode":"WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange() .block(); });",
        "ins2PreCode":"WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\") .exchange()::block) });",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void noPrematureSubscription() { PublishProcessor<Object> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final AtomicInteger subscribed = new AtomicInteger();",
        "ins2PreCode":"public void noMultipleSubscriptions() { PublishProcessor<Object> other = PublishProcessor.create(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); final AtomicInteger subscribed = new AtomicInteger();",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void assertValue() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposables.empty());  try {",
        "ins2PreCode":"public void assertValue() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposables.empty()); try {",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (count++ == 1) { throw new TestException(); } else { return new ArrayList<Integer>(); } }",
        "ins2PreCode":"if (count++ == 1) { .assertFailure(NullPointerException.class); } else { return new ArrayList<Integer>(); } }",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"PublishProcessor<Integer> source = PublishProcessor.create(); PublishProcessor<Integer> until = PublishProcessor.create();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  source.takeUntil(until).subscribe(ts);",
        "ins2PreCode":"PublishProcessor<Integer> source = PublishProcessor.create(); PublishProcessor<Integer> until = PublishProcessor.create(); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); source.takeUntil(until).take(1).subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"public ErrorPosition[] getErrorPosition(@NotNull DBCSession session, @NotNull String query, @NotNull Throwable error) {",
        "ins1DelCode":"public ErrorPosition[] getErrorPosition(@NotNull Throwable error) {",
        "ins1PreCode":"public ErrorPosition[] getErrorPosition(@NotNull Throwable error) { String message = error.getMessage(); if (!CommonUtils.isEmpty(message)) {",
        "ins2PreCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(@NotNull Throwable error) { String message = error.getMessage(); if (!CommonUtils.isEmpty(message)) {",
        "label":0
    },
    {
        "ins1AddCode":"result  = new StringBuilder(); done = true;",
        "ins1DelCode":"",
        "ins1PreCode":"final HttpServletResponse resp) throws ServletException, IOException {  result.append('1'); result.append(req.isAsyncStarted()); req.startAsync(); result.append('2'); result.append(req.isAsyncStarted());  req.getAsyncContext().start(new Runnable() { @Override public void run() { try { result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4'); result.append(req.isAsyncStarted()); resp.setContentType(\"text/plain\"); resp.getWriter().print(\"OK\"); req.getAsyncContext().complete(); result.append('5'); result.append(req.isAsyncStarted()); } catch (InterruptedException e) { result.append(e); } catch (IOException e) { result.append(e);",
        "ins2PreCode":"final HttpServletResponse resp) throws ServletException, IOException { result.append('1'); result.append(req.isAsyncStarted()); req.startAsync(); result.append('2'); result.append(req.isAsyncStarted()); req.getAsyncContext().start(new Runnable() { @Override public void run() { try { result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4'); result.append(req.isAsyncStarted()); resp.setContentType(\"text/plain\"); resp.getWriter().print(\"OK\"); req.getAsyncContext().complete(); result.append('5'); result.append(req.isAsyncStarted()); } catch (InterruptedException e) { result.append(e); } catch (IOException e) { result.append(e);",
        "label":1
    },
    {
        "ins1AddCode":"YIntervalSeriesCollection<String> c2 = TestUtils.serialised(c1);",
        "ins1DelCode":"YIntervalSeriesCollection c2 = TestUtils.serialised(c1);",
        "ins1PreCode":"YIntervalSeries<String> s1 = new YIntervalSeries<>(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); YIntervalSeriesCollection c2 = TestUtils.serialised(c1); assertEquals(c1, c2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"mutableGraph.addEdge(\"A\", \"A\", \"AA\"); mutableGraph.addEdge(\"A\", \"B\", \"AB\");",
        "ins1DelCode":"mutableGraph.addEdgeV2(\"A\", \"A\", \"AA\"); mutableGraph.addEdgeV2(\"A\", \"B\", \"AB\");",
        "ins1PreCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdgeV2(\"A\", \"A\", \"AA\"); mutableGraph.addEdgeV2(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph); ",
        "ins2PreCode":"public void edgesConnecting_undirected() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.undirected().build(); mutableGraph.addEdgeV2(\"A\", \"A\", \"AA\"); mutableGraph.addEdgeV2(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);",
        "label":1
    },
    {
        "ins1AddCode":"FlowableCache<Long> cached = new FlowableCache<>(source, 16); List<TestSubscriber<Long>> list = new ArrayList<>(100); TestSubscriber<Long> ts = new TestSubscriber<>(); List<Long> expected = new ArrayList<>();",
        "ins1DelCode":"FlowableCache<Long> cached = new FlowableCache<Long>(source, 16); List<TestSubscriber<Long>> list = new ArrayList<TestSubscriber<Long>>(100); TestSubscriber<Long> ts = new TestSubscriber<Long>(); List<Long> expected = new ArrayList<Long>();",
        "ins1PreCode":"Flowable<Long> source = Flowable.interval(1, 1, TimeUnit.MILLISECONDS) .take(1000) .subscribeOn(Schedulers.io()); FlowableCache<Long> cached = new FlowableCache<Long>(source, 16);  Flowable<Long> output = cached.observeOn(Schedulers.computation());  List<TestSubscriber<Long>> list = new ArrayList<TestSubscriber<Long>>(100); for (int i = 0; i < 100; i++) { TestSubscriber<Long> ts = new TestSubscriber<Long>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) { expected.add((long)(i - 10));",
        "ins2PreCode":"Observable<Long> source = Observable.interval(1, 1, TimeUnit.MILLISECONDS) .take(1000) .subscribeOn(Schedulers.io()); ObservableCache<Long> cached = new ObservableCache<Long>(source, 16); Observable<Long> output = cached.observeOn(Schedulers.computation()); List<TestObserver<Long>> list = new ArrayList<TestObserver<Long>>(100); for (int i = 0; i < 100; i++) { TestObserver<Long> to = new TestObserver<Long>(); list.add(to); output.skip(i * 10).take(10).subscribe(to); } List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) { expected.add((long)(i - 10));",
        "label":1
    },
    {
        "ins1AddCode":"assertMatcher(matcher, \"/actuator\").matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator/foo/zoo/\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator/bar/baz\"); assertMatcher(matcher, \"/actuator\").matches(\"/actuator\");",
        "ins1DelCode":"assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/foo/zoo/\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/bar/baz\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator\");",
        "ins1PreCode":"public void toAnyEndpointShouldMatchEndpointPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/foo/zoo/\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator/bar/baz\"); assertMatcher(matcher, \"/actuator\", \"/\").matches(\"/actuator\");",
        "ins2PreCode":"public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint(); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/foo\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator/bar\"); assertMatcher(matcher, \"/actuator\", null).matches(\"/actuator\");",
        "label":0
    },
    {
        "ins1AddCode":".authorizedTo(Run.UPDATE, Item.READ, Jenkins.READ)",
        "ins1DelCode":".authorizedTo(Run.UPDATE, Job.READ, Jenkins.READ)",
        "ins1PreCode":"@Test public void setBuildDescriptionShouldFailIfJobDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Run.UPDATE, Job.READ, Jenkins.READ) .invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".setMetricName(\"accuracy\");",
        "ins1DelCode":".setMetricName(\"precision\");",
        "ins1PreCode":"MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));",
        "ins2PreCode":"MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));",
        "label":1
    },
    {
        "ins1AddCode":"return f.concatMapDelayError(Functions.justFunction(Observable.just(1).hide()), true, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"return f.concatMapDelayError(Functions.justFunction(Observable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"TestHelper.checkBadSourceObservable(new Function<Observable<Integer>, Object>() { @Override public Object apply(Observable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Observable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE); } }, true, 1, 1, 1);",
        "ins2PreCode":"TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() { @Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE); } }, true, 1, 1, 1);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs = Disposable.empty();",
        "ins1DelCode":"Disposable bs = Disposables.empty();",
        "ins1PreCode":"Observable.unsafeCreate(new ObservableSource<Observable<Integer>>() { @Override public void subscribe(final Observer<? super Observable<Integer>> observer) { Disposable bs = Disposables.empty(); observer.onSubscribe(bs); observer.onNext(Observable.just(1));",
        "ins2PreCode":"Flowable.unsafeCreate(new Publisher<Flowable<Integer>>() { @Override public void subscribe(final Subscriber<? super Flowable<Integer>> subscriber) { BooleanSubscription bs = new BooleanSubscription(); subscriber.onSubscribe(bs); subscriber.onNext(Flowable.just(1));",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> series = new XYSeries<>(\"Series\", false, true);",
        "ins1DelCode":"XYSeries series = new XYSeries(\"Series\", false, true);",
        "ins1PreCode":"public void testAddOrUpdate3() { XYSeries series = new XYSeries(\"Series\", false, true); series.addOrUpdate(1.0, 1.0); series.addOrUpdate(1.0, 2.0);",
        "ins2PreCode":"public void testBug1955483() { XYSeries series = new XYSeries(\"Series\", true, true); series.addOrUpdate(1.0, 1.0); series.addOrUpdate(1.0, 2.0);",
        "label":1
    },
    {
        "ins1AddCode":".startObject(TEXT_FIELD_NAME) .startObject(KEYWORD_FIELD_NAME)",
        "ins1DelCode":".startObject(STRING_FIELD_NAME) .startObject(STRING_FIELD_NAME_2)",
        "ins1PreCode":".field(PARENT_DOC, CHILD_DOC) .endObject() .endObject() .startObject(STRING_FIELD_NAME) .field(\"type\", \"text\") .endObject() .startObject(STRING_FIELD_NAME_2) .field(\"type\", \"keyword\") .endObject()",
        "ins2PreCode":".field(PARENT_DOC, CHILD_DOC) .endObject() .endObject() .startObject(STRING_FIELD_NAME) .field(\"type\", \"text\") .endObject() .startObject(STRING_FIELD_NAME_2) .field(\"type\", \"keyword\") .endObject()",
        "label":1
    },
    {
        "ins1AddCode":"coll = ExceptionHelper.nullCheck(collectionSupplier.get(), \"The collectionSupplier returned a null Collection.\");",
        "ins1DelCode":"coll = ObjectHelper.requireNonNull(collectionSupplier.get(), \"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins1PreCode":"public void subscribeActual(SingleObserver<? super U> t) { U coll; try { coll = ObjectHelper.requireNonNull(collectionSupplier.get(), \"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "ins2PreCode":"public void subscribeActual(Observer<? super U> t) { U coll; try { coll = ObjectHelper.requireNonNull(collectionSupplier.get(), \"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "label":1
    },
    {
        "ins1AddCode":"return jjStartNfaWithStates_0(4, 18, 15);",
        "ins1DelCode":"return jjStartNfaWithStates_0(4, 18, 17);",
        "ins1PreCode":"case 69: case 101: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 17); break; default :",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaRDD<Integer> partitionSums = rdd.mapPartitions(iter -> { int sum = 0; while (iter.hasNext()) { sum += iter.next(); return Collections.singletonList(sum).iterator(); });",
        "ins1DelCode":"JavaRDD<Integer> partitionSums = rdd.mapPartitions( new FlatMapFunction<Iterator<Integer>, Integer>() { @Override public Iterator<Integer> call(Iterator<Integer> iter) { int sum = 0; while (iter.hasNext()) { sum += iter.next(); } return Collections.singletonList(sum).iterator(); });",
        "ins1PreCode":"public void mapPartitions() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4), 2); JavaRDD<Integer> partitionSums = rdd.mapPartitions( new FlatMapFunction<Iterator<Integer>, Integer>() { @Override public Iterator<Integer> call(Iterator<Integer> iter) { int sum = 0; while (iter.hasNext()) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "ins1DelCode":"assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins1PreCode":"assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"boolean validated = compareCredentials(credentials, dbCredentials); return new GenericPrincipal(username, credentials, list);",
        "ins1DelCode":"boolean validated = false; if (hasMessageDigest()) { validated = (digest(credentials).equalsIgnoreCase(dbCredentials)); } else validated = (digest(credentials).equals(dbCredentials)); return (new GenericPrincipal(username, credentials, list));",
        "ins1PreCode":"String dbCredentials = getPassword(dbConnection, username);   boolean validated = false; if (hasMessageDigest()) {  validated = (digest(credentials).equalsIgnoreCase(dbCredentials)); } else validated = (digest(credentials).equals(dbCredentials));  if (validated) { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateSuccess\", username)); } else { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateFailure\", username)); return (null); }  ArrayList<String> list = getRoles(dbConnection, username);   return (new GenericPrincipal(username, credentials, list)); ",
        "ins2PreCode":"String serverCredentials = getPassword(username); boolean validated = compareCredentials(credentials, serverCredentials); if (containerLog.isTraceEnabled()) { boolean validated = compareCredentials(credentials, serverCredentials); } boolean validated = compareCredentials(credentials, serverCredentials); if (!validated) { if (containerLog.isTraceEnabled()) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateSuccess\", username)); } if (containerLog.isTraceEnabled()) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateFailure\", username)); return null; } String serverCredentials = getPassword(username); return getPrincipal(username);",
        "label":0
    },
    {
        "ins1AddCode":"synchronized (typeClassDefinitions) { i.hasNext();) { if (!(Task.class.isAssignableFrom(clazz))) {",
        "ins1DelCode":"synchronized(typeClassDefinitions) { i.hasNext();) { if (! Task.class.isAssignableFrom(clazz)) {",
        "ins1PreCode":"public Hashtable getDataTypeDefinitions() { synchronized(typeClassDefinitions) { synchronized (antTypeTable) { if (rebuildTypeClassDefinitions) { typeClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = (Class) antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (! Task.class.isAssignableFrom(clazz)) { typeClassDefinitions.put( name, antTypeTable.getTypeClass(name));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory);",
        "ins1DelCode":"MetaClass meta = MetaClass.forClass(RichType.class);",
        "ins1PreCode":"public void shouldCheckGetterExistance() { MetaClass meta = MetaClass.forClass(RichType.class); assertTrue(meta.hasGetter(\"richField\")); assertTrue(meta.hasGetter(\"richProperty\"));",
        "ins2PreCode":"public void shouldCheckSetterExistance() { MetaClass meta = MetaClass.forClass(RichType.class); assertTrue(meta.hasSetter(\"richField\")); assertTrue(meta.hasSetter(\"richProperty\"));",
        "label":1
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { actions.add(",
        "ins2PreCode":"public void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { public void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { actions.add(",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void assertValuesOnlyThrowsOnUnexpectedValue() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposables.empty()); to.assertValuesOnly(); ",
        "ins2PreCode":"public void assertValuesOnly() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposables.empty()); to.assertValuesOnly();",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(startCount).isEqualTo(endCount);",
        "ins1DelCode":"assertThat(startCount).isEqualTo(endCount + 1);",
        "ins1PreCode":".filter((invocation) -> invocation.getMethod().toString().contains(\"start(\")).count(); long endCount = mockingDetails(startupStep).getInvocations().stream() .filter((invocation) -> invocation.getMethod().toString().contains(\"end(\")).count(); assertThat(startCount).isEqualTo(endCount + 1);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Environment environment, WebEndpointDiscoverer endpointDiscoverer, endpointDiscoverer.getEndpoints(), endpointMediaTypes,",
        "ins1DelCode":"Environment environment, EndpointDiscoverer<WebOperation> endpointDiscoverer, endpointDiscoverer.discoverEndpoints(), endpointMediaTypes,",
        "ins1PreCode":"public WebFluxEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, EndpointDiscoverer<WebOperation> endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebFluxEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, corsConfiguration);",
        "ins2PreCode":"public WebMvcEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, EndpointDiscoverer<WebOperation> webEndpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebMvcEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), webEndpointDiscoverer.discoverEndpoints(), endpointMediaTypes, corsConfiguration);",
        "label":0
    },
    {
        "ins1AddCode":"DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>();",
        "ins1DelCode":"DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset();",
        "ins1PreCode":"public void testFindDomainBounds4() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {0.8, 3.2, 3.0}; double[] x1Start = new double[] {0.9, 1.9, 2.9};",
        "ins2PreCode":"public void testIterateToFindDomainBounds_IntervalXYDataset() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {0.8, 3.2, 3.0}; double[] x1Start = new double[] {0.9, 1.9, 2.9};",
        "label":1
    },
    {
        "ins1AddCode":"String value = \"0xnotanumber\";",
        "ins1DelCode":"String value = \"0x\" + randomAlphaOfLengthBetween(1, 10);",
        "ins1PreCode":"public void testConvertIntHexError() { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String value = \"0x\" + randomAlphaOfLengthBetween(1, 10); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, value); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.INTEGER, false);",
        "ins2PreCode":"public void testConvertLongHexError() { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String value = \"0x\" + randomAlphaOfLengthBetween(1, 10); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, value); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.LONG, false);",
        "label":1
    },
    {
        "ins1AddCode":"IllegalArgumentException iae = new IllegalArgumentException(sm.getString(\"userMBean.destroyError.role\", rolename));",
        "ins1DelCode":"IllegalArgumentException iae = new IllegalArgumentException( \"Exception destroying role [\" + rolename + \"] MBean\");",
        "ins1PreCode":"MBeanUtils.destroyMBean(role); database.removeRole(role); } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException( \"Exception destroying role [\" + rolename + \"] MBean\"); iae.initCause(e); throw iae;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() {",
        "ins1DelCode":"public void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() {",
        "ins1PreCode":"public void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() {  Map<String, Object> map = new LinkedHashMap<>();",
        "ins2PreCode":"public void readOnlyOriginTrackedMapPropertySourceKeyAdditionDoesNotInvalidateCache() { Map<String, Object> map = new LinkedHashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person parent = person.getParent(); Assert.assertNull(\"Parent must be null\", parent); }",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person parent = person.getParent(); Assert.assertNull(\"Parent must be null\", parent); sqlSession.close();",
        "ins1PreCode":"public void testNoParent() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person parent = person.getParent(); Assert.assertNull(\"Parent must be null\", parent); sqlSession.close();",
        "ins2PreCode":"public void testNoParent() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person parent = person.getParent(); Assert.assertNull(\"Parent must be null\", parent); sqlSession.close();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertValuesOnly() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(new BooleanSubscription()); ts.assertValuesOnly();",
        "ins2PreCode":"public void assertValuesOnlyThrowsOnUnexpectedValue() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(new BooleanSubscription()); ts.assertValuesOnly();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":".sequential() ;  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  result.subscribe(ts);",
        "ins2PreCode":".sequential() ; TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); result.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  Single.just(1).flattenAsObservable(new Function<Integer, Iterable<Integer>>() {",
        "ins2PreCode":"public void fusedNoSync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC); Single.just(1).flattenAsObservable(new Function<Integer, Iterable<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"DeferredScalarDisposable<T> d = new DeferredScalarDisposable<>(observer);",
        "ins1DelCode":"DeferredScalarDisposable<T> d = new DeferredScalarDisposable<T>(observer);",
        "ins1PreCode":"public void subscribeActual(Observer<? super T> observer) { DeferredScalarDisposable<T> d = new DeferredScalarDisposable<T>(observer); observer.onSubscribe(d); if (d.isDisposed()) {",
        "ins2PreCode":"public void subscribeActual(Observer<? super T> observer) { DeferredScalarDisposable<T> d = new DeferredScalarDisposable<T>(observer); observer.onSubscribe(d); if (d.isDisposed()) {",
        "label":1
    },
    {
        "ins1AddCode":"Set<Task> unblockedTasks = Hudson.getInstance().getQueue().getUnblockedTasks(); for (AbstractProject tup : Hudson.getInstance().getDependencyGraph().getTransitiveDownstream(this)) { if (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup)))",
        "ins1DelCode":"DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue(); ItemList<Queue.Item> unblockedItems = queue.getUnblockedItems(); for (AbstractProject tup : tups) { if(tup.isBuilding() || unblockedItems.containsKey(tup))",
        "ins1PreCode":"protected AbstractProject getBuildingDownstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue(); ItemList<Queue.Item> unblockedItems = queue.getUnblockedItems(); for (AbstractProject tup : tups) { if(tup.isBuilding() || unblockedItems.containsKey(tup)) return tup; }",
        "ins2PreCode":"protected AbstractProject getBuildingUpstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); for (AbstractProject tup : tups) { if(tup.isBuilding() || tup.isInQueue()) return tup; }",
        "label":0
    },
    {
        "ins1AddCode":"File file1 = new File(getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProject().getProperty(\"to.dir\")+\"/file3.txt\");",
        "ins1DelCode":"File file1 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file3.txt\");",
        "ins1PreCode":"public void testFileResourcePlain() { executeTarget(\"testFileResourcePlain\"); File file1 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists());",
        "ins2PreCode":"public void testPathAsResource() { executeTarget(\"testPathAsResource\"); File file1 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file1.txt\"); File file2 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file2.txt\"); File file3 = new File(getProjectDir(), getProject().getProperty(\"to.dir\")+\"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists());",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void tryTerminateConsumerMaybeObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile);",
        "ins1DelCode":"for (int i = 0; i < scannedFiles.length; ++i) { files.put(scannedFiles[i], scannedFiles[i]);",
        "ins1PreCode":"DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (int i = 0; i < scannedFiles.length; ++i) { files.put(scannedFiles[i], scannedFiles[i]); } assertEquals(\"Classfileset did not pick up expected number of \"",
        "ins2PreCode":"DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (int i = 0; i < scannedFiles.length; ++i) { files.put(scannedFiles[i], scannedFiles[i]); } assertEquals(\"Classfileset did not pick up expected number of \"",
        "label":1
    },
    {
        "ins1AddCode":"Exception e = Assert.assertThrows(AccessDeniedException.class, () -> jenkins.getACL().checkAnyPermission(Jenkins.MANAGE, Jenkins.SYSTEM_READ)); Assert.assertEquals(\"manager is missing the Overall/Administer permission\", e.getMessage());",
        "ins1DelCode":"expectedException.expectMessage(\"manager is missing the Overall/Administer permission\"); expectedException.expect(AccessDeniedException.class); jenkins.getACL().checkAnyPermission(Jenkins.MANAGE, Jenkins.SYSTEM_READ);",
        "ins1PreCode":" final User manager = User.getOrCreateByIdOrFullName(\"manager\");  expectedException.expectMessage(\"manager is missing the Overall/Administer permission\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as2(manager.impersonate2())) { jenkins.getACL().checkAnyPermission(Jenkins.MANAGE, Jenkins.SYSTEM_READ); }",
        "ins2PreCode":"final User manager = User.getOrCreateByIdOrFullName(\"manager\"); expectedException.expectMessage(\"manager is missing a permission, one of Job/WipeOut, Run/Artifacts is required\"); expectedException.expect(AccessDeniedException.class); try (ACLContext ignored = ACL.as2(manager.impersonate2())) { jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Build.ARTIFACTS); }",
        "label":0
    },
    {
        "ins1AddCode":"source = Objects.requireNonNull(onSuccessMapper.apply(value), \"The onSuccessMapper returned a null MaybeSource\");",
        "ins1DelCode":"source = ObjectHelper.requireNonNull(onSuccessMapper.apply(value), \"The onSuccessMapper returned a null MaybeSource\");",
        "ins1PreCode":"MaybeSource<? extends R> source;  try { source = ObjectHelper.requireNonNull(onSuccessMapper.apply(value), \"The onSuccessMapper returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"MaybeSource<? extends R> source; try { source = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null MaybeSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"value = ExceptionHelper.nullCheck(callable.call(), \"Callable returned a null value.\");",
        "ins1DelCode":"value = ObjectHelper.requireNonNull(callable.call(), \"Callable returned null\");",
        "ins1PreCode":"} T value; try { value = ObjectHelper.requireNonNull(callable.call(), \"Callable returned null\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "ins2PreCode":"} T value; try { value = ObjectHelper.requireNonNull(supplier.get(), \"Supplier returned null\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "label":1
    },
    {
        "ins1AddCode":"super.setStandardBounds(X0, Y0, WIDTH, NAME_FIG_HEIGHT + ROWHEIGHT);",
        "ins1DelCode":"setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "ins1PreCode":"  enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_BIBTEX_LIBRARY_LOCATION); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.of(file)); verify(preferences, times(1)).setWorkingDir(file.getParent());",
        "ins1DelCode":"when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_FILE_PATH); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(path); verify(preferences, times(1)).setWorkingDir(path.get().getParent());",
        "ins1PreCode":"public void saveAsShouldSetWorkingDirectory() { when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_FILE_PATH); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(path); doNothing().when(saveDatabaseAction).saveAs(any());  saveDatabaseAction.saveAs();  verify(preferences, times(1)).setWorkingDir(path.get().getParent());",
        "ins2PreCode":"public void saveAsShouldNotSetWorkingDirectoryIfNotSelected() { when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_FILE_PATH); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.empty()); doNothing().when(saveDatabaseAction).saveAs(any()); saveDatabaseAction.saveAs(); verify(preferences, times(0)).setWorkingDir(path.get().getParent());",
        "label":0
    },
    {
        "ins1AddCode":"ASSERT.that(family).iteratesOverSequence(",
        "ins1DelCode":"ASSERT.that(family).hasContentsInOrder(",
        "ins1PreCode":"Iterable<String> family = COMMA_SPLITTER .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).hasContentsInOrder( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins2PreCode":"Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).hasContentsInOrder( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "label":1
    },
    {
        "ins1AddCode":"Object element = entries.get(i);",
        "ins1DelCode":"Object element = entries.elementAt(i);",
        "ins1PreCode":" final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i);  if (element instanceof FieldRefCPInfo) {",
        "ins2PreCode":"final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i); if (element instanceof NameAndTypeCPInfo) {",
        "label":1
    },
    {
        "ins1AddCode":"checkNotNull(collection);",
        "ins1DelCode":"if (collection == null) { throw new NullPointerException(); }",
        "ins1PreCode":"public boolean addAll(Collection<? extends Boolean> collection) { ensureIsMutable();  if (collection == null) { throw new NullPointerException(); } ",
        "ins2PreCode":"public boolean addAll(Collection<? extends Integer> collection) { ensureIsMutable(); if (collection == null) { throw new NullPointerException(); }",
        "label":1
    },
    {
        "ins1AddCode":"void testAnnotatedInsertTable2() {",
        "ins1DelCode":"public void testAnnotatedInsertTable2() {",
        "ins1PreCode":"public void testAnnotatedInsertTable2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins2PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "label":1
    },
    {
        "ins1AddCode":"void testLangVelocityWithMapper() {",
        "ins1DelCode":"public void testLangVelocityWithMapper() {",
        "ins1PreCode":"public void testLangVelocityWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins2PreCode":"public void testLangXmlWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "label":1
    },
    {
        "ins1AddCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 30000,",
        "ins1DelCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 20000,",
        "ins1PreCode":"   int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 20000, null, null); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assumeFalse(\"https://github.com/elastic/elasticsearch/issues/49094\", inFipsJvm());",
        "ins1DelCode":"",
        "ins1PreCode":"public void testClientFailsWithUntrustedCertificate() throws IOException { final List<Thread> threads = new ArrayList<>(); final Settings settings = Settings.builder() .put(\"path.home\", createTempDir())",
        "ins2PreCode":"public void testClientSucceedsWithVerificationDisabled() throws IOException { final List<Thread> threads = new ArrayList<>(); final Settings settings = Settings.builder() .put(\"path.home\", createTempDir())",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertEmpty() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  try {",
        "ins2PreCode":"public void assertEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); try {",
        "label":1
    },
    {
        "ins1AddCode":"TesterWsClient client = new TesterWsClient(\"localhost\", getPort()); client.sendTextMessage(\"Test\");",
        "ins1DelCode":"TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.sendMessage(\"Test\");",
        "ins1PreCode":" startServer(TestEndpointConfig.class);  TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.httpUpgrade(BaseEndpointConfig.PATH); client.sendMessage(\"Test\"); awaitLatch(events.onMessageCalled, \"onMessage not called\"); ",
        "ins2PreCode":"startServer(TestEndpointConfig.class); TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.httpUpgrade(BaseEndpointConfig.PATH); client.sendMessage(\"Test\"); awaitLatch(events.onMessageCalled, \"onMessage not called\");",
        "label":1
    },
    {
        "ins1AddCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1DelCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { String sql = String.format(SQL_RENAME_TABLE, DBUtils.getQuotedIdentifier(command.getObject().getSchema()) + \".\" + DBUtils.getQuotedIdentifier(command.getObject().getDataSource(), command.getOldName()),",
        "ins2PreCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) String sql = String.format(SQL_RENAME_TABLE, DBUtils.getQuotedIdentifier(command.getObject().getSchema()) + \".\" + DBUtils.getQuotedIdentifier(command.getObject().getDataSource(), command.getOldName()),",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(12.779642067948913, result.metricScore(), DELTA); assertEquals(12.779642067948913 / 13.347184833073591, dcg.evaluate(\"id\", hits, rated).metricScore(), DELTA);",
        "ins1DelCode":"assertEquals(12.779642067948913, result.getQualityLevel(), DELTA); assertEquals(12.779642067948913 / 13.347184833073591, dcg.evaluate(\"id\", hits, rated).getQualityLevel(), DELTA);",
        "ins1PreCode":"} DiscountedCumulativeGain dcg = new DiscountedCumulativeGain(); EvalQueryQuality result = dcg.evaluate(\"id\", hits, rated); assertEquals(12.779642067948913, result.getQualityLevel(), DELTA); assertEquals(2, filterUnratedDocuments(result.getHitsAndRatings()).size());              dcg = new DiscountedCumulativeGain(true, null, 10); assertEquals(12.779642067948913 / 13.347184833073591, dcg.evaluate(\"id\", hits, rated).getQualityLevel(), DELTA);",
        "ins2PreCode":"} DiscountedCumulativeGain dcg = new DiscountedCumulativeGain(); EvalQueryQuality result = dcg.evaluate(\"id\", hits, ratedDocs); assertEquals(12.392789260714371, result.getQualityLevel(), DELTA); assertEquals(1, filterUnratedDocuments(result.getHitsAndRatings()).size()); dcg = new DiscountedCumulativeGain(true, null, 10); assertEquals(12.392789260714371 / 13.347184833073591, dcg.evaluate(\"id\", hits, ratedDocs).getQualityLevel(), DELTA);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertValuesOnly() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposable.empty()); to.assertValuesOnly();",
        "ins2PreCode":"to.assertValuesOnly(); TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposable.empty()); to.assertValuesOnly();",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"throws Exception",
        "ins1PreCode":"public void testInterpolateObjectWithStringListField() throws Exception { Model model = new Model();",
        "ins2PreCode":"public void testInterpolateObjectWithStringListFieldAndOneLiteralValue() throws Exception { Model model = new Model();",
        "label":1
    },
    {
        "ins1AddCode":"getHtmlButton(f, \"Add\", true).click(); getHtmlButton(f, \"Add\", false).click();",
        "ins1DelCode":"HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); HtmlFormUtil.getButtonByCaption(f, \"Add\").click();",
        "ins1PreCode":"public void testRadio() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(1).click(); HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click();",
        "ins2PreCode":"public void testRadio_ExistingData() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt 4\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click(); HtmlFormUtil.getButtonByCaption(f, \"Add\").click(); f.getInputByValue(\"\").setValueAttribute(\"txt 4\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click();",
        "label":0
    },
    {
        "ins1AddCode":"public R poll() {",
        "ins1DelCode":"public R poll() throws Exception {",
        "ins1PreCode":"public R poll() throws Exception { Iterator<? extends R> iterator = it; ",
        "ins2PreCode":"public R poll() throws Exception { Iterator<? extends R> iterator = it;",
        "label":1
    },
    {
        "ins1AddCode":"if (!Objects.equals(getToolTipText(), that.getToolTipText())) { if (!Objects.equals(getURLText(), that.getURLText())) {",
        "ins1DelCode":"if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { if (!ObjectUtils.equal(getURLText(), that.getURLText())) {",
        "ins1PreCode":"if (!getArea().equals(that.getArea())) { return false; } if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtils.equal(getURLText(), that.getURLText())) { return false; }",
        "ins2PreCode":"if (!getArea().equals(that.getArea())) { return false; } if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtils.equal(getURLText(), that.getURLText())) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"void fixedRateScheduledMethodIsReported() {",
        "ins1DelCode":"public void fixedRateScheduledMethodIsReported() {",
        "ins1PreCode":"public void fixedRateScheduledMethodIsReported() { run(FixedRateScheduledMethod.class, (tasks) -> { assertThat(tasks.getCron()).isEmpty();",
        "ins2PreCode":"public void fixedRateTriggerIsReported() { run(FixedRateTriggerTask.class, (tasks) -> { assertThat(tasks.getCron()).isEmpty();",
        "label":1
    },
    {
        "ins1AddCode":"Rectangle2D labelBounds = TextUtils.getTextBounds(label, g2, fm); TextUtils.drawRotatedString(label, g2, (float) labelx, TextUtils.drawRotatedString(label, g2, (float) labelx, TextUtils.drawRotatedString(label, g2, (float) labelx, TextUtils.drawRotatedString(label, g2, (float) labelx,",
        "ins1DelCode":"Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm); TextUtilities.drawRotatedString(label, g2, (float) labelx, TextUtilities.drawRotatedString(label, g2, (float) labelx, TextUtilities.drawRotatedString(label, g2, (float) labelx, TextUtilities.drawRotatedString(label, g2, (float) labelx,",
        "ins1PreCode":"g2.setFont(font); g2.setPaint(getLabelPaint()); FontMetrics fm = g2.getFontMetrics(); Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);  if (edge == RectangleEdge.TOP) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle(), labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = labelLocationX(this.labelLocation, dataArea); double labely = state.getCursor() - insets.getBottom() - labelBounds.getHeight() / 2.0; TextAnchor anchor = labelAnchorH(this.labelLocation); TextUtilities.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER); state.cursorUp(insets.getTop() + labelBounds.getHeight() + insets.getBottom()); } else if (edge == RectangleEdge.BOTTOM) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle(), labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = labelLocationX(this.labelLocation, dataArea); double labely = state.getCursor() + insets.getTop() + labelBounds.getHeight() / 2.0; TextAnchor anchor = labelAnchorH(this.labelLocation); TextUtilities.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER); state.cursorDown(insets.getTop() + labelBounds.getHeight() + insets.getBottom()); } else if (edge == RectangleEdge.LEFT) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = state.getCursor() - insets.getRight() - labelBounds.getWidth() / 2.0; double labely = labelLocationY(this.labelLocation, dataArea); TextAnchor anchor = labelAnchorV(this.labelLocation); TextUtilities.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle() - Math.PI / 2.0, anchor); state.cursorLeft(insets.getLeft() + labelBounds.getWidth() + insets.getRight()); } else if (edge == RectangleEdge.RIGHT) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle() + Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = state.getCursor() + insets.getLeft() + labelBounds.getWidth() / 2.0; double labely = labelLocationY(this.labelLocation, dataArea); TextAnchor anchor = labelAnchorV(this.labelLocation); TextUtilities.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle() + Math.PI / 2.0, anchor);",
        "ins2PreCode":"g2.setFont(getLabelFont()); g2.setPaint(getLabelPaint()); + insets.getBottom()); Rectangle2D labelBounds = layout.getBounds(); if (edge == RectangleEdge.TOP) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle(), labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = labelLocationX(this.labelLocation, dataArea); double labely = state.getCursor() - insets.getBottom() - labelBounds.getHeight() / 2.0; TextAnchor anchor = labelAnchorH(this.labelLocation); AttrStringUtils.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER); state.cursorUp(insets.getTop() + labelBounds.getHeight() + insets.getBottom()); } else if (edge == RectangleEdge.BOTTOM) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle(), labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = labelLocationX(this.labelLocation, dataArea); double labely = state.getCursor() + insets.getTop() + labelBounds.getHeight() / 2.0; TextAnchor anchor = labelAnchorH(this.labelLocation); AttrStringUtils.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle(), TextAnchor.CENTER); state.cursorDown(insets.getTop() + labelBounds.getHeight() + insets.getBottom()); } else if (edge == RectangleEdge.LEFT) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = state.getCursor() - insets.getRight() - labelBounds.getWidth() / 2.0; double labely = labelLocationY(this.labelLocation, dataArea); TextAnchor anchor = labelAnchorV(this.labelLocation); AttrStringUtils.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle() - Math.PI / 2.0, anchor); state.cursorLeft(insets.getLeft() + labelBounds.getWidth() + insets.getRight()); } else if (edge == RectangleEdge.RIGHT) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle() + Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); double labelx = state.getCursor() + insets.getLeft() + labelBounds.getWidth() / 2.0; double labely = labelLocationY(this.labelLocation, dataArea); TextAnchor anchor = labelAnchorV(this.labelLocation); AttrStringUtils.drawRotatedString(label, g2, (float) labelx, (float) labely, anchor, getLabelAngle() + Math.PI / 2.0, anchor);",
        "label":0
    },
    {
        "ins1AddCode":"Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); Map.Entry<?,?> e = i.next();",
        "ins1DelCode":"Iterator i = super.entrySet().iterator(); Map.Entry e = (Map.Entry)i.next();",
        "ins1PreCode":"public Set<MapEntry> entrySet() { LinkedHashSet<MapEntry> set = new LinkedHashSet<MapEntry>(super.size()); Iterator i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key);",
        "ins2PreCode":"public Set<Object> keySet() { LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key);",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertNotNull(person, \"Persons must not be null\"); Assertions.assertNotNull(person.getParent(), \"Parent must not be null\"); Assertions.assertNotNull(person.getParent().getParent(), \"Grandparent must not be null\"); Assertions.assertEquals(expectedAncestor, person.getAncestor(), \"Ancestor must be John Smith sr.\");",
        "ins1DelCode":"Assert.assertNotNull(\"Persons must not be null\", person); Assert.assertNotNull(\"Parent must not be null\", person.getParent()); Assert.assertNotNull(\"Grandparent must not be null\", person.getParent().getParent()); Assert.assertEquals(\"Ancestor must be John Smith sr.\", expectedAncestor, person.getAncestor());",
        "ins1PreCode":"Person expectedAncestor = personMapper.selectById(1); Person person = personMapper.selectById(3);  Assert.assertNotNull(\"Persons must not be null\", person); Assert.assertNotNull(\"Parent must not be null\", person.getParent()); Assert.assertNotNull(\"Grandparent must not be null\", person.getParent().getParent()); Assert.assertEquals(\"Ancestor must be John Smith sr.\", expectedAncestor, person.getAncestor()); }",
        "ins2PreCode":"Person expectedAncestor = personMapper.selectById(1); Person person = personMapper.selectById(3); Assert.assertNotNull(\"Persons must not be null\", person); Assert.assertNotNull(\"Parent must not be null\", person.getParent()); Assert.assertNotNull(\"Grandparent must not be null\", person.getParent().getParent()); Assert.assertEquals(\"Ancestor must be John Smith sr.\", expectedAncestor, person.getAncestor()); }",
        "label":1
    },
    {
        "ins1AddCode":"when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey]\");",
        "ins1DelCode":"when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey]\");",
        "ins1PreCode":"LinkedFile fileField = new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation(fileField));  when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey]\"); cleanup.cleanup(entry); ",
        "ins2PreCode":"LinkedFile fileField = new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation(fileField)); when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey] - [fulltitle]\"); cleanup.cleanup(entry);",
        "label":1
    },
    {
        "ins1AddCode":"IntervalBarRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"IntervalBarRenderer r2 = (IntervalBarRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalBarRenderer r1 = new IntervalBarRenderer(); IntervalBarRenderer r2 = (IntervalBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedBarRenderer r1 = new StackedBarRenderer(); StackedBarRenderer r2 = (StackedBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsEmpty() {",
        "ins1DelCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsEmpty() throws Exception {",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsEmpty() throws Exception { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "ins2PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsComma() throws Exception { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "label":1
    },
    {
        "ins1AddCode":"String key = \"test.\" + UUID.randomUUID();",
        "ins1DelCode":"String key = \"test.\" + UUID.randomUUID().toString();",
        "ins1PreCode":"public void runWithSystemPropertiesShouldSetAndRemoveProperties() { String key = \"test.\" + UUID.randomUUID().toString(); assertThat(System.getProperties().containsKey(key)).isFalse(); get().withSystemProperties(key + \"=value\")",
        "ins2PreCode":"public void runWithSystemPropertiesWhenContextFailsShouldRemoveProperties() String key = \"test.\" + UUID.randomUUID().toString(); assertThat(System.getProperties().containsKey(key)).isFalse(); get().withSystemProperties(key + \"=value\")",
        "label":1
    },
    {
        "ins1AddCode":"if (done || emitter.isDisposed()) {",
        "ins1DelCode":"if (emitter.isDisposed() || done) {",
        "ins1PreCode":"public void onNext(T t) { if (emitter.isDisposed() || done) { return; }",
        "ins2PreCode":"public void onNext(T t) { if (emitter.isCancelled() || done) { return; }",
        "label":0
    },
    {
        "ins1AddCode":"if (Execute.isFailure(result)) {",
        "ins1DelCode":"if (result != 0) {",
        "ins1PreCode":"System.out.println(commandLine.toString());  result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, location);",
        "ins2PreCode":"System.out.println(commandLine.toString()); result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, location);",
        "label":1
    },
    {
        "ins1AddCode":"super.addObjectModifyActions(monitor, actionList, command, options);",
        "ins1DelCode":"if (command.getProperty(DBConstants.PROP_ID_DESCRIPTION) != null) { actionList.add(new SQLDatabasePersistAction(\"Set column comment\", \"COMMENT ON COLUMN \" + DBUtils.getObjectFullName(column.getTable(), DBPEvaluationContext.DDL) + \".\" + DBUtils.getQuotedIdentifier(column) + \" IS \" + SQLUtils.quoteString(column, CommonUtils.notEmpty(column.getDescription())))); }",
        "ins1PreCode":"actionList.add(new SQLDatabasePersistAction(\"Set column default\", prefix + \"SET DEFAULT \" + column.getDefaultValue())); } } if (command.getProperty(DBConstants.PROP_ID_DESCRIPTION) != null) { actionList.add(new SQLDatabasePersistAction(\"Set column comment\", \"COMMENT ON COLUMN \" + DBUtils.getObjectFullName(column.getTable(), DBPEvaluationContext.DDL) + \".\" + DBUtils.getQuotedIdentifier(column) + \" IS \" + SQLUtils.quoteString(column, CommonUtils.notEmpty(column.getDescription())))); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.loggingSystem.initialize(null, getRelativeClasspathLocation(\"log4j2-file.xml\"), getLogFile(null, tmpDir()));",
        "ins1DelCode":"this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir()));",
        "ins1PreCode":"void exceptionsIncludeClassPackaging(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Map<Integer, Collection<String>> expected = new HashMap<>();",
        "ins1DelCode":"Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>();",
        "ins1PreCode":" Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFuncErr);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\")); expected.put(2, Arrays.asList(\"cc\", \"dd\"));",
        "ins2PreCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFuncErr); Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\")); expected.put(2, Arrays.asList(\"cc\", \"dd\"));",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.SEVERE, \"could not set package due to:\" + e",
        "ins1DelCode":"LOG.error(\"could not set package due to:\" + e",
        "ins1PreCode":"Model.getCoreHelper().setNamespace(me, m); } } catch (Exception e) { LOG.error(\"could not set package due to:\" + e + \"' at \" + encloser, e); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Observable<Integer>> inner = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>();",
        "ins1PreCode":"public void windowAbandonmentCancelsUpstream() { PublishSubject<Integer> ps = PublishSubject.create();  final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>();  TestObserver<Observable<Integer>> to = ps.window(Observable.<Integer>just(1).concatWith(Observable.<Integer>never()),",
        "ins2PreCode":"public void windowAbandonmentCancelsUpstream() { PublishSubject<Integer> ps = PublishSubject.create(); final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>(); TestObserver<Observable<Integer>> to = ps.window(Observable.<Integer>never())",
        "label":1
    },
    {
        "ins1AddCode":"cd.add(Disposable.empty());",
        "ins1DelCode":"cd.add(Disposables.empty());",
        "ins1PreCode":"Runnable run2 = new Runnable() { @Override public void run() { cd.add(Disposables.empty()); } };",
        "ins2PreCode":"Runnable run2 = new Runnable() { @Override public void run() { cd.addAll(Disposables.empty()); } };",
        "label":1
    },
    {
        "ins1AddCode":"Path expectedFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI()); exporter.export(databaseContext, exportedFile, charset, entries); String.join(\"\\n\", Files.readAllLines(expectedFile)), String.join(\"\\n\", Files.readAllLines(exportedFile)));",
        "ins1DelCode":"Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI()); exporter.export(databaseContext, tempFile, charset, entries); String.join(\"\\n\", Files.readAllLines(xmlFile)), String.join(\"\\n\", Files.readAllLines(tempFile)));",
        "ins1PreCode":"importFile = Paths.get(ModsExportFormatTestFiles.class.getResource(filename).toURI()); String xmlFileName = filename.replace(\".bib\", \".xml\"); List<BibEntry> entries = bibtexImporter.importDatabase(importFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI());  exporter.export(databaseContext, tempFile, charset, entries);  assertEquals( String.join(\"\\n\", Files.readAllLines(xmlFile)), String.join(\"\\n\", Files.readAllLines(tempFile)));",
        "ins2PreCode":"importFile = Paths.get(ModsExportFormatTestFiles.class.getResource(filename).toURI()); String xmlFileName = filename.replace(\".bib\", \".xml\"); List<BibEntry> entries = modsImporter.importDatabase(xmlFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI()); exporter.export(databaseContext, tempFile, charset, entries); assertEquals( String.join(\"\\n\", Files.readAllLines(xmlFile)), String.join(\"\\n\", Files.readAllLines(tempFile)));",
        "label":0
    },
    {
        "ins1AddCode":"verifyStatic(ChannelPinger.class);",
        "ins1DelCode":"verifyStatic();",
        "ins1PreCode":"channelPinger.install(mockChannel, null);  verify(mockChannel).call(eq(new ChannelPinger.SetUpRemotePing(ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 420))); verifyStatic(); ChannelPinger.setUpPingForChannel(mockChannel, null, ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 420, true);",
        "ins2PreCode":"channelPinger.install(mockChannel, null); verify(mockChannel).call(eq(new ChannelPinger.SetUpRemotePing(ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 73))); verifyStatic(); ChannelPinger.setUpPingForChannel(mockChannel, null, ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 73, true);",
        "label":1
    },
    {
        "ins1AddCode":"for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1DelCode":"for (JavaDoubleRDD rdd: Lists.newArrayList(rdd1, rdd2, rdd3)) {",
        "ins1PreCode":"JavaDoubleRDD rdd1 = poissonJavaRDD(sc, mean, m); JavaDoubleRDD rdd2 = poissonJavaRDD(sc, mean, m, p); JavaDoubleRDD rdd3 = poissonJavaRDD(sc, mean, m, p, seed); for (JavaDoubleRDD rdd: Lists.newArrayList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); }",
        "ins2PreCode":"JavaDoubleRDD rdd1 = exponentialJavaRDD(sc, mean, m); JavaDoubleRDD rdd2 = exponentialJavaRDD(sc, mean, m, p); JavaDoubleRDD rdd3 = exponentialJavaRDD(sc, mean, m, p, seed); for (JavaDoubleRDD rdd: Lists.newArrayList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); }",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('a');  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\")); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd'); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"S1\");",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"S1\");",
        "ins1PreCode":"public void testRemove2() { XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); s1.add(2.0, 2.2);",
        "ins2PreCode":"public void testSetMaximumItemCount3() { XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); s1.add(2.0, 2.2);",
        "label":1
    },
    {
        "ins1AddCode":"d2 = CloneUtils.clone(d1); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset<String, String>) d2.getUnderlyingDataset();",
        "ins1DelCode":"d2 = (SlidingCategoryDataset) d1.clone(); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset();",
        "ins1PreCode":"u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); SlidingCategoryDataset<String, String> d2; d2 = (SlidingCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\"); assertTrue(d1.equals(d2));",
        "ins2PreCode":"u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); assertTrue(d1.equals(d2)); assertTrue(d1.equals(d2)); assertTrue(d1.equals(d2)); u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset<String, String> u1 = new DefaultCategoryDataset<>(); u2.addValue(3.0, \"R1\", \"C3\"); assertTrue(d1.equals(d2));",
        "label":0
    },
    {
        "ins1AddCode":"IfNode irIfNode = new IfNode(userIfNode.getLocation());",
        "ins1DelCode":"IfNode irIfNode = new IfNode(); irIfNode.setLocation(userIfNode.getLocation());",
        "ins1PreCode":"public void visitIf(SIf userIfNode, ScriptScope scriptScope) { IfNode irIfNode = new IfNode(); irIfNode.setConditionNode(injectCast(userIfNode.getConditionNode(), scriptScope)); irIfNode.setBlockNode((BlockNode)visit(userIfNode.getIfBlockNode(), scriptScope)); irIfNode.setLocation(userIfNode.getLocation());  scriptScope.putDecoration(userIfNode, new IRNodeDecoration(irIfNode));",
        "ins2PreCode":"public void visitIfElse(SIfElse userIfElseNode, ScriptScope scriptScope) { IfElseNode irIfElseNode = new IfElseNode(); irIfElseNode.setConditionNode(injectCast(userIfElseNode.getConditionNode(), scriptScope)); irIfElseNode.setBlockNode((BlockNode)visit(userIfElseNode.getIfBlockNode(), scriptScope)); irIfElseNode.setLocation(userIfElseNode.getLocation()); scriptScope.putDecoration(userIfElseNode, new IRNodeDecoration(irIfElseNode));",
        "label":1
    },
    {
        "ins1AddCode":"kv2D1.addValue(234.2, \"Row1\", \"Col1\"); kv2D1.addValue(345.9, \"Row2\", \"Col1\"); kv2D1.addValue(452.7, \"Row2\", \"Col2\");",
        "ins1DelCode":"kv2D1.addValue(new Double(234.2), \"Row1\", \"Col1\"); kv2D1.addValue(new Double(345.9), \"Row2\", \"Col1\"); kv2D1.addValue(new Double(452.7), \"Row2\", \"Col2\");",
        "ins1PreCode":"public void testSerialization() { DefaultKeyedValues2D kv2D1 = new DefaultKeyedValues2D(); kv2D1.addValue(new Double(234.2), \"Row1\", \"Col1\"); kv2D1.addValue(null, \"Row1\", \"Col2\"); kv2D1.addValue(new Double(345.9), \"Row2\", \"Col1\"); kv2D1.addValue(new Double(452.7), \"Row2\", \"Col2\");  DefaultKeyedValues2D kv2D2 = (DefaultKeyedValues2D)",
        "ins2PreCode":"public void testSerialization() { DefaultKeyedValues2DDataset d1 = new DefaultKeyedValues2DDataset(); d1.addValue(new Double(234.2), \"Row1\", \"Col1\"); d1.addValue(null, \"Row1\", \"Col2\"); d1.addValue(new Double(345.9), \"Row2\", \"Col1\"); d1.addValue(new Double(452.7), \"Row2\", \"Col2\"); DefaultKeyedValues2DDataset d2 = (DefaultKeyedValues2DDataset)",
        "label":1
    },
    {
        "ins1AddCode":"RestTemplateBuilder restTemplateBuilder, ServletEndpointsSupplier servletEndpointsSupplier, ControllerEndpointsSupplier controllerEndpointsSupplier) { Collection<ExposableWebEndpoint> webEndpoints = discoverer.getEndpoints(); List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>(); allEndpoints.addAll(webEndpoints); allEndpoints.addAll(servletEndpointsSupplier.getEndpoints()); allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints()); new EndpointMapping(\"/cloudfoundryapplication\"), webEndpoints, endpointMediaTypes, getCorsConfiguration(), securityInterceptor, new EndpointLinksResolver(allEndpoints));",
        "ins1DelCode":"RestTemplateBuilder restTemplateBuilder) { new EndpointMapping(\"/cloudfoundryapplication\"), discoverer.getEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins1PreCode":"public CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping( ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, RestTemplateBuilder restTemplateBuilder) { CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, PathMapper.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( restTemplateBuilder, this.applicationContext.getEnvironment()); return new CloudFoundryWebEndpointServletHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), discoverer.getEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"PathMappedEndpoints pathMappedEndpoints, String servletPath) { DispatcherServletPathProvider pathProvider = () -> servletPath; context.registerBean(DispatcherServletPathProvider.class, () -> pathProvider);",
        "ins1DelCode":"PathMappedEndpoints pathMappedEndpoints) {",
        "ins1PreCode":"private RequestMatcherAssert assertMatcher(RequestMatcher matcher, PathMappedEndpoints pathMappedEndpoints) { StaticWebApplicationContext context = new StaticWebApplicationContext(); context.registerBean(WebEndpointProperties.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(b,iter.next()); Assert.assertTrue(others.contains(o)); Assert.assertEquals(d,iter.next()); Assert.assertFalse(iter.hasNext());",
        "ins1DelCode":"assertEquals(b,iter.next()); assertTrue(others.contains(o)); assertEquals(d,iter.next()); assertFalse(iter.hasNext());",
        "ins1PreCode":"Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments, null);  Iterator<WebXml> iter = ordered.iterator(); assertEquals(b,iter.next());  while (others.size() > 0) { WebXml o = iter.next(); assertTrue(others.contains(o)); others.remove(o); } assertEquals(d,iter.next()); assertFalse(iter.hasNext());",
        "ins2PreCode":"Set<WebXml> ordered = WebXml.orderWebFragments(app, fragments, null); Iterator<WebXml> iter = ordered.iterator(); assertEquals(b,iter.next()); while (others.size() > 0) { WebXml o = iter.next(); assertTrue(others.contains(o)); others.remove(o); } assertEquals(d,iter.next()); assertFalse(iter.hasNext());",
        "label":1
    },
    {
        "ins1AddCode":"subscribers = RxJavaPlugins.onSubscribe(this, subscribers);",
        "ins1DelCode":"",
        "ins1PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return; }",
        "ins2PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return; }",
        "label":1
    },
    {
        "ins1AddCode":"void testSameUpdateAfterCommitReuse() {",
        "ins1DelCode":"public void testSameUpdateAfterCommitReuse() {",
        "ins1PreCode":"public void testSameUpdateAfterCommitReuse() { try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.REUSE)) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "ins2PreCode":"public void testSameUpdateAfterCommitBatch() { try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH)) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"builder.field(PARENT_TYPE_FIELD.getPreferredName(), type);",
        "ins1DelCode":"builder.field(TYPE_FIELD.getPreferredName(), type);",
        "ins1PreCode":"builder.startObject(NAME); builder.field(QUERY_FIELD.getPreferredName()); query.toXContent(builder, params); builder.field(TYPE_FIELD.getPreferredName(), type); builder.field(SCORE_FIELD.getPreferredName(), score); builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped);",
        "ins2PreCode":"builder.startObject(NAME); builder.field(QUERY_FIELD.getPreferredName()); query.toXContent(builder, params); builder.field(TYPE_FIELD.getPreferredName(), type); builder.field(TYPE_FIELD.getPreferredName(), type); builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped);",
        "label":0
    },
    {
        "ins1AddCode":"Month m1 = new Month(new Date(951868799999L), zone, Locale.getDefault()); Month m2 = new Month(new Date(951868800000L), zone, Locale.getDefault());",
        "ins1DelCode":"Month m1 = new Month(new Date(951868799999L), zone); Month m2 = new Month(new Date(951868800000L), zone);",
        "ins1PreCode":" TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Month m1 = new Month(new Date(951868799999L), zone); Month m2 = new Month(new Date(951868800000L), zone);  assertEquals(MonthConstants.FEBRUARY, m1.getMonth());",
        "ins2PreCode":"TimeZone zone = TimeZone.getTimeZone(\"Pacific/Auckland\"); Calendar cal = Calendar.getInstance(zone); Month m1 = new Month(new Date(951821999999L), zone, Locale.getDefault()); Month m2 = new Month(new Date(951822000000L), zone, Locale.getDefault()); assertEquals(MonthConstants.FEBRUARY, m1.getMonth());",
        "label":0
    },
    {
        "ins1AddCode":"FastRemovalDequeue<Object> q = new FastRemovalDequeue<>(2);",
        "ins1DelCode":"FastRemovalDequeue<Object> q = new FastRemovalDequeue<Object>(2);",
        "ins1PreCode":"public void testSinglePushPop() throws Exception { FastRemovalDequeue<Object> q = new FastRemovalDequeue<Object>(2);  Object o1 = new Object();",
        "ins2PreCode":"public void testSingleUnpopPop() throws Exception { FastRemovalDequeue<Object> q = new FastRemovalDequeue<Object>(2); Object o1 = new Object();",
        "label":1
    },
    {
        "ins1AddCode":"void testList() {",
        "ins1DelCode":"public void testList() {",
        "ins1PreCode":"public void testList() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(ListConfig.class) .withPropertyValues(\"foo.list[0]:foo\");",
        "ins2PreCode":"public void testInetAddress() { ApplicationContextRunner contextRunner = new ApplicationContextRunner() .withUserConfiguration(AddressedConfig.class).withPropertyValues(\"foo.address:192.168.1.10\");",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); to.dispose(); observer.onComplete();",
        "ins2PreCode":"new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); .assertEmpty(); subscriber.onComplete();",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(expected).hasCauseThat().isSameInstanceAs(cause);",
        "ins1DelCode":"assertThat(expected).hasCauseThat().isSameAs(cause);",
        "ins1PreCode":"Throwables.getRootCause(cause); fail(\"Should have throw IAE\"); } catch (IllegalArgumentException expected) { assertThat(expected).hasCauseThat().isSameAs(cause); }",
        "ins2PreCode":"Throwables.getCausalChain(cause); fail(\"Should have throw IAE\"); } catch (IllegalArgumentException expected) { assertThat(expected).hasCauseThat().isSameAs(cause); }",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":".window(new Observable<Object>() { @Override protected void subscribeActual(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); ref.set(observer); }",
        "ins2PreCode":".window(new Flowable<Object>() { @Override protected void subscribeActual(Subscriber<? super Object> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); ref.set(subscriber); }",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"public void testReplaceDataset() {   XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1);  LocalListener l = new LocalListener();",
        "ins2PreCode":"public void testReplaceDataset() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1); LocalListener l = new LocalListener();",
        "label":1
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { AtlasMeterRegistry registry = context.getBean(AtlasMeterRegistry.class);",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).with(mandatoryProperties()).run((context) -> { DynatraceMeterRegistry registry = context.getBean(DynatraceMeterRegistry.class);",
        "label":1
    },
    {
        "ins1AddCode":"ds.setBasedir(new File(getProject().getProperty(\"output\")));",
        "ins1DelCode":"ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\"));",
        "ins1PreCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/**\",",
        "ins2PreCode":"public void testAlternateExcludeInclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/**\",",
        "label":1
    },
    {
        "ins1AddCode":"if (applicationListeners[i].getClassName().equals(listener)) { ApplicationListener results[] = new ApplicationListener[applicationListeners.length - 1];",
        "ins1DelCode":"if (applicationListeners[i].equals(listener)) { String results[] = new String[applicationListeners.length - 1];",
        "ins1PreCode":" int n = -1; for (int i = 0; i < applicationListeners.length; i++) { if (applicationListeners[i].equals(listener)) { n = i; break; } } if (n < 0) return;   int j = 0; String results[] = new String[applicationListeners.length - 1]; for (int i = 0; i < applicationListeners.length; i++) { if (i != n)",
        "ins2PreCode":"int n = -1; for (int i = 0; i < wrapperListeners.length; i++) { if (wrapperListeners[i].equals(listener)) { n = i; break; } } if (n < 0) return; int j = 0; String results[] = new String[wrapperListeners.length - 1]; for (int i = 0; i < wrapperListeners.length; i++) { if (i != n)",
        "label":0
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { ElasticMeterRegistry registry = context.getBean(ElasticMeterRegistry.class);",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { GangliaMeterRegistry registry = context.getBean(GangliaMeterRegistry.class);",
        "label":1
    },
    {
        "ins1AddCode":"TestDisposableObserver<Integer> tc = new TestDisposableObserver<>();",
        "ins1DelCode":"TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>();",
        "ins1PreCode":"List<Throwable> error = TestHelper.trackPluginErrors();  try { TestDisposableObserver<Integer> tc = new TestDisposableObserver<Integer>();  tc.onSubscribe(Disposable.empty());",
        "ins2PreCode":"List<Throwable> error = TestHelper.trackPluginErrors(); try { Disposable d = Disposable.empty(); tc.onSubscribe(Disposable.empty());",
        "label":0
    },
    {
        "ins1AddCode":"project1.getBuildersList().add(createScriptBuilder(\"echo 1\")); project2.getBuildersList().add(createScriptBuilder(\"echo 1\"));",
        "ins1DelCode":"project1.getBuildersList().add(new Shell(\"echo 1\")); project2.getBuildersList().add(new Shell(\"echo 1\"));",
        "ins1PreCode":"@Test public void reloadJobManyShouldFailIfMiddleJobDoesNotExist() throws Exception {  FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\"));  assertThat(project1.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "ins2PreCode":"@Test public void reloadJobManyShouldFailIfMoreJobsDoNotExist() throws Exception { FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\")); assertThat(project1.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "label":1
    },
    {
        "ins1AddCode":"String actionL = getValue().toLowerCase(Locale.ENGLISH);",
        "ins1DelCode":"String actionL = getValue().toLowerCase(Locale.US);",
        "ins1PreCode":"public int getAction() { String actionL = getValue().toLowerCase(Locale.US);  if (actionL.equals(\"send\") || actionL.equals(\"put\")) {",
        "ins2PreCode":"public int getAction() { String actionL = getValue().toLowerCase(Locale.US); if (actionL.equals(\"send\") || actionL.equals(\"put\")) {",
        "label":1
    },
    {
        "ins1AddCode":"Set<Integer> expectedSet = new HashSet<>(Arrays.asList(1, 2)); Set<Integer> actualSet = new HashSet<>(to.values());",
        "ins1DelCode":"Set<Integer> expectedSet = new HashSet<Integer>(Arrays.asList(1, 2)); Set<Integer> actualSet = new HashSet<Integer>(to.values());",
        "ins1PreCode":"public void onNextOnNextRace() { Set<Integer> expectedSet = new HashSet<Integer>(Arrays.asList(1, 2));  for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final Subject<Integer> s = PublishSubject.<Integer>create().toSerialized();  TestObserverEx<Integer> to = s.to(TestHelper.<Integer>testConsumer());  Runnable r1 = new Runnable() { @Override public void run() { s.onNext(1); } };  Runnable r2 = new Runnable() { @Override public void run() { s.onNext(2); } };  TestHelper.race(r1, r2);  to.assertSubscribed() .assertNoErrors() .assertNotComplete() .assertValueCount(2) ;  Set<Integer> actualSet = new HashSet<Integer>(to.values()); assertEquals(\"\" + actualSet, expectedSet, actualSet); }",
        "ins2PreCode":"public void onNextOnNextRace() { Set<Integer> expectedSet = new HashSet<Integer>(Arrays.asList(1, 2)); for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final FlowableProcessor<Integer> s = PublishProcessor.<Integer>create().toSerialized(); TestSubscriberEx<Integer> ts = s.to(TestHelper.<Integer>testConsumer()); Runnable r1 = new Runnable() { @Override public void run() { s.onNext(1); } }; Runnable r2 = new Runnable() { @Override public void run() { s.onNext(2); } }; TestHelper.race(r1, r2); ts.assertSubscribed() .assertNoErrors() .assertNotComplete() .assertValueCount(2) ; Set<Integer> actualSet = new HashSet<Integer>(ts.values()); assertEquals(\"\" + actualSet, expectedSet, actualSet); }",
        "label":1
    },
    {
        "ins1AddCode":"ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference",
        "ins1DelCode":"ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference",
        "ins1PreCode":" assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject()",
        "ins2PreCode":"assertEquals(mapping, mapper.mappingSource().toString()); ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject()",
        "label":1
    },
    {
        "ins1AddCode":"File appDir = new File(\"test/webapp\");",
        "ins1DelCode":"File appDir = new File(\"test/webapp-3.0\");",
        "ins1PreCode":"public void testBug49726a() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start();",
        "ins2PreCode":"public void testBug49726b() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(error);",
        "ins1DelCode":"assertEquals(false,error);",
        "ins1PreCode":"}catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; } assertEquals(false,error);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"enterRule(_localctx, 40, RULE_postfix); setState(359); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { setState(356); setState(357); setState(358);",
        "ins1DelCode":"enterRule(_localctx, 38, RULE_postfix); setState(353); switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) { setState(350); setState(351); setState(352);",
        "ins1PreCode":"public final PostfixContext postfix() throws RecognitionException { PostfixContext _localctx = new PostfixContext(_ctx, getState()); enterRule(_localctx, 38, RULE_postfix); try { setState(353); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(350); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(351); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(352); braceaccess(); }",
        "ins2PreCode":"public final PostdotContext postdot() throws RecognitionException { PostdotContext _localctx = new PostdotContext(_ctx, getState()); enterRule(_localctx, 40, RULE_postdot); try { setState(357); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(357); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(357); fieldaccess(); } break; case 1: enterOuterAlt(_localctx, 1); { setState(357); fieldaccess(); }",
        "label":0
    },
    {
        "ins1AddCode":"ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( EndpointPathResolver.useEndpointId(), Collections.emptyList(), Collections.emptyList()); discoverer.getEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins1DelCode":"ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, CloudFoundryWebAnnotationEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebAnnotationEndpointDiscoverer( EndpointPathResolver.useEndpointId(), null, null, CloudFoundryHealthEndpointWebExtension.class); endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins1PreCode":"public CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping( ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, RestTemplateBuilder restTemplateBuilder) { CloudFoundryWebAnnotationEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebAnnotationEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null, CloudFoundryHealthEndpointWebExtension.class); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( restTemplateBuilder, this.applicationContext.getEnvironment()); return new CloudFoundryWebEndpointServletHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"}, false, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"}, 2, false, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"public Observable<Integer> apply(Integer v) throws Throwable { return Observable.just(v).hide(); } }, 2, false, ImmediateThinScheduler.INSTANCE); } });",
        "ins2PreCode":"public Observable<Integer> apply(Integer v) throws Throwable { return Observable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); } });",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>();",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot();",
        "ins1PreCode":"public void testListenersWithCategoryPlot() { CategoryPlot plot = new CategoryPlot(); CategoryMarker marker1 = new CategoryMarker(\"X\"); ValueMarker marker2 = new ValueMarker(1.0);",
        "ins2PreCode":"public void testListenersWithXYPlot() { XYPlot plot = new XYPlot(); ValueMarker marker1 = new ValueMarker(1.0); ValueMarker marker1 = new ValueMarker(1.0);",
        "label":0
    },
    {
        "ins1AddCode":"void testSelectBlogWithPosts() {",
        "ins1DelCode":"public void testSelectBlogWithPosts() {",
        "ins1PreCode":"public void testSelectBlogWithPosts() { try (SqlSession session = sqlSessionFactory.openSession()) { Mapper mapper = session.getMapper(Mapper.class);",
        "ins2PreCode":"public void testSelectBlogWithPostsColumnPrefix() { try (SqlSession session = sqlSessionFactory.openSession()) { Mapper mapper = session.getMapper(Mapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"void envVar() {",
        "ins1DelCode":"public void envVar() {",
        "ins1PreCode":"public void envVar() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty(); TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void nested() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty(); TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1AddCode":"Assert.state(StringUtils.hasLength(packageName), \"@EntityScan cannot be used with the default package\");",
        "ins1DelCode":"Assert.state(!StringUtils.isEmpty(packageName), \"@EntityScan cannot be used with the default package\");",
        "ins1PreCode":"} if (packagesToScan.isEmpty()) { String packageName = ClassUtils.getPackageName(metadata.getClassName()); Assert.state(!StringUtils.isEmpty(packageName), \"@EntityScan cannot be used with the default package\"); return Collections.singleton(packageName); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1DelCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final ExasolTableColumn column = command.getObject(); ",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) final DB2TableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"assertThrows(AssertionError.class, () -> { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber); subscriber.assertValue(1); subscriber.assertValueCount(2); subscriber.assertComplete().assertNoErrors(); });",
        "ins1DelCode":"Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber); thrown.expect(AssertionError.class); subscriber.assertValue(1); subscriber.assertValueCount(2); subscriber.assertComplete().assertNoErrors();",
        "ins1PreCode":"TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber);  thrown.expect(AssertionError.class);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEqualsJsonArray(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" formData.get(\"foos\"));",
        "ins1DelCode":"assertEquals(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" formData.get(\"foos\").toString());",
        "ins1PreCode":"try { f.getInputByValue(\"\"); fail(\"?\"); } catch (ElementNotFoundException expected) { } f.getInputsByName(\"bool\").get(2).click(); submit(f); assertEquals(\"[{\\\"bool\\\":false,\\\"txt\\\":\\\"value one\\\"},\" + \"{\\\"bool\\\":false,\\\"txt\\\":\\\"value two\\\"},{\\\"bool\\\":true,\\\"txt\\\":\\\"value three\\\"}]\", formData.get(\"foos\").toString());",
        "ins2PreCode":"try { f.getInputByValue(\"\"); fail(\"?\"); } catch (ElementNotFoundException expected) { } f.getInputsByName(\"bool\").get(1).click(); submit(f); assertEquals(\"[{\\\"bool\\\":true,\\\"txt\\\":\\\"existing one\\\"},\" assertEquals(\"[{\\\"bool\\\":true,\\\"txt\\\":\\\"existing one\\\"},\" formData.get(\"foos\").toString());",
        "label":1
    },
    {
        "ins1AddCode":"private static int validatePrediction( List<LabeledPoint> validationData, LinearRegressionModel model) {",
        "ins1DelCode":"int validatePrediction(List<LabeledPoint> validationData, LinearRegressionModel model) {",
        "ins1PreCode":"int validatePrediction(List<LabeledPoint> validationData, LinearRegressionModel model) { int numAccurate = 0; for (LabeledPoint point : validationData) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"socketBufferHandler.configureWriteBufferForRead(); pool.write(socketBufferHandler.getWriteBuffer(), getSocket(), selector, writeTimeout, block);",
        "ins1DelCode":"if (!writeBufferFlipped) { socketWriteBuffer.flip(); writeBufferFlipped = true; } pool.write(socketWriteBuffer, getSocket(), selector, writeTimeout, block); if (socketWriteBuffer.remaining() == 0) { socketWriteBuffer.clear(); writeBufferFlipped = false; }",
        "ins1PreCode":"protected synchronized void doWrite(boolean block) throws IOException { if (!writeBufferFlipped) { socketWriteBuffer.flip(); writeBufferFlipped = true; }  long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(socketWriteBuffer, getSocket(), selector, writeTimeout, block);  do { if (getSocket().flush(true, selector, writeTimeout)) break; } while (true); } finally { if (selector != null) { pool.put(selector); } } if (socketWriteBuffer.remaining() == 0) { socketWriteBuffer.clear(); writeBufferFlipped = false; } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertThat(graph.hasEdge(predecessor, node)).isTrue(); assertThat(graph.hasEdge(node, successor)).isTrue();",
        "ins1PreCode":" for (N predecessor : sanityCheckSet(graph.predecessors(node))) { assertThat(graph.successors(predecessor)).contains(node); assertThat(graph.hasEdge(predecessor, node)).isTrue(); }  for (N successor : sanityCheckSet(graph.successors(node))) { allEndpointPairs.add(EndpointPair.of(graph, node, successor)); assertThat(graph.predecessors(successor)).contains(node); assertThat(graph.hasEdge(node, successor)).isTrue(); } }",
        "ins2PreCode":"for (N predecessor : sanityCheckSet(graph.predecessors(node))) { assertThat(graph.successors(predecessor)).contains(node); assertThat(graph.hasEdge(predecessor, node)).isTrue(); } for (N successor : sanityCheckSet(graph.successors(node))) { allEndpointPairs.add(EndpointPair.of(graph, node, successor)); assertThat(graph.predecessors(successor)).contains(node); assertThat(graph.hasEdge(node, successor)).isTrue(); } }",
        "label":1
    },
    {
        "ins1AddCode":"private XYDataset<String> createDataset2() {",
        "ins1DelCode":"private XYDataset createDataset2() {",
        "ins1PreCode":"private XYDataset createDataset2() {  ",
        "ins2PreCode":"private XYDataset createDataset2() {",
        "label":1
    },
    {
        "ins1AddCode":"try { sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2); } finally { sqlSession.close(); }",
        "ins1DelCode":"sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2);",
        "ins1PreCode":"} finally { sqlSession.close(); }  sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\");",
        "ins2PreCode":"} finally { sqlSession.close(); } sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"selectIdentity\");",
        "label":1
    },
    {
        "ins1AddCode":"void testCleanHistoryOnStartProperty() {",
        "ins1DelCode":"public void testCleanHistoryOnStartProperty() {",
        "ins1PreCode":"public void testCleanHistoryOnStartProperty() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.clean-history-on-start\", \"true\");",
        "ins2PreCode":"public void testCleanHistoryOnStartPropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.clean-history-on-start\", \"true\");",
        "label":1
    },
    {
        "ins1AddCode":"\"The web application [ROOT] created a ThreadLocal with key of\");",
        "ins1DelCode":"\"The web application [] created a ThreadLocal with key of\");",
        "ins1PreCode":"  LogValidationFilter f = new LogValidationFilter( \"The web application [] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger( \"org.apache.catalina.loader.WebappClassLoaderBase\").setFilter(f);",
        "ins2PreCode":"LogValidationFilter f = new LogValidationFilter( \"The web application [] created a ThreadLocal with key of\"); LogManager.getLogManager().getLogger( \"org.apache.catalina.loader.WebappClassLoaderBase\").setFilter(f);",
        "label":1
    },
    {
        "ins1AddCode":"public Number getValue(R rowKey, C columnKey) {",
        "ins1DelCode":"public Number getValue(Comparable rowKey, Comparable columnKey) {",
        "ins1PreCode":"public Number getValue(Comparable rowKey, Comparable columnKey) { int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.basicAuthentication, this.restTemplateCustomizers,",
        "ins1DelCode":"this.basicAuthorization, this.restTemplateCustomizers,",
        "ins1PreCode":"Collections.unmodifiableSet( new LinkedHashSet<HttpMessageConverter<?>>(messageConverters)), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins2PreCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { Collection<? extends HttpMessageConverter<?>> messageConverters) { this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "label":1
    },
    {
        "ins1AddCode":"if (grant.getGrantee().equals(this.getName()))",
        "ins1DelCode":"if (grant.getName().equals(this.getName()))",
        "ins1PreCode":" for(ExasolScriptGrant grant: this.dataSource.getScriptGrants(monitor)) { if (grant.getName().equals(this.getName())) { grants.add(grant);",
        "ins2PreCode":"for(ExasolSchemaGrant grant: this.dataSource.getSchemaGrants(monitor)) { if (grant.getName().equals(this.getName())) { grants.add(grant);",
        "label":1
    },
    {
        "ins1AddCode":"mutableGraph.addEdgeV2(\"A\", \"A\", \"AA\"); mutableGraph.addEdgeV2(\"A\", \"B\", \"AB\");",
        "ins1DelCode":"mutableGraph.addEdge(\"AA\", \"A\", \"A\"); mutableGraph.addEdge(\"AB\", \"A\", \"B\");",
        "ins1PreCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdge(\"AA\", \"A\", \"A\"); mutableGraph.addEdge(\"AB\", \"A\", \"B\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph); ",
        "ins2PreCode":"public void edgesConnecting_undirected() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.undirected().build(); mutableGraph.addEdge(\"AA\", \"A\", \"A\"); mutableGraph.addEdge(\"AB\", \"A\", \"B\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);",
        "label":1
    },
    {
        "ins1AddCode":"Path texFile = Path.of(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI());",
        "ins1DelCode":"Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI());",
        "ins1PreCode":"public void testFileEncodingUtf8() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI());  LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "ins2PreCode":"public void testFileEncodingIso88591() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "label":1
    },
    {
        "ins1AddCode":"long maxwait = 0, minwait = Long.MAX_VALUE, totalwait = 0;",
        "ins1DelCode":"long maxwait = 0, minwait = Long.MAX_VALUE, averagewait = 0, totalwait = 0; float avgfetch = 0;",
        "ins1PreCode":"protected void printThreadResults(TestThread[] threads, String name, int active, int expected) { long minfetch = Long.MAX_VALUE, maxfetch = Long.MIN_VALUE, totalfetch = 0; long maxwait = 0, minwait = Long.MAX_VALUE, averagewait = 0, totalwait = 0; float avgfetch = 0; for (int i=0; i<threads.length; i++) { TestThread t = threads[i];",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec, true) }) {",
        "ins1DelCode":"for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) {",
        "ins1PreCode":"public void timerInterruptible() throws Exception { ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor(); try { for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) { final AtomicBoolean interrupted = new AtomicBoolean(); TestSubscriber<Long> ts = Flowable.timer(1, TimeUnit.MILLISECONDS, s)",
        "ins2PreCode":"public void timerInterruptible() throws Exception { ScheduledExecutorService exec = Executors.newSingleThreadScheduledExecutor(); try { for (Scheduler s : new Scheduler[] { Schedulers.single(), Schedulers.computation(), Schedulers.newThread(), Schedulers.io(), Schedulers.from(exec) }) { final AtomicBoolean interrupted = new AtomicBoolean(); TestObserver<Long> to = Maybe.timer(1, TimeUnit.MILLISECONDS, s)",
        "label":1
    },
    {
        "ins1AddCode":"void autoConfiguredNonSupportedCacheManagerIsIgnored() {",
        "ins1DelCode":"public void autoConfiguredNonSupportedCacheManagerIsIgnored() {",
        "ins1PreCode":"public void autoConfiguredNonSupportedCacheManagerIsIgnored() { this.contextRunner.withPropertyValues(\"spring.cache.type=simple\", \"spring.cache.cache-names=cache1,cache2\") .run((context) -> {",
        "ins2PreCode":"public void cacheInstrumentationCanBeDisabled() { this.contextRunner.withPropertyValues(\"management.metrics.enable.cache=false\", \"spring.cache.type=caffeine\", \"spring.cache.cache-names=cache1\").run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":"public void tfIdf() {  HashingTF tf = new HashingTF(); JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")),",
        "ins2PreCode":"public void tfIdfMinimumDocumentFrequency() { HashingTF tf = new HashingTF(); JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")),",
        "label":1
    },
    {
        "ins1AddCode":"jj_la1[40] = jj_gen; jj_la1[41] = jj_gen;",
        "ins1DelCode":"jj_la1[41] = jj_gen; jj_la1[42] = jj_gen;",
        "ins1PreCode":"} break; default: jj_la1[42] = jj_gen; ; }",
        "ins2PreCode":"} break; default: jj_la1[43] = jj_gen; ; }",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void cancelAfterOnComplete() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() { ",
        "ins2PreCode":"public void cancelAfterOnError() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"if (sharedInstance == null && metaContext == null && executionContext == null) {",
        "ins1DelCode":"if (metaContext == null && executionContext == null) {",
        "ins1PreCode":"public DBSObject refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { if (metaContext == null && executionContext == null) {  return this;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (!Model.getFacade().isAState(state)) { return; } Collection oldOnes = new ArrayList(Model.getFacade()",
        "ins1DelCode":"if (!Model.getFacade().isAState(state)) return; Collection oldOnes = new ArrayList(Model.getFacade()",
        "ins1PreCode":"protected void doIt(Collection selected) { Object state = getTarget(); if (!Model.getFacade().isAState(state)) return; Collection oldOnes = new ArrayList(Model.getFacade() .getDeferrableEvents(state)); Collection toBeRemoved = new ArrayList(oldOnes);",
        "ins2PreCode":"protected void doIt(Collection selected) { Object stereo = getTarget(); Model.getExtensionMechanismsHelper().removeBaseClass(stereo, o); protected void doIt(Collection selected) { Model.getExtensionMechanismsHelper().removeBaseClass(stereo, o); Set toBeRemoved = new HashSet<Object>(oldSet);",
        "label":0
    },
    {
        "ins1AddCode":"WebTestClient client = createClient(context); assertThat(isExposed(client, HttpMethod.GET, \"beans\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"custommvc\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"customservlet\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"env\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"health\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(client, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(client, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(client, HttpMethod.GET, \"httptrace\")).isTrue();",
        "ins1DelCode":"MockMvc mvc = MockMvcBuilders.webAppContextSetup(context).build(); assertThat(isExposed(mvc, HttpMethod.GET, \"beans\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"custommvc\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"httptrace\")).isTrue();",
        "ins1PreCode":"WebApplicationContextRunner contextRunner = this.contextRunner .withPropertyValues(\"management.endpoints.web.expose=*\"); contextRunner.run((context) -> { MockMvc mvc = MockMvcBuilders.webAppContextSetup(context).build(); assertThat(isExposed(mvc, HttpMethod.GET, \"beans\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"custommvc\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"httptrace\")).isTrue(); });",
        "ins2PreCode":"WebApplicationContextRunner contextRunner = this.contextRunner.withPropertyValues( \"management.endpoints.web.expose=*\", contextRunner.run((context) -> { MockMvc mvc = MockMvcBuilders.webAppContextSetup(context).build(); assertThat(isExposed(mvc, HttpMethod.GET, \"beans\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"custommvc\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"httptrace\")).isTrue(); });",
        "label":1
    },
    {
        "ins1AddCode":"return new Optional(Boolean.valueOf(!match.booleanValue()));",
        "ins1DelCode":"return new Optional(new Boolean(!match.booleanValue()));",
        "ins1PreCode":"match = (Boolean) le.invoke(iterator.next()); }  return new Optional(new Boolean(!match.booleanValue()));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (Model.getFacade().isAGeneralizableElement(element)) { Collection generalizations = Model.getFacade().getGeneralizations(element); for (Object generalization : generalizations) { if (diagram.presentationFor(generalization) == null) { Object general = Model.getFacade().getGeneral(generalization); al.add(new AddGeneralAction( \"Add Generalization to \"+ Model.getFacade().getName(general), diagram, element, generalization, general)); }",
        "ins1DelCode":"Collection generalizations = Model.getFacade().getGeneralizations(element); for (Object generalization : generalizations) { if (diagram.presentationFor(generalization) == null) { Object general = Model.getFacade().getGeneral(generalization); al.add(new AddGeneralAction( \"Add Generalization to \"+ Model.getFacade().getName(general), diagram, element, generalization, general));",
        "ins1PreCode":"private ActionList getGeneralizationToActions(final Object element, ArgoDiagram diagram) { ActionList al= new ActionList(\"Add Generalizations to \"); Collection generalizations = Model.getFacade().getGeneralizations(element); for (Object generalization : generalizations) { ",
        "ins2PreCode":"private ActionList getGeneralizationFromActions(final Object element, ArgoDiagram diagram) { ActionList al= new ActionList(\"Add Generalizations from \"); Collection specializations = Model.getFacade().getSpecializations(element); for (Object specialization : specializations) {",
        "label":1
    },
    {
        "ins1AddCode":"boolean atLeastV9 = dataSource.isAtLeastV9(); \"SELECT s.*, \"); if (atLeastV9) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\"); if(atLeastV9) { sql.append(\" AND s.sql_child_number = sq.child_number\"); }",
        "ins1DelCode":"\"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM GV$SESSION s \\n\" + \"LEFT JOIN gv$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN gv$sess_io io ON ( s.sid = io.sid AND s.inst_id = io.inst_id )\\n\" + \"WHERE 1=1\");",
        "ins1PreCode":"try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM GV$SESSION s \\n\" + \"LEFT JOIN gv$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN gv$sess_io io ON ( s.sid = io.sid AND s.inst_id = io.inst_id )\\n\" +   \"WHERE 1=1\"); if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) { sql.append(\" AND s.TYPE = 'USER'\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0);",
        "ins1DelCode":"new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.HEAP));",
        "ins1PreCode":"public void heap() { final TaskMemoryManager memoryManager = new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.HEAP)); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128);",
        "ins2PreCode":"public void offHeap() { final TaskMemoryManager memoryManager = new TaskMemoryManager(new ExecutorMemoryManager(MemoryAllocator.UNSAFE)); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable.wrap(new ObservableSource<Object>() { @Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete(); }",
        "ins2PreCode":"Observable.wrap(new ObservableSource<Object>() { @Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete(); }",
        "label":1
    },
    {
        "ins1AddCode":"filterDef.addInitParameter(\"internalProxies\", \"192\\\\.168\\\\.0\\\\.10|192\\\\.168\\\\.0\\\\.11\");",
        "ins1DelCode":"filterDef.addInitParameter(\"internalProxies\", \"192\\\\.168\\\\.0\\\\.10, 192\\\\.168\\\\.0\\\\.11\");",
        "ins1PreCode":"  FilterDef filterDef = new FilterDef(); filterDef.addInitParameter(\"internalProxies\", \"192\\\\.168\\\\.0\\\\.10, 192\\\\.168\\\\.0\\\\.11\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIpHeader\", \"x-forwarded-for\");",
        "ins2PreCode":"FilterDef filterDef = new FilterDef(); filterDef.addInitParameter(\"internalProxies\", \"127\\\\.0\\\\.0\\\\.1, 192\\\\.168\\\\..*, another-internal-proxy\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIpHeader\", \"x-forwarded-for\");",
        "label":0
    },
    {
        "ins1AddCode":"XYDataset<String> dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYDataset dataset = new XYSeriesCollection<>(series1);",
        "ins1PreCode":"series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createScatterPlot(\"Scatter Plot\", \"Domain\", \"Range\", dataset);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"setMapValuesUsingMutableMap(builder);",
        "ins1DelCode":"setMapValues(builder);",
        "ins1PreCode":"public void testIterationOrder() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); ",
        "ins2PreCode":"public void testIterationOrder() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();",
        "label":1
    },
    {
        "ins1AddCode":"void shouldAssignMultipleGeneratedKeysToABean() {",
        "ins1DelCode":"public void shouldAssignMultipleGeneratedKeysToABean() throws Exception {",
        "ins1PreCode":"public void shouldAssignMultipleGeneratedKeysToABean() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try {",
        "ins2PreCode":"public void shouldAssignMultipleGeneratedKeysToABean_MultiParams() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try {",
        "label":0
    },
    {
        "ins1AddCode":"receiverInfo.executorId();",
        "ins1DelCode":"",
        "ins1PreCode":"receiverInfo.name(); receiverInfo.active(); receiverInfo.location(); receiverInfo.lastErrorMessage(); receiverInfo.lastError(); receiverInfo.lastErrorTime();",
        "ins2PreCode":"receiverInfo.name(); receiverInfo.active(); receiverInfo.location(); receiverInfo.lastErrorMessage(); receiverInfo.lastError(); receiverInfo.lastErrorTime();",
        "label":1
    },
    {
        "ins1AddCode":"void periodSeparated() {",
        "ins1DelCode":"public void periodSeparated() {",
        "ins1PreCode":"public void periodSeparated() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty(); TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void envVar() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty(); TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1AddCode":"Iterable<ModelObject> itemList = newRuns(1, 10);",
        "ins1DelCode":"List<ModelObject> itemList = newRuns(1, 10);",
        "ins1PreCode":"public void test_olderThan_mid_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 8L); List<ModelObject> itemList = newRuns(1, 10);  historyPageFilter.add(itemList);",
        "ins2PreCode":"public void test_newerThan_near_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 3L, null); List<ModelObject> itemList = newRuns(1, 10); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1AddCode":"File tmp  = new File(getOutputDir(), \"copy.filterchain.tmp\");",
        "ins1DelCode":"File tmp  = new File(getProjectDir(), \"copy.filterchain.tmp\");",
        "ins1PreCode":"public void testFilterChain() throws IOException { executeTarget(\"testFilterChain\"); File tmp  = new File(getProjectDir(), \"copy.filterchain.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists());",
        "ins2PreCode":"public void testFilterSet() throws IOException { executeTarget(\"testFilterSet\"); File tmp  = new File(getProjectDir(), \"move.filterset.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\"); assertTrue(tmp.exists());",
        "label":1
    },
    {
        "ins1AddCode":"void shouldNotLetReadUnloadedPropertyAfterSerialization() throws Exception { Assertions.assertThrows(ExecutorException.class, author2::getId);",
        "ins1DelCode":"public void shouldNotLetReadUnloadedPropertyAfterSerialization() throws Exception { Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins1PreCode":"public void shouldNotLetReadUnloadedPropertyAfterSerialization() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins2PreCode":"public void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "label":1
    },
    {
        "ins1AddCode":"DefaultBoxAndWhiskerXYDataset d2 = TestUtils.serialised(d1);",
        "ins1DelCode":"DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1);",
        "ins1PreCode":"\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2); ",
        "ins2PreCode":"\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) assertFalse(d1.equals(d2)); assertTrue(d1 != d2);",
        "label":0
    },
    {
        "ins1AddCode":"try (JDBCSession session = DBUtils.openMetaSession(monitor, view, \"Load view source code\")) {",
        "ins1DelCode":"try (JDBCSession session = DBUtils.openMetaSession(monitor, view.getDataSource(), \"Load view source code\")) {",
        "ins1PreCode":"public static String getViewSource(DBRProgressMonitor monitor, GenericTable view) throws DBException { try (JDBCSession session = DBUtils.openMetaSession(monitor, view.getDataSource(), \"Load view source code\")) { DatabaseMetaData fbMetaData = session.getOriginal().getMetaData(); String source = (String) fbMetaData.getClass().getMethod(\"getViewSourceCode\", String.class).invoke(fbMetaData, view.getName());",
        "ins2PreCode":"public static String getTriggerSource(DBRProgressMonitor monitor, FireBirdTrigger trigger) throws DBException { try (JDBCSession session = DBUtils.openMetaSession(monitor, trigger.getDataSource(), \"Load trigger source code\")) { DatabaseMetaData fbMetaData = session.getOriginal().getMetaData(); String source = (String) fbMetaData.getClass().getMethod(\"getTriggerSourceCode\", String.class).invoke(fbMetaData, trigger.getName());",
        "label":1
    },
    {
        "ins1AddCode":"void callbackInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() {",
        "ins1DelCode":"public void callbackInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() {",
        "ins1PreCode":"public void callbackInvokeAndWhenHasResolvableGenericNonMatchShouldReturnNoResult() { GenericFactory<?> callbackInstance = mock(StringBuilderFactory.class); String argument = \"foo\";",
        "ins2PreCode":"public void callbackInvokeAndWhenLambdaMismatchShouldSwallowException() { GenericFactory<StringBuilder> callbackInstance = (s) -> { String argument = \"foo\";",
        "label":1
    },
    {
        "ins1AddCode":"Graph<Integer, String> undirectedGraph = GraphBuilder.undirected() .expectedNodeCount(NODE_COUNT) .build();",
        "ins1DelCode":"UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(config().expectedNodeCount(NODE_COUNT));",
        "ins1PreCode":"public void createUndirected_expectedNodeCount() { UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(config().expectedNodeCount(NODE_COUNT)); assertThat(undirectedGraph.addEdge(E12, N1, N2)).isTrue(); assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals( classUnderTest + \" from string must have the expected type\", classUnderTest, getActualClassName(concatenated)); assertTrue( classUnderTest + \" underlying bytes must match after balancing\", assertEquals( classUnderTest + \" balanced string must equal flat string\", testString, concatenated); assertEquals( classUnderTest + \" flat string must equal balanced string\", concatenated, testString); assertEquals( classUnderTest + \" balanced string must have same hash code as flat string\", testString.hashCode(), concatenated.hashCode());",
        "ins1DelCode":"assertEquals(classUnderTest + \" from string must have the expected type\", classUnderTest, getActualClassName(concatenated)); assertTrue(classUnderTest + \" underlying bytes must match after balancing\", assertTrue(classUnderTest + \" balanced string must equal flat string\", concatenated.equals(testString)); assertTrue(classUnderTest + \" flat string must equal balanced string\", testString.equals(concatenated)); assertEquals(classUnderTest + \" balanced string must have same hash code as flat string\", testString.hashCode(), concatenated.hashCode());",
        "ins1PreCode":"concatenated = concatenated.concat(ByteString.copyFrom(testBytes, i * pieceSize, pieceSize)); }  assertEquals(classUnderTest + \" from string must have the expected type\", classUnderTest, getActualClassName(concatenated)); assertTrue(classUnderTest + \" underlying bytes must match after balancing\", Arrays.equals(testBytes, concatenated.toByteArray())); ByteString testString = ByteString.copyFrom(testBytes); assertTrue(classUnderTest + \" balanced string must equal flat string\", concatenated.equals(testString)); assertTrue(classUnderTest + \" flat string must equal balanced string\", testString.equals(concatenated)); assertEquals(classUnderTest + \" balanced string must have same hash code as flat string\", testString.hashCode(), concatenated.hashCode());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType);",
        "ins1DelCode":"any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences);",
        "ins1PreCode":"any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete(); ",
        "ins2PreCode":"any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(5))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void forEachWileWithError() { final List<Object> list = new ArrayList<Object>();  Flowable.range(1, 5).concatWith(Flowable.<Integer>error(new TestException()))",
        "ins2PreCode":"public void forEachWileWithError() { final List<Object> list = new ArrayList<Object>(); Observable.range(1, 5).concatWith(Observable.<Integer>error(new TestException()))",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, xAxis, yAxis, renderer);",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer);",
        "ins1PreCode":"CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); assertEquals(xAxis, plot.getDomainAxisForDataset(0)); ",
        "ins2PreCode":"CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new DefaultCategoryItemRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); assertEquals(yAxis, plot.getRangeAxisForDataset(0));",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"Boolean[] booleans = new Boolean[] { Boolean.FALSE, Boolean.TRUE };",
        "ins1PreCode":"public static Collection<Object[]> inputs() { Boolean[] booleans = new Boolean[] { Boolean.FALSE, Boolean.TRUE }; String[] urls = new String[] { COLLECTION_NAME, FILE_NAME, UNKNOWN_NAME }; String[] methods = new String[] { \"GET\", \"POST\", \"HEAD\", \"TRACE\", \"PUT\", \"DELETE\",",
        "ins2PreCode":"public static Collection<Object[]> inputs() { Boolean[] booleans = new Boolean[] { Boolean.FALSE, Boolean.TRUE }; String[] urls = new String[] { COLLECTION_NAME, FILE_NAME, UNKNOWN_NAME }; String[] methods = new String[] { \"GET\", \"POST\", \"HEAD\", \"TRACE\", \"PUT\", \"DELETE\" };",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":" Observable<Integer> result = source.withLatestFrom(other, COMBINER);  TestObserverEx<Integer> to = new TestObserverEx<Integer>();  result.subscribe(to);",
        "ins2PreCode":"Observable<Integer> result = source.withLatestFrom(other, COMBINER); TestObserverEx<Integer> to = new TestObserverEx<Integer>(); result.subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"public final <R> Observable<R> flatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper,",
        "ins1DelCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper,",
        "ins1PreCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins2PreCode":"public final <R> Observable<R> switchMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); Objects.requireNonNull(mapper, \"mapper is null\");",
        "label":1
    },
    {
        "ins1AddCode":"public static Method getWriteMethod(Class<?> beanClass, String prop) Class<?> type = null;",
        "ins1DelCode":"public static Method getWriteMethod(Class beanClass, String prop) Class type = null;",
        "ins1PreCode":"public static Method getWriteMethod(Class beanClass, String prop) throws JasperException { Method method = null; Class type = null; try { java.beans.BeanInfo info",
        "ins2PreCode":"public static Method getReadMethod(Class beanClass, String prop) throws JasperException { Method method = null; Class type = null; try { java.beans.BeanInfo info",
        "label":1
    },
    {
        "ins1AddCode":"void testFindFileInSubdirectory() throws Exception { localEntry.setCitationKey(\"pdfInSubdirectory\"); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[citationkey].*\\\\\\\\.[extension]\", ',');",
        "ins1DelCode":"public void testFindFileInSubdirectory() throws Exception { localEntry.setCiteKey(\"pdfInSubdirectory\"); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');",
        "ins1PreCode":"public void testFindFileInSubdirectory() throws Exception {  BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');  ",
        "ins2PreCode":"public void testFindFileNonRecursive() throws Exception { BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\"); List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[bibtexkey].*\\\\\\\\.[extension]\", ',');",
        "label":1
    },
    {
        "ins1AddCode":"HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1DelCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1PreCode":"int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaRDD<LabeledPoint> testRDD = jsc.parallelize(LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache(); LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);",
        "ins1DelCode":"JavaRDD<LabeledPoint> testRDD = sc.parallelize(LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache(); LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);",
        "ins1PreCode":"double A = 0.0; double[] weights = {-1.5, 1.0e-2};  JavaRDD<LabeledPoint> testRDD = sc.parallelize(LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache(); List<LabeledPoint> validationData =",
        "ins2PreCode":"double A = 3.0; double[] weights = {10, 10}; JavaRDD<LabeledPoint> testRDD = sc.parallelize( LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 42, 0.1), 2).cache(); List<LabeledPoint> validationData =",
        "label":1
    },
    {
        "ins1AddCode":"public Long getRowCount(DBRProgressMonitor monitor)",
        "ins1DelCode":"public synchronized Long getRowCount(DBRProgressMonitor monitor)",
        "ins1PreCode":"public synchronized Long getRowCount(DBRProgressMonitor monitor) { if (rowCount != null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws Exception {",
        "ins1DelCode":"protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException {",
        "ins1PreCode":"protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> { assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {",
        "ins2PreCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> { assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {",
        "label":1
    },
    {
        "ins1AddCode":"doReturn(true).when(saveDatabaseAction).saveAs(any());",
        "ins1DelCode":"doNothing().when(saveDatabaseAction).saveAs(any());",
        "ins1PreCode":"public void saveAsShouldSetWorkingDirectory() { when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_BIBTEX_LIBRARY_LOCATION); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.of(file)); doNothing().when(saveDatabaseAction).saveAs(any());  saveDatabaseAction.saveAs();",
        "ins2PreCode":"public void saveAsShouldNotSetWorkingDirectoryIfNotSelected() { when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_BIBTEX_LIBRARY_LOCATION); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.empty()); doNothing().when(saveDatabaseAction).saveAs(any()); saveDatabaseAction.saveAs();",
        "label":1
    },
    {
        "ins1AddCode":"expected.remove(JstorFetcher.class); expected.remove(GoogleScholar.class);",
        "ins1DelCode":"",
        "ins1PreCode":"  expected.remove(ACMPortalFetcher.class);  expected.remove(PagedSearchBasedParserFetcher.class); expected.remove(PagedSearchBasedFetcher.class); ",
        "ins2PreCode":"assertEquals(expected, getClasses(fullTextFetchers)); assertEquals(expected, getClasses(fullTextFetchers)); assertEquals(expected, getClasses(fullTextFetchers));",
        "label":0
    },
    {
        "ins1AddCode":"IllegalArgumentException iae = new IllegalArgumentException(sm.getString(\"userMBean.destroyError.user\", username));",
        "ins1DelCode":"IllegalArgumentException iae = new IllegalArgumentException( \"Exception destroying user [\" + username + \"] MBean\");",
        "ins1PreCode":"MBeanUtils.destroyMBean(user); database.removeUser(user); } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException( \"Exception destroying user [\" + username + \"] MBean\"); iae.initCause(e); throw iae;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"when(view.getItems()).thenReturn(Collections.emptyList());",
        "ins1DelCode":"when(view.getItems()).thenReturn(Collections.<TopLevelItem>emptyList());",
        "ins1PreCode":"when(view.getOwner().getItemGroup()).thenReturn(parent); createMockAncestors(req, createAncestor(j, \"../..\"), createAncestor(view, \".\")); TopLevelItem i = createMockItem(parent, \"job/i/\"); when(view.getItems()).thenReturn(Collections.<TopLevelItem>emptyList()); String result = Functions.getRelativeLinkTo(i); assertEquals(\"/jenkins/job/i/\", result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\"));",
        "ins1PreCode":"assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such node 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\"));  assertThat(j.jenkins.getView(\"aNode1\"), nullValue());",
        "ins2PreCode":"assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such node 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); assertThat(j.jenkins.getView(\"aNode1\"), nullValue());",
        "label":1
    },
    {
        "ins1AddCode":"tgt = new CiManagement(); target.setCiManagement( tgt );",
        "ins1DelCode":"target.setCiManagement( tgt = new CiManagement() );",
        "ins1PreCode":"CiManagement tgt = target.getCiManagement(); if ( tgt == null ) { target.setCiManagement( tgt = new CiManagement() ); } mergeCiManagement( tgt, src, sourceDominant, context );",
        "ins2PreCode":"DistributionManagement tgt = target.getDistributionManagement(); if ( tgt == null ) { target.setDistributionManagement( tgt = new DistributionManagement() ); } mergeDistributionManagement( tgt, src, sourceDominant, context );",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new ObservableSource<Integer>() { @Override public void subscribe(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(0); observer.onNext(1);",
        "ins2PreCode":"new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(0); subscriber.onNext(1);",
        "label":0
    },
    {
        "ins1AddCode":"Project p = getProject(); if (p != null) { npArguments.put(\"rightGuillemot\", p.getProjectSettings().getRightGuillemot()); npArguments.put(\"leftGuillemot\", p.getProjectSettings().getLeftGuillemot()); }",
        "ins1DelCode":"",
        "ins1PreCode":"NotationProviderFactory2.getInstance().getNotationProvider( getNotationProviderType(), own, this); npArguments.put(\"pathVisible\", Boolean.valueOf(isPathVisible())); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); JavaRDD<Rating> data = jsc.parallelize(testData._1());",
        "ins1DelCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false); JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "ins1PreCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = sc.parallelize(testData._1());  MatrixFactorizationModel model = new ALS().setRank(features)",
        "ins2PreCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, true); JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features)",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs1 = Disposable.empty(); Disposable bs2 = Disposable.empty();",
        "ins1DelCode":"Disposable bs1 = Disposables.empty(); Disposable bs2 = Disposables.empty();",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1);  Disposable bs2 = Disposables.empty(); observer.onSubscribe(bs2); ",
        "ins2PreCode":"Flowable.empty().concatWith(new Single<Integer>() { @Override protected void subscribeActual(SingleObserver<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1); Disposable bs2 = Disposables.empty(); observer.onSubscribe(bs2);",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0);",
        "ins1DelCode":"assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0);",
        "ins1PreCode":" String result = res.toString();  assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString(); assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"void oneElement() { repository.addCustomAbbreviation(new Abbreviation(\"Long Name\", \"L. N.\")); assertEquals(1, repository.getCustomAbbreviations().size());",
        "ins1DelCode":"public void oneElement() { JournalAbbreviationRepository repository = new JournalAbbreviationRepository(); repository.addEntry(new Abbreviation(\"Long Name\", \"L. N.\")); assertEquals(1, repository.size()); assertFalse(repository.getAbbreviations().isEmpty());",
        "ins1PreCode":"public void oneElement() { JournalAbbreviationRepository repository = new JournalAbbreviationRepository(); repository.addEntry(new Abbreviation(\"Long Name\", \"L. N.\")); assertEquals(1, repository.size()); assertFalse(repository.getAbbreviations().isEmpty());  assertEquals(\"L. N.\", repository.getDefaultAbbreviation(\"Long Name\").orElse(\"WRONG\"));",
        "ins2PreCode":"public void oneElementWithShortestUniqueAbbreviation() { JournalAbbreviationRepository repository = new JournalAbbreviationRepository(); repository.addEntry(new Abbreviation(\"Long Name\", \"L. N.\", \"LN\")); assertEquals(1, repository.size()); assertFalse(repository.getAbbreviations().isEmpty()); assertEquals(\"L. N.\", repository.getDefaultAbbreviation(\"Long Name\").orElse(\"WRONG\"));",
        "label":1
    },
    {
        "ins1AddCode":"WebClient.Builder webClientBuilder, ControllerEndpointsSupplier controllerEndpointsSupplier) { Collection<ExposableWebEndpoint> webEndpoints = endpointDiscoverer.getEndpoints(); List<ExposableEndpoint<?>> allEndpoints = new ArrayList<>(); allEndpoints.addAll(webEndpoints); allEndpoints.addAll(controllerEndpointsSupplier.getEndpoints()); new EndpointMapping(\"/cloudfoundryapplication\"), webEndpoints, endpointMediaTypes, getCorsConfiguration(), securityInterceptor, new EndpointLinksResolver(allEndpoints));",
        "ins1DelCode":"WebClient.Builder webClientBuilder) { new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.getEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins1PreCode":"public CloudFoundryWebFluxEndpointHandlerMapping cloudFoundryWebFluxEndpointHandlerMapping( ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, WebClient.Builder webClientBuilder) { CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, PathMapper.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( webClientBuilder, this.applicationContext.getEnvironment()); return new CloudFoundryWebFluxEndpointHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.getEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins2PreCode":"public CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping( ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, RestTemplateBuilder restTemplateBuilder) { CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, PathMapper.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( restTemplateBuilder, this.applicationContext.getEnvironment()); return new CloudFoundryWebEndpointServletHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), discoverer.getEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "label":0
    },
    {
        "ins1AddCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart(",
        "ins2PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedBarChart(",
        "label":1
    },
    {
        "ins1AddCode":"target.setUrl( extrapolateChildUrl( src, context ) );",
        "ins1DelCode":"target.setUrl( appendPath( src, context ) );",
        "ins1PreCode":"} else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) ); }",
        "ins2PreCode":"} else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) ); }",
        "label":1
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { GangliaMeterRegistry registry = context.getBean(GangliaMeterRegistry.class);",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { .withUserConfiguration(BaseConfiguration.class).run((context) -> { SignalFxMeterRegistry registry = context.getBean(SignalFxMeterRegistry.class);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> subplot1 = (CategoryPlot) plot.getSubplots().get(0);",
        "ins1DelCode":"CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0);",
        "ins1PreCode":"CombinedRangeCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero());",
        "ins2PreCode":"CombinedRangeXYPlot<String> plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot<String> subplot1 = plot.getSubplots().get(0); NumberAxis xAxis = (NumberAxis) subplot1.getDomainAxis(); xAxis.setAutoRangeIncludesZero(!xAxis.getAutoRangeIncludesZero());",
        "label":0
    },
    {
        "ins1AddCode":"private void setCurrentSchema(DBRProgressMonitor monitor, String schemaName) throws DBCException { JDBCUtils.executeSQL(session, String.format(SET_CURRENT_SCHEMA, schemaName)); this.activeSchemaName = schemaName;",
        "ins1DelCode":"void setCurrentSchema(DBRProgressMonitor monitor, ExasolSchema object) throws DBCException { if (object == null) { log.debug(\"Null current schema\"); return; } JDBCUtils.executeSQL(session, String.format(SET_CURRENT_SCHEMA, object.getName())); this.activeSchemaName = object.getName();",
        "ins1PreCode":"void setCurrentSchema(DBRProgressMonitor monitor, ExasolSchema object) throws DBCException { if (object == null) { log.debug(\"Null current schema\"); return; } try (JDBCSession session = openSession(monitor, DBCExecutionPurpose.UTIL, \"Set active schema\")) { JDBCUtils.executeSQL(session, String.format(SET_CURRENT_SCHEMA, object.getName())); this.activeSchemaName = object.getName(); } catch (SQLException e) { throw new DBCException(e, getDataSource());",
        "ins2PreCode":"void setCurrentSchema(DBRProgressMonitor monitor, DB2Schema object) throws DBCException { if (object == null) { log.debug(\"Null current schema\"); return; } try (JDBCSession session = openSession(monitor, DBCExecutionPurpose.UTIL, \"Set active schema\")) { JDBCUtils.executeSQL(session, String.format(SET_CURRENT_SCHEMA, object.getName())); this.activeSchemaName = object.getName(); } catch (SQLException e) { throw new DBCException(e, getDataSource());",
        "label":1
    },
    {
        "ins1AddCode":"List<TestSubscriberEx<Long>> list = new ArrayList<>(100); TestSubscriberEx<Long> ts = new TestSubscriberEx<>(); List<Long> expected = new ArrayList<>();",
        "ins1DelCode":"List<TestSubscriberEx<Long>> list = new ArrayList<TestSubscriberEx<Long>>(100); TestSubscriberEx<Long> ts = new TestSubscriberEx<Long>(); List<Long> expected = new ArrayList<Long>();",
        "ins1PreCode":" Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);  List<TestSubscriberEx<Long>> list = new ArrayList<TestSubscriberEx<Long>>(100); for (int i = 0; i < 100; i++) { TestSubscriberEx<Long> ts = new TestSubscriberEx<Long>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) { expected.add((long)(i - 10));",
        "ins2PreCode":"Observable<Long> output = cached.observeOn(Schedulers.computation()); List<TestObserverEx<Long>> list = new ArrayList<TestObserverEx<Long>>(100); for (int i = 0; i < 100; i++) { TestObserverEx<Long> to = new TestObserverEx<Long>(); list.add(to); output.skip(i * 10).take(10).subscribe(to); } List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) { expected.add((long)(i - 10));",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"never_created: No such item \u2018never_created\u2019 exists.\"));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"never_created: No such job \\u2018never_created\\u2019 exists.\"));",
        "ins1PreCode":" assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job \\u2018never_created\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)); ",
        "ins2PreCode":"assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job \\u2018never_created\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>();",
        "ins1PreCode":"} });  TestSubscriber<String> ts = new TestSubscriber<String>(); m.subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"} }); TestObserver<String> to = new TestObserver<String>(); m.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(environment.acceptsProfiles(Profiles.of(\"foo\"))).isTrue();",
        "ins1DelCode":"assertThat(environment.acceptsProfiles(\"foo\")).isTrue();",
        "ins1PreCode":"ConfigurableEnvironment environment = new StandardEnvironment(); application.setEnvironment(environment); this.context = application.run(); assertThat(environment.acceptsProfiles(\"foo\")).isTrue();",
        "ins2PreCode":"ConfigurableEnvironment environment = new StandardEnvironment(); application.setEnvironment(environment); this.context = application.run(\"--spring.profiles.active=bar,spam\"); assertThat(environment.getActiveProfiles()).containsExactly(\"foo\", \"bar\", \"spam\");",
        "label":0
    },
    {
        "ins1AddCode":"List<TaskSegment> taskSegments = TaskSegment mergedSegment = new TaskSegment( false ); for ( TaskSegment taskSegment : taskSegments )",
        "ins1DelCode":"List<org.apache.maven.lifecycle.internal.TaskSegment> taskSegments = org.apache.maven.lifecycle.internal.TaskSegment mergedSegment = new org.apache.maven.lifecycle.internal.TaskSegment( false ); for ( org.apache.maven.lifecycle.internal.TaskSegment taskSegment : taskSegments )",
        "ins1PreCode":"PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException { List<org.apache.maven.lifecycle.internal.TaskSegment> taskSegments = lifeCycleTaskSegmentCalculator.calculateTaskSegments( session, Arrays.asList( tasks ) );  org.apache.maven.lifecycle.internal.TaskSegment mergedSegment = new org.apache.maven.lifecycle.internal.TaskSegment( false );  for ( org.apache.maven.lifecycle.internal.TaskSegment taskSegment : taskSegments ) { mergedSegment.getTasks().addAll( taskSegment.getTasks() );",
        "ins2PreCode":"PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException { for ( TaskSegment taskSegment : taskSegments ) List<TaskSegment> taskSegments = lifecycleTaskSegmentCalculator.calculateTaskSegments( session ); TaskSegment mergedSegment = new TaskSegment( false ); TaskSegment mergedSegment = new TaskSegment( false ); for ( TaskSegment taskSegment : taskSegments ) { mergedSegment.getTasks().addAll( taskSegment.getTasks() );",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue(); assertThat(graphAsMutableGraph.removeEdge(N1, N2)).isTrue(); assertThat(graphAsMutableGraph.removeEdge(N1, N2)).isFalse();",
        "ins1DelCode":"assertThat(graph.removeEdge(N1, N2)).isTrue(); assertThat(graph.removeEdge(N1, N2)).isFalse();",
        "ins1PreCode":"putEdge(N1, N2); assertThat(graph.successors(N1)).containsExactly(N2); assertThat(graph.predecessors(N2)).containsExactly(N1); assertThat(graph.removeEdge(N1, N2)).isTrue(); assertThat(graph.removeEdge(N1, N2)).isFalse(); assertThat(graph.successors(N1)).isEmpty(); assertThat(graph.predecessors(N2)).isEmpty();",
        "ins2PreCode":"putEdge(N1, N2); assertThat(graph.successors(N1)).containsExactly(N2); assertThat(graph.predecessors(N2)).containsExactly(N1); assertThat(graph.removeEdge(N1, N2)).isTrue(); assertThat(graph.removeEdge(N1, N2)).isFalse(); assertThat(graph.successors(N1)).isEmpty(); assertThat(graph.predecessors(N2)).isEmpty();",
        "label":1
    },
    {
        "ins1AddCode":"Map<ServiceType, List<EndpointDiagnostics>> endpoints = Collections.singletonMap(ServiceType.KV, Collections.singletonList(new EndpointDiagnostics(ServiceType.KV, EndpointState.CONNECTED, \"127.0.0.1\", \"127.0.0.1\", Optional.empty(), Optional.of(1234L), Optional.of(\"endpoint-1\")))); DiagnosticsResult diagnostics = new DiagnosticsResult(endpoints, \"test-sdk\", \"test-id\");",
        "ins1DelCode":"List<EndpointHealth> endpoints = Arrays.asList(new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-1\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null);",
        "ins1PreCode":"void couchbaseClusterIsUp() { Cluster cluster = mock(Cluster.class); CouchbaseHealthIndicator healthIndicator = new CouchbaseHealthIndicator(cluster); List<EndpointHealth> endpoints = Arrays.asList(new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-1\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics); Health health = healthIndicator.health();",
        "ins2PreCode":"void couchbaseClusterIsDown() { Cluster cluster = mock(Cluster.class); CouchbaseHealthIndicator healthIndicator = new CouchbaseHealthIndicator(cluster); new EndpointHealth(ServiceType.BINARY, LifecycleState.CONNECTED, new InetSocketAddress(0), new InetSocketAddress(0), 1234, \"endpoint-2\")); DiagnosticsReport diagnostics = new DiagnosticsReport(endpoints, \"test-sdk\", \"test-id\", null); given(cluster.diagnostics()).willReturn(diagnostics); Health health = healthIndicator.health();",
        "label":0
    },
    {
        "ins1AddCode":"void propertyWithSensitivePlaceholderResolved() {",
        "ins1DelCode":"public void propertyWithSensitivePlaceholderResolved() {",
        "ins1PreCode":"public void propertyWithSensitivePlaceholderResolved() { ConfigurableEnvironment environment = emptyEnvironment(); TestPropertyValues.of(\"my.foo: http://${bar.password}://hello\", \"bar.password: hello\").applyTo(environment);",
        "ins2PreCode":"public void propertyWithSensitivePlaceholderNotResolved() { ConfigurableEnvironment environment = emptyEnvironment(); TestPropertyValues.of(\"my.foo: http://${bar.password}://hello\").applyTo(environment);",
        "label":1
    },
    {
        "ins1AddCode":"String granularityU = getValue().toUpperCase(Locale.ENGLISH);",
        "ins1DelCode":"String granularityU = getValue().toUpperCase(Locale.US);",
        "ins1PreCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.US);  if (\"\".equals(granularityU)) {",
        "ins2PreCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.US); if (\"\".equals(granularityU)) {",
        "label":1
    },
    {
        "ins1AddCode":"final List<Throwable> list = new CopyOnWriteArrayList<>();",
        "ins1DelCode":"final List<Throwable> list = new CopyOnWriteArrayList<Throwable>();",
        "ins1PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsObservable() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list)); final RuntimeException e1 = new RuntimeException();",
        "ins2PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissions() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list)); final RuntimeException e1 = new RuntimeException();",
        "label":1
    },
    {
        "ins1AddCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"String s = 's'; char c = s; return c\")); assertEquals('s', exec(\"String s = 's'; char c = (char)s; return c\"));",
        "ins1DelCode":"assertEquals('s', exec(\"String s = 's'; (char)s\"));",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"String o = 'string'; short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"String o = null; short b = (short)o;\"));  assertEquals('s', exec(\"String s = 's'; (char)s\")); expectScriptThrows(ClassCastException.class, () -> exec(\"String o = 'string'; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"String o = null; char b = o;\"));",
        "ins2PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; short b = (short)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; char b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Boolean o = null; char b = o;\"));",
        "label":0
    },
    {
        "ins1AddCode":"void shouldNotApplyTypeHandlerToParamMap() {",
        "ins1DelCode":"public void shouldNotApplyTypeHandlerToParamMap() {",
        "ins1PreCode":"public void shouldNotApplyTypeHandlerToParamMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins2PreCode":"public void shouldGetAUserFromAnnotation() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.stroke, that.stroke)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.stroke, that.stroke)) {",
        "ins1PreCode":"if (!Arrays.equals(this.polygon, that.polygon)) { return false; } if (!ObjectUtils.equal(this.stroke, that.stroke)) { return false; }",
        "ins2PreCode":"if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!ObjectUtils.equal(this.stroke, that.stroke)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"void parseCombinesMultipleKeywordsFields() throws IOException {",
        "ins1DelCode":"public void parseCombinesMultipleKeywordsFields() throws IOException {",
        "ins1PreCode":"public void parseCombinesMultipleKeywordsFields() throws IOException { ParserResult result = parser.parse( new StringReader(\"@article{test,Keywords={Test},Keywords={Second Keyword},Keywords={Third Keyword}}\"));",
        "ins2PreCode":"public void parseRecognizesFieldValuesInQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Ed von Test\\\"}\"));",
        "label":1
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(-614962680001L, m.getLastMillisecond(cal)); m.getLastMillisecond((Calendar) null);",
        "ins1DelCode":"assertEquals(-614962680001L, m.getLastMillisecond(zone)); m.getLastMillisecond((TimeZone) null);",
        "ins1PreCode":"public void testGetLastMillisecondWithTimeZone() { Minute m = new Minute(1, 2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-614962680001L, m.getLastMillisecond(zone));   boolean pass = false; try { m.getLastMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "ins2PreCode":"public void testGetFirstMillisecondWithTimeZone() { Millisecond m = new Millisecond(500, 50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-623289609500L, m.getFirstMillisecond(zone)); boolean pass = false; try { m.getFirstMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "label":1
    },
    {
        "ins1AddCode":"void completeBeginnigOfSecondWordReturnsWholeFieldValue() { database.insertEntry(entry); Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"val\")));",
        "ins1DelCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"val\")));",
        "ins1PreCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"test value\"), result);",
        "ins2PreCode":"public void completePartOfWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"lue\"))); assertEquals(Collections.singletonList(\"test value\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Long> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Long> ts = new TestSubscriber<Long>();",
        "ins1PreCode":"} }).take(SIZE);  TestSubscriber<Long> ts = new TestSubscriber<Long>();  Flowable.combineLatest(timer, Flowable.<Integer> never(), new BiFunction<Long, Integer, Long>() {",
        "ins2PreCode":"} }).take(SIZE); TestObserver<Long> to = new TestObserver<Long>(); Observable.combineLatest(timer, Observable.<Integer> never(), new BiFunction<Long, Integer, Long>() {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), entry.getField(StandardField.FILE));",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"1-4~#nov#\"), entry.getField(StandardField.DATE));",
        "label":1
    },
    {
        "ins1AddCode":"testString.copyTo(destination, sourceOffset, destinationOffset, length);",
        "ins1DelCode":"TEST_STRING.copyTo(destination, sourceOffset, destinationOffset, length);",
        "ins1PreCode":"int length = 100; byte[] destination = new byte[destinationOffset + length]; int sourceOffset = 213; TEST_STRING.copyTo(destination, sourceOffset, destinationOffset, length); boolean stillEqual = true; for (int i = 0; stillEqual && i < length; ++i) {",
        "ins2PreCode":"int length = 100; byte[] destination = new byte[destinationOffset + length]; int sourceOffset = 213; stringUnderTest.copyTo(destination, sourceOffset, destinationOffset, length); boolean stillEqual = true; for (int i = 0; stillEqual && i < length; ++i) {",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void merge10000SyncStreamOf10() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(10000, 10).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1000000SyncStreamOf1() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(1000000, 1).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":".set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), true) .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 10000L);",
        "ins1DelCode":".set(\"spark.memory.offHeap.enabled\", \"true\") .set(\"spark.memory.offHeap.size\", \"10000\");",
        "ins1PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"true\") .set(\"spark.memory.offHeap.size\", \"10000\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void shouldLimitResultsUsingMapperClass() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1DelCode":"public void shouldLimitResultsUsingMapperClass() throws Exception { SqlSession session = sqlMapper.openSession(); try { } finally { session.close();",
        "ins1PreCode":"public void shouldLimitResultsUsingMapperClass() throws Exception { SqlSession session = sqlMapper.openSession(); try { BlogMapper mapper = session.getMapper(BlogMapper.class); List<Map> posts = mapper.selectAllPosts(new RowBounds(0, 2), null); assertEquals(2, posts.size()); assertEquals(1, posts.get(0).get(\"ID\")); assertEquals(2, posts.get(1).get(\"ID\")); } finally { session.close(); }",
        "ins2PreCode":"public void shouldOffsetAndLimitResultsUsingMapperClass() throws Exception { SqlSession session = sqlMapper.openSession(); try { BlogMapper mapper = session.getMapper(BlogMapper.class); List<Map> posts = mapper.selectAllPosts(new RowBounds(2, 3)); assertEquals(3, posts.size()); assertEquals(3, posts.get(0).get(\"ID\")); assertEquals(4, posts.get(1).get(\"ID\")); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"NextSubscriber<Integer> no = new NextSubscriber<>();",
        "ins1DelCode":"NextSubscriber<Integer> no = new NextSubscriber<Integer>();",
        "ins1PreCode":"public void nextObserverOnNext() throws Exception { NextSubscriber<Integer> no = new NextSubscriber<Integer>();  no.setWaiting();",
        "ins2PreCode":"public void nextObserverOnNext() throws Exception { NextObserver<Integer> no = new NextObserver<Integer>(); no.setWaiting();",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series = new XYSeries<>(\"S1\"); XYSeriesCollection<String> dataset = new XYSeriesCollection<>(series);",
        "ins1DelCode":"XYSeries series = new XYSeries(\"S1\"); XYSeriesCollection dataset = new XYSeriesCollection(series);",
        "ins1PreCode":"public void testFindYValue() { XYSeries series = new XYSeries(\"S1\"); XYSeriesCollection dataset = new XYSeriesCollection(series); assertTrue(Double.isNaN(DatasetUtils.findYValue(dataset, 0, 100.0))); ",
        "ins2PreCode":"public void testFindYValueNonSorted() { XYSeries series = new XYSeries(\"S1\", false); XYSeriesCollection dataset = new XYSeriesCollection(series); assertTrue(Double.isNaN(DatasetUtils.findYValue(dataset, 0, 100.0)));",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(final Observer<? super Event> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"*** Subscribing to EventStream ***\"); subscribeCounter.incrementAndGet();",
        "ins2PreCode":"@Override public void subscribe(final Subscriber<? super Event> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); System.out.println(\"*** Subscribing to EventStream ***\"); subscribeCounter.incrementAndGet();",
        "label":0
    },
    {
        "ins1AddCode":"void liveReloadDisabled() throws Exception {",
        "ins1DelCode":"public void liveReloadDisabled() throws Exception {",
        "ins1PreCode":"public void liveReloadDisabled() throws Exception { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.livereload.enabled\", false);",
        "ins2PreCode":"public void restartDisabled() throws Exception { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.restart.enabled\", false);",
        "label":1
    },
    {
        "ins1AddCode":"Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI());",
        "ins1DelCode":"Path auxFile = Paths.get(AuxParserTest.class.getResource(\"paper.aux\").toURI());",
        "ins1PreCode":"public void containsReturnsTrueForEntryInAux() throws Exception { Path auxFile = Paths.get(AuxParserTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor()); BibEntry inAux = new BibEntry();",
        "ins2PreCode":"public void containsReturnsTrueForEntryNotInAux() throws Exception { Path auxFile = Paths.get(AuxParserTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor()); BibEntry notInAux = new BibEntry();",
        "label":1
    },
    {
        "ins1AddCode":"BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>(true) { private static final long serialVersionUID = -9081211580719235896L; @Override void truncate() { } };",
        "ins1DelCode":"BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(true);",
        "ins1PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(true); buf.addLast(new Node(1, 0)); buf.addLast(new Node(2, 1));",
        "ins2PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(false); buf.addLast(new Node(1, 0)); buf.addLast(new Node(2, 1));",
        "label":0
    },
    {
        "ins1AddCode":"if (command.getProperties().size() > 1 || command.getProperty(DBConstants.PROP_ID_DESCRIPTION) == null) {",
        "ins1DelCode":"if (command.getProperties().size() > 1 || command.getProperty(\"description\") == null) {",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"description\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \"); query.append(command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL)).append(\" \");",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"comment\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \"); query.append(command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL)).append(\" \");",
        "label":0
    },
    {
        "ins1AddCode":"this.uriTemplateHandler, this.errorHandler, this.basicAuthentication,",
        "ins1DelCode":"this.uriTemplateHandler, this.errorHandler, this.basicAuthorization,",
        "ins1PreCode":"\"RestTemplateCustomizers must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, Collections.unmodifiableSet(new LinkedHashSet<RestTemplateCustomizer>( restTemplateCustomizers)),",
        "ins2PreCode":"Assert.notNull(customizers, \"RestTemplateCustomizers must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, Collection<? extends RestTemplateCustomizer> customizers) { append(this.restTemplateCustomizers, customizers),",
        "label":1
    },
    {
        "ins1AddCode":"new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 1, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 2, 0, 0)); new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0, 0); validateChunks(TEST_APP, 0, 0, 0, blockMeta, new int[] {4, 7}, new int[][] {{0}, {1, 2}});",
        "ins1DelCode":"new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 2, 0, 0)); new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 7}, new int[][] {{0}, {1, 2}});",
        "ins1PreCode":"useTestFiles(true, false); RemoteBlockPushResolver.PushBlockStreamCallback callback1 = (RemoteBlockPushResolver.PushBlockStreamCallback) pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); RemoteBlockPushResolver.AppShufflePartitionInfo partitionInfo = callback1.getPartitionInfo();  TestMergeShuffleFile testIndexFile = (TestMergeShuffleFile) partitionInfo.getIndexFile(); testIndexFile.close(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); callback2.onData(callback2.getID(), ByteBuffer.wrap(new byte[5]));   callback2.onComplete(callback2.getID()); assertEquals(\"index position\", 16, testIndexFile.getPos());  testIndexFile.restore(); StreamCallbackWithID callback3 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 2, 0, 0)); callback3.onData(callback3.getID(), ByteBuffer.wrap(new byte[2])); callback3.onComplete(callback3.getID()); assertEquals(\"index position\", 24, testIndexFile.getPos()); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); validateMergeStatuses(statuses, new int[] {0}, new long[] {11}); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 7}, new int[][] {{0}, {1, 2}});",
        "ins2PreCode":"useTestFiles(true, false); RemoteBlockPushResolver.PushBlockStreamCallback callback1 = (RemoteBlockPushResolver.PushBlockStreamCallback) pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); RemoteBlockPushResolver.AppShufflePartitionInfo partitionInfo = callback1.getPartitionInfo(); TestMergeShuffleFile testIndexFile = (TestMergeShuffleFile) partitionInfo.getIndexFile(); testIndexFile.close(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); callback2.onData(callback2.getID(), ByteBuffer.wrap(new byte[5])); callback2.onComplete(callback2.getID()); assertEquals(\"index position\", 16, testIndexFile.getPos()); testIndexFile.restore(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); assertEquals(\"index position\", 24, testIndexFile.getPos()); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); validateMergeStatuses(statuses, new int[] {0}, new long[] {9}); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "label":1
    },
    {
        "ins1AddCode":"socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear();",
        "ins1DelCode":"socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear();",
        "ins1PreCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try { getEndpoint().getHandler().release(this); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.handlerRelease\"), e); } } try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) { getSocket().close(true); } socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear(); if (getEndpoint().running && !getEndpoint().paused) { if (nioChannels == null || !nioChannels.push(getSocket())) { getSocket().free(); } } } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.channelCloseFail\"), e); } } finally { reset(NioChannel.CLOSED_NIO_CHANNEL); } try { SendfileData data = getSendfileData(); if (data != null && data.fchannel != null && data.fchannel.isOpen()) { data.fchannel.close(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.sendfile.closeError\"), e); } }",
        "ins2PreCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try { getEndpoint().getHandler().release(this); } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.handlerRelease\"), e); } } try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) { getSocket().close(true); } socketBufferHandler = SocketBufferHandler.EMPTY; nonBlockingWriteBuffer.clear(); if (getEndpoint().running && !getEndpoint().paused) { if (nioChannels == null || !nioChannels.push(getSocket())) { getSocket().free(); } } } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.debug.channelCloseFail\"), e); } } finally { reset(Nio2Channel.CLOSED_NIO2_CHANNEL); } try { SendfileData data = getSendfileData(); if (data != null && data.fchannel != null && data.fchannel.isOpen()) { data.fchannel.close(); } } catch (Throwable e) { ExceptionUtils.handleThrowable(e); if (log.isDebugEnabled()) { log.error(sm.getString(\"endpoint.sendfile.closeError\"), e); } }",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>(); TestSubscriber<List<Integer>> ts = new TestSubscriber<>();",
        "ins1DelCode":"return new ArrayList<Integer>(); TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();",
        "ins1PreCode":"Supplier<List<Integer>> as = new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();  Flowable.range(1, 100000).hide()",
        "ins2PreCode":"Supplier<List<Integer>> as = new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); Flowable.range(1, 100000).hide()",
        "label":1
    },
    {
        "ins1AddCode":"verify(session, Mockito.never()).write(any(CoapMessage.class));",
        "ins1DelCode":"Mockito.verifyZeroInteractions(session);",
        "ins1PreCode":"verify(writeController).callWriteNextFilter(writeRequest);   Mockito.verifyZeroInteractions(session);",
        "ins2PreCode":"verify(writeController).callWriteNextFilter(writeRequest); Mockito.verifyZeroInteractions(session);",
        "label":1
    },
    {
        "ins1AddCode":"spark = SparkSession.builder() .master(\"local\") .appName(\"JavaLogisticRegressionSuite\") .getOrCreate(); jsc = new JavaSparkContext(spark.sparkContext()); dataset = spark.createDataFrame(datasetRDD, LabeledPoint.class);",
        "ins1DelCode":"jsc = new JavaSparkContext(\"local\", \"JavaLogisticRegressionSuite\"); jsql = new SQLContext(jsc); dataset = jsql.createDataFrame(datasetRDD, LabeledPoint.class);",
        "ins1PreCode":"public void setUp() { jsc = new JavaSparkContext(\"local\", \"JavaLogisticRegressionSuite\"); jsql = new SQLContext(jsc); List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2); dataset = jsql.createDataFrame(datasetRDD, LabeledPoint.class); dataset.registerTempTable(\"dataset\");",
        "ins2PreCode":"public void setUp() { jsc = new JavaSparkContext(\"local\", \"JavaLinearRegressionSuite\"); jsql = new SQLContext(jsc); List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2); dataset = jsql.createDataFrame(datasetRDD, LabeledPoint.class); dataset.registerTempTable(\"dataset\");",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testLangRawWithMapper() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); Mapper m = sqlSession.getMapper(Mapper.class); List<Name> answer = m.selectRawWithMapper(p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testLangVelocityWithMapper() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); Mapper m = sqlSession.getMapper(Mapper.class); List<Name> answer = m.selectVelocityWithMapper(p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb; q =\\t1\\t\")); Assert.assertEquals(Q1_000, actual.get(0).getQuality(), 0.0001);",
        "ins1DelCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.500\")); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testSingle12() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.500\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testSingle13() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5009\")); Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "label":0
    },
    {
        "ins1AddCode":"seriesFillPaint = this.defaultFillPaint;",
        "ins1DelCode":"seriesFillPaint = this.baseFillPaint;",
        "ins1PreCode":"} } if (seriesFillPaint == null) { seriesFillPaint = this.baseFillPaint; } return seriesFillPaint;",
        "ins2PreCode":"} } if (seriesOutlinePaint == null) { seriesOutlinePaint = this.baseOutlinePaint; } return seriesOutlinePaint;",
        "label":1
    },
    {
        "ins1AddCode":"Diagram diag = ((LayerPerspective) lay).getDiagram(); LOG.log(Level.WARNING, \"ActivityDiagramRenderer getFigNodeFor unexpected node \" LOG.log(Level.FINE, \"ActivityDiagramRenderer getFigNodeFor {0}\", result); return result;",
        "ins1DelCode":"Diagram diag = ((LayerPerspective) lay).getDiagram(); LOG.warn(\"ActivityDiagramRenderer getFigNodeFor unexpected node \" LOG.debug(\"ActivityDiagramRenderer getFigNodeFor \" + result); return result;",
        "ins1PreCode":"&& ((UMLDiagram) diag).doesAccept(node)) { result = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.warn(\"ActivityDiagramRenderer getFigNodeFor unexpected node \" + node); return null; } LOG.debug(\"ActivityDiagramRenderer getFigNodeFor \" + result); lay.add(result); return result;",
        "ins2PreCode":"&& ((UMLDiagram) diag).doesAccept(node)) { result = (FigNode) ((UMLDiagram) diag).drop(node, null); } else { LOG.warn(\"SequenceDiagramRenderer getFigNodeFor unexpected node \" + node); return null; } LOG.debug(\"SequenceDiagramRenderer getFigNodeFor \" + result); lay.add(result); return result;",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void tryTerminateConsumerCompletableObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerEmitterTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"spark.createDataFrame(data, (new StructType()).add(group.toStructField()));",
        "ins1DelCode":"jsql.createDataFrame(data, (new StructType()).add(group.toStructField()));",
        "ins1PreCode":");  Dataset<Row> dataset = jsql.createDataFrame(data, (new StructType()).add(group.toStructField()));  VectorSlicer vectorSlicer = new VectorSlicer()",
        "ins2PreCode":"); Dataset<Row> dataset = spark.createDataFrame(data, (new StructType()).add(group.toStructField())); VectorSlicer vectorSlicer = new VectorSlicer()",
        "label":0
    },
    {
        "ins1AddCode":"LOG.log(Level.WARNING, \"While calling targetRemoved for \" + targetEvent + \" in \" + listeners[i + 1] + \" an error is thrown.\", e); targetEvent \" in \" listeners[i + 1] \" an error is thrown.\",",
        "ins1DelCode":"LOG.warn(\"While calling targetRemoved for \" + targetEvent + \" in \" + listeners[i + 1] + \" an error is thrown.\", e);",
        "ins1PreCode":".targetRemoved(targetEvent); } } catch (RuntimeException e) { LOG.warn(\"While calling targetRemoved for \" + targetEvent + \" in \" + listeners[i + 1] + \" an error is thrown.\", e);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(state, \"state\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(state, \"state\");",
        "ins1PreCode":"AxisState state) {   ParamChecks.nullNotPermitted(state, \"state\");  if ((label == null) || (label.equals(\"\"))) {",
        "ins2PreCode":"RectangleEdge edge, AxisState state) { ParamChecks.nullNotPermitted(state, \"state\"); if (label == null) {",
        "label":1
    },
    {
        "ins1AddCode":"subscribers = RxJavaPlugins.onSubscribe(this, subscribers);",
        "ins1DelCode":"",
        "ins1PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return; }",
        "ins2PreCode":"public void subscribe(Subscriber<? super T>[] subscribers) { if (!validate(subscribers)) { return; }",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleWeb.class)).isFalse();",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(1.0, series.getY(0)); assertEquals(2.0, series.getY(1));",
        "ins1DelCode":"assertEquals(new Double(1.0), series.getY(0)); assertEquals(new Double(2.0), series.getY(1));",
        "ins1PreCode":"XYSeries series = new XYSeries(\"Series\", true, true); series.addOrUpdate(1.0, 1.0); series.addOrUpdate(1.0, 2.0); assertEquals(new Double(1.0), series.getY(0)); assertEquals(new Double(2.0), series.getY(1)); assertEquals(2, series.getItemCount());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void checkAnyPermissionThrowsIfPermissionIsMissing() {",
        "ins1DelCode":"public void checkAnyPermissionThrowsIfPermissionIsMissing() throws Exception {",
        "ins1PreCode":"public void checkAnyPermissionThrowsIfPermissionIsMissing() throws Exception { Jenkins jenkins = r.jenkins; jenkins.setSecurityRealm(r.createDummySecurityRealm());",
        "ins2PreCode":"public void checkAnyPermissionThrowsIfMissingMoreThanOne() throws Exception { Jenkins jenkins = r.jenkins; jenkins.setSecurityRealm(r.createDummySecurityRealm());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertThat(request.requests().get(1).getRequest().types()[0], equalTo(\"type1\")); assertThat(request.requests().get(2).getRequest().types()[0], equalTo(\"type2\")); assertThat(request.requests().get(2).getRequest().types()[1], equalTo(\"type1\"));",
        "ins1PreCode":"assertThat(request.requests().get(0).getRequest().preference(), nullValue()); assertThat(request.requests().get(1).getRequest().indices()[0], equalTo(\"test2\")); assertThat(request.requests().get(1).getRequest().indices()[1], equalTo(\"test3\")); assertThat(request.requests().get(1).getRequest().types()[0], equalTo(\"type1\")); assertThat(request.requests().get(1).getRequest().requestCache(), nullValue()); assertThat(request.requests().get(1).getRequest().preference(), equalTo(\"_local\")); assertThat(request.requests().get(2).getRequest().indices()[0], equalTo(\"test4\")); assertThat(request.requests().get(2).getRequest().indices()[1], equalTo(\"test1\")); assertThat(request.requests().get(2).getRequest().types()[0], equalTo(\"type2\")); assertThat(request.requests().get(2).getRequest().types()[1], equalTo(\"type1\")); assertThat(request.requests().get(2).getRequest().routing(), equalTo(\"123\")); assertNotNull(request.requests().get(0).getScript());",
        "ins2PreCode":"assertThat(request.requests().get(0).getRequest().preference(), nullValue()); assertThat(request.requests().get(0).getRequest().indices()[0], equalTo(\"test0\")); assertThat(request.requests().get(0).getRequest().indices()[1], equalTo(\"test1\")); assertThat(request.requests().get(0).getRequest().indices()[0], equalTo(\"test0\")); assertThat(request.requests().get(0).getRequest().requestCache(), equalTo(true)); assertThat(request.requests().get(0).getRequest().preference(), nullValue()); assertThat(request.requests().get(0).getRequest().indices()[0], equalTo(\"test0\")); assertThat(request.requests().get(0).getRequest().indices()[1], equalTo(\"test1\")); assertThat(request.requests().get(0).getRequest().indices()[0], equalTo(\"test0\")); assertThat(request.requests().get(0).getRequest().indices()[1], equalTo(\"test1\")); assertThat(request.requests().get(0).getRequest().indices()[1], equalTo(\"test1\")); assertNotNull(request.requests().get(0).getScript());",
        "label":0
    },
    {
        "ins1AddCode":"environment.getPropertySources().addFirst( new MapPropertySource(\"foo\", Collections.singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst( new MapPropertySource(\"far\", Collections.singletonMap(\"far\", \"far\"))); sources.addLast( new MapPropertySource(\"baz\", Collections.singletonMap(\"baz\", \"barf\")));",
        "ins1DelCode":"environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.<String, Object>singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst(new MapPropertySource(\"far\", Collections.<String, Object>singletonMap(\"far\", \"far\"))); sources.addLast(new MapPropertySource(\"baz\", Collections.<String, Object>singletonMap(\"baz\", \"barf\")));",
        "ins1PreCode":"public void fromPropertySourceShouldFlattenPropertySources() throws Exception { StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.<String, Object>singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst(new MapPropertySource(\"far\", Collections.<String, Object>singletonMap(\"far\", \"far\"))); MutablePropertySources sources = new MutablePropertySources(); sources.addFirst(new PropertySource<Environment>(\"env\", environment) {  @Override public String getProperty(String key) { return this.source.getProperty(key); }  }); sources.addLast(new MapPropertySource(\"baz\", Collections.<String, Object>singletonMap(\"baz\", \"barf\"))); Iterable<ConfigurationPropertySource> configurationSources = ConfigurationPropertySources .from(sources);",
        "ins2PreCode":"public void shouldFlattenEnvironment() throws Exception { StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.<String, Object>singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst(new MapPropertySource(\"far\", Collections.<String, Object>singletonMap(\"far\", \"far\"))); MutablePropertySources sources = new MutablePropertySources(); sources.addFirst(new PropertySource<Environment>(\"env\", environment) { @Override public String getProperty(String key) { return this.source.getProperty(key); } }); sources.addLast(new MapPropertySource(\"baz\", Collections.<String, Object>singletonMap(\"baz\", \"barf\"))); assertThat(configurationSources.iterator()).hasSize(5); sources);",
        "label":1
    },
    {
        "ins1AddCode":"Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList(",
        "ins1DelCode":"scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList(",
        "ins1PreCode":"int iterations = 15; int users = 80; int products = 160; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); ",
        "ins2PreCode":"int iterations = 15; int users = 100; int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false);",
        "label":1
    },
    {
        "ins1AddCode":"List<ModelObject> itemList = newRuns(1, 10);",
        "ins1DelCode":"List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10));",
        "ins1PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList); ",
        "ins2PreCode":"public void test_newerThan_near_newest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 8L, null); List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2));",
        "ins1DelCode":"JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });",
        "ins1PreCode":"Arrays.asList(9,10,11));  JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });  JavaTestUtils.attachTestOutputStream(transformed);",
        "ins2PreCode":"Arrays.asList(9, 10, 11)); JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2)); JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); public void testTransform() { JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); List<List<Integer>> expected = Arrays.asList( public void testTransform() { public void testTransform() { JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2)); } } } } JavaTestUtils.attachTestOutputStream(transformed);",
        "label":0
    },
    {
        "ins1AddCode":"ExceptionUtils.handleThrowable(t);",
        "ins1DelCode":"",
        "ins1PreCode":"} else log.error(\"StoreConfig mbean not registered\" + sname); } catch (Throwable t) { log.error(t); } ",
        "ins2PreCode":"} else log.error(\"StoreConfig mbean not registered\" + sname); } catch (Throwable t) { log.error(t); }",
        "label":1
    },
    {
        "ins1AddCode":"if (isDisposed()) { Throwable e = error; if (e != null) { throw ExceptionHelper.wrapOrThrow(e); } return false; } while (!done && queue.isEmpty() && !isDisposed()) {",
        "ins1DelCode":"while (!done && queue.isEmpty()) {",
        "ins1PreCode":"BlockingHelper.verifyNonBlocking(); lock.lock(); try { while (!done && queue.isEmpty()) { condition.await(); }",
        "ins2PreCode":"BlockingHelper.verifyNonBlocking(); lock.lock(); try { while (!done && queue.isEmpty()) { condition.await(); }",
        "label":1
    },
    {
        "ins1AddCode":"\"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Byte.class.getCanonicalName());",
        "ins1DelCode":"\"def [\" + value.getClass().getCanonicalName() + \"] to \" + Byte.class.getCanonicalName());",
        "ins1PreCode":"return ((Number)value).byteValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Byte.class.getCanonicalName()); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset0, new CategoryAxis(\"x\"),",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"),",
        "ins1PreCode":"dataset1.addValue(24.0, \"R4\", \"C1\"); dataset1.addValue(25.0, \"R5\", \"C1\"); CategoryStepRenderer r = new CategoryStepRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, dataset1);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void subscribeActual(Observer<? super Observable<T>> downstream) { downstream, downstream, source.subscribe(new WindowSkipObserver<T>(downstream,",
        "ins1DelCode":"public void subscribeActual(Observer<? super Observable<T>> t) { SerializedObserver<Observable<T>> actual = new SerializedObserver<Observable<T>>(t); actual, actual, source.subscribe(new WindowSkipObserver<T>(actual,",
        "ins1PreCode":"public void subscribeActual(Observer<? super Observable<T>> t) { SerializedObserver<Observable<T>> actual = new SerializedObserver<Observable<T>>(t);  if (timespan == timeskip) { if (maxSize == Long.MAX_VALUE) { source.subscribe(new WindowExactUnboundedObserver<T>( actual, timespan, unit, scheduler, bufferSize)); return; } source.subscribe(new WindowExactBoundedObserver<T>( actual, timespan, unit, scheduler, bufferSize, maxSize, restartTimerOnMaxSize)); return; } source.subscribe(new WindowSkipObserver<T>(actual, timespan, timeskip, unit, scheduler.createWorker(), bufferSize));",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super Flowable<T>> s) { SerializedSubscriber<Flowable<T>> actual = new SerializedSubscriber<Flowable<T>>(s); if (timespan == timeskip) { if (maxSize == Long.MAX_VALUE) { source.subscribe(new WindowExactUnboundedSubscriber<T>( actual, timespan, unit, scheduler, bufferSize)); return; } source.subscribe(new WindowExactBoundedSubscriber<T>( actual, timespan, unit, scheduler, bufferSize, maxSize, restartTimerOnMaxSize)); return; } source.subscribe(new WindowSkipSubscriber<T>(actual, timespan, timeskip, unit, scheduler.createWorker(), bufferSize));",
        "label":1
    },
    {
        "ins1AddCode":"setState(355); switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) { setState(353); setState(354);",
        "ins1DelCode":"setState(358); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { setState(356); setState(357);",
        "ins1PreCode":"PostdotContext _localctx = new PostdotContext(_ctx, getState()); enterRule(_localctx, 40, RULE_postdot); try { setState(358); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(356); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(357); fieldaccess(); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"BibEntry entry = entries.get(0); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(\"journal\")); entry.getField(\"title\")); assertEquals(Optional.of(\"4\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"3\"), entry.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), entry.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), entry.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(\"author\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); entry.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(\"abstract\"));",
        "ins1DelCode":"BibEntry a = entries.get(0); assertEquals(\"article\", a.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), a.getField(\"journal\")); a.getField(\"title\")); assertEquals(Optional.of(\"4\"), a.getField(\"volume\")); assertEquals(Optional.of(\"3\"), a.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), a.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), a.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), a.getField(\"author\")); assertEquals(Optional.of(\"2006\"), a.getField(\"year\")); a.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), a.getField(\"abstract\"));",
        "ins1PreCode":"List<BibEntry> entries = importer.importDatabase(file, StandardCharsets.UTF_8).getDatabase().getEntries();  assertEquals(1, entries.size()); BibEntry a = entries.get(0); assertEquals(\"article\", a.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), a.getField(\"journal\")); assertEquals(Optional.of(\"Improving Urban Road Extraction in High-Resolution \" + \"Images Exploiting Directional Filtering, Perceptual \" + \"Grouping, and Simple Topological Concepts\"), a.getField(\"title\")); assertEquals(Optional.of(\"4\"), a.getField(\"volume\")); assertEquals(Optional.of(\"3\"), a.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), a.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), a.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), a.getField(\"author\")); assertEquals(Optional.of(\"2006\"), a.getField(\"year\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), a.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), a.getField(\"abstract\"));",
        "ins2PreCode":"List<BibEntry> entries = importer.importDatabase(file, StandardCharsets.UTF_8).getDatabase().getEntries(); assertEquals(1, entries.size()); BibEntry a = entries.get(0); assertEquals(\"article\", a.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), a.getField(\"journal\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), \"Improving Urban Road Extraction in High-Resolution Images Exploiting Directional Filtering, Perceptual Grouping, and Simple Topological Concepts\"), a.getField(\"title\")); assertEquals(Optional.of(\"4\"), a.getField(\"volume\")); assertEquals(Optional.of(\"3\"), a.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), a.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), a.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), a.getField(\"author\")); assertEquals(Optional.of(\"2006\"), a.getField(\"year\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), a.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), a.getField(\"abstract\"));",
        "label":1
    },
    {
        "ins1AddCode":"Context ctx = tomcat.addContext(\"\", null);",
        "ins1DelCode":"Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));  Bug49528Servlet servlet = new Bug49528Servlet();",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); Bug49567Servlet servlet = new Bug49567Servlet();",
        "label":1
    },
    {
        "ins1AddCode":"public void testPerformExportForSingleAuthor(@TempDirectory.TempDir Path testFolder) throws Exception { Path path = testFolder.resolve(\"ThisIsARandomlyNamedFile\"); exportFormat.export(databaseContext, path, charset, entries); List<String> lines = Files.readAllLines(path); \"10,\\\"\\\",\\\"\\\",\\\"Someone, Van Something\\\",\\\"\\\",\\\"\\\",,,\\\"\\\",\\\"\\\",,\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\"\", lines.get(1));",
        "ins1DelCode":"public void testPerformExportForSingleAuthor() throws Exception { File tmpFile = testFolder.newFile(); exportFormat.export(databaseContext, tmpFile.toPath(), charset, entries); List<String> lines = Files.readAllLines(tmpFile.toPath()); \"10,\\\"\\\",\\\"\\\",\\\"Someone, Van Something\\\",\\\"\\\",\\\"\\\",,,\\\"\\\",\\\"\\\",,\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\",\\\"\\\"\", lines.get(1));",
        "ins1PreCode":"public void testPerformExportForSingleAuthor() throws Exception { File tmpFile = testFolder.newFile(); BibEntry entry = new BibEntry(); entry.setField(\"author\", \"Someone, Van Something\"); List<BibEntry> entries = Arrays.asList(entry);  exportFormat.export(databaseContext, tmpFile.toPath(), charset, entries);  List<String> lines = Files.readAllLines(tmpFile.toPath()); assertEquals(2, lines.size()); assertEquals(",
        "ins2PreCode":"public void testPerformExportForMultipleAuthors() throws Exception { File tmpFile = testFolder.newFile(); BibEntry entry = new BibEntry(); entry.setField(\"author\", \"von Neumann, John and Smith, John and Black Brown, Peter\"); List<BibEntry> entries = Arrays.asList(entry); exportFormat.export(databaseContext, tmpFile.toPath(), charset, entries); List<String> lines = Files.readAllLines(tmpFile.toPath()); assertEquals(2, lines.size()); assertEquals(",
        "label":1
    },
    {
        "ins1AddCode":"xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS))) {",
        "ins1DelCode":"xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) {",
        "ins1PreCode":"} }; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) { transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"InfoContributor beanName1() {",
        "ins1DelCode":"public InfoContributor beanName1() {",
        "ins1PreCode":"public InfoContributor beanName1() { return (builder) -> { Map<String, Object> content = new LinkedHashMap<>();",
        "ins2PreCode":"public InfoContributor beanName2() { return (builder) -> { Map<String, Object> content = new LinkedHashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"public static void execute(@NotNull final DBCExecutionContext context) { TasksJob.runTask(\"Commit transaction\", new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } });",
        "ins1DelCode":"public static void execute(Shell shell, @NotNull final DBCExecutionContext context) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } }); } catch (InvocationTargetException e) { UIUtils.showErrorDialog(shell, \"Commit\", \"Error while committing session\", e); } catch (InterruptedException e) { }",
        "ins1PreCode":"public static void execute(Shell shell, @NotNull final DBCExecutionContext context) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } } } }); } catch (InvocationTargetException e) { UIUtils.showErrorDialog(shell, \"Commit\", \"Error while committing session\", e); } catch (InterruptedException e) {  }",
        "ins2PreCode":"public static void execute(Shell shell, final DBCExecutionContext context) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\"); try { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } } } }); } catch (InvocationTargetException e) { UIUtils.showErrorDialog(shell, \"Rollback\", \"Error during session rollback\", e); } catch (InterruptedException e) { }",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void edges_checkReturnedSetMutability() { Set<String> edges = network.edges(); try { edges.add(E12); fail(ERROR_MODIFIABLE_COLLECTION);",
        "ins2PreCode":"public void edges_checkReturnedSetMutability() { Set<String> edges = network.edges(); try { edges.add(E12); fail(ERROR_MODIFIABLE_COLLECTION);",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"System.out.println(xml);",
        "ins1PreCode":"ImmutableMapHolder a = new ImmutableMapHolder(); a.m = m; String xml = xs.toXML(a); System.out.println(xml); assertFalse(\"shouldn't contain the class name\",xml.contains(\"google\")); assertFalse(\"shouldn't contain the class name\",xml.contains(\"class\"));",
        "ins2PreCode":"MapHolder a = new MapHolder(); a.m = m; String xml = xs.toXML(a); System.out.println(xml); assertTrue(\"XML should mention the class name\",xml.contains('\\\"'+ImmutableMap.class.getName()+'\\\"')); assertTrue(\"XML should mention the class name\",xml.contains('\\\"'+ImmutableMap.class.getName()+'\\\"'));",
        "label":1
    },
    {
        "ins1AddCode":"assumeTrue(\"System does not support Symlinks\", supportsSymlinks); assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1DelCode":"Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1PreCode":"public void testProhibitSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\"); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void testFileSymlink() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-file-setup\"); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1AddCode":"() -> client.get().uri(\"/actuator/health/charlie\").accept(MediaType.APPLICATION_JSON).exchange() .expectStatus().isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\") .isEqualTo(\"DOWN\"));",
        "ins1DelCode":"() -> client.get().uri(\"/actuator/health/charlie\").exchange().expectStatus() .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\"));",
        "ins1PreCode":"HealthIndicator healthIndicator = () -> Health.down().build(); ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); withHealthContributor(context, \"charlie\", healthIndicator, reactiveHealthIndicator, () -> client.get().uri(\"/actuator/health/charlie\").exchange().expectStatus() .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"LinkedFile fileField = new LinkedFile(\"\", path.toAbsolutePath(), \"\"); LinkedFile newFileField = new LinkedFile(\"\", Path.of(\"Toot.tmp\"), \"\");",
        "ins1DelCode":"LinkedFile fileField = new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"); LinkedFile newFileField = new LinkedFile(\"\", \"Toot.tmp\", \"\");",
        "ins1PreCode":"Path path = testFolder.resolve(\"toot.tmp\"); Files.createFile(path);  LinkedFile fileField = new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation(fileField));  when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey]\"); cleanup.cleanup(entry);  LinkedFile newFileField = new LinkedFile(\"\", \"Toot.tmp\", \"\"); assertEquals(Optional.of(FileFieldWriter.getStringRepresentation(newFileField)), entry.getField(StandardField.FILE));",
        "ins2PreCode":"Path path = testFolder.resolve(\"Toot.tmp\"); Files.createFile(path); LinkedFile fileField = new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation(fileField)); when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey] - [fulltitle]\"); cleanup.cleanup(entry); LinkedFile newFileField = new LinkedFile(\"\", \"Toot - test title.tmp\", \"\"); assertEquals(Optional.of(FileFieldWriter.getStringRepresentation(newFileField)), entry.getField(StandardField.FILE));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); List<Flowable<Integer>> sourceList = new ArrayList<>(i); List<Integer> result = new ArrayList<>(i);",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); List<Integer> result = new ArrayList<Integer>(i);",
        "ins1PreCode":"public void simple() { for (int i = 1; i < 100; i++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); List<Integer> result = new ArrayList<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j));",
        "ins2PreCode":"public void simpleOneLess() { for (int i = 2; i < 100; i++) { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); List<Integer> result = new ArrayList<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j));",
        "label":1
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaTfIdfExample\").getOrCreate(); List<Row> data = Arrays.asList( ); Dataset<Row> sentenceData = spark.createDataFrame(data, schema); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JavaTfIdfExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc); JavaRDD<Row> jrdd = jsc.parallelize(Arrays.asList( )); Dataset<Row> sentenceData = sqlContext.createDataFrame(jrdd, schema); jsc.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaTfIdfExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext sqlContext = new SQLContext(jsc);   JavaRDD<Row> jrdd = jsc.parallelize(Arrays.asList( RowFactory.create(0, \"Hi I heard about Spark\"), RowFactory.create(0, \"I wish Java could use case classes\"), RowFactory.create(1, \"Logistic regression models are neat\") )); StructType schema = new StructType(new StructField[]{ new StructField(\"label\", DataTypes.DoubleType, false, Metadata.empty()), new StructField(\"sentence\", DataTypes.StringType, false, Metadata.empty()) }); Dataset<Row> sentenceData = sqlContext.createDataFrame(jrdd, schema); Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\"); Dataset<Row> wordsData = tokenizer.transform(sentenceData); int numFeatures = 20; HashingTF hashingTF = new HashingTF() .setInputCol(\"words\") .setOutputCol(\"rawFeatures\") .setNumFeatures(numFeatures); Dataset<Row> featurizedData = hashingTF.transform(wordsData);   IDF idf = new IDF().setInputCol(\"rawFeatures\").setOutputCol(\"features\"); IDFModel idfModel = idf.fit(featurizedData); Dataset<Row> rescaledData = idfModel.transform(featurizedData); for (Row r : rescaledData.select(\"features\", \"label\").takeAsList(3)) { Vector features = r.getAs(0); Double label = r.getDouble(1); System.out.println(features); System.out.println(label); }   jsc.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (XYPlot plot : this.subplots) {",
        "ins1DelCode":"Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { XYPlot plot = (XYPlot) iterator.next();",
        "ins1PreCode":"if (result == null) { result = new LegendItemCollection(); if (this.subplots != null) { Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { XYPlot plot = (XYPlot) iterator.next(); LegendItemCollection more = plot.getLegendItems(); result.addAll(more);",
        "ins2PreCode":"if (result == null) { result = new LegendItemCollection(); if (this.subplots != null) { Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { CategoryPlot plot = (CategoryPlot) iterator.next(); LegendItemCollection more = plot.getLegendItems(); result.addAll(more);",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\") FPGrowthModel<String> newModel = (FPGrowthModel<String>) FPGrowthModel.load(sc.sc(), outputPath);",
        "ins1DelCode":"FPGrowthModel newModel = FPGrowthModel.load(sc.sc(), outputPath);",
        "ins1PreCode":" try { model.save(sc.sc(), outputPath); FPGrowthModel newModel = FPGrowthModel.load(sc.sc(), outputPath); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD() .collect();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"return;",
        "ins1PreCode":"protected void start(PrintWriter writer, String name, StringManager smClient) {  if (debug >= 1) { log(sm.getString(\"hostManagerServlet.start\", name)); }   if ((name == null) || name.length() == 0) { writer.println(smClient.getString( \"hostManagerServlet.invalidHostName\", name)); return; }  Container host = engine.findChild(name);   if (host == null) { writer.println(smClient.getString( \"hostManagerServlet.noHost\", name)); return; }   if (host == installedHost) { writer.println(smClient.getString( \"hostManagerServlet.cannotStartOwnHost\", name)); return; }   if (host.getState().isAvailable()) { writer.println(smClient.getString( \"hostManagerServlet.alreadyStarted\", name)); return; }   try { host.start(); writer.println(smClient.getString( \"hostManagerServlet.started\", name)); } catch (Exception e) { getServletContext().log (sm.getString(\"hostManagerServlet.startFailed\", name), e); writer.println(smClient.getString( \"hostManagerServlet.startFailed\", name)); writer.println(smClient.getString( \"hostManagerServlet.exception\", e.toString())); return; } ",
        "ins2PreCode":"protected void stop(PrintWriter writer, String name, StringManager smClient) { if (debug >= 1) { log(sm.getString(\"hostManagerServlet.stop\", name)); } if ((name == null) || name.length() == 0) { writer.println(smClient.getString( \"hostManagerServlet.invalidHostName\", name)); return; } Container host = engine.findChild(name); if (host == null) { writer.println(smClient.getString( \"hostManagerServlet.cannotStopOwnHost\", name)); return; } if (host == installedHost) { writer.println(smClient.getString( \"hostManagerServlet.cannotStopOwnHost\", name)); return; } if (!host.getState().isAvailable()) { writer.println(smClient.getString( \"hostManagerServlet.alreadyStopped\", name)); return; } try { host.stop(); writer.println(smClient.getString( \"hostManagerServlet.stopFailed\", name), e); } catch (Exception e) { getServletContext().log(sm.getString( log(sm.getString(\"hostManagerServlet.stop\", name)); writer.println(smClient.getString( \"hostManagerServlet.stopFailed\", name), e); writer.println(smClient.getString( \"hostManagerServlet.cannotStopOwnHost\", name)); return; }",
        "label":1
    },
    {
        "ins1AddCode":"false, false);",
        "ins1DelCode":"false);",
        "ins1PreCode":"MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( createObjectProvider(this.customizers), createObjectProvider(this.filters), createObjectProvider(this.binders), false); configurer.configure(this.mockRegistry); verify(this.mockConfig).meterFilter(this.mockFilter);",
        "ins2PreCode":"MeterRegistryConfigurer configurer = new MeterRegistryConfigurer( createObjectProvider(this.customizers), createObjectProvider(this.filters), createObjectProvider(this.binders), false); configurer.configure(this.mockRegistry); verify(this.mockBinder).bindTo(this.mockRegistry);",
        "label":1
    },
    {
        "ins1AddCode":"tgt = new IssueManagement(); target.setIssueManagement( tgt );",
        "ins1DelCode":"target.setIssueManagement( tgt = new IssueManagement() );",
        "ins1PreCode":"IssueManagement tgt = target.getIssueManagement(); if ( tgt == null ) { target.setIssueManagement( tgt = new IssueManagement() ); } mergeIssueManagement( tgt, src, sourceDominant, context );",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void forwardInSequence() throws Exception {",
        "ins1DelCode":"public void forwardInSequence() throws Exception {",
        "ins1PreCode":"public void forwardInSequence() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); WritableByteChannel channel = Channels.newChannel(out);",
        "ins2PreCode":"public void forwardOutOfSequence() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream(); WritableByteChannel channel = Channels.newChannel(out);",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataEnvironmentContributor contributor = createBoundContributor(null, configData, 0); ConfigDataEnvironmentContributor childContributor = createBoundContributor(null, childConfigData, 0);",
        "ins1DelCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor childContributor = ConfigDataEnvironmentContributor.ofImported(null, childConfigData, 0, this.activationContext);",
        "ins1PreCode":"MockPropertySource propertySource = new MockPropertySource(); propertySource.setProperty(\"spring.config.import\", \"springboot\"); ConfigData configData = new ConfigData(Collections.singleton(propertySource)); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigData childConfigData = new ConfigData(Collections.singleton(new MockPropertySource())); ConfigDataEnvironmentContributor childContributor = ConfigDataEnvironmentContributor.ofImported(null, childConfigData, 0, this.activationContext); ConfigDataEnvironmentContributor withChildren = contributor.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.singletonList(childContributor));",
        "ins2PreCode":"MockPropertySource propertySource = new MockPropertySource(); propertySource.setProperty(\"spring.config.import\", \"springboot\"); ConfigData configData = new ConfigData(Collections.singleton(propertySource)); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigData childConfigData = new ConfigData(Collections.singleton(new MockPropertySource())); ConfigDataEnvironmentContributor childContributor = ConfigDataEnvironmentContributor.ofImported(null, childConfigData, 0, this.activationContext); ConfigDataEnvironmentContributor withChildren = contributor.withChildren(ImportPhase.BEFORE_PROFILE_ACTIVATION, Collections.singletonList(childContributor));",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(",
        "ins1DelCode":"CategoryDataset newData = DatasetUtilities.createCategoryDataset(",
        "ins1PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset( \"S\", \"C\", data); LocalListener l = new LocalListener();",
        "ins2PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener();",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series = new XYSeries<>(\"Test\"); XYDataset ds = new XYSeriesCollection<String>(series);",
        "ins1DelCode":"XYSeries series = new XYSeries(\"Test\"); XYDataset ds = new XYSeriesCollection(series);",
        "ins1PreCode":" double[][] data = createSampleData1();  XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 11; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getPowerRegression(ds, 0); ",
        "ins2PreCode":"double[][] data = createSampleData2(); XYSeries series = new XYSeries(\"Test\"); for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection(series); double[] result = Regression.getOLSRegression(ds, 0);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.fail(targetName + \" was expected to fail since Ant runtime libraries \" +",
        "ins1DelCode":"Assert.fail(targetName + \" was expected to fail since JUnit platform libraries \" +",
        "ins1PreCode":"final String targetName = \"test-junit-ant-runtime-lib-excluded\"; try { buildRule.executeTarget(targetName); Assert.fail(targetName + \" was expected to fail since JUnit platform libraries \" + \"weren't included in the classpath of the forked JVM\"); } catch (BuildException be) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"continue;",
        "ins1PreCode":"else { tickDate = unit.rollDate(tickDate, this.timeZone); hasRolled = true; continue; } ",
        "ins2PreCode":"else { tickDate = unit.rollDate(tickDate, this.timeZone); hasRolled = true; hasRolled = true; }",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> p1 = new CategoryPlot<>(); CategoryPlot<String, String> p2 = new CategoryPlot<>();",
        "ins1DelCode":"CategoryPlot p1 = new CategoryPlot(); CategoryPlot p2 = new CategoryPlot();",
        "ins1PreCode":"public void testEquals_ObjectList2() { CategoryPlot p1 = new CategoryPlot(); p1.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot p2 = new CategoryPlot(); p2.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); assertEquals(p1, p2);",
        "ins2PreCode":"public void testEquals_ObjectList4() { CategoryPlot p1 = new CategoryPlot(); p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot p2 = new CategoryPlot(); p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1AddCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry));",
        "ins1DelCode":"ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry));",
        "ins1PreCode":"   ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();",
        "ins2PreCode":"ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();",
        "label":1
    },
    {
        "ins1AddCode":"Set<String> conflicts = new HashSet<>();",
        "ins1DelCode":"Set<String> conflicts = new HashSet<String>();",
        "ins1PreCode":"public Set<String> setInitParameters(Map<String, String> initParameters) {  Set<String> conflicts = new HashSet<String>();  for (Map.Entry<String, String> entry : initParameters.entrySet()) {",
        "ins2PreCode":"public Set<String> setInitParameters(Map<String, String> initParameters) { Set<String> conflicts = new HashSet<String>(); for (Map.Entry<String, String> entry : initParameters.entrySet()) {",
        "label":1
    },
    {
        "ins1AddCode":"alv.validateAccessLog(1, 200, 0, REQUEST_TIME);",
        "ins1DelCode":"validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);",
        "ins1PreCode":"assertEquals(expected.toString(), res.toString());   validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);",
        "ins2PreCode":"assertEquals(expected.toString(), res.toString()); validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);",
        "label":1
    },
    {
        "ins1AddCode":"GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B > B1\", true, ',', true);",
        "ins1DelCode":"GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true);",
        "ins1PreCode":"public void draggedOnBottomOfGroupAddsAfterItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA)); GroupNodeViewModel groupBViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupB));",
        "ins2PreCode":"public void draggedOnTopOfGroupAddsBeforeItWhenSourceGroupWasBefore() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA)); GroupNodeViewModel groupBViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupB));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void tryScalarXMap() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); assertTrue(FlowableScalarXMap.tryScalarXMapSubscribe(new CallablePublisher(), ts, new Function<Integer, Publisher<Integer>>() { @Override",
        "ins2PreCode":"public void emptyXMap() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); assertTrue(FlowableScalarXMap.tryScalarXMapSubscribe(new EmptyCallablePublisher(), ts, new Function<Integer, Publisher<Integer>>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Collections.singletonList(\"val\"), result);",
        "ins1DelCode":"Assert.assertEquals(Collections.singletonList(\"val\"), result);",
        "ins1PreCode":"autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"va\"))); Assert.assertEquals(Collections.singletonList(\"val\"), result);",
        "ins2PreCode":"autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"va\"))); Assert.assertEquals(Collections.singletonList(\"val\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"void bindWhenExceptionNotIgnorableShouldFail() {",
        "ins1DelCode":"public void bindWhenExceptionNotIgnorableShouldFail() {",
        "ins1PreCode":"public void bindWhenExceptionNotIgnorableShouldFail() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.foo\", \"1\");",
        "ins2PreCode":"public void bindWhenExceptionInNestedContextShouldFail() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.map\", \"hello\");",
        "label":1
    },
    {
        "ins1AddCode":"SpscLinkedArrayQueue<Object> q = new SpscLinkedArrayQueue<>(16);",
        "ins1DelCode":"SpscLinkedArrayQueue<Object> q = new SpscLinkedArrayQueue<Object>(16);",
        "ins1PreCode":"public void spscLinkedArrayQueueBiOffer() { SpscLinkedArrayQueue<Object> q = new SpscLinkedArrayQueue<Object>(16); q.offer(1, 2); ",
        "ins2PreCode":"public void mpscLinkedQueueBiOffer() { MpscLinkedQueue<Object> q = new MpscLinkedQueue<Object>(); q.offer(1, 2);",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Flowable<Integer>> ref = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Flowable<Integer>> ref = new AtomicReference<Flowable<Integer>>();",
        "ins1PreCode":"public void publishFunctionCancelOuterAfterOneInner() { final AtomicReference<Flowable<Integer>> ref = new AtomicReference<Flowable<Integer>>();  PublishProcessor<Integer> pp = PublishProcessor.create();",
        "ins2PreCode":"public void publishFunctionCancelOuterAfterOneInnerBackpressured() { final AtomicReference<Flowable<Integer>> ref = new AtomicReference<Flowable<Integer>>(); PublishProcessor<Integer> pp = PublishProcessor.create();",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD_COLON); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD_COLON, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()),",
        "ins1DelCode":"sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()), sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()), sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()),",
        "ins1PreCode":"  if (netInBuffer.position() == 0) { sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; }  TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer);  if (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; }  String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: sc.read(netInBuffer, Nio2Endpoint.toNio2Timeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1;",
        "ins2PreCode":"netOutBuffer.position(0); netInBuffer.capacity() < endpoint.getSniParseLimit()) { handshakeStatus = sslEngine.getHandshakeStatus(); return -1; } TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer); while (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) { int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit))); netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); netInBuffer.capacity() < endpoint.getSniParseLimit()) { handshakeStatus = sslEngine.getHandshakeStatus(); return -1; } String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols(); case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: netInBuffer.capacity() < endpoint.getSniParseLimit()) { handshakeStatus = sslEngine.getHandshakeStatus(); return -1;",
        "label":0
    },
    {
        "ins1AddCode":"JavaDStream<Integer> reversed = pairStream.map(in -> in._2());",
        "ins1DelCode":"JavaDStream<Integer> reversed = pairStream.map( new Function<Tuple2<String, Integer>, Integer>() { @Override public Integer call(Tuple2<String, Integer> in) { return in._2(); } });",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map( new Function<Tuple2<String, Integer>, Integer>() { @Override public Integer call(Tuple2<String, Integer> in) { return in._2(); } });  JavaTestUtils.attachTestOutputStream(reversed);",
        "ins2PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); JavaDStream<Tuple2<String, Integer>> stream = public void testPairMap2() { JavaDStream<Tuple2<String, Integer>> stream = JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); } } JavaTestUtils.attachTestOutputStream(reversed);",
        "label":0
    },
    {
        "ins1AddCode":"pool.write(from, getSocket(), selector, writeTimeout);",
        "ins1DelCode":"pool.write(from, getSocket(), selector, writeTimeout, block);",
        "ins1PreCode":" } try { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) { ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"WebClient webClient = getWebClient(this.webServer.getPort()).build();",
        "ins1DelCode":"WebClient webClient = getWebClient().build();",
        "ins1PreCode":"BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient().build(); webClient.get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue();",
        "ins2PreCode":"BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); Mono<ResponseEntity<Void>> unconnectableRequest1 = getWebClient().build().get().retrieve().toBodilessEntity(); getWebClient().build().get().retrieve().toBodilessEntity().subscribe((response) -> responseLatch.countDown()); blockingHandler.awaitQueue();",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace());",
        "ins1DelCode":"Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace());",
        "ins1PreCode":"  parser.readFrame(true); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1AddCode":"setMapValuesUsingAccessors(builder);",
        "ins1DelCode":"setMapValuesUsingMutableMap(builder);",
        "ins1PreCode":"public void testGetMap() { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); TestMap message = builder.build(); assertEquals(",
        "ins2PreCode":"public void testGetMap() { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); assertEquals(",
        "label":0
    },
    {
        "ins1AddCode":"} else if (\"--module-path\".equals(mockProcLauncher.cmd[i])) { } else if (mockProcLauncher.cmd[i].equals(\"--add-exports\")) { resExports.add(mockProcLauncher.cmd[++i]);",
        "ins1DelCode":"} else if (\"-modulepath\".equals(mockProcLauncher.cmd[i])) { } else if (mockProcLauncher.cmd[i].startsWith(\"-XaddExports:\")) { resExports.add(mockProcLauncher.cmd[i]);",
        "ins1PreCode":"for (int i = 1; i< mockProcLauncher.cmd.length; i++) { if (\"-classpath\".equals(mockProcLauncher.cmd[i])) { resCp = mockProcLauncher.cmd[++i]; } else if (\"-modulepath\".equals(mockProcLauncher.cmd[i])) { resMp = mockProcLauncher.cmd[++i]; } else if (mockProcLauncher.cmd[i].startsWith(\"-XaddExports:\")) { resExports.add(mockProcLauncher.cmd[i]); } else if (JUnitTestRunner.class.getName().equals(mockProcLauncher.cmd[i])) { break;",
        "ins2PreCode":"for (int i = 1; i< mockProcLauncher.cmd.length; i++) { if (\"-classpath\".equals(mockProcLauncher.cmd[i])) { resCp = mockProcLauncher.cmd[++i]; } else if (\"-modulepath\".equals(mockProcLauncher.cmd[i])) { resMp = mockProcLauncher.cmd[++i]; } else if (mockProcLauncher.cmd[i].startsWith(\"-XaddExports:\")) { resExports.add(mockProcLauncher.cmd[i]); } else if (JUnitTestRunner.class.getName().equals(mockProcLauncher.cmd[i])) { break;",
        "label":1
    },
    {
        "ins1AddCode":"public UMLTextArea(UMLPlainTextDocument doc) {",
        "ins1DelCode":"public UMLTextArea(UMLDocument doc) {",
        "ins1PreCode":"public UMLTextArea(UMLDocument doc) { super(doc); setFont(LookAndFeelMgr.getInstance().getStandardFont());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"systemDefault = System.getProperty(MagicNames.REGEXP_IMPL); systemDefault = p.getProperty(MagicNames.REGEXP_IMPL);",
        "ins1DelCode":"systemDefault = System.getProperty(\"ant.regexp.regexpimpl\"); systemDefault = p.getProperty(\"ant.regexp.regexpimpl\");",
        "ins1PreCode":"throws BuildException { String systemDefault = null; if (p == null) { systemDefault = System.getProperty(\"ant.regexp.regexpimpl\"); } else { systemDefault = p.getProperty(\"ant.regexp.regexpimpl\"); } ",
        "ins2PreCode":"throw new BuildException( String systemDefault = null; if (p == null) { systemDefault = System.getProperty(\"ant.regexp.regexpimpl\"); } else { systemDefault = p.getProperty(\"ant.regexp.regexpimpl\"); }",
        "label":1
    },
    {
        "ins1AddCode":"Validate.notNull( input, \"input cannot be null\" );",
        "ins1DelCode":"if ( input == null ) { throw new IllegalArgumentException( \"input reader missing\" ); }",
        "ins1PreCode":"public Metadata read( Reader input, Map<String, ?> options ) throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input reader missing\" ); } ",
        "ins2PreCode":"public Metadata read( InputStream input, Map<String, ?> options ) throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input stream missing\" ); }",
        "label":1
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE));",
        "ins1DelCode":"TextFlow description = createDescription(query, true, false);",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false); TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "label":0
    },
    {
        "ins1AddCode":"private void initialize() {",
        "ins1DelCode":"private final void initialize() {",
        "ins1PreCode":"private final void initialize() { Parameter[] params = getParameters(); if (params != null) {",
        "ins2PreCode":"private final void initialize() { Parameter[] params = getParameters(); if (params != null) {",
        "label":1
    },
    {
        "ins1AddCode":"SearchResponse.Clusters clusters = randomClusters();",
        "ins1DelCode":"SearchResponse.Clusters clusters = new SearchResponse.Clusters(totalShards, successfulShards, skippedShards);",
        "ins1PreCode":"int successfulShards = randomIntBetween(0, totalShards); int skippedShards = totalShards - successfulShards; InternalSearchResponse internalSearchResponse = InternalSearchResponse.empty(); SearchResponse.Clusters clusters = new SearchResponse.Clusters(totalShards, successfulShards, skippedShards); SearchTemplateResponse searchTemplateResponse = new SearchTemplateResponse(); SearchResponse searchResponse = new SearchResponse(internalSearchResponse, null, totalShards,",
        "ins2PreCode":"int successfulShards = randomIntBetween(0, totalShards); int skippedShards = totalShards - successfulShards; InternalSearchResponse internalSearchResponse = InternalSearchResponse.empty(); SearchResponse.Clusters clusters = new SearchResponse.Clusters(totalShards, successfulShards, skippedShards); SearchTemplateResponse searchTemplateResponse = new SearchTemplateResponse(); SearchResponse searchResponse = new SearchResponse(internalSearchResponse, null, totalShards,",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, String> parms = new HashMap<>();",
        "ins1DelCode":"Map<String, String> parms = new HashMap<String, String>();",
        "ins1PreCode":"public void testInsertTable1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table1.insert\", parms);",
        "ins2PreCode":"public void testInsertTable2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insert\", parms);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void normal() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  Flowable.range(1, 5).concatMapIterable(mapper)",
        "ins2PreCode":"public void normalViaFlatMap() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(1, 5).flatMapIterable(mapper)",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(\"SystemIDs should not start with file:////\", systemid.startsWith(\"file:////\"));",
        "ins1DelCode":"assertTrue(\"SystemIDs should not start with file:////\", !systemid.startsWith(\"file:////\"));",
        "ins1PreCode":"} String systemid = JAXPUtils.getSystemId(file); assertTrue(\"SystemIDs should start by file:/\", systemid.startsWith(\"file:/\")); assertTrue(\"SystemIDs should not start with file:////\", !systemid.startsWith(\"file:////\"));",
        "ins2PreCode":"} String systemid = JAXPUtils.getSystemId(file); assertTrue(\"SystemIDs should start by file:/\", systemid.startsWith(\"file:/\")); assertTrue(\"SystemIDs should not start with file:////\", !systemid.startsWith(\"file:////\"));",
        "label":1
    },
    {
        "ins1AddCode":"CombinedRangeXYPlot<S> result = (CombinedRangeXYPlot) super.clone(); for (XYPlot<S> child : result.subplots) {",
        "ins1DelCode":"CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); for (XYPlot child : result.subplots) {",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException {  CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) CloneUtils.cloneList(this.subplots); for (XYPlot child : result.subplots) { child.setParent(result); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"manager.getContext().getLogger().error",
        "ins1DelCode":"manager.getContainer().getLogger().error",
        "ins1PreCode":".sessionWillPassivate(event); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t); }",
        "ins2PreCode":".sessionDidActivate(event); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t); }",
        "label":1
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa8_1(active0, 0x100000000000L);",
        "ins1PreCode":"switch(curChar) { case 101: return jjMoveStringLiteralDfa8_1(active0, 0x100000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 111: return jjMoveStringLiteralDfa9_1(active0, 0x100000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"}, true, 2, Schedulers.single())",
        "ins1DelCode":"}, 2, true, Schedulers.single())",
        "ins1PreCode":".repeat(1000) .observeOn(Schedulers.io()); } }, 2, true, Schedulers.single()) .distinct() .test()",
        "ins2PreCode":".repeat(1000) .observeOn(Schedulers.io()); } }, 2, false, Schedulers.single()) .distinct() .test()",
        "label":1
    },
    {
        "ins1AddCode":"config.put(\"field\", \"{{field1}}\");",
        "ins1DelCode":"config.put(\"field\", \"field1\");",
        "ins1PreCode":"public void testInvalidMustacheTemplate() throws Exception { AppendProcessor.Factory factory = new AppendProcessor.Factory(TestTemplateService.instance(true)); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10);",
        "ins2PreCode":"public void testInvalidMustacheTemplate() throws Exception { SetProcessor.Factory factory = new SetProcessor.Factory(TestTemplateService.instance(true)); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10);",
        "label":1
    },
    {
        "ins1AddCode":"assertThrowsWithMessage(\"Index 2 is out of range [0, 2) (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> {",
        "ins1DelCode":"assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> {",
        "ins1PreCode":"public void assertValueAtInvalidIndex() { assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins2PreCode":"public void assertNeverAtMatchingPredicate() { assertThrows(AssertionError.class, () -> { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>(); final SerializedObserver<Integer> so = new SerializedObserver<>(to);",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>(); final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to);",
        "ins1PreCode":"public void onNextOnCompleteRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<Integer>();  final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to);  Disposable d = Disposable.empty();",
        "ins2PreCode":"public void onNextOnErrorRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<Integer>(); final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty());  assertFalse(((Disposable)observer).isDisposed());",
        "ins2PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); assertFalse(((Disposable)observer).isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false);",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"Series 1\", true, false); XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
        "ins1PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "ins2PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1); XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "label":1
    },
    {
        "ins1AddCode":"assertMapValuesSet(source);",
        "ins1DelCode":"",
        "ins1PreCode":"TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValues(sourceBuilder); TestMap source = sourceBuilder.build();  TestMap.Builder destination = TestMap.newBuilder(); copyMapValues(source, destination);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = (FileSet) buildRule.getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(buildRule.getProject());",
        "ins1DelCode":"if (!supportsSymlinks) { return; } if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = (FileSet) getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(getProject());",
        "ins1PreCode":"public void testGetFollowSymlinksTrue() { if (!supportsSymlinks) { return; } if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } getProject().executeTarget(\"ftp-get-directory-symbolic-link\"); FileSet fsDestination = (FileSet) getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(getProject()); dsDestination.scan(); compareFiles(dsDestination, new String[] {\"alpha/beta/gamma/gamma.xml\"},",
        "ins2PreCode":"public void testGetFollowSymlinksFalse() { if (!supportsSymlinks) { return; } if (!loginSuceeded) { return; } if (!changeRemoteDir(remoteTmpDir)) { return; } getProject().executeTarget(\"ftp-get-directory-no-symbolic-link\"); FileSet fsDestination = (FileSet) getProject().getReference(\"fileset-destination-without-selector\"); DirectoryScanner dsDestination = fsDestination.getDirectoryScanner(getProject()); dsDestination.scan(); compareFiles(dsDestination, new String[] {},",
        "label":1
    },
    {
        "ins1AddCode":"result = HashUtils.hashCode(result, this.labelFormat); result = HashUtils.hashCode(result, this.nullValueString); result = HashUtils.hashCode(result, this.dateFormat); result = HashUtils.hashCode(result, this.numberFormat); result = HashUtils.hashCode(result, this.percentFormat);",
        "ins1DelCode":"result = HashUtilities.hashCode(result, this.labelFormat); result = HashUtilities.hashCode(result, this.nullValueString); result = HashUtilities.hashCode(result, this.dateFormat); result = HashUtilities.hashCode(result, this.numberFormat); result = HashUtilities.hashCode(result, this.percentFormat);",
        "ins1PreCode":"public int hashCode() { int result = 127; result = HashUtilities.hashCode(result, this.labelFormat); result = HashUtilities.hashCode(result, this.nullValueString); result = HashUtilities.hashCode(result, this.dateFormat); result = HashUtilities.hashCode(result, this.numberFormat); result = HashUtilities.hashCode(result, this.percentFormat); return result;",
        "ins2PreCode":"public int hashCode() { int result = 127; result = HashUtilities.hashCode(result, this.xDateFormat); result = HashUtilities.hashCode(result, this.formatString); result = HashUtilities.hashCode(result, this.xDateFormat); result = HashUtilities.hashCode(result, this.xFormat); result = HashUtilities.hashCode(result, this.xFormat); return result;",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"if (i % 1000 == 0) { System.out.println(\"concatMapRangeAsyncLoop > \" + i); } TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.range(0, 1000) .concatMap(new Function<Integer, Observable<Integer>>() {",
        "ins2PreCode":"if (i % 1000 == 0) { System.out.println(\"concatMapRangeAsyncLoop > \" + i); } TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.range(0, 1000) .concatMap(new Function<Integer, Observable<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(sources, \"sources is null\");",
        "ins1DelCode":"",
        "ins1PreCode":"public static <T, R> Flowable<R> zipArray(@NonNull Function<? super Object[], ? extends R> zipper, boolean delayError, int bufferSize, @NonNull Publisher<? extends T>... sources) { if (sources.length == 0) { return empty(); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"BoxAndWhiskerRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"BoxAndWhiskerRenderer r2 = (BoxAndWhiskerRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerRenderer r1 = new BoxAndWhiskerRenderer(); BoxAndWhiskerRenderer r2 = (BoxAndWhiskerRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { LayeredBarRenderer r1 = new LayeredBarRenderer(); LayeredBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Long>> aggregated = grouped.agg( aggregated.collectAsList());",
        "ins1DelCode":"Dataset<Tuple2<String, Long>> agged = grouped.agg( agged.collectAsList());",
        "ins1PreCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(value -> (long) value._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), agged.collectAsList());",
        "ins2PreCode":"public void testTypedAggregationSumLong() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sumLong(v -> (long)v._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3L), new Tuple2<>(\"b\", 3L)), agged.collectAsList());",
        "label":1
    },
    {
        "ins1AddCode":"List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2); (listOfRDDs, time) -> { Assert.assertEquals(2, listOfRDDs.size()); return null; Arrays.asList(stream1, stream2, pairStream1.toJavaDStream()); (listOfRDDs, time) -> { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = (PairFunction<Integer, Integer, Integer>) i -> new Tuple2<>(i, i); return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);",
        "ins1DelCode":"List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2); new Function2<List<JavaRDD<?>>, Time, JavaRDD<Long>>() { @Override public JavaRDD<Long> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(2, listOfRDDs.size()); return null; } Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream()); new Function2<List<JavaRDD<?>>, Time, JavaPairRDD<Integer, Tuple2<Integer, String>>>() { @Override public JavaPairRDD<Integer, Tuple2<Integer, String>> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer i) { return new Tuple2<>(i, i); } }; return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3); }",
        "ins1PreCode":"JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream( JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));  List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2);   ssc.transform( listOfDStreams1, new Function2<List<JavaRDD<?>>, Time, JavaRDD<Long>>() { @Override public JavaRDD<Long> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(2, listOfRDDs.size()); return null; } } );  List<JavaDStream<?>> listOfDStreams2 = Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream());  JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair( listOfDStreams2, new Function2<List<JavaRDD<?>>, Time, JavaPairRDD<Integer, Tuple2<Integer, String>>>() { @Override public JavaPairRDD<Integer, Tuple2<Integer, String>> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer i) { return new Tuple2<>(i, i); } }; return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3); }",
        "ins2PreCode":"JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream( JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1)); List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2); JavaDStream<Long> transformed1 = ssc.transform( List<JavaDStream<?>> listOfDStreams2 = listOfDStreams2, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Arrays.asList(2) listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Assert.assertEquals(2, listOfRDDs.size()); return null; } } ); List<JavaDStream<?>> listOfDStreams2 = Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream()); JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair( List<JavaDStream<?>> listOfDStreams2 = List<List<Tuple2<Integer, Tuple2<Integer, String>>>> result = Arrays.asList(2) JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2); listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>) listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>) listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = PairFunction<Integer, Integer, Integer> mapToTuple = Arrays.asList(2) PairFunction<Integer, Integer, Integer> mapToTuple = (Integer i) -> new Tuple2<>(i, i); } }); return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3); }",
        "label":0
    },
    {
        "ins1AddCode":"normalMessage.writeDelimitedTo(output); assertMessageEquals(normalMessage, normalMessage.getParserForType().parseDelimitedFrom(input)); assertMessageEquals(normalMessage, normalMessage.getParserForType().parseDelimitedFrom(input));",
        "ins1DelCode":"TestPackedExtensionsLite packedMessage = TestUtilLite.getLitePackedExtensionsSet(); packedMessage.writeDelimitedTo(output); assertMessageEquals( normalMessage, normalMessage.getParserForType().parseDelimitedFrom(input)); assertMessageEquals( packedMessage, packedMessage .getParserForType() .parseDelimitedFrom(input, TestUtilLite.getExtensionRegistryLite()));",
        "ins1PreCode":"normalMessage.writeDelimitedTo(output);   TestPackedExtensionsLite packedMessage = TestUtilLite.getLitePackedExtensionsSet(); packedMessage.writeDelimitedTo(output);  InputStream input = new ByteArrayInputStream(output.toByteArray()); assertMessageEquals( normalMessage, normalMessage.getParserForType().parseDelimitedFrom(input)); assertMessageEquals( packedMessage, packedMessage .getParserForType() .parseDelimitedFrom(input, TestUtilLite.getExtensionRegistryLite()));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() throws Exception {",
        "ins1DelCode":"public void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() throws Exception {",
        "ins1PreCode":"public void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() throws Exception { String tokenKeyValue = \"-----BEGIN PUBLIC KEY-----\\n\" + \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA0m59l2u9iDnMbrXHfqkO\\n\"",
        "ins2PreCode":"public void fetchTokenKeysWhenNoKeysReturnedFromUAA() throws Exception { String responseBody = \"{\\\"keys\\\": []}\"; .consumeNextWith((tokenKeys) -> assertThat(tokenKeys).hasSize(0)).expectComplete().verify();",
        "label":1
    },
    {
        "ins1AddCode":"name.append(\",context=\"); String contextName = context.getName(); if (!contextName.startsWith(\"/\")) { name.append(\"/\"); name.append(contextName);",
        "ins1DelCode":"name.append(\",path=\"); String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; name.append(path);",
        "ins1PreCode":"StringBuilder name = new StringBuilder(\"type=Loader\");  if (container instanceof Context) { name.append(\",path=\"); Context context = (Context) container;  String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; } name.append(path);  name.append(\",host=\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception {",
        "ins1DelCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception {",
        "ins1PreCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": true,\\\"read_basic_data\\\": true}\"; prepareResponse((response) -> response.setBody(responseBody).setHeader(\"Content-Type\", \"application/json\"));",
        "ins2PreCode":"public void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": false,\\\"read_basic_data\\\": true}\"; prepareResponse((response) -> response.setBody(responseBody).setHeader(\"Content-Type\", \"application/json\"));",
        "label":1
    },
    {
        "ins1AddCode":"void javaBeanMetadataSimpleProperty() throws IOException {",
        "ins1DelCode":"public void javaBeanMetadataSimpleProperty() throws IOException {",
        "ins1PreCode":"public void javaBeanMetadataSimpleProperty() throws IOException { process(SimpleTypeProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(SimpleTypeProperties.class);",
        "ins2PreCode":"public void lombokMetadataSimpleProperty() throws IOException { process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"author @ good\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"author @ good\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"author @ good\\\"}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"author @ good\"), e.getField(\"author\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public Observable<? extends Integer> apply(Integer v) { public Observable<? extends Integer> apply(Integer v) { public Maybe<? extends Integer> apply(Integer v) {",
        "ins1DelCode":"public Observable<? extends Integer> apply(Integer v) throws Exception { public Observable<? extends Integer> apply(Integer v) throws Exception { public Maybe<? extends Integer> apply(Integer v) throws Exception {",
        "ins1PreCode":" observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.empty(); } });  observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Maybe.<Integer>empty().toObservable(); } });  observableDedicated = source.flatMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.empty(); }",
        "ins2PreCode":"observablePlain = source.switchMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.empty(); } }); observableConvert = source.switchMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Maybe.<Integer>empty().toObservable(); } }); observableDedicated = source.switchMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.empty(); }",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void blockingSubscribeConsumerConsumerError() { final List<Object> list = new ArrayList<Object>();  TestException ex = new TestException();",
        "ins2PreCode":"public void boundedBlockingSubscribeConsumerConsumerError() { final List<Object> list = new ArrayList<Object>(); TestException ex = new TestException();",
        "label":1
    },
    {
        "ins1AddCode":"HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1DelCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1PreCode":"int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); } ",
        "ins2PreCode":"int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); Assert.assertEquals( hasher.hashUnsafeWordsBlock(mb), hasher.hashUnsafeWordsBlock(mb)); hashcodes.add(hasher.hashUnsafeWordsBlock(mb)); }",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriberEx<Integer> inner1 = new TestSubscriberEx<>(); final TestSubscriberEx<Integer> inner2 = new TestSubscriberEx<>(); = new TestSubscriberEx<>(new DefaultSubscriber<GroupedFlowable<Integer, Integer>>() {",
        "ins1DelCode":"final TestSubscriberEx<Integer> inner1 = new TestSubscriberEx<Integer>(); final TestSubscriberEx<Integer> inner2 = new TestSubscriberEx<Integer>(); = new TestSubscriberEx<GroupedFlowable<Integer, Integer>>(new DefaultSubscriber<GroupedFlowable<Integer, Integer>>() {",
        "ins1PreCode":"public void groupByShouldPropagateError() { final Throwable e = new RuntimeException(\"Oops\"); final TestSubscriberEx<Integer> inner1 = new TestSubscriberEx<Integer>(); final TestSubscriberEx<Integer> inner2 = new TestSubscriberEx<Integer>();  final TestSubscriberEx<GroupedFlowable<Integer, Integer>> outer = new TestSubscriberEx<GroupedFlowable<Integer, Integer>>(new DefaultSubscriber<GroupedFlowable<Integer, Integer>>() {  @Override",
        "ins2PreCode":"public void groupByShouldPropagateError() { final Throwable e = new RuntimeException(\"Oops\"); final TestObserverEx<Integer> inner1 = new TestObserverEx<Integer>(); final TestObserverEx<Integer> inner2 = new TestObserverEx<Integer>(); final TestObserverEx<GroupedObservable<Integer, Integer>> outer = new TestObserverEx<GroupedObservable<Integer, Integer>>(new DefaultObserver<GroupedObservable<Integer, Integer>>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build(); MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();",
        "ins1DelCode":"MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build();",
        "ins1PreCode":"public void transitiveClosure_directedCycleGraph() { MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N2, N3); directedGraph.putEdge(N3, N4); directedGraph.putEdge(N4, N1);  MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "ins2PreCode":"public void transitiveClosure_undirectedCycleGraph() { MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().allowsSelfLoops(false).build(); undirectedGraph.putEdge(N1, N2); undirectedGraph.putEdge(N2, N3); undirectedGraph.putEdge(N3, N4); undirectedGraph.putEdge(N4, N1); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.undirected().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "label":1
    },
    {
        "ins1AddCode":"pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0));",
        "ins1DelCode":"pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 1, 0, 0)); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0));",
        "ins1PreCode":"public void testDeferredBufsAreWrittenDuringOnComplete() throws IOException { StreamCallbackWithID stream1 = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream1.onData(stream1.getID(), ByteBuffer.wrap(new byte[2])); StreamCallbackWithID stream2 = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 1, 0, 0));  stream2.onData(stream2.getID(), ByteBuffer.wrap(new byte[3])); stream2.onData(stream2.getID(), ByteBuffer.wrap(new byte[3]));  stream1.onData(stream1.getID(), ByteBuffer.wrap(new byte[2])); stream1.onComplete(stream1.getID());  stream2.onComplete(stream2.getID()); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[]{4, 6}, new int[][]{{0}, {1}});",
        "ins2PreCode":"public void testDuplicateBlocksAreIgnoredWhenPrevStreamIsInProgress() throws IOException { StreamCallbackWithID stream1 = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream1.onData(stream1.getID(), ByteBuffer.wrap(new byte[2])); StreamCallbackWithID stream2 = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream2.onData(stream2.getID(), ByteBuffer.wrap(new byte[2])); stream2.onData(stream2.getID(), ByteBuffer.wrap(new byte[2])); stream1.onData(stream1.getID(), ByteBuffer.wrap(new byte[2])); stream1.onComplete(stream1.getID()); stream2.onComplete(stream2.getID()); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[]{4}, new int[][]{{0}});",
        "label":1
    },
    {
        "ins1AddCode":"public Set<K> keySet() { LinkedHashSet<K> set = new LinkedHashSet<K>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<K,MapEntry<K,V>> e = i.next(); K key = e.getKey(); MapEntry<K,V> entry = innerMap.get(key); if ( entry!=null && entry.isActive() ) set.add(key); } return Collections.unmodifiableSet(set); }",
        "ins1DelCode":"public Set<Object> keySet() { LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isActive() ) set.add(key); } return Collections.unmodifiableSet(set); }",
        "ins1PreCode":"public Set<Object> keySet() {   LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size()); Iterator<Map.Entry<?,?>> i = super.entrySet().iterator(); while ( i.hasNext() ) { Map.Entry<?,?> e = i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isActive() ) set.add(key); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (timeout == null || timeout == 0) { endTime.add(Calendar.SECOND, timeout);",
        "ins1DelCode":"if (timeout == null || timeout.intValue() == 0) { endTime.add(Calendar.SECOND, timeout.intValue());",
        "ins1PreCode":"try { StringBuilder sb = new StringBuilder(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); windowStart++; } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart < 0 || !sb.substring(windowStart).equals(s)) {",
        "ins2PreCode":"try { StringBuilder sb = new StringBuilder(); int windowStart = -s.length(); if (timeout == null || timeout.intValue() == 0) { while (windowStart < 0 || !sb.substring(windowStart).equals(s)) { sb.append((char) is.read()); windowStart++; } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (windowStart < 0 || !sb.substring(windowStart).equals(s)) {",
        "label":1
    },
    {
        "ins1AddCode":"WebAnnotationEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, corsConfiguration);",
        "ins1DelCode":"WebAnnotationEndpointDiscoverer endpointDiscoverer) { endpointDiscoverer.discoverEndpoints(), corsConfiguration);",
        "ins1PreCode":"public WebFluxEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, WebAnnotationEndpointDiscoverer endpointDiscoverer) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebFluxEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), endpointDiscoverer.discoverEndpoints(), corsConfiguration);",
        "ins2PreCode":"public WebMvcEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, WebAnnotationEndpointDiscoverer webEndpointDiscoverer) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebMvcEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), webEndpointDiscoverer.discoverEndpoints(), corsConfiguration);",
        "label":1
    },
    {
        "ins1AddCode":"int index = pair.indexOf('=');",
        "ins1DelCode":"int index = pair.indexOf(\"=\");",
        "ins1PreCode":"MutablePropertySources sources = context.getEnvironment().getPropertySources(); Map<String, Object> map = new HashMap<>(); for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0) ? pair.substring(0, index) : pair; String value = (index > 0) ? pair.substring(index + 1) : \"\";",
        "ins2PreCode":"MutablePropertySources sources = context.getEnvironment().getPropertySources(); Map<String, Object> map = new HashMap<>(); for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0) ? pair.substring(0, index) : pair; String value = (index > 0) ? pair.substring(index + 1) : \"\";",
        "label":1
    },
    {
        "ins1AddCode":"when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType);",
        "ins1DelCode":"when(mapperService.fullName(\"field\")).thenReturn(fieldType); when(mapperService.fullName(\"alias\")).thenReturn(fieldType);",
        "ins1PreCode":" NumberFieldType fieldType = new NumberFieldType(NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fullName(\"field\")).thenReturn(fieldType); when(mapperService.fullName(\"alias\")).thenReturn(fieldType);  SortedNumericDoubleValues doubleValues = mock(SortedNumericDoubleValues.class);",
        "ins2PreCode":"NumberFieldMapper.NumberFieldType fieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fullName(\"field\")).thenReturn(fieldType); when(mapperService.fullName(\"alias\")).thenReturn(fieldType); SortedNumericDoubleValues doubleValues = mock(SortedNumericDoubleValues.class);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(null, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), r);",
        "ins1DelCode":"new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r);",
        "ins1PreCode":"  r.setAutoPopulateSeriesFillPaint(true); new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r); assertEquals(DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE[0], r.lookupSeriesFillPaint(0));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), true, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() { @Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE); } }, true, 1, 1, 1);",
        "ins2PreCode":"TestHelper.checkBadSourceFlowable(new Function<Flowable<Integer>, Object>() { @Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide())); } }, true, 1, 1, 1);",
        "label":0
    },
    {
        "ins1AddCode":"corsConfiguration.setAllowedOrigins(Arrays.asList(\"https://example.com\"));",
        "ins1DelCode":"corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\"));",
        "ins1PreCode":"Environment environment, WebEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebFluxEndpointHandlerMapping(",
        "ins2PreCode":"Environment environment, WebEndpointDiscoverer endpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebMvcEndpointHandlerMapping(",
        "label":1
    },
    {
        "ins1AddCode":"XIntervalSeriesCollection<String> c1 = new XIntervalSeriesCollection<>(); XIntervalSeriesCollection<String> c2 = new XIntervalSeriesCollection<>(); XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series\"); XIntervalSeries<String> s2 = new XIntervalSeries<>(\"Series\"); c1.addSeries(new XIntervalSeries<>(\"Empty Series\")); c2.addSeries(new XIntervalSeries<>(\"Empty Series\"));",
        "ins1DelCode":"XIntervalSeriesCollection c1 = new XIntervalSeriesCollection(); XIntervalSeriesCollection c2 = new XIntervalSeriesCollection(); XIntervalSeries s1 = new XIntervalSeries(\"Series\"); XIntervalSeries s2 = new XIntervalSeries(\"Series\"); c1.addSeries(new XIntervalSeries(\"Empty Series\")); c2.addSeries(new XIntervalSeries(\"Empty Series\"));",
        "ins1PreCode":"public void testEquals() { XIntervalSeriesCollection c1 = new XIntervalSeriesCollection(); XIntervalSeriesCollection c2 = new XIntervalSeriesCollection(); assertEquals(c1, c2);   XIntervalSeries s1 = new XIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); assertFalse(c1.equals(c2)); XIntervalSeries s2 = new XIntervalSeries(\"Series\"); s2.add(1.0, 1.1, 1.2, 1.3); c2.addSeries(s2); assertTrue(c1.equals(c2));   c1.addSeries(new XIntervalSeries(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new XIntervalSeries(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "ins2PreCode":"public void testEquals() { YIntervalSeriesCollection c1 = new YIntervalSeriesCollection(); YIntervalSeriesCollection c2 = new YIntervalSeriesCollection(); assertEquals(c1, c2); YIntervalSeries s1 = new YIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); assertFalse(c1.equals(c2)); YIntervalSeries s2 = new YIntervalSeries(\"Series\"); s2.add(1.0, 1.1, 1.2, 1.3); c2.addSeries(s2); assertTrue(c1.equals(c2)); c1.addSeries(new YIntervalSeries(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new YIntervalSeries(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "label":1
    },
    {
        "ins1AddCode":"void globalError() throws Exception {",
        "ins1DelCode":"public void globalError() throws Exception {",
        "ins1PreCode":"public void globalError() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, \"BAD\"));",
        "ins2PreCode":"public void statusError() throws Exception { this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, \"/400\")); this.chain = new TestFilterChain((request, response, chain) -> response.sendError(400, \"BAD\"));",
        "label":1
    },
    {
        "ins1AddCode":"if (col.size() == 0) { return; }",
        "ins1DelCode":"if (col.size() == 0) return;",
        "ins1PreCode":"protected void addAll(Collection col) { if (col.size() == 0) return; Iterator it = col.iterator(); fireListEvents = false;",
        "ins2PreCode":"protected void addAll(Collection col) { if (col.size() == 0) return; Iterator it = col.iterator(); fireListEvents = false;",
        "label":1
    },
    {
        "ins1AddCode":".compose(TestHelper.conditional())",
        "ins1DelCode":".filter(Functions.alwaysTrue())",
        "ins1PreCode":" Flowable.range(1, 5).hide() .doFinally(this) .filter(Functions.alwaysTrue()) .subscribe(ts); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"readRDD.foreach(pair -> pair._2().toArray());",
        "ins1DelCode":"readRDD.foreach(new VoidFunction<Tuple2<String,PortableDataStream>>() { @Override public void call(Tuple2<String, PortableDataStream> pair) { pair._2().toArray(); } });",
        "ins1PreCode":"channel1.close();  JavaPairRDD<String, PortableDataStream> readRDD = sc.binaryFiles(tempDirName).cache(); readRDD.foreach(new VoidFunction<Tuple2<String,PortableDataStream>>() { @Override public void call(Tuple2<String, PortableDataStream> pair) { pair._2().toArray(); } });  List<Tuple2<String, PortableDataStream>> result = readRDD.collect();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); Exception error = new TestException(); publishNext(observer, 100, \"one\");",
        "ins2PreCode":"Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); Exception error = new TestException(); publishNext(subscriber, 100, \"one\");",
        "label":0
    },
    {
        "ins1AddCode":"void shouldGetAUser() {",
        "ins1DelCode":"public void shouldGetAUser() {",
        "ins1PreCode":"public void shouldGetAUser() { sqlSessionFactory.getConfiguration().setAutoMappingBehavior(AutoMappingBehavior.NONE); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetAUserWhithPhoneNumber() { sqlSessionFactory.getConfiguration().setAutoMappingBehavior(AutoMappingBehavior.NONE); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"ERROR: No such item \u2018never_created\u2019 exists.\"));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"ERROR: No such job \\u2018never_created\\u2019 exists.\"));",
        "ins1PreCode":".invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such job \\u2018never_created\\u2019 exists.\"));",
        "ins2PreCode":".invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\"));",
        "label":0
    },
    {
        "ins1AddCode":"try (Connection con = datasource.getConnection()) { Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 0\",0,datasource.getPool().getActive()); }",
        "ins1DelCode":"Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 0\",0,datasource.getPool().getActive()); con.close();",
        "ins1PreCode":"this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(100); this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 0\",0,datasource.getPool().getActive()); con.close();",
        "ins2PreCode":"this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(100); this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable d1 = Disposable.empty();",
        "ins1DelCode":"final Disposable d1 = Disposables.empty();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty();  cd.add(d1);",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final ListCompositeDisposable cd = new ListCompositeDisposable(); final Disposable d1 = Disposables.empty(); cd.add(d1);",
        "label":1
    },
    {
        "ins1AddCode":"FutureTask<Integer> ft = new FutureTask<>(Functions.justCallable(1));",
        "ins1DelCode":"FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1));",
        "ins1PreCode":"public void timeout() { FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1));  Maybe.fromFuture(ft, 1, TimeUnit.MILLISECONDS).test()",
        "ins2PreCode":"public void timedWait() { FutureTask<Integer> ft = new FutureTask<Integer>(Functions.justCallable(1)); Maybe.fromFuture(ft, 1, TimeUnit.MILLISECONDS).test()",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void disposeInner() { final TestObserver<Object> to = new TestObserver<Object>();  Observable.just(1).flatMapSingle(new Function<Integer, SingleSource<Object>>() {",
        "ins2PreCode":"public void disposeInner() { final TestObserver<Object> to = new TestObserver<Object>(); Observable.just(1).flatMapMaybe(new Function<Integer, MaybeSource<Object>>() {",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty(); to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"Disposable d = Disposables.empty(); to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {  TestObserver<Integer> to = new TestObserver<Integer>(); Disposable d = Disposables.empty(); final QueueDrainObserver<Integer, Integer, Integer> qd = createUnordered(to, d); to.onSubscribe(Disposables.empty());  Runnable r1 = new Runnable() {",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<Integer>(); Disposable d = Disposables.empty(); final QueueDrainObserver<Integer, Integer, Integer> qd = createOrdered(to, d); to.onSubscribe(Disposables.empty()); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"TextUtils.drawAlignedString(label, g2,",
        "ins1DelCode":"TextUtilities.drawAlignedString(label, g2,",
        "ins1PreCode":"g2.setPaint(marker.getLabelBackgroundColor()); g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(), marker.getLabelTextAnchor());",
        "ins2PreCode":"g2.setPaint(marker.getLabelBackgroundColor()); g2.fill(r); g2.setPaint(marker.getLabelPaint()); TextUtilities.drawAlignedString(label, g2, (float) coords.getX(), (float) coords.getY(), marker.getLabelTextAnchor());",
        "label":1
    },
    {
        "ins1AddCode":"protected void subscribeActual(@NonNull Subscriber<? super T> t) {",
        "ins1DelCode":"protected void subscribeActual(Subscriber<? super T> t) {",
        "ins1PreCode":"protected void subscribeActual(Subscriber<? super T> t) { PublishSubscription<T> ps = new PublishSubscription<>(t, this); t.onSubscribe(ps);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Disposable sub1 = Disposable.empty(); Disposable sub2 = Disposable.empty();",
        "ins1DelCode":"Disposable sub1 = Disposables.empty(); Disposable sub2 = Disposables.empty();",
        "ins1PreCode":"} };  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty();  consumer.onSubscribe(sub2);",
        "ins2PreCode":"} }; Disposable sub1 = Disposables.empty(); consumer.onSubscribe(sub1); assertFalse(sub1.isDisposed()); Disposable sub2 = Disposables.empty(); consumer.onSubscribe(sub2);",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair(in -> { List<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) { Tuple2<String, Integer> next = in.next(); out.add(next.swap()); } return out.iterator(); });",
        "ins1DelCode":"JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair( new PairFlatMapFunction<Iterator<Tuple2<String, Integer>>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Iterator<Tuple2<String, Integer>> in) { List<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) { Tuple2<String, Integer> next = in.next(); out.add(next.swap()); } return out.iterator(); } });",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair( new PairFlatMapFunction<Iterator<Tuple2<String, Integer>>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Iterator<Tuple2<String, Integer>> in) { List<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) {",
        "ins2PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapPartitionsToPair(in -> { Tuple2<String, Integer> next = in.next(); Arrays.asList( LinkedList<Tuple2<Integer, String>> out = new LinkedList<>(); LinkedList<Tuple2<Integer, String>> out = new LinkedList<>(); while (in.hasNext()) {",
        "label":0
    },
    {
        "ins1AddCode":"}, true, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"}, 2, true, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); } });",
        "ins2PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, false); } });",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(graph.edgeValueOrNull(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValueOrNull(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrNull(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrNull(4, 4)).isEqualTo(\"valueD\");",
        "ins1DelCode":"assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\");",
        "ins1PreCode":"graph.putEdgeValue(2, 3, \"valueC\"); graph.putEdgeValue(4, 4, \"valueD\");  assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\");  String toString = graph.toString();",
        "ins2PreCode":"graph.putEdgeValue(2, 3, \"valueC\"); graph.putEdgeValue(4, 4, \"valueD\"); assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\"); String toString = graph.toString();",
        "label":1
    },
    {
        "ins1AddCode":"public void customProtocolResolverIsUsedInNonWebApplication() {",
        "ins1DelCode":"public void customProtocolResolverIsUsedInNonWebApplication() throws Exception {",
        "ins1PreCode":"public void customProtocolResolverIsUsedInNonWebApplication() throws Exception { GenericApplicationContext context = new GenericApplicationContext(); Resource resource = mock(Resource.class);",
        "ins2PreCode":"public void customProtocolResolverIsUsedInWebApplication() throws Exception { GenericWebApplicationContext context = new GenericWebApplicationContext( Resource resource = mock(Resource.class);",
        "label":1
    },
    {
        "ins1AddCode":"} catch (XStreamException | LinkageError e) {",
        "ins1DelCode":"} catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) {",
        "ins1PreCode":"items.add(item); } catch (CriticalXStreamException e) { throw e; } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { RobustReflectionConverter.addErrorInContext(context, e); }",
        "ins2PreCode":"collection.add(item); } catch (CriticalXStreamException e) { throw e; } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { RobustReflectionConverter.addErrorInContext(context, e); }",
        "label":1
    },
    {
        "ins1AddCode":"if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'') { }",
        "ins1DelCode":"if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'' || c1 == '#' || c1 == '$') {",
        "ins1PreCode":"char c = image.charAt(i); if (c == '\\\\' && i + 1 < size) { char c1 = image.charAt(i + 1); if (c1 == '\\\\' || c1 == '\"' || c1 == '\\'' || c1 == '#' || c1 == '$') { c = c1; i++;",
        "ins2PreCode":"char c = image.charAt(i); if (c == '\\\\' && i + 2 < size) { char c1 = image.charAt(i + 1); if ((c1 == '#' || c1 == '$') && c2 == '{')  { if ((c1 == '#' || c1 == '$') && c2 == '{')  { c = c1; i++;",
        "label":0
    },
    {
        "ins1AddCode":"List<AuditEvent> events = repository.find(\"dave\", null, null);",
        "ins1DelCode":"List<AuditEvent> events = repository.find(\"dave\", null);",
        "ins1PreCode":"repository.add(new AuditEvent(\"phil\", \"b\")); repository.add(new AuditEvent(\"dave\", \"c\")); repository.add(new AuditEvent(\"phil\", \"d\")); List<AuditEvent> events = repository.find(\"dave\", null); assertThat(events.size()).isEqualTo(2); assertThat(events.get(0).getType()).isEqualTo(\"a\");",
        "ins2PreCode":"repository.add(new AuditEvent(\"phil\", \"b\")); repository.add(new AuditEvent(\"dave\", \"c\")); repository.add(new AuditEvent(\"phil\", \"d\")); List<AuditEvent> events = repository.find(\"dave\", null, \"a\"); assertThat(events.size()).isEqualTo(1); assertThat(events.get(0).getType()).isEqualTo(\"a\");",
        "label":0
    },
    {
        "ins1AddCode":"public void setup() throws Exception { MockitoAnnotations.openMocks(this).close();",
        "ins1DelCode":"public void setup() { MockitoAnnotations.initMocks(this);",
        "ins1PreCode":"public void setup() { memoryManager = new TestMemoryManager( new SparkConf() .set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), useOffHeapMemoryAllocator()) .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 256 * 1024 * 1024L) .set(package$.MODULE$.SHUFFLE_SPILL_COMPRESS(), false) .set(package$.MODULE$.SHUFFLE_COMPRESS(), false)); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);  tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(invocationOnMock -> {",
        "ins2PreCode":"public void setUp() { serializerManager, serializerManager, anyInt(), return Tuple2$.MODULE$.apply(blockId, file); return Tuple2$.MODULE$.apply(blockId, file); return Tuple2$.MODULE$.apply(blockId, file); return Tuple2$.MODULE$.apply(blockId, file); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(invocationOnMock -> {",
        "label":1
    },
    {
        "ins1AddCode":"try { @SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); try { int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } finally { fis2.close(); } finally { fis1.close();",
        "ins1DelCode":"@SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false;",
        "ins1PreCode":" @SuppressWarnings(\"resource\") FileInputStream fis1 = new FileInputStream(file1); @SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } return true;",
        "ins2PreCode":"@SuppressWarnings(\"resource\") FileInputStream fis1 = new FileInputStream(file1); @SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } return true;",
        "label":0
    },
    {
        "ins1AddCode":"v = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1DelCode":"v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"R v;  try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);  ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"R v; try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); ParallelFailureHandling h; try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void putEdge_allowsSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue();  assertThat(graphAsMutableGraph.putEdge(N1, N1)).isTrue();",
        "ins2PreCode":"public void putEdge_allowsSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); assertThat(graphAsMutableGraph.putEdge(N1, N1)).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"synchronized (watchedResourcesLock) {",
        "ins1DelCode":"synchronized (watchedResources) {",
        "ins1PreCode":"public void removeWatchedResource(String name) {  synchronized (watchedResources) {  ",
        "ins2PreCode":"public void removeWelcomeFile(String name) { synchronized (welcomeFiles) {",
        "label":1
    },
    {
        "ins1AddCode":"public void nodeOrder_insertion() {",
        "ins1DelCode":"public void nodeOrder_insertion() throws Exception {",
        "ins1PreCode":"public void nodeOrder_insertion() throws Exception { MutableGraph<Integer> graph = GraphBuilder .directed()",
        "ins2PreCode":"public void nodeOrder_default() throws Exception { MutableGraph<Integer> graph = GraphBuilder .directed()",
        "label":1
    },
    {
        "ins1AddCode":"return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "ins1DelCode":"return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins1PreCode":"public RestTemplateBuilder additionalMessageConverters( Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins2PreCode":"return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer,",
        "label":0
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(-621187200000L, d.getFirstMillisecond(cal)); d.getFirstMillisecond((Calendar) null);",
        "ins1DelCode":"assertEquals(-621187200000L, d.getFirstMillisecond(zone)); d.getFirstMillisecond((TimeZone) null);",
        "ins1PreCode":"public void testGetFirstMillisecondWithTimeZone() { Day d = new Day(26, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-621187200000L, d.getFirstMillisecond(zone));   boolean pass = false; try { d.getFirstMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "ins2PreCode":"public void testGetLastMillisecondWithTimeZone() { Day d = new Day(1, 2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-628358400001L, d.getLastMillisecond(zone)); boolean pass = false; try { d.getLastMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "label":1
    },
    {
        "ins1AddCode":"verifyNoInteractions(callbackInstance);",
        "ins1DelCode":"verifyZeroInteractions(callbackInstance);",
        "ins1PreCode":"String argument = \"foo\"; LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument) .invoke((c) -> c.handle(null)); verifyZeroInteractions(callbackInstance);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"protected void subscribeActual(SingleObserver<? super T> observer) { Disposable d = Disposables.empty(); observer.onSubscribe(d); ",
        "ins2PreCode":"protected void subscribeActual(SingleObserver<? super T> observer) { Disposable d = Disposables.empty(); observer.onSubscribe(d);",
        "label":1
    },
    {
        "ins1AddCode":"public void retentionFiltering() {",
        "ins1DelCode":"public void retentionFiltering() throws Exception {",
        "ins1PreCode":"public void retentionFiltering() throws Exception { DumbSlave.DescriptorImpl descriptor = j.getInstance().getDescriptorByType(DumbSlave.DescriptorImpl.class);",
        "ins2PreCode":"public void propertyFiltering() throws Exception { DumbSlave.DescriptorImpl descriptor = j.getInstance().getDescriptorByType(DumbSlave.DescriptorImpl.class);",
        "label":1
    },
    {
        "ins1AddCode":"\"/test/bug49nnn/bug49297NoSpace.jsp\", res, null);",
        "ins1DelCode":"\"/test/bug49nnn/bug49297NoSpace.jsp\", res, new HashMap<String,List<String>>());",
        "ins1PreCode":" ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297NoSpace.jsp\", res, new HashMap<String,List<String>>());  ",
        "ins2PreCode":"ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297MultipleImport1.jsp\", res, new HashMap<String,List<String>>());",
        "label":1
    },
    {
        "ins1AddCode":"Project project = ProjectManager.getManager().getCurrentProject(); UmlFactoryDefaults defaults = project.getUmlFactoryDefaults(); Object attr = Model.getUmlFactory().buildNode(Model.getMetaTypes().getOperation(), classifier, null, defaults); TargetManager.getInstance().setTarget(attr);",
        "ins1DelCode":"Project project = ProjectManager.getManager().getCurrentProject(); Object returnType = project.getDefaultReturnType(); Object oper = Model.getCoreFactory().buildOperation(classifier, returnType); TargetManager.getInstance().setTarget(oper);",
        "ins1PreCode":"return; }  Object returnType = project.getDefaultReturnType(); Object oper = Model.getCoreFactory().buildOperation(classifier, returnType); TargetManager.getInstance().setTarget(oper); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void specificResource() {",
        "ins1DelCode":"public void specificResource() throws Exception {",
        "ins1PreCode":"public void specificResource() throws Exception { String location = \"classpath:specificlocation.properties\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void specificResourceFromAdditionalLocation() throws Exception { String additionalLocation = \"classpath:specificlocation.properties\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1AddCode":"runGenericFileSourceOptionsExample(spark);",
        "ins1DelCode":"",
        "ins1PreCode":".getOrCreate();  runBasicDataSourceExample(spark); runBasicParquetExample(spark); runParquetSchemaMergingExample(spark); runJsonDatasetExample(spark);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void assertEqualContent(File expect, File result) throws IOException { assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists());",
        "ins1DelCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { if (!result.exists()) { fail(\"Expected file \" + result + \" doesn\\'t exist\"); }",
        "ins1PreCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { if (!result.exists()) { fail(\"Expected file \" + result + \" doesn\\'t exist\"); } ",
        "ins2PreCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { assertTrue(\"Expected file \" + result + \" doesn\\'t exist\", result.exists()); assertTrue(\"Expected file \" + result + \" doesn\\'t exist\", result.exists()); }",
        "label":0
    },
    {
        "ins1AddCode":"void shouldRemoveItemOnDemand() {",
        "ins1DelCode":"public void shouldRemoveItemOnDemand() {",
        "ins1PreCode":"public void shouldRemoveItemOnDemand() { Cache cache = new PerpetualCache(\"default\"); cache = new SynchronizedCache(cache);",
        "ins2PreCode":"public void shouldRemoveItemOnDemand() { FifoCache cache = new FifoCache(new PerpetualCache(\"default\")); FifoCache cache = new FifoCache(new PerpetualCache(\"default\"));",
        "label":1
    },
    {
        "ins1AddCode":"throw new AssertionError(\"Blocking call didn't finish after timeout!\", e);",
        "ins1DelCode":"fail(\"Blocking call didn't finish after timeout!\");",
        "ins1PreCode":"try { exec_task.get(2*TIMEOUT, TimeUnit.MILLISECONDS); } catch (TimeoutException e) { fail(\"Blocking call didn't finish after timeout!\"); } assertThat(exec_task.isDone(), equalTo(true));",
        "ins2PreCode":"return null; get(exec_task); public void quietDownShouldSuccessWithBlockAndNonExpiredTimeoutAndFinishingExecutor() throws Exception { final OneShotEvent finish = new OneShotEvent(); } assertThat(project.isBuilding(), equalTo(false));",
        "label":0
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Double>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.avg(value -> value._2() * 2.0));",
        "ins1DelCode":"Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.avg(value -> value._2() * 2.0));",
        "ins1PreCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.avg(value -> value._2() * 2.0)); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)),",
        "ins2PreCode":"public void testTypedAggregationAverage() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.avg(v -> (double)(v._2() * 2))); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 6.0)),",
        "label":1
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaMinMaxScalerExample\").getOrCreate(); Dataset<Row> dataFrame = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JaveMinMaxScalerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); jsc.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JaveMinMaxScalerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MinMaxScaler scaler = new MinMaxScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MinMaxScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  jsc.stop();",
        "ins2PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaMaxAbsScalerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\"); MaxAbsScalerModel scalerModel = scaler.fit(dataFrame); Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show(); jsc.stop();",
        "label":0
    },
    {
        "ins1AddCode":"@Override",
        "ins1DelCode":"",
        "ins1PreCode":"public void testHash1() throws Exception { CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() { public int next(int n) { return n-1; }",
        "ins2PreCode":"public void testHash2() throws Exception { CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() { public int next(int n) { return 1; }",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void boundedBlockingSubscribeConsumerConsumerActionBufferExceed() { final List<Object> list = new ArrayList<Object>();  Consumer<Object> cons = new Consumer<Object>() {",
        "ins2PreCode":"public void boundedBlockingSubscribeConsumerConsumerActionBufferExceedMillionItem() { final List<Object> list = new ArrayList<Object>(); Consumer<Object> cons = new Consumer<Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"throw new IllegalArgumentException(sm.getString(\"userMBean.invalidRole\", rolename));",
        "ins1DelCode":"throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\");",
        "ins1PreCode":"} Role role = user.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\"); } user.addRole(role);",
        "ins2PreCode":"} Role role = user.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\"); } user.removeRole(role);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"OK\", bc.toString()); Assert.assertEquals(\"1false2true3true4true5false\", servlet.getResult());",
        "ins1DelCode":"assertEquals(\"OK\", bc.toString()); assertEquals(\"1false2true3true4true5false\", servlet.getResult());",
        "ins1PreCode":"  ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\"); assertEquals(\"OK\", bc.toString());   int counter = 0; while (!servlet.isDone() && counter < 10) { Thread.sleep(1000); counter++; }  assertEquals(\"1false2true3true4true5false\", servlet.getResult());  ",
        "ins2PreCode":"ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\"); assertEquals(\"OK\", bc.toString()); int counter = 0; while (!servlet.isDone() && counter < 10) { Thread.sleep(1000); counter++; } assertEquals(\"1false2true3true4true5false\", servlet.getResult());",
        "label":1
    },
    {
        "ins1AddCode":"assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\"));",
        "ins1DelCode":"assertEquals(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\").toString());",
        "ins1PreCode":"f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click(); submit(f); assertEquals(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\").toString());",
        "ins2PreCode":"f.getInputByValue(\"\").setValueAttribute(\"txt 4\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click(); submit(f); assertEquals(\"[{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"1\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"2\\\"},\" + \"{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"three\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt 4\\\"}]\", formData.get(\"foos\").toString());",
        "label":1
    },
    {
        "ins1AddCode":"(expectedJson != null) ? expectedJson.toString() : null,",
        "ins1DelCode":"((expectedJson != null) ? expectedJson.toString() : null),",
        "ins1PreCode":"} try { return JSONCompare.compareJSON( ((expectedJson != null) ? expectedJson.toString() : null), this.actual.toString(), compareMode); }",
        "ins2PreCode":"} try { return JSONCompare.compareJSON( ((expectedJson != null) ? expectedJson.toString() : null), this.actual.toString(), comparator); }",
        "label":1
    },
    {
        "ins1AddCode":"ds.setBasedir(new File(getProject().getProperty(\"output\")));",
        "ins1DelCode":"ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\"));",
        "ins1PreCode":"public void testFullPathMatchesCaseInsensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setCaseSensitive(false); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/beta/gamma/GAMMA.XML\"}); ds.scan();",
        "ins2PreCode":"public void testExcludeOneFile() { DirectoryScanner ds = new DirectoryScanner(); ds.scan(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, ds.scan();",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Boolean> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Boolean> to = new TestObserverEx<Boolean>();",
        "ins1PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException(); ",
        "ins2PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException();",
        "label":1
    },
    {
        "ins1AddCode":"queue = new SpscLinkedArrayQueue<>(prefetch);",
        "ins1DelCode":"queue = new SpscLinkedArrayQueue<T>(prefetch);",
        "ins1PreCode":"} }  queue = new SpscLinkedArrayQueue<T>(prefetch);  downstream.onSubscribe(this);",
        "ins2PreCode":"} } queue = new SpscLinkedArrayQueue<T>(bufferSize); downstream.onSubscribe(this);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertNotMatchValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts); ",
        "ins2PreCode":"public void assertNeverAtNotMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts);",
        "ins1PreCode":"public void onNextOnErrorRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts);  BooleanSubscription bs = new BooleanSubscription();",
        "ins2PreCode":"public void onNextOnErrorRaceDelayError() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts, true); BooleanSubscription bs = new BooleanSubscription();",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<MaybeObserver<? super Integer>> moRef = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<MaybeObserver<? super Integer>> moRef = new AtomicReference<MaybeObserver<? super Integer>>();",
        "ins1PreCode":"public void innerErrorAfterTermination() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<MaybeObserver<? super Integer>> moRef = new AtomicReference<MaybeObserver<? super Integer>>();  TestObserverEx<Integer> to = new Observable<Integer>() {",
        "ins2PreCode":"public void innerErrorAfterTermination() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<SingleObserver<? super Integer>> moRef = new AtomicReference<SingleObserver<? super Integer>>(); TestObserverEx<Integer> to = new Observable<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"void parentFirstWithDifferentProfile() {",
        "ins1DelCode":"public void parentFirstWithDifferentProfile() {",
        "ins1PreCode":"public void parentFirstWithDifferentProfile() { SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class).profiles(\"node\") .properties(\"transport=redis\").child(ChildConfig.class).profiles(\"admin\").web(WebApplicationType.NONE);",
        "ins2PreCode":"public void parentFirstWithDifferentProfileAndExplicitEnvironment() { SpringApplicationBuilder application = new SpringApplicationBuilder(ExampleConfig.class) .child(ChildConfig.class).profiles(\"admin\").web(WebApplicationType.NONE);",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(\"x-forwarded-proto is null\", actualSecure); assertFalse(\"postInvoke secure\", actualPostInvokeSecure);",
        "ins1DelCode":"assertEquals(\"x-forwarded-proto is null\", false, actualSecure); assertEquals(\"postInvoke secure\", false, actualPostInvokeSecure);",
        "ins1PreCode":"assertEquals(\"x-forwarded-proto is null\", 8080, actualServerPort);  boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure(); assertEquals(\"x-forwarded-proto is null\", false, actualSecure);  boolean actualPostInvokeSecure = request.isSecure(); assertEquals(\"postInvoke secure\", false, actualPostInvokeSecure);  int actualPostInvokeServerPort = request.getServerPort();",
        "ins2PreCode":"assertEquals(\"x-forwarded-proto is null\", 8443, actualServerPort); boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure(); assertEquals(\"x-forwarded-proto is null\", true, actualSecure); boolean actualPostInvokeSecure = request.isSecure(); assertEquals(\"postInvoke secure\", true, actualPostInvokeSecure); int actualPostInvokeServerPort = request.getServerPort();",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(0L);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);",
        "ins1PreCode":"rs.onNext(3); rs.onComplete();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);  rs.subscribe(ts);",
        "ins2PreCode":"rs.onNext(3); rs.onComplete(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); rs.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"Path testBibtexFile = Path.of(\"src/test/resources/testbib/bibWithUserComments.bib\"); assertEquals(Files.readString(Path.of(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins1DelCode":"Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins1PreCode":"void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(StandardField.AUTHOR, \"Mr. Author\");  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JoinProcessor joinProcessor = factory.create(null, processorTag, null, config);",
        "ins1DelCode":"JoinProcessor joinProcessor = factory.create(null, processorTag, config);",
        "ins1PreCode":"config.put(\"field\", \"field1\"); config.put(\"separator\", \"-\"); String processorTag = randomAlphaOfLength(10); JoinProcessor joinProcessor = factory.create(null, processorTag, config); assertThat(joinProcessor.getTag(), equalTo(processorTag)); assertThat(joinProcessor.getField(), equalTo(\"field1\"));",
        "ins2PreCode":"config.put(\"field\", \"field1\"); config.put(\"separator\", \"-\"); String processorTag = randomAlphaOfLength(10); JoinProcessor joinProcessor = factory.create(null, processorTag, config); assertThat(joinProcessor.getTag(), equalTo(processorTag)); assertThat(joinProcessor.getField(), equalTo(\"field1\"));",
        "label":1
    },
    {
        "ins1AddCode":"TimePeriodValues<String> s = new TimePeriodValues<>(\"Test\");",
        "ins1DelCode":"TimePeriodValues s = new TimePeriodValues(\"Test\");",
        "ins1PreCode":"public void testGetMaxMiddleIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMaxMiddleIndex()); s.add(new SimpleTimePeriod(100L, 200L), 1.0);",
        "ins2PreCode":"public void getMinEndIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMinEndIndex()); s.add(new SimpleTimePeriod(100L, 200L), 1.0);",
        "label":1
    },
    {
        "ins1AddCode":"}, false, 16, ImmediateThinScheduler.INSTANCE)",
        "ins1DelCode":"}, 16, false, ImmediateThinScheduler.INSTANCE)",
        "ins1PreCode":"public Observable<Integer> apply(Object v) throws Exception { return Observable.just(1); } }, 16, false, ImmediateThinScheduler.INSTANCE) .test() .assertResult(1);",
        "ins2PreCode":"public Flowable<Integer> apply(Object v) throws Exception { return Flowable.just(1); } }, 16, false, ImmediateThinScheduler.INSTANCE) .test() .assertResult(1);",
        "label":1
    },
    {
        "ins1AddCode":"void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {",
        "ins1DelCode":"public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {",
        "ins1PreCode":"public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { Ssl ssl = new Ssl(); ssl.setClientAuth(Ssl.ClientAuth.NEED);",
        "ins2PreCode":"public void sslNeedsClientAuthenticationFailsWithoutClientCertificate() { Ssl ssl = new Ssl(); ssl.setClientAuth(Ssl.ClientAuth.NEED);",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0);",
        "ins1DelCode":"assertTrue(res.toString().indexOf(\"<h1>Hello World!</h1>\") > 0);",
        "ins1PreCode":"tomcat.start(); ByteChunk res = getUrl(\"https://localhost:\" + getPort() + \"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<h1>Hello World!</h1>\") > 0);",
        "ins2PreCode":"tomcat.start(); ByteChunk res = getUrl(\"https://localhost:\" + getPort() + \"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<h1>Hello World!</h1>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"StandardPieSectionLabelGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"StandardPieSectionLabelGenerator g2 = (StandardPieSectionLabelGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StandardPieSectionLabelGenerator g1 = new StandardPieSectionLabelGenerator(); StandardPieSectionLabelGenerator g2 = (StandardPieSectionLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g1 IntervalCategoryToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() {",
        "ins1DelCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() throws Exception {",
        "ins1PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() throws Exception { TestPropertyValues .of(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\")",
        "ins2PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() throws Exception { TestPropertyValues .of(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\")",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new Observable<Notification<Object>>() { @Override protected void subscribeActual(Observer<? super Notification<Object>> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(Notification.createOnComplete()); observer.onNext(Notification.<Object>createOnNext(1));",
        "ins2PreCode":"new Flowable<Notification<Object>>() { @Override protected void subscribeActual(Subscriber<? super Notification<Object>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(Notification.createOnComplete()); subscriber.onNext(Notification.<Object>createOnNext(1));",
        "label":0
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.zFormat, that.zFormat)) { if (!Objects.equals(this.zDateFormat, that.zDateFormat)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.zFormat, that.zFormat)) { if (!ObjectUtils.equal(this.zDateFormat, that.zDateFormat)) {",
        "ins1PreCode":"return false; } BubbleXYItemLabelGenerator that = (BubbleXYItemLabelGenerator) obj; if (!ObjectUtils.equal(this.zFormat, that.zFormat)) { return false; } if (!ObjectUtils.equal(this.zDateFormat, that.zDateFormat)) { return false; }",
        "ins2PreCode":"return false; } StandardXYZToolTipGenerator that = (StandardXYZToolTipGenerator) obj; if (!ObjectUtils.equal(this.zFormat, that.zFormat)) { return false; } if (!ObjectUtils.equal(this.zDateFormat, that.zDateFormat)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"this.bootstrapContext, Arrays.asList(contributor));",
        "ins1DelCode":"this.bootstrapRegistry, Arrays.asList(contributor));",
        "ins1PreCode":"propertySource.setProperty(\"test\", \"springboot\"); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext); assertThat(binder.bind(\"test\", String.class).get()).isEqualTo(\"springboot\");",
        "ins2PreCode":"propertySource.setProperty(\"other\", \"springboot\"); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext); assertThat(binder.bind(\"test\", String.class).get()).isEqualTo(\"springboot\");",
        "label":1
    },
    {
        "ins1AddCode":"try (FileChannel channel1 = fos1.getChannel()) { ByteBuffer bbuf = ByteBuffer.wrap(content1); channel1.write(bbuf); }",
        "ins1DelCode":"FileChannel channel1 = fos1.getChannel(); ByteBuffer bbuf = ByteBuffer.wrap(content1); channel1.write(bbuf); channel1.close();",
        "ins1PreCode":" FileOutputStream fos1 = new FileOutputStream(file1);  FileChannel channel1 = fos1.getChannel(); ByteBuffer bbuf = ByteBuffer.wrap(content1); channel1.write(bbuf); channel1.close(); JavaPairRDD<String, PortableDataStream> readRDD = sc.binaryFiles(tempDirName, 3); List<Tuple2<String, PortableDataStream>> result = readRDD.collect();",
        "ins2PreCode":"FileOutputStream fos1 = new FileOutputStream(file1); FileChannel channel1 = fos1.getChannel(); ByteBuffer bbuf = ByteBuffer.wrap(content1); channel1.write(bbuf); channel1.close(); JavaPairRDD<String, PortableDataStream> readRDD = sc.binaryFiles(tempDirName).cache(); List<Tuple2<String, PortableDataStream>> result = readRDD.collect();",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(!graph.edgeValueOrDefault(node, otherNode, DEFAULT).equals(DEFAULT)) .isEqualTo(hasEdge);",
        "ins1DelCode":"",
        "ins1PreCode":"boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); } }",
        "ins2PreCode":"boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); } }",
        "label":1
    },
    {
        "ins1AddCode":"void parseRecognizesFieldsWithBracketsEnclosedInQuotationMarks() throws IOException {",
        "ins1DelCode":"public void parseRecognizesFieldsWithBracketsEnclosedInQuotationMarks() throws IOException {",
        "ins1PreCode":"public void parseRecognizesFieldsWithBracketsEnclosedInQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Test {Ed {von} Test}\\\"}\"));",
        "ins2PreCode":"public void parseRecognizesFieldsWithEscapedQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Test {\\\" Test}\\\"}\"));",
        "label":1
    },
    {
        "ins1AddCode":"corsConfiguration, new EndpointLinksResolver(endpointDiscoverer.getEndpoints()));",
        "ins1DelCode":"corsConfiguration);",
        "ins1PreCode":"return new WebFluxEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), endpointDiscoverer.getEndpoints(), endpointMediaTypes, corsConfiguration);",
        "ins2PreCode":"return new WebMvcEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), endpointDiscoverer.getEndpoints(), endpointMediaTypes, corsConfiguration);",
        "label":1
    },
    {
        "ins1AddCode":"Group objectsGroup = UIUtils.createControlGroup(composite, MySQLUIMessages.tools_db_export_wizard_page_settings_group_objects, 1, GridData.FILL_HORIZONTAL, 0);",
        "ins1DelCode":"Group objectsGroup = UIUtils.createControlGroup(composite, MySQLMessages.tools_db_export_wizard_page_settings_group_objects, 1, GridData.FILL_HORIZONTAL, 0);",
        "ins1PreCode":"{ Composite composite = UIUtils.createPlaceholder(parent, 1);  Group objectsGroup = UIUtils.createControlGroup(composite, MySQLMessages.tools_db_export_wizard_page_settings_group_objects, 1, GridData.FILL_HORIZONTAL, 0); objectsGroup.setLayoutData(new GridData(GridData.FILL_BOTH)); ",
        "ins2PreCode":"{ Composite composite = UIUtils.createPlaceholder(parent, 1); Group objectsGroup = UIUtils.createControlGroup(composite, PostgreMessages.wizard_backup_page_object_group_object, 1, GridData.FILL_HORIZONTAL, 0); objectsGroup.setLayoutData(new GridData(GridData.FILL_BOTH));",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command)",
        "ins1PreCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command) { String sql = buildStatement(command.getObject(), true);",
        "ins2PreCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command) { String sql = buildStatement(command.getObject(), true);",
        "label":1
    },
    {
        "ins1AddCode":"void testCallWithResultSet3_a1() {",
        "ins1DelCode":"public void testCallWithResultSet3_a1() {",
        "ins1PreCode":"public void testCallWithResultSet3_a1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins2PreCode":"public void testCallWithResultSet4_a1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Boolean> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Boolean> to = new TestObserverEx<Boolean>();",
        "ins1PreCode":"public void predicateThrowsExceptionAndValueInCauseMessageObservable() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException(); ",
        "ins2PreCode":"public void predicateThrowsExceptionAndValueInCauseMessage() { TestObserverEx<Boolean> to = new TestObserverEx<Boolean>(); final IllegalArgumentException ex = new IllegalArgumentException();",
        "label":1
    },
    {
        "ins1AddCode":"javac.setCompiler(\"javac1.8\");",
        "ins1DelCode":"javac.setCompiler(\"javac8\");",
        "ins1PreCode":"LogCapturingJavac javac = new LogCapturingJavac(); Project p = new Project(); javac.setProject(p); javac.setCompiler(\"javac8\"); javac.setSource(\"6\"); javac.setTarget(\"6\");",
        "ins2PreCode":"LogCapturingJavac javac = new LogCapturingJavac(); Project p = new Project(); javac.setProject(p); javac.setCompiler(\"javac9\"); javac.setSource(\"6\"); javac.setTarget(\"6\");",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateStarShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateStarShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"fastPath(a, iterator);",
        "ins1DelCode":"slowPath(a, iterator);",
        "ins1PreCode":"long e = 0L;  if (r == Long.MAX_VALUE) { slowPath(a, iterator); return; }",
        "ins2PreCode":"long e = 0L; if (r == Long.MAX_VALUE) { fastPath(a, iterator); return; }",
        "label":0
    },
    {
        "ins1AddCode":"Args.requireNonNegative(index, \"index\");",
        "ins1DelCode":"ParamChecks.requireNonNegative(index, \"index\");",
        "ins1PreCode":"public ValueAxis getRangeAxisForDataset(int index) { ParamChecks.requireNonNegative(index, \"index\"); ValueAxis valueAxis; List axisIndices = (List) this.datasetToRangeAxesMap.get(",
        "ins2PreCode":"public ValueAxis getAxisForDataset(int index) { new Integer(index)); ValueAxis valueAxis; List axisIndices = (List) this.datasetToAxesMap.get(",
        "label":0
    },
    {
        "ins1AddCode":"JavaRDD<Tuple2<Integer, Integer>> sortedRDD = rdd.sortBy(Tuple2::_1, true, 2); sortedRDD = rdd.sortBy(Tuple2::_2, true, 2);",
        "ins1DelCode":"JavaRDD<Tuple2<Integer, Integer>> sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._1(); } }, true, 2); sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._2(); } }, true, 2);",
        "ins1PreCode":"JavaRDD<Tuple2<Integer, Integer>> rdd = sc.parallelize(pairs);   JavaRDD<Tuple2<Integer, Integer>> sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._1(); } }, true, 2);  assertEquals(new Tuple2<>(-1, 1), sortedRDD.first()); List<Tuple2<Integer, Integer>> sortedPairs = sortedRDD.collect(); assertEquals(new Tuple2<>(0, 4), sortedPairs.get(1)); assertEquals(new Tuple2<>(3, 2), sortedPairs.get(2));   sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._2(); } }, true, 2); assertEquals(new Tuple2<>(-1, 1), sortedRDD.first()); sortedPairs = sortedRDD.collect();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaDStream<Integer> reversed = pairStream.map(Tuple2::_2);",
        "ins1DelCode":"JavaDStream<Integer> reversed = pairStream.map(in -> in._2());",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); JavaTestUtils.attachTestOutputStream(reversed); List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void parseRecognizesEntryInParenthesis() throws IOException {",
        "ins1DelCode":"public void parseRecognizesEntryInParenthesis() throws IOException {",
        "ins1PreCode":"public void parseRecognizesEntryInParenthesis() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article(test,author={Ed von Test})\"));",
        "ins2PreCode":"public void parseRecognizesEntryWhereLastFieldIsFinishedWithComma() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},}\"));",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings( \"unchecked\" ) List<Plugin> plugins = (List<Plugin>) pom.getValue( \"build/plugins\" ); for ( Plugin plugin : plugins )",
        "ins1DelCode":"for ( Plugin plugin : (List<Plugin>) pom.getValue( \"build/plugins\" ) )",
        "ins1PreCode":"expected.add( \"maven-it-plugin-touch\" );  List<String> actual = new ArrayList<String>(); for ( Plugin plugin : (List<Plugin>) pom.getValue( \"build/plugins\" ) ) { actual.add( plugin.getArtifactId() );",
        "ins2PreCode":"expected.add( \"maven-it-plugin-touch\" ); List<String> actual = new ArrayList<String>(); for ( Plugin plugin : (List<Plugin>) pom.getValue( \"build/plugins\" ) ) { actual.add( plugin.getArtifactId() );",
        "label":1
    },
    {
        "ins1AddCode":"observer1.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer1.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<Long> source = Observable.unsafeCreate(new ObservableSource<Long>() { @Override public void subscribe(final Observer<? super Long> observer1) { observer1.onSubscribe(Disposables.empty()); innerScheduler.schedule(new Runnable() { @Override",
        "ins2PreCode":"Flowable<Long> source = Flowable.unsafeCreate(new Publisher<Long>() { @Override public void subscribe(final Subscriber<? super Long> subscriber1) { subscriber1.onSubscribe(new BooleanSubscription()); innerScheduler.schedule(new Runnable() { @Override",
        "label":0
    },
    {
        "ins1AddCode":"return Objects.equals(appId, o.appId) && Objects.equals(execId, o.execId)",
        "ins1DelCode":"return Objects.equal(appId, o.appId) && Objects.equal(execId, o.execId)",
        "ins1PreCode":"public boolean equals(Object other) { if (other != null && other instanceof OpenBlocks) { OpenBlocks o = (OpenBlocks) other; return Objects.equal(appId, o.appId) && Objects.equal(execId, o.execId) && Arrays.equals(blockIds, o.blockIds); }",
        "ins2PreCode":"public boolean equals(Object other) { if (other != null && other instanceof RemoveBlocks) { RemoveBlocks o = (RemoveBlocks) other; return Objects.equal(appId, o.appId) && Objects.equal(execId, o.execId) && Arrays.equals(blockIds, o.blockIds); }",
        "label":1
    },
    {
        "ins1AddCode":"int port = Math.max(getPort(), 0);",
        "ins1DelCode":"int port = (getPort() >= 0) ? getPort() : 0;",
        "ins1PreCode":"protected void customizeConnector(Connector connector) { int port = (getPort() >= 0) ? getPort() : 0; connector.setPort(port); if (StringUtils.hasText(this.getServerHeader())) {",
        "ins2PreCode":"protected void customizeConnector(Connector connector) { int port = (getPort() >= 0) ? getPort() : 0; connector.setPort(port); if (StringUtils.hasText(this.getServerHeader())) {",
        "label":1
    },
    {
        "ins1AddCode":"List<List<Tuple2<Integer, Integer>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1DelCode":"List<List<Tuple2<String, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1PreCode":"JavaPairDStream<Integer, Integer> sorted = pairStream.transformToPair(in -> in.sortByKey());  JavaTestUtils.attachTestOutputStream(sorted); List<List<Tuple2<String, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"LOG.log(Level.FINE, \"Showing popup at {0},{1}\", new Object[]{e.getX(), e.getY()});",
        "ins1DelCode":"LOG.debug(\"Showing popup at \" + e.getX() + \",\" + e.getY());",
        "ins1PreCode":"JPopupMenu popup = getPopupMenu(); if (popup.getComponentCount() > 0) { initActions(); LOG.debug(\"Showing popup at \" + e.getX() + \",\" + e.getY()); getPopupMenu().show(this, e.getX(), e.getY()); }",
        "ins2PreCode":"JPopupMenu popup = getPopupMenu(); if (popup.getComponentCount() > 0) { initActions(); LOG.info(\"Showing popup at \" + e.getX() + \",\" + e.getY()); getPopupMenu().show(this, e.getX(), e.getY()); }",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"this.producerProcessor = false;",
        "ins1PreCode":"public void selectConsumer(DataTransferNodeDescriptor consumer, DataTransferProcessorDescriptor processor, boolean rewrite) { this.consumer = consumer; this.processor = processor; this.producerProcessor = false; if (consumer != null && processor != null) { if (!processorPropsHistory.containsKey(processor)) {",
        "ins2PreCode":"public void selectProducer(DataTransferNodeDescriptor producer, DataTransferProcessorDescriptor processor, boolean rewrite) { this.producer = producer; this.processor = processor; this.producerProcessor = true; if (producer != null && processor != null) { if (!processorPropsHistory.containsKey(processor)) {",
        "label":1
    },
    {
        "ins1AddCode":"int offset = 0; while (offset < this.numBytes && getByte(offset) <= ' ') offset++; if (offset == this.numBytes) return false; int end = this.numBytes - 1; while (end > offset && getByte(end) <= ' ') end--; byte b = getByte(offset); if (end - offset == 0) { offset++; while (offset <= end) { while (offset <= end) {",
        "ins1DelCode":"if (numBytes == 0) { return false; } byte b = getByte(0); int offset = 0; offset++; if (numBytes == 1) { while (offset < numBytes) { while (offset < numBytes) {",
        "ins1PreCode":"public boolean toLong(LongWrapper toLongResult) { if (numBytes == 0) { return false; }  byte b = getByte(0); final boolean negative = b == '-'; int offset = 0; if (negative || b == '+') { offset++; if (numBytes == 1) { return false; } }  final byte separator = '.'; final int radix = 10; final long stopValue = Long.MIN_VALUE / radix; long result = 0;  while (offset < numBytes) { b = getByte(offset); offset++; if (b == separator) {    break; }  int digit; if (b >= '0' && b <= '9') { digit = b - '0'; } else { return false; }     if (result < stopValue) { return false; }  result = result * radix - digit;   if (result > 0) { return false; } }     while (offset < numBytes) { byte currentByte = getByte(offset); if (currentByte < '0' || currentByte > '9') {",
        "ins2PreCode":"public boolean toInt(IntWrapper intWrapper) { if (numBytes == 0) { return false; } byte b = getByte(0); final boolean negative = b == '-'; int offset = 0; if (negative || b == '+') { offset++; if (numBytes == 1) { return false; } } final byte separator = '.'; final int radix = 10; final int stopValue = Integer.MIN_VALUE / radix; int result = 0; while (offset < numBytes) { b = getByte(offset); offset++; if (b == separator) { break; } int digit; if (b >= '0' && b <= '9') { digit = b - '0'; } else { return false; } if (result < stopValue) { return false; } result = result * radix - digit; if (result > 0) { return false; } } while (offset < numBytes) { byte currentByte = getByte(offset); if (currentByte < '0' || currentByte > '9') {",
        "label":1
    },
    {
        "ins1AddCode":"stmt +=                             \" ORDER BY SCHEMA_NAME, VIEW_NAME LIMIT \" + maxResults;",
        "ins1DelCode":"stmt +=                             \" ORDER BY VIEW_NAME LIMIT \" + maxResults;",
        "ins1PreCode":"String stmt =                       \"SELECT SCHEMA_NAME, VIEW_NAME, COMMENTS FROM SYS.VIEWS WHERE\"; stmt += caseSensitive ?             \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt +=    \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY VIEW_NAME LIMIT \" + maxResults;  DBRProgressMonitor monitor = session.getProgressMonitor();",
        "ins2PreCode":"String stmt =                       \"SELECT SCHEMA_NAME, PROCEDURE_NAME FROM SYS.PROCEDURES WHERE\"; stmt += caseSensitive ?             \" PROCEDURE_NAME LIKE ?\" : \" UPPER(PROCEDURE_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY PROCEDURE_NAME LIMIT \" + maxResults; DBRProgressMonitor monitor = session.getProgressMonitor();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(1);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1);",
        "ins1PreCode":"public void unorderedFastPathReject() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnorderedReject(ts, d);",
        "ins2PreCode":"public void orderedFastPathReject() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrderedReject(ts, d);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); assertEquals(0, parsed.size());",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "ins1PreCode":" assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "ins2PreCode":"assertTrue(result.hasWarnings()); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l);  XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "label":1
    },
    {
        "ins1AddCode":"HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1DelCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(paddedBytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1PreCode":"byte[] strBytes = String.valueOf(i).getBytes(StandardCharsets.UTF_8); byte[] paddedBytes = new byte[byteArrSize]; System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(paddedBytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(javaDecimal, precision, scale);",
        "ins1DelCode":"long offsetAndSize = getLong(ordinal); long offset = offsetAndSize >>> 32; int signum = ((int) (offsetAndSize & 0xfff) >> 8); assert signum >=0 && signum <= 2 : \"invalid signum \" + signum; int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; Platform.copyMemory( baseObject, baseOffset + offset, mag, Platform.INT_ARRAY_OFFSET, size * 4); BigInteger v = new BigInteger(0, EMPTY); Platform.putInt(v, Platform.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); Platform.putObjectVolatile(v, Platform.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale);",
        "ins1PreCode":"if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.apply(getLong(ordinal), precision, scale); } else { long offsetAndSize = getLong(ordinal); long offset = offsetAndSize >>> 32; int signum = ((int) (offsetAndSize & 0xfff) >> 8); assert signum >=0 && signum <= 2 : \"invalid signum \" + signum; int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; Platform.copyMemory( baseObject, baseOffset + offset, mag, Platform.INT_ARRAY_OFFSET, size * 4);   BigInteger v = new BigInteger(0, EMPTY); Platform.putInt(v, Platform.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); Platform.putObjectVolatile(v, Platform.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"StackedXYBarRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"StackedXYBarRenderer r2 = (StackedXYBarRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYBarRenderer r1 = new StackedXYBarRenderer(); StackedXYBarRenderer r2 = (StackedXYBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString());",
        "ins1DelCode":"assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"Cookie name ok\", res.toString());",
        "ins1PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "ins2PreCode":"public void testCookiesInstance() throws Exception { System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); Tomcat tomcat = getTomcatInstance(); addServlets(tomcat); tomcat.start(); ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); addServlets(tomcat); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING\", public void testCookiesInstance() throws Exception { assertEquals(\"Cookie name fail\", res.toString()); }",
        "label":0
    },
    {
        "ins1AddCode":"LongArray array, long startIndex, long numRecords, int startByteIndex, int endByteIndex) {",
        "ins1DelCode":"LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) {",
        "ins1PreCode":"private static long[][] getKeyPrefixArrayCounts( LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][]; long bitwiseMax = 0;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"String textData = TextFormat.printer().printToString(message);",
        "ins1DelCode":"String textData = TextFormat.printToString(message);",
        "ins1PreCode":"setMapValuesUsingAccessors(builder); TestMap message = builder.build();  String textData = TextFormat.printToString(message);  builder = TestMap.newBuilder();",
        "ins2PreCode":"setMapValuesUsingAccessors(builder); TestMap message = builder.build(); String textData = TextFormat.printToString(message); builder = TestMap.newBuilder();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void interruptTerminalEventAwait() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  final Thread t0 = Thread.currentThread();",
        "ins2PreCode":"public void interruptTerminalEventAwaitTimed() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final Thread t0 = Thread.currentThread();",
        "label":1
    },
    {
        "ins1AddCode":"catch (SAXException | ParserConfigurationException e) {",
        "ins1DelCode":"catch (SAXException e) { } catch (ParserConfigurationException e2) { throw new RuntimeException(e2);",
        "ins1PreCode":"parser.parse(in, handler); result = handler.getDataset(); } catch (SAXException e) { throw new RuntimeException(e); } catch (ParserConfigurationException e2) { throw new RuntimeException(e2); } return result;",
        "ins2PreCode":"parser.parse(in, handler); result = handler.getDataset(); } catch (SAXException e) { throw new RuntimeException(e); } catch (ParserConfigurationException e2) { throw new RuntimeException(e2); } return result;",
        "label":1
    },
    {
        "ins1AddCode":"t = ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\");",
        "ins1DelCode":"t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins1PreCode":"public boolean tryOnError(Throwable t) { if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); } if (get() != DisposableHelper.DISPOSED) {",
        "ins2PreCode":"public boolean tryOnError(Throwable t) { if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); } if (get() != DisposableHelper.DISPOSED) {",
        "label":1
    },
    {
        "ins1AddCode":"List<Archive> archives = CollectionUtils.iteratorToList(launcher.getClassPathArchivesIterator());",
        "ins1DelCode":"List<Archive> archives = launcher.getClassPathArchives();",
        "ins1PreCode":"System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.queue = new MpscLinkedQueue<>(); this.windows = new ArrayList<>(); this.startObserver = new WindowStartObserver<>(this);",
        "ins1DelCode":"this.queue = new MpscLinkedQueue<Object>(); this.windows = new ArrayList<UnicastSubject<T>>(); this.startObserver = new WindowStartObserver<B>(this);",
        "ins1PreCode":"WindowBoundaryMainObserver(Observer<? super Observable<T>> downstream, ObservableSource<B> open, Function<? super B, ? extends ObservableSource<V>> closingIndicator, int bufferSize) { this.downstream = downstream; this.queue = new MpscLinkedQueue<Object>(); this.open = open; this.closingIndicator = closingIndicator; this.bufferSize = bufferSize; this.resources = new CompositeDisposable(); this.windows = new ArrayList<UnicastSubject<T>>(); this.windowCount = new AtomicLong(1L); this.downstreamDisposed = new AtomicBoolean(); this.error = new AtomicThrowable(); this.startObserver = new WindowStartObserver<B>(this); this.requested = new AtomicLong();",
        "ins2PreCode":"WindowBoundaryMainSubscriber(Subscriber<? super Flowable<T>> actual, Publisher<B> open, Function<? super B, ? extends Publisher<V>> closingIndicator, int bufferSize) { this.downstream = actual; this.queue = new MpscLinkedQueue<Object>(); this.open = open; this.closingIndicator = closingIndicator; this.bufferSize = bufferSize; this.resources = new CompositeDisposable(); this.windows = new ArrayList<UnicastProcessor<T>>(); this.windowCount = new AtomicLong(1L); this.downstreamCancelled = new AtomicBoolean(); this.error = new AtomicThrowable(); this.startSubscriber = new WindowStartSubscriber<B>(this); this.requested = new AtomicLong();",
        "label":0
    },
    {
        "ins1AddCode":"StringBuilder fixBuffer = new StringBuilder();",
        "ins1DelCode":"fixBuffer.setLength(0);",
        "ins1PreCode":"displayString = DBConstants.NULL_VALUE_LABEL; }  fixBuffer.setLength(0); for (int i = 0; i < displayString.length(); i++) { char c = displayString.charAt(i);",
        "ins2PreCode":"displayString = DBConstants.NULL_VALUE_LABEL; } fixBuffer.setLength(0); for (int i = 0; i < displayString.length(); i++) { char c = displayString.charAt(i);",
        "label":0
    },
    {
        "ins1AddCode":"void matchWhenHasNoControllers() throws Exception {",
        "ins1DelCode":"public void matchWhenHasNoControllers() throws Exception {",
        "ins1PreCode":"public void matchWhenHasNoControllers() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithNoControllers.class); assertThat(excludes(filter, Controller1.class)).isFalse();",
        "ins2PreCode":"public void matchWhenHasController() throws Exception { WebFluxTypeExcludeFilter filter = new WebFluxTypeExcludeFilter(WithController.class); assertThat(excludes(filter, Controller1.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"when(preferences.shouldSaveInOriginalOrder()).thenReturn(true);",
        "ins1DelCode":"when(preferences.isSaveInOriginalOrder()).thenReturn(true);",
        "ins1PreCode":"entry.setField(StandardField.AUTHOR, \"Mr. Author\");  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData()); ",
        "ins2PreCode":"Charset encoding = StandardCharsets.UTF_8; when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "label":1
    },
    {
        "ins1AddCode":"BubbleXYItemLabelGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"BubbleXYItemLabelGenerator g2 = (BubbleXYItemLabelGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator(); BubbleXYItemLabelGenerator g2 = (BubbleXYItemLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { = new StandardCategoryToolTipGenerator(); = (StandardCategoryToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"} else if (NEGATE_KEY.equals(params[i].getType())) { setNegate(Project.toBoolean(params[i].getValue()));",
        "ins1DelCode":"",
        "ins1PreCode":"for (int i = 0; i < params.length; i++) { if (CONTAINS_KEY.equals(params[i].getType())) { contains.addElement(params[i].getValue()); } } }",
        "ins2PreCode":"for (int i = 0; i < params.length; i++) { if (REGEXP_KEY.equals(params[i].getType())) { String pattern = params[i].getValue(); } } }",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void outDegree_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void degree_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), parsedEntry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional());",
        "ins1PreCode":"assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"assertFalse(result.hasWarnings()); assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(Optional.of(\"H'{e}lne Fiaux\"), parsedEntry.getField(StandardField.AUTHOR));",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1DelCode":"AUTH_HEADER.getHeader());",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, \" \" + PASSWORD + \" \"); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(POSSIBLY_DAMAGED_PWD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"long after = TestHelper.awaitGC(GC_SLEEP_TIME, 20, start + 20 * 1000 * 1000);",
        "ins1DelCode":"System.gc(); Thread.sleep(GC_SLEEP_TIME); long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();",
        "ins1PreCode":"System.gc(); Thread.sleep(GC_SLEEP_TIME);  long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();  source = null;",
        "ins2PreCode":"System.gc(); Thread.sleep(GC_SLEEP_TIME); long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed(); source = null;",
        "label":1
    },
    {
        "ins1AddCode":"SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<>(2, true); List<Integer> values = new ArrayList<>();",
        "ins1DelCode":"SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<Integer>(2, true); List<Integer> values = new ArrayList<Integer>();",
        "ins1PreCode":"public void sizedTruncation() { SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<Integer>(2, true); List<Integer> values = new ArrayList<Integer>();  buf.next(1);",
        "ins2PreCode":"public void sizedTruncation() { SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<Integer>(2, false); List<Integer> values = new ArrayList<Integer>(); buf.next(1);",
        "label":1
    },
    {
        "ins1AddCode":"Integer.valueOf(Calendar.MILLISECOND)); calendarFields.put(SECOND, Integer.valueOf(Calendar.SECOND)); calendarFields.put(MINUTE, Integer.valueOf(Calendar.MINUTE)); calendarFields.put(HOUR, Integer.valueOf(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, Integer.valueOf(Calendar.DATE)); calendarFields.put(WEEK, Integer.valueOf(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, Integer.valueOf(Calendar.MONTH)); calendarFields.put(YEAR, Integer.valueOf(Calendar.YEAR));",
        "ins1DelCode":"new Integer(Calendar.MILLISECOND)); calendarFields.put(SECOND, new Integer(Calendar.SECOND)); calendarFields.put(MINUTE, new Integer(Calendar.MINUTE)); calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, new Integer(Calendar.DATE)); calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, new Integer(Calendar.MONTH)); calendarFields.put(YEAR, new Integer(Calendar.YEAR));",
        "ins1PreCode":"public Unit() { calendarFields.put(MILLISECOND, new Integer(Calendar.MILLISECOND)); calendarFields.put(SECOND, new Integer(Calendar.SECOND)); calendarFields.put(MINUTE, new Integer(Calendar.MINUTE)); calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, new Integer(Calendar.DATE)); calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, new Integer(Calendar.MONTH)); calendarFields.put(YEAR, new Integer(Calendar.YEAR));",
        "ins2PreCode":"public Unit() { calendarFields.put(MILLISECOND, new Integer(Calendar.MILLISECOND)); calendarFields.put(SECOND, new Integer(Calendar.SECOND)); calendarFields.put(MINUTE, new Integer(Calendar.MINUTE)); calendarFields.put(HOUR, new Integer(Calendar.HOUR_OF_DAY)); calendarFields.put(DAY, new Integer(Calendar.DATE)); calendarFields.put(WEEK, new Integer(Calendar.WEEK_OF_YEAR)); calendarFields.put(MONTH, new Integer(Calendar.MONTH)); calendarFields.put(YEAR, new Integer(Calendar.YEAR));",
        "label":1
    },
    {
        "ins1AddCode":"public static void main(String[] args) throws AnalysisException {",
        "ins1DelCode":"public static void main(String[] args) {",
        "ins1PreCode":"public static void main(String[] args) {  SparkSession spark = SparkSession",
        "ins2PreCode":"public static void main(String[] args) { SparkSession spark = SparkSession",
        "label":0
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ) .authorizedTo(Jenkins.READ, Item.READ)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ) .authorizedTo(Jenkins.READ, Job.READ)",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsInvalid() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1a,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1a,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"aa,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse 'aa,2,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2a,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2a,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,aa,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,aa,3', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,3a\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2,3a', expected number\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,aa\"); assertThat(result, failedWith(3));",
        "ins2PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsSpace() { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\")); result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\")); result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\")); result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1, ,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1, ,3', expected number\")); result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \" ,2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ' ,2,3', expected number\")); result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2, \"); assertThat(result, failedWith(3));",
        "label":0
    },
    {
        "ins1AddCode":"public SQLServerTableForeignKey(DBRProgressMonitor monitor, SQLServerTableBase table, SQLServerTableForeignKey source) throws DBException {",
        "ins1DelCode":"public SQLServerTableForeignKey(DBRProgressMonitor monitor, SQLServerTable table, SQLServerTableForeignKey source) throws DBException {",
        "ins1PreCode":"public SQLServerTableForeignKey(DBRProgressMonitor monitor, SQLServerTable table, SQLServerTableForeignKey source) throws DBException { super( monitor,",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void verifyThatLeadingSpacesAreRemovedFromHeader() throws UnsupportedEncodingException, ProtocolDecoderException { HttpDecoderState state = decoder.createDecoderState(); HttpPdu[] pdus = decoder.decode(buffer, state); assertEquals(\"localhost\", ((HttpRequestImpl) pdus[0]).getHeader(\"host\"));",
        "ins1DelCode":"public void verifyThatLeadingSpacesAreRemovedFromHeader() throws UnsupportedEncodingException, ProtocolDecoderException { HttpPdu[] pdus = decoder.decode(buffer); assertEquals(\"localhost\", ((HttpRequestImpl)pdus[0]).getHeader(\"host\"));",
        "ins1PreCode":"public void verifyThatLeadingSpacesAreRemovedFromHeader() throws UnsupportedEncodingException, ProtocolDecoderException { String reqStr = \"GET / HTTP/1.0\\r\\nHost:  localhost\\r\\n\\r\\n\"; ByteBuffer buffer = ByteBuffer.allocate(reqStr.length()); buffer.put(reqStr.getBytes(\"US-ASCII\")); buffer.rewind(); HttpServerDecoder decoder = new HttpServerDecoder(); HttpPdu[] pdus = decoder.decode(buffer); assertNotNull(pdus); assertEquals(1, pdus.length); assertEquals(\"localhost\", ((HttpRequestImpl)pdus[0]).getHeader(\"host\"));",
        "ins2PreCode":"public void verifyThatTrailingSpacesAreRemovedFromHeader() throws UnsupportedEncodingException, ProtocolDecoderException { String reqStr = \"GET / HTTP/1.0\\r\\nHost:localhost  \\r\\n\\r\\n\"; ByteBuffer buffer = ByteBuffer.allocate(reqStr.length()); buffer.put(reqStr.getBytes(\"US-ASCII\")); buffer.rewind(); HttpServerDecoder decoder = new HttpServerDecoder(); HttpPdu[] pdus = decoder.decode(buffer); assertNotNull(pdus); assertEquals(1, pdus.length); assertEquals(\"localhost\", ((HttpRequestImpl)pdus[0]).getHeader(\"host\"));",
        "label":1
    },
    {
        "ins1AddCode":"Function4<Time, String, Optional<Integer>, State<Boolean>, Optional<Double>> mapFn = (time, key, value, state) -> { state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); }; wordsDstream.mapWithState( StateSpec.function(mapFn) .initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10))); Function3<String, Optional<Integer>, State<Boolean>, Double> mapFn2 = (key, value, state) -> { state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return 2.0; }; wordsDstream.mapWithState( StateSpec.function(mapFn2) .initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));",
        "ins1DelCode":"wordsDstream.mapWithState( StateSpec.<String, Integer, Boolean, Double>function((time, key, value, state) -> { state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); }).initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10))); wordsDstream.mapWithState( StateSpec.<String, Integer, Boolean, Double>function((key, value, state) -> { state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return 2.0; }).initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));",
        "ins1PreCode":" JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = wordsDstream.mapWithState( StateSpec.<String, Integer, Boolean, Double>function((time, key, value, state) -> {  state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); }).initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));  JavaPairDStream<String, Boolean> emittedRecords = stateDstream.stateSnapshots();  JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream2 = wordsDstream.mapWithState( StateSpec.<String, Integer, Boolean, Double>function((key, value, state) -> { state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return 2.0; }).initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10))",
        "ins2PreCode":"JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = wordsDstream.mapWithState( JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); .initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10))); JavaPairDStream<String, Integer> wordsDstream = null; JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream2 = wordsDstream.mapWithState( JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return 2.0; .initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10))",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":" Flowable<Integer> source = Flowable.range(1, 5);  TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  source.delaySubscription(Flowable.defer(new Supplier<Publisher<Integer>>() {",
        "ins2PreCode":"Flowable<Integer> source = Flowable.range(1, 5); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); source.delaySubscription(Flowable.defer(new Supplier<Publisher<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"StringBuilder sb = new StringBuilder(\"SetNextRule[\");",
        "ins1DelCode":"StringBuffer sb = new StringBuffer(\"SetNextRule[\");",
        "ins1PreCode":"public String toString() {  StringBuffer sb = new StringBuffer(\"SetNextRule[\"); sb.append(\"methodName=\"); sb.append(methodName);",
        "ins2PreCode":"public String toString() { StringBuffer sb = new StringBuffer(\"SetNextRule[\"); sb.append(\"methodName=\"); sb.append(methodName);",
        "label":1
    },
    {
        "ins1AddCode":"processCookieHeader(bc.getBytes(), bc.getOffset(), bc.getLength(), serverCookies);",
        "ins1DelCode":"if (getPreserveCookieHeader()) { int len = bc.getLength(); if (len > 0) { byte[] buf = new byte[len]; System.arraycopy(bc.getBytes(), bc.getOffset(), buf, 0, len); processCookieHeader(buf, 0, len, serverCookies); } } else { processCookieHeader(bc.getBytes(), bc.getOffset(), bc.getLength(), serverCookies); }",
        "ins1PreCode":"log.debug(\"Cookies: Parsing b[]: \" + cookieValue.toString()); } ByteChunk bc = cookieValue.getByteChunk(); if (getPreserveCookieHeader()) { int len = bc.getLength(); if (len > 0) { byte[] buf = new byte[len]; System.arraycopy(bc.getBytes(), bc.getOffset(), buf, 0, len); processCookieHeader(buf, 0, len, serverCookies); } } else { processCookieHeader(bc.getBytes(), bc.getOffset(), bc.getLength(), serverCookies); } }",
        "ins2PreCode":"log.debug(\"Cookies: Parsing b[]: \" + cookieValue.toString()); } ByteChunk bc = cookieValue.getByteChunk(); serverCookies); Cookie.parseCookie(bc.getBytes(), bc.getOffset(), bc.getLength(), while (pos >= 0) { Exception e = new Exception(); Cookie.parseCookie(bc.getBytes(), bc.getOffset(), bc.getLength(), ServerCookies serverCookies) { } while (pos >= 0) { Cookie.parseCookie(bc.getBytes(), bc.getOffset(), bc.getLength(), serverCookies); } }",
        "label":0
    },
    {
        "ins1AddCode":"DialBackground b2 = new DialBackground(Color.GREEN);",
        "ins1DelCode":"DialBackground b2 = new DialBackground(Color.green);",
        "ins1PreCode":"b1.setPaint(Color.BLUE); assertNotNull(this.lastEvent);  DialBackground b2 = new DialBackground(Color.green); p.setBackground(b2); this.lastEvent = null;",
        "ins2PreCode":"b1.setPaint(Color.BLUE); assertNotNull(this.lastEvent); DialBackground b2 = new DialBackground(Color.green); p.removeLayer(b2); this.lastEvent = null;",
        "label":0
    },
    {
        "ins1AddCode":"int c = skipLws(input, false);",
        "ins1DelCode":"int c = input.read(); while (c == 32 || c == 9) { c = input.read(); }",
        "ins1PreCode":"StringBuilder result = new StringBuilder(); boolean quoted = false;  int c = input.read();   while (c == 32 || c == 9) { c = input.read(); }",
        "ins2PreCode":"StringBuilder result = new StringBuilder(); boolean quoted = false; int c = input.read(); while (c == 32 || c == 9) { c = input.read(); }",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void blockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>();  Flowable.range(1, 5)",
        "ins2PreCode":"public void blockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>(); Observable.range(1, 5)",
        "label":1
    },
    {
        "ins1AddCode":"when(builder::parse);",
        "ins1DelCode":"when(builder).parse();",
        "ins1PreCode":"+ \"</configuration>\\n\";  XMLConfigBuilder builder = new XMLConfigBuilder(new StringReader(MAPPER_CONFIG)); when(builder).parse(); then(caughtException()).isInstanceOf(BuilderException.class) .hasMessageContaining(\"The setting foo is not known.  Make sure you spelled it correctly (case sensitive).\");",
        "ins2PreCode":"+ \"</configuration>\\n\"; XMLConfigBuilder builder = new XMLConfigBuilder(new StringReader(MAPPER_CONFIG)); when(builder).parse(); then(caughtException()).isInstanceOf(BuilderException.class) .hasMessageContaining(\"Error registering typeAlias for 'null'. Cause: \");",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(0);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0);",
        "ins1PreCode":"public void orderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "ins2PreCode":"public void unorderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "label":1
    },
    {
        "ins1AddCode":"oi.subscribe(new TestSubscriber<>(mockSubscriber));",
        "ins1DelCode":"oi.subscribe(new TestSubscriber<Integer>(mockSubscriber));",
        "ins1PreCode":" Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber();  oi.subscribe(new TestSubscriber<Integer>(mockSubscriber));  InOrder inOrder = inOrder(mockSubscriber);",
        "ins2PreCode":"Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber(); oi.subscribe(new TestSubscriber<Integer>(mockSubscriber)); InOrder inOrder = inOrder(mockSubscriber);",
        "label":1
    },
    {
        "ins1AddCode":"if (errors.tryAddThrowableOrReport(e)) {",
        "ins1DelCode":"if (errors.addThrowable(e)) { } else { RxJavaPlugins.onError(e);",
        "ins1PreCode":"public void onError(Throwable e) { if (errors.addThrowable(e)) { if (delayErrors) { if (decrementAndGet() == 0) { errors.tryTerminateConsumer(downstream); } else { if (maxConcurrency != Integer.MAX_VALUE) { upstream.request(1); } } } else { disposed = true; upstream.cancel(); set.dispose(); if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream); } } } else { RxJavaPlugins.onError(e); }",
        "ins2PreCode":"public void onError(Throwable e) { if (errors.addThrowable(e)) { if (delayErrors) { if (decrementAndGet() == 0) { errors.tryTerminateConsumer(downstream); } else { if (maxConcurrency != Integer.MAX_VALUE) { upstream.request(1); } } } else { set.dispose(); upstream.cancel(); set.dispose(); if (getAndSet(0) > 0) { errors.tryTerminateConsumer(downstream); } } } else { RxJavaPlugins.onError(e); }",
        "label":1
    },
    {
        "ins1AddCode":"operator.onSubscribe(Disposable.empty());",
        "ins1DelCode":"operator.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new ConcatMapSingleMainObserver<Integer, Integer>( to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE);  operator.onSubscribe(Disposables.empty());  operator.queue.offer(1);",
        "ins2PreCode":"new ConcatMapMaybeMainObserver<Integer, Integer>( to, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE); operator.onSubscribe(Disposables.empty()); operator.queue.offer(1);",
        "label":1
    },
    {
        "ins1AddCode":"while (c != -1 && isToken(c)) {",
        "ins1DelCode":"while (c != -1 && isToken[c]) {",
        "ins1PreCode":"} c = input.read();  while (c != -1 && isToken[c]) { result.append((char) c); c = input.read();",
        "ins2PreCode":"} c = input.read(); while (c != -1 && isHex[c]) { result.append((char) c); c = input.read();",
        "label":1
    },
    {
        "ins1AddCode":"Class<?> mapperType = Mapper.class; Method mapperMethod = mapperType.getMethod(\"getUsersByName\", String.class, String.class); mapperMethod.getAnnotation(SelectProvider.class), mapperType, mapperMethod)",
        "ins1DelCode":"Mapper.class.getMethod(\"getUsersByName\", String.class, String.class).getAnnotation(SelectProvider.class))",
        "ins1PreCode":"public void notSupportParameterObjectOnMultipleArguments() throws NoSuchMethodException { try { new ProviderSqlSource(new Configuration(), Mapper.class.getMethod(\"getUsersByName\", String.class, String.class).getAnnotation(SelectProvider.class)) .getBoundSql(new Object()); fail();",
        "ins2PreCode":"public void notSupportParameterObjectOnNamedArgument() throws NoSuchMethodException { try { new ProviderSqlSource(new Configuration(), Mapper.class.getMethod(\"getUsersByNameWithParamName\", String.class).getAnnotation(SelectProvider.class)) .getBoundSql(new Object()); fail();",
        "label":1
    },
    {
        "ins1AddCode":"t.onSubscribe(Disposable.empty());",
        "ins1DelCode":"t.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<Integer> source = Observable.unsafeCreate(new ObservableSource<Integer>() { @Override public void subscribe(Observer<? super Integer> t) { t.onSubscribe(Disposables.empty()); calls.getAndIncrement(); }",
        "ins2PreCode":"Flowable<Integer> source = Flowable.unsafeCreate(new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> t) { t.onSubscribe(new BooleanSubscription()); calls.getAndIncrement(); }",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldIgnorePartialAutoMappingBehavior_InlineNestedResultMap() {  sqlSessionFactory.getConfiguration().setAutoMappingBehavior(AutoMappingBehavior.PARTIAL); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_Inline(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldIgnorePartialAutoMappingBehavior_ExternalNestedResultMap() { sqlSessionFactory.getConfiguration().setAutoMappingBehavior(AutoMappingBehavior.PARTIAL); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_External(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"sub.onSubscribe(Disposable.empty());",
        "ins1DelCode":"sub.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Integer> sub) { sub.onSubscribe(Disposables.empty()); counter.incrementAndGet(); sub.onNext(1);",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super Integer> sub) { sub.onSubscribe(new BooleanSubscription()); counter.incrementAndGet(); sub.onNext(1);",
        "label":0
    },
    {
        "ins1AddCode":"map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(3);",
        "ins1DelCode":"",
        "ins1PreCode":"DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.setThrowException(true);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"RequestUtil.filter(displayPath)));",
        "ins1DelCode":"HttpMessages.filter(displayPath)));",
        "ins1PreCode":"Context context = (Context) host.findChild(cn.getName()); if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", HttpMessages.filter(displayPath))); return; }",
        "ins2PreCode":"Context context = (Context) host.findChild(cn.getName()); if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", HttpMessages.filter(displayPath))); return; }",
        "label":1
    },
    {
        "ins1AddCode":"public void hsqlServerIsNotShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));",
        "ins1DelCode":"public void hsqlServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class);",
        "ins1PreCode":"public void hsqlServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "ins2PreCode":"public void inMemoryHsqlIsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "label":1
    },
    {
        "ins1AddCode":"list.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins1DelCode":"",
        "ins1PreCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":1
    },
    {
        "ins1AddCode":"Throwable ex = ExceptionHelper.createNullPointerException(\"onNext called with a null Throwable.\");",
        "ins1DelCode":"Throwable ex = new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins1PreCode":"}  if (t == null) { Throwable ex = new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"); try { upstream.cancel();",
        "ins2PreCode":"} if (t == null) { Throwable ex = new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"); try { upstream.dispose();",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); new Thread(new Runnable() { ",
        "ins2PreCode":"@Override public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); new Thread(new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"ConnectableObservable<String> connectable = Observable.<String>unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); count.incrementAndGet(); new Thread(new Runnable() {",
        "ins2PreCode":"ConnectableFlowable<String> connectable = Flowable.<String>unsafeCreate(new Publisher<String>() { @Override public void subscribe(final Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); count.incrementAndGet(); new Thread(new Runnable() {",
        "label":0
    },
    {
        "ins1AddCode":"private static final char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][];",
        "ins1DelCode":"private static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][];",
        "ins1PreCode":"private static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][]; static { specialCharactersRepresentation['&'] = \"&amp;\".toCharArray();",
        "ins2PreCode":"private static char[][] specialCharactersRepresentation = new char[HIGHEST_SPECIAL + 1][]; static { specialCharactersRepresentation['&'] = \"&amp;\".toCharArray();",
        "label":1
    },
    {
        "ins1AddCode":"plugins = new LinkedHashSet<>();",
        "ins1DelCode":"plugins = new LinkedHashSet<Plugin>();",
        "ins1PreCode":" if ( \"JAR\".equals( packaging ) ) { plugins = new LinkedHashSet<Plugin>();  plugins.add( newPlugin( \"maven-compiler-plugin\", \"compile\", \"testCompile\" ) );",
        "ins2PreCode":"if ( \"JAR\".equals( packaging ) ) { plugins = new LinkedHashSet<Plugin>(); plugins.add( newPlugin( \"maven-compiler-plugin\", \"compile\", \"testCompile\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"assumeTrue(\"System does not support Symlinks\", supportsSymlinks); assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1DelCode":"Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1PreCode":"public void testAllowSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\"); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void testProhibitSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\"); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(onNext, \"onNext is null\"); Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\");",
        "ins1PreCode":"private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins2PreCode":"private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "label":1
    },
    {
        "ins1AddCode":"final int months = Platform.getInt(baseObject, baseOffset + offset); final int days = Platform.getInt(baseObject, baseOffset + offset + 4); return new CalendarInterval(months, days, microseconds);",
        "ins1DelCode":"final int months = (int) Platform.getLong(baseObject, baseOffset + offset); return new CalendarInterval(months, microseconds);",
        "ins1PreCode":"if (isNullAt(ordinal)) return null; final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int months = (int) Platform.getLong(baseObject, baseOffset + offset); final long microseconds = Platform.getLong(baseObject, baseOffset + offset + 8); return new CalendarInterval(months, microseconds);",
        "ins2PreCode":"if (isNullAt(ordinal)) { final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int months = (int) Platform.getLong(baseObject, baseOffset + offset); final long microseconds = Platform.getLong(baseObject, baseOffset + offset + 8); return new CalendarInterval(months, microseconds);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\" + LS + LS + \"[0] Inside the definition for plugin 'artifactId', specify the following:\" + LS + LS + \"<configuration>\" + LS + \"  ...\" + LS + \"  <toAddresses>\" + LS + \"    <item>VALUE</item>\" + LS + \"  </toAddresses>\" + LS + \"</configuration>.\" + LS, exception.buildDiagnosticMessage() );",
        "ins1DelCode":"assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\\n\" + \"\\n\" + \"[0] Inside the definition for plugin 'artifactId', specify the following:\\n\" + \"\\n\" + \"<configuration>\\n\" + \"  ...\\n\" + \"  <toAddresses>\\n\" + \"    <item>VALUE</item>\\n\" + \"  </toAddresses>\\n\" + \"</configuration>.\\n\", exception.buildDiagnosticMessage() );",
        "ins1PreCode":"PluginParameterException exception = new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );  assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\\n\" + \"\\n\" + \"[0] Inside the definition for plugin 'artifactId', specify the following:\\n\" + \"\\n\" + \"<configuration>\\n\" + \"  ...\\n\" + \"  <toAddresses>\\n\" + \"    <item>VALUE</item>\\n\" + \"  </toAddresses>\\n\" + \"</configuration>.\\n\", exception.buildDiagnosticMessage() );",
        "ins2PreCode":"PluginParameterException exception = new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) ); assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\\n\" + \"\\n\" + \"[0] Inside the definition for plugin 'artifactId', specify the following:\\n\" + \"\\n\" + \"<configuration>\\n\" + \"  ...\\n\" + \"  <toAddresses>\\n\" + \"    <KEY>VALUE</KEY>\\n\" + \"  </toAddresses>\\n\" + \"</configuration>.\\n\", exception.buildDiagnosticMessage() );",
        "label":1
    },
    {
        "ins1AddCode":"skipTokens(st, 2);",
        "ins1DelCode":"if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken();",
        "ins1PreCode":"Argo.KEY_IMPORT_GENERAL_SETTINGS_FLAGS); if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) { return false;",
        "ins2PreCode":"Argo.KEY_IMPORT_GENERAL_SETTINGS_FLAGS); if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) { return false;",
        "label":1
    },
    {
        "ins1AddCode":"void parseQuotedEntries() throws IOException {",
        "ins1DelCode":"public void parseQuotedEntries() throws IOException {",
        "ins1PreCode":"public void parseQuotedEntries() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Ed von Test\\\"}\"));",
        "ins2PreCode":"public void parseRecognizesEntryOnlyWithKey() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{test}\")); ParserResult result = parser.parse(new StringReader(\"@article{test}\"));",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(classUnderTest + \" must have exhausted the iterator\", iter.hasNext());",
        "ins1DelCode":"assertFalse(classUnderTest + \" must have exhausted the itertor\", iter.hasNext());",
        "ins1PreCode":"stillEqual = (iter.hasNext() && referenceBytes[i] == iter.nextByte()); } assertTrue(classUnderTest + \" must capture the right bytes\", stillEqual); assertFalse(classUnderTest + \" must have exhausted the itertor\", iter.hasNext());  try {",
        "ins2PreCode":"stillEqual = (iter.hasNext() && BYTES[i] == iter.nextByte()); } assertTrue(CLASSNAME + \" must capture the right bytes\", stillEqual); assertFalse(CLASSNAME + \" must have exhausted the itertor\", iter.hasNext()); try {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(StandardField.EDITOR));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"editor\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"editor\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Test, Second Keyword, Third Keyword\"), entry.getField(\"keywords\"));",
        "label":1
    },
    {
        "ins1AddCode":"verify(listener, never())",
        "ins1DelCode":"verify(listener, times(0))",
        "ins1PreCode":"finally { verify(listener).onApplicationEvent(isA(ApplicationStartedEvent.class)); verify(listener).onApplicationEvent(isA(ApplicationFailedEvent.class)); verify(listener, times(0)) .onApplicationEvent(isA(ApplicationReadyEvent.class)); }",
        "ins2PreCode":"finally { verify(listener).onApplicationEvent(isA(ApplicationStartedEvent.class)); verify(listener).onApplicationEvent(isA(ApplicationFailedEvent.class)); verify(listener, times(0)) .onApplicationEvent(isA(ApplicationReadyEvent.class)); }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>(observerA);",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>(observerA);",
        "ins1PreCode":"Observer<Object> observerB = TestHelper.mockObserver(); Observer<Object> observerC = TestHelper.mockObserver(); Observer<Object> observerD = TestHelper.mockObserver(); TestObserver<Object> to = new TestObserver<Object>(observerA);  channel.subscribe(to);",
        "ins2PreCode":"Subscriber<Object> observerB = TestHelper.mockSubscriber(); Subscriber<Object> observerC = TestHelper.mockSubscriber(); Subscriber<Object> observerD = TestHelper.mockSubscriber(); TestSubscriber<Object> ts = new TestSubscriber<Object>(observerA); channel.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"TaskSeries<String> s1 = new TaskSeries<>(\"Series\"); SlidingGanttCategoryDataset d2 = TestUtils.serialised(d1); TaskSeries<String> s2 = u2.getSeries(\"Series\");",
        "ins1DelCode":"TaskSeries s1 = new TaskSeries(\"Series\"); SlidingGanttCategoryDataset d2 = (SlidingGanttCategoryDataset) TestUtils.serialised(d1); TaskSeries s2 = u2.getSeries(\"Series\");",
        "ins1PreCode":"public void testSerialization() { TaskSeries s1 = new TaskSeries(\"Series\"); s1.add(new Task(\"Task 1\", new Date(0L), new Date(1L))); TaskSeriesCollection u1 = new TaskSeriesCollection(); u1.add(s1); SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset( u1, 0, 5); SlidingGanttCategoryDataset d2 = (SlidingGanttCategoryDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   s1.add(new Task(\"Task 2\", new Date(10L), new Date(11L))); assertFalse(d1.equals(d2)); TaskSeriesCollection u2 = (TaskSeriesCollection) d2.getUnderlyingDataset(); TaskSeries s2 = u2.getSeries(\"Series\"); s2.add(new Task(\"Task 2\", new Date(10L), new Date(11L))); assertTrue(d1.equals(d2));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"List<LabeledPoint> data = generateRidgeData(2 * numExamples, numFeatures, 10.0); JavaRDD<LabeledPoint> testRDD = jsc.parallelize(data.subList(0, numExamples));",
        "ins1DelCode":"List<LabeledPoint> data = generateRidgeData(2*numExamples, numFeatures, 10.0); JavaRDD<LabeledPoint> testRDD = sc.parallelize(data.subList(0, numExamples));",
        "ins1PreCode":"public void runRidgeRegressionUsingConstructor() { int numExamples = 50; int numFeatures = 20; List<LabeledPoint> data = generateRidgeData(2*numExamples, numFeatures, 10.0);  JavaRDD<LabeledPoint> testRDD = sc.parallelize(data.subList(0, numExamples)); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples); ",
        "ins2PreCode":"public void runRidgeRegressionUsingStaticMethods() { int numExamples = 50; int numFeatures = 20; List<LabeledPoint> data = generateRidgeData(2 * numExamples, numFeatures, 10.0); JavaRDD<LabeledPoint> testRDD = sc.parallelize(data.subList(0, numExamples)); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);",
        "label":1
    },
    {
        "ins1AddCode":"final List<Long> requests = new ArrayList<>();",
        "ins1DelCode":"final List<Long> requests = new ArrayList<Long>();",
        "ins1PreCode":"public void elementAtConstrainsUpstreamRequests() { final List<Long> requests = new ArrayList<Long>(); Flowable.fromArray(1, 2, 3, 4) .doOnRequest(new LongConsumer() {",
        "ins2PreCode":"public void elementAtWithDefaultConstrainsUpstreamRequests() { final List<Long> requests = new ArrayList<Long>(); Flowable.fromArray(1, 2, 3, 4) .doOnRequest(new LongConsumer() {",
        "label":1
    },
    {
        "ins1AddCode":"j.jenkins.rebuildDependencyGraph();",
        "ins1DelCode":"",
        "ins1PreCode":"j.assertBuildStatusSuccess(upstream2.scheduleBuild2(0).get()); j.assertBuildStatusSuccess(downstream.scheduleBuild2(0).get());  List<AbstractProject> downstreamProjects = upstream.getDownstreamProjects(); List<AbstractProject> downstreamProjects2 = upstream2.getDownstreamProjects(); List<AbstractProject> upstreamProjects = downstream.getUpstreamProjects();",
        "ins2PreCode":"j.assertBuildStatusSuccess(upstream.scheduleBuild2(0).get()); j.assertBuildStatusSuccess(downstream.scheduleBuild2(0).get()); List<AbstractProject> downstreamProjects = upstream.getDownstreamProjects(); List<AbstractProject> downstreamProjects = upstream.getDownstreamProjects(); List<AbstractProject> upstreamProjects = downstream.getUpstreamProjects();",
        "label":1
    },
    {
        "ins1AddCode":"DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() { public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException {",
        "ins1DelCode":"RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException {",
        "ins1PreCode":"public boolean performFinish() { try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try { importProjects(monitor);",
        "ins2PreCode":"public boolean performFinish() { try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try { exportProjects(monitor, exportData);",
        "label":1
    },
    {
        "ins1AddCode":"private static NumberSortScript.LeafFactory newSortScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {",
        "ins1DelCode":"private NumberSortScript.LeafFactory newSortScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {",
        "ins1PreCode":"private NumberSortScript.LeafFactory newSortScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {  ",
        "ins2PreCode":"private AggregationScript.LeafFactory newAggregationScript(Expression expr, SearchLookup lookup,",
        "label":1
    },
    {
        "ins1AddCode":"ModuleLoader2.addClass(SequenceDiagramModule.class.getName()); ModuleLoader2.doLoad(false);",
        "ins1DelCode":"",
        "ins1PreCode":"(new InitClassDiagram()).init(); (new InitUseCaseDiagram()).init(); (new InitProfileSubsystem()).init();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"value instanceof Double  || value instanceof BigInteger",
        "ins1DelCode":"value instanceof Double",
        "ins1PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double ) { return ((Number)value).doubleValue();",
        "ins2PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double ) { return ((Number)value).byteValue();",
        "label":0
    },
    {
        "ins1AddCode":"CoreMatchers.equalTo(\"failed to parse setting [Ingest Field] with value [junk]\"));",
        "ins1DelCode":"CoreMatchers.equalTo(\"failed to parse [junk]\"));",
        "ins1PreCode":"Processor processor = newProcessor(fieldName, randomBoolean(), fieldName); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> processor.execute(ingestDocument)); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse [junk]\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return ge.scan(new HashMap<>(), new BiFunction<HashMap<String, String>, Event, HashMap<String, String>>() {",
        "ins1DelCode":"return ge.scan(new HashMap<String, String>(), new BiFunction<HashMap<String, String>, Event, HashMap<String, String>>() {",
        "ins1PreCode":".flatMap(new Function<GroupedObservable<String, Event>, Observable<HashMap<String, String>>>() { @Override public Observable<HashMap<String, String>> apply(final GroupedObservable<String, Event> ge) { return ge.scan(new HashMap<String, String>(), new BiFunction<HashMap<String, String>, Event, HashMap<String, String>>() { @Override public HashMap<String, String> apply(HashMap<String, String> accum,",
        "ins2PreCode":".flatMap(new Function<GroupedFlowable<String, Event>, Publisher<HashMap<String, String>>>() { @Override public Publisher<HashMap<String, String>> apply(final GroupedFlowable<String, Event> ge) { return ge.scan(new HashMap<String, String>(), new BiFunction<HashMap<String, String>, Event, HashMap<String, String>>() { @Override public HashMap<String, String> apply(HashMap<String, String> accum,",
        "label":1
    },
    {
        "ins1AddCode":"acceptor.getSessionConfig().setSslContext(BogusSslContextFactory.getInstance(true));",
        "ins1DelCode":"acceptor.setSslContext(BogusSslContextFactory.getInstance(true));",
        "ins1PreCode":"NioTcpServer acceptor = new NioTcpServer(strategy);   acceptor.setSslContext(BogusSslContextFactory.getInstance(true));  acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"),",
        "ins2PreCode":"NioTcpServer acceptor = new NioTcpServer(strategy); acceptor.bind(new InetSocketAddress(8080)); acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"),",
        "label":0
    },
    {
        "ins1AddCode":"new JspCServletContext(null, appDir.toURI().toURL(), null);",
        "ins1DelCode":"new JspCServletContext(null, appDir.toURI().toURL());",
        "ins1PreCode":"public void testWebapp_3_0() throws Exception { File appDir = new File(\"test/webapp-3.0\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(3, context.getEffectiveMajorVersion()); Assert.assertEquals(0, context.getEffectiveMinorVersion());",
        "ins2PreCode":"public void testWebapp_3_1() throws Exception { File appDir = new File(\"test/webapp-3.1\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL()); Assert.assertEquals(3, context.getEffectiveMajorVersion()); Assert.assertEquals(1, context.getEffectiveMinorVersion());",
        "label":1
    },
    {
        "ins1AddCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsTooBig() {",
        "ins1DelCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsTooBig() throws Exception {",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsTooBig() throws Exception { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsTooBigNumber() throws Exception { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "label":1
    },
    {
        "ins1AddCode":"UnicastSubject<Integer> us = UnicastSubject.create(); TestHelper.emit(us, 1, 2, 3, 4, 5); us",
        "ins1DelCode":"UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5); up",
        "ins1PreCode":"public void asyncFused() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doFinally(this) .subscribe(to);",
        "ins2PreCode":"public void asyncFusedConditional() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ASYNC); UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5); up .doFinally(this) .subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, user.setterCounter);",
        "ins1DelCode":"assertEquals(0, user.lazyLoadCounter);",
        "ins1PreCode":"user.hashCode(); user.equals(null); user.clone(); assertEquals(0, user.lazyLoadCounter); } finally { sqlSession.close();",
        "ins2PreCode":"user.hashCode(); user.equals(null); user.clone(); assertEquals(0, user.lazyLoadCounter); } finally { sqlSession.close();",
        "label":0
    },
    {
        "ins1AddCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1DelCode":"public void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"public void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { String sql = String.format(SQL_RENAME_TABLE, DBUtils.getQuotedIdentifier(command.getObject().getSchema()) + \".\" + DBUtils.getQuotedIdentifier(command.getObject().getDataSource(), command.getOldName()),",
        "ins2PreCode":"public void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) String sql = String.format(SQL_RENAME_TABLE, DBUtils.getQuotedIdentifier(command.getObject().getSchema()) + \".\" + DBUtils.getQuotedIdentifier(command.getObject().getDataSource(), command.getOldName()),",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.INFO, \"Rebuilding\"); LOG.log(Level.FINE, \"buildModelList threw exception for target \"",
        "ins1DelCode":"LOG.info(\"Rebuilding\"); LOG.debug(\"buildModelList threw exception for target \"",
        "ins1PreCode":"private void rebuildModelList() { LOG.info(\"Rebuilding\"); removeAllElements(); buildingModel = true; try { buildModelList(); } catch (InvalidElementException exception) {        LOG.debug(\"buildModelList threw exception for target \" + getTarget() + \": \" + exception);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TextFormat.printer().printToString(message));",
        "ins1DelCode":"TextFormat.printToString(message));",
        "ins1PreCode":"+ \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void constructorParameterNestedPropertySameClass() throws IOException {",
        "ins1DelCode":"public void constructorParameterNestedPropertySameClass() throws IOException {",
        "ins1PreCode":"public void constructorParameterNestedPropertySameClass() throws IOException { process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(ImmutableInnerClassProperties.class);",
        "ins2PreCode":"public void javaBeanNestedPropertySameClass() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(InnerClassProperties.class);",
        "label":1
    },
    {
        "ins1AddCode":"void testSelect() { assertEquals(3, answer.size());",
        "ins1DelCode":"public void testSelect() { assertTrue(answer.size() == 3);",
        "ins1PreCode":"public void testSelect() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Integer> ids = new ArrayList<>(); ids.add(1); ids.add(3); ids.add(5); Parameter parameter = new Parameter(); parameter.setEnabled(true); parameter.setSchema(\"ibtest\"); parameter.setIds(ids);  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.select\", parameter);  assertTrue(answer.size() == 3); }",
        "ins2PreCode":"public void testSelectSimple() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Integer> ids = new ArrayList<>(); ids.add(1); ids.add(3); ids.add(5); Parameter parameter = new Parameter(); parameter.setEnabled(true); parameter.setSchema(\"ibtest\"); parameter.setIds(ids); List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.select_simple\", parameter); assertTrue(answer.size() == 3); }",
        "label":1
    },
    {
        "ins1AddCode":"NioSocketWrapper socketWrapper = (NioSocketWrapper) channel.getAttachment(); if (socketWrapper == null) { nRead = pool.read(to, channel, selector, socketWrapper.getReadTimeout());",
        "ins1DelCode":"NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel .getAttachment(); if (att == null) { nRead = pool.read(to, channel, selector, att.getReadTimeout());",
        "ins1PreCode":" } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel .getAttachment(); if (att == null) { throw new IOException(sm.getString(\"endpoint.nio.keyMustBeCancelled\")); } nRead = pool.read(to, channel, selector, att.getReadTimeout()); } finally { if (selector != null) {",
        "ins2PreCode":"} try { pool.write(from, getSocket(), selector, writeTimeout, block); updateLastWrite(); if (selector != null) { } catch (IOException x) { } pool.write(from, getSocket(), selector, writeTimeout, block); } finally { if (selector != null) {",
        "label":0
    },
    {
        "ins1AddCode":"\"  note    = {some note},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  note    = {some note},\" + OS.NEWLINE +",
        "ins1PreCode":"void testSerialization() throws IOException { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.Article);  entry.setField(StandardField.AUTHOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins2PreCode":"void writeEntryWithOrField() throws Exception { StringWriter stringWriter = new StringWriter(); BibEntry entry = new BibEntry(StandardEntryType.InBook); entry.setField(StandardField.EDITOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\"); entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\"); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString(); String expected = OS.NEWLINE + \"@InBook{,\" + OS.NEWLINE + \"  editor  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE; assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(new FlowableSubscriber<Integer>() {",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(new FlowableSubscriber<Integer>() {",
        "ins1PreCode":"public void errorDelegateThrows() throws Exception { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(new FlowableSubscriber<Integer>() {  @Override",
        "ins2PreCode":"public void completeDelegateThrows() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(new FlowableSubscriber<Integer>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Files.readString(testBibtexFile, encoding), stringWriter.toString());",
        "ins1DelCode":"try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins1PreCode":"new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins2PreCode":"new Defaults(BibDatabaseMode.BIBTEX)); databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "label":0
    },
    {
        "ins1AddCode":"HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request).getRequest();",
        "ins1DelCode":"HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);",
        "ins1PreCode":"request.addHeader(\"x-forwarded-for\", \"140.211.11.130, 192.168.0.10, 192.168.0.11\");   HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);  ",
        "ins2PreCode":"request.addHeader(\"x-forwarded-for\", \"140.211.11.130\"); HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(properties.isGraphiteTagsEnabled()).isEqualTo(config.graphiteTagsEnabled());",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(properties.getHost()).isEqualTo(config.host()); assertThat(properties.getPort()).isEqualTo(config.port()); assertThat(properties.getProtocol()).isEqualTo(config.protocol()); assertThat(properties.getTagsAsPrefix()).isEqualTo(config.tagsAsPrefix());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (debug >= 1) { log(sm.getString(\"hostManagerServlet.start\", name)); }",
        "ins1DelCode":"if (debug >= 1) log(\"start: Starting host with name '\" + name + \"'\");",
        "ins1PreCode":"protected void start(PrintWriter writer, String name) {  if (debug >= 1) log(\"start: Starting host with name '\" + name + \"'\");  ",
        "ins2PreCode":"protected void stop(PrintWriter writer, String name) { if (debug >= 1) log(\"stop: Stopping host with name '\" + name + \"'\");",
        "label":1
    },
    {
        "ins1AddCode":"protected Aggregator doCreateInternal(Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata) throws IOException { long maxOrd = valuesSource.globalMaxOrd(context.searcher()); return new ParentToChildrenAggregator(name, factories, context, parent, childFilter,",
        "ins1DelCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata) throws IOException { long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter,",
        "ins1PreCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator parent, CardinalityUpperBound cardinality, Map<String, Object> metadata) throws IOException {  ValuesSource rawValuesSource = config.getValuesSource(); if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, cardinality, metadata);",
        "ins2PreCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator children, CardinalityUpperBound cardinality, Map<String, Object> metadata) throws IOException { ValuesSource rawValuesSource = config.getValuesSource(); if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ChildrenToParentAggregator(name, factories, searchContext, children, childFilter, parentFilter, valuesSource, maxOrd, cardinality, metadata);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1",
        "ins2PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>();",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot();",
        "ins1PreCode":"public void testSetRenderer() { CategoryPlot plot = new CategoryPlot(); CategoryItemRenderer renderer = new LineAndShapeRenderer(); plot.setRenderer(renderer);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void propertiesAsMap() { SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class) .contextFactory(ApplicationContextFactory.forContextClass(StaticApplicationContext.class))",
        "ins1DelCode":"public void propertiesAsMap() { SpringApplicationBuilder application = new SpringApplicationBuilder() .sources(ExampleConfig.class).contextClass(StaticApplicationContext.class)",
        "ins1PreCode":"public void propertiesAsMap() { SpringApplicationBuilder application = new SpringApplicationBuilder() .sources(ExampleConfig.class).contextClass(StaticApplicationContext.class) .properties(Collections.singletonMap(\"bar\", \"foo\")); this.context = application.run();",
        "ins2PreCode":"void propertiesAsProperties() { SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class) .contextClass(StaticApplicationContext.class) .properties(StringUtils.splitArrayElementsIntoProperties(new String[] { \"bar=foo\" }, \"=\")); this.context = application.run();",
        "label":1
    },
    {
        "ins1AddCode":"void testAnnotatedInsertTable2WithGeneratedKeyXml() {",
        "ins1DelCode":"public void testAnnotatedInsertTable2WithGeneratedKeyXml() {",
        "ins1PreCode":"public void testAnnotatedInsertTable2WithGeneratedKeyXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins2PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMapXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "label":1
    },
    {
        "ins1AddCode":"public void getLoggingConfiguration() {",
        "ins1DelCode":"public void getLoggingConfiguration() throws Exception {",
        "ins1PreCode":"public void getLoggingConfiguration() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null);",
        "ins2PreCode":"public void getLoggingConfiguration() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null);",
        "label":1
    },
    {
        "ins1AddCode":"Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false, ThreadWatchdog.noop());",
        "ins1DelCode":"Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false);",
        "ins1PreCode":"IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false); Exception e = expectThrows(Exception.class, () -> processor.execute(doc)); assertThat(e.getMessage(), equalTo(\"field [\" + fieldName + \"] of type [java.lang.Integer] cannot be cast to [java.lang.String]\"));",
        "ins2PreCode":"IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, true); Exception e = expectThrows(Exception.class, () -> processor.execute(doc)); assertThat(e.getMessage(), equalTo(\"field [\" + fieldName + \"] of type [java.lang.Integer] cannot be cast to [java.lang.String]\"));",
        "label":1
    },
    {
        "ins1AddCode":"void completeReturnsMultipleResults() { database.insertEntry(entryOne); database.insertEntry(entryTwo); Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"testValue\")));",
        "ins1DelCode":"public void completeReturnsMultipleResults() { autoCompleter.indexEntry(entryOne); autoCompleter.indexEntry(entryTwo); Collection<String> result = autoCompleter.call(getRequest((\"testValue\")));",
        "ins1PreCode":"public void completeReturnsMultipleResults() { BibEntry entryOne = new BibEntry(); entryOne.setField(StandardField.TITLE, \"testValueOne\"); autoCompleter.indexEntry(entryOne); BibEntry entryTwo = new BibEntry(); entryTwo.setField(StandardField.TITLE, \"testValueTwo\"); autoCompleter.indexEntry(entryTwo);  Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValueOne\", \"testValueTwo\"), result);",
        "ins2PreCode":"public void completeReturnsMultipleResults() { BibEntry entryOne = new BibEntry(); entryOne.setField(StandardField.TITLE, \"testValueOne\"); autoCompleter.indexEntry(entryOne); BibEntry entryTwo = new BibEntry(); entryTwo.setField(StandardField.TITLE, \"testValueTwo\"); autoCompleter.indexEntry(entryTwo); Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValueOne\", \"testValueTwo\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(1L, c.getStartValue(\"S1\", \"Task 1\")); assertEquals(3L, c.getStartValue(\"S1\", \"Task 2\")); assertEquals(5L, c.getStartValue(\"S2\", \"Task 3\")); assertEquals(1L, c.getStartValue(0, 0)); assertEquals(3L, c.getStartValue(0, 1)); assertEquals(5L, c.getStartValue(1, 2)); assertEquals(100L, c3.getStartValue(0, 0)); assertEquals(220L, c3.getStartValue(0, 1)); assertEquals(2220L, c3.getStartValue(1, 1));",
        "ins1DelCode":"assertEquals(new Long(1L), c.getStartValue(\"S1\", \"Task 1\")); assertEquals(new Long(3L), c.getStartValue(\"S1\", \"Task 2\")); assertEquals(new Long(5L), c.getStartValue(\"S2\", \"Task 3\")); assertEquals(new Long(1L), c.getStartValue(0, 0)); assertEquals(new Long(3L), c.getStartValue(0, 1)); assertEquals(new Long(5L), c.getStartValue(1, 2)); assertEquals(new Long(100), c3.getStartValue(0, 0)); assertEquals(new Long(220), c3.getStartValue(0, 1)); assertEquals(new Long(2220), c3.getStartValue(1, 1));",
        "ins1PreCode":"public void testGetStartValue() { TaskSeriesCollection c = createCollection1(); assertEquals(new Long(1L), c.getStartValue(\"S1\", \"Task 1\")); assertEquals(new Long(3L), c.getStartValue(\"S1\", \"Task 2\")); assertEquals(new Long(5L), c.getStartValue(\"S2\", \"Task 3\"));  assertEquals(new Long(1L), c.getStartValue(0, 0)); assertEquals(new Long(3L), c.getStartValue(0, 1)); assertEquals(null, c.getStartValue(0, 2)); assertEquals(null, c.getStartValue(1, 0)); assertEquals(null, c.getStartValue(1, 1)); assertEquals(new Long(5L), c.getStartValue(1, 2));   TaskSeriesCollection c3 = createCollection3(); assertEquals(new Long(100), c3.getStartValue(0, 0)); assertEquals(new Long(220), c3.getStartValue(0, 1)); assertTrue(c3.getStartValue(1, 0) == null); assertEquals(new Long(2220), c3.getStartValue(1, 1));",
        "ins2PreCode":"public void testGetEndValue() { TaskSeriesCollection c = createCollection1(); assertEquals(new Long(2L), c.getEndValue(\"S1\", \"Task 1\")); assertEquals(new Long(4L), c.getEndValue(\"S1\", \"Task 2\")); assertEquals(new Long(6L), c.getEndValue(\"S2\", \"Task 3\")); assertEquals(new Long(2L), c.getEndValue(0, 0)); assertEquals(new Long(4L), c.getEndValue(0, 1)); assertEquals(null, c.getEndValue(0, 2)); assertEquals(null, c.getEndValue(1, 0)); assertEquals(null, c.getEndValue(1, 1)); assertEquals(new Long(6L), c.getEndValue(1, 2)); TaskSeriesCollection c3 = createCollection3(); assertEquals(new Long(200), c3.getEndValue(0, 0)); assertEquals(new Long(200), c3.getEndValue(0, 0)); assertTrue(c3.getEndValue(1, 0) == null); assertEquals(new Long(3350), c3.getEndValue(1, 1));",
        "label":1
    },
    {
        "ins1AddCode":"TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult);",
        "ins1DelCode":"TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.addUnresolvedKey(UNKNOWN);",
        "ins1PreCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.addUnresolvedKey(UNKNOWN);  assertEquals(expectedCrossingResult, crossingResult);",
        "ins2PreCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"nested.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.insertEntry(database, DARWIN); assertEquals(expectedCrossingResult, crossingResult);",
        "label":1
    },
    {
        "ins1AddCode":"TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<>();",
        "ins1DelCode":"TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<Integer>();",
        "ins1PreCode":"List<Throwable> error = TestHelper.trackPluginErrors();  try { TestResourceSubscriber<Integer> tc = new TestResourceSubscriber<Integer>();  tc.onSubscribe(new BooleanSubscription());",
        "ins2PreCode":"List<Throwable> error = TestHelper.trackPluginErrors(); try { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>(); tc.onSubscribe(new BooleanSubscription());",
        "label":1
    },
    {
        "ins1AddCode":"List<String> pathElements = SelectorUtils.tokenizePath(path); parent.curpwd); throw new BuildException( \"could not change working dir to %s\", parent.curpwd); String currentPathElement = pathElements.get(fcount); if (!this.client.changeWorkingDirectory(currentPathElement)) { if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } this.curpwd = currentPathElement; getCurpwdPlusFileSep() + currentPathElement; throw new BuildException( \"could not change working dir to %s from %s\", currentPathElement, this.curpwd); (String) pathElements.elementAt(fcount) \" from \" + this.curpwd); String lastpathelement = pathElements.get(size - 1); FTPFile[] theFiles = listFiles(this.curpwd);",
        "ins1DelCode":"Vector pathElements = SelectorUtils.tokenizePath(path); throw new BuildException(\"could not change working dir to \" + parent.curpwd); String currentPathElement = (String) pathElements.elementAt(fcount); boolean result = this.client.changeWorkingDirectory(currentPathElement); if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } else if (!result) { this.curpwd = getCurpwdPlusFileSep() + currentPathElement; throw new BuildException(\"could not change working dir to \" + (String) pathElements.elementAt(fcount) + \" from \" + this.curpwd); String lastpathelement = (String) pathElements.elementAt(size - 1); FTPFile [] theFiles = listFiles(this.curpwd);",
        "ins1PreCode":"public AntFTPFile(AntFTPFile parent, String path) { this.parent = parent; this.client = parent.client; Vector pathElements = SelectorUtils.tokenizePath(path); try { boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());  if (!result) { return; } this.curpwd = parent.getAbsolutePath(); } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + parent.curpwd); } final int size = pathElements.size(); for (int fcount = 0; fcount < size - 1; fcount++) { String currentPathElement = (String) pathElements.elementAt(fcount); try { boolean result = this.client.changeWorkingDirectory(currentPathElement); if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } } else if (!result) { return; } this.curpwd = getCurpwdPlusFileSep() + currentPathElement; } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + (String) pathElements.elementAt(fcount) + \" from \" + this.curpwd); }  } String lastpathelement = (String) pathElements.elementAt(size - 1); FTPFile [] theFiles = listFiles(this.curpwd); this.ftpFile = getFile(theFiles, lastpathelement);",
        "ins2PreCode":"public AntFTPFile(AntFTPFile parent, String path) { this.parent = parent; this.client = parent.client; Vector pathElements = SelectorUtils.tokenizePath(path); try { boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath()); if (!result) { return; } this.curpwd = parent.getAbsolutePath(); } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + parent.curpwd); } final int size = pathElements.size(); for (int fcount = 0; fcount < size - 1; fcount++) { String currentPathElement = (String) pathElements.elementAt(fcount); try { boolean result = this.client.changeWorkingDirectory(currentPathElement); if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } } else if (!result) { return; } this.curpwd = getCurpwdPlusFileSep() + currentPathElement; } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + (String) pathElements.elementAt(fcount) + \" from \" + this.curpwd); } } String lastpathelement = (String) pathElements.elementAt(size - 1); FTPFile [] theFiles = listFiles(this.curpwd); this.ftpFile = getFile(theFiles, lastpathelement);",
        "label":0
    },
    {
        "ins1AddCode":"} catch (AssertionError e) {",
        "ins1DelCode":"} catch (AssertionFailedError e) {",
        "ins1PreCode":"try { assertEquals(expectedBasedirs[calls++], event.getProject().getBaseDir().getAbsolutePath()); } catch (AssertionFailedError e) { error = e; }",
        "ins2PreCode":"try { assertEquals(expectedBasedirs[calls++], event.getProject().getBaseDir().getAbsolutePath()); } catch (AssertionFailedError e) { error = e; }",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<SingleObserver<? super Integer>> moRef = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<SingleObserver<? super Integer>> moRef = new AtomicReference<SingleObserver<? super Integer>>();",
        "ins1PreCode":"public void innerErrorAfterTermination() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<SingleObserver<? super Integer>> moRef = new AtomicReference<SingleObserver<? super Integer>>();  TestSubscriberEx<Integer> ts = new Flowable<Integer>() {",
        "ins2PreCode":"public void innerErrorAfterTermination() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<MaybeObserver<? super Integer>> moRef = new AtomicReference<MaybeObserver<? super Integer>>(); TestSubscriberEx<Integer> ts = new Flowable<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"v = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null value\");",
        "ins1DelCode":"v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\");",
        "ins1PreCode":"R v;  try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"R v; try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"if (path == null) { return null; } int fragmentPos = path.indexOf('#'); if (fragmentPos > -1) { context.getLogger().warn(sm.getString(\"applicationHttpRequest.fragmentInDispatchPath\", path)); path = path.substring(0, fragmentPos); } if (path.startsWith(\"/\")) { } if (context.getDispatchersUseEncodedPaths()) { if (pos >= 0) { relative = URLEncoder.DEFAULT.encode( requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path; } else { relative = URLEncoder.DEFAULT.encode(requestPath, StandardCharsets.UTF_8) + path; } if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; }",
        "ins1DelCode":"if (path == null) return null; else if (path.startsWith(\"/\")) if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; relative = requestPath + path;",
        "ins1PreCode":"return null;   if (path == null) return null; else if (path.startsWith(\"/\")) return context.getServletContext().getRequestDispatcher(path); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) {",
        "ins1DelCode":"SqlSession sqlSession1 = sqlSessionFactory.openSession(true); try { } finally { sqlSession1.close(); SqlSession sqlSession2 = sqlSessionFactory.openSession(true); try { } finally { sqlSession2.close(); SqlSession sqlSession3 = sqlSessionFactory.openSession(true); try { } finally { sqlSession3.close();",
        "ins1PreCode":"public void testplan3() { SqlSession sqlSession1 = sqlSessionFactory.openSession(true); try { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); } finally { sqlSession1.close(); }  SqlSession sqlSession2 = sqlSessionFactory.openSession(true); try { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); pm.delete(1); } finally { sqlSession2.close(); }  SqlSession sqlSession3 = sqlSessionFactory.openSession(true); try { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(1, pm.findAll().size()); } finally { sqlSession3.close(); }",
        "ins2PreCode":"public void shouldInsertWithOptionsFlushesCache() { SqlSession sqlSession1 = sqlSessionFactory.openSession(true); try { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); } finally { sqlSession1.close(); } SqlSession sqlSession2 = sqlSessionFactory.openSession(true); try { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); pm.createWithOptions(p); } finally { sqlSession2.close(); } SqlSession sqlSession3 = sqlSessionFactory.openSession(true); try { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); } finally { sqlSession3.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"final WeakReference<Disposable> wr = new WeakReference<>(d);",
        "ins1DelCode":"final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "ins1PreCode":"public void successDetaches() throws Exception { Disposable d = Disposable.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);  TestObserver<Integer> to = new Single<Integer>() {",
        "ins2PreCode":"public void successDetaches() throws Exception { Disposable d = Disposable.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d); TestObserver<Integer> to = new Maybe<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"element.invalidate();",
        "ins1DelCode":"element.setValid(false);",
        "ins1PreCode":"first.setPrevious(null); } size--; element.setValid(false); } return content;",
        "ins2PreCode":"last = last.getPrevious(); } size--; element.setValid(false); } return content;",
        "label":1
    },
    {
        "ins1AddCode":"void setLevelToNull(CapturedOutput output) { assertThat(StringUtils.countOccurrencesOf(output.toString(), \"Hello\")).isEqualTo(1);",
        "ins1DelCode":"public void setLevelToNull() { assertThat(StringUtils.countOccurrencesOf(this.output.toString(), \"Hello\")).isEqualTo(1);",
        "ins1PreCode":"public void setLevelToNull() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", null); this.logger.debug(\"Hello\"); assertThat(StringUtils.countOccurrencesOf(this.output.toString(), \"Hello\")).isEqualTo(1);",
        "ins2PreCode":"public void setLevel() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); this.loggingSystem.setLogLevel(\"org.springframework.boot\", LogLevel.DEBUG); this.logger.debug(\"Hello\"); assertThat(StringUtils.countOccurrencesOf(this.output.toString(), \"Hello\")).isEqualTo(1);",
        "label":1
    },
    {
        "ins1AddCode":"void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception {",
        "ins1DelCode":"public void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception {",
        "ins1PreCode":"public void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception { Map<String, String> KEYS = Collections.singletonMap(\"valid-key\", INVALID_KEY); given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(KEYS));",
        "ins2PreCode":"public void validateTokenWhenTokenAlgorithmIsNotRS256ShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));",
        "label":1
    },
    {
        "ins1AddCode":"void shouldDemonstrateCopiesAreEqual() {",
        "ins1DelCode":"public void shouldDemonstrateCopiesAreEqual() {",
        "ins1PreCode":"public void shouldDemonstrateCopiesAreEqual() { Cache cache = new SoftCache(new PerpetualCache(\"default\")); cache = new SerializedCache(cache);",
        "ins2PreCode":"public void shouldDemonstrateCopiesAreEqual() { Cache cache = new WeakCache(new PerpetualCache(\"default\")); cache = new SerializedCache(cache);",
        "label":1
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaVectorSlicerExample\").getOrCreate(); List<Row> data = Lists.newArrayList( ); spark.createDataFrame(data, (new StructType()).add(group.toStructField())); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JavaVectorSlicerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); JavaRDD<Row> jrdd = jsc.parallelize(Lists.newArrayList( )); jsql.createDataFrame(jrdd, (new StructType()).add(group.toStructField())); jsc.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaVectorSlicerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Attribute[] attrs = new Attribute[]{ NumericAttribute.defaultAttr().withName(\"f1\"), NumericAttribute.defaultAttr().withName(\"f2\"), NumericAttribute.defaultAttr().withName(\"f3\") }; AttributeGroup group = new AttributeGroup(\"userFeatures\", attrs);  JavaRDD<Row> jrdd = jsc.parallelize(Lists.newArrayList( RowFactory.create(Vectors.sparse(3, new int[]{0, 1}, new double[]{-2.0, 2.3})), RowFactory.create(Vectors.dense(-2.0, 2.3, 0.0)) ));  Dataset<Row> dataset = jsql.createDataFrame(jrdd, (new StructType()).add(group.toStructField()));  VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\");  vectorSlicer.setIndices(new int[]{1}).setNames(new String[]{\"f3\"});   Dataset<Row> output = vectorSlicer.transform(dataset);  System.out.println(output.select(\"userFeatures\", \"features\").first());  jsc.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"CroAnnHow05\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"CroAnnHow05\"), entry.getCiteKeyOptional());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.InProceedings, entry.getType()); assertEquals(8, entry.getFields().size()); assertEquals(Optional.of(\"CroAnnHow05\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"Crowston, K. and Annabi, H. and Howison, J. and Masango, C.\"), entry.getField(StandardField.AUTHOR)); assertEquals(Optional.of(\"Effective work practices for floss development: A model and propositions\"),",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.InProceedings, entry.getType()); assertEquals(8, entry.getFields().size()); assertEquals(Optional.of(\"CroAnnHow05\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"Crowston, K. and Annabi, H. and Howison, J. and Masango, C.\"), entry.getField(StandardField.AUTHOR)); assertEquals(Optional.of(\"Effective work practices for floss development: A model and propositions\"),",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ObservableSkipLastTimed<>(this, time, unit, scheduler, s, delayError));",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ObservableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));",
        "ins1PreCode":"ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");  int s = bufferSize << 1; return RxJavaPlugins.onAssembly(new ObservableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));",
        "ins2PreCode":"ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); int s = bufferSize << 1; return RxJavaPlugins.onAssembly(new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));",
        "label":0
    },
    {
        "ins1AddCode":"void parseDebugArg() { assertThat(this.output).contains(\"testatdebug\"); assertThat(this.output).doesNotContain(\"testattrace\");",
        "ins1DelCode":"public void parseDebugArg() { assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).doesNotContain(\"testattrace\");",
        "ins1PreCode":"public void parseDebugArg() { addPropertiesToEnvironment(this.context, \"debug\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).doesNotContain(\"testattrace\");",
        "ins2PreCode":"public void parseTraceArg() { addPropertiesToEnvironment(this.context, \"trace\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "label":1
    },
    {
        "ins1AddCode":"expected.remove(JstorFetcher.class); expected.remove(GoogleScholar.class);",
        "ins1DelCode":"",
        "ins1PreCode":"  expected.remove(ACMPortalFetcher.class);  assertEquals(expected, getClasses(idFetchers)); }",
        "ins2PreCode":"expected.remove(ACMPortalFetcher.class); assertEquals(expected, getClasses(searchBasedFetchers)); }",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\")); });",
        "ins1DelCode":"CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\"));",
        "ins1PreCode":"public void cloudFoundryPlatformActive() { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public final <R> Flowable<R> concatMap(@NonNull Function<? super T, ? extends Publisher<@NonNull ? extends R>> mapper, int prefetch) {",
        "ins1DelCode":"public final <R> Flowable<R> concatMap(@NonNull Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) {",
        "ins1PreCode":"public final <R> Flowable<R> concatMap(@NonNull Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\");",
        "ins2PreCode":"public final <R> Flowable<R> concatMapDelayError(@NonNull Function<? super T, ? extends Publisher<? extends R>> mapper, Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\");",
        "label":1
    },
    {
        "ins1AddCode":"Files.createDirectories( mavenHomeDir ); File garbage = mavenHomeDir.resolve( \"garbage\" ).toFile(); Files.createFile( garbage.toPath() ); Path homeDir = install.createDist( configuration ); Assert.assertTrue( Files.isDirectory( mavenHomeDir ) ); Assert.assertFalse( Files.exists( homeDir.resolve( \"garbage\" ) ) ); Assert.assertTrue( Files.exists( zipDestination ) );",
        "ins1DelCode":"mavenHomeDir.mkdirs(); File garbage = new File( mavenHomeDir, \"garbage\" ); FileUtils.touch( garbage ); File homeDir = install.createDist( configuration ); Assert.assertTrue( mavenHomeDir.isDirectory() ); Assert.assertFalse( new File( homeDir, \"garbage\" ).exists() ); Assert.assertTrue( zipDestination.exists() );",
        "ins1PreCode":"{  createTestZip( zipDestination ); mavenHomeDir.mkdirs(); File garbage = new File( mavenHomeDir, \"garbage\" ); FileUtils.touch( garbage ); configuration.setAlwaysUnpack( true );  File homeDir = install.createDist( configuration );  Assert.assertEquals( mavenHomeDir, homeDir ); Assert.assertTrue( mavenHomeDir.isDirectory() ); Assert.assertFalse( new File( homeDir, \"garbage\" ).exists() ); Assert.assertTrue( zipDestination.exists() );  Assert.assertEquals( localDistribution, pathAssembler.getDistribution( configuration ) );",
        "ins2PreCode":"{ createTestZip( zipDestination ); Assert.assertEquals( mavenHomeDir, homeDir ); File garbage = new File( mavenHomeDir, \"garbage\" ); FileUtils.touch( garbage ); configuration.setAlwaysUnpack( true ); File homeDir = install.createDist( configuration ); Assert.assertEquals( mavenHomeDir, homeDir ); Assert.assertTrue( mavenHomeDir.isDirectory() ); Assert.assertFalse( new File( homeDir, \"garbage\" ).exists() ); Assert.assertTrue( zipDestination.exists() ); Assert.assertEquals( localDistribution, pathAssembler.getDistribution( configuration ) );",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"sparkConf = new SparkConf();",
        "ins1PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); sparkConf = new SparkConf(); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"entry.setCitationKey(\"testKey\");",
        "ins1DelCode":"entry.setCiteKey(\"testKey\");",
        "ins1PreCode":"void completeKeyReturnsKey() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"testKey\"); database.insertEntry(entry); ",
        "ins2PreCode":"void completeLowercaseKeyReturnsKey() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"testKey\"); database.insertEntry(entry);",
        "label":1
    },
    {
        "ins1AddCode":"public void setLevel() {",
        "ins1DelCode":"public void setLevel() throws Exception {",
        "ins1PreCode":"public void setLevel() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null);",
        "ins2PreCode":"public void setLevelToNull() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null);",
        "label":1
    },
    {
        "ins1AddCode":"Tuple3<List<Rating>, double[], double[]> testData = ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);",
        "ins1DelCode":"Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false);",
        "ins1PreCode":"int iterations = 15; int users = 80; int products = 160; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false);  JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "ins2PreCode":"int iterations = 15; int users = 100; int products = 200; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void coldReplayNoBackpressure() { Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  source.subscribe(ts);",
        "ins2PreCode":"public void coldReplayNoBackpressure() { Flowable<Integer> source = Flowable.range(0, 1000).replay().autoConnect(); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); source.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\") ; } catch (BuildException ex) { assertEquals(specificMessage, ex.getMessage()); }",
        "ins1DelCode":"expectSpecificBuildException(target.toString(), \"it is required to fail :-)\", specificMessage);",
        "ins1PreCode":" for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); expectSpecificBuildException(target.toString(), \"it is required to fail :-)\", specificMessage); }",
        "ins2PreCode":"for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); expectSpecificBuildException(target.toString(), \"it is required to fail :-)\", specificMessage); }",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false);",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"Series 1\", true, false); XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
        "ins1PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "ins2PreCode":"try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1); XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0); s2.add(10.0, 15.5);",
        "label":1
    },
    {
        "ins1AddCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins1DelCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { String sql = buildStatement(command.getObject(), true); actionList.add(new SQLDatabasePersistAction(\"Alter Sequence\", sql));",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) String sql = buildStatement(command.getObject(), true); actionList.add(new SQLDatabasePersistAction(\"Alter Sequence\", sql));",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> concat(",
        "ins1DelCode":"public static <T> Flowable<T> concat(",
        "ins1PreCode":"public static <T> Flowable<T> concat( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"setMapValuesUsingAccessors(builder); updateMapValuesUsingAccessors(builder);",
        "ins1DelCode":"setMapValuesUsingMutableMap(builder); updateMapValuesUsingMutableMap(builder);",
        "ins1PreCode":"assertMapValuesCleared(message);  builder = message.toBuilder(); setMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesUpdated(message);",
        "ins2PreCode":"assertMapValuesCleared(message); builder = message.toBuilder(); setMapValues(builder); message = builder.build(); assertMapValuesSet(message); builder = message.toBuilder(); updateMapValues(builder); message = builder.build(); assertMapValuesUpdated(message);",
        "label":0
    },
    {
        "ins1AddCode":"void simpleMapPropertySourceKeyDataChangeInvalidatesCache() {",
        "ins1DelCode":"public void simpleMapPropertySourceKeyDataChangeInvalidatesCache() {",
        "ins1PreCode":"public void simpleMapPropertySourceKeyDataChangeInvalidatesCache() {  Map<String, Object> map = new LinkedHashMap<>();",
        "ins2PreCode":"public void concurrentModificationExceptionInvalidatesCache() { ConcurrentModificationThrowingMap<String, Object> map = new ConcurrentModificationThrowingMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"public void testNaming() {",
        "ins1DelCode":"public void testNaming() throws Exception {",
        "ins1PreCode":"public void testNaming() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner() .withUserConfiguration(FooConfig.class)",
        "ins2PreCode":"public void testEmptyMapIsNotAdded() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner() .withUserConfiguration(MapConfig.class);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> subplot1 = (CategoryPlot) plot.getSubplots().get(0);",
        "ins1DelCode":"CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0);",
        "ins1PreCode":"CombinedRangeCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final List<Long> list = new CopyOnWriteArrayList<>();",
        "ins1DelCode":"final List<Long> list = new CopyOnWriteArrayList<Long>();",
        "ins1PreCode":"public void issue3008RetryInfinite() { final List<Long> list = new CopyOnWriteArrayList<Long>(); final AtomicBoolean isFirst = new AtomicBoolean(true); Flowable.<Long> just(1L, 2L, 3L).map(new Function<Long, Long>() {",
        "ins2PreCode":"public void issue3008RetryInfinite() { final List<Long> list = new CopyOnWriteArrayList<Long>(); final AtomicBoolean isFirst = new AtomicBoolean(true); Observable.<Long> just(1L, 2L, 3L).map(new Function<Long, Long>() {",
        "label":1
    },
    {
        "ins1AddCode":"protected void applyThemeSettings(ITheme currentTheme) { curLineColor = currentTheme.getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK);",
        "ins1DelCode":"protected void applyThemeSettings() { IThemeManager themeManager = controller.getSite().getWorkbenchWindow().getWorkbench().getThemeManager(); curLineColor = themeManager.getCurrentTheme().getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK); ITheme currentTheme = themeManager.getCurrentTheme();",
        "ins1PreCode":"protected void applyThemeSettings() { IThemeManager themeManager = controller.getSite().getWorkbenchWindow().getWorkbench().getThemeManager(); curLineColor = themeManager.getCurrentTheme().getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK);  ITheme currentTheme = themeManager.getCurrentTheme(); Font rsFont = currentTheme.getFontRegistry().get(ThemeConstants.FONT_SQL_RESULT_SET); if (rsFont != null) {",
        "ins2PreCode":"protected void applyThemeSettings() { IThemeManager themeManager = controller.getSite().getWorkbenchWindow().getWorkbench().getThemeManager(); curLineColor = themeManager.getCurrentTheme().getColorRegistry().get(ThemeConstants.COLOR_SQL_RESULT_CELL_ODD_BACK); ITheme currentTheme = themeManager.getCurrentTheme(); Font rsFont = currentTheme.getFontRegistry().get(ThemeConstants.FONT_SQL_RESULT_SET); if (rsFont != null) {",
        "label":1
    },
    {
        "ins1AddCode":"getStereotypeFig().setKeyword(getKeyword());",
        "ins1DelCode":"getStereotypeFig().setKeyword(\"datatype\");",
        "ins1PreCode":"private void constructFigs() { getStereotypeFig().setKeyword(\"datatype\");  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory());",
        "ins1DelCode":"MetaClass metaClass = MetaClass.forClass(parameterType);",
        "ins1PreCode":"} else if (JdbcType.CURSOR.name().equals(jdbcType)) { propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType); if (metaClass.hasGetter(property)) { propertyType = metaClass.getGetterType(property);",
        "ins2PreCode":"} else if (JdbcType.CURSOR.name().equals(propertiesMap.get(\"jdbcType\"))) { propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType); if (metaClass.hasGetter(property)) { propertyType = metaClass.getGetterType(property);",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset<String> dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYDataset dataset = new XYSeriesCollection<String>(series1);",
        "ins1PreCode":"series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYStepAreaChart(\"Step Chart\", \"Domain\", \"Range\", dataset);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"DatasetUtils.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "ins2PreCode":"= DatasetUtils.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "label":1
    },
    {
        "ins1AddCode":"public void parentContextCreationThatIsRunDirectly() {",
        "ins1DelCode":"public void parentContextCreationThatIsRunDirectly() throws Exception {",
        "ins1PreCode":"public void parentContextCreationThatIsRunDirectly() throws Exception { SpringApplicationBuilder application = new SpringApplicationBuilder( ChildConfig.class).contextClass(SpyApplicationContext.class);",
        "ins2PreCode":"public void parentContextCreationThatIsBuiltThenRun() throws Exception { SpringApplicationBuilder application = new SpringApplicationBuilder( ChildConfig.class).contextClass(SpyApplicationContext.class);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs1 = Disposable.empty(); Disposable bs2 = Disposable.empty();",
        "ins1DelCode":"Disposable bs1 = Disposables.empty(); Disposable bs2 = Disposables.empty();",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1);  Disposable bs2 = Disposables.empty(); observer.onSubscribe(bs2); ",
        "ins2PreCode":"observer.onComplete(); @Override protected void subscribeActual(MaybeObserver<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1); Disposable bs2 = Disposables.empty(); observer.onSubscribe(bs2);",
        "label":1
    },
    {
        "ins1AddCode":"DocumentMapper mapper = createDocumentMapper( fieldMapping(b -> b.field(\"type\", \"scaled_float\").field(\"index\", false).field(\"scaling_factor\", 10.0)) );",
        "ins1DelCode":"String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"index\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject()); DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping)); assertEquals(mapping, mapper.mappingSource().toString());",
        "ins1PreCode":"public void testNotIndexed() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"index\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject());  DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));  assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference",
        "ins2PreCode":"public void testNoDocValues() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"doc_values\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject()); DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping)); assertEquals(mapping, mapper.mappingSource().toString()); ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void inEdges_checkReturnedSetMutability() { addNode(N2); Set<String> inEdges = network.inEdges(N2); try { inEdges.add(E12);",
        "ins2PreCode":"public void inEdges_checkReturnedSetMutability() { addNode(N2); Set<String> inEdges = network.inEdges(N2); try { inEdges.add(E12);",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>07-hello world</p>\") > 0);",
        "ins1DelCode":"",
        "ins1PreCode":"Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"Assert.assertTrue(result.indexOf(\"<p>00-${'hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>01-#{'hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>00-${'hello world'}</p>\") > 0);",
        "label":0
    },
    {
        "ins1AddCode":"ctx.addApplicationListener(new ApplicationListener( TesterEchoServer.Config.class.getName(), false));",
        "ins1DelCode":"ctx.addApplicationListener(TesterEchoServer.Config.class.getName());",
        "ins1PreCode":" Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName());  tomcat.start();",
        "ins2PreCode":"Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"richType.richProperty\", meta.findProperty(\"richType.richProperty\", false));",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(meta.hasGetter(\"richType.richMap\")); assertTrue(meta.hasGetter(\"richType.richList[0]\"));  assertFalse(meta.hasGetter(\"[0]\"));",
        "ins2PreCode":"assertTrue(meta.hasSetter(\"richType.richMap\")); assertTrue(meta.hasSetter(\"richType.richList[0]\")); assertFalse(meta.hasSetter(\"[0]\"));",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(StandardField.JOURNAL)); entry.getField(StandardField.TITLE)); assertEquals(Optional.of(\"4\"), entry.getField(StandardField.VOLUME)); assertEquals(Optional.of(\"3\"), entry.getField(StandardField.NUMBER)); assertEquals(Optional.of(\"1545-598X\"), entry.getField(new UnknownField(\"SN\"))); assertEquals(Optional.of(\"387--391\"), entry.getField(StandardField.PAGES)); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(StandardField.AUTHOR)); assertEquals(Optional.of(\"2006\"), entry.getField(StandardField.YEAR)); entry.getField(StandardField.KEYWORDS)); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(StandardField.ABSTRACT));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(\"journal\")); entry.getField(\"title\")); assertEquals(Optional.of(\"4\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"3\"), entry.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), entry.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), entry.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(\"author\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); entry.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(\"abstract\"));",
        "ins1PreCode":"BibEntry entry = entries.get(0);  assertEquals(1, entries.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"Improving Urban Road Extraction in High-Resolution \" + \"Images Exploiting Directional Filtering, Perceptual \" + \"Grouping, and Simple Topological Concepts\"), entry.getField(\"title\")); assertEquals(Optional.of(\"4\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"3\"), entry.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), entry.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), entry.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(\"author\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), entry.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(\"abstract\"));",
        "ins2PreCode":"BibEntry entry = entries.get(0); assertEquals(1, entries.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), \"Improving Urban Road Extraction in High-Resolution Images Exploiting Directional Filtering, Perceptual Grouping, and Simple Topological Concepts\"), entry.getField(\"title\")); assertEquals(Optional.of(\"4\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"3\"), entry.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), entry.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), entry.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(\"author\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), entry.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(\"abstract\"));",
        "label":1
    },
    {
        "ins1AddCode":"if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getOpType(), Project.MSG_VERBOSE); } if (Execute.isFailure(result) && getFailOnErr()) { throw new BuildException(msg, getLocation());",
        "ins1DelCode":"System.out.println(commandLine.toString()); if (Execute.isFailure(result)) { throw new BuildException(msg, location);",
        "ins1PreCode":"checkOptions(commandLine);   System.out.println(commandLine.toString());  result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, location); }",
        "ins2PreCode":"checkOptions(commandLine); System.out.println(commandLine.toString()); result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, location); }",
        "label":1
    },
    {
        "ins1AddCode":"DateTickUnit unit = new DateTickUnit(DateTickUnitType.SECOND, 1); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault());",
        "ins1DelCode":"DateTickUnit unit = new DateTickUnit(DateTickUnit.SECOND, 1); Date nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd);",
        "ins1PreCode":" Date end = new Date(s1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.SECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "ins2PreCode":"Date end = new Date(s1.getLastMillisecond()); DateTickUnit unit = new DateTickUnit(DateTickUnit.SECOND, 5); axis.setTickUnit(unit); axis.setTickMarkPosition(DateTickMarkPosition.START); axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime()); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime()); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.END); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); ",
        "ins2PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; CategoryDataset newData = DatasetUtilities.createCategoryDataset( \"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "label":1
    },
    {
        "ins1AddCode":"Object[] path = new Object[2]; int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; fireTreeNodesInserted(this, path, childIndices, children);",
        "ins1DelCode":"final Object[] path = new Object[2]; final int[] childIndices = new int[nMatchingItems]; final Object[] children = new Object[nMatchingItems]; fireNodesInserted(path, childIndices, children);",
        "ins1PreCode":"public void toDoItemsAdded(ToDoListEvent tde) { LOG.debug(\"toDoItemAdded\"); List<ToDoItem> items = tde.getToDoItemList(); final Object[] path = new Object[2]; path[0] = Designer.theDesigner().getToDoList();  for (PriorityNode pn : PriorityNode.getPriorityList()) { path[1] = pn; int nMatchingItems = 0; synchronized (items) { for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } nMatchingItems++; } } if (nMatchingItems == 0) { continue; } final int[] childIndices = new int[nMatchingItems]; final Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; synchronized (items) { for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } childIndices[nMatchingItems] = getIndexOfChild(pn, item); children[nMatchingItems] = item; nMatchingItems++; } } fireNodesInserted(path, childIndices, children); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void testAdderAsSelectDoubleCall1() {",
        "ins1DelCode":"public void testAdderAsSelectDoubleCall1() {",
        "ins1PreCode":"public void testAdderAsSelectDoubleCall1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter parameter = new Parameter();",
        "ins2PreCode":"public void testAdderAsSelectDoubleCall2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter parameter = new Parameter();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, s1.indexOf(1.0)); assertEquals(1, s1.indexOf(2.0));",
        "ins1DelCode":"assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(2.0)));",
        "ins1PreCode":"s1.add(1.0, 1.0); s1.add(2.0, 2.0); s1.add(2.0, 3.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(2.0)));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JenkinsRule.WebClient wc = j.createWebClient() .withThrowExceptionOnFailingStatusCode(false);",
        "ins1DelCode":"JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false);",
        "ins1PreCode":"testParams.paramAlt = \"Alternative text for icon\"; testParams.paramConfirm = \"Confirm message\";  JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); HtmlPage p = wc.goTo(\"test\"); ",
        "ins2PreCode":"testParams.paramAlt = \"Alternative text for icon\"; testParams.paramConfirm = postPayload; JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); HtmlPage p = wc.goTo(\"test\");",
        "label":1
    },
    {
        "ins1AddCode":"}, true, 2, Schedulers.single())",
        "ins1DelCode":"}, 2, true, Schedulers.single())",
        "ins1PreCode":"public Observable<String> apply(Integer t) throws Throwable { return Observable.just(Thread.currentThread().getName()).hide(); } }, 2, true, Schedulers.single()) .test() .awaitDone(5, TimeUnit.SECONDS)",
        "ins2PreCode":"public Flowable<String> apply(Integer t) throws Throwable { return Flowable.just(Thread.currentThread().getName()).hide(); } }, 2, true, Schedulers.single()) .test() .awaitDone(5, TimeUnit.SECONDS)",
        "label":1
    },
    {
        "ins1AddCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<? super Throwable> onError) {",
        "ins1DelCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) {",
        "ins1PreCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) { Objects.requireNonNull(onError, \"onError is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<>(this,",
        "ins2PreCode":"public final ParallelFlowable<T> doOnComplete(@NonNull Action onComplete) { Objects.requireNonNull(onComplete, \"onComplete is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<>(this,",
        "label":0
    },
    {
        "ins1AddCode":"List<ModelObject> itemList = newRuns(1, 10);",
        "ins1DelCode":"List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10));",
        "ins1PreCode":"public void test_olderThan_mid_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 8L); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList); ",
        "ins2PreCode":"public void test_newerThan_near_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 3L, null); List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1AddCode":".set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), useOffHeapMemoryAllocator()) .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 256 * 1024 * 1024L)",
        "ins1DelCode":".set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\")",
        "ins1PreCode":"memoryManager = new TestMemoryManager( new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\") .set(package$.MODULE$.SHUFFLE_SPILL_COMPRESS(), false) .set(package$.MODULE$.SHUFFLE_COMPRESS(), false));",
        "ins2PreCode":"serializerManager, serializerManager, anyInt(), File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); return Tuple2$.MODULE$.apply(blockId, file); return Tuple2$.MODULE$.apply(blockId, file);",
        "label":0
    },
    {
        "ins1AddCode":"this.contextRunner .withPropertyValues(\"management.metrics.export.appoptics.api-token=abcde\") .withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "ins1DelCode":"this.contextRunner.withUserConfiguration(BaseConfiguration.class) .run((context) -> {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class) .run((context) -> { AppOpticsMeterRegistry registry = context .getBean(AppOpticsMeterRegistry.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void legacyToken_regularCase() throws Throwable { sessions.then(j -> { configureSecurity(j); JenkinsRule.WebClient wc = j.createWebClient(); sessions.then(j -> { JenkinsRule.WebClient wc = j.createWebClient(); WebRequest request = new WebRequest(new URL(j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); WebRequest request = new WebRequest(new URL(j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); WebRequest request = new WebRequest(new URL(j.jenkins.getRootUrl() + \"whoAmI/api/xml\"));",
        "ins1DelCode":"public void legacyToken_regularCase() { rr.addStep(new Statement() { @Override public void evaluate() throws Throwable { configureSecurity(); JenkinsRule.WebClient wc = rr.j.createWebClient(); } rr.addStep(new Statement() { @Override public void evaluate() throws Throwable { JenkinsRule.WebClient wc = rr.j.createWebClient(); WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); }",
        "ins1PreCode":"public void legacyToken_regularCase() { AtomicReference<String> token = new AtomicReference<>(); rr.addStep(new Statement() { @Override public void evaluate() throws Throwable { enableLegacyTokenGenerationOnUserCreation(); configureSecurity();  { JenkinsRule.WebClient wc = rr.j.createWebClient();   wc.login(\"user1\"); HtmlPage page = wc.goTo(\"user/user1/configure\"); String tokenValue = ((HtmlTextInput) page.getDocumentElement().querySelector(\"#apiToken\")).getText(); token.set(tokenValue); } } }); rr.addStep(new Statement() { @Override public void evaluate() throws Throwable { User user = User.getById(\"user1\", false); assertNotNull(user);  JenkinsRule.WebClient wc = rr.j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false);  { WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); request.setAdditionalHeader(\"Authorization\", base64(\"user1\", \"invalid-token\")); assertThat(wc.getPage(request).getWebResponse().getStatusCode(), equalTo(401)); } { WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); request.setAdditionalHeader(\"Authorization\", base64(\"user-not-valid\", token.get())); assertThat(wc.getPage(request).getWebResponse().getStatusCode(), equalTo(401)); }  assertNull(User.getById(\"user-not-valid\", false));  { WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); request.setAdditionalHeader(\"Authorization\", base64(\"user1\", token.get())); XmlPage xmlPage = wc.getPage(request);",
        "ins2PreCode":"public void legacyToken_withoutLastGrantedAuthorities() { AtomicReference<String> token = new AtomicReference<>(); rr.addStep(new Statement() { @Override public void evaluate() throws Throwable { enableLegacyTokenGenerationOnUserCreation(); configureSecurity(); { JenkinsRule.WebClient wc = rr.j.createWebClient(); wc.login(\"user1\"); HtmlPage page = wc.goTo(\"user/user1/configure\"); String tokenValue = ((HtmlTextInput) page.getDocumentElement().querySelector(\"#apiToken\")).getText(); token.set(tokenValue); } } }); rr.addStep(new Statement() { @Override public void evaluate() throws Throwable { User user = User.getById(\"user1\", false); assertNull(user); JenkinsRule.WebClient wc = rr.j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); { WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); request.setAdditionalHeader(\"Authorization\", base64(\"user1\", \"invalid-token\")); assertThat(wc.getPage(request).getWebResponse().getStatusCode(), equalTo(401)); } { WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); request.setAdditionalHeader(\"Authorization\", base64(\"user-not-valid\", token.get())); assertThat(wc.getPage(request).getWebResponse().getStatusCode(), equalTo(401)); } assertNull(User.getById(\"user-not-valid\", false)); { WebRequest request = new WebRequest(new URL(rr.j.jenkins.getRootUrl() + \"whoAmI/api/xml\")); request.setAdditionalHeader(\"Authorization\", base64(\"user1\", token.get())); XmlPage xmlPage = wc.getPage(request);",
        "label":1
    },
    {
        "ins1AddCode":"if (isJdk9()) { return; }",
        "ins1DelCode":"",
        "ins1PreCode":"public void testUnloadableInStaticFieldIfClosed() throws Exception { Policy oldPolicy = Policy.getPolicy(); SecurityManager oldSecurityManager = System.getSecurityManager(); try { Policy.setPolicy(new PermissivePolicy());",
        "ins2PreCode":"public void testUnloadableInStaticFieldIfClosed() throws Exception { Policy oldPolicy = Policy.getPolicy(); SecurityManager oldSecurityManager = System.getSecurityManager(); try { Policy.setPolicy(new PermissivePolicy());",
        "label":1
    },
    {
        "ins1AddCode":"}).block(Duration.ofSeconds(30));",
        "ins1DelCode":"}).block();",
        "ins1PreCode":".onErrorResume((t) -> { exchange.getResponse().setStatusCodeValue(500); return exchange.getResponse().setComplete(); }).block(); assertMetricsContainsTag(\"uri\", \"/projects/{project}\"); assertMetricsContainsTag(\"status\", \"500\");",
        "ins2PreCode":".onErrorResume((t) -> { exchange.getResponse().setStatusCodeValue(500); return exchange.getResponse().setComplete(); }).block(); assertMetricsContainsTag(\"uri\", \"/projects/{project}\"); assertMetricsContainsTag(\"status\", \"500\");",
        "label":1
    },
    {
        "ins1AddCode":"o.onSubscribe(Disposable.empty());",
        "ins1DelCode":"o.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(final Observer<? super Integer> o) { o.onSubscribe(Disposables.empty()); task.replace(Schedulers.single().scheduleDirect(new Runnable() { ",
        "ins2PreCode":"@Override public void subscribe(final Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); task.replace(Schedulers.single().scheduleDirect(new Runnable() {",
        "label":0
    },
    {
        "ins1AddCode":"if (locale.getLanguage().equals(Locale.ENGLISH.getLanguage())) { locale = Locale.ROOT; }",
        "ins1DelCode":"",
        "ins1PreCode":"} catch (MissingResourceException ex) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (cl != null) { try {",
        "ins2PreCode":"} catch (MissingResourceException ex) { ClassLoader cl = Thread.currentThread().getContextClassLoader(); if (cl != null) { try {",
        "label":0
    },
    {
        "ins1AddCode":"public void testList() {",
        "ins1DelCode":"public void testList() throws Exception {",
        "ins1PreCode":"public void testList() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner() .withUserConfiguration(ListConfig.class)",
        "ins2PreCode":"public void testInetAddress() throws Exception { ApplicationContextRunner contextRunner = new ApplicationContextRunner() .withUserConfiguration(AddressedConfig.class)",
        "label":1
    },
    {
        "ins1AddCode":"result.subplots = (List) ObjectUtils.deepClone(this.subplots);",
        "ins1DelCode":"result.subplots = (List) ObjectUtilities.deepClone(this.subplots);",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException { CombinedRangeCategoryPlot result = (CombinedRangeCategoryPlot) super.clone(); result.subplots = (List) ObjectUtilities.deepClone(this.subplots); for (Iterator it = result.subplots.iterator(); it.hasNext();) { Plot child = (Plot) it.next();",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) ObjectUtilities.deepClone(this.subplots); for (Iterator it = result.subplots.iterator(); it.hasNext();) { Plot child = (Plot) it.next();",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> fromObservable(@NonNull ObservableSource<T> source, @NonNull BackpressureStrategy strategy) {",
        "ins1DelCode":"public static <T> Flowable<T> fromObservable(@NonNull ObservableSource<T> source, @NonNull BackpressureStrategy strategy) {",
        "ins1PreCode":"public static <T> Flowable<T> fromObservable(@NonNull ObservableSource<T> source, @NonNull BackpressureStrategy strategy) { Objects.requireNonNull(source, \"source is null\"); Objects.requireNonNull(strategy, \"strategy is null\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Map<Object, Repository> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 ); target.setRepositories( new ArrayList<>( merged.values() ) );",
        "ins1DelCode":"Map<Object, Repository> merged = new LinkedHashMap<Object, Repository>( ( src.size() + tgt.size() ) * 2 ); target.setRepositories( new ArrayList<Repository>( merged.values() ) );",
        "ins1PreCode":"if ( !src.isEmpty() ) { List<Repository> tgt = target.getRepositories(); Map<Object, Repository> merged = new LinkedHashMap<Object, Repository>( ( src.size() + tgt.size() ) * 2 );  List<Repository> dominant, recessive; if ( sourceDominant ) { dominant = src; recessive = tgt; } else { dominant = tgt; recessive = src; }  for ( Repository element : dominant ) { Object key = getRepositoryKey( element ); merged.put( key, element ); }  for ( Repository element : recessive ) { Object key = getRepositoryKey( element ); if ( !merged.containsKey( key ) ) { merged.put( key, element ); } }  target.setRepositories( new ArrayList<Repository>( merged.values() ) ); }",
        "ins2PreCode":"if ( !src.isEmpty() ) { List<Repository> tgt = target.getPluginRepositories(); Map<Object, Repository> merged = new LinkedHashMap<Object, Repository>( ( src.size() + tgt.size() ) * 2 ); List<Repository> dominant, recessive; if ( sourceDominant ) { dominant = src; recessive = tgt; } else { dominant = tgt; recessive = src; } for ( Repository element : dominant ) { Object key = getRepositoryKey( element ); merged.put( key, element ); } for ( Repository element : recessive ) { Object key = getRepositoryKey( element ); if ( !merged.containsKey( key ) ) { merged.put( key, element ); } } target.setPluginRepositories( new ArrayList<Repository>( merged.values() ) ); }",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateStarShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateStarShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"log.error(sm.getString(\"opensslconf.failedCommand\", name, value, Integer.toString(rc))); log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, Integer.toString(rc)));",
        "ins1DelCode":"log.error(sm.getString(\"opensslconf.failedCommand\", name, value, rc)); log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, rc));",
        "ins1PreCode":"return false; } if (rc <= 0) { log.error(sm.getString(\"opensslconf.failedCommand\", name, value, rc)); result = false; } else if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, rc)); } }",
        "ins2PreCode":"return false; } if (rc <= 0) { log.error(sm.getString(\"opensslconf.failedCommand\", name, value, rc)); result = false; } else if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, rc)); } }",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) chart.getPlot();",
        "ins1PreCode":"dataset.addSeries(series); JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot plot = (XYPlot) chart.getPlot(); NumberAxis axis = (NumberAxis) plot.getDomainAxis(); axis.setAutoRangeIncludesZero(false);",
        "ins2PreCode":"dataset.addSeries(series); JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot plot = (XYPlot) chart.getPlot(); NumberAxis axis = (NumberAxis) plot.getRangeAxis(); axis.setAutoRangeIncludesZero(false);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d1 = Disposable.empty(); Disposable d2 = Disposable.empty();",
        "ins1DelCode":"Disposable d1 = Disposables.empty(); Disposable d2 = Disposables.empty();",
        "ins1PreCode":"public static void doubleOnSubscribe(CompletableObserver observer) { List<Throwable> errors = trackPluginErrors(); try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty();  observer.onSubscribe(d2);",
        "ins2PreCode":"public static void doubleOnSubscribe(MaybeObserver<?> observer) { List<Throwable> errors = trackPluginErrors(); try { Disposable d1 = Disposables.empty(); observer.onSubscribe(d1); Disposable d2 = Disposables.empty(); observer.onSubscribe(d2);",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void requestZero() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() { ",
        "ins2PreCode":"public void requestNegative() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/serializecircular/CreateDB.sql\");",
        "ins1DelCode":"Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn); conn.close();",
        "ins1PreCode":"SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close();  Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn); conn.close();  return sqlSessionFactory;",
        "ins2PreCode":"sqlSessionFactory = new SqlSessionFactoryBuilder().build(batisConfigReader); batisConfigReader.close(); Connection conn = session.getConnection(); conn.close(); conn.close(); SqlSessionFactory sqlSessionFactory;",
        "label":0
    },
    {
        "ins1AddCode":"setFilled(true); setFillColor(FILL_COLOR); setLineColor(LINE_COLOR); setLineWidth(LINE_WIDTH);",
        "ins1DelCode":"",
        "ins1PreCode":"  if (bounds != null) { setLocation(bounds.x, bounds.y); }  setSuppressCalcBounds(false);  ",
        "ins2PreCode":"if (bounds != null) { setLocation(bounds.x, bounds.y); } setSuppressCalcBounds(false);",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner.withConfiguration(AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\", \"management.cloudfoundry.skip-ssl-validation:true\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block(); });",
        "ins1DelCode":"setupContextWithCloudEnabled(); TestPropertyValues.of(\"management.cloudfoundry.skip-ssl-validation:true\") .applyTo(this.context); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils.getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange().block();",
        "ins1PreCode":"public void skipSslValidation() { setupContextWithCloudEnabled(); TestPropertyValues.of(\"management.cloudfoundry.skip-ssl-validation:true\") .applyTo(this.context); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\");",
        "ins2PreCode":"public void sslValidationNotSkippedByDefault() { setupContextWithCloudEnabled(); \"cloudFoundrySecurityService\"); this.context.refresh(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\");",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void merge10000SyncStreamOf10() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(10000, 10).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1000000SyncStreamOf1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(1000000, 1).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,AUTHOR={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,file = {D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional());",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Disposable> d = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Disposable> d = new AtomicReference<Disposable>();",
        "ins1PreCode":"public void setReplace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final AtomicReference<Disposable> d = new AtomicReference<Disposable>();  Runnable r = new Runnable() {",
        "ins2PreCode":"public void setRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final AtomicReference<Disposable> d = new AtomicReference<Disposable>(); Runnable r = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"protected void doAssertLuceneQuery(HasChildQueryBuilder queryBuilder, Query query, QueryShardContext context) throws IOException { queryBuilder = (HasChildQueryBuilder) queryBuilder.rewrite(context); assertTrue(innerHitBuilders.containsKey(queryBuilder.innerHit().getName())); InnerHitContextBuilder innerHits = innerHitBuilders.get(queryBuilder.innerHit().getName()); assertEquals(innerHits.innerHitBuilder(), queryBuilder.innerHit());",
        "ins1DelCode":"protected void doAssertLuceneQuery(HasChildQueryBuilder queryBuilder, Query query, SearchContext searchContext) throws IOException { queryBuilder = (HasChildQueryBuilder) queryBuilder.rewrite(searchContext.getQueryShardContext()); final InnerHitsContext innerHitsContext = new InnerHitsContext(); for (InnerHitContextBuilder builder : innerHitBuilders.values()) { builder.build(searchContext, innerHitsContext); } assertEquals(1, innerHitsContext.getInnerHits().size()); assertTrue(innerHitsContext.getInnerHits().containsKey(queryBuilder.innerHit().getName())); InnerHitsContext.InnerHitSubContext innerHits = innerHitsContext.getInnerHits().get(queryBuilder.innerHit().getName()); assertEquals(innerHits.size(), queryBuilder.innerHit().getSize()); assertEquals(innerHits.sort().sort.getSort().length, 1); assertEquals(innerHits.sort().sort.getSort()[0].getField(), STRING_FIELD_NAME_2);",
        "ins1PreCode":"protected void doAssertLuceneQuery(HasChildQueryBuilder queryBuilder, Query query, SearchContext searchContext) throws IOException { assertThat(query, instanceOf(HasChildQueryBuilder.LateParsingQuery.class)); HasChildQueryBuilder.LateParsingQuery lpq = (HasChildQueryBuilder.LateParsingQuery) query; assertEquals(queryBuilder.minChildren(), lpq.getMinChildren()); assertEquals(queryBuilder.maxChildren(), lpq.getMaxChildren()); assertEquals(queryBuilder.scoreMode(), lpq.getScoreMode()); if (queryBuilder.innerHit() != null) {   queryBuilder = (HasChildQueryBuilder) queryBuilder.rewrite(searchContext.getQueryShardContext()); Map<String, InnerHitContextBuilder> innerHitBuilders = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(queryBuilder, innerHitBuilders); final InnerHitsContext innerHitsContext = new InnerHitsContext(); for (InnerHitContextBuilder builder : innerHitBuilders.values()) { builder.build(searchContext, innerHitsContext); } assertEquals(1, innerHitsContext.getInnerHits().size()); assertTrue(innerHitsContext.getInnerHits().containsKey(queryBuilder.innerHit().getName())); InnerHitsContext.InnerHitSubContext innerHits = innerHitsContext.getInnerHits().get(queryBuilder.innerHit().getName()); assertEquals(innerHits.size(), queryBuilder.innerHit().getSize()); assertEquals(innerHits.sort().sort.getSort().length, 1); assertEquals(innerHits.sort().sort.getSort()[0].getField(), STRING_FIELD_NAME_2); }",
        "ins2PreCode":"protected void doAssertLuceneQuery(HasParentQueryBuilder queryBuilder, Query query, SearchContext searchContext) throws IOException { assertThat(query, instanceOf(HasChildQueryBuilder.LateParsingQuery.class)); HasChildQueryBuilder.LateParsingQuery lpq = (HasChildQueryBuilder.LateParsingQuery) query; assertEquals(innerHits.size(), queryBuilder.innerHit().getSize()); assertEquals(innerHits.size(), queryBuilder.innerHit().getSize()); assertEquals(queryBuilder.score() ? ScoreMode.Max : ScoreMode.None, lpq.getScoreMode()); if (queryBuilder.innerHit() != null) { queryBuilder = (HasParentQueryBuilder) queryBuilder.rewrite(searchContext.getQueryShardContext()); Map<String, InnerHitContextBuilder> innerHitBuilders = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(queryBuilder, innerHitBuilders); final InnerHitsContext innerHitsContext = new InnerHitsContext(); for (InnerHitContextBuilder builder : innerHitBuilders.values()) { builder.build(searchContext, innerHitsContext); } assertEquals(1, innerHitsContext.getInnerHits().size()); assertTrue(innerHitsContext.getInnerHits().containsKey(queryBuilder.innerHit().getName())); InnerHitsContext.InnerHitSubContext innerHits = innerHitsContext.getInnerHits().get(queryBuilder.innerHit().getName()); assertEquals(innerHits.size(), queryBuilder.innerHit().getSize()); assertEquals(innerHits.sort().sort.getSort().length, 1); assertEquals(innerHits.sort().sort.getSort()[0].getField(), STRING_FIELD_NAME_2); }",
        "label":1
    },
    {
        "ins1AddCode":"\"vcap.application.cf_api:https://my-cloud-controller.com\")",
        "ins1DelCode":"\"vcap.application.cf_api:http://my-cloud-controller.com\")",
        "ins1PreCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(",
        "ins2PreCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(",
        "label":1
    },
    {
        "ins1AddCode":"sqlSession.selectList(\"org.apache.ibatis.submitted.nested.Mapper.simpleSelect\", parameter);",
        "ins1DelCode":"sqlSession.selectList(\"org.apache.ibatis.submitted.nested.simpleSelect\", parameter);",
        "ins1PreCode":"parameter.addName(name);  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.nested.simpleSelect\", parameter);  assertEquals(3, answer.size());",
        "ins2PreCode":"parameter.addName(name); List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.nested.nestedSelect\", parameter); assertEquals(2, answer.size());",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"Assume.assumeTrue( \"Only supported on NIO X\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Nio\"));",
        "ins1PreCode":"public void testUpgradeInternal() throws Exception { Assume.assumeTrue( \"Only supported on NIO X\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Nio\"));  UpgradeConnection uc = doUpgrade(EchoAsync.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1AddCode":"\"vcap.application.cf_api:https://my-cloud-controller.com\",",
        "ins1DelCode":"\"vcap.application.cf_api:http://my-cloud-controller.com\",",
        "ins1PreCode":"AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\", \"management.cloudfoundry.skip-ssl-validation:true\") .run((context) -> {",
        "ins2PreCode":"AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .getField(interceptor, \"cloudFoundrySecurityService\"); .run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"this.queue = new SpscLinkedArrayQueue<>(bufferSize()); this.upstream = new AtomicReference<>(); this.buffers = new LinkedHashMap<>();",
        "ins1DelCode":"this.queue = new SpscLinkedArrayQueue<C>(bufferSize()); this.upstream = new AtomicReference<Disposable>(); this.buffers = new LinkedHashMap<Long, C>();",
        "ins1PreCode":"this.bufferSupplier = bufferSupplier; this.bufferOpen = bufferOpen; this.bufferClose = bufferClose; this.queue = new SpscLinkedArrayQueue<C>(bufferSize()); this.observers = new CompositeDisposable(); this.upstream = new AtomicReference<Disposable>(); this.buffers = new LinkedHashMap<Long, C>(); this.errors = new AtomicThrowable();",
        "ins2PreCode":"this.bufferSupplier = bufferSupplier; this.bufferOpen = bufferOpen; this.bufferClose = bufferClose; this.queue = new SpscLinkedArrayQueue<C>(bufferSize()); this.subscribers = new CompositeDisposable(); this.upstream = new AtomicReference<Subscription>(); this.buffers = new LinkedHashMap<Long, C>(); this.errors = new AtomicThrowable();",
        "label":0
    },
    {
        "ins1AddCode":"void noFile(CapturedOutput output) {",
        "ins1DelCode":"public void noFile() { String output = this.output.toString().trim();",
        "ins1PreCode":"public void noFile() { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, null); this.logger.info(\"Hello world\"); String output = this.output.toString().trim(); assertThat(output).contains(\"Hello world\").doesNotContain(\"Hidden\"); assertThat(new File(tmpDir() + \"/spring.log\").exists()).isFalse();",
        "ins2PreCode":"public void noFile() { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, null); this.logger.info(\"Hello world\"); String output = this.output.toString().trim(); assertThat(output).contains(\"Hello world\").doesNotContain(\"Hidden\"); assertThat(new File(tmpDir() + \"/spring.log\").exists()).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":".reduce(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiFunction<List<Integer>, Integer, List<Integer>>() {",
        "ins2PreCode":".reduce(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiFunction<List<Integer>, Integer, List<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"final TestObservable<String> w1 = new TestObservable<>(null, okToContinueW1, \"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<>(null, okToContinueW2, \"four\", \"five\", \"six\");",
        "ins1DelCode":"final TestObservable<String> w1 = new TestObservable<String>(null, okToContinueW1, \"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(null, okToContinueW2, \"four\", \"five\", \"six\");",
        "ins1PreCode":"final CountDownLatch okToContinueW1 = new CountDownLatch(1); final CountDownLatch okToContinueW2 = new CountDownLatch(1);  final TestObservable<String> w1 = new TestObservable<String>(null, okToContinueW1, \"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(null, okToContinueW2, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber();",
        "ins2PreCode":"final CountDownLatch okToContinueW1 = new CountDownLatch(1); final CountDownLatch okToContinueW2 = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(null, okToContinueW1, \"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(null, okToContinueW2, \"four\", \"five\", \"six\"); Observer<String> observer = TestHelper.mockObserver();",
        "label":1
    },
    {
        "ins1AddCode":"false, false, false);",
        "ins1DelCode":"false, false);",
        "ins1PreCode":"Exception error = new CustomException(); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); assertThat(attributes.get(\"message\")).isEqualTo(\"\");",
        "ins2PreCode":"Exception error = new Custom2Exception(); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, true); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase()); assertThat(attributes.get(\"message\")).isEqualTo(\"Nope!\");",
        "label":0
    },
    {
        "ins1AddCode":"boolean needsScores = false; if (variable.equals(\"_score\")) { bindings.add(new SortField(\"_score\", SortField.Type.SCORE)); needsScores = true; } else if (variable.equals(\"_value\")) { needsScores |= valueSource.getSortField(false).needsScores(); return new ExpressionAggregationScript(expr, bindings, needsScores, specialValue);",
        "ins1DelCode":"if (variable.equals(\"_value\")) { return new ExpressionAggregationScript(expr, bindings, specialValue);",
        "ins1PreCode":"ReplaceableConstDoubleValueSource specialValue = null; for (String variable : expr.variables) { try { if (variable.equals(\"_value\")) { specialValue = new ReplaceableConstDoubleValueSource(); bindings.add(\"_value\", specialValue);     } else if (vars != null && vars.containsKey(variable)) { bindFromParams(vars, bindings, variable); } else {   final ValueSource valueSource = getDocValueSource(variable, lookup); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {  throw convertToScriptException(\"link error\", expr.sourceText, variable, e); } } return new ExpressionAggregationScript(expr, bindings, specialValue);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"new AsyncDeleteByQueryAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, scriptService,",
        "ins1DelCode":"new AsyncDeleteByQueryAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, scriptService, state,",
        "ins1PreCode":"ClusterState state = clusterService.state(); ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncDeleteByQueryAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, scriptService, state, listener).start(); }",
        "ins2PreCode":"ClusterState state = clusterService.state(); ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(), bulkByScrollTask); new AsyncIndexBySearchAction(bulkByScrollTask, logger, assigningClient, threadPool, this, request, state, listener).start(); }",
        "label":0
    },
    {
        "ins1AddCode":"HighLowItemLabelGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"HighLowItemLabelGenerator g2 = (HighLowItemLabelGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowItemLabelGenerator g1 = new HighLowItemLabelGenerator(); HighLowItemLabelGenerator g2 = (HighLowItemLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try ( InputStream is = source.getInputStream(); Scanner scanner = new Scanner( is ) )",
        "ins1DelCode":"Scanner scanner = null; InputStream is = null; try is = source.getInputStream(); scanner = new Scanner( is ); finally { if ( scanner != null ) { scanner.close(); } if ( is != null ) { is.close(); } }",
        "ins1PreCode":"{ URL txtFile = new File( \"target/test-classes/source.txt\" ).toURI().toURL(); UrlSource source = new UrlSource( txtFile );  Scanner scanner = null; InputStream is = null; try { is = source.getInputStream();  scanner = new Scanner( is ); assertEquals( \"Hello World!\", scanner.nextLine() ); } finally { if ( scanner != null ) { scanner.close(); } if ( is != null ) { is.close(); } }",
        "ins2PreCode":"{ File txtFile = new File( \"target/test-classes/source.txt\" ); FileSource source = new FileSource( txtFile ); Scanner scanner = null; InputStream is = null; try { is = source.getInputStream(); scanner = new Scanner( is ); assertEquals( \"Hello World!\", scanner.nextLine() ); } finally { if ( scanner != null ) { scanner.close(); } if ( is != null ) { is.close(); } }",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); assertEquals(0, parsed.size());",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "ins1PreCode":" assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "ins2PreCode":"assertTrue(result.hasWarnings()); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(0, c.size());",
        "label":1
    },
    {
        "ins1AddCode":"List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\",",
        "ins1DelCode":"List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\",",
        "ins1PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"blog_id\", 1);",
        "ins2PreCode":"public void shouldFindPostsWithAuthorIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"author_id\", 101);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(expected).hasCauseThat().isInstanceOf(SomeCheckedException.class);",
        "ins1DelCode":"assertThat(expected.getCause()).isInstanceOf(SomeCheckedException.class);",
        "ins1PreCode":"sample.noneDeclared(); fail(); } catch (RuntimeException expected) { assertThat(expected.getCause()).isInstanceOf(SomeCheckedException.class); }",
        "ins2PreCode":"sample.oneDeclared(); fail(); } catch (SomeCheckedException expected) { Throwables.propagateIfInstanceOf(t, SomeCheckedException.class); }",
        "label":0
    },
    {
        "ins1AddCode":"runTextDatasetExample(spark);",
        "ins1DelCode":"",
        "ins1PreCode":"runParquetSchemaMergingExample(spark); runJsonDatasetExample(spark); runCsvDatasetExample(spark); runJdbcDatasetExample(spark);  spark.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\");",
        "ins1PreCode":"MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4 ) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return mergeArray(source1, source2, source3, source4);",
        "ins2PreCode":"MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4) { MaybeSource<? extends T> source3, MaybeSource<? extends T> source4) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return mergeArrayDelayError(source1, source2, source3, source4);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Disposable.disposed(), s.scheduleDirect(r)); assertEquals(Disposable.disposed(), s.scheduleDirect(r, 1, TimeUnit.SECONDS)); assertEquals(Disposable.disposed(), s.schedulePeriodicallyDirect(r, 1, 1, TimeUnit.SECONDS)); assertEquals(Disposable.disposed(), w.schedule(r)); assertEquals(Disposable.disposed(), w.schedule(r, 1, TimeUnit.SECONDS)); assertEquals(Disposable.disposed(), w.schedulePeriodically(r, 1, 1, TimeUnit.SECONDS));",
        "ins1DelCode":"assertEquals(Disposables.disposed(), s.scheduleDirect(r)); assertEquals(Disposables.disposed(), s.scheduleDirect(r, 1, TimeUnit.SECONDS)); assertEquals(Disposables.disposed(), s.schedulePeriodicallyDirect(r, 1, 1, TimeUnit.SECONDS)); assertEquals(Disposables.disposed(), w.schedule(r)); assertEquals(Disposables.disposed(), w.schedule(r, 1, TimeUnit.SECONDS)); assertEquals(Disposables.disposed(), w.schedulePeriodically(r, 1, 1, TimeUnit.SECONDS));",
        "ins1PreCode":"Scheduler s = new SingleScheduler(); s.shutdown();  assertEquals(Disposables.disposed(), s.scheduleDirect(r));  assertEquals(Disposables.disposed(), s.scheduleDirect(r, 1, TimeUnit.SECONDS));  assertEquals(Disposables.disposed(), s.schedulePeriodicallyDirect(r, 1, 1, TimeUnit.SECONDS));  Worker w = s.createWorker(); ((ScheduledWorker)w).executor.shutdownNow();  assertEquals(Disposables.disposed(), w.schedule(r));  assertEquals(Disposables.disposed(), w.schedule(r, 1, TimeUnit.SECONDS));  assertEquals(Disposables.disposed(), w.schedulePeriodically(r, 1, 1, TimeUnit.SECONDS));  assertEquals(0, calls[0]);",
        "ins2PreCode":"Scheduler s = new ComputationScheduler(); s.shutdown(); assertEquals(Disposables.disposed(), s.scheduleDirect(r)); assertEquals(Disposables.disposed(), s.scheduleDirect(r, 1, TimeUnit.SECONDS)); assertEquals(Disposables.disposed(), s.schedulePeriodicallyDirect(r, 1, 1, TimeUnit.SECONDS)); Worker w = s.createWorker(); Worker w = s.createWorker(); assertEquals(Disposables.disposed(), w.schedule(r)); assertEquals(Disposables.disposed(), w.schedule(r, 1, TimeUnit.SECONDS)); assertEquals(Disposables.disposed(), w.schedulePeriodically(r, 1, 1, TimeUnit.SECONDS)); assertEquals(0, calls[0]);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty());  observer.onNext(o1);",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(o1);",
        "label":1
    },
    {
        "ins1AddCode":"URL resultUrl = result.getUrl();",
        "ins1DelCode":"URL resultUrl = result.getWebResponse().getUrl();",
        "ins1PreCode":"assertNotNull(result); j.assertGoodStatus(result);  URL resultUrl = result.getWebResponse().getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "ins2PreCode":"assertNotNull(result); j.assertGoodStatus(result); URL resultUrl = result.getWebResponse().getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "label":1
    },
    {
        "ins1AddCode":"void ignoresIfMissingSecretFromRequest() throws Exception {",
        "ins1DelCode":"public void ignoresIfMissingSecretFromRequest() throws Exception {",
        "ins1PreCode":"public void ignoresIfMissingSecretFromRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins2PreCode":"public void ignoresInvalidSecretInRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "label":1
    },
    {
        "ins1AddCode":"return sb.toString();",
        "ins1DelCode":"return (sb.toString());",
        "ins1PreCode":"public String toString() {  StringBuilder sb = new StringBuilder(\"SetNextRule[\"); sb.append(\"methodName=\"); sb.append(methodName); sb.append(\", paramType=\"); sb.append(paramType); sb.append(\"]\"); return (sb.toString()); ",
        "ins2PreCode":"public String toString() { StringBuilder sb = new StringBuilder(\"SetNextRule[\"); sb.append(\"methodName=\"); sb.append(methodName); sb.append(\", paramType=\"); sb.append(paramType); sb.append(\"]\"); return (sb.toString());",
        "label":1
    },
    {
        "ins1AddCode":"Map<EndpointId, ExposableJmxEndpoint> endpoints = discover(discoverer); assertThat(endpoints).containsOnlyKeys(EndpointId.of(\"test\")); endpoints.get(EndpointId.of(\"test\")).getOperations());",
        "ins1DelCode":"Map<String, ExposableJmxEndpoint> endpoints = discover(discoverer); assertThat(endpoints).containsOnlyKeys(\"test\"); endpoints.get(\"test\").getOperations());",
        "ins1PreCode":"public void getEndpointsWhenHasCacheWithTtlShouldCacheReadOperationWithTtlValue() { load(TestEndpoint.class, (id) -> 500L, (discoverer) -> { Map<String, ExposableJmxEndpoint> endpoints = discover(discoverer); assertThat(endpoints).containsOnlyKeys(\"test\"); Map<String, JmxOperation> operationByName = mapOperations( endpoints.get(\"test\").getOperations()); assertThat(operationByName).containsOnlyKeys(\"getAll\", \"getSomething\", \"update\", \"deleteSomething\");",
        "ins2PreCode":"public void getEndpointsShouldCacheReadOperations() { load(AdditionalOperationJmxEndpointConfiguration.class, (id) -> 500L, Map<String, ExposableJmxEndpoint> endpoints = discover(discoverer); assertThat(endpoints).containsOnlyKeys(\"test\"); Map<String, JmxOperation> operationByName = mapOperations( endpoints.get(\"test\").getOperations()); assertThat(operationByName).containsOnlyKeys(\"getAll\", \"getSomething\", \"update\", \"deleteSomething\", \"getAnother\");",
        "label":1
    },
    {
        "ins1AddCode":"if (e == null) { }",
        "ins1DelCode":"if (e == null)",
        "ins1PreCode":"for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == TreeModelListener.class) {  if (e == null) e = new TreeModelEvent(",
        "ins2PreCode":"for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == TreeModelListener.class) { if (e == null) e = new TreeModelEvent(",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset<String> ds = new XYSeriesCollection<>(series);",
        "ins1DelCode":"XYDataset ds = new XYSeriesCollection<String>(series);",
        "ins1PreCode":"for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection<String>(series); double[] result = Regression.getOLSRegression(ds, 0); ",
        "ins2PreCode":"for (int i = 0; i < 10; i++) { series.add(data[i][0], data[i][1]); } XYDataset ds = new XYSeriesCollection<String>(series); double[] result = Regression.getPowerRegression(ds, 0);",
        "label":1
    },
    {
        "ins1AddCode":"secret = new SecretKeySpec(payload,0,128/8, KEY_ALGORITHM);",
        "ins1DelCode":"secret = new SecretKeySpec(payload,0,128/8, ALGORITHM);",
        "ins1PreCode":"store(payload); }  secret = new SecretKeySpec(payload,0,128/8, ALGORITHM); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void configureShouldApplyFilter() {",
        "ins1DelCode":"public void configureShouldApplyFilter() {",
        "ins1PreCode":"public void configureShouldApplyFilter() { this.filters.add(this.mockFilter); MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(createObjectProvider(this.customizers),",
        "ins2PreCode":"public void configureShouldApplyBinder() { this.binders.add(this.mockBinder); MeterRegistryConfigurer configurer = new MeterRegistryConfigurer(createObjectProvider(this.customizers),",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"PublishProcessor<Integer> source = PublishProcessor.create(); PublishProcessor<Integer> other = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  source.delaySubscription(other).subscribe(ts);",
        "ins2PreCode":"PublishProcessor<Integer> source = PublishProcessor.create(); PublishProcessor<Integer> other = PublishProcessor.create(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); source.delaySubscription(other).subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"if(wakeUpTransferInterval > 0) { if(wakeUpTransferIntervalExpired()) { getProject().log(\"wakeUpTransferInterval is reached, trigger a data connection \" , Project.MSG_DEBUG); ftp.listFiles(file.getName()); } }",
        "ins1DelCode":"",
        "ins1PreCode":"} } } } ftp.changeToParentDirectory(); } catch (FTPConnectionClosedException ftpcce) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", ftpcce); } catch (IOException e) { throw new BuildException(\"Error while communicating with FTP \"",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE)) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testShouldFlushLocalSessionCacheOnQueryForList() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE); try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> people = personMapper.selectAllFlush(); updateDatabase(sqlSession.getConnection()); people = personMapper.selectAllFlush(); assertEquals(\"Simone\", people.get(0).getFirstName()); sqlSession.commit(); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testShouldNotFlushLocalSessionCacheOnQueryForList() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE); try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> people = personMapper.selectAllNoFlush(); updateDatabase(sqlSession.getConnection()); people = personMapper.selectAllNoFlush(); assertEquals(\"John\", people.get(0).getFirstName()); sqlSession.commit(); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"public Set<MapEntry> entrySet() { LinkedHashSet<MapEntry> set = new LinkedHashSet<MapEntry>(super.size());",
        "ins1DelCode":"public Set entrySet() { LinkedHashSet set = new LinkedHashSet(super.size());",
        "ins1PreCode":"public Set entrySet() { LinkedHashSet set = new LinkedHashSet(super.size()); Iterator i = super.entrySet().iterator(); while ( i.hasNext() ) {",
        "ins2PreCode":"public Set keySet() { LinkedHashSet set = new LinkedHashSet(super.size()); Iterator i = super.entrySet().iterator(); while ( i.hasNext() ) {",
        "label":0
    },
    {
        "ins1AddCode":"final Disposable upstream = Disposable.fromRunnable(new Runnable() {",
        "ins1DelCode":"final Disposable upstream = Disposables.fromRunnable(new Runnable() {",
        "ins1PreCode":"@Override public void subscribe(final Observer<? super Observable<Long>> observer) {  final Disposable upstream = Disposables.fromRunnable(new Runnable() { @Override public void run() {",
        "ins2PreCode":"@Override public void subscribe(final Subscriber<? super Flowable<Long>> subscriber) { new Thread(new Runnable() { @Override public void run() {",
        "label":0
    },
    {
        "ins1AddCode":"public void testGetNamesAndItems() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"public void testGetNamesAndItems() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testGetNamesAndItems() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  List<List<?>> results = spMapper.getNamesAndItems(); assertEquals(2, results.size()); assertEquals(4, results.get(0).size()); assertEquals(3, results.get(1).size()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testGetNamesAndItems_a3() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class); List<List<?>> results = spMapper.getNamesAndItemsAnnotatedWithXMLResultMapArray(); assertEquals(2, results.size()); assertEquals(4, results.get(0).size()); assertEquals(3, results.get(1).size()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1DelCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final ExasolTableColumn column = command.getObject(); ",
        "ins2PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) final DB2TableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"void verifyErrorMessageFromSelectKey() {",
        "ins1DelCode":"public void verifyErrorMessageFromSelectKey() {",
        "ins1PreCode":"public void verifyErrorMessageFromSelectKey() { try (SqlSession session = sqlSessionFactory.openSession()) { try {",
        "ins2PreCode":"public void verifyErrorMessageFromInsertAfterSelectKey() { try (SqlSession session = sqlSessionFactory.openSession()) { try {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (n == 0) { return; }",
        "ins1PreCode":"for (;;) { InnerObserver<?, ?>[] a = observers.get(); int n = a.length; if (n == 0) { return; }",
        "ins2PreCode":"for (;;) { InnerSubscriber<?, ?>[] a = subscribers.get(); int n = a.length; if (n == 0) { return; }",
        "label":0
    },
    {
        "ins1AddCode":"File appDir = new File(\"test/webapp\");",
        "ins1DelCode":"File appDir = new File(\"test/webapp-3.0\");",
        "ins1PreCode":" Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(message.getStringToInt32FieldMap(), message.getStringToInt32FieldMap()); assertEquals(message.getInt32ToBytesFieldMap(), message.getInt32ToBytesFieldMap()); assertEquals(message.getInt32ToEnumFieldMap(), message.getInt32ToEnumFieldMap()); assertEquals(message.getInt32ToEnumFieldValueMap(), message.getInt32ToEnumFieldValueMap()); assertEquals(message.getInt32ToMessageFieldMap(), message.getInt32ToMessageFieldMap());",
        "ins1DelCode":"assertEquals(message.getStringToInt32Field(), message.getStringToInt32FieldMap()); assertEquals(message.getInt32ToBytesField(), message.getInt32ToBytesFieldMap()); assertEquals(message.getInt32ToEnumField(), message.getInt32ToEnumFieldMap()); assertEquals(message.getInt32ToEnumFieldValue(), message.getInt32ToEnumFieldValueMap()); assertEquals(message.getInt32ToMessageField(), message.getInt32ToMessageFieldMap());",
        "ins1PreCode":"TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingAccessors(builder); TestMap message = builder.build(); assertEquals(message.getStringToInt32Field(), message.getStringToInt32FieldMap()); assertEquals(message.getInt32ToBytesField(), message.getInt32ToBytesFieldMap()); assertEquals(message.getInt32ToEnumField(), message.getInt32ToEnumFieldMap()); assertEquals(message.getInt32ToEnumFieldValue(), message.getInt32ToEnumFieldValueMap()); assertEquals(message.getInt32ToMessageField(), message.getInt32ToMessageFieldMap());",
        "ins2PreCode":"TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build(); assertEquals(message.getStringToInt32Field(), message.getStringToInt32FieldMap()); assertEquals(message.getInt32ToBytesField(), message.getInt32ToBytesFieldMap()); assertEquals(message.getInt32ToEnumField(), message.getInt32ToEnumFieldMap()); assertEquals(message.getInt32ToEnumField(), message.getInt32ToEnumFieldMap()); assertEquals(message.getInt32ToMessageField(), message.getInt32ToMessageFieldMap());",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs1 = Disposable.empty();",
        "ins1DelCode":"Disposable bs1 = Disposables.empty();",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1); ",
        "ins2PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { Disposable bs1 = Disposables.empty(); observer.onSubscribe(bs1);",
        "label":1
    },
    {
        "ins1AddCode":"org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository, RepositoryEvent.Builder event = new RepositoryEvent.Builder( session, EventType.METADATA_INVALID ); event.setTrace( trace ); listener.metadataInvalid( event.build() );",
        "ins1DelCode":"org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository, DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace ); listener.metadataInvalid( event );",
        "ins1PreCode":"private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception ) { RepositoryListener listener = session.getRepositoryListener(); if ( listener != null ) { DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace ); event.setMetadata( metadata ); event.setException( exception ); event.setRepository( repository ); listener.metadataInvalid( event ); }",
        "ins2PreCode":"private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception ) { RepositoryListener listener = session.getRepositoryListener(); if ( listener != null ) { DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace ); event.setMetadata( metadata ); event.setException( exception ); event.setRepository( repository ); listener.metadataInvalid( event ); }",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts); ",
        "ins2PreCode":"public void assertNotMatchValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"FileSet resultFileSet = p.getReference(RESULT_FILESET);",
        "ins1DelCode":"FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET);",
        "ins1PreCode":"public void testBasicSet() { Project p = buildRule.getProject(); buildRule.executeTarget(\"testbasicset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles();",
        "ins2PreCode":"public void testSmallSet() { Project p = buildRule.getProject(); buildRule.executeTarget(\"testsmallset\"); FileSet resultFileSet = (FileSet)p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, s1.indexOf(1.0)); assertEquals(1, s1.indexOf(3.0)); assertEquals(2, s1.indexOf(2.0));",
        "ins1DelCode":"assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(3.0))); assertEquals(2, s1.indexOf(new Double(2.0)));",
        "ins1PreCode":"s1.add(1.0, 1.0, 1.0, 2.0); s1.add(3.0, 3.0, 3.0, 3.0); s1.add(2.0, 2.0, 2.0, 2.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(3.0))); assertEquals(2, s1.indexOf(new Double(2.0)));",
        "ins2PreCode":"s1.add(1.0, 1.0, 1.0, 2.0); s1.add(3.0, 3.0, 3.0, 3.0); s1.add(2.0, 2.0, 2.0, 2.0); assertEquals(0, s1.indexOf(new Double(1.0))); assertEquals(1, s1.indexOf(new Double(3.0))); assertEquals(2, s1.indexOf(new Double(2.0)));",
        "label":1
    },
    {
        "ins1AddCode":"void testSelectLike() { assertEquals(2, answer.size()); assertEquals(4, answer.get(0).get(\"ID\")); assertEquals(6, answer.get(1).get(\"ID\"));",
        "ins1DelCode":"public void testSelectLike() { assertTrue(answer.size() == 2); assertEquals(Integer.valueOf(4), answer.get(0).get(\"ID\")); assertEquals(Integer.valueOf(6), answer.get(1).get(\"ID\"));",
        "ins1PreCode":"public void testSelectLike() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.selectLike\", \"Ba\");  assertTrue(answer.size() == 2); assertEquals(Integer.valueOf(4), answer.get(0).get(\"ID\")); assertEquals(Integer.valueOf(6), answer.get(1).get(\"ID\")); }",
        "ins2PreCode":"public void testOgnlStaticMethodCall() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.ognlStaticMethodCall\", \"Rock 'n Roll\"); assertTrue(answer.size() == 1); assertEquals(Integer.valueOf(7), answer.get(0).get(\"ID\")); assertEquals(Integer.valueOf(7), answer.get(0).get(\"ID\")); }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertResult() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void assertResult() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposable.empty());",
        "label":0
    },
    {
        "ins1AddCode":"JspCServletContext context = new JspCServletContext( null, appDir.toURI().toURL(), null, false, false);",
        "ins1DelCode":"JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null);",
        "ins1PreCode":"public void testWebapp_3_0() throws Exception { File appDir = new File(\"test/webapp-3.0\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(3, context.getEffectiveMajorVersion()); Assert.assertEquals(0, context.getEffectiveMinorVersion());",
        "ins2PreCode":"public void testWebapp_3_1() throws Exception { File appDir = new File(\"test/webapp-3.1\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(3, context.getEffectiveMajorVersion()); Assert.assertEquals(1, context.getEffectiveMinorVersion());",
        "label":1
    },
    {
        "ins1AddCode":"if (to.isDirect() && to.remaining() >= limit) {",
        "ins1DelCode":"if (to.remaining() >= limit) {",
        "ins1PreCode":"  int limit = socketBufferHandler.getReadBuffer().capacity(); if (to.remaining() >= limit) { to.limit(to.position() + limit); nRead = fillReadBuffer(block, to);",
        "ins2PreCode":"int limit = socketBufferHandler.getReadBuffer().capacity(); if (to.remaining() >= limit) { to.limit(to.position() + limit); nRead = fillReadBuffer(block, to);",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"upstream.dispose(); upstream.dispose();",
        "ins1PreCode":"} }  upstream.dispose(); downstream.onComplete(); } else { downstream.onComplete(); upstream.dispose(); disposeResource(); }",
        "ins2PreCode":"} } upstream.cancel(); downstream.onComplete(); } else { downstream.onComplete(); upstream.cancel(); disposeResource(); }",
        "label":1
    },
    {
        "ins1AddCode":"void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() {",
        "ins1DelCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() {",
        "ins1PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins2PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyObjectXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "label":1
    },
    {
        "ins1AddCode":"public final <@NonNull R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper,",
        "ins1DelCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper,",
        "ins1PreCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins2PreCode":"public final <R> Observable<R> flatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\");",
        "label":1
    },
    {
        "ins1AddCode":"new ENumeric(nextIdentifier(), location(ctx), \"1\", 10), false, operation);",
        "ins1DelCode":"new EConstant(nextIdentifier(), location(ctx), 1), false, operation);",
        "ins1PreCode":"}  return new EAssignment(nextIdentifier(), location(ctx), expression, new EConstant(nextIdentifier(), location(ctx), 1), false, operation);",
        "ins2PreCode":"} return new EAssignment(nextIdentifier(), location(ctx), expression, new EConstant(nextIdentifier(), location(ctx), 1), true, operation);",
        "label":1
    },
    {
        "ins1AddCode":"new ArrayList<String>(message.getStringToInt32FieldMap().keySet()));",
        "ins1DelCode":"new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins1PreCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet())); Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "label":1
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { actions.add(",
        "ins2PreCode":"public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { public void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { actions.add(",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset<String, String> dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"private static JFreeChart createBarChart() {  Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}}; CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createBarChart(\"Bar Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true);",
        "ins2PreCode":"private static JFreeChart createAreaChart() { Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}}; CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true);",
        "label":1
    },
    {
        "ins1AddCode":"if (ce != null) { Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) { ((SelectionClass) sel).hideButtons(); }",
        "ins1DelCode":"Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) { ((SelectionClass) sel).hideButtons();",
        "ins1PreCode":"public void translate(int dx, int dy) { super.translate(dx, dy); Editor ce = Globals.curEditor(); Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) { ((SelectionClass) sel).hideButtons();",
        "ins2PreCode":"public void translate(int dx, int dy) { super.translate(dx, dy); Editor ce = Globals.curEditor(); Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) { ((SelectionClass) sel).hideButtons();",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser.parse( new StringReader(\"@article{test,author={Ed von Test},author={Second Author},author={Third Author}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"String key = (index > 0) ? pair.substring(0, index) : pair; String value = (index > 0) ? pair.substring(index + 1) : \"\";",
        "ins1DelCode":"String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\");",
        "ins1PreCode":"Map<String, Object> map = new HashMap<>(); for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\"); map.put(key.trim(), value.trim()); }",
        "ins2PreCode":"Map<String, Object> map = new HashMap<>(); for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\"); map.put(key.trim(), value.trim()); }",
        "label":1
    },
    {
        "ins1AddCode":"List<String> fileDirectories = dbContext.getFileDirectories(StandardField.FILE, fileDirPrefs);",
        "ins1DelCode":"List<String> fileDirectories = dbContext.getFileDirectories(\"file\", fileDirPrefs);",
        "ins1PreCode":" BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabaseFile(file.toFile()); List<String> fileDirectories = dbContext.getFileDirectories(\"file\", fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()), fileDirectories);",
        "ins2PreCode":"BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabaseFile(file.toFile()); List<String> fileDirectories = dbContext.getFileDirectories(\"file\", fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()), fileDirectories);",
        "label":1
    },
    {
        "ins1AddCode":"void shouldHashCodeTriggerLazyLoading() {",
        "ins1DelCode":"public void shouldHashCodeTriggerLazyLoading() {",
        "ins1PreCode":"public void shouldHashCodeTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldEqualsTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"DefaultStatisticalCategoryDataset<String, String> dataset = new DefaultStatisticalCategoryDataset<>();",
        "ins1DelCode":"DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset();",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, \"S1\", \"C1\"); dataset.add(3.0, 4.0, \"S1\", \"C2\");",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultStatisticalCategoryDataset dataset = new DefaultStatisticalCategoryDataset(); dataset.add(1.0, 2.0, \"S1\", \"C1\"); dataset.add(3.0, 4.0, \"S1\", \"C2\");",
        "label":1
    },
    {
        "ins1AddCode":"private void testParseMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder().setI(123).build().toByteString()) .build()) .build(); TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension(TestMessageSetExtension1.messageSetExtension).getI());",
        "ins1DelCode":"private void testParseMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { int TYPE_ID_1 = TestMessageSetExtension1 .getDescriptor().getExtensions().get(0).getNumber(); RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder() .setI(123) .build().toByteString()) .build()) .build(); TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension( TestMessageSetExtension1.messageSetExtension).getI());",
        "ins1PreCode":"private void testParseMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { ExtensionRegistryLite.setEagerlyParseMessageSets(eagerParsing); ExtensionRegistry extensionRegistry = ExtensionRegistry.newInstance(); extensionRegistry.add(TestMessageSetExtension1.messageSetExtension);   int TYPE_ID_1 = TestMessageSetExtension1 .getDescriptor().getExtensions().get(0).getNumber(); RawMessageSet raw = RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder() .setI(123) .build().toByteString()) .build()) .build();  ByteString data = raw.toByteString();   TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension( TestMessageSetExtension1.messageSetExtension).getI());",
        "ins2PreCode":"private void testMergeLazyMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { ExtensionRegistryLite.setEagerlyParseMessageSets(eagerParsing); ExtensionRegistry extensionRegistry = ExtensionRegistry.newInstance(); extensionRegistry.add(TestMessageSetExtension1.messageSetExtension); int TYPE_ID_1 = TestMessageSetExtension1 .getDescriptor().getExtensions().get(0).getNumber(); RawMessageSet raw = RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder() .setI(123) .build().toByteString()) .build()) .build(); ByteString data = raw.toByteString(); TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension( TestMessageSetExtension1.messageSetExtension).getI());",
        "label":1
    },
    {
        "ins1AddCode":"public SQLServerTable getTable(DBRProgressMonitor monitor, long tableId) throws DBException { for (SQLServerTableBase table : tableCache.getAllObjects(monitor, this)) { if (table.getObjectId() == tableId && table instanceof SQLServerTable) { return (SQLServerTable) table; log.debug(\"Table '\" + tableId + \"' not found in schema \" + getName()); return null; }",
        "ins1DelCode":"private SQLServerTable getTable(DBRProgressMonitor monitor, long tableId) throws DBException { for (SQLServerTableBase table: tableCache.getAllObjects(monitor, SQLServerSchema.this)) { if (table.getObjectId() == tableId && table instanceof SQLServerTable) { return (SQLServerTable) table; } log.debug(\"Table '\" + tableId + \"' not found in schema \" + getName()); return null;",
        "ins1PreCode":"private SQLServerTable getTable(DBRProgressMonitor monitor, long tableId) throws DBException { for (SQLServerTableBase table: tableCache.getAllObjects(monitor, SQLServerSchema.this)) { if (table.getObjectId() == tableId && table instanceof SQLServerTable) { return (SQLServerTable) table;",
        "ins2PreCode":"public SQLServerTableType getTableType(DBRProgressMonitor monitor, long tableId) throws DBException { for (SQLServerTableBase table : tableCache.getAllObjects(monitor, this)) { if (table.getObjectId() == tableId && table instanceof SQLServerTableType) { return (SQLServerTableType) table;",
        "label":0
    },
    {
        "ins1AddCode":"System.out.println(\"Test completed in: \" + delta + \"ms.\");",
        "ins1DelCode":"",
        "ins1PreCode":"this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",this.datasource.getSize(),10); tearDown(); ",
        "ins2PreCode":"this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10Fair\",this.datasource.getSize(),10); tearDown();",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ, Item.BUILD)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ, Item.BUILD)",
        "ins1PreCode":"assertThat(project.getBuildByNumber(1).getLog(), not(containsString(\"echo 6\")));  CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Item.BUILD) .invokeWithArgs(\"aProject\", \"1\", \"-f\", \"-n\", Functions.isWindows() ? \"5\" : \"4\"); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Arrays.setAll(listeners, i -> mock(TomcatContextCustomizer.class));",
        "ins1DelCode":"for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatContextCustomizer.class); }",
        "ins1PreCode":"public void tomcatCustomizers() { TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatContextCustomizer.class); } factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins2PreCode":"public void tomcatListeners() { TomcatReactiveWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(LifecycleListener.class); } factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void coldReplayNoBackpressure() { Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<Integer>();  source.subscribe(to);",
        "ins2PreCode":"public void coldReplayNoBackpressure() { Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect(); TestObserverEx<Integer> to = new TestObserverEx<Integer>(); source.subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"return -1;",
        "ins1DelCode":"throw new EOFException(sm.getString(\"socket.apr.clientAbort\"));",
        "ins1PreCode":"return 0; } } else if (-result == Status.APR_EOF) { throw new EOFException(sm.getString(\"socket.apr.clientAbort\")); } else if ((OS.IS_WIN32 || OS.IS_WIN64) && (-result == Status.APR_OS_START_SYSERR + 10053)) {",
        "ins2PreCode":"return len; } } else if (nRead == -1) { throw new EOFException(); } else if (nRead == -1) { if (remaining > 0) {",
        "label":0
    },
    {
        "ins1AddCode":"String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : parentType; new ParentChildInnerHitContextBuilder(parentType, false, query, innerHitBuilder, children);",
        "ins1DelCode":"String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type; new ParentChildInnerHitContextBuilder(type, false, query, innerHitBuilder, children);",
        "ins1PreCode":"protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) { if (innerHitBuilder != null) { String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type; if (innerHits.containsKey(name)) { throw new IllegalArgumentException(\"[inner_hits] already contains an entry for key [\" + name + \"]\"); }  Map<String, InnerHitContextBuilder> children = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(query, children); InnerHitContextBuilder innerHitContextBuilder = new ParentChildInnerHitContextBuilder(type, false, query, innerHitBuilder, children); innerHits.put(name, innerHitContextBuilder); }",
        "ins2PreCode":"protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) { if (innerHitBuilder != null) { String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type; if (innerHits.containsKey(name)) { throw new IllegalArgumentException(\"[inner_hits] already contains an entry for key [\" + name + \"]\"); } Map<String, InnerHitContextBuilder> children = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(query, children); InnerHitContextBuilder innerHitContextBuilder = new ParentChildInnerHitContextBuilder(type, true, query, innerHitBuilder, children); innerHits.put(name, innerHitContextBuilder); }",
        "label":0
    },
    {
        "ins1AddCode":"return null; ObjectName oname = MBeanUtils.createObjectName(managedUser.getDomain(), user); return oname.toString(); IllegalArgumentException iae = new IllegalArgumentException( \"Cannot create object name for user [\" + username + \"]\");",
        "ins1DelCode":"return (null); ObjectName oname = MBeanUtils.createObjectName(managedUser.getDomain(), user); return (oname.toString()); IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for user [\" + username + \"]\");",
        "ins1PreCode":"public String findUser(String username) {  UserDatabase database = (UserDatabase) this.resource; User user = database.findUser(username); if (user == null) { return (null); } try { ObjectName oname = MBeanUtils.createObjectName(managedUser.getDomain(), user); return (oname.toString()); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for user [\" + username + \"]\"); iae.initCause(e); throw iae; } ",
        "ins2PreCode":"public void removeUser(String username) { UserDatabase database = (UserDatabase) this.resource; User user = database.findUser(username); if (user == null) { return; } try { iae.initCause(e); MBeanUtils.destroyMBean(user); return; } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying user [\" + username + \"] MBean\"); iae.initCause(e); throw iae; }",
        "label":0
    },
    {
        "ins1AddCode":"new GeoIpCache(1000), false);",
        "ins1DelCode":"new GeoIpCache(1000));",
        "ins1PreCode":"public void testCityWithMissingLocation() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false, new GeoIpCache(1000));  Map<String, Object> document = new HashMap<>();",
        "ins2PreCode":"public void testCountryWithMissingLocation() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-Country.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false, new GeoIpCache(1000)); Map<String, Object> document = new HashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"OHLCSeries<String> s1 = new OHLCSeries<>(\"Series 1\"); OHLCSeries<String> s2 = new OHLCSeries<>(\"Series 2\"); OHLCSeries<String> s3 = new OHLCSeries<>(\"Series 3\"); OHLCSeries<String> s4 = new OHLCSeries<>(\"Series 4\");",
        "ins1DelCode":"OHLCSeries s1 = new OHLCSeries(\"Series 1\"); OHLCSeries s2 = new OHLCSeries(\"Series 2\"); OHLCSeries s3 = new OHLCSeries(\"Series 3\"); OHLCSeries s4 = new OHLCSeries(\"Series 4\");",
        "ins1PreCode":"public void testRemoveSeries_int() { OHLCSeriesCollection c1 = new OHLCSeriesCollection(); OHLCSeries s1 = new OHLCSeries(\"Series 1\"); OHLCSeries s2 = new OHLCSeries(\"Series 2\"); OHLCSeries s3 = new OHLCSeries(\"Series 3\"); OHLCSeries s4 = new OHLCSeries(\"Series 4\"); c1.addSeries(s1); c1.addSeries(s2);",
        "ins2PreCode":"public void testRemoveSeries() { OHLCSeriesCollection c1 = new OHLCSeriesCollection(); OHLCSeries s1 = new OHLCSeries(\"Series 1\"); OHLCSeries s2 = new OHLCSeries(\"Series 2\"); OHLCSeries s3 = new OHLCSeries(\"Series 3\"); OHLCSeries s4 = new OHLCSeries(\"Series 4\"); c1.addSeries(s1); c1.addSeries(s2);",
        "label":1
    },
    {
        "ins1AddCode":"OHLCSeries s2 = CloneUtils.clone(s1);",
        "ins1DelCode":"OHLCSeries s2 = (OHLCSeries) s1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = (OHLCSeries) s1.clone(); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"foreignKey.setReferencedKey((MySQLTableConstraint) editPage.getUniqueConstraint());",
        "ins1DelCode":"foreignKey.setReferencedKey((MySQLTableUniqueKey) editPage.getUniqueConstraint());",
        "ins1PreCode":"return null; }  foreignKey.setReferencedKey((MySQLTableUniqueKey) editPage.getUniqueConstraint()); foreignKey.setDeleteRule(editPage.getOnDeleteRule()); foreignKey.setUpdateRule(editPage.getOnUpdateRule());",
        "ins2PreCode":"return null; } foreignKey.setReferencedKey((DBSEntityReferrer) editPage.getUniqueConstraint()); foreignKey.setDeleteRule(editPage.getOnDeleteRule()); foreignKey.setUpdateRule(editPage.getOnUpdateRule());",
        "label":0
    },
    {
        "ins1AddCode":"this.seriesA.add(new Year(2000), 102000); this.seriesA.add(new Year(2001), 102001); this.seriesA.add(new Year(2002), 102002); this.seriesA.add(new Year(2003), 102003); this.seriesA.add(new Year(2004), 102004); this.seriesA.add(new Year(2005), 102005); this.seriesB.add(new Year(2006), 202006); this.seriesB.add(new Year(2007), 202007); this.seriesB.add(new Year(2008), 202008); this.seriesC.add(new Year(1999), 301999); this.seriesC.add(new Year(2000), 302000); this.seriesC.add(new Year(2002), 302002);",
        "ins1DelCode":"this.seriesA.add(new Year(2000), new Integer(102000)); this.seriesA.add(new Year(2001), new Integer(102001)); this.seriesA.add(new Year(2002), new Integer(102002)); this.seriesA.add(new Year(2003), new Integer(102003)); this.seriesA.add(new Year(2004), new Integer(102004)); this.seriesA.add(new Year(2005), new Integer(102005)); this.seriesB.add(new Year(2006), new Integer(202006)); this.seriesB.add(new Year(2007), new Integer(202007)); this.seriesB.add(new Year(2008), new Integer(202008)); this.seriesC.add(new Year(1999), new Integer(301999)); this.seriesC.add(new Year(2000), new Integer(302000)); this.seriesC.add(new Year(2002), new Integer(302002));",
        "ins1PreCode":"public void setUp() { this.seriesA = new TimeSeries(\"Series A\"); this.seriesA.add(new Year(2000), new Integer(102000)); this.seriesA.add(new Year(2001), new Integer(102001)); this.seriesA.add(new Year(2002), new Integer(102002)); this.seriesA.add(new Year(2003), new Integer(102003)); this.seriesA.add(new Year(2004), new Integer(102004)); this.seriesA.add(new Year(2005), new Integer(102005));  this.seriesB = new TimeSeries(\"Series B\"); this.seriesB.add(new Year(2006), new Integer(202006)); this.seriesB.add(new Year(2007), new Integer(202007)); this.seriesB.add(new Year(2008), new Integer(202008));  this.seriesC = new TimeSeries(\"Series C\"); this.seriesC.add(new Year(1999), new Integer(301999)); this.seriesC.add(new Year(2000), new Integer(302000)); this.seriesC.add(new Year(2002), new Integer(302002));",
        "ins2PreCode":"public void setUp() { this.seriesA = new TimePeriodValues(\"Series A\"); this.seriesA.add(new Year(2000), new Integer(102000)); this.seriesA.add(new Year(2001), new Integer(102001)); this.seriesA.add(new Year(2002), new Integer(102002)); this.seriesA.add(new Year(2003), new Integer(102003)); this.seriesA.add(new Year(2004), new Integer(102004)); this.seriesA.add(new Year(2005), new Integer(102005)); this.seriesB = new TimePeriodValues(\"Series B\"); this.seriesB.add(new Year(2006), new Integer(202006)); this.seriesB.add(new Year(2007), new Integer(202007)); this.seriesB.add(new Year(2008), new Integer(202008)); this.seriesC = new TimePeriodValues(\"Series C\"); this.seriesC.add(new Year(1999), new Integer(301999)); this.seriesC.add(new Year(2000), new Integer(302000)); this.seriesC.add(new Year(2002), new Integer(302002));",
        "label":1
    },
    {
        "ins1AddCode":"prepareResponse((response) -> response.setBody(responseBody) .consumeNextWith((accessLevel) -> assertThat(accessLevel) expectRequest((request) -> {",
        "ins1DelCode":"prepareResponse(response -> response.setBody(responseBody) .consumeNextWith(accessLevel -> assertThat(accessLevel) expectRequest(request -> {",
        "ins1PreCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": true,\\\"read_basic_data\\\": true}\"; prepareResponse(response -> response.setBody(responseBody) .setHeader(\"Content-Type\", \"application/json\")); StepVerifier .create(this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeNextWith(accessLevel -> assertThat(accessLevel) .isEqualTo(AccessLevel.FULL)) .expectComplete().verify(); expectRequest(request -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)) .isEqualTo(\"bearer my-access-token\");",
        "ins2PreCode":"public void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() String responseBody = \"{\\\"read_sensitive_data\\\": false,\\\"read_basic_data\\\": true}\"; prepareResponse(response -> response.setBody(responseBody) .setHeader(\"Content-Type\", \"application/json\")); StepVerifier .create(this.securityService.getAccessLevel(\"my-access-token\", \"my-app-id\")) .consumeNextWith(accessLevel -> assertThat(accessLevel) .isEqualTo(AccessLevel.RESTRICTED)) .expectComplete().verify(); expectRequest(request -> { assertThat(request.getHeader(HttpHeaders.AUTHORIZATION)) .isEqualTo(\"bearer my-access-token\");",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(map.getInt32ToMessageFieldMap().isEmpty());",
        "ins1DelCode":"assertTrue(map.getInt32ToMessageField().isEmpty());",
        "ins1PreCode":"} catch (InvalidProtocolBufferException expected) { assertTrue(expected.getUnfinishedMessage() instanceof TestMap); map = (TestMap) expected.getUnfinishedMessage(); assertTrue(map.getInt32ToMessageField().isEmpty()); } ",
        "ins2PreCode":"} catch (InvalidProtocolBufferException expected) { assertTrue(expected.getUnfinishedMessage() instanceof TestMap); map = (TestMap) expected.getUnfinishedMessage(); assertTrue(map.getInt32ToMessageField().isEmpty()); }",
        "label":1
    }
]
