[
    {
        "ins1CurCode":"OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "ins1PreCode":"OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = (OHLCSeries) s1.clone(); assertTrue(s1 != s2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries s2 = (XYIntervalSeries) s1.clone(); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass()); assertTrue(s1.equals(s2));",
        "label":0
    },
    {
        "ins1CurCode":"public void testLoadProject13() throws Exception { ProjectFile file = new ProjectFile(\"xmi\"); XmiFilePersister persister = new XmiFilePersister(); Project project = ProjectManager.getManager().makeEmptyProject(); ProjectManager.getManager().setCurrentProject(project);  persister.doLoad(file.getFile()); ",
        "ins1PreCode":"public void testLoadProject13() throws Exception { String filename = \"/testmodels/uml13/Alittlebitofeverything.xmi\"; URL url = TestZargoFilePersister.class.getResource(filename); assertTrue(\"Unintended failure: resource to be tested is not found: \" + filename + \", converted to URL: \" + url, url != null);  XmiFilePersister persister = new XmiFilePersister();  Project project = ProjectManager.getManager().makeEmptyProject(); ProjectManager.getManager().setCurrentProject(project);  persister.doLoad(new File(url.toURI())); ",
        "ins2PreCode":"public void testLoadProject() throws Exception { testSave(); File file = new File(\"test.xmi\");  XmiFilePersister persister = new XmiFilePersister();  Project project = ProjectManager.getManager().makeEmptyProject(); ProjectManager.getManager().setCurrentProject(project);  persister.doLoad(file);  ProjectManager.getManager().removeProject(project);",
        "label":0
    },
    {
        "ins1CurCode":"}  queue = new SpscLinkedArrayQueue<>(bufferSize); ",
        "ins1PreCode":"}  queue = new SpscLinkedArrayQueue<T>(bufferSize); ",
        "ins2PreCode":"}  queue = new SpscLinkedArrayQueue<T>(bufferSize); ",
        "label":1
    },
    {
        "ins1CurCode":".assertEmpty();  assertEquals(0, calls.get());",
        "ins1PreCode":".assertEmpty();  assertEquals(1, calls.get());",
        "ins2PreCode":".assertEmpty();  assertEquals(1, calls.get());",
        "label":1
    },
    {
        "ins1CurCode":"MaybeSource<? extends T> source3, MaybeSource<? extends T> source4 ) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return mergeArray(source1, source2, source3, source4);",
        "ins1PreCode":"MaybeSource<? extends T> source3, MaybeSource<? extends T> source4 ) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return mergeArray(source1, source2, source3, source4);",
        "ins2PreCode":"MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return mergeArrayDelayError(source1, source2, source3, source4);",
        "label":1
    },
    {
        "ins1CurCode":"void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\");",
        "ins1PreCode":"public void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\");",
        "ins2PreCode":"public void containsDescendantOfWhenSourceReturnsTrueShouldReturnEmpty() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\");",
        "label":1
    },
    {
        "ins1CurCode":"void innerError(int index, Throwable ex) { if (errors.tryAddThrowableOrReport(ex)) { boolean cancelOthers = true;",
        "ins1PreCode":"void innerError(int index, Throwable ex) { if (errors.addThrowable(ex)) { boolean cancelOthers = true; if (delayError) { synchronized (this) { Object[] latest = this.latest; if (latest == null) { return; }  cancelOthers = latest[index] == null; if (cancelOthers || ++complete == latest.length) { done = true; } } } if (cancelOthers) { cancelSources(); } drain(); } else { RxJavaPlugins.onError(ex); }",
        "ins2PreCode":"void innerComplete(int index) { boolean cancelOthers = false; synchronized (this) { Object[] latest = this.latest; if (latest == null) { return; }  cancelOthers = latest[index] == null; if (cancelOthers || ++complete == latest.length) { done = true; } } if (cancelOthers) { cancelSources(); } drain();",
        "label":0
    },
    {
        "ins1CurCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); ",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); ",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); ",
        "label":1
    },
    {
        "ins1CurCode":" File appDir = new File(getBuildDirectory(), \"webapps/examples\"); org.apache.catalina.Context ctxt  = tomcat.addWebapp( null, \"/examples\", appDir.getAbsolutePath()); ctxt.addApplicationListener(WsListener.class.getName()); ",
        "ins1PreCode":" File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath()); ",
        "ins2PreCode":" File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath()); ",
        "label":1
    },
    {
        "ins1CurCode":"private static FormFillFailure _errorWithMarkup(@NonNull final String message, final FormValidation.Kind kind) { return new FormFillFailure(kind, message) { @Override public String renderHtml() { StaplerRequest req = Stapler.getCurrentRequest(); if (req == null) { return message; }  return \"<div class=\" + getKind().name().toLowerCase(Locale.ENGLISH) + \"><img src='\" + req.getContextPath() + Jenkins.RESOURCE_PATH + \"/images/none.gif' height=16 width=1>\" + message + \"</div>\"; }  @Override public String toString() { return kind + \": \" + message; } };",
        "ins1PreCode":"private static FormFillFailure _errorWithMarkup(@NonNull final String message, final FormValidation.Kind kind) { return new FormFillFailure(kind, message) { public String renderHtml() { StaplerRequest req = Stapler.getCurrentRequest(); if (req == null) { return message; }  return \"<div class=\" + getKind().name().toLowerCase(Locale.ENGLISH) + \"><img src='\" + req.getContextPath() + Jenkins.RESOURCE_PATH + \"/images/none.gif' height=16 width=1>\" + message + \"</div>\"; }  @Override public String toString() { return kind + \": \" + message; } };",
        "ins2PreCode":"return ok(); return new FormValidation(kind, message) { public String renderHtml() { StaplerRequest req = Stapler.getCurrentRequest();",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> ambArray(@NonNull Publisher<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T> Flowable<T> ambArray(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T> Observable<T> ambArray(@NonNull ObservableSource<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "label":0
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_13: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[34] = jj_gen; break label_13; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[35] = jj_gen; ;",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_11: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[33] = jj_gen; break label_11; }",
        "ins2PreCode":"case IDENTIFIER: Expression(); label_12: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[35] = jj_gen; break label_12; }",
        "label":1
    },
    {
        "ins1CurCode":"Observer<? super R> downstream = this.downstream; ErrorMode errorMode = this.errorMode; SimpleQueue<T> queue = this.queue; AtomicThrowable errors = this.errors;  for (;;) {  for (;;) { if (disposed) { queue.clear(); item = null; break; }  int s = state;  if (errors.get() != null) { if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) { queue.clear(); item = null; errors.tryTerminateConsumer(downstream); return; } }  if (s == STATE_INACTIVE) { boolean d = done; T v;  try { v = queue.poll(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); disposed = true; upstream.dispose();",
        "ins1PreCode":"Observer<? super R> downstream = this.downstream; ErrorMode errorMode = this.errorMode; SimplePlainQueue<T> queue = this.queue; AtomicThrowable errors = this.errors;  for (;;) {  for (;;) { if (cancelled) { queue.clear(); item = null; break; }  int s = state;  if (errors.get() != null) { if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) { queue.clear(); item = null; errors.tryTerminateConsumer(downstream); return; } }  if (s == STATE_INACTIVE) { boolean d = done; T v = queue.poll(); boolean empty = v == null;",
        "ins2PreCode":"Observer<? super R> downstream = this.downstream; ErrorMode errorMode = this.errorMode; SimplePlainQueue<T> queue = this.queue; AtomicThrowable errors = this.errors;  for (;;) {  for (;;) { if (cancelled) { queue.clear(); item = null; break; }  int s = state;  if (errors.get() != null) { if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) { queue.clear(); item = null; errors.tryTerminateConsumer(downstream); return; } }  if (s == STATE_INACTIVE) { boolean d = done; T v = queue.poll(); boolean empty = v == null;",
        "label":1
    },
    {
        "ins1CurCode":" stream.defaultReadObject(); this.domainGridlineStroke = SerialUtils.readStroke(stream); this.domainGridlinePaint = SerialUtils.readPaint(stream); this.rangeGridlineStroke = SerialUtils.readStroke(stream); this.rangeGridlinePaint = SerialUtils.readPaint(stream); this.domainMinorGridlineStroke = SerialUtils.readStroke(stream); this.domainMinorGridlinePaint = SerialUtils.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtils.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtils.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtils.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtils.readPaint(stream); this.domainCrosshairStroke = SerialUtils.readStroke(stream); this.domainCrosshairPaint = SerialUtils.readPaint(stream); this.rangeCrosshairStroke = SerialUtils.readStroke(stream); this.rangeCrosshairPaint = SerialUtils.readPaint(stream); this.domainTickBandPaint = SerialUtils.readPaint(stream); this.rangeTickBandPaint = SerialUtils.readPaint(stream); this.quadrantOrigin = SerialUtils.readPoint2D(stream); this.quadrantPaint = new Paint[4]; for (int i = 0; i < 4; i++) { this.quadrantPaint[i] = SerialUtils.readPaint(stream); }  this.domainZeroBaselineStroke = SerialUtils.readStroke(stream); this.domainZeroBaselinePaint = SerialUtils.readPaint(stream); ",
        "ins1PreCode":" stream.defaultReadObject(); this.domainGridlineStroke = SerialUtilities.readStroke(stream); this.domainGridlinePaint = SerialUtilities.readPaint(stream); this.rangeGridlineStroke = SerialUtilities.readStroke(stream); this.rangeGridlinePaint = SerialUtilities.readPaint(stream); this.domainMinorGridlineStroke = SerialUtilities.readStroke(stream); this.domainMinorGridlinePaint = SerialUtilities.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream); this.domainCrosshairStroke = SerialUtilities.readStroke(stream); this.domainCrosshairPaint = SerialUtilities.readPaint(stream); this.rangeCrosshairStroke = SerialUtilities.readStroke(stream); this.rangeCrosshairPaint = SerialUtilities.readPaint(stream); this.domainTickBandPaint = SerialUtilities.readPaint(stream); this.rangeTickBandPaint = SerialUtilities.readPaint(stream); this.quadrantOrigin = SerialUtilities.readPoint2D(stream); this.quadrantPaint = new Paint[4]; for (int i = 0; i < 4; i++) { this.quadrantPaint[i] = SerialUtilities.readPaint(stream); }  this.domainZeroBaselineStroke = SerialUtilities.readStroke(stream); this.domainZeroBaselinePaint = SerialUtilities.readPaint(stream); ",
        "ins2PreCode":" stream.defaultReadObject(); this.domainGridlineStroke = SerialUtilities.readStroke(stream); this.domainGridlinePaint = SerialUtilities.readPaint(stream); this.rangeGridlineStroke = SerialUtilities.readStroke(stream); this.rangeGridlinePaint = SerialUtilities.readPaint(stream); this.rangeCrosshairStroke = SerialUtilities.readStroke(stream); this.rangeCrosshairPaint = SerialUtilities.readPaint(stream); this.domainCrosshairStroke = SerialUtilities.readStroke(stream); this.domainCrosshairPaint = SerialUtilities.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtilities.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtilities.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtilities.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtilities.readPaint(stream); ",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposable.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposable.empty(); ",
        "ins1PreCode":"protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "ins2PreCode":"protected void subscribeActual(Observer<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"(sm.getString(\"managerServlet.startFailed\", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getServletContext().log",
        "ins1PreCode":"(sm.getString(\"managerServlet.startFailed\", displayPath)); } catch (Throwable t) { getServletContext().log (sm.getString(\"managerServlet.startFailed\", displayPath), t);",
        "ins2PreCode":"writer.println(sm.getString(\"managerServlet.stopped\", displayPath)); } catch (Throwable t) { log(\"ManagerServlet.stop[\" + displayPath + \"]\", t); writer.println(sm.getString(\"managerServlet.exception\",",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 43; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(client.isResponse200());",
        "ins1PreCode":"  assertTrue(client.isResponse200());",
        "ins2PreCode":"  assertTrue(client.isResponse200());",
        "label":1
    },
    {
        "ins1CurCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) { return; }",
        "ins1PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target);",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target);",
        "label":1
    },
    {
        "ins1CurCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');",
        "ins1PreCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a');   assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a');",
        "ins2PreCode":"public void forTree_breadthFirst_iterableIsLazy() { RequestSavingGraph graph = new RequestSavingGraph(TREE); Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('h');  assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');",
        "label":0
    },
    {
        "ins1CurCode":"byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); }",
        "ins1PreCode":" Assert.assertEquals( HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));  hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); }",
        "ins2PreCode":"public void randomizedStressTestBytes() { int size = 65536; Random rand = new Random();   Set<Integer> hashcodes = new HashSet<>(); for (int i = 0; i < size; i++) { int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes);  Assert.assertEquals( hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));  hashcodes.add(hasher.hashUnsafeWords( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); }   Assert.assertTrue(hashcodes.size() > size * 0.95);",
        "label":0
    },
    {
        "ins1CurCode":" try { testAvailability(\"java.util.regex.Matcher\"); return createRegexpInstance(\"org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp\"); } catch (BuildException be) {}  try { testAvailability(\"org.apache.oro.text.regex.Pattern\"); return createRegexpInstance(\"org.apache.tools.ant.util.regexp.JakartaOroRegexp\"); } catch (BuildException be) {}  try { testAvailability(\"org.apache.regexp.RE\"); return createRegexpInstance(\"org.apache.tools.ant.util.regexp.JakartaRegexpRegexp\");",
        "ins1PreCode":" try { return createRegexpInstance(\"org.apache.tools.ant.util.regexp.Jdk14RegexpRegexp\"); } catch (BuildException be) {}  try { return createRegexpInstance(\"org.apache.tools.ant.util.regexp.JakartaOroRegexp\"); } catch (BuildException be) {}  try { return createRegexpInstance(\"org.apache.tools.ant.util.regexp.JakartaRegexpRegexp\"); } catch (BuildException be) {}  throw new BuildException(\"No supported regular expression matcher found\");",
        "ins2PreCode":" try { return createInstance(\"org.apache.tools.ant.util.regexp.Jdk14RegexpMatcher\"); } catch (BuildException be) {}  try { return createInstance(\"org.apache.tools.ant.util.regexp.JakartaOroMatcher\"); } catch (BuildException be) {}  try { return createInstance(\"org.apache.tools.ant.util.regexp.JakartaRegexpMatcher\"); } catch (BuildException be) {}  throw new BuildException(\"No supported regular expression matcher found\");",
        "label":1
    },
    {
        "ins1CurCode":"public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userBooleanConstantNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userBooleanConstantNode, ValueType.class).getValueType());",
        "ins1PreCode":"public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userBooleanConstantNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userBooleanConstantNode, ValueType.class).getValueType());",
        "ins2PreCode":"public void visitNumeric(ENumeric userNumericNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userNumericNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType());",
        "label":1
    },
    {
        "ins1CurCode":"configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);",
        "ins1PreCode":"configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);",
        "ins2PreCode":"configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE);",
        "label":1
    },
    {
        "ins1CurCode":"Author updated; try { original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "ins1PreCode":"Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "ins2PreCode":"Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); original.setBio(null); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthorIfNecessary\", original);  updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"servlet\", new PathParamServlet()); ctx.addServletMappingDecoded(\"/\", \"servlet\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"servlet\", new PathParamServlet()); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"errorServlet\", new ErrorServlet()); ctx.addServletMapping(\"/\", \"errorServlet\"); ",
        "label":1
    },
    {
        "ins1CurCode":"protected SendfileState processSendfile(SendfileData sendfile) { if (sendfile != null) { try { try (FileChannel channel = FileChannel.open(sendfile.path, StandardOpenOption.READ)) { sendfile.mappedBuffer = channel.map(MapMode.READ_ONLY, sendfile.pos, sendfile.end - sendfile.pos); }  int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation  = sendfile.stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation); } catch (IOException e) { return SendfileState.ERROR; }  int frameSize = Integer.min(getMaxFrameSize(), sendfile.connectionReservation); boolean finished = (frameSize == sendfile.left) && sendfile.stream.getCoyoteResponse().getTrailerFields() == null;   boolean writeable = sendfile.stream.canWrite(); byte[] header = new byte[9]; ByteUtil.setThreeBytes(header, 0, frameSize); header[3] = FrameType.DATA.getIdByte(); if (finished) { header[4] = FLAG_END_OF_STREAM; sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } } if (writeable) { ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue()); sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize);",
        "ins1PreCode":"protected SendfileState processSendfile(Stream stream) { String fileName = (String) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILENAME_ATTR); if (fileName != null) { java.nio.file.Path path = new File(fileName).toPath(); SendfileData sendfile = new SendfileData(); sendfile.pos = ((Long) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILE_START_ATTR)).longValue(); sendfile.end = ((Long) stream.getCoyoteRequest().getAttribute( org.apache.coyote.Constants.SENDFILE_FILE_END_ATTR)).longValue(); sendfile.left = sendfile.end - sendfile.pos; try { try (FileChannel channel = FileChannel.open(path, StandardOpenOption.READ)) { sendfile.mappedBuffer = channel.map(MapMode.READ_ONLY, sendfile.pos, sendfile.end - sendfile.pos); sendfile.stream = stream; }  int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation  = stream.reserveWindowSize(reservation, true); sendfile.connectionReservation = reserveWindowSize(stream, sendfile.streamReservation); } catch (IOException e) { return SendfileState.ERROR; }  int frameSize = Integer.min(getMaxFrameSize(), sendfile.connectionReservation); boolean finished = (frameSize == sendfile.left) && stream.getCoyoteResponse().getTrailerFields() == null;   boolean writeable = stream.canWrite(); byte[] header = new byte[9]; ByteUtil.setThreeBytes(header, 0, frameSize); header[3] = FrameType.DATA.getIdByte(); if (finished) { header[4] = FLAG_END_OF_STREAM; stream.sentEndOfStream(); if (!stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } } if (writeable) { ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue()); sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize);",
        "ins2PreCode":"public void completed(Long nBytes, SendfileData sendfile) { long bytesWritten = nBytes.longValue() - 9; sendfile.left -= bytesWritten; if (sendfile.left == 0) { try { sendfile.stream.getOutputBuffer().close(); } catch (IOException e) { failed(e, sendfile); } return; } sendfile.streamReservation -= bytesWritten; sendfile.connectionReservation -= bytesWritten; sendfile.pos += bytesWritten; try { if (sendfile.connectionReservation == 0) { if (sendfile.streamReservation == 0) { int reservation = (sendfile.end - sendfile.pos > Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int) (sendfile.end - sendfile.pos); sendfile.streamReservation = sendfile.stream.reserveWindowSize(reservation, true); } sendfile.connectionReservation = reserveWindowSize(sendfile.stream, sendfile.streamReservation); } } catch (IOException e) { failed (e, sendfile); return; } int frameSize = Integer.min(getMaxFrameSize(), sendfile.streamReservation); boolean finished = (frameSize == sendfile.left) && sendfile.stream.getCoyoteResponse().getTrailerFields() == null;   boolean writeable = sendfile.stream.canWrite(); byte[] header = new byte[9]; ByteUtil.setThreeBytes(header, 0, frameSize); header[3] = FrameType.DATA.getIdByte(); if (finished) { header[4] = FLAG_END_OF_STREAM; sendfile.stream.sentEndOfStream(); if (!sendfile.stream.isActive()) { activeRemoteStreamCount.decrementAndGet(); } } if (writeable) { ByteUtil.set31Bits(header, 5, sendfile.stream.getIdentifier().intValue()); sendfile.mappedBuffer.limit(sendfile.mappedBuffer.position() + frameSize); socketWrapper.write(BlockingMode.SEMI_BLOCK, protocol.getWriteTimeout(), TimeUnit.MILLISECONDS, sendfile, COMPLETE_WRITE_WITH_COMPLETION, this, ByteBuffer.wrap(header), sendfile.mappedBuffer); try { handleAsyncException(); } catch (IOException e) { failed(e, sendfile); } }",
        "label":0
    },
    {
        "ins1CurCode":"ViewerColumnController columnController = new ViewerColumnController(\"sqlTaskScriptViewer\", viewer); columnController.setForceAutoSize(true); columnController.addColumn(ModelMessages.model_navigator_Name, DTUIMessages.sql_script_task_selector_dialog_column_description_script, SWT.LEFT, true, true, new ColumnLabelProvider() { @Override public String getText(Object element) { return mainLabelProvider.getText(element); } @Override public Image getImage(Object element) { return mainLabelProvider.getImage(element); } @Override public String getToolTipText(Object element) { if (mainLabelProvider instanceof IToolTipProvider) { return ((IToolTipProvider) mainLabelProvider).getToolTipText(element); } return null; } });  columnController.addColumn(ModelMessages.model_navigator_Connection, DTUIMessages.sql_script_task_selector_dialog_column_description_script_data_source, SWT.LEFT, true, true, new ColumnLabelProvider() { @Override",
        "ins1PreCode":"ViewerColumnController columnController = new ViewerColumnController(\"sqlTaskScriptViewer\", viewer); columnController.setForceAutoSize(true); columnController.addColumn(ModelMessages.model_navigator_Name, \"Script\", SWT.LEFT, true, true, new ColumnLabelProvider() { @Override public String getText(Object element) { return mainLabelProvider.getText(element); } @Override public Image getImage(Object element) { return mainLabelProvider.getImage(element); } @Override public String getToolTipText(Object element) { if (mainLabelProvider instanceof IToolTipProvider) { return ((IToolTipProvider) mainLabelProvider).getToolTipText(element); } return null; } });  columnController.addColumn(ModelMessages.model_navigator_Connection, \"Script datasource\", SWT.LEFT, true, true, new ColumnLabelProvider() { @Override",
        "ins2PreCode":"ViewerColumnController columnController = new ViewerColumnController(\"sqlTaskScriptViewer\", viewer); columnController.setForceAutoSize(true); columnController.addColumn(ModelMessages.model_navigator_Name, \"Script\", SWT.LEFT, true, true, new ColumnLabelProvider() { @Override public String getText(Object element) { return mainLabelProvider.getText(element); } @Override public Image getImage(Object element) { return mainLabelProvider.getImage(element); } @Override public String getToolTipText(Object element) { if (mainLabelProvider instanceof IToolTipProvider) { return ((IToolTipProvider) mainLabelProvider).getToolTipText(element); } return null; } });  columnController.addColumn(ModelMessages.model_navigator_Connection, \"Script datasource\", SWT.LEFT, true, true, new ColumnLabelProvider() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"void allHikariDataSourcesCanBeInstrumented() { this.contextRunner.withUserConfiguration(TwoHikariDataSourcesConfiguration.class)",
        "ins1PreCode":"public void allHikariDataSourcesCanBeInstrumented() { this.contextRunner.withUserConfiguration(TwoHikariDataSourcesConfiguration.class)",
        "ins2PreCode":"public void hikariProxiedDataSourceCanBeInstrumented() { this.contextRunner.withUserConfiguration(ProxiedHikariDataSourcesConfiguration.class)",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(1); } }, true, 16, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"return Flowable.just(1); } }, 16, true, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"return Flowable.just(1); } }, 16, true) .test()",
        "label":0
    },
    {
        "ins1CurCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {",
        "ins1PreCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {",
        "ins2PreCode":"public void testAlternateExcludeInclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setExcludes(new String[] {",
        "label":1
    },
    {
        "ins1CurCode":"public void testAncestorAfterQueryingParents() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "ins1PreCode":"public void testAncestorAfterQueryingParents() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person expectedAncestor = personMapper.selectById(1); Person person = personMapper.selectById(3);  Assert.assertNotNull(\"Persons must not be null\", person); Assert.assertNotNull(\"Parent must not be null\", person.getParent()); Assert.assertNotNull(\"Grandparent must not be null\", person.getParent().getParent()); Assert.assertEquals(\"Ancestor must be John Smith sr.\", expectedAncestor, person.getAncestor()); sqlSession.close();",
        "ins2PreCode":"public void testAncestorAfterQueryingParents() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person expectedAncestor = personMapper.selectById(1); Person person = personMapper.selectById(3);  Assert.assertNotNull(\"Persons must not be null\", person); Assert.assertNotNull(\"Parent must not be null\", person.getParent()); Assert.assertNotNull(\"Grandparent must not be null\", person.getParent().getParent()); Assert.assertEquals(\"Ancestor must be John Smith sr.\", expectedAncestor, person.getAncestor()); sqlSession.close();",
        "label":1
    },
    {
        "ins1CurCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");",
        "ins1PreCode":"public final <R> Observable<R> flatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean delayErrors, int maxConcurrency, int bufferSize) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(maxConcurrency, \"maxConcurrency\");",
        "ins2PreCode":"public final <R> Observable<R> switchMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":1
    },
    {
        "ins1CurCode":" NioTcpServer acceptor = new NioTcpServer(); acceptor.setFilters(new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new DummyHttpSever());",
        "ins1PreCode":" NioTcpServer acceptor = new NioTcpServer(); acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"), new DummyHttpSever());",
        "ins2PreCode":"public static void main(String[] args) throws Exception {  NioTcpServer acceptor = new NioTcpServer();  acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"), new DummyHttpSever());  acceptor.getSessionConfig().setTcpNoDelay(true);   acceptor.getSessionConfig().setSslContext(BogusSslContextFactory.getInstance(true));  acceptor.bind(new InetSocketAddress(8080));   Thread.sleep(20000); acceptor.unbind(); ",
        "label":0
    },
    {
        "ins1CurCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), false); final TaskMemoryManager memoryManager =",
        "ins1PreCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.memory.offHeap.enabled\", \"false\"); final TaskMemoryManager memoryManager =",
        "ins2PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"true\") .set(\"spark.memory.offHeap.size\", \"10000\"); final TaskMemoryManager memoryManager =",
        "label":0
    },
    {
        "ins1CurCode":"void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, JdbcType.BIGINT, ProductIdTypeHandler.class);",
        "ins1PreCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, JdbcType.BIGINT, ProductIdTypeHandler.class);",
        "ins2PreCode":"public void shouldPickHandlerForNull() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, null, ConstantProductIdTypeHandler.class);",
        "label":1
    },
    {
        "ins1CurCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); ",
        "ins2PreCode":"@Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void visitNumeric(ENumeric userNumericNode, ScriptScope scriptScope) { Class<?> valueType = scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType(); Object constant = scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant();  ConstantNode irConstantNode = new ConstantNode(userNumericNode.getLocation()); irConstantNode.attachDecoration(new IRDExpressionType(valueType)); irConstantNode.setConstant(constant); ",
        "ins1PreCode":"public void visitNumeric(ENumeric userNumericNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userNumericNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant()); ",
        "ins2PreCode":"public void visitDecimal(EDecimal userDecimalNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userDecimalNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userDecimalNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userDecimalNode, StandardConstant.class).getStandardConstant()); ",
        "label":1
    },
    {
        "ins1CurCode":"public RestTemplateBuilder messageConverters(Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, setOf(messageConverters), this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "ins1PreCode":"public RestTemplateBuilder messageConverters(Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, Collections.unmodifiableSet(new LinkedHashSet<HttpMessageConverter<?>>(messageConverters)), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins2PreCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "label":1
    },
    {
        "ins1CurCode":"}  assertEquals( \"Concatenated string must be equal to literal string\", literalString, concatenatedString); assertEquals( \"Concatenated string must have same hashcode as literal string\", literalString.hashCode(), concatenatedString.hashCode());",
        "ins1PreCode":"}  assertTrue(\"Concatenated string must be equal to literal string\", concatenatedString.equals(literalString)); assertEquals(\"Concatenated string must have same hashcode as literal string\", literalString.hashCode(), concatenatedString.hashCode());",
        "ins2PreCode":"public void testConcat() { byte[] referenceBytes = getTestBytes(77748, 113344L); ByteString literalString = ByteString.copyFrom(referenceBytes);  List<ByteString> pieces = makeConcretePieces(referenceBytes);  Iterator<ByteString> iter = pieces.iterator(); ByteString concatenatedString = iter.next(); while (iter.hasNext()) { concatenatedString = concatenatedString.concat(iter.next()); }  assertTrue(\"Concatenated string must be equal to literal string\", concatenatedString.equals(literalString)); assertEquals(\"Concatenated string must have same hashcode as literal string\", literalString.hashCode(), concatenatedString.hashCode());",
        "label":0
    },
    {
        "ins1CurCode":"public void testSerialization() { TaskSeries<String> s1 = new TaskSeries<>(\"Series\"); s1.add(new Task(\"Task 1\", new Date(0L), new Date(1L))); TaskSeriesCollection u1 = new TaskSeriesCollection(); u1.add(s1); SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset( u1, 0, 5); SlidingGanttCategoryDataset d2 = TestUtils.serialised(d1); assertEquals(d1, d2);   s1.add(new Task(\"Task 2\", new Date(10L), new Date(11L))); assertFalse(d1.equals(d2)); TaskSeriesCollection u2 = (TaskSeriesCollection) d2.getUnderlyingDataset(); TaskSeries<String> s2 = u2.getSeries(\"Series\"); s2.add(new Task(\"Task 2\", new Date(10L), new Date(11L)));",
        "ins1PreCode":"public void testSerialization() { TaskSeries s1 = new TaskSeries(\"Series\"); s1.add(new Task(\"Task 1\", new Date(0L), new Date(1L))); TaskSeriesCollection u1 = new TaskSeriesCollection(); u1.add(s1); SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset( u1, 0, 5); SlidingGanttCategoryDataset d2 = (SlidingGanttCategoryDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   s1.add(new Task(\"Task 2\", new Date(10L), new Date(11L))); assertFalse(d1.equals(d2)); TaskSeriesCollection u2 = (TaskSeriesCollection) d2.getUnderlyingDataset(); TaskSeries s2 = u2.getSeries(\"Series\"); s2.add(new Task(\"Task 2\", new Date(10L), new Date(11L)));",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { TaskSeries s1 = new TaskSeries(\"Series\"); s1.add(new Task(\"Task 1\", new Date(0L), new Date(1L))); TaskSeriesCollection u1 = new TaskSeriesCollection(); u1.add(s1); SlidingGanttCategoryDataset d1 = new SlidingGanttCategoryDataset( u1, 0, 5); SlidingGanttCategoryDataset d2 = (SlidingGanttCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   s1.add(new Task(\"Task 2\", new Date(10L), new Date(11L))); assertFalse(d1.equals(d2)); TaskSeriesCollection u2 = (TaskSeriesCollection) d2.getUnderlyingDataset(); TaskSeries s2 = u2.getSeries(\"Series\"); s2.add(new Task(\"Task 2\", new Date(10L), new Date(11L)));",
        "label":0
    },
    {
        "ins1CurCode":"Statement.RETURN_GENERATED_KEYS)) {  preparedEntryStatement.setString(1, bibEntry.getType().getName()); preparedEntryStatement.executeUpdate();",
        "ins1PreCode":"Statement.RETURN_GENERATED_KEYS)) {  preparedEntryStatement.setString(1, bibEntry.getType()); preparedEntryStatement.executeUpdate();",
        "ins2PreCode":"new String[] {\"SHARED_ID\"})) {  preparedEntryStatement.setString(1, bibEntry.getType()); preparedEntryStatement.executeUpdate();",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {1, 2}); plot.mapDatasetToDomainAxes(0, axisIndices);",
        "ins1PreCode":"assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToDomainAxes(0, axisIndices);",
        "ins2PreCode":"assertEquals(yAxis2, plot.getRangeAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToRangeAxes(0, axisIndices);",
        "label":1
    },
    {
        "ins1CurCode":"  Context ctx = tomcat.addContext(\"\", null); ",
        "ins1PreCode":"  File docBase = new File(System.getProperty(\"java.io.tmpdir\"));  Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath()); ",
        "ins2PreCode":"  File docBase = new File(System.getProperty(\"java.io.tmpdir\"));  Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath()); ",
        "label":1
    },
    {
        "ins1CurCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  final TestObservable<String> o1 = new TestObservable<>(\"one\", \"two\", \"three\"); final TestObservable<String> o2 = new TestObservable<>(\"four\", \"five\", \"six\"); final TestObservable<String> o3 = new TestObservable<>(\"seven\", \"eight\", \"nine\"); final CountDownLatch allowThird = new CountDownLatch(1);  final AtomicReference<Thread> parent = new AtomicReference<>(); final CountDownLatch parentHasStarted = new CountDownLatch(1);",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  final TestObservable<String> o1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> o2 = new TestObservable<String>(\"four\", \"five\", \"six\"); final TestObservable<String> o3 = new TestObservable<String>(\"seven\", \"eight\", \"nine\"); final CountDownLatch allowThird = new CountDownLatch(1);  final AtomicReference<Thread> parent = new AtomicReference<Thread>(); final CountDownLatch parentHasStarted = new CountDownLatch(1);",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver();  final TestObservable<String> o1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> o2 = new TestObservable<String>(\"four\", \"five\", \"six\"); final TestObservable<String> o3 = new TestObservable<String>(\"seven\", \"eight\", \"nine\"); final CountDownLatch allowThird = new CountDownLatch(1);  final AtomicReference<Thread> parent = new AtomicReference<Thread>(); final CountDownLatch parentHasStarted = new CountDownLatch(1);",
        "label":1
    },
    {
        "ins1CurCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super TRight, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( Publisher<? extends TRight> other, Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, BiFunction<? super T, ? super TRight, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins2PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> join( ObservableSource<? extends TRight> other, Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd, Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd, BiFunction<? super T, ? super TRight, ? extends R> resultSelector ) {",
        "label":1
    },
    {
        "ins1CurCode":"{ PomTestWrapper pom = buildPom( \"url-inheritance/sub\" ); assertEquals( \"https://parent.url/child\", pom.getValue( \"url\" ) ); assertEquals( \"https://parent.url/org\", pom.getValue( \"organization/url\" ) ); assertEquals( \"https://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) ); assertEquals( \"https://parent.url/viewvc/child\", pom.getValue( \"scm/url\" ) ); assertEquals( \"https://parent.url/scm/child\", pom.getValue( \"scm/connection\" ) ); assertEquals( \"https://parent.url/scm/child\", pom.getValue( \"scm/developerConnection\" ) ); assertEquals( \"https://parent.url/issues\", pom.getValue( \"issueManagement/url\" ) ); assertEquals( \"https://parent.url/ci\", pom.getValue( \"ciManagement/url\" ) ); assertEquals( \"https://parent.url/dist\", pom.getValue( \"distributionManagement/repository/url\" ) ); assertEquals( \"https://parent.url/snaps\", pom.getValue( \"distributionManagement/snapshotRepository/url\" ) ); assertEquals( \"https://parent.url/site/child\", pom.getValue( \"distributionManagement/site/url\" ) ); assertEquals( \"https://parent.url/download\", pom.getValue( \"distributionManagement/downloadUrl\" ) );",
        "ins1PreCode":"{ PomTestWrapper pom = buildPom( \"url-inheritance/sub\" ); assertEquals( \"http://parent.url/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) ); assertEquals( \"http://parent.url/viewvc/child\", pom.getValue( \"scm/url\" ) ); assertEquals( \"http://parent.url/scm/child\", pom.getValue( \"scm/connection\" ) ); assertEquals( \"https://parent.url/scm/child\", pom.getValue( \"scm/developerConnection\" ) ); assertEquals( \"http://parent.url/issues\", pom.getValue( \"issueManagement/url\" ) ); assertEquals( \"http://parent.url/ci\", pom.getValue( \"ciManagement/url\" ) ); assertEquals( \"http://parent.url/dist\", pom.getValue( \"distributionManagement/repository/url\" ) ); assertEquals( \"http://parent.url/snaps\", pom.getValue( \"distributionManagement/snapshotRepository/url\" ) ); assertEquals( \"http://parent.url/site/child\", pom.getValue( \"distributionManagement/site/url\" ) ); assertEquals( \"http://parent.url/download\", pom.getValue( \"distributionManagement/downloadUrl\" ) );",
        "ins2PreCode":"{ PomTestWrapper pom = buildPom( \"url-inheritance/another-parent/sub\" ); assertEquals( \"http://parent.url/ap/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) ); assertEquals( \"http://parent.url/viewvc/ap/child\", pom.getValue( \"scm/url\" ) ); assertEquals( \"http://parent.url/scm/ap/child\", pom.getValue( \"scm/connection\" ) ); assertEquals( \"https://parent.url/scm/ap/child\", pom.getValue( \"scm/developerConnection\" ) ); assertEquals( \"http://parent.url/issues\", pom.getValue( \"issueManagement/url\" ) ); assertEquals( \"http://parent.url/ci\", pom.getValue( \"ciManagement/url\" ) ); assertEquals( \"http://parent.url/dist\", pom.getValue( \"distributionManagement/repository/url\" ) ); assertEquals( \"http://parent.url/snaps\", pom.getValue( \"distributionManagement/snapshotRepository/url\" ) ); assertEquals( \"http://parent.url/site/ap/child\", pom.getValue( \"distributionManagement/site/url\" ) ); assertEquals( \"http://parent.url/download\", pom.getValue( \"distributionManagement/downloadUrl\" ) );",
        "label":1
    },
    {
        "ins1CurCode":"void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Path.of(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(StandardField.AUTHOR, \"Mr. Author\");  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); assertEquals(Files.readString(Path.of(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins1PreCode":"void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(StandardField.AUTHOR, \"Mr. Author\");  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins2PreCode":"void roundtripWithUserComment() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8;",
        "label":0
    },
    {
        "ins1CurCode":"public static CategoryDataset<String, String> createCategoryDataset( String rowKeyPrefix, String columnKeyPrefix, Number[][] data) {  DefaultCategoryDataset<String, String> result = new DefaultCategoryDataset<>(); for (int r = 0; r < data.length; r++) {",
        "ins1PreCode":"public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, Number[][] data) {  DefaultCategoryDataset result = new DefaultCategoryDataset(); for (int r = 0; r < data.length; r++) {",
        "ins2PreCode":"public static CategoryDataset createCategoryDataset(String rowKeyPrefix, String columnKeyPrefix, double[][] data) {  DefaultCategoryDataset result = new DefaultCategoryDataset(); for (int r = 0; r < data.length; r++) { String rowKey = rowKeyPrefix + (r + 1); for (int c = 0; c < data[r].length; c++) { String columnKey = columnKeyPrefix + (c + 1); result.addValue(new Double(data[r][c]), rowKey, columnKey); }",
        "label":0
    },
    {
        "ins1CurCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(Tuple2::swap); JavaTestUtils.attachTestOutputStream(reversed);",
        "ins1PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(x -> x.swap()); JavaTestUtils.attachTestOutputStream(reversed);",
        "ins2PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair( new PairFunction<Tuple2<String, Integer>, Integer, String>() { @Override public Tuple2<Integer, String> call(Tuple2<String, Integer> in) { return in.swap(); } }); ",
        "label":0
    },
    {
        "ins1CurCode":"return false; } if (!ObjectUtils.equal(this.stroke, that.stroke)) { return false; } if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!PaintUtils.equal(this.fillPaint, that.fillPaint)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtilities.equal(this.stroke, that.stroke)) { return false; } if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!PaintUtilities.equal(this.fillPaint, that.fillPaint)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtilities.equal(this.stroke, that.stroke)) { return false; } if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!PaintUtilities.equal(this.fillPaint, that.fillPaint)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"} nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getReadTimeout()); } catch (EOFException eof) {",
        "ins1PreCode":"} nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getTimeout()); } catch (EOFException eof) {",
        "ins2PreCode":"protected synchronized void doWrite(boolean block) throws IOException { socketBufferHandler.configureWriteBufferForRead();  long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(socketBufferHandler.getWriteBuffer(), getSocket(), selector, writeTimeout, block);  do { if (getSocket().flush(true, selector, writeTimeout)) break; } while (true); } finally { if (selector != null) { pool.put(selector); } }    ",
        "label":0
    },
    {
        "ins1CurCode":"public void testStartStopBindOnStart() throws Exception { Tomcat tomcat = getTomcatInstance(); Connector c = tomcat.getConnector(); c.setProperty(\"bindOnInit\", \"false\");  File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());   tomcat.start(); int port = getPort();  tomcat.getConnector().stop(); Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\"); try {  if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) {  } } assertNull(e); tomcat.getConnector().start();",
        "ins1PreCode":"public void testStartStopBindOnStart() throws Exception { Tomcat tomcat = getTomcatInstance(); Connector c = tomcat.getConnector(); c.setProperty(\"bindOnInit\", \"false\");  File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());  int port = getPort();  tomcat.start();  tomcat.getConnector().stop(); Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\"); try {  if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) {  } } assertNull(e); tomcat.getConnector().start();",
        "ins2PreCode":"public void testStartStopBindOnInit() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(getBuildDirectory(), \"webapps/examples\"); tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath());  int port = getPort();  tomcat.start();  tomcat.getConnector().stop(); Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\"); try {  if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) {  } } if (e != null) { log.info(\"Exception was\", e); } assertNotNull(e); tomcat.getConnector().start();",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(property).isEqualTo(\"fromspecificlocation\"); assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: [classpath:specificlocation.properties]\"));  assertThat(this.environment) .doesNotHave(matchingPropertySource(\"applicationConfig: [classpath:/application.properties]\")); assertThat(this.environment.getProperty(\"foo\")).isNull();",
        "ins1PreCode":"assertThat(property).isEqualTo(\"fromspecificlocation\"); assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:specificlocation.properties]\"));  assertThat(this.environment) .doesNotHave(matchingPropertySource(\"applicationConfig: \" + \"[classpath:/application.properties]\")); assertThat(this.environment.getProperty(\"foo\")).isNull();",
        "ins2PreCode":"assertThat(property).isEqualTo(\"fromspecificlocation\"); assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:specificlocation.properties]\"));  assertThat(this.environment) .has(matchingPropertySource(\"applicationConfig: \" + \"[classpath:/application.properties]\")); assertThat(this.environment.getProperty(\"foo\")).isEqualTo(\"bucket\");",
        "label":1
    },
    {
        "ins1CurCode":"if (listeners[i] == TreeModelListener.class) {  if (e == null) { e =",
        "ins1PreCode":"if (listeners[i] == TreeModelListener.class) {  if (e == null) e =",
        "ins2PreCode":"if (listeners[i] == TreeModelListener.class) {  if (e == null) e =",
        "label":1
    },
    {
        "ins1CurCode":"public void setDataset(int index, CategoryDataset<R, C> dataset) { CategoryDataset<R, C> existing = this.datasets.get(index); if (existing != null) {",
        "ins1PreCode":"public void setDataset(int index, CategoryDataset dataset) { CategoryDataset existing = this.datasets.get(index); if (existing != null) {",
        "ins2PreCode":"public void setDataset(int index, XYDataset dataset) { XYDataset existing = getDataset(index); if (existing != null) { existing.removeChangeListener(this); } this.datasets.set(index, dataset); if (dataset != null) { dataset.addChangeListener(this); }   DatasetChangeEvent event = new DatasetChangeEvent(this, dataset); datasetChanged(event);",
        "label":0
    },
    {
        "ins1CurCode":"}  getRequiredAttributes(); getOptionalAttributes(); ",
        "ins1PreCode":"commandLine = new Commandline();  commandLine.setExecutable(getSosCommand());  if (getFilename() != null) {  commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND); commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKOUT_FILE);  commandLine.createArgument().setValue(SOSCmd.FLAG_FILE); commandLine.createArgument().setValue(getFilename()); } else {  commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND); commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKOUT_PROJECT);  commandLine.createArgument().setValue(getRecursive()); }  if (getSosServerPath() == null) { throw new BuildException(\"sosserverpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_SERVER); commandLine.createArgument().setValue(getSosServerPath());  if (getUsername() == null) { throw new BuildException(\"username attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_USERNAME); commandLine.createArgument().setValue(getUsername());   commandLine.createArgument().setValue(SOSCmd.FLAG_PASSWORD); commandLine.createArgument().setValue(getPassword());  if (getVssServerPath() == null) { throw new BuildException(\"vssserverpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_VSS_SERVER); commandLine.createArgument().setValue(getVssServerPath());  if (getProjectPath() == null) { throw new BuildException(\"projectpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_PROJECT); commandLine.createArgument().setValue(getProjectPath());     commandLine.createArgument().setValue(getVerbose());  commandLine.createArgument().setValue(getNoCompress());  if (getSosHome() == null) {  commandLine.createArgument().setValue(getNoCache()); } else { commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_HOME); commandLine.createArgument().setValue(getSosHome()); }  if (getLocalPath() != null) { commandLine.createArgument().setValue(SOSCmd.FLAG_WORKING_DIR); commandLine.createArgument().setValue(getLocalPath()); }",
        "ins2PreCode":"commandLine = new Commandline();  commandLine.setExecutable(getSosCommand());  if (getFilename() != null) {  commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND); commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKIN_FILE);  commandLine.createArgument().setValue(SOSCmd.FLAG_FILE); commandLine.createArgument().setValue(getFilename()); } else {  commandLine.createArgument().setValue(SOSCmd.FLAG_COMMAND); commandLine.createArgument().setValue(SOSCmd.COMMAND_CHECKIN_PROJECT);  commandLine.createArgument().setValue(getRecursive()); }  if (getSosServerPath() == null) { throw new BuildException(\"sosserverpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_SERVER); commandLine.createArgument().setValue(getSosServerPath());  if (getUsername() == null) { throw new BuildException(\"username attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_USERNAME); commandLine.createArgument().setValue(getUsername());   commandLine.createArgument().setValue(SOSCmd.FLAG_PASSWORD); commandLine.createArgument().setValue(getPassword());  if (getVssServerPath() == null) { throw new BuildException(\"vssserverpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_VSS_SERVER); commandLine.createArgument().setValue(getVssServerPath());  if (getProjectPath() == null) { throw new BuildException(\"projectpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_PROJECT); commandLine.createArgument().setValue(getProjectPath());     commandLine.createArgument().setValue(getVerbose());  commandLine.createArgument().setValue(getNoCompress());  if (getSosHome() == null) {  commandLine.createArgument().setValue(getNoCache()); } else { commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_HOME); commandLine.createArgument().setValue(getSosHome()); }  if (getLocalPath() != null) { commandLine.createArgument().setValue(SOSCmd.FLAG_WORKING_DIR); commandLine.createArgument().setValue(getLocalPath()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testBug49297MultipleImport1() throws Exception { getTomcatInstanceTestWebapp(false, true); ",
        "ins1PreCode":"public void testBug49297MultipleImport1() throws Exception {  Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start(); ",
        "ins2PreCode":"public void testBug49297MultipleImport2() throws Exception {  Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start(); ",
        "label":1
    },
    {
        "ins1CurCode":"HttpServerDecoder decoder = new HttpServerDecoder(); HttpDecoderState state = decoder.createDecoderState(); HttpPdu pdus = decoder.decode(buffer, state); assertNotNull(pdus); assertEquals(\"localhost\", ((HttpRequestImpl) pdus).getHeader(\"host\"));",
        "ins1PreCode":"HttpServerDecoder decoder = new HttpServerDecoder(); HttpDecoderState state = decoder.createDecoderState(); HttpPdu[] pdus = decoder.decode(buffer, state); assertNotNull(pdus); assertEquals(1, pdus.length); assertEquals(\"localhost\", ((HttpRequestImpl) pdus[0]).getHeader(\"host\"));",
        "ins2PreCode":"HttpServerDecoder decoder = new HttpServerDecoder(); HttpDecoderState state = decoder.createDecoderState(); HttpPdu[] pdus = decoder.decode(buffer, state); assertNotNull(pdus); assertEquals(1, pdus.length); assertEquals(\"localhost\", ((HttpRequestImpl) pdus[0]).getHeader(\"host\"));",
        "label":1
    },
    {
        "ins1CurCode":"JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<?> plot = (XYPlot) chart.getPlot(); NumberAxis axis = (NumberAxis) plot.getDomainAxis();",
        "ins1PreCode":"JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<String> plot = (XYPlot) chart.getPlot(); NumberAxis axis = (NumberAxis) plot.getDomainAxis();",
        "ins2PreCode":"JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<String> plot = (XYPlot) chart.getPlot(); NumberAxis axis = (NumberAxis) plot.getRangeAxis();",
        "label":1
    },
    {
        "ins1CurCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Set<Country> countries = new HashSet<>(); countries.add(new Country(\"China\", \"CN\"));",
        "ins1PreCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Set<Country> countries = new HashSet<Country>(); countries.add(new Country(\"China\", \"CN\"));",
        "ins2PreCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Set<Country> countries = new HashSet<Country>(); countries.add(new Country(\"China\", \"CN\"));",
        "label":1
    },
    {
        "ins1CurCode":"appMaster.shutDownJob();  assertTrue(((TestMRApp)appMaster).getTestIsLastAMRetry()); verify(fs).delete(stagingJobPath, true);",
        "ins1PreCode":"appMaster.shutDownJob();  Assert.assertEquals(true, ((TestMRApp)appMaster).getTestIsLastAMRetry()); verify(fs).delete(stagingJobPath, true);",
        "ins2PreCode":"appMaster.shutDownJob();  Assert.assertEquals(true, ((TestMRApp) appMaster).getTestIsLastAMRetry()); verify(fs, times(0)).delete(stagingJobPath, true);",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command) {",
        "ins2PreCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command) {",
        "label":1
    },
    {
        "ins1CurCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assertions.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); Person p = new Person(3, \"hello\", \"world\"); pm.createWithoutFlushCache(p); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assertions.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession4 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession4.getMapper(PersonMapper.class); Assertions.assertEquals(3, pm.findWithFlushCache().size()); }",
        "ins1PreCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); Person p = new Person(3, \"hello\", \"world\"); pm.createWithoutFlushCache(p); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession4 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession4.getMapper(PersonMapper.class); Assert.assertEquals(3, pm.findWithFlushCache().size()); }",
        "ins2PreCode":"try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class); Assert.assertEquals(2, pm.findAll().size()); }  try (SqlSession sqlSession2 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession2.getMapper(PersonMapper.class); Person p = new Person(3, \"hello\", \"world\"); pm.createWithOptions(p); }  try (SqlSession sqlSession3 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession3.getMapper(PersonMapper.class); Assert.assertEquals(3, pm.findAll().size()); }",
        "label":0
    },
    {
        "ins1CurCode":"MockitoAnnotations.initMocks(this); tempDir = new File(Utils.createTempDir$default$1()); shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE); spillFilesCreated.clear(); taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file);",
        "ins1PreCode":"taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(shuffleMemoryManager.tryToAcquire(anyLong())).then(returnsFirstArg()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager);",
        "ins2PreCode":"public void setup() { shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE); taskMemoryManager = new TaskMemoryManager(new ExecutorMemoryManager(getMemoryAllocator()));   sizeLimitedTaskMemoryManager = mock(TaskMemoryManager.class); when(sizeLimitedTaskMemoryManager.allocate(geq(1L << 20))).thenAnswer( new Answer<MemoryBlock>() { @Override public MemoryBlock answer(InvocationOnMock invocation) throws Throwable { if (((Long) invocation.getArguments()[0] / 8) > Integer.MAX_VALUE) { throw new OutOfMemoryError(\"Requested array size exceeds VM limit\"); } return new MemoryBlock(null, 0, (Long) invocation.getArguments()[0]); } } );",
        "label":0
    },
    {
        "ins1CurCode":"private static <K, V> Message newMapEntry(Message.Builder builder, String name, K key, V value) { FieldDescriptor field = builder.getDescriptorForType().findFieldByName(name);",
        "ins1PreCode":"Message newMapEntry(Message.Builder builder, String name, KeyType key, ValueType value) { FieldDescriptor field = builder.getDescriptorForType().findFieldByName(name);",
        "ins2PreCode":"Message newMapEntry(Message.Builder builder, String name, KeyType key, ValueType value) { FieldDescriptor field = builder.getDescriptorForType().findFieldByName(name);",
        "label":1
    },
    {
        "ins1CurCode":"this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); try (Connection con = datasource.getConnection()) { Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive());",
        "ins1PreCode":"this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 0\",0,datasource.getPool().getActive()); con.close();",
        "ins2PreCode":"this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "label":1
    },
    {
        "ins1CurCode":"boolean includeInterval) { Range result = null; for (Object visibleSeriesKey : visibleSeriesKeys) { Comparable seriesKey = (Comparable) visibleSeriesKey; TimeSeries<S> series = getSeries((S) seriesKey);",
        "ins1PreCode":"boolean includeInterval) { Range result = null; Iterator iterator = visibleSeriesKeys.iterator(); while (iterator.hasNext()) { Comparable seriesKey = (Comparable) iterator.next(); TimeSeries<S> series = getSeries((S) seriesKey);",
        "ins2PreCode":"public Range getDomainBounds(boolean includeInterval) { Range result = null; for (TimeSeries<S> series : this.data) { int count = series.getItemCount(); if (count > 0) { RegularTimePeriod start = series.getTimePeriod(0); RegularTimePeriod end = series.getTimePeriod(count - 1); Range temp; if (!includeInterval) { temp = new Range(getX(start), getX(end)); } else { temp = new Range( start.getFirstMillisecond(this.workingCalendar), end.getLastMillisecond(this.workingCalendar)); } result = Range.combine(result, temp); } } return result;",
        "label":0
    },
    {
        "ins1CurCode":"public void requestRaceConditional() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final TestSubscriber<Integer> ts = new TestSubscriber<>(0L); ",
        "ins1PreCode":"public void requestRaceConditional() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "ins2PreCode":"public void requestRaceConditional2() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "label":1
    },
    {
        "ins1CurCode":".ofExisting(existingPropertySource); this.importer = mock(ConfigDataImporter.class); List<ConfigDataLocation> locations = Arrays.asList(LOCATION_1); MockPropertySource propertySource = new MockPropertySource(); Map<ConfigDataResource, ConfigData> imported = new LinkedHashMap<>(); imported.put(new TestConfigDataResource(\"a'\"), new ConfigData(Arrays.asList(propertySource))); given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations))) .willReturn(imported); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(LOCATION_1); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "ins1PreCode":".ofExisting(existingPropertySource); this.importer = mock(ConfigDataImporter.class); List<String> locations = Arrays.asList(\"testimport\"); MockPropertySource propertySource = new MockPropertySource(); Map<ConfigDataLocation, ConfigData> imported = new LinkedHashMap<>(); imported.put(new TestConfigDataLocation(\"a'\"), new ConfigData(Arrays.asList(propertySource))); given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations))) .willReturn(imported); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(\"testimport\"); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "ins2PreCode":".ofExisting(existingPropertySource); this.importer = mock(ConfigDataImporter.class); List<String> locations = Arrays.asList(\"testimport\"); MockPropertySource propertySource = new MockPropertySource(); Map<ConfigDataLocation, ConfigData> imported = new LinkedHashMap<>(); imported.put(new TestConfigDataLocation(\"a'\"), new ConfigData(Arrays.asList(propertySource))); given(this.importer.resolveAndLoad(eq(this.activationContext), any(), any(), eq(locations))) .willReturn(imported); ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(\"testimport\"); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory,",
        "label":1
    },
    {
        "ins1CurCode":"public void testNoPreserveLastModified() { buildRule.executeTarget(\"lastModifiedSetup\");",
        "ins1PreCode":"public void testNoPreserveLastModified() throws Exception { buildRule.executeTarget(\"lastModifiedSetup\");",
        "ins2PreCode":"public void testPreserveLastModified() throws Exception { buildRule.executeTarget(\"lastModifiedSetup\");",
        "label":1
    },
    {
        "ins1CurCode":"updateNameText();  LOG.log(Level.INFO, \"Registering as listener\"); Model.getPump().addModelEventListener(this, getOwner(), \"region\");",
        "ins1PreCode":"updateNameText();  LOG.info(\"Registering as listener\"); Model.getPump().addModelEventListener(this, getOwner(), \"region\");",
        "ins2PreCode":"updateNameText();  LOG.info(\"Registering as listener\"); Model.getPump().addModelEventListener(this, getOwner(), \"region\");",
        "label":1
    },
    {
        "ins1CurCode":"void pushWhenUnknownHostExceptionIsThrownDoesShutdown() throws Exception { givenScheduleAtFixedRateWithReturnFuture(); new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\",",
        "ins1PreCode":"void pushWhenUnknownHostExceptionIsThrownDoesShutdown() throws Exception { new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, null);",
        "ins2PreCode":"void pushDoesNotThrowException() throws Exception { new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, null); verify(this.scheduler).scheduleAtFixedRate(this.task.capture(), eq(this.pushRate)); willThrow(RuntimeException.class).given(this.pushGateway).pushAdd(this.registry, \"job\", this.groupingKey); this.task.getValue().run();",
        "label":0
    },
    {
        "ins1CurCode":"public boolean removeDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) { Collection<CategoryMarker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundDomainMarkers.get(index); } else { markers = this.backgroundDomainMarkers.get(index); }",
        "ins1PreCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundDomainMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundDomainMarkers.get(index); }",
        "ins2PreCode":"boolean notify) { Args.nullNotPermitted(marker, \"marker\"); ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundRangeMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundRangeMarkers.get(index); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testHash1() throws Exception { CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() { public int next(int n) { return n-1; } });  assertEquals(\"59;\", bitset(x.bits[0])); assertEquals(\"8;\", bitset(x.bits[1])); assertEquals(\"3;6;9;12;15;18;21;24;27;\", bitset(x.bits[2])); assertEquals(\"4;8;\", bitset(x.bits[3]));",
        "ins1PreCode":"public void testHash1() throws Exception { CronTab x = new CronTab(\"H H(5-8) * * *\",new Hash() { public int next(int n) {",
        "ins2PreCode":"public void testHash2() throws Exception { CronTab x = new CronTab(\"H H(5-8) * * *\",new Hash() { public int next(int n) {",
        "label":1
    },
    {
        "ins1CurCode":"{ add(new ResultMapping.Builder(config, \"id\", \"tag_id\", registry.getTypeHandler(int.class)) .flags(new ArrayList<ResultFlag>() { {",
        "ins1PreCode":"{ add(new ResultMapping.Builder(config, \"id\", \"tag_id\", registry.getTypeHandler(int.class)) .flags(new ArrayList() { {",
        "ins2PreCode":"{ add(new ResultMapping.Builder(config, \"id\", \"tag_id\", registry.getTypeHandler(int.class)) .flags(new ArrayList() { {",
        "label":1
    },
    {
        "ins1CurCode":"void bindToCollectionWithNoDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToCollectionWithNoDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToCollectionWithDefaultConstructor() { ",
        "label":1
    },
    {
        "ins1CurCode":"for (BibEntry e : entries) { row = result.createElement(\"table:table-row\"); addTableCell(result, row, getField(e, InternalField.KEY_FIELD)); addTableCell(result, row, new GetOpenOfficeType().format(e.getType().getName())); addTableCell(result, row, getField(e, StandardField.ADDRESS)); addTableCell(result, row, getField(e, StandardField.ASSIGNEE)); addTableCell(result, row, getField(e, StandardField.ANNOTE)); addTableCell(result, row, getField(e, StandardField.AUTHOR)); addTableCell(result, row, getField(e, StandardField.BOOKTITLE)); addTableCell(result, row, getField(e, StandardField.CHAPTER)); addTableCell(result, row, getField(e, StandardField.DAY)); addTableCell(result, row, getField(e, StandardField.DAYFILED)); addTableCell(result, row, getField(e, StandardField.EDITION)); addTableCell(result, row, getField(e, StandardField.EDITOR)); addTableCell(result, row, getField(e, StandardField.HOWPUBLISHED)); addTableCell(result, row, getField(e, StandardField.INSTITUTION)); addTableCell(result, row, getField(e, StandardField.JOURNAL)); addTableCell(result, row, getField(e, StandardField.LANGUAGE)); addTableCell(result, row, getField(e, StandardField.MONTH)); addTableCell(result, row, getField(e, StandardField.MONTHFILED)); addTableCell(result, row, getField(e, StandardField.NATIONALITY)); addTableCell(result, row, getField(e, StandardField.NOTE)); addTableCell(result, row, getField(e, StandardField.NUMBER)); addTableCell(result, row, getField(e, StandardField.ORGANIZATION)); addTableCell(result, row, getField(e, StandardField.PAGES)); addTableCell(result, row, getField(e, StandardField.PUBLISHER)); addTableCell(result, row, getField(e, StandardField.REVISION)); addTableCell(result, row, getField(e, StandardField.SCHOOL)); addTableCell(result, row, getField(e, StandardField.SERIES)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, StandardField.TITLE)))); addTableCell(result, row, getField(e, new UnknownField(\"reporttype\"))); addTableCell(result, row, getField(e, StandardField.VOLUME)); addTableCell(result, row, getField(e, StandardField.YEAR)); addTableCell(result, row, getField(e, StandardField.YEARFILED)); addTableCell(result, row, getField(e, StandardField.URL)); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, getField(e, StandardField.ISBN)); table.appendChild(row);",
        "ins1PreCode":"for (BibEntry e : entries) { row = result.createElement(\"table:table-row\"); addTableCell(result, row, getField(e, BibEntry.KEY_FIELD)); addTableCell(result, row, new GetOpenOfficeType().format(e.getType())); addTableCell(result, row, getField(e, FieldName.ADDRESS)); addTableCell(result, row, getField(e, FieldName.ASSIGNEE)); addTableCell(result, row, getField(e, FieldName.ANNOTE)); addTableCell(result, row, getField(e, FieldName.AUTHOR)); addTableCell(result, row, getField(e, FieldName.BOOKTITLE)); addTableCell(result, row, getField(e, FieldName.CHAPTER)); addTableCell(result, row, getField(e, FieldName.DAY)); addTableCell(result, row, getField(e, FieldName.DAYFILED)); addTableCell(result, row, getField(e, FieldName.EDITION)); addTableCell(result, row, getField(e, FieldName.EDITOR)); addTableCell(result, row, getField(e, FieldName.HOWPUBLISHED)); addTableCell(result, row, getField(e, FieldName.INSTITUTION)); addTableCell(result, row, getField(e, FieldName.JOURNAL)); addTableCell(result, row, getField(e, FieldName.LANGUAGE)); addTableCell(result, row, getField(e, FieldName.MONTH)); addTableCell(result, row, getField(e, FieldName.MONTHFILED)); addTableCell(result, row, getField(e, FieldName.NATIONALITY)); addTableCell(result, row, getField(e, FieldName.NOTE)); addTableCell(result, row, getField(e, FieldName.NUMBER)); addTableCell(result, row, getField(e, FieldName.ORGANIZATION)); addTableCell(result, row, getField(e, FieldName.PAGES)); addTableCell(result, row, getField(e, FieldName.PUBLISHER)); addTableCell(result, row, getField(e, FieldName.REVISION)); addTableCell(result, row, getField(e, FieldName.SCHOOL)); addTableCell(result, row, getField(e, FieldName.SERIES)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, FieldName.TITLE)))); addTableCell(result, row, getField(e, \"reporttype\")); addTableCell(result, row, getField(e, FieldName.VOLUME)); addTableCell(result, row, getField(e, FieldName.YEAR)); addTableCell(result, row, getField(e, FieldName.YEARFILED)); addTableCell(result, row, getField(e, FieldName.URL)); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, getField(e, FieldName.ISBN)); table.appendChild(row);",
        "ins2PreCode":"for (BibEntry e : entries) { row = result.createElement(\"table:table-row\"); addTableCell(result, row, new GetOpenOfficeType().format(e.getType())); addTableCell(result, row, getField(e, FieldName.ISBN)); addTableCell(result, row, getField(e, BibEntry.KEY_FIELD)); addTableCell(result, row, getField(e, FieldName.AUTHOR)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, FieldName.TITLE)))); addTableCell(result, row, getField(e, FieldName.JOURNAL)); addTableCell(result, row, getField(e, FieldName.VOLUME)); addTableCell(result, row, getField(e, FieldName.NUMBER)); addTableCell(result, row, getField(e, FieldName.MONTH)); addTableCell(result, row, getField(e, FieldName.PAGES)); addTableCell(result, row, getField(e, FieldName.YEAR)); addTableCell(result, row, getField(e, FieldName.ADDRESS)); addTableCell(result, row, getField(e, FieldName.NOTE)); addTableCell(result, row, getField(e, FieldName.URL)); addTableCell(result, row, getField(e, FieldName.BOOKTITLE)); addTableCell(result, row, getField(e, FieldName.CHAPTER)); addTableCell(result, row, getField(e, FieldName.EDITION)); addTableCell(result, row, getField(e, FieldName.SERIES)); addTableCell(result, row, getField(e, FieldName.EDITOR)); addTableCell(result, row, getField(e, FieldName.PUBLISHER)); addTableCell(result, row, getField(e, \"reporttype\")); addTableCell(result, row, getField(e, FieldName.HOWPUBLISHED)); addTableCell(result, row, getField(e, FieldName.INSTITUTION)); addTableCell(result, row, getField(e, FieldName.ORGANIZATION)); addTableCell(result, row, getField(e, FieldName.SCHOOL)); addTableCell(result, row, getField(e, FieldName.ANNOTE)); addTableCell(result, row, getField(e, FieldName.ASSIGNEE)); addTableCell(result, row, getField(e, FieldName.DAY)); addTableCell(result, row, getField(e, FieldName.DAYFILED)); addTableCell(result, row, getField(e, FieldName.MONTHFILED)); addTableCell(result, row, getField(e, FieldName.YEARFILED)); addTableCell(result, row, getField(e, FieldName.LANGUAGE)); addTableCell(result, row, getField(e, FieldName.NATIONALITY)); addTableCell(result, row, getField(e, FieldName.REVISION)); addTableCell(result, row, \"\");",
        "label":1
    },
    {
        "ins1CurCode":" InOrder inOrder = inOrder(subscriber); TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber); ",
        "ins1PreCode":" InOrder inOrder = inOrder(subscriber); TestSubscriberEx<String> ts = new TestSubscriberEx<String>(subscriber); ",
        "ins2PreCode":" InOrder inOrder = inOrder(observer); TestObserverEx<String> to = new TestObserverEx<String>(observer); ",
        "label":1
    },
    {
        "ins1CurCode":" Flowable.merge(f1.take(Flowable.bufferSize() * 2), f2.take(Flowable.bufferSize() * 2)).observeOn(Schedulers.computation()).subscribe(testSubscriber); testSubscriber.awaitDone(10, TimeUnit.SECONDS); if (testSubscriber.errors().size() > 0) {",
        "ins1PreCode":" Flowable.merge(f1.take(Flowable.bufferSize() * 2), f2.take(Flowable.bufferSize() * 2)).observeOn(Schedulers.computation()).subscribe(testSubscriber); testSubscriber.awaitDone(5, TimeUnit.SECONDS); if (testSubscriber.errors().size() > 0) {",
        "ins2PreCode":"public void backpressureUpstream() throws InterruptedException { final AtomicInteger generated1 = new AtomicInteger(); Flowable<Integer> f1 = createInfiniteFlowable(generated1).subscribeOn(Schedulers.computation()); final AtomicInteger generated2 = new AtomicInteger(); Flowable<Integer> f2 = createInfiniteFlowable(generated2).subscribeOn(Schedulers.computation());  TestSubscriberEx<Integer> testSubscriber = new TestSubscriberEx<Integer>() { @Override public void onNext(Integer t) { System.err.println(\"testSubscriber received => \" + t + \"  on thread \" + Thread.currentThread()); super.onNext(t); } };  Flowable.merge(f1.take(Flowable.bufferSize() * 2), f2.take(Flowable.bufferSize() * 2)).subscribe(testSubscriber); testSubscriber.awaitDone(5, TimeUnit.SECONDS); if (testSubscriber.errors().size() > 0) { testSubscriber.errors().get(0).printStackTrace(); } testSubscriber.assertNoErrors(); System.err.println(testSubscriber.values()); assertEquals(Flowable.bufferSize() * 4, testSubscriber.values().size());  System.out.println(\"Generated 1: \" + generated1.get()); System.out.println(\"Generated 2: \" + generated2.get()); assertTrue(generated1.get() >= Flowable.bufferSize() * 2 && generated1.get() <= Flowable.bufferSize() * 4);",
        "label":0
    },
    {
        "ins1CurCode":" Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ",
        "ins1PreCode":" Context ctx = tomcat.addContext(\"/\", System.getProperty(\"java.io.tmpdir\")); ",
        "ins2PreCode":" Context ctx = tomcat.addContext(\"/\", System.getProperty(\"java.io.tmpdir\")); ",
        "label":1
    },
    {
        "ins1CurCode":"public CategoryDataset<String, String> createDataset1() {  DefaultCategoryDataset<String, String> result = new DefaultCategoryDataset<>(); ",
        "ins1PreCode":"public CategoryDataset createDataset1() {  DefaultCategoryDataset result = new DefaultCategoryDataset(); ",
        "ins2PreCode":"public CategoryDataset createDataset2() {  DefaultCategoryDataset result = new DefaultCategoryDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void setFutureCancel() { AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE, true) { private static final long serialVersionUID = 208585707945686116L;",
        "ins1PreCode":"public void setFutureCancel() { AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE) { private static final long serialVersionUID = 208585707945686116L;",
        "ins2PreCode":"public void setFutureCancelSameThread() { AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE) { private static final long serialVersionUID = 208585707945686116L;",
        "label":1
    },
    {
        "ins1CurCode":"int num = (int) (Flowable.bufferSize() * 0.2); AtomicInteger c = new AtomicInteger(); TestSubscriber<Integer> ts = new TestSubscriber<>(); incrementingIntegers(c).observeOn(Schedulers.computation()).map(",
        "ins1PreCode":"int num = (int) (Flowable.bufferSize() * 0.2); AtomicInteger c = new AtomicInteger(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); incrementingIntegers(c).observeOn(Schedulers.computation()).map(",
        "ins2PreCode":"int num = (int) (Flowable.bufferSize() * 2.1); AtomicInteger c = new AtomicInteger(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void timeoutResetsSource() { TestConnectableFlowable<Object> tcf = new TestConnectableFlowable<>(); FlowableRefCount<Object> o = (FlowableRefCount<Object>)tcf.refCount();",
        "ins1PreCode":"public void timeoutResetsSource() { TestConnectableFlowable<Object> tcf = new TestConnectableFlowable<Object>(); FlowableRefCount<Object> o = (FlowableRefCount<Object>)tcf.refCount();",
        "ins2PreCode":"public void timeoutResetsSource() { TestConnectableObservable<Object> tco = new TestConnectableObservable<Object>(); ObservableRefCount<Object> o = (ObservableRefCount<Object>)tco.refCount();",
        "label":1
    },
    {
        "ins1CurCode":"void excludeByClassShouldNotMatchExcluded() { ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excluding(FooEndpoint.class,",
        "ins1PreCode":"public void excludeByClassShouldNotMatchExcluded() { ServerWebExchangeMatcher matcher = EndpointRequest.toAnyEndpoint().excluding(FooEndpoint.class,",
        "ins2PreCode":"public void excludeByClassShouldNotMatchExcluded() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint().excluding(FooEndpoint.class, BazServletEndpoint.class);",
        "label":1
    },
    {
        "ins1CurCode":"void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, true, new SaveOrderConfig.SortCriterion(\"author\", false),",
        "ins1PreCode":"void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, new SaveOrderConfig.SortCriterion(\"author\", false),",
        "ins2PreCode":"void writeEntriesInOriginalOrderWhenNoSaveOrderConfigIsSetInMetadata() throws Exception { BibEntry firstEntry = new BibEntry(); firstEntry.setType(BibtexEntryTypes.ARTICLE); firstEntry.setField(\"author\", \"A\"); firstEntry.setField(\"year\", \"2010\");  BibEntry secondEntry = new BibEntry(); secondEntry.setType(BibtexEntryTypes.ARTICLE); secondEntry.setField(\"author\", \"B\"); secondEntry.setField(\"year\", \"2000\");  BibEntry thirdEntry = new BibEntry(); thirdEntry.setType(BibtexEntryTypes.ARTICLE); thirdEntry.setField(\"author\", \"A\"); thirdEntry.setField(\"year\", \"2000\");  database.insertEntry(firstEntry); database.insertEntry(secondEntry); database.insertEntry(thirdEntry);  when(preferences.isSaveInOriginalOrder()).thenReturn(false); databaseWriter.savePartOfDatabase(bibtexContext, database.getEntries());  assertEquals( OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {A},\" + OS.NEWLINE + \"  year   = {2010},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {B},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {A},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE , stringWriter.toString());",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(5, joined.size()); Tuple2<Integer,Tuple2<Integer,Optional<Character>>> firstUnmatched = rdd1.leftOuterJoin(rdd2).filter(tup -> !tup._2()._2().isPresent()).first(); assertEquals(3, firstUnmatched._1().intValue());",
        "ins1PreCode":"assertEquals(5, joined.size()); Tuple2<Integer,Tuple2<Integer,Optional<Character>>> firstUnmatched = rdd1.leftOuterJoin(rdd2).filter( new Function<Tuple2<Integer, Tuple2<Integer, Optional<Character>>>, Boolean>() { @Override public Boolean call(Tuple2<Integer, Tuple2<Integer, Optional<Character>>> tup) { return !tup._2()._2().isPresent(); } }).first(); assertEquals(3, firstUnmatched._1().intValue());",
        "ins2PreCode":"public void leftOuterJoin() { JavaPairRDD<Integer, Integer> rdd1 = sc.parallelizePairs(Arrays.asList( new Tuple2<>(1, 1), new Tuple2<>(1, 2), new Tuple2<>(2, 1), new Tuple2<>(3, 1) )); JavaPairRDD<Integer, Character> rdd2 = sc.parallelizePairs(Arrays.asList( new Tuple2<>(1, 'x'), new Tuple2<>(2, 'y'), new Tuple2<>(2, 'z'), new Tuple2<>(4, 'w') )); List<Tuple2<Integer, Tuple2<Integer, Optional<Character>>>> joined = rdd1.leftOuterJoin(rdd2).collect(); Assert.assertEquals(5, joined.size()); Tuple2<Integer, Tuple2<Integer, Optional<Character>>> firstUnmatched = rdd1.leftOuterJoin(rdd2).filter(tup -> !tup._2()._2().isPresent()).first(); Assert.assertEquals(3, firstUnmatched._1().intValue());",
        "label":0
    },
    {
        "ins1CurCode":"  ArgoDiagram diagram = createDiagram(ns, settings); ",
        "ins1PreCode":"  ArgoDiagram diagram = createDiagram(ns); diagram.setDiagramSettings(settings); ",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { super.actionPerformed(e);     Project p = ProjectManager.getManager().getCurrentProject(); Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns); assert (diagram != null) : \"No diagram was returned by the concrete class\";  p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded( diagram.getNamespace()); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "label":0
    },
    {
        "ins1CurCode":"try { getEndpoint().connections.remove(getSocket().getIOChannel()); if (getSocket().isOpen()) { getSocket().close(true);",
        "ins1PreCode":"try { getEndpoint().connections.remove(getSocket().getIOChannel()); synchronized (getSocket()) { if (getSocket().isOpen()) {",
        "ins2PreCode":"try { getEndpoint().connections.remove(getSocket().getIOChannel()); synchronized (getSocket()) { if (getSocket().isOpen()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribe(final Observer<? super Long> observer) { final AtomicBoolean terminate = new AtomicBoolean(false); observer.onSubscribe(Disposable.fromRunnable(new Runnable() { @Override",
        "ins1PreCode":"public void subscribe(final Observer<? super Long> observer) { final AtomicBoolean terminate = new AtomicBoolean(false); observer.onSubscribe(Disposables.fromRunnable(new Runnable() { @Override",
        "ins2PreCode":"public void subscribe(final Subscriber<? super Long> subscriber) { final AtomicBoolean terminate = new AtomicBoolean(false); subscriber.onSubscribe(new Subscription() { @Override public void request(long n) {   }  @Override public void cancel() { terminate.set(true); active.decrementAndGet(); } }); efforts.getAndIncrement(); active.getAndIncrement(); maxActive.set(Math.max(active.get(), maxActive.get())); final Thread thread = new Thread(context) { @Override public void run() { long nr = 0; try { while (!terminate.get()) { Thread.sleep(emitDelay); if (nextBeforeFailure.getAndDecrement() > 0) { subscriber.onNext(nr++); } else { active.decrementAndGet(); subscriber.onError(new RuntimeException(\"expected-failed\")); break; } } } catch (InterruptedException t) { } } }; thread.start();",
        "label":0
    },
    {
        "ins1CurCode":"Plot parent = getParent(); if (parent instanceof CategoryPlot) { @SuppressWarnings(\"unchecked\") CategoryPlot<R, C> cp = (CategoryPlot) parent; result = cp.getDomainAxis(index);",
        "ins1PreCode":"Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getDomainAxis(index);",
        "ins2PreCode":"Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index);",
        "label":1
    },
    {
        "ins1CurCode":"UpgradeServlet servlet = new UpgradeServlet(upgradeHandlerClass); Tomcat.addServlet(ctx, \"servlet\", servlet); ctx.addServletMappingDecoded(\"/\", \"servlet\"); ",
        "ins1PreCode":"UpgradeServlet servlet = new UpgradeServlet(upgradeHandlerClass); Tomcat.addServlet(ctx, \"servlet\", servlet); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "ins2PreCode":"UpgradeServlet servlet = new UpgradeServlet(upgradeHandlerClass); Tomcat.addServlet(ctx, \"servlet\", servlet); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"TestMap message = builder.build();  assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumFieldMap().get(0)); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumFieldMap().get(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, message.getInt32ToEnumFieldMap().get(2)); assertEquals(1000, message.getInt32ToEnumFieldValueMap().get(2).intValue());      message = TestMap.parseFrom(message.toByteString()); assertEquals(1000, message.getInt32ToEnumFieldValueMap().get(2).intValue()); builder = message.toBuilder(); assertEquals(1000, builder.getInt32ToEnumFieldValueMap().get(2).intValue()); builder = TestMap.newBuilder().mergeFrom(message); assertEquals(1000, builder.getInt32ToEnumFieldValueMap().get(2).intValue());   builder.putAllInt32ToEnumFieldValue(newMap(2, 1001)); TestMap message2 = builder.build(); assertFalse(message.hashCode() == message2.hashCode()); assertFalse(message.equals(message2));   assertEquals(message2.getInt32ToEnumFieldMap(), message.getInt32ToEnumFieldMap());",
        "ins1PreCode":"TestMap message = builder.build();  assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumField().get(0)); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, message.getInt32ToEnumField().get(2)); assertEquals(1000, message.getInt32ToEnumFieldValue().get(2).intValue());      message = TestMap.parseFrom(message.toByteString()); assertEquals(1000, message.getInt32ToEnumFieldValue().get(2).intValue()); builder = message.toBuilder(); assertEquals(1000, builder.getInt32ToEnumFieldValue().get(2).intValue()); builder = TestMap.newBuilder().mergeFrom(message); assertEquals(1000, builder.getInt32ToEnumFieldValue().get(2).intValue());   builder.putAllInt32ToEnumFieldValue(newMap(2, 1001)); TestMap message2 = builder.build(); assertFalse(message.hashCode() == message2.hashCode()); assertFalse(message.equals(message2));   assertEquals(message2.getInt32ToEnumField(), message.getInt32ToEnumField());",
        "ins2PreCode":"TestMap message = builder.build();  assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumField().get(0)); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.UNRECOGNIZED, message.getInt32ToEnumField().get(2));  builder.putAllInt32ToEnumFieldValue(newMap(2, 1000)); message = builder.build(); assertEquals(TestMap.EnumValue.UNRECOGNIZED, message.getInt32ToEnumField().get(2));      message = TestMap.parseFrom(message.toByteString()); assertEquals(1000, message.getInt32ToEnumFieldValue().get(2).intValue()); builder = message.toBuilder(); assertEquals(1000, builder.getInt32ToEnumFieldValue().get(2).intValue()); builder = TestMap.newBuilder().mergeFrom(message); assertEquals(1000, builder.getInt32ToEnumFieldValue().get(2).intValue());   builder.putAllInt32ToEnumFieldValue(newMap(2, 1001)); TestMap message2 = builder.build(); assertFalse(message.hashCode() == message2.hashCode()); assertFalse(message.equals(message2));   assertEquals(message2.getInt32ToEnumField(), message.getInt32ToEnumField());",
        "label":1
    },
    {
        "ins1CurCode":"public void loadTwoPropertiesFilesWithProfiles() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins1PreCode":"public void loadTwoPropertiesFilesWithProfiles() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void loadTwoPropertiesFilesWithProfilesUsingAdditionalLocation() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, EnumSet.noneOf(SearchFlags.class)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false); ",
        "ins2PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); ",
        "label":0
    },
    {
        "ins1CurCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); }",
        "ins1PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getPercentComplete(r,",
        "ins2PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getEndValue(r,",
        "label":0
    },
    {
        "ins1CurCode":"public void testDateConstructor1() { TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Locale locale = Locale.getDefault(); Hour h1 = new Hour(new Date(1014307199999L), zone, locale); Hour h2 = new Hour(new Date(1014307200000L), zone, locale);  assertEquals(15, h1.getHour()); assertEquals(1014307199999L, h1.getLastMillisecond(cal));  assertEquals(16, h2.getHour()); assertEquals(1014307200000L, h2.getFirstMillisecond(cal));",
        "ins1PreCode":" assertEquals(15, h1.getHour()); assertEquals(1014307199999L, h1.getLastMillisecond(zone));  assertEquals(16, h2.getHour()); assertEquals(1014307200000L, h2.getFirstMillisecond(zone));",
        "ins2PreCode":" assertEquals(15, h1.getHour()); assertEquals(1014267599999L, h1.getLastMillisecond(zone));  assertEquals(16, h2.getHour()); assertEquals(1014267600000L, h2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1CurCode":"MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), ErrorAttributeOptions.defaults()); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());",
        "ins1PreCode":"MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, false, false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());",
        "ins2PreCode":"MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, true, false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());",
        "label":0
    },
    {
        "ins1CurCode":"public void assertValuesOnly() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposable.empty()); to.assertValuesOnly();",
        "ins1PreCode":"public void assertValuesOnly() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposables.empty()); to.assertValuesOnly();",
        "ins2PreCode":"public void assertValuesOnlyThrowsOnUnexpectedValue() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposables.empty()); to.assertValuesOnly();",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)); ",
        "ins1PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); ",
        "ins2PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); ",
        "label":1
    },
    {
        "ins1CurCode":"nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\"));  ",
        "ins1PreCode":"nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); nonloginContext.setSessionTimeout(LONG_SESSION_TIMEOUT_MINS); ",
        "ins2PreCode":"private void setUpNonLogin() throws Exception {   nonloginContext = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); nonloginContext.setSessionTimeout(LONG_SESSION_TIMEOUT_MINS);   Tomcat.addServlet(nonloginContext, \"TesterServlet1\", new TesterServletEncodeUrl()); nonloginContext.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); nonloginContext.addConstraint(sc1);   Tomcat.addServlet(nonloginContext, \"TesterServlet2\", new TesterServletEncodeUrl()); nonloginContext.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); nonloginContext.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); nonloginContext.setLoginConfig(lc); AuthenticatorBase nonloginAuthenticator = new NonLoginAuthenticator(); nonloginContext.getPipeline().addValve(nonloginAuthenticator);",
        "label":0
    },
    {
        "ins1CurCode":"SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{",
        "ins1PreCode":"SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{",
        "ins2PreCode":"SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{",
        "label":1
    },
    {
        "ins1CurCode":"public void normal() { FutureTask<Object> ft = new FutureTask<>(Functions.EMPTY_RUNNABLE, null); Disposable d = Disposable.fromFuture(ft);",
        "ins1PreCode":"public void normal() { FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, null); Disposable d = Disposable.fromFuture(ft);",
        "ins2PreCode":"public void interruptible() { FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, null); Disposable d = Disposable.fromFuture(ft, true);",
        "label":1
    },
    {
        "ins1CurCode":"void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() throws Exception { String tokenKeyValue = \"-----BEGIN PUBLIC KEY-----\\n\"",
        "ins1PreCode":"public void fetchTokenKeysWhenSuccessfulShouldReturnListOfKeysFromUAA() throws Exception { String tokenKeyValue = \"-----BEGIN PUBLIC KEY-----\\n\"",
        "ins2PreCode":"public void fetchTokenKeysWhenNoKeysReturnedFromUAA() throws Exception { prepareResponse((response) -> {",
        "label":1
    },
    {
        "ins1CurCode":"if (!isFollowSymlinks() && file.isSymbolicLink()) { filesExcluded.addElement(name); } else { ",
        "ins1PreCode":"if (!isFollowSymlinks() && file.isSymbolicLink()) { filesExcluded.addElement(name); } else if (isFunctioningAsFile(ftp, dir, file)) { accountForIncludedFile(name);",
        "ins2PreCode":"protected void scandir(String dir, String vpath, boolean fast) {  if (fast && hasBeenScanned(vpath)) { return; } try { if (!ftp.changeWorkingDirectory(dir)) { return; } String completePath; if (vpath.isEmpty()) { completePath = rootPath; } else { completePath = rootPath + task.getSeparator() + vpath.replace(File.separatorChar, task.getSeparator().charAt(0)); } FTPFile[] newfiles = listFiles(completePath, false);  if (newfiles == null) { ftp.changeToParentDirectory(); return; } for (FTPFile file : newfiles) { if (file != null && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file)); if (isFunctioningAsDirectory(ftp, dir, file)) { boolean slowScanAllowed = true; if (!isFollowSymlinks() && file.isSymbolicLink()) { dirsExcluded.addElement(name); slowScanAllowed = false; } else if (isIncluded(name)) { accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath), fast); } else { dirsNotIncluded.addElement(name); if (fast && couldHoldIncluded(name)) { scandir(file.getName(), name + File.separator, fast); } } if (!fast && slowScanAllowed) { scandir(file.getName(), name + File.separator, fast); } } else { if (!isFollowSymlinks() && file.isSymbolicLink()) { filesExcluded.addElement(name); } else if (isFunctioningAsFile(ftp, dir, file)) { accountForIncludedFile(name); } } } } ftp.changeToParentDirectory(); } catch (IOException e) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", e); }",
        "label":0
    },
    {
        "ins1CurCode":"public void onSubscribeThrows() { final List<Object> received = new ArrayList<>();  BoundedSubscriber<Object> subscriber = new BoundedSubscriber<>(new Consumer<Object>() { @Override",
        "ins1PreCode":"public void onSubscribeThrows() { final List<Object> received = new ArrayList<Object>();  BoundedSubscriber<Object> subscriber = new BoundedSubscriber<Object>(new Consumer<Object>() { @Override",
        "ins2PreCode":"public void onNextThrows() { final List<Object> received = new ArrayList<Object>();  BoundedSubscriber<Object> subscriber = new BoundedSubscriber<Object>(new Consumer<Object>() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"final void bufferUInt32NoTag(int value) { if (HAS_UNSAFE_ARRAY_OPERATIONS) { final long originalPos = position; while (true) { if ((value & ~0x7F) == 0) { UnsafeUtil.putByte(buffer, position++, (byte) value); break; } else { UnsafeUtil.putByte(buffer, position++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7; } } int delta = (int) (position - originalPos); totalBytesWritten += delta;",
        "ins1PreCode":"final void bufferUInt32NoTag(int value) { if (HAS_UNSAFE_ARRAY_OPERATIONS) { final long originalPos = ARRAY_BASE_OFFSET + position; long pos = originalPos; while (true) { if ((value & ~0x7F) == 0) { UnsafeUtil.putByte(buffer, pos++, (byte) value); break; } else { UnsafeUtil.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7; } } int delta = (int) (pos - originalPos); position += delta; totalBytesWritten += delta;",
        "ins2PreCode":"public final void writeUInt64NoTag(long value) throws IOException { if (HAS_UNSAFE_ARRAY_OPERATIONS && spaceLeft() >= MAX_VARINT_SIZE) { long pos = ARRAY_BASE_OFFSET + position; while (true) { if ((value & ~0x7FL) == 0) { UnsafeUtil.putByte(buffer, pos++, (byte) value); position++; return; } else { UnsafeUtil.putByte(buffer, pos++, (byte) (((int) value & 0x7F) | 0x80)); position++; value >>>= 7;",
        "label":0
    },
    {
        "ins1CurCode":"IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> InnerHitContextBuilder.extractInnerHits(queryBuilder, Collections.singletonMap(\"some_name\", null))); assertEquals(\"[inner_hits] already contains an entry for key [some_name]\", e.getMessage());",
        "ins1PreCode":"IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> InnerHitContextBuilder.extractInnerHits(queryBuilder, Collections.singletonMap(\"some_name\", null)));",
        "ins2PreCode":"IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> InnerHitContextBuilder.extractInnerHits(queryBuilder, Collections.singletonMap(\"some_name\", null)));",
        "label":1
    },
    {
        "ins1CurCode":"final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<>(); final TestSubscriber<Integer> ts2 = new TestSubscriber<>(); ",
        "ins1PreCode":"final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); final TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"final ConnectableFlowable<Integer> cf = Flowable.range(1, 3).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); final TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"lpf.remove(\"prop.beta\");  lpf.saveAs(tmp);  ",
        "ins1PreCode":"lpf.remove(\"prop.beta\");  File tmp = File.createTempFile(\"tmp\", \"props\"); tmp.deleteOnExit(); lpf.saveAs(tmp);",
        "ins2PreCode":"lpf.remove(\"prop.beta\");  File tmp = File.createTempFile(\"tmp\", \"props\"); tmp.deleteOnExit(); lpf.saveAs(tmp);",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "label":0
    },
    {
        "ins1CurCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"Assert.assertEquals(3, historyPageFilter.runs.size());  Assert.assertEquals(HistoryPageEntry.getEntryId(3), historyPageFilter.newestOnPage); Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);",
        "ins1PreCode":"Assert.assertEquals(3, historyPageFilter.runs.size());  Assert.assertEquals(3, historyPageFilter.newestOnPage); Assert.assertEquals(1, historyPageFilter.oldestOnPage);",
        "ins2PreCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(5, historyPageFilter.newestOnPage); Assert.assertEquals(1, historyPageFilter.oldestOnPage);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { AreaRenderer r1 = new AreaRenderer(); AreaRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { AreaRenderer r1 = new AreaRenderer(); AreaRenderer r2 = (AreaRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StatisticalBarRenderer r1 = new StatisticalBarRenderer(); StatisticalBarRenderer r2 = (StatisticalBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":" final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(MockOptInProtocol1.NAME); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertProtocolEnabled(MockOptInProtocol1.NAME, \"before the roundtrip\");  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have additional enabled protocol\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 1)); assertProtocolEnabled(MockOptInProtocol1.NAME, \"after the roundtrip\");",
        "ins1PreCode":"public void agentProtocols_singleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\")));  final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\"));  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have additional enabled protocol\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 1)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\"));",
        "ins2PreCode":"public void agentProtocols_multipleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\"))); Assume.assumeThat(\"We assume that JNLP4-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP4-connect\")));  final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); newProtocols.add(\"JNLP4-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\")); assertThat(\"JNLP4-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP4-connect\"));  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have two additional enabled protocols\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 2)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\")); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP4-connect\"));",
        "label":0
    },
    {
        "ins1CurCode":"  Hashtable<String, JarEntry> genericEntries = StreamUtils.enumerationAsStream(genericJar.entries()) .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b, Hashtable::new));   Hashtable<String, JarEntry> wasEntries = StreamUtils.enumerationAsStream(wasJar.entries()) .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));",
        "ins1PreCode":"  Hashtable<String, JarEntry> genericEntries = Collections.list(genericJar.entries()).stream() .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b, Hashtable::new));   Hashtable<String, JarEntry> wasEntries = Collections.list(wasJar.entries()).stream() .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new)); ",
        "ins2PreCode":"protected boolean isRebuildRequired(File genericJarFile, File weblogicJarFile) { boolean rebuild = false;  JarFile genericJar = null; JarFile wlJar = null; File newWLJarFile = null; JarOutputStream newJarStream = null; ClassLoader genericLoader = null;  try { log(\"Checking if weblogic Jar needs to be rebuilt for jar \" + weblogicJarFile.getName(), Project.MSG_VERBOSE);  if (genericJarFile.exists() && genericJarFile.isFile() && weblogicJarFile.exists() && weblogicJarFile.isFile()) {  genericJar = new JarFile(genericJarFile); wlJar = new JarFile(weblogicJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = genericEntries.get(filepath); JarEntry wlEntry = wlEntries.get(filepath);  if (genericEntry.getCrc() != wlEntry.getCrc() || genericEntry.getSize() != wlEntry.getSize()) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) {   log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } else {   log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newWLJarFile.toPath())); newJarStream.setLevel(0);   for (JarEntry je : wlEntries.values()) { if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }  InputStream is;  if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage();  throw new BuildException(msg, ioe); } finally { FileUtils.close(genericJar); FileUtils.close(wlJar); FileUtils.close(newJarStream);  if (newJarStream != null) { try { FILE_UTILS.rename(newWLJarFile, weblogicJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true; } } if (genericLoader instanceof AntClassLoader) { @SuppressWarnings(\"resource\") AntClassLoader loader = (AntClassLoader) genericLoader; loader.cleanup(); } } return rebuild;",
        "label":0
    },
    {
        "ins1CurCode":"while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(WAIT_INTERVAL); }",
        "ins1PreCode":"while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(QUARTER_SECOND); }",
        "ins2PreCode":"public void waitForString(String s, Integer timeout) { InputStream is = this.getInputStream(); try { StringBuffer sb = new StringBuffer(); if (timeout == null || timeout.intValue() == 0) { while (sb.toString().indexOf(s) == -1) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (sb.toString().indexOf(s) == -1) { while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(250); } if (is.available() == 0) { throw new BuildException( \"Response timed-out waiting for \\\"\" + s + '\\\"', getLocation()); } sb.append((char) is.read()); } } log(sb.toString(), Project.MSG_INFO); } catch (BuildException be) { throw be; } catch (Exception e) { throw new BuildException(e, getLocation()); }",
        "label":0
    },
    {
        "ins1CurCode":"try { final ThreadSubscription subscription = new ThreadSubscription(); final AtomicReference<Thread> subscribeThread = new AtomicReference<>(); Flowable<Integer> w = Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(Subscriber<? super Integer> t1) { subscribeThread.set(Thread.currentThread()); t1.onSubscribe(subscription); t1.onNext(1); t1.onNext(2);     } });  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); w.subscribeOn(uiEventLoop).observeOn(Schedulers.computation())",
        "ins1PreCode":"try { final ThreadSubscription subscription = new ThreadSubscription(); final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>(); Flowable<Integer> w = Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(Subscriber<? super Integer> t1) { subscribeThread.set(Thread.currentThread()); t1.onSubscribe(subscription); t1.onNext(1); t1.onNext(2);     } });  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); w.subscribeOn(uiEventLoop).observeOn(Schedulers.computation())",
        "ins2PreCode":"try { final ThreadSubscription subscription = new ThreadSubscription(); final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>(); Flowable<Integer> w = Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(Subscriber<? super Integer> t1) { subscribeThread.set(Thread.currentThread()); t1.onSubscribe(subscription); t1.onNext(1); t1.onNext(2);     } });  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); w.subscribeOn(Schedulers.newThread()).observeOn(Schedulers.computation())",
        "label":1
    },
    {
        "ins1CurCode":"String processorTag = randomAlphaOfLength(10);  GeoIpProcessor processor = factory.create(null, processorTag, null, config); ",
        "ins1PreCode":"String processorTag = randomAlphaOfLength(10);  GeoIpProcessor processor = factory.create(null, processorTag, config); ",
        "ins2PreCode":"String processorTag = randomAlphaOfLength(10);  GeoIpProcessor processor = factory.create(null, processorTag, config); ",
        "label":1
    },
    {
        "ins1CurCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); }",
        "ins1PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getStartValue(r,",
        "ins2PreCode":"int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getSubIntervalCount(r,",
        "label":1
    },
    {
        "ins1CurCode":"public void completeAfterAddingEntryWithoutFieldReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(StandardField.AUTHOR, \"testAuthor\"); autoCompleter.indexEntry(entry);",
        "ins1PreCode":"public void completeAfterAddingEntryWithoutFieldReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(\"title\", \"testTitle\"); autoCompleter.indexEntry(entry);",
        "ins2PreCode":"public void completeAfterAddingEntryWithoutFieldReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(\"title\", \"testTitle\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, request.requests().get(2).getScriptParams().size());  assertWarnings(RestMultiSearchAction.TYPES_DEPRECATION_MESSAGE);",
        "ins1PreCode":"assertEquals(1, request.requests().get(2).getScriptParams().size());",
        "ins2PreCode":"public void testParseWithCarriageReturn() throws Exception { final String content = \"{\\\"index\\\":[\\\"test0\\\", \\\"test1\\\"], \\\"request_cache\\\": true}\\r\\n\" + \"{\\\"source\\\": {\\\"query\\\" : {\\\"match_{{template}}\\\" :{}}}, \\\"params\\\": {\\\"template\\\": \\\"all\\\" } }\\r\\n\"; RestRequest restRequest = new FakeRestRequest.Builder(xContentRegistry()) .withContent(new BytesArray(content), XContentType.JSON).build();  MultiSearchTemplateRequest request = RestMultiSearchTemplateAction.parseRequest(restRequest, true);  assertThat(request.requests().size(), equalTo(1)); assertThat(request.requests().get(0).getRequest().indices()[0], equalTo(\"test0\")); assertThat(request.requests().get(0).getRequest().indices()[1], equalTo(\"test1\")); assertThat(request.requests().get(0).getRequest().indices(), arrayContaining(\"test0\", \"test1\")); assertThat(request.requests().get(0).getRequest().requestCache(), equalTo(true)); assertThat(request.requests().get(0).getRequest().preference(), nullValue()); assertNotNull(request.requests().get(0).getScript()); assertEquals(ScriptType.INLINE, request.requests().get(0).getScriptType()); assertEquals(\"{\\\"query\\\":{\\\"match_{{template}}\\\":{}}}\", request.requests().get(0).getScript()); assertEquals(1, request.requests().get(0).getScriptParams().size());",
        "label":0
    },
    {
        "ins1CurCode":"void parentContextCreationThatIsRunDirectly() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)",
        "ins1PreCode":"public void parentContextCreationThatIsRunDirectly() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)",
        "ins2PreCode":"public void parentContextCreationThatIsBuiltThenRun() { SpringApplicationBuilder application = new SpringApplicationBuilder(ChildConfig.class)",
        "label":1
    },
    {
        "ins1CurCode":"return null;  if (path == null) { return null; }  int fragmentPos = path.indexOf('#'); if (fragmentPos > -1) { context.getLogger().warn(sm.getString(\"applicationHttpRequest.fragmentInDispatchPath\", path)); path = path.substring(0, fragmentPos); }   if (path.startsWith(\"/\")) { return context.getServletContext().getRequestDispatcher(path); }   String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); if (servletPath == null) servletPath = getServletPath();   String pathInfo = getPathInfo(); String requestPath = null;  if (pathInfo == null) { requestPath = servletPath; } else { requestPath = servletPath + pathInfo; }  int pos = requestPath.lastIndexOf('/'); String relative = null; if (context.getDispatchersUseEncodedPaths()) { if (pos >= 0) { relative = URLEncoder.DEFAULT.encode( requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path; } else { relative = URLEncoder.DEFAULT.encode(requestPath, StandardCharsets.UTF_8) + path; }",
        "ins1PreCode":"  if (path == null) return null; else if (path.startsWith(\"/\")) return context.getServletContext().getRequestDispatcher(path);",
        "ins2PreCode":"if (path == null) { return null; } else if (path.startsWith(\"/\")) { return context.getServletContext().getRequestDispatcher(path);",
        "label":0
    },
    {
        "ins1CurCode":"TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>();  tc.onSubscribe(Disposable.empty());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>();  tc.onSubscribe(Disposables.empty());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void startOnce() {  List<Throwable> error = TestHelper.trackPluginErrors();  try { TestDisposableSubscriber<Integer> tc = new TestDisposableSubscriber<Integer>();  tc.onSubscribe(new BooleanSubscription());  BooleanSubscription bs = new BooleanSubscription();  tc.onSubscribe(bs);  assertTrue(bs.isCancelled());  assertEquals(1, tc.start);  TestHelper.assertError(error, 0, IllegalStateException.class, EndConsumerHelper.composeMessage(tc.getClass().getName())); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTableBase owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) {",
        "ins1PreCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) {",
        "ins2PreCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"} if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { writeBlocking = false; }",
        "ins1PreCode":"if (n == 0) { try { writeBlock = new CountDownLatch(1); registerWriteInterest(); if (timeout > 0) { if (!writeBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { writeBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { writeBlock = null; }",
        "ins2PreCode":"long timeout = getReadTimeout(); try { readBlock = new CountDownLatch(1); registerReadInterest(); if (timeout > 0) { if (!readBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { readBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { readBlock = null; }",
        "label":0
    },
    {
        "ins1CurCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a', 'b', 'b');",
        "ins1PreCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('h', 'd', 'a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'd', 'a', 'a', 'b', 'b');",
        "ins2PreCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('h', 'd', 'a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'd', 'a', 'a', 'b', 'b');",
        "label":1
    },
    {
        "ins1CurCode":"output.flush();  byte[] rawInput = rawOutput.toByteString().toByteArray(); for (InputType inputType : InputType.values()) { CodedInputStream input = inputType.newDecoder(rawInput); assertEquals(inputType.name(), tag, input.readTag()); String text = input.readString(); assertEquals(inputType.name(), lorem, text); }",
        "ins1PreCode":"output.flush();  CodedInputStream input = CodedInputStream.newInstance( new ByteArrayInputStream(rawOutput.toByteString().toByteArray())); assertEquals(tag, input.readTag()); String text = input.readString(); assertEquals(lorem, text);",
        "ins2PreCode":"output.flush();  CodedInputStream input = CodedInputStream.newInstance( new ByteArrayInputStream(rawOutput.toByteString().toByteArray())); assertEquals(tag, input.readTag()); String text = input.readStringRequireUtf8(); assertEquals(lorem, text);",
        "label":1
    },
    {
        "ins1CurCode":"JavaDStream<Integer> reversed = pairStream.map(Tuple2::_2); JavaTestUtils.attachTestOutputStream(reversed); List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 2, 2); ",
        "ins1PreCode":"JavaDStream<Integer> reversed = pairStream.map(Tuple2::_2); JavaTestUtils.attachTestOutputStream(reversed); List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2); ",
        "ins2PreCode":"public void testPairMap2() { List<List<Tuple2<String, Integer>>> inputData = stringIntKVStream;  List<List<Integer>> expected = Arrays.asList( Arrays.asList(1, 3, 4, 1), Arrays.asList(5, 5, 3, 1));  JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2());  JavaTestUtils.attachTestOutputStream(reversed); List<List<Integer>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "label":0
    },
    {
        "ins1CurCode":" if (result.getStatus() == Status.OK) { if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) { tasks(); }",
        "ins1PreCode":" if (result.getStatus() == Status.OK) { if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks(); } else {",
        "ins2PreCode":"public long write(ByteBuffer[] srcs, int offset, int length) throws IOException { checkInterruptStatus();  if (closing || closed) { throw new IOException(sm.getString(\"channel.nio.ssl.closing\")); }  if (!flush(netOutBuffer)) {  return 0; }   netOutBuffer.clear();  SSLEngineResult result = sslEngine.wrap(srcs, offset, length, netOutBuffer);  int written = result.bytesConsumed(); netOutBuffer.flip();  if (result.getStatus() == Status.OK) { if (result.getHandshakeStatus() == HandshakeStatus.NEED_TASK) tasks(); } else { throw new IOException(sm.getString(\"channel.nio.ssl.wrapFail\", result.getStatus())); }   flush(netOutBuffer);  return written;",
        "label":0
    },
    {
        "ins1CurCode":"Month m = new Month(2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-628444800000L, m.getFirstMillisecond(cal));   boolean pass = false; try { m.getFirstMillisecond((Calendar) null); }",
        "ins1PreCode":"Month m = new Month(2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-628444800000L, m.getFirstMillisecond(zone));   boolean pass = false; try { m.getFirstMillisecond((TimeZone) null); }",
        "ins2PreCode":"Month m = new Month(2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-626025600001L, m.getLastMillisecond(zone));   boolean pass = false; try { m.getLastMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedDelay()).isEmpty(); assertThat(tasks.getCustom()).isEmpty(); assertThat(tasks.getFixedRate()).hasSize(1);",
        "ins1PreCode":"assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedDelay()).isEmpty(); assertThat(tasks.getFixedRate()).hasSize(1); FixedRateTaskDescription description = (FixedRateTaskDescription) tasks",
        "ins2PreCode":"assertThat(tasks.getCron()).isEmpty(); assertThat(tasks.getFixedDelay()).isEmpty(); assertThat(tasks.getFixedRate()).hasSize(1); FixedRateTaskDescription description = (FixedRateTaskDescription) tasks",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1 = new StandardCategoryURLGenerator(); renderer.setSeriesItemURLGenerator(0, url1);",
        "label":1
    },
    {
        "ins1CurCode":"else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); }",
        "ins1PreCode":"else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context.get( ARTIFACT_ID ).toString(), context.get( CHILD_PATH_ADJUSTMENT ).toString() ) ); }",
        "ins2PreCode":"else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context.get( ARTIFACT_ID ).toString(), context.get( CHILD_PATH_ADJUSTMENT ).toString() ) ); }",
        "label":1
    },
    {
        "ins1CurCode":"TakeLast source = new TakeLast(to);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"TakeLast source = new TakeLast(to);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"TakeLast source = new TakeLast(to);  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"\"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "ins1PreCode":"\"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class));",
        "ins2PreCode":"\"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class));",
        "label":1
    },
    {
        "ins1CurCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(Tuple2::swap); ",
        "ins1PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair( new PairFunction<Tuple2<String, Integer>, Integer, String>() { @Override public Tuple2<Integer, String> call(Tuple2<String, Integer> in) { return in.swap(); } }); ",
        "ins2PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(x -> x.swap()); JavaTestUtils.attachTestOutputStream(reversed);",
        "label":0
    },
    {
        "ins1CurCode":"assertThatIllegalStateException().isThrownBy(context::refresh) .withMessageContaining(\"Unable to register mock bean \" + ExampleService.class.getName() + \" expected a single matching bean to replace but found [example1, example2]\");",
        "ins1PreCode":"assertThatIllegalStateException().isThrownBy(context::refresh) .withMessageContaining(\"Unable to register mock bean \" + ExampleService.class.getName() + \" expected a single matching bean to replace \" + \"but found [example1, example2]\");",
        "ins2PreCode":"assertThatIllegalStateException().isThrownBy(context::refresh) .withMessageContaining(\"Unable to register mock bean \" + ExampleService.class.getName() + \" expected a single matching bean to replace \" + \"but found [example1, example3]\");",
        "label":1
    },
    {
        "ins1CurCode":"protected UpdateByQueryRequest buildRequest(RestRequest request, NamedWriteableRegistry namedWriteableRegistry) throws IOException {      UpdateByQueryRequest internal = new UpdateByQueryRequest();  Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(Script.parse(o))); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));  parseInternalRequest(internal, request, namedWriteableRegistry, consumers); ",
        "ins1PreCode":"protected UpdateByQueryRequest buildRequest(RestRequest request) throws IOException {      UpdateByQueryRequest internal = new UpdateByQueryRequest();  Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(Script.parse(o))); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));  parseInternalRequest(internal, request, consumers); ",
        "ins2PreCode":"protected DeleteByQueryRequest buildRequest(RestRequest request) throws IOException {      DeleteByQueryRequest internal = new DeleteByQueryRequest();  Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));  parseInternalRequest(internal, request, consumers); ",
        "label":1
    },
    {
        "ins1CurCode":"void testMaxHistoryPropertyWithXmlConfiguration() { this.environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile); this.logger.info(\"Hello world\");",
        "ins1PreCode":"void testMaxHistoryPropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile); this.logger.info(\"Hello world\");",
        "ins2PreCode":"private void testTotalSizeCapProperty(String sizeValue, String expectedFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\");",
        "label":1
    },
    {
        "ins1CurCode":"+ getOpType(), Project.MSG_VERBOSE); } int result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { throw new BuildException(\"Failed executing: \" + commandLine, getLocation()); }",
        "ins1PreCode":"Commandline commandLine = new Commandline(); Project aProj = getProject(); int result = 0;   if (getViewPath() == null) { setViewPath(aProj.getBaseDir().getPath()); }     commandLine.setExecutable(getClearToolCommand()); commandLine.createArgument().setValue(COMMAND_LOCK);   checkOptions(commandLine);     if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getOpType(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "ins2PreCode":"Commandline commandLine = new Commandline(); Project aProj = getProject(); int result = 0;   if (getViewPath() == null) { setViewPath(aProj.getBaseDir().getPath()); }     commandLine.setExecutable(getClearToolCommand()); commandLine.createArgument().setValue(COMMAND_UNLOCK);   checkOptions(commandLine);     if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getOpType(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "label":1
    },
    {
        "ins1CurCode":"} try (JDBCSession session = DBUtils.openMetaSession(monitor, container, \"Read triggers\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement(\"SELECT TRIGGER_NAME FROM SYS.TRIGGERS WHERE SUBJECT_TABLE_SCHEMA=? AND SUBJECT_TABLE_NAME=?\")) { dbStat.setString(1, table.getSchema().getName()); dbStat.setString(2, table.getName()); List<GenericTrigger> result = new ArrayList<>();",
        "ins1PreCode":"} try (JDBCSession session = DBUtils.openMetaSession(monitor, container, \"Read triggers\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement(\"SELECT TRIGGER_NAME FROM SYS.TRIGGERS WHERE SUBJECT_TABLE_NAME=?\")) { dbStat.setString(1, table.getName()); List<GenericTrigger> result = new ArrayList<>();",
        "ins2PreCode":"public List<? extends GenericTrigger> loadTriggers(DBRProgressMonitor monitor, @NotNull GenericStructContainer container, @Nullable GenericTableBase table) throws DBException { if (table == null) { return Collections.emptyList(); } try (JDBCSession session = DBUtils.openMetaSession(monitor, container, \"Read triggers\")) { try (JDBCPreparedStatement dbStat = session.prepareStatement(\"SELECT name FROM sqlite_master WHERE type='trigger' AND tbl_name=?\")) { dbStat.setString(1, table.getName()); List<GenericTrigger> result = new ArrayList<>(); try (JDBCResultSet dbResult = dbStat.executeQuery()) { while (dbResult.next()) { String name = JDBCUtils.safeGetString(dbResult, 1); result.add(new GenericTrigger(container, table, name, null)); } } return result; } } catch (SQLException e) { throw new DBException(e, container.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins1PreCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins2PreCode":"public void tomcatNopLoggingConfigDoesNotCauseAFailure() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "label":1
    },
    {
        "ins1CurCode":"Object r = q.pop();  Assert.assertEquals(o1, r); Assert.assertNull(q.first); Assert.assertNull(q.last);",
        "ins1PreCode":"Object r = q.pop();  assertEquals(o1, r); assertNull(q.first); assertNull(q.last);",
        "ins2PreCode":"Object r = q.pop();  assertEquals(o1, r); assertNull(q.first); assertNull(q.last);",
        "label":1
    },
    {
        "ins1CurCode":"public boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) { throw new NullPointerException(); } long nanos = unit.toNanos(timeout); lock.lockInterruptibly(); try { while (!linkFirst(e)) { if (nanos <= 0) { return false;",
        "ins1PreCode":"public boolean offerFirst(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); lock.lockInterruptibly(); try { while (!linkFirst(e)) { if (nanos <= 0) return false;",
        "ins2PreCode":"public boolean offerLast(E e, long timeout, TimeUnit unit) throws InterruptedException { if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); lock.lockInterruptibly(); try { while (!linkLast(e)) { if (nanos <= 0) return false;",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XYBoxAndWhiskerRenderer r1 = new XYBoxAndWhiskerRenderer(); XYBoxAndWhiskerRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYBoxAndWhiskerRenderer r1 = new XYBoxAndWhiskerRenderer(); XYBoxAndWhiskerRenderer r2 = (XYBoxAndWhiskerRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer(); ClusteredXYBarRenderer r2 = (ClusteredXYBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorNonEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposables.empty()); ",
        "label":0
    },
    {
        "ins1CurCode":"return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtilities.equal(this.subplots, that.subplots)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtilities.equal(this.subplots, that.subplots)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"public void testAPIExample() throws InterruptedException { final int port = TEST_PORT + 1; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread(port); ",
        "ins1PreCode":"public void testAPIExample() throws InterruptedException {  ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.cc(\"cc1@you.com\"); testMailClient.cc(\"cc2@you.com\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc1@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc2@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"Cc: cc1@you.com, cc2@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\";                  assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result);",
        "ins2PreCode":"public void testToOnly() throws InterruptedException { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result);",
        "label":1
    },
    {
        "ins1CurCode":"JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.train(data.rdd(), features, iterations); validatePrediction(model, users, products, testData._2(), 0.3, false, testData._3());",
        "ins1PreCode":"JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.train(data.rdd(), features, iterations); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins2PreCode":"MatrixFactorizationModel model = new ALS().setRank(features) .setIterations(iterations) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "label":0
    },
    {
        "ins1CurCode":"public void blockingGetDefault() { final BlockingMultiObserver<Integer> bmo = new BlockingMultiObserver<>(); ",
        "ins1PreCode":"public void blockingGetDefault() { final BlockingMultiObserver<Integer> bmo = new BlockingMultiObserver<Integer>(); ",
        "ins2PreCode":"public void blockingAwait() { final BlockingMultiObserver<Integer> bmo = new BlockingMultiObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"this.errors = new AtomicThrowable(); this.active = new AtomicInteger(1); this.queue = new AtomicReference<>();",
        "ins1PreCode":"this.errors = new AtomicThrowable(); this.active = new AtomicInteger(1); this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();",
        "ins2PreCode":"this.errors = new AtomicThrowable(); this.active = new AtomicInteger(1); this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();",
        "label":1
    },
    {
        "ins1CurCode":"}  if (numFields == 0) { return; }   for (int i = 0; i < (numFields - 1); i++) { insertFieldQuery.append(\", (?, ?, ?)\");",
        "ins1PreCode":"}  for (int i = 0; i < numFields - 1; i++) { insertFieldQuery.append(\", (?, ?, ?)\");",
        "ins2PreCode":"protected void insertIntoFieldTable(List<BibEntry> bibEntries) { try {   List<List<Field>> fields = bibEntries.stream().map(entry -> new ArrayList<>(entry.getFields())) .collect(Collectors.toList()); StringBuilder insertFieldQuery = new StringBuilder() .append(\"INSERT ALL\"); int numFields = 0; for (List<Field> entryFields : fields) { numFields += entryFields.size(); } for (int i = 0; i < numFields; i++) { insertFieldQuery.append(\" INTO \") .append(escape(\"FIELD\")) .append(\" (\") .append(escape(\"ENTRY_SHARED_ID\")) .append(\", \") .append(escape(\"NAME\")) .append(\", \") .append(escape(\"VALUE\")) .append(\") VALUES (?, ?, ?)\"); } insertFieldQuery.append(\" SELECT * FROM DUAL\"); try (PreparedStatement preparedFieldStatement = connection.prepareStatement(insertFieldQuery.toString())) { int fieldsCompleted = 0; for (int entryIndex = 0; entryIndex < fields.size(); entryIndex++) { for (int entryFieldsIndex = 0; entryFieldsIndex < fields.get(entryIndex).size(); entryFieldsIndex++) {  preparedFieldStatement.setInt((3 * fieldsCompleted) + 1, bibEntries.get(entryIndex).getSharedBibEntryData().getSharedID()); preparedFieldStatement.setString((3 * fieldsCompleted) + 2, fields.get(entryIndex).get(entryFieldsIndex).getName()); preparedFieldStatement.setString((3 * fieldsCompleted) + 3, bibEntries.get(entryIndex).getField(fields.get(entryIndex).get(entryFieldsIndex)).get()); fieldsCompleted += 1; } } preparedFieldStatement.executeUpdate();            } } catch (SQLException e) { LOGGER.error(\"SQL Error: \", e); }",
        "label":0
    },
    {
        "ins1CurCode":"public static <@NonNull T, @NonNull R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<@NonNull ? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T, R> Flowable<R> zipArray(@NonNull Function<? super Object[], ? extends R> zipper, boolean delayError, int bufferSize, @NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "label":1
    },
    {
        "ins1CurCode":"} catch (final ClassNotFoundException e) { throw new BuildException( \"The <classpath> or <modulepath> for <junit> must include junit.jar \" + \"if not in Ant's own classpath\",",
        "ins1PreCode":"} catch (final ClassNotFoundException e) { throw new BuildException( \"The <classpath> for <junit> must include junit.jar \" + \"if not in Ant's own classpath\",",
        "ins2PreCode":"private static FTPTaskMirror createMirror(FTPTask task, ClassLoader loader) { try { loader.loadClass(\"org.apache.commons.net.ftp.FTP\"); } catch (ClassNotFoundException e) { throw new BuildException(\"The <classpath> for <ftp> must include\" + \" commons-net.jar if not in Ant's own \" + \" classpath\", e, task.getLocation()); } try { Class c = loader.loadClass(FTPTaskMirror.class.getName() + \"Impl\"); if (c.getClassLoader() != loader) { throw new BuildException(\"Overdelegating loader\", task.getLocation()); } Constructor cons = c.getConstructor(new Class[] {FTPTask.class}); return (FTPTaskMirror) cons.newInstance(new Object[] {task}); } catch (Exception e) { throw new BuildException(e, task.getLocation()); }",
        "label":0
    },
    {
        "ins1CurCode":"protected synchronized int doWrite(boolean block) throws IOException { if (!writeBufferFlipped) { socketWriteBuffer.flip();",
        "ins1PreCode":"protected synchronized int doWrite(boolean block, boolean flip) throws IOException { if (flip) { socketWriteBuffer.flip();",
        "ins2PreCode":"private int fillReadBuffer(boolean block) throws IOException { int nRead; NioChannel channel = getSocket(); if (block) { Selector selector = null; try { selector = pool.get(); } catch ( IOException x ) {  } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel.getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(channel.getBufHandler().getReadBuffer(), channel, selector, att.getTimeout()); } catch (EOFException eof) { nRead = -1; } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(channel.getBufHandler().getReadBuffer()); } return nRead;",
        "label":0
    },
    {
        "ins1CurCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull R> Maybe<R> zip( @NonNull MaybeSource<? extends T1> source1, @NonNull MaybeSource<? extends T2> source2, @NonNull MaybeSource<? extends T3> source3,",
        "ins1PreCode":"public static <T1, T2, T3, R> Maybe<R> zip( @NonNull MaybeSource<? extends T1> source1, @NonNull MaybeSource<? extends T2> source2, @NonNull MaybeSource<? extends T3> source3,",
        "ins2PreCode":"public static <T1, T2, T3, R> Single<R> zip( @NonNull SingleSource<? extends T1> source1, @NonNull SingleSource<? extends T2> source2,",
        "label":1
    },
    {
        "ins1CurCode":"U u; try { u = Objects.requireNonNull(initialSupplier.get(), \"The initial value supplied is null\"); } catch (Throwable e) {",
        "ins1PreCode":"U u; try { u = ObjectHelper.requireNonNull(initialSupplier.get(), \"The initial value supplied is null\"); } catch (Throwable e) {",
        "ins2PreCode":" try { r = ObjectHelper.requireNonNull(seedSupplier.get(), \"The seed supplied is null\"); } catch (Throwable e) {",
        "label":1
    },
    {
        "ins1CurCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = (String)o;\"));",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((short)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = Short.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Short o = null; String n = (String)o;\"));",
        "ins2PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = Character.valueOf((char)0); String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = null; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = Short.valueOf((byte)0); String n = (String)o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"Character o = null; String n = (String)o;\"));",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"public void testTypedAggregationSumDouble() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sum(value -> (double) value._2())); Assert.assertEquals(",
        "ins1PreCode":"public void testTypedAggregationSumDouble() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.sum(value -> (double) value._2())); Assert.assertEquals(",
        "ins2PreCode":"public void testTypedAggregationSumDouble() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.sum(v -> (double)v._2())); Assert.assertEquals(",
        "label":1
    },
    {
        "ins1CurCode":"if (descriptor.isRepeated()) { if (descriptor.getLiteJavaType() == WireFormat.JavaType.ENUM) { final List result = new ArrayList<>(); for (final Object element : (List) value) {",
        "ins1PreCode":"if (descriptor.isRepeated()) { if (descriptor.getLiteJavaType() == WireFormat.JavaType.ENUM) { final List result = new ArrayList(); for (final Object element : (List) value) {",
        "ins2PreCode":"if (descriptor.isRepeated()) { if (descriptor.getLiteJavaType() == WireFormat.JavaType.ENUM) { final List result = new ArrayList(); for (final Object element : (List) value) {",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValue() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void assertValue() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void assertValue() { TestObserver<Integer> to = TestObserver.create();  to.onSubscribe(Disposable.empty());  try { to.assertValue(1); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  to.onNext(1);  to.assertValue(1);  try { to.assertValue(2); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }  to.onNext(2);  try { to.assertValue(1); throw new RuntimeException(\"Should have thrown\"); } catch (Throwable ex) {  }",
        "label":0
    },
    {
        "ins1CurCode":"final MaybeSubject<Integer> cs = MaybeSubject.create();  final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<>(0)); ",
        "ins1PreCode":"final MaybeSubject<Integer> cs = MaybeSubject.create();  final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<Integer>(0)); ",
        "ins2PreCode":"final SingleSubject<Integer> cs = SingleSubject.create();  final TestSubscriber<Integer> ts = pp.mergeWith(cs).subscribeWith(new TestSubscriber<Integer>(0)); ",
        "label":1
    },
    {
        "ins1CurCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = jsc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.trainImplicit(data.rdd(), features, iterations);",
        "ins1PreCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.trainImplicit(data.rdd(), features, iterations);",
        "ins2PreCode":"ALSSuite.generateRatingsAsJava(users, products, features, 0.7, true, false);  JavaRDD<Rating> data = sc.parallelize(testData._1()); ",
        "label":1
    },
    {
        "ins1CurCode":"} if (block) { long timeout = getWriteTimeout(); try { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { if (blockWriteDone == null) { blockWriteDone = new AtomicBoolean(false); } else { blockWriteDone.set(false); } registerWriteInterest(); synchronized (blockWriteDone) { if (!blockWriteDone.get()) { try { if (timeout > 0) { blockWriteDone.wait(timeout); } else { blockWriteDone.wait(); } } catch (InterruptedException e) {  } if (!blockWriteDone.get()) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { blockWriteDone = null; }",
        "ins1PreCode":"} if (block) { long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(from, socket, selector, writeTimeout);  do { } while (!socket.flush(true, selector, writeTimeout)); } finally { if (selector != null) { pool.put(selector); }",
        "ins2PreCode":"throw new ClosedChannelException(); } if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { nRead = pool.read(to, socket, selector, getReadTimeout()); } finally { if (selector != null) { pool.put(selector); }",
        "label":0
    },
    {
        "ins1CurCode":" ContainerRequestEvent event1 = ContainerRequestCreator.createRequest(jobId, 1, Resource.newInstance(1024, 1), new String[]{\"h1\"}); allocator.sendRequest(event1); ContainerRequestEvent event2 = ContainerRequestCreator.createRequest(jobId, 2, Resource.newInstance(1024, 1), new String[]{\"h2\"}); allocator.sendRequest(event2); ContainerRequestEvent event3 = createRequest(jobId, 3, Resource.newInstance(1024, 1), new String[]{\"h2\"}, false, true); allocator.sendRequest(event3);    allocator.schedule(); rm.drainEvents();   clock.setTime(System.currentTimeMillis() + 500000L);   ContainerRequestEvent event4 = createRequest(jobId, 4, Resource.newInstance(1024, 1), new String[] {\"h3\"}, false, true); allocator.sendRequest(event4);",
        "ins1PreCode":" ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[] { \"h1\" }); allocator.sendRequest(event1); ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[] { \"h2\" }); allocator.sendRequest(event2); ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[] { \"h2\" }, false, true); allocator.sendRequest(event3);    allocator.schedule(); rm.drainEvents();   clock.setTime(System.currentTimeMillis() + 500000L);   ContainerRequestEvent event4 = createReq(jobId, 4, 1024, new String[] { \"h3\" }, false, true); allocator.sendRequest(event4);",
        "ins2PreCode":" ContainerRequestEvent event1 = createReq(jobId, 1, 1024, new String[] { \"h1\" }); allocator.sendRequest(event1); ContainerRequestEvent event2 = createReq(jobId, 2, 1024, new String[] { \"h2\" }); allocator.sendRequest(event2); ContainerRequestEvent event3 = createReq(jobId, 3, 1024, new String[] { \"h2\" }, false, true); allocator.sendRequest(event3);    allocator.schedule(); rm.drainEvents();   clock.setTime(System.currentTimeMillis() + 500000L);   ContainerRequestEvent event4 = createReq(jobId, 4, 1024, new String[] { \"h3\" }, false, true); allocator.sendRequest(event4);",
        "label":1
    },
    {
        "ins1CurCode":"rb2.setUdpPort(50000); channel2.addChannelListener(listener1); TesterUtil.addRandomDomain(new ManagedChannel[] {channel1, channel2}); channel1.start(Channel.DEFAULT);",
        "ins1PreCode":"rb2.setUdpPort(50000); channel2.addChannelListener(listener1); channel1.start(Channel.DEFAULT); channel2.start(Channel.DEFAULT);",
        "ins2PreCode":"rb2.setUdpPort(50000); channel2.addChannelListener(listener1); channel1.start(Channel.DEFAULT); channel2.start(Channel.DEFAULT);",
        "label":1
    },
    {
        "ins1CurCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) d1.clone(); assertTrue(d1 != d2);",
        "label":0
    },
    {
        "ins1CurCode":"String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; assertThatExceptionOfType(CloudFoundryAuthorizationException.class) .isThrownBy(() -> this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .satisfies(reasonRequirement(Reason.TOKEN_EXPIRED));",
        "ins1PreCode":"String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.TOKEN_EXPIRED)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "ins2PreCode":"String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"foo.bar\\\"]}\"; this.thrown.expect( AuthorizationExceptionMatcher.withReason(Reason.INVALID_AUDIENCE)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "label":1
    },
    {
        "ins1CurCode":"void shutdownWhenOwnsSchedulerDoesShutdownScheduler() { PushGatewayTaskScheduler ownedScheduler = givenScheduleAtFixedRateWillReturnFuture( mock(PushGatewayTaskScheduler.class)); PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "ins1PreCode":"void shutdownWhenOwnsSchedulerDoesShutdownScheduler() { PushGatewayTaskScheduler ownedScheduler = mockScheduler(PushGatewayTaskScheduler.class); PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "ins2PreCode":"void shutdownWhenDoesNotOwnSchedulerDoesNotShutdownScheduler() { ThreadPoolTaskScheduler otherScheduler = mockScheduler(ThreadPoolTaskScheduler.class); PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "label":1
    },
    {
        "ins1CurCode":"if (oldValue == null) { if (greenForIncrease) { plot.setSectionPaint(key, Color.GREEN); } else { plot.setSectionPaint(key, Color.RED); }",
        "ins1PreCode":"if (oldValue == null) { if (greenForIncrease) { plot.setSectionPaint(key, Color.green); } else { plot.setSectionPaint(key, Color.red); }",
        "ins2PreCode":"if (oldValue == null) { if (greenForIncrease) { plot.setSectionPaint(key, Color.green); } else { plot.setSectionPaint(key, Color.red); }",
        "label":1
    },
    {
        "ins1CurCode":" assertTrue(answer.size() == 2); assertEquals(Integer.valueOf(4), answer.get(0).get(\"ID\")); assertEquals(Integer.valueOf(6), answer.get(1).get(\"ID\")); }",
        "ins1PreCode":" assertTrue(answer.size() == 2); assertEquals(new Integer(4), answer.get(0).get(\"ID\")); assertEquals(new Integer(6), answer.get(1).get(\"ID\")); }",
        "ins2PreCode":"List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.ognlStaticMethodCall\", \"Rock 'n Roll\"); assertTrue(answer.size() == 1); assertEquals(new Integer(7), answer.get(0).get(\"ID\")); }",
        "label":0
    },
    {
        "ins1CurCode":" if (getSosServerPath() == null) { throw new BuildException(\"sosserverpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_SERVER); commandLine.createArgument().setValue(getSosServerPath());  if (getUsername() == null) { throw new BuildException(\"username attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_USERNAME); commandLine.createArgument().setValue(getUsername());   commandLine.createArgument().setValue(SOSCmd.FLAG_PASSWORD); commandLine.createArgument().setValue(getPassword());  if (getVssServerPath() == null) { throw new BuildException(\"vssserverpath attribute must be set!\", getLocation()); } commandLine.createArgument().setValue(SOSCmd.FLAG_VSS_SERVER); commandLine.createArgument().setValue(getVssServerPath());  if (getProjectPath() == null) { throw new BuildException(\"projectpath attribute must be set!\", getLocation()); }",
        "ins1PreCode":" if (getSosServerPath() == null) { throw new BuildException(\"sosserverpath attribute must be set!\", location); } commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_SERVER); commandLine.createArgument().setValue(getSosServerPath());  if (getUsername() == null) { throw new BuildException(\"username attribute must be set!\", location); } commandLine.createArgument().setValue(SOSCmd.FLAG_USERNAME); commandLine.createArgument().setValue(getUsername());   commandLine.createArgument().setValue(SOSCmd.FLAG_PASSWORD); commandLine.createArgument().setValue(getPassword());  if (getVssServerPath() == null) { throw new BuildException(\"vssserverpath attribute must be set!\", location); } commandLine.createArgument().setValue(SOSCmd.FLAG_VSS_SERVER); commandLine.createArgument().setValue(getVssServerPath());  if (getProjectPath() == null) { throw new BuildException(\"projectpath attribute must be set!\", location); }",
        "ins2PreCode":" if (getSosServerPath() == null) { throw new BuildException(\"sosserverpath attribute must be set!\", location); } commandLine.createArgument().setValue(SOSCmd.FLAG_SOS_SERVER); commandLine.createArgument().setValue(getSosServerPath());  if (getUsername() == null) { throw new BuildException(\"username attribute must be set!\", location); } commandLine.createArgument().setValue(SOSCmd.FLAG_USERNAME); commandLine.createArgument().setValue(getUsername());   commandLine.createArgument().setValue(SOSCmd.FLAG_PASSWORD); commandLine.createArgument().setValue(getPassword());  if (getVssServerPath() == null) { throw new BuildException(\"vssserverpath attribute must be set!\", location); } commandLine.createArgument().setValue(SOSCmd.FLAG_VSS_SERVER); commandLine.createArgument().setValue(getVssServerPath());  if (getProjectPath() == null) { throw new BuildException(\"projectpath attribute must be set!\", location); }",
        "label":1
    },
    {
        "ins1CurCode":"public void takeFlatMapCompletes() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void takeFlatMapCompletes() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void takeFlatMapCompletes() { TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public final Flowable<T> skipLast(long time, @NonNull TimeUnit unit, @NonNull Scheduler scheduler, boolean delayError, int bufferSize) { Objects.requireNonNull(unit, \"unit is null\"); Objects.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");  int s = bufferSize << 1; return RxJavaPlugins.onAssembly(new FlowableSkipLastTimed<>(this, time, unit, scheduler, s, delayError));",
        "ins1PreCode":"public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) { Objects.requireNonNull(unit, \"unit is null\"); Objects.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");  int s = bufferSize << 1; return RxJavaPlugins.onAssembly(new FlowableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));",
        "ins2PreCode":" int s = bufferSize << 1; return RxJavaPlugins.onAssembly(new ObservableSkipLastTimed<T>(this, time, unit, scheduler, s, delayError));",
        "label":0
    },
    {
        "ins1CurCode":"System.out.println(\"JSP strict whitespace: [\" +  w.getInitParameter(\"strictWhitespace\") + \"]\");  File tmpJsp = new File(\"test/webapp/bug49nnn/bug49297NoSpace.jsp\"); System.out.println(\".jsp [\" + tmpJsp.lastModified() + \"]\");  File tmp = (File) ctxt.getServletContext().getAttribute(ServletContext.TEMPDIR); File tmpJava = new File(tmp, \"org/apache/jsp/bug49nnn/bug49297NoSpace_jsp.java\"); File tmpClass = new File(tmp, \"org/apache/jsp/bug49nnn/bug49297NoSpace_jsp.class\"); System.out.println(\"before request  .java [\" + tmpJava.lastModified() + \"]\"); System.out.println(\"before request .class [\" + tmpClass.lastModified() + \"]\");   ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297NoSpace.jsp\", res, null);   System.out.println(\"after request  .java [\" + tmpJava.lastModified() + \"]\"); System.out.println(\"after request .class [\" + tmpClass.lastModified() + \"]\"); ",
        "ins1PreCode":"System.out.println(\"JSP strict whitespace: [\" +  w.getInitParameter(\"strictWhitespace\") + \"]\");   ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297NoSpace.jsp\", res, null);  Assert.assertEquals(200, sc); assertEcho(res.toString(), \"Hello World\");",
        "ins2PreCode":"public void testBug49297MultipleImport1() throws Exception { getTomcatInstanceTestWebapp(false, true);  ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297MultipleImport1.jsp\", res, null);  Assert.assertEquals(200, sc); assertEcho(res.toString(), \"OK\");",
        "label":0
    },
    {
        "ins1CurCode":"try { synchronized (getSocket()) { if (getSocket().isOpen()) { getSocket().close(true);",
        "ins1PreCode":"try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) {",
        "ins2PreCode":"try { synchronized (getSocket()) { getEndpoint().countDownConnection(); if (getSocket().isOpen()) {",
        "label":1
    },
    {
        "ins1CurCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.name=target/foo.log\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins1PreCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file=target/foo.log\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins2PreCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.path=target/foo/\"); this.initializer.initialize(this.context.getEnvironment(),",
        "label":0
    },
    {
        "ins1CurCode":"DiagramSettings settings) { if (!Model.getFacade().isANamespace(namespace)) { LOG.log(Level.SEVERE, \"No namespace as argument {0}\",namespace);  throw new IllegalArgumentException(",
        "ins1PreCode":"DiagramSettings settings) { if (!Model.getFacade().isANamespace(namespace)) { LOG.error(\"No namespace as argument\"); LOG.error(namespace); throw new IllegalArgumentException(",
        "ins2PreCode":" if (!Model.getFacade().isANamespace(namespace)) { LOG.error(\"No namespace as argument\"); LOG.error(namespace); throw new IllegalArgumentException(",
        "label":1
    },
    {
        "ins1CurCode":"public UMLTextArea(UMLPlainTextDocument doc) { super(doc);",
        "ins1PreCode":"public UMLTextArea(UMLDocument doc) { super(doc);",
        "ins2PreCode":"public UMLTextArea2(UMLDocument doc) { super(doc); setFont(LookAndFeelMgr.getInstance().getStandardFont()); addCaretListener(ActionCopy.getInstance()); addCaretListener(ActionCut.getInstance()); addCaretListener(ActionPaste.getInstance()); addFocusListener(ActionPaste.getInstance());",
        "label":0
    },
    {
        "ins1CurCode":"public void exceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new RuntimeException(\"BAD\"); }); this.filter.doFilter(this.request, this.response, this.chain);",
        "ins1PreCode":"public void exceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new RuntimeException(\"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "ins2PreCode":"public void subClassExceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new IllegalStateException(\"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "label":1
    },
    {
        "ins1CurCode":"  Set<String> optional = new HashSet<>(); optional.add(\".svn\");  optional.add(\".ignore-me.txt\");  for (String result : results) { Assert.assertTrue(result, expected.remove(result) || optional.remove(result)); }",
        "ins1PreCode":" for (String result : results) { Assert.assertTrue(result, expected.remove(result)); }",
        "ins2PreCode":" for (String result : results) { Assert.assertTrue(result, expected.remove(result)); }",
        "label":1
    },
    {
        "ins1CurCode":"JDBCStatement dbStat = session.createStatement();  dbStat.setQueryString(sql); ",
        "ins1PreCode":"JDBCStatement dbStat = session.createStatement();  ((JDBCStatementImpl) dbStat).setQueryString(sql); ",
        "ins2PreCode":"protected JDBCStatement prepareObjectsStatement(JDBCSession session, ExasolSchema exasolSchema, ExasolTable forTable) throws SQLException {  String sql; if (forTable != null) { sql = String.format(SQL_UK_TAB,ExasolUtils.quoteString(exasolSchema.getName()), ExasolUtils.quoteString(forTable.getName()),ExasolUtils.quoteString(exasolSchema.getName()), ExasolUtils.quoteString(forTable.getName())); } else { sql = String.format(SQL_UK_ALL,ExasolUtils.quoteString(exasolSchema.getName()),ExasolUtils.quoteString(exasolSchema.getName())); }  JDBCStatement dbStat = session.createStatement();  ((JDBCStatementImpl) dbStat).setQueryString(sql);  return dbStat; ",
        "label":0
    },
    {
        "ins1CurCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<>(observer); ",
        "ins1PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); ",
        "ins2PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer);  @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2)); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "label":1
    },
    {
        "ins1CurCode":"public void appendOnlyLinkedArrayListForEachWhileExact() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<>(3);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<>(); ",
        "ins1PreCode":"public void appendOnlyLinkedArrayListForEachWhileExact() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(3);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void appendOnlyLinkedArrayListForEachWhileAll() throws Exception { AppendOnlyLinkedArrayList<Integer> list = new AppendOnlyLinkedArrayList<Integer>(2);  list.add(1); list.add(2); list.add(3);  final List<Integer> out = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), new Double(4.0), new Double(0.5), null, new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins2PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), new Double(4.0), new Double(0.5), new Double(4.5), null, new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "label":0
    },
    {
        "ins1CurCode":" for (String index : docs.keySet()) { assertHitCount(client().prepareSearch(index).setSize(0).get(), 0); }",
        "ins1PreCode":" for (String index : docs.keySet()) { assertHitCount(client().prepareSearch(index).setTypes(\"test\").setSize(0).get(), 0); }",
        "ins2PreCode":"public void testMultipleSources() throws Exception { int sourceIndices = between(2, 5);  Map<String, List<IndexRequestBuilder>> docs = new HashMap<>(); for (int sourceIndex = 0; sourceIndex < sourceIndices; sourceIndex++) { String indexName = \"test\" + sourceIndex; docs.put(indexName, new ArrayList<>()); int numDocs = between(5, 15); for (int i = 0; i < numDocs; i++) { docs.get(indexName).add(client().prepareIndex(indexName, \"test\", Integer.toString(i)).setSource(\"foo\", \"a\")); } }  List<IndexRequestBuilder> allDocs = docs.values().stream().flatMap(Collection::stream).collect(Collectors.toList()); indexRandom(true, allDocs); for (Map.Entry<String, List<IndexRequestBuilder>> entry : docs.entrySet()) { assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().size()); }  int slices = randomSlices(1, 10); int expectedSlices = expectedSliceStatuses(slices, docs.keySet());  String[] sourceIndexNames = docs.keySet().toArray(new String[docs.size()]); BulkByScrollResponse response = updateByQuery().source(sourceIndexNames).refresh(true).setSlices(slices).get(); assertThat(response, matcher().updated(allDocs.size()).slices(hasSize(expectedSlices)));  for (Map.Entry<String, List<IndexRequestBuilder>> entry : docs.entrySet()) { String index = entry.getKey(); List<IndexRequestBuilder> indexDocs = entry.getValue(); int randomDoc = between(0, indexDocs.size() - 1); assertEquals(2, client().prepareGet(index, \"test\", Integer.toString(randomDoc)).get().getVersion()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void removeEdge_oneOfMany() { assume().that(graphIsMutable()).isTrue();  putEdge(N1, N2); putEdge(N1, N3); putEdge(N1, N4); assertThat(graphAsMutableGraph.removeEdge(N1, N3)).isTrue(); assertThat(graph.adjacentNodes(N1)).containsExactly(N2, N4);",
        "ins1PreCode":"putEdge(N1, N3); putEdge(N1, N4); assertThat(graph.removeEdge(N1, N3)).isTrue(); assertThat(graph.adjacentNodes(N1)).containsExactly(N2, N4);",
        "ins2PreCode":"putEdge(N1, N3); putEdge(N1, N4); assertThat(graph.removeEdge(N1, N3)).isTrue(); assertThat(graph.adjacentNodes(N1)).containsExactly(N2, N4);",
        "label":1
    },
    {
        "ins1CurCode":"}  final List<Thread> threads = new ArrayList<>(); for (int i = 0; i < count; i++) {",
        "ins1PreCode":"}  final List<Thread> threads = new ArrayList<Thread>(); for (int i = 0; i < count; i++) {",
        "ins2PreCode":"}));  final List<Thread> threads = new ArrayList<Thread>(); for (int i = 0; i < count; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"public void propertiesFileEnhancesEnvironment() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins1PreCode":"public void propertiesFileEnhancesEnvironment() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins2PreCode":"public void emptyCommandLinePropertySourceNotAdded() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":1
    },
    {
        "ins1CurCode":"} catch (final IOException e) { throw new RuntimeException( \"Serializing to a byte array threw an IOException (should never happen).\", e); }",
        "ins1PreCode":"} catch (final IOException e) { throw new RuntimeException( \"Serializing to a byte array threw an IOException \" + \"(should never happen).\", e); }",
        "ins2PreCode":"public byte[] toByteArray() { try { final byte[] result = new byte[getSerializedSize()]; final CodedOutputStream output = CodedOutputStream.newInstance(result); writeTo(output); output.checkNoSpaceLeft(); return result; } catch (IOException e) { throw new RuntimeException(getSerializingExceptionMessage(\"byte array\"), e); }",
        "label":0
    },
    {
        "ins1CurCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestObserver<Integer> to = new TestObserver<>(); List<Observable<Integer>> sourceList = new ArrayList<>(i); Set<Integer> expected = new HashSet<>(i); for (int j = 1; j <= i; j++) { sourceList.add(Observable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Observable.merge(sourceList, i).subscribe(to);  to.awaitDone(1, TimeUnit.SECONDS); to.assertNoErrors(); Set<Integer> actual = new HashSet<>(to.values()); ",
        "ins1PreCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestObserver<Integer> to = new TestObserver<Integer>(); List<Observable<Integer>> sourceList = new ArrayList<Observable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Observable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Observable.merge(sourceList, i).subscribe(to);  to.awaitDone(1, TimeUnit.SECONDS); to.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(to.values()); ",
        "ins2PreCode":"break; } TestObserver<Integer> to = new TestObserver<Integer>(); List<Observable<Integer>> sourceList = new ArrayList<Observable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Observable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Observable.merge(sourceList, i - 1).subscribe(to);  to.awaitDone(1, TimeUnit.SECONDS); to.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(to.values()); ",
        "label":1
    },
    {
        "ins1CurCode":"  validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);",
        "ins1PreCode":"  List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > 0); assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);",
        "ins2PreCode":"  List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > 0); assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);",
        "label":1
    },
    {
        "ins1CurCode":"void shouldFlushAllItemsOnDemand() { Cache cache = new LruCache(new PerpetualCache(\"default\"));",
        "ins1PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new LruCache(new PerpetualCache(\"default\"));",
        "ins2PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new PerpetualCache(\"DefaultCache\");",
        "label":1
    },
    {
        "ins1CurCode":" TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Month m1 = new Month(new Date(951868799999L), zone); Month m2 = new Month(new Date(951868800000L), zone);  assertEquals(MonthConstants.FEBRUARY, m1.getMonth()); assertEquals(951868799999L, m1.getLastMillisecond(cal));  assertEquals(MonthConstants.MARCH, m2.getMonth()); assertEquals(951868800000L, m2.getFirstMillisecond(cal)); ",
        "ins1PreCode":" assertEquals(MonthConstants.FEBRUARY, m1.getMonth()); assertEquals(951868799999L, m1.getLastMillisecond(zone));  assertEquals(MonthConstants.MARCH, m2.getMonth()); assertEquals(951868800000L, m2.getFirstMillisecond(zone)); ",
        "ins2PreCode":" TimeZone zone = TimeZone.getTimeZone(\"Pacific/Auckland\"); Month m1 = new Month(new Date(951821999999L), zone); Month m2 = new Month(new Date(951822000000L), zone);  assertEquals(MonthConstants.FEBRUARY, m1.getMonth()); assertEquals(951821999999L, m1.getLastMillisecond(zone));  assertEquals(MonthConstants.MARCH, m2.getMonth()); assertEquals(951822000000L, m2.getFirstMillisecond(zone)); ",
        "label":0
    },
    {
        "ins1CurCode":"void lombokSimplePropertyWithOnlyGetterOnFieldShouldNotBeExposed() throws IOException { process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void lombokSimplePropertyWithOnlyGetterOnFieldShouldNotBeExposed() throws IOException { process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokSimplePropertyWithOnlySetterOnFieldShouldNotBeExposed() throws IOException { process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":" result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString();",
        "ins1PreCode":" result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString();",
        "ins2PreCode":" int result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString();",
        "label":0
    },
    {
        "ins1CurCode":"items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(FINE, \"Failed to resolve class\", e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(FINE, \"Failed to resolve class\", e); RobustReflectionConverter.addErrorInContext(context, e);",
        "ins1PreCode":"items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e);",
        "ins2PreCode":"collection.add(item); } catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e);",
        "label":1
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":"void oneElement() { repository.addCustomAbbreviation(new Abbreviation(\"Long Name\", \"L. N.\")); assertEquals(1, repository.getCustomAbbreviations().size()); ",
        "ins1PreCode":"public void oneElement() { JournalAbbreviationRepository repository = new JournalAbbreviationRepository(); repository.addEntry(new Abbreviation(\"Long Name\", \"L. N.\")); assertEquals(1, repository.size()); assertFalse(repository.getAbbreviations().isEmpty()); ",
        "ins2PreCode":"public void oneElementWithShortestUniqueAbbreviation() { JournalAbbreviationRepository repository = new JournalAbbreviationRepository(); repository.addEntry(new Abbreviation(\"Long Name\", \"L. N.\", \"LN\")); assertEquals(1, repository.size()); assertFalse(repository.getAbbreviations().isEmpty()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void blockingSubscribeConsumerConsumerAction() { final List<Object> list = new ArrayList<>(); ",
        "ins1PreCode":"public void blockingSubscribeConsumerConsumerAction() { final List<Object> list = new ArrayList<Object>(); ",
        "ins2PreCode":"public void blockingSubscribeConsumerConsumerAction() { final List<Object> list = new ArrayList<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"  if (!getFailOnErr()) { getProject().log(\"Ignoring any errors that occur for: \" + getOpType(), Project.MSG_VERBOSE); } result = run(commandLine); if (Execute.isFailure(result) && getFailOnErr()) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "ins1PreCode":"  System.out.println(commandLine.toString());  result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, location); }",
        "ins2PreCode":"  System.out.println(commandLine.toString());  result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, location); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testPoolThreads20Connections10() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(false);",
        "ins1PreCode":"public void testPoolThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", null, config); ",
        "ins1PreCode":"config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config); ",
        "ins2PreCode":"config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoLite2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config);   assertNull(databaseReaders.get(\"GeoLite2-City.mmdb\").databaseReader.get()); city.execute(document);  assertNotNull(databaseReaders.get(\"GeoLite2-City.mmdb\").databaseReader.get());  config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoLite2-Country.mmdb\"); final GeoIpProcessor country = factory.create(null, \"_tag\", config);   assertNull(databaseReaders.get(\"GeoLite2-Country.mmdb\").databaseReader.get()); country.execute(document);  assertNotNull(databaseReaders.get(\"GeoLite2-Country.mmdb\").databaseReader.get());  config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoLite2-ASN.mmdb\"); final GeoIpProcessor asn = factory.create(null, \"_tag\", config); ",
        "label":0
    },
    {
        "ins1CurCode":"entry.setField(StandardField.TITLE, \"test title\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( Arrays.asList( new LinkedFile(\"\", Path.of(\"\"), \"\"), new LinkedFile(\"\", path.toAbsolutePath(), \"\"), new LinkedFile(\"\", Path.of(\"\"), \"\"))));  when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey] - [fulltitle]\"); cleanup.cleanup(entry);  assertEquals(Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList( new LinkedFile(\"\", Path.of(\"\"), \"\"), new LinkedFile(\"\", Path.of(\"Toot - test title.tmp\"), \"\"), new LinkedFile(\"\", Path.of(\"\"), \"\")))), entry.getField(StandardField.FILE));",
        "ins1PreCode":"entry.setField(StandardField.TITLE, \"test title\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"), new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey] - [fulltitle]\"); cleanup.cleanup(entry);  assertEquals( Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"Toot - test title.tmp\", \"\"), new LinkedFile(\"\", \"\", \"\")))), entry.getField(StandardField.FILE));",
        "ins2PreCode":"void movesFileWithMulitpleLinked() throws Exception { LinkedFile fileField = new LinkedFile(\"\", fileBefore.toAbsolutePath().toString(), \"\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), fileField, new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileDirectoryPattern()).thenReturn(\"\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"test.pdf\", \"\"), new LinkedFile(\"\", \"\", \"\")))), entry.getField(StandardField.FILE));",
        "label":1
    },
    {
        "ins1CurCode":"(catalog == null ? \"\" : \" AND \" + MySQLConstants.COL_TABLE_SCHEMA + \"=?\") + \" ORDER BY \" + MySQLConstants.COL_TABLE_NAME + \" LIMIT \" + maxResults)) { dbStat.setString(1, tableNameMask.toLowerCase(Locale.ENGLISH)); if (catalog != null) {",
        "ins1PreCode":"(catalog == null ? \"\" : \" AND \" + MySQLConstants.COL_TABLE_SCHEMA + \"=?\") + \" ORDER BY \" + MySQLConstants.COL_TABLE_NAME + \" LIMIT \" + maxResults)) { dbStat.setString(1, tableNameMask.toLowerCase()); if (catalog != null) {",
        "ins2PreCode":"(catalog == null ? \"\" : \" AND \" + MySQLConstants.COL_ROUTINE_SCHEMA + \"=?\") + \" ORDER BY \" + MySQLConstants.COL_ROUTINE_NAME + \" LIMIT \" + maxResults)) { dbStat.setString(1, procNameMask.toLowerCase()); if (catalog != null) {",
        "label":1
    },
    {
        "ins1CurCode":"protected void doWrite(boolean block, ByteBuffer buffer) throws IOException { int n = 0; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { long timeout = getWriteTimeout(); do { n = socket.write(buffer); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { writeBlocking = false; throw new SocketTimeoutException(); } writeBlocking = false; } } } } while (buffer.hasRemaining());     } else { do { n = socket.write(buffer); if (n == -1) { throw new EOFException(); } } while (n > 0 && buffer.hasRemaining()); }",
        "ins1PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { long timeout = getWriteTimeout(); try { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { writeBlocking = false; }     } else { int n = 0; do { n = socket.write(from); if (n == -1) { throw new EOFException(); } } while (n > 0 && from.hasRemaining()); }",
        "ins2PreCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } if (block && nRead == 0) { long timeout = getReadTimeout(); try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; } } return nRead;",
        "label":0
    },
    {
        "ins1CurCode":"void draggedOnTopOfGroupAddsBeforeIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true));",
        "ins1PreCode":"public void draggedOnTopOfGroupAddsBeforeIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true));",
        "ins2PreCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true));",
        "label":1
    },
    {
        "ins1CurCode":"public void customProtocolResolverIsUsedInNonWebApplication() { GenericApplicationContext context = new GenericApplicationContext();",
        "ins1PreCode":"public void customProtocolResolverIsUsedInNonWebApplication() throws Exception { GenericApplicationContext context = new GenericApplicationContext();",
        "ins2PreCode":"public void customProtocolResolverIsUsedInWebApplication() throws Exception { GenericWebApplicationContext context = new GenericWebApplicationContext(",
        "label":1
    },
    {
        "ins1CurCode":"CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(() -> mapper.insertMultiParams_keyPropertyWithoutParamName(country, 1)); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining(",
        "ins1PreCode":"CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(mapper).insertMultiParams_keyPropertyWithoutParamName(country, 1); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining(",
        "ins2PreCode":"CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(mapper).insertMultiParams_keyPropertyWithWrongParamName(country, 1); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining(",
        "label":1
    },
    {
        "ins1CurCode":"public void testSelectShouldFlushLocalCacheIfFlushLocalCacheAtferEachStatementIsTrue() throws SQLException { sqlSessionFactory.getConfiguration().setLocalCacheScope(LocalCacheScope.STATEMENT); SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);",
        "ins1PreCode":"public void testSelectShouldFlushLocalCacheIfFlushLocalCacheAtferEachStatementIsTrue() throws SQLException { sqlSessionFactory.getConfiguration().setClearLocalCacheAfterEachStatement(true); SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE);",
        "ins2PreCode":"public void testShouldNotFlushLocalSessionCacheOnQueryForList() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE); try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> people = personMapper.selectAllNoFlush(); updateDatabase(sqlSession.getConnection()); people = personMapper.selectAllNoFlush(); assertEquals(\"John\", people.get(0).getFirstName()); sqlSession.commit(); } finally { sqlSession.close(); }",
        "label":0
    },
    {
        "ins1CurCode":"when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.shouldIncludeTimestamps()).thenReturn(includeTimestamp); ",
        "ins1PreCode":"when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.includeTimestamps()).thenReturn(includeTimestamp); ",
        "ins2PreCode":"when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.includeTimestamps()).thenReturn(includeTimestamp); ",
        "label":1
    },
    {
        "ins1CurCode":"public void checkAnyPermissionDoesNotShowDisabledPermissionsInError() { Jenkins jenkins = r.jenkins;",
        "ins1PreCode":"public void checkAnyPermissionDoesNotShowDisabledPermissionsInError() throws Exception { Jenkins jenkins = r.jenkins;",
        "ins2PreCode":"public void checkAnyPermissionShouldShowDisabledPermissionsIfNotImplied() throws Exception { Jenkins jenkins = r.jenkins;",
        "label":1
    },
    {
        "ins1CurCode":" Thread.sleep(20000); acceptor.unbind(); ",
        "ins1PreCode":" Thread.sleep(20000); acceptor.unbindAll(); ",
        "ins2PreCode":" Thread.sleep(20000); acceptor.unbindAll(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<?> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt = new StandardCategoryToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertSame(tt2, tt);",
        "label":0
    },
    {
        "ins1CurCode":"assertNotNull(result); assertEquals(\"Blog with posts\", result.getTitle()); Assertions.assertEquals(2, result.getPosts().size()); Post firstPost = result.getPosts().get(0); Assertions.assertEquals(1, firstPost.getBlog().getId()); Assertions.assertEquals(2, firstPost.getComments().size()); Post secondPost = result.getPosts().get(1); Assertions.assertEquals(1, secondPost.getComments().size()); Assertions.assertEquals(2, secondPost.getComments().get(0).getPost().getId()); }",
        "ins1PreCode":"assertNotNull(result); assertEquals(\"Blog with posts\", result.getTitle()); Assert.assertEquals(2, result.getPosts().size()); Post firstPost = result.getPosts().get(0); Assert.assertEquals(1, firstPost.getBlog().getId()); Assert.assertEquals(2, firstPost.getComments().size()); Post secondPost = result.getPosts().get(1); Assert.assertEquals(1, secondPost.getComments().size()); Assert.assertEquals(2, secondPost.getComments().get(0).getPost().getId()); }",
        "ins2PreCode":"assertNotNull(result); assertEquals(\"Blog with posts\", result.getTitle()); Assert.assertEquals(2, result.getPosts().size()); Post firstPost = result.getPosts().get(0); Assert.assertEquals(1, firstPost.getBlog().getId()); Assert.assertEquals(2, firstPost.getComments().size()); Post secondPost = result.getPosts().get(1); Assert.assertEquals(1, secondPost.getComments().size()); Assert.assertEquals(2, secondPost.getComments().get(0).getPost().getId()); }",
        "label":1
    },
    {
        "ins1CurCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);",
        "ins1PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); ",
        "ins2PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.addUnresolvedKey(UNKNOWN); ",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(r1.equals(r2));  r1.setShadowPaint(Color.RED); assertFalse(r1.equals(r2)); r2.setShadowPaint(Color.RED); assertTrue(r1.equals(r2));",
        "ins1PreCode":"assertTrue(r1.equals(r2));  r1.setShadowPaint(Color.red); assertFalse(r1.equals(r2)); r2.setShadowPaint(Color.red); assertTrue(r1.equals(r2));",
        "ins2PreCode":"public void testEquals() {   XYBarRenderer r1 = new XYBarRenderer(); XYBarRenderer r2 = new XYBarRenderer(); assertTrue(r1.equals(r2)); assertTrue(r2.equals(r1));   r1.setBase(1.0); assertFalse(r1.equals(r2)); r2.setBase(1.0); assertTrue(r1.equals(r2));   r1.setUseYInterval(!r1.getUseYInterval()); assertFalse(r1.equals(r2)); r2.setUseYInterval(!r2.getUseYInterval()); assertTrue(r1.equals(r2));   r1.setMargin(0.10); assertFalse(r1.equals(r2)); r2.setMargin(0.10); assertTrue(r1.equals(r2));   r1.setDrawBarOutline(!r1.isDrawBarOutline()); assertFalse(r1.equals(r2)); r2.setDrawBarOutline(!r2.isDrawBarOutline()); assertTrue(r1.equals(r2));   r1.setGradientPaintTransformer(new StandardGradientPaintTransformer( GradientPaintTransformType.CENTER_HORIZONTAL)); assertFalse(r1.equals(r2)); r2.setGradientPaintTransformer(new StandardGradientPaintTransformer( GradientPaintTransformType.CENTER_HORIZONTAL)); assertTrue(r1.equals(r2));   r1.setLegendBar(new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0)); assertFalse(r1.equals(r2)); r2.setLegendBar(new Rectangle2D.Double(1.0, 2.0, 3.0, 4.0)); assertTrue(r1.equals(r2));   r1.setPositiveItemLabelPositionFallback(new ItemLabelPosition()); assertFalse(r1.equals(r2)); r2.setPositiveItemLabelPositionFallback(new ItemLabelPosition()); assertTrue(r1.equals(r2));   r1.setNegativeItemLabelPositionFallback(new ItemLabelPosition()); assertFalse(r1.equals(r2)); r2.setNegativeItemLabelPositionFallback(new ItemLabelPosition()); assertTrue(r1.equals(r2));   r1.setBarPainter(new GradientXYBarPainter(0.11, 0.22, 0.33)); assertFalse(r1.equals(r2)); r2.setBarPainter(new GradientXYBarPainter(0.11, 0.22, 0.33)); assertTrue(r1.equals(r2));   r1.setShadowVisible(false); assertFalse(r1.equals(r2)); r2.setShadowVisible(false); assertTrue(r1.equals(r2));   r1.setShadowXOffset(3.3); assertFalse(r1.equals(r2)); r2.setShadowXOffset(3.3); assertTrue(r1.equals(r2));   r1.setShadowYOffset(3.3); assertFalse(r1.equals(r2)); r2.setShadowYOffset(3.3); assertTrue(r1.equals(r2)); ",
        "label":0
    },
    {
        "ins1CurCode":" Widget widget = SWTElementHelpers.getWidget(element); if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { return false; }  Color newColor = getCurrentEditorConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) {",
        "ins1PreCode":" Widget widget = SWTElementHelpers.getWidget(element); if (widget == null) { return false; }  Color newColor = getCurrentConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) {",
        "ins2PreCode":"public boolean applyCSSProperty(Object element, String property, CSSValue value, String pseudo, CSSEngine engine) throws Exception { Widget widget = SWTElementHelpers.getWidget(element); if (widget == null) { return false; }  Color newColor = CustomSelectedTabFillHandler.getCurrentConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) {",
        "label":1
    },
    {
        "ins1CurCode":"public byte[] getBase64(boolean required) throws IOException { String s = remainingStrings(); if (s == null) { if (required) { throw exception(\"expected base64 encoded string\"); } else { return null; } } byte[] array = base64.fromString(s); if (array == null) { throw exception(\"invalid base64 encoding\");",
        "ins1PreCode":"public byte [] getBase64(boolean required) throws IOException { String s = remainingStrings(); if (s == null) { if (required) throw exception(\"expected base64 encoded string\"); else return null; } byte [] array = base64.fromString(s); if (array == null) throw exception(\"invalid base64 encoding\");",
        "ins2PreCode":"public byte [] getHex(boolean required) throws IOException { String s = remainingStrings(); if (s == null) { if (required) throw exception(\"expected hex encoded string\"); else return null; } byte [] array = base16.fromString(s); if (array == null) throw exception(\"invalid hex encoding\");",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribeActual(Subscriber<? super T> s) { DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<>(s); s.onSubscribe(deferred);",
        "ins1PreCode":"public void subscribeActual(Subscriber<? super T> s) { DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s); s.onSubscribe(deferred);",
        "ins2PreCode":"public void subscribeActual(Subscriber<? super T> s) { DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s); s.onSubscribe(deferred);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(context).getBeans(MetricsWebFilter.class).hasSize(1); assertThat(context).getBeans(DefaultWebFluxTagsProvider.class).hasSize(1); assertThat(context.getBean(DefaultWebFluxTagsProvider.class)).extracting(\"ignoreTrailingSlash\") .isEqualTo(true); });",
        "ins1PreCode":"assertThat(context).getBeans(MetricsWebFilter.class).hasSize(1); assertThat(context).getBeans(DefaultWebFluxTagsProvider.class).hasSize(1); assertThat(ReflectionTestUtils.getField(context.getBean(DefaultWebFluxTagsProvider.class), \"ignoreTrailingSlash\")).isEqualTo(true); });",
        "ins2PreCode":"void handlerAdaptersCreated() { this.contextRunner.run((context) -> { assertThat(context).getBeans(HandlerAdapter.class).hasSize(4); assertThat(context.getBean(RequestMappingHandlerAdapter.class).getMessageConverters()).isNotEmpty() .isEqualTo(context.getBean(HttpMessageConverters.class).getConverters()); });",
        "label":0
    },
    {
        "ins1CurCode":"private static JFreeChart createLineChart() { Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}}; CategoryDataset<String,String> dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createLineChart(\"Line Chart\", \"Domain\", \"Range\",",
        "ins1PreCode":"private static JFreeChart createLineChart() {  Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);  return ChartFactory.createLineChart(\"Line Chart\", \"Domain\", \"Range\", dataset); ",
        "ins2PreCode":"Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedAreaChart( \"Stacked Area Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true ); ",
        "label":1
    },
    {
        "ins1CurCode":"public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, @NonNull TimeUnit unit, @NonNull Scheduler scheduler) { if (count < 0L) {",
        "ins1PreCode":"public static Flowable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) { if (count < 0L) {",
        "ins2PreCode":"public static Observable<Long> intervalRange(long start, long count, long initialDelay, long period, TimeUnit unit, Scheduler scheduler) { if (count < 0) {",
        "label":1
    },
    {
        "ins1CurCode":"void imageBannerAndTextBanner(CapturedOutput capturedOutput) { SpringApplication application = new SpringApplication(ExampleConfig.class); MockResourceLoader resourceLoader = new MockResourceLoader(); resourceLoader.addResource(\"banner.gif\", \"black-and-white.gif\"); resourceLoader.addResource(\"banner.txt\", \"foobar.txt\"); application.setWebApplicationType(WebApplicationType.NONE); application.setResourceLoader(resourceLoader); application.run(); assertThat(capturedOutput).contains(\"@@@@\").contains(\"Foo Bar\");",
        "ins1PreCode":"public void imageBannerAndTextBanner() { SpringApplication application = new SpringApplication(ExampleConfig.class); MockResourceLoader resourceLoader = new MockResourceLoader(); resourceLoader.addResource(\"banner.gif\", \"black-and-white.gif\"); resourceLoader.addResource(\"banner.txt\", \"foobar.txt\"); application.setWebApplicationType(WebApplicationType.NONE); application.setResourceLoader(resourceLoader); application.run(); assertThat(this.output.toString()).contains(\"@@@@\").contains(\"Foo Bar\");",
        "ins2PreCode":"public void imageBannerLoads() { SpringApplication application = new SpringApplication(ExampleConfig.class); MockResourceLoader resourceLoader = new MockResourceLoader(); resourceLoader.addResource(\"banner.gif\", \"black-and-white.gif\"); application.setWebApplicationType(WebApplicationType.NONE); application.setResourceLoader(resourceLoader); application.run(); assertThat(this.output.toString()).contains(\"@@@@@@\");",
        "label":1
    },
    {
        "ins1CurCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory() && !\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "ins1PreCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory()) { if (!\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "ins2PreCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory()) { if (!\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "label":1
    },
    {
        "ins1CurCode":"pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest );  pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null ); }",
        "ins1PreCode":"pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest );  pluginManager.setupPluginRealm( pluginDescriptor, session, null, null ); }",
        "ins2PreCode":"pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest );  pluginManager.setupPluginRealm( pluginDescriptor, session, null, null ); }",
        "label":1
    },
    {
        "ins1CurCode":"void getNonRecursiveManifest() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"))) { assertThat(explodedArchive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive); assertThat(entries.size()).isEqualTo(4);",
        "ins1PreCode":"public void getNonRecursiveManifest() throws Exception { ExplodedArchive archive = new ExplodedArchive( new File(\"src/test/resources/root\")); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(4);",
        "ins2PreCode":"public void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), false); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(3);",
        "label":0
    },
    {
        "ins1CurCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, null, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), null, new Double(0.0), new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins2PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(null, new Double(2.0), new Double(0.0), new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "label":0
    },
    {
        "ins1CurCode":"private static MutableNetwork<Integer, String> buildDirectedNetwork() { MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build(); directedGraph.addEdge(N1, N1, E11);",
        "ins1PreCode":"private static MutableNetwork<Integer, String> buildDirectedNetwork() { MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().allowsSelfLoops(true).allowsParallelEdges(true).build(); directedGraph.addEdge(N1, N1, E11);",
        "ins2PreCode":"private static MutableNetwork<Integer, String> buildUndirectedNetwork() { MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected().allowsSelfLoops(true).allowsParallelEdges(true).build(); undirectedGraph.addEdge(N1, N1, E11);",
        "label":1
    },
    {
        "ins1CurCode":"final AtomicBoolean didRunOnTerminate = new AtomicBoolean();  UnicastProcessor<Integer> up = UnicastProcessor.create(Observable.bufferSize(), new Runnable() { @Override public void run() { didRunOnTerminate.set(true); } });  final Disposable subscribe = up.subscribe(); ",
        "ins1PreCode":"final AtomicBoolean didRunOnTerminate = new AtomicBoolean();  UnicastProcessor<Integer> us = UnicastProcessor.create(Observable.bufferSize(), new Runnable() { @Override public void run() { didRunOnTerminate.set(true); } });  final Disposable subscribe = us.subscribe(); ",
        "ins2PreCode":"public void onTerminateCalledWhenCanceled() { final AtomicBoolean didRunOnTerminate = new AtomicBoolean();  UnicastSubject<Integer> us = UnicastSubject.create(Observable.bufferSize(), new Runnable() { @Override public void run() { didRunOnTerminate.set(true); } });  final Disposable subscribe = us.subscribe();  assertFalse(didRunOnTerminate.get()); subscribe.dispose(); assertTrue(didRunOnTerminate.get());",
        "label":0
    },
    {
        "ins1CurCode":"conf);  for (String blockId : blockIds) { verify(listener).onBlockFetchSuccess(blockId, blocks.get(blockId));",
        "ins1PreCode":"conf);  for (int chunkIndex = 0; chunkIndex < blockIds.length; chunkIndex++) { String blockId = blockIds[chunkIndex]; verify(listener).onBlockFetchSuccess(blockId, blocks.get(blockId));",
        "ins2PreCode":"public void testFetchThree() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"b0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"b1\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"b2\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new OpenBlocks(\"app-id\", \"exec-id\", blockIds), conf);  for (int i = 0; i < 3; i ++) { verify(listener, times(1)).onBlockFetchSuccess(\"b\" + i, blocks.get(\"b\" + i)); }",
        "label":0
    },
    {
        "ins1CurCode":"for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0) ? pair.substring(0, index) : pair; String value = (index > 0) ? pair.substring(index + 1) : \"\"; map.put(key.trim(), value.trim());",
        "ins1PreCode":"for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\"); map.put(key.trim(), value.trim());",
        "ins2PreCode":"for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\"); map.put(key.trim(), value.trim());",
        "label":1
    },
    {
        "ins1CurCode":"assertMapCounts(0, builder);  setMapValuesUsingAccessors(builder); assertMapCounts(3, builder);",
        "ins1PreCode":"assertMapCounts(0, builder);  setMapValuesUsingMutableMap(builder); assertMapCounts(3, builder);",
        "ins2PreCode":"public void testCount() { TestMap.Builder builder = TestMap.newBuilder(); assertMapCounts(0, builder);  setMapValues(builder); assertMapCounts(3, builder);  TestMap message = builder.build(); assertMapCounts(3, message);  builder = message.toBuilder().putInt32ToInt32Field(4, 44); assertEquals(4, builder.getInt32ToInt32FieldCount()); assertEquals(4, builder.build().getInt32ToInt32FieldCount());   builder.putInt32ToInt32Field(4, 44); assertEquals(4, builder.getInt32ToInt32FieldCount());",
        "label":0
    },
    {
        "ins1CurCode":"this.activeSchemaName = schemaName; } catch (SQLException e) { throw new DBCException(e, this); }",
        "ins1PreCode":"this.activeSchemaName = schemaName; } catch (SQLException e) { throw new DBCException(e, getDataSource()); }",
        "ins2PreCode":"this.activeSchemaName = schemaName; } catch (SQLException e) { throw new DBCException(e, getDataSource()); }",
        "label":1
    },
    {
        "ins1CurCode":"} } return results.toArray(new String[0]);",
        "ins1PreCode":"} } return results.toArray(new String[results.size()]);",
        "ins2PreCode":"} } return results.toArray(new String[results.size()]);",
        "label":1
    },
    {
        "ins1CurCode":"  TesterLogValidationFilter f = new TesterLogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\");",
        "ins1PreCode":"  LogValidationFilter f = new LogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\");",
        "ins2PreCode":"  LogValidationFilter f = new LogValidationFilter( \"The web application [ROOT] created a ThreadLocal with key of\");",
        "label":1
    },
    {
        "ins1CurCode":"void exceptionThrownOnLoadFailureWhenFailCtxIfServletStartFailsIsTrue() { TomcatServletWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void exceptionThrownOnLoadFailureWhenFailCtxIfServletStartFailsIsTrue() { TomcatServletWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void exceptionThrownOnLoadFailureWhenFailCtxIfServletStartFailsIsFalse() { TomcatServletWebServerFactory factory = getFactory();",
        "label":1
    },
    {
        "ins1CurCode":"public void onNextFailure() { AtomicReference<Throwable> onError = new AtomicReference<>(); try {",
        "ins1PreCode":"public void onNextFailure() { AtomicReference<Throwable> onError = new AtomicReference<Throwable>(); try {",
        "ins2PreCode":"public void onNextFailure() { AtomicReference<Throwable> onError = new AtomicReference<Throwable>(); try {",
        "label":1
    },
    {
        "ins1CurCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/bug45nnn/bug45427.jsp\"); ",
        "ins1PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/bug45427.jsp\"); ",
        "ins2PreCode":"public void testScriptingExpression() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/script-expr.jsp\"); String result = res.toString(); assertEcho(result, \"00-hello world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"02-hello \\\\\\\"world\"); assertEcho(result, \"03-hello ${world\"); assertEcho(result, \"04-hello \\\\${world\"); assertEcho(result, \"05-hello world\"); assertEcho(result, \"06-hello \\\"world\"); assertEcho(result, \"07-hello \\\\\\\"world\"); assertEcho(result, \"08-hello ${world\"); assertEcho(result, \"09-hello \\\\${world\"); assertEcho(result, \"10-hello <% world\"); assertEcho(result, \"11-hello %> world\");",
        "label":0
    },
    {
        "ins1CurCode":" @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = jsc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  List<FPGrowth.FreqItemset<String>> freqItemsets = model.freqItemsets().toJavaRDD().collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset : freqItemsets) { ",
        "ins1PreCode":" @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  List<FPGrowth.FreqItemset<String>> freqItemsets = model.freqItemsets().toJavaRDD().collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset: freqItemsets) { ",
        "ins2PreCode":" @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  File tempDir = Utils.createTempDir( System.getProperty(\"java.io.tmpdir\"), \"JavaFPGrowthSuite\"); String outputPath = tempDir.getPath();  try { model.save(sc.sc(), outputPath); @SuppressWarnings(\"unchecked\") FPGrowthModel<String> newModel = (FPGrowthModel<String>) FPGrowthModel.load(sc.sc(), outputPath); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD() .collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset: freqItemsets) { ",
        "label":0
    },
    {
        "ins1CurCode":"void testAnnotatedUpdateTable2WithGeneratedKeyXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testAnnotatedUpdateTable2WithGeneratedKeyXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"existing.removeChangeListener(this); } this.renderers.put(index, renderer); if (renderer != null) {",
        "ins1PreCode":"existing.removeChangeListener(this); } this.renderers.set(index, renderer); if (renderer != null) {",
        "ins2PreCode":"public void setRenderer(int index, XYItemRenderer renderer, boolean notify) { XYItemRenderer existing = getRenderer(index); if (existing != null) { existing.removeChangeListener(this); } this.renderers.put(index, renderer); if (renderer != null) { renderer.setPlot(this); renderer.addChangeListener(this); } configureDomainAxes(); configureRangeAxes(); if (notify) { fireChangeEvent(); }",
        "label":0
    },
    {
        "ins1CurCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin( @NonNull Publisher<@NonNull ? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<@NonNull TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<@NonNull TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) {",
        "ins2PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> groupJoin( @NonNull ObservableSource<? extends TRight> other,",
        "label":1
    },
    {
        "ins1CurCode":"\"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0); assertTrue(\"Checking no client issuer has been requested\", TesterSupport.getLastClientAuthRequestedIssuerCount() == 0);",
        "ins1PreCode":"\"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0);",
        "ins2PreCode":"\"/examples/servlets/servlet/HelloWorldExample\"); assertTrue(res.toString().indexOf(\"<a href=\\\"../helloworld.html\\\">\") > 0);",
        "label":1
    },
    {
        "ins1CurCode":"  int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 10000, null, null);",
        "ins1PreCode":"int expectedStatus) throws IOException { ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 30000, null, null);",
        "ins2PreCode":"private void assertPageContains(String pageUrl, String expectedBody, int expectedStatus) throws IOException { ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, null);  assertEquals(expectedStatus, sc);  if (expectedStatus == 200) { String result = res.toString(); assertTrue(result, result.indexOf(expectedBody) > 0); }",
        "label":0
    },
    {
        "ins1CurCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\")); ",
        "ins1PreCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\"), importFormatPreferences, fileMonitor); ",
        "ins2PreCode":"public void parsePreservesNewlineInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups \\nsala}}\"), importFormatPreferences, fileMonitor); ",
        "label":1
    },
    {
        "ins1CurCode":"public void bindToCollectionShouldTriggerOnSuccess() { this.sources.add(new MockConfigurationPropertySource(\"foo[0]\", \"1\", \"line1\")); BindHandler handler = mock(BindHandler.class, Answers.CALLS_REAL_METHODS); this.binder.bind(\"foo\", INTEGER_LIST, handler);",
        "ins1PreCode":"public void bindToCollectionShouldTriggerOnSuccess() { this.sources.add(new MockConfigurationPropertySource(\"foo[0]\", \"1\", \"line1\")); BindHandler handler = mock(BindHandler.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); this.binder.bind(\"foo\", INTEGER_LIST, handler);",
        "ins2PreCode":"public void bindToArrayShouldTriggerOnSuccess() { this.sources.add(new MockConfigurationPropertySource(\"foo[0]\", \"1\", \"line1\")); BindHandler handler = mock(BindHandler.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); Bindable<Integer[]> target = INTEGER_ARRAY;",
        "label":1
    },
    {
        "ins1CurCode":"void entriesAreParsedHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeader, importFormatPreferences, timestampPreferences, fileMonitor); BibDatabase db = result.getDatabase();",
        "ins1PreCode":"void entriesAreParsedHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeader, importFormatPreferences, fileMonitor); BibDatabase db = result.getDatabase();",
        "ins2PreCode":"void entriesAreParsedHeaderAndSignature() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeaderAndSignature, importFormatPreferences, fileMonitor); BibDatabase db = result.getDatabase();",
        "label":1
    },
    {
        "ins1CurCode":"return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"float [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + byte.class.getCanonicalName()); }",
        "ins1PreCode":"return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to float\"); }",
        "ins2PreCode":"return ((Number)value).longValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to long\"); }",
        "label":0
    },
    {
        "ins1CurCode":"collection.addPatternDecoded(\"/\"); String utf8User = \"test\"; String utf8Pass = \"123\u00a3\"; ",
        "ins1PreCode":"collection.addPatternDecoded(\"/\"); String utf8User = \"test\"; String utf8Pass = \"123\ufffd\"; ",
        "ins2PreCode":"public void testConnectToDigestEndpoint() throws Exception {  Tomcat tomcat = getTomcatInstance(); Context ctx = tomcat.addContext(URI_PROTECTED, null); ctx.addApplicationListener(TesterEchoServer.Config.class.getName()); Tomcat.addServlet(ctx, \"default\", new DefaultServlet()); ctx.addServletMappingDecoded(\"/\", \"default\");  SecurityCollection collection = new SecurityCollection(); collection.addPatternDecoded(\"/*\");  tomcat.addUser(USER, PWD); tomcat.addRole(USER, ROLE);  SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); ctx.addConstraint(sc);  LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"DIGEST\"); ctx.setLoginConfig(lc);  AuthenticatorBase digestAuthenticator = new org.apache.catalina.authenticator.DigestAuthenticator(); ctx.getPipeline().addValve(digestAuthenticator);  tomcat.start();  ClientEndpointConfig clientEndpointConfig = ClientEndpointConfig.Builder.create().build(); clientEndpointConfig.getUserProperties().put(Constants.WS_AUTHENTICATION_USER_NAME, USER); clientEndpointConfig.getUserProperties().put(Constants.WS_AUTHENTICATION_PASSWORD,PWD);  echoTester(URI_PROTECTED, clientEndpointConfig); ",
        "label":0
    },
    {
        "ins1CurCode":"public void test_olderThan_leaving_part_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L); Iterable<ModelObject> itemList = newRuns(1, 10); ",
        "ins1PreCode":"public void test_olderThan_leaving_part_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L); List<ModelObject> itemList = newRuns(1, 10); ",
        "ins2PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = newRuns(1, 10); ",
        "label":1
    },
    {
        "ins1CurCode":"String xmlConfig = \"org/apache/ibatis/submitted/result_handler_type/MapperConfig.xml\"; SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryXmlConfig(xmlConfig); try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<Integer, Person> map = sqlSession.selectMap(",
        "ins1PreCode":"String xmlConfig = \"org/apache/ibatis/submitted/result_handler_type/MapperConfig.xml\"; SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryXmlConfig(xmlConfig); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Map<Integer, Person> map = sqlSession.selectMap( \"org.apache.ibatis.submitted.result_handler_type.PersonMapper.doSelect\", \"id\"); assertEquals(map.size(), 2); assertEquals(\"java.util.LinkedHashMap\", map.getClass().getCanonicalName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"String xmlConfig = \"org/apache/ibatis/submitted/result_handler_type/MapperConfig.xml\"; SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryXmlConfig(xmlConfig); SqlSession sqlSession = sqlSessionFactory.openSession(); try { PersonMapper mapper = sqlSession.getMapper(PersonMapper.class); Map<Integer, Person> map = mapper.selectAsMap(); assertEquals(map.size(), 2); assertEquals(\"java.util.LinkedHashMap\", map.getClass().getCanonicalName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"}  return new EBinary(nextIdentifier(), location(ctx), left, right, operation);",
        "ins1PreCode":"}  return new EBinary(location(ctx), operation, left, right);",
        "ins2PreCode":"}  return new EAssignment(location(ctx), lhs, rhs, false, operation);",
        "label":0
    },
    {
        "ins1CurCode":"String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit)); } long offset = index; final long offsetLimit = limit; if (state != COMPLETE) {",
        "ins1PreCode":"String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit)); } long offset = getArrayBaseOffset() + index; final long offsetLimit = getArrayBaseOffset() + limit; if (state != COMPLETE) {",
        "ins2PreCode":"int partialIsValidUtf8Direct( final int state, ByteBuffer buffer, final int index, final int limit) { if ((index | limit | buffer.limit() - limit) < 0) { throw new ArrayIndexOutOfBoundsException( String.format(\"buffer limit=%d, index=%d, limit=%d\", buffer.limit(), index, limit)); } long address = addressOffset(buffer) + index; final long addressLimit = address + (limit - index); if (state != COMPLETE) {        if (address >= addressLimit) { return state; }  final int byte1 = (byte) state;  if (byte1 < (byte) 0xE0) {     if (byte1 < (byte) 0xC2  || UnsafeUtil.getByte(address++) > (byte) 0xBF) { return MALFORMED; } } else if (byte1 < (byte) 0xF0) {    int byte2 = (byte) ~(state >> 8); if (byte2 == 0) { byte2 = UnsafeUtil.getByte(address++); if (address >= addressLimit) { return incompleteStateFor(byte1, byte2); } } if (byte2 > (byte) 0xBF  || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)  || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)  || UnsafeUtil.getByte(address++) > (byte) 0xBF) { return MALFORMED; } } else {    int byte2 = (byte) ~(state >> 8); int byte3 = 0; if (byte2 == 0) { byte2 = UnsafeUtil.getByte(address++); if (address >= addressLimit) { return incompleteStateFor(byte1, byte2); } } else { byte3 = (byte) (state >> 16); } if (byte3 == 0) { byte3 = UnsafeUtil.getByte(address++); if (address >= addressLimit) { return incompleteStateFor(byte1, byte2, byte3); } }      if (byte2 > (byte) 0xBF     || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0  || byte3 > (byte) 0xBF  || UnsafeUtil.getByte(address++) > (byte) 0xBF) { return MALFORMED; } } }  return partialIsValidUtf8(address, (int) (addressLimit - address));",
        "label":0
    },
    {
        "ins1CurCode":"mgr.createRandomInputStream(); mgr.generateSessionId(); while (mgr.sessionCreationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionCreationTiming.add(null); } while (mgr.sessionExpirationTiming.size() < ManagerBase.TIMING_STATS_CACHE_SIZE) { mgr.sessionExpirationTiming.add(null); }",
        "ins1PreCode":"mgr.createRandomInputStream(); mgr.generateSessionId();   Thread[] threads = new Thread[threadCount];  for (int i = 0; i < threadCount; i++) { threads[i] = new Thread( new TestThreadGenerateSessionId(mgr, iterCount)); }",
        "ins2PreCode":"mgr.createRandomInputStream(); mgr.generateSessionId();  Thread[] threads = new Thread[threadCount];  for (int i = 0; i < threadCount; i++) { threads[i] = new Thread( new TestThreadCreateSession(mgr, iterCount)); } ",
        "label":1
    },
    {
        "ins1CurCode":"if (vertical) { FontMetrics fm = g2.getFontMetrics(font); for (Object o : ticks) { Tick tick = (Tick) o; Rectangle2D labelBounds = null;",
        "ins1PreCode":"if (vertical) { FontMetrics fm = g2.getFontMetrics(font); Iterator iterator = ticks.iterator(); while (iterator.hasNext()) { Tick tick = (Tick) iterator.next(); Rectangle2D labelBounds = null;",
        "ins2PreCode":"if (!vertical) { FontMetrics fm = g2.getFontMetrics(font); Iterator iterator = ticks.iterator(); while (iterator.hasNext()) { Tick tick = (Tick) iterator.next(); Rectangle2D labelBounds = null;",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerMaybeObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void tryTerminateConsumerMaybeObserverTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerSingleTerminated() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void onSubscribe() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();  ts.onSubscribe(null);  ts.assertError(NullPointerException.class);  ts = new TestSubscriberEx<>();  ts.onSubscribe(new BooleanSubscription());  BooleanSubscription bs1 = new BooleanSubscription();  ts.onSubscribe(bs1);  assertTrue(bs1.isCancelled());  ts.assertError(IllegalStateException.class);  ts = new TestSubscriberEx<>(); ts.dispose();",
        "ins1PreCode":"public void onSubscribe() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  ts.onSubscribe(null);  ts.assertError(NullPointerException.class);  ts = new TestSubscriberEx<Integer>();  ts.onSubscribe(new BooleanSubscription());  BooleanSubscription bs1 = new BooleanSubscription();  ts.onSubscribe(bs1);  assertTrue(bs1.isCancelled());  ts.assertError(IllegalStateException.class);  ts = new TestSubscriberEx<Integer>(); ts.dispose();",
        "ins2PreCode":"public void onSubscribe() { TestSubscriber<Integer> ts = TestSubscriber.create();  ts.onSubscribe(null);  ts.assertError(NullPointerException.class);  ts = TestSubscriber.create();  ts.onSubscribe(new BooleanSubscription());  BooleanSubscription bs1 = new BooleanSubscription();  ts.onSubscribe(bs1);  assertTrue(bs1.isCancelled());  ts.assertError(IllegalStateException.class);  ts = TestSubscriber.create(); ts.dispose();  bs1 = new BooleanSubscription();  ts.onSubscribe(bs1);  assertTrue(bs1.isCancelled()); ",
        "label":0
    },
    {
        "ins1CurCode":"public void onNext(T t) { ExceptionHelper.nullCheck(t, \"onNext called with a null value.\"); ",
        "ins1PreCode":"public void onNext(T t) { ObjectHelper.requireNonNull(t, \"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"); ",
        "ins2PreCode":"public void onNext(T t) { ObjectHelper.requireNonNull(t, \"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"); ",
        "label":1
    },
    {
        "ins1CurCode":"void testUnknownExternalFileWillNotLoad() { ",
        "ins1PreCode":"public void testUnknownExternalFileWillNotLoad() { ",
        "ins2PreCode":"public void testDoNotLoadTheSameInternalListTwice() { ",
        "label":1
    },
    {
        "ins1CurCode":"pool.write(socketBufferHandler.getWriteBuffer(), getSocket(), selector, writeTimeout, block); if (block) {  do { if (getSocket().flush(true, selector, writeTimeout)) break; } while (true); } lastWrite = System.currentTimeMillis(); } finally {",
        "ins1PreCode":"pool.write(socketBufferHandler.getWriteBuffer(), getSocket(), selector, writeTimeout, block);  do { if (getSocket().flush(true, selector, writeTimeout)) break; } while (true); } finally { if (selector != null) { pool.put(selector); }",
        "ins2PreCode":"private int fillReadBuffer(boolean block) throws IOException { int nRead; NioChannel channel = getSocket(); socketBufferHandler.configureReadBufferForWrite(); if (block) { Selector selector = null; try { selector = pool.get(); } catch ( IOException x ) {  } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel.getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(socketBufferHandler.getReadBuffer()); if (nRead == -1) { throw new EOFException(); } } return nRead;",
        "label":0
    },
    {
        "ins1CurCode":"for (N otherNode : network.nodes()) { Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode)); switch (edgesConnecting.size()) { case 0: assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull(); break; case 1: assertThat(network.edgeConnectingOrNull(node, otherNode)) .isEqualTo(edgesConnecting.iterator().next()); break; default: try { network.edgeConnectingOrNull(node, otherNode); fail(); } catch (IllegalArgumentException expected) {} }",
        "ins1PreCode":"for (N otherNode : network.nodes()) { Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));  boolean isSelfLoop = node.equals(otherNode); boolean connected = !edgesConnecting.isEmpty(); if (network.isDirected() || !isSelfLoop) { assertThat(edgesConnecting) .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode))); } if (!network.allowsParallelEdges()) { assertThat(edgesConnecting.size()).isAtMost(1); } if (!network.allowsSelfLoops() && isSelfLoop) { assertThat(connected).isFalse(); } ",
        "ins2PreCode":"for (N otherNode : network.nodes()) { Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));  boolean isSelfLoop = node.equals(otherNode); boolean connected = !edgesConnecting.isEmpty(); if (network.isDirected() || !isSelfLoop) { assertThat(edgesConnecting) .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode))); } if (!network.allowsParallelEdges()) { assertThat(edgesConnecting.size()).isAtMost(1); } if (!network.allowsSelfLoops() && isSelfLoop) { assertThat(connected).isFalse(); }  assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected); assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected); for (E edge : edgesConnecting) { assertThat(network.incidentNodes(edge)) .isEqualTo(EndpointPair.of(network, node, otherNode)); assertThat(network.outEdges(node)).contains(edge);",
        "label":0
    },
    {
        "ins1CurCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = BibtexParser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\"), importFormatPreferences, fileMonitor); Collection<BibEntry> c = result.getDatabase().getEntries();",
        "ins1PreCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = BibtexParser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\"), importFormatPreferences); Collection<BibEntry> c = result.getDatabase().getEntries();",
        "ins2PreCode":"public void parsePreservesNewlineInAbstractField() throws IOException { ParserResult result = BibtexParser.parse(new StringReader(\"@article{canh05,abstract = {ups \\nsala}}\"), importFormatPreferences); ",
        "label":1
    },
    {
        "ins1CurCode":"Object cs = Model.getFacade().getContainer(ps); if (cs == null) { LOG.log(Level.FINE, \"null parent in still valid\"); return offs;",
        "ins1PreCode":"Object cs = Model.getFacade().getContainer(ps); if (cs == null) { LOG.debug(\"null parent in still valid\"); return offs;",
        "ins2PreCode":"Object cs = Model.getFacade().getContainer(ps); if (cs == null) { LOG.debug(\"null parent in still valid\"); return offs;",
        "label":1
    },
    {
        "ins1CurCode":"getDropConstraintPattern(command.getObject()) .replace(PATTERN_ITEM_TABLE, command.getObject().getTable().getFullyQualifiedName(DBPEvaluationContext.DDL)) .replace(PATTERN_ITEM_CONSTRAINT, DBUtils.getQuotedIdentifier(command.getObject()))) );",
        "ins1PreCode":"getDropConstraintPattern(command.getObject()) .replace(PATTERN_ITEM_TABLE, command.getObject().getTable().getFullyQualifiedName(DBPEvaluationContext.DDL)) .replace(PATTERN_ITEM_CONSTRAINT, command.getObject().getName())) );",
        "ins2PreCode":"getDropForeignKeyPattern(command.getObject()) .replace(PATTERN_ITEM_TABLE, command.getObject().getTable().getFullyQualifiedName(DBPEvaluationContext.DDL)) .replace(PATTERN_ITEM_CONSTRAINT, command.getObject().getName())) );",
        "label":1
    },
    {
        "ins1CurCode":"public void manyIteratorThrows() { Flowable.just(1) .withLatestFrom(new CrashingMappedIterable<>(1, 100, 100, new Function<Integer, Flowable<Integer>>() { @Override",
        "ins1PreCode":"public void manyIteratorThrows() { Flowable.just(1) .withLatestFrom(new CrashingMappedIterable<Flowable<Integer>>(1, 100, 100, new Function<Integer, Flowable<Integer>>() { @Override",
        "ins2PreCode":"public void manyIteratorThrows() { Observable.just(1) .withLatestFrom(new CrashingMappedIterable<Observable<Integer>>(1, 100, 100, new Function<Integer, Observable<Integer>>() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"() -> processor.execute(RandomDocumentPicks.randomIngestDocument(random(), document))); assertThat(e.getMessage(), equalTo(\"unable to parse date [2010]\")); assertThat(e.getCause().getMessage(), equalTo(\"Unknown time-zone ID: invalid_timezone\"));",
        "ins1PreCode":"() -> processor.execute(RandomDocumentPicks.randomIngestDocument(random(), document))); assertThat(e.getMessage(), equalTo(\"unable to parse date [2010]\")); assertThat(e.getCause().getMessage(), equalTo(\"The datetime zone id 'invalid_timezone' is not recognised\"));",
        "ins2PreCode":"public void testInvalidLocale() { DateProcessor processor = new DateProcessor(randomAlphaOfLength(10), templatize(ZoneOffset.UTC), new TestTemplateService.MockTemplateScript.Factory(\"invalid_locale\"), \"date_as_string\", Collections.singletonList(\"yyyy\"), \"date_as_date\"); Map<String, Object> document = new HashMap<>(); document.put(\"date_as_string\", \"2010\"); IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> processor.execute(RandomDocumentPicks.randomIngestDocument(random(), document))); assertThat(e.getMessage(), equalTo(\"unable to parse date [2010]\")); assertThat(e.getCause().getMessage(), equalTo(\"Unknown language: invalid\"));",
        "label":0
    },
    {
        "ins1CurCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void predicateThrowsSuppressOthers() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription());  subscriber.onNext(1); subscriber.onNext(2); subscriber.onError(new IOException()); subscriber.onComplete(); } } .any(new Predicate<Integer>() { @Override public boolean test(Integer v) throws Exception { throw new TestException(); } }) .toFlowable() .test() .assertFailure(TestException.class);  TestHelper.assertUndeliverable(errors, 0, IOException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"private List<CategoryDataset> datasetsMappedToDomainAxis(int axisIndex) { List<CategoryDataset> result = new ArrayList<>(); for (Entry<Integer, CategoryDataset> entry : this.datasets.entrySet()) {",
        "ins1PreCode":"private List<CategoryDataset> datasetsMappedToDomainAxis(int axisIndex) { List<CategoryDataset> result = new ArrayList<CategoryDataset>(); for (Entry<Integer, CategoryDataset> entry : this.datasets.entrySet()) {",
        "ins2PreCode":"private List<CategoryDataset> datasetsMappedToRangeAxis(int axisIndex) { List<CategoryDataset> result = new ArrayList<CategoryDataset>(); for (Entry<Integer, CategoryDataset> entry : this.datasets.entrySet()) {",
        "label":1
    },
    {
        "ins1CurCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { ResultMapReferencePersonMapper personMapper = sqlSession.getMapper(ResultMapReferencePersonMapper.class);",
        "ins1PreCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { ResultMapReferencePersonMapper personMapper = sqlSession.getMapper(ResultMapReferencePersonMapper.class);  Pet pet = personMapper.selectPet(1); assertEquals(Integer.valueOf(1), pet.getId());  } finally { sqlSession.close(); }",
        "ins2PreCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { ResultMapReferencePersonMapper personMapper = sqlSession.getMapper(ResultMapReferencePersonMapper.class);  Pet pet = personMapper.selectPet(1); assertEquals(Integer.valueOf(1), pet.getId());  } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":" ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) ); assertEquals( createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts(), \"Check artifact list\" ); Artifact artifact = getArtifact( \"c\", res.getArtifacts() );   assertEquals( Artifact.SCOPE_TEST, artifact.getScope(), \"Check artifactScope\" );",
        "ins1PreCode":" ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() ); Artifact artifact = getArtifact( \"c\", res.getArtifacts() );   assertEquals( \"Check artifactScope\", Artifact.SCOPE_TEST, artifact.getScope() );",
        "ins2PreCode":" ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, c.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, modifiedC } ), res.getArtifacts() ); Artifact artifact = getArtifact( \"c\", res.getArtifacts() );   assertEquals( \"Check artifactScope\", Artifact.SCOPE_PROVIDED, artifact.getScope() );",
        "label":1
    },
    {
        "ins1CurCode":"public void removeEdge_existingEdge() { assume().that(graphIsMutable()).isTrue();  addEdge(N1, N2, E12); assertTrue(networkAsMutableNetwork.removeEdge(E12)); assertFalse(networkAsMutableNetwork.removeEdge(E12)); assertThat(networkAsMutableNetwork.edges()).doesNotContain(E12); assertThat(networkAsMutableNetwork.edgesConnecting(N1, N2)).isEmpty();",
        "ins1PreCode":"public void removeEdge_existingEdge() { addEdge(N1, N2, E12); assertTrue(network.removeEdge(E12)); assertFalse(network.removeEdge(E12)); assertThat(network.edges()).doesNotContain(E12); assertThat(network.edgesConnecting(N1, N2)).isEmpty();",
        "ins2PreCode":"public void removeEdge_existingEdge() { addEdge(N1, N2, E12); assertTrue(network.removeEdge(E12)); assertFalse(network.removeEdge(E12)); assertThat(network.edges()).doesNotContain(E12); assertThat(network.edgesConnecting(N1, N2)).isEmpty();",
        "label":1
    },
    {
        "ins1CurCode":"try { return JSONCompare.compareJSON( ((expectedJson != null) ? expectedJson.toString() : null), this.actual.toString(), compareMode);",
        "ins1PreCode":"try { return JSONCompare.compareJSON( (expectedJson != null ? expectedJson.toString() : null), this.actual.toString(), compareMode);",
        "ins2PreCode":"try { return JSONCompare.compareJSON( (expectedJson != null ? expectedJson.toString() : null), this.actual.toString(), comparator);",
        "label":1
    },
    {
        "ins1CurCode":"XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0, 1.9, 2.1); XYIntervalDataItem item2 = CloneUtils.clone(item1); assertTrue(item1 != item2);",
        "ins1PreCode":"XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0, 1.9, 2.1); XYIntervalDataItem item2 = (XYIntervalDataItem) item1.clone(); assertTrue(item1 != item2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { YIntervalDataItem item1 = new YIntervalDataItem(1.0, 2.0, 1.5, 2.5); YIntervalDataItem item2 = (YIntervalDataItem) item1.clone(); assertTrue(item1 != item2);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such node 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)); ",
        "ins1PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such node 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); ",
        "ins2PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such node 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>(); ",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void map() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5)); JavaDoubleRDD doubles = rdd.mapToDouble(Integer::doubleValue).cache(); doubles.collect(); JavaPairRDD<Integer, Integer> pairs = rdd.mapToPair(x -> new Tuple2<>(x, x)).cache(); pairs.collect(); JavaRDD<String> strings = rdd.map(Object::toString).cache(); strings.collect();",
        "ins1PreCode":"public void map() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5)); JavaDoubleRDD doubles = rdd.mapToDouble(new DoubleFunction<Integer>() { @Override public double call(Integer x) { return x.doubleValue(); } }).cache(); doubles.collect(); JavaPairRDD<Integer, Integer> pairs = rdd.mapToPair( new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer x) { return new Tuple2<>(x, x); } }).cache(); pairs.collect(); JavaRDD<String> strings = rdd.map(new Function<Integer, String>() { @Override public String call(Integer x) { return x.toString(); } }).cache(); strings.collect();",
        "ins2PreCode":"public void map() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5)); JavaDoubleRDD doubles = rdd.mapToDouble(x -> 1.0 * x).cache(); doubles.collect(); JavaPairRDD<Integer, Integer> pairs = rdd.mapToPair(x -> new Tuple2<>(x, x)) .cache(); pairs.collect(); JavaRDD<String> strings = rdd.map(Object::toString).cache(); strings.collect();",
        "label":0
    },
    {
        "ins1CurCode":"public void testPatternsDifferInCaseScanningSensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"});",
        "ins1PreCode":"public void testPatternsDifferInCaseScanningSensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"});",
        "ins2PreCode":"public void testParentDiffersInCaseScanningSensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/beta/\"});",
        "label":1
    },
    {
        "ins1CurCode":"void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput output) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(output).contains(\"Reached the maximum number of URI tags for 'http.client.requests'.\") .contains(\"Are you using 'uriVariables'?\");",
        "ins1PreCode":"void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput capturedOutput) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(capturedOutput).contains(\"Reached the maximum number of URI tags for 'http.client.requests'.\") .contains(\"Are you using 'uriVariables'?\");",
        "ins2PreCode":"void afterMaxUrisReachedFurtherUrisAreDenied(CapturedOutput capturedOutput) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(capturedOutput).contains(\"Reached the maximum number of URI tags for 'http.client.requests'.\") .contains(\"Are you using 'uriVariables'?\");",
        "label":1
    },
    {
        "ins1CurCode":"public void incidentEdges_selfLoop() { assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void incidentEdges_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void incidentEdges_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"protected static final String addEscapes(String str) { StringBuffer retval = new StringBuffer(); char ch;",
        "ins1PreCode":"protected static final String addEscapes(String str) { StringBuilder retval = new StringBuilder(); char ch;",
        "ins2PreCode":"static String add_escapes(String str) { StringBuilder retval = new StringBuilder(); char ch;",
        "label":1
    },
    {
        "ins1CurCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false); s2.add(5.0, 5.0);",
        "ins1PreCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0);",
        "ins2PreCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(5.0, 5.0); s1.add(10.0, 15.5); s1.add(15.0, 9.5); s1.add(20.0, 7.5); dataset.addSeries(s1);  XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(5.0, 5.0);",
        "label":1
    },
    {
        "ins1CurCode":"static final QueueDrainObserver<Integer, Integer, Integer> createUnordered(TestObserver<Integer> to, final Disposable d) { return new QueueDrainObserver<Integer, Integer, Integer>(to, new SpscArrayQueue<>(4)) { @Override",
        "ins1PreCode":"static final QueueDrainObserver<Integer, Integer, Integer> createUnordered(TestObserver<Integer> to, final Disposable d) { return new QueueDrainObserver<Integer, Integer, Integer>(to, new SpscArrayQueue<Integer>(4)) { @Override",
        "ins2PreCode":"static final QueueDrainObserver<Integer, Integer, Integer> createOrdered(TestObserver<Integer> to, final Disposable d) { return new QueueDrainObserver<Integer, Integer, Integer>(to, new SpscArrayQueue<Integer>(4)) { @Override",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(0, g1.getURLCount(0));  List<String> list1 = new ArrayList<>(); list1.add(\"URL1\");",
        "ins1PreCode":"assertEquals(0, g1.getURLCount(0));  List list1 = new java.util.ArrayList(); list1.add(\"URL1\");",
        "ins2PreCode":"assertEquals(0, g1.getURLCount(0));  List list1 = new java.util.ArrayList(); list1.add(\"URL1\");",
        "label":1
    },
    {
        "ins1CurCode":"void parseTraceArg() { addPropertiesToEnvironment(this.context, \"trace\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output).contains(\"testatdebug\"); assertThat(this.output).contains(\"testattrace\");",
        "ins1PreCode":"public void parseTraceArg() { addPropertiesToEnvironment(this.context, \"trace\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "ins2PreCode":"public void parseLevels() { addPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=TRACE\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "label":1
    },
    {
        "ins1CurCode":"long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins1PreCode":"long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins2PreCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<120000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "label":0
    },
    {
        "ins1CurCode":"ps.onNext(1);  final Single<Integer> source = Single.ambArray(ps.singleOrError(), Single.<Integer>never(), Single.<Integer>never(), null); ",
        "ins1PreCode":"ps.onNext(1);  @SuppressWarnings(\"unchecked\") final Single<Integer> source = Single.ambArray(ps.singleOrError(), Single.<Integer>never(), Single.<Integer>never(), null);",
        "ins2PreCode":"ps.onNext(1);  @SuppressWarnings(\"unchecked\") final Maybe<Integer> source = Maybe.ambArray(ps.singleElement(),",
        "label":1
    },
    {
        "ins1CurCode":"void shouldFlushAllItemsOnDemand() { FifoCache cache = new FifoCache(new PerpetualCache(\"default\"));",
        "ins1PreCode":"public void shouldFlushAllItemsOnDemand() { FifoCache cache = new FifoCache(new PerpetualCache(\"default\"));",
        "ins2PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new SoftCache(new PerpetualCache(\"default\"));",
        "label":1
    },
    {
        "ins1CurCode":"HttpUtil.setContentLength(request, contentLength);  final FullHttpResponse response = client.send(remoteAddress.address(), request); try { assertThat(response.status(), equalTo(expectedStatus)); if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) { final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.EMPTY_BUFFER); final FullHttpResponse continuationResponse = client.send(remoteAddress.address(), continuationRequest); try {",
        "ins1PreCode":"HttpUtil.setContentLength(request, contentLength);  final FullHttpResponse response = client.post(remoteAddress.address(), request); try { assertThat(response.status(), equalTo(expectedStatus)); if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) { final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.EMPTY_BUFFER); final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest); try {",
        "ins2PreCode":"HttpUtil.setContentLength(request, contentLength);  final FullHttpResponse response = client.post(remoteAddress.address(), request); try { assertThat(response.status(), equalTo(expectedStatus)); if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) { final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.EMPTY_BUFFER); final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest); try {",
        "label":1
    },
    {
        "ins1CurCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeThat(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\"),",
        "ins1PreCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assertThat(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\"),",
        "ins2PreCode":"public void testFilterContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeThat(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\"), containsString(\"bye world\"));  buildRule.executeTarget(\"filtercontainsregex\"); String contents = getFileString(buildRule.getProject().getProperty(\"output\") + \"/filtercontainsregex\"); assertThat(contents, containsString(\"hello world\")); assertThat(contents, not(containsString(\"this is the moon\"))); assertThat(contents, containsString(\"World here\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void testAddOrUpdate3() { XYSeries<String> series = new XYSeries<>(\"Series\", false, true); series.addOrUpdate(1.0, 1.0);",
        "ins1PreCode":"public void testAddOrUpdate3() { XYSeries series = new XYSeries(\"Series\", false, true); series.addOrUpdate(1.0, 1.0);",
        "ins2PreCode":"public void testBug1955483() { XYSeries series = new XYSeries(\"Series\", true, true); series.addOrUpdate(1.0, 1.0);",
        "label":1
    },
    {
        "ins1CurCode":"public void testOldCvsFormat() { parser.stdout(\"Working file: build.xml\");",
        "ins1PreCode":"public void testOldCvsFormat() throws Exception { parser.stdout(\"Working file: build.xml\");",
        "ins2PreCode":"public void testCvs112Format() throws Exception { parser.stdout(\"Working file: build.xml\");",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Item.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\");",
        "label":1
    },
    {
        "ins1CurCode":"private Flowable<T> doOnEach(@NonNull Consumer<? super T> onNext, @NonNull Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { Objects.requireNonNull(onNext, \"onNext is null\"); Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new FlowableDoOnEach<>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins1PreCode":"private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { Objects.requireNonNull(onNext, \"onNext is null\"); Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins2PreCode":"Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "label":0
    },
    {
        "ins1CurCode":" byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; base.writeTo(0, data, BYTE_ARRAY_OFFSET, this.numBytes); int offset = this.numBytes; int idx = 0; while (idx < count) { pad.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); ++ idx; offset += pad.numBytes; } remain.base.writeTo(0, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes); ",
        "ins1PreCode":" byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes]; copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes); int offset = this.numBytes; int idx = 0; while (idx < count) { copyMemory(pad.base, pad.offset, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); ++ idx; offset += pad.numBytes; } copyMemory(remain.base, remain.offset, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes); ",
        "ins2PreCode":"int idx = 0; while (idx < count) { copyMemory(pad.base, pad.offset, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes); ++ idx; offset += pad.numBytes; } copyMemory(remain.base, remain.offset, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes); offset += remain.numBytes; copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET + offset, numBytes()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "ins1PreCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "ins2PreCode":"public void testDataSendACK() throws Exception { System.err.println(\"Starting ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST); Thread.sleep(250);",
        "label":0
    },
    {
        "ins1CurCode":"public final void testPerformExport(String filename) throws Exception { importFile = Paths.get(ModsExportFormatTestFiles.class.getResource(filename).toURI()); String xmlFileName = filename.replace(\".bib\", \".xml\"); Path tempFilename = tempFile.toAbsolutePath(); List<BibEntry> entries = bibtexImporter.importDatabase(importFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI());  modsExportFormat.export(databaseContext, tempFile, charset, entries);  Builder control = Input.from(Files.newInputStream(xmlFile)); Builder test = Input.from(Files.newInputStream(tempFilename));  assertThat(test, CompareMatcher.isSimilarTo(control) .withNodeMatcher(new DefaultNodeMatcher(ElementSelectors.byNameAndText)).throwComparisonFailure());",
        "ins1PreCode":"public final void testPerformExport() throws Exception { String xmlFileName = filename.replace(\".bib\", \".xml\"); String tempFilename = tempFile.getCanonicalPath(); List<BibEntry> entries = bibtexImporter.importDatabase(importFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI());  modsExportFormat.export(databaseContext, tempFile.toPath(), charset, entries);  Builder control = Input.from(Files.newInputStream(xmlFile)); Builder test = Input.from(Files.newInputStream(Paths.get(tempFilename)));  Assert.assertThat(test, CompareMatcher.isSimilarTo(control) .withNodeMatcher(new DefaultNodeMatcher(ElementSelectors.byNameAndText)).throwComparisonFailure());",
        "ins2PreCode":"public final void testImportAsModsAndExportAsMods() throws Exception { String xmlFileName = filename.replace(\".bib\", \".xml\"); String tempFilename = tempFile.getCanonicalPath(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI());  List<BibEntry> entries = modsImporter.importDatabase(xmlFile, charset).getDatabase().getEntries();  modsExportFormat.export(databaseContext, tempFile.toPath(), charset, entries);  Builder control = Input.from(Files.newInputStream(xmlFile)); Builder test = Input.from(Files.newInputStream(Paths.get(tempFilename)));  Assert.assertThat(test, CompareMatcher.isSimilarTo(control) .withNodeMatcher(new DefaultNodeMatcher(ElementSelectors.byNameAndText)).throwComparisonFailure());",
        "label":1
    },
    {
        "ins1CurCode":" try { File javaFile = new File(ctxt.getServletJavaFileName()); if (log.isDebugEnabled())",
        "ins1PreCode":" try { String javaFileName = ctxt.getServletJavaFileName(); if (javaFileName != null) { File javaFile = new File(javaFileName); if (log.isDebugEnabled())",
        "ins2PreCode":"public void removeGeneratedClassFiles() { try { String classFileName = ctxt.getClassFileName(); if (classFileName != null) { File classFile = new File(classFileName); if (log.isDebugEnabled())",
        "label":0
    },
    {
        "ins1CurCode":"void iterate() { MimeMappings mappings = new MimeMappings();",
        "ins1PreCode":"public void iterate() { MimeMappings mappings = new MimeMappings();",
        "ins2PreCode":"public void getAll() { MimeMappings mappings = new MimeMappings();",
        "label":1
    },
    {
        "ins1CurCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(null, 2.0, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(null, new Double(2.0), new Double(0.0), new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "ins2PreCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), null, new Double(0.0), new Double(4.0), new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset,",
        "label":0
    },
    {
        "ins1CurCode":"insertRow(row2);  assert(compare(0, 1) > 0);",
        "ins1PreCode":"insertRow(row2);  assert(compare(0, 1) < 0);",
        "ins2PreCode":"public void testBinaryComparatorWhenSubtractionCanOverflowLongValue() throws Exception { int numFields = 1;  UnsafeRow row1 = new UnsafeRow(numFields); byte[] data1 = new byte[100]; row1.pointTo(data1, computeSizeInBytes(numFields * 8)); row1.setLong(0, Long.MIN_VALUE);  UnsafeRow row2 = new UnsafeRow(numFields); byte[] data2 = new byte[100]; row2.pointTo(data2, computeSizeInBytes(numFields * 8)); row2.setLong(0, 1);  insertRow(row1); insertRow(row2);  assert(compare(0, 1) < 0);",
        "label":0
    },
    {
        "ins1CurCode":"void entriesAreParsedHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeader, importFormatPreferences, fileMonitor);",
        "ins1PreCode":"public void entriesAreParsedHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeader, importFormatPreferences, fileMonitor);",
        "ins2PreCode":"public void entriesAreParsedHeaderAndSignature() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeaderAndSignature, importFormatPreferences, fileMonitor);",
        "label":1
    },
    {
        "ins1CurCode":"return false; } if (!Objects.equals(this.stroke, that.stroke)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtils.equal(this.stroke, that.stroke)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtils.equal(this.stroke, that.stroke)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"principal = getPrincipal(context, username, gssCredential);  } catch (CommunicationException | ServiceUnavailableException e) { ",
        "ins1PreCode":"principal = getPrincipal(context, username, gssCredential);  } catch (CommunicationException e) {   containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = getPrincipal(context, username, gssCredential);  } catch (ServiceUnavailableException e) { ",
        "ins2PreCode":"principal = authenticate(context, username, credentials);  } catch (NullPointerException e) {     containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials);  } catch (CommunicationException e) {   containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials);  } catch (ServiceUnavailableException e) { ",
        "label":0
    },
    {
        "ins1CurCode":"public void testAsciiFoldingFilterForSynonyms() throws IOException { Settings settings = Settings.builder() .put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT) .put(\"path.home\", createTempDir().toString())",
        "ins1PreCode":"public void testAsciiFoldingFilterForSynonyms() throws IOException { Settings settings = Settings.builder() .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT) .put(\"path.home\", createTempDir().toString())",
        "ins2PreCode":"public void testPreconfigured() throws IOException { Settings settings = Settings.builder() .put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT) .put(\"path.home\", createTempDir().toString())",
        "label":1
    },
    {
        "ins1CurCode":"} else { active = true; inner.setSubscription(new WeakScalarSubscription<>(vr, inner)); }",
        "ins1PreCode":"} else { active = true; inner.setSubscription(new WeakScalarSubscription<R>(vr, inner)); }",
        "ins2PreCode":"} else { active = true; inner.setSubscription(new WeakScalarSubscription<R>(vr, inner)); }",
        "label":1
    },
    {
        "ins1CurCode":"kv2D1.addValue(452.7, \"Row2\", \"Col2\");  DefaultKeyedValues2D<String, String> kv2D2 = TestUtils.serialised(kv2D1); assertEquals(kv2D1, kv2D2);",
        "ins1PreCode":"kv2D1.addValue(452.7, \"Row2\", \"Col2\");  DefaultKeyedValues2D<String, String> kv2D2 = (DefaultKeyedValues2D) TestUtils.serialised(kv2D1); assertEquals(kv2D1, kv2D2);",
        "ins2PreCode":"public void testSerialization() { DefaultKeyedValues2DDataset d1 = new DefaultKeyedValues2DDataset(); d1.addValue(new Double(234.2), \"Row1\", \"Col1\"); d1.addValue(null, \"Row1\", \"Col2\"); d1.addValue(new Double(345.9), \"Row2\", \"Col1\"); d1.addValue(new Double(452.7), \"Row2\", \"Col2\");  DefaultKeyedValues2DDataset d2 = (DefaultKeyedValues2DDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":0
    },
    {
        "ins1CurCode":"void constructorParameterNestedPropertySameClass() throws IOException { process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void constructorParameterNestedPropertySameClass() throws IOException { process(ImmutableInnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void javaBeanNestedPropertySameClass() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":".setImplicitPrefs(true) .run(data.rdd()); validatePrediction(model, users, products, testData._2(), 0.4, true, testData._3());",
        "ins1PreCode":".setImplicitPrefs(true) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins2PreCode":".setSeed(8675309L) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "label":1
    },
    {
        "ins1CurCode":"public void testAcceptZeroPermissions() throws IOException { buildRule.executeTarget(\"acceptZeroPermissions\"); try (org.apache.tools.zip.ZipFile zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\"))) { org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "ins1PreCode":"public void testAcceptZeroPermissions() throws IOException { buildRule.executeTarget(\"acceptZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\"); assertEquals(0000, ze.getUnixMode()); } finally { if (zf != null) { zf.close(); }",
        "ins2PreCode":"public void testForBugzilla34764() throws IOException { buildRule.executeTarget(\"testForBugzilla34764\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"file1\"); assertEquals(UnixStat.FILE_FLAG | 0644, ze.getUnixMode()); } finally { if (zf != null) { zf.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"return false; } throw new BuildException(\"could not date test remote file: %s\", ftp.getReplyString()); }  long remoteTimestamp = files[0].getTimestamp().getTime().getTime(); long localTimestamp = localFile.lastModified(); long adjustedRemoteTimestamp = remoteTimestamp + task.getTimeDiffMillis() + task.getGranularityMillis();  StringBuilder msg; synchronized(TIMESTAMP_LOGGING_SDF) { msg = new StringBuilder(\"   [\") .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))) .append(\"] local\"); } task.log(msg.toString(), Project.MSG_VERBOSE);  synchronized(TIMESTAMP_LOGGING_SDF) { msg = new StringBuilder(\"   [\") .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp)))",
        "ins1PreCode":"+ \"assuming out of date.\", Project.MSG_VERBOSE); return false; } else { throw new BuildException(\"could not date test remote file: \" + ftp.getReplyString()); } }  long remoteTimestamp = files[0].getTimestamp().getTime().getTime(); long localTimestamp = localFile.lastModified(); long adjustedRemoteTimestamp = remoteTimestamp + task.getTimeDiffMillis() + task.getGranularityMillis();  StringBuffer msg; synchronized(TIMESTAMP_LOGGING_SDF) { msg = new StringBuffer(\"   [\") .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))) .append(\"] local\"); } task.log(msg.toString(), Project.MSG_VERBOSE);  synchronized(TIMESTAMP_LOGGING_SDF) { msg = new StringBuffer(\"   [\") .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp))) .append(\"] remote\"); } if (remoteTimestamp != adjustedRemoteTimestamp) { synchronized(TIMESTAMP_LOGGING_SDF) { msg.append(\" - (raw: \") .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp))) .append(\")\"); } } task.log(msg.toString(), Project.MSG_VERBOSE);  if (task.getAction() == FTPTask.SEND_FILES) { return adjustedRemoteTimestamp >= localTimestamp; } else { return localTimestamp >= adjustedRemoteTimestamp;",
        "ins2PreCode":"+ \"assuming out of date.\", Project.MSG_VERBOSE); return false; } else { throw new BuildException(\"could not date test remote file: \" + ftp.getReplyString()); } }  long remoteTimestamp = files[0].getTimestamp().getTime().getTime(); long localTimestamp = localFile.lastModified(); long adjustedRemoteTimestamp = remoteTimestamp + this.timeDiffMillis + this.granularityMillis;  StringBuffer msg; synchronized(TIMESTAMP_LOGGING_SDF) { msg = new StringBuffer(\"   [\") .append(TIMESTAMP_LOGGING_SDF.format(new Date(localTimestamp))) .append(\"] local\"); } log(msg.toString(), Project.MSG_VERBOSE);  synchronized(TIMESTAMP_LOGGING_SDF) { msg = new StringBuffer(\"   [\") .append(TIMESTAMP_LOGGING_SDF.format(new Date(adjustedRemoteTimestamp))) .append(\"] remote\"); } if (remoteTimestamp != adjustedRemoteTimestamp) { synchronized(TIMESTAMP_LOGGING_SDF) { msg.append(\" - (raw: \") .append(TIMESTAMP_LOGGING_SDF.format(new Date(remoteTimestamp))) .append(\")\"); } } log(msg.toString(), Project.MSG_VERBOSE);    if (this.action == SEND_FILES) { return adjustedRemoteTimestamp >= localTimestamp; } else { return localTimestamp >= adjustedRemoteTimestamp;",
        "label":1
    },
    {
        "ins1CurCode":"void testNormal() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\");",
        "ins1PreCode":"public void testNormal() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\");",
        "ins2PreCode":"public void testNotAllFound() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\");",
        "label":1
    },
    {
        "ins1CurCode":"int products = 160; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); ",
        "ins1PreCode":"int products = 160; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true); ",
        "ins2PreCode":"int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true); ",
        "label":1
    },
    {
        "ins1CurCode":"final AtomicInteger loopcount = new AtomicInteger(0); final Runnable run = new Runnable() { @Override public void run() {",
        "ins1PreCode":"final AtomicInteger loopcount = new AtomicInteger(0); final Runnable run = new Runnable() { public void run() { try {",
        "ins2PreCode":"final AtomicInteger loopcount = new AtomicInteger(0); final Runnable run = new Runnable() { public void run() { try {",
        "label":1
    },
    {
        "ins1CurCode":" addFig(getStereotypeFig()); createCompartments(); ",
        "ins1PreCode":"  if (Model.getUmlFactory().isContainmentValid( Model.getMetaTypes().getAttribute(), getOwner())) { addFig(new FigAttributesCompartment( getOwner(), DEFAULT_COMPARTMENT_BOUNDS, getSettings())); } addFig(getOperationsFig()); ",
        "ins2PreCode":"addFig(getNameFig()); addFig(getStereotypeFig()); addExtraCompartments(); addFig(getOperationsFig()); ",
        "label":0
    },
    {
        "ins1CurCode":"Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber(); oi.subscribe(new TestSubscriber<>(mockSubscriber)); ",
        "ins1PreCode":"Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber(); oi.subscribe(new TestSubscriber<Integer>(mockSubscriber)); ",
        "ins2PreCode":"Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber();  oi.subscribe(new TestSubscriberEx<Integer>(mockSubscriber)); ",
        "label":1
    },
    {
        "ins1CurCode":"void toAnyEndpointShouldMatchEndpointPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint();",
        "ins1PreCode":"public void toAnyEndpointShouldMatchEndpointPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint();",
        "ins2PreCode":"public void toAnyEndpointWhenDispatcherServletPathProviderNotAvailableUsesEmptyPath() { RequestMatcher matcher = EndpointRequest.toAnyEndpoint();",
        "label":1
    },
    {
        "ins1CurCode":"bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); } this.storage = new TemporaryContentStorage(platform, tempFile, getDefaultEncoding()); }",
        "ins1PreCode":"bs, contentLength, platform.getPreferenceStore().getString(ModelPreferences.CONTENT_HEX_ENCODING)); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); } this.storage = new TemporaryContentStorage(platform, tempFile); }",
        "ins2PreCode":"bs, contentLength, platform.getPreferenceStore().getString(ModelPreferences.CONTENT_HEX_ENCODING)); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + bfile.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = getInputStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); } this.storage = new TemporaryContentStorage(platform, tempFile); }",
        "label":1
    },
    {
        "ins1CurCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "ins2PreCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1CurCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Path.of(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "ins1PreCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "ins2PreCode":"public void testUnknownKey() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "label":1
    },
    {
        "ins1CurCode":"AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\"); String[] lines = banner.split(System.lineSeparator()); for (int i = 2; i < lines.length - 1; i++) {",
        "ins1PreCode":"AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\"); String[] lines = banner.split(NEW_LINE); for (int i = 2; i < lines.length - 1; i++) {",
        "ins2PreCode":"AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\", \"spring.banner.image.margin=4\"); String[] lines = banner.split(NEW_LINE); for (int i = 2; i < lines.length - 1; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetMinX() { XYSeries<String> s1 = new XYSeries<>(\"S1\"); assertTrue(Double.isNaN(s1.getMinX()));",
        "ins1PreCode":"public void testGetMinX() { XYSeries s1 = new XYSeries(\"S1\"); assertTrue(Double.isNaN(s1.getMinX()));",
        "ins2PreCode":"public void testGetMinY() { XYSeries s1 = new XYSeries(\"S1\"); assertTrue(Double.isNaN(s1.getMinY()));",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(v).hide(); } }, false, 2, ImmediateThinScheduler.INSTANCE); }",
        "ins1PreCode":"return Flowable.just(v).hide(); } }, 2, false, ImmediateThinScheduler.INSTANCE); }",
        "ins2PreCode":"return Flowable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); }",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"} if (f.isFile()) { if (lastRotateMillis + logRotateMillis < System.currentTimeMillis() || (logRotateSize > 0 && f.length() > logRotateSize)) {",
        "ins1PreCode":"} if (f.isFile()) { if ((lastRotateMillis + logRotateMillis < System.currentTimeMillis()) || (logRotateSize > 0 && f.length() > logRotateSize)) {",
        "ins2PreCode":"} if (f.isFile()) { if ((lastRotateMillis + logRotateMillis < System.currentTimeMillis()) || (logRotateSize > 0 && f.length() > logRotateSize)) {",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"Include\", new NamedIncludeServlet()); ctx.addServletMappingDecoded(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMappingDecoded(\"/mapping\", \"Mapping\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"Include\", new NamedIncludeServlet()); ctx.addServletMapping(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"Forward\", new NamedForwardServlet()); ctx.addServletMapping(mapping, \"Forward\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); ",
        "label":1
    },
    {
        "ins1CurCode":"d1.add(2.0, 2.2, \"Series 1\");  CategoryTableXYDataset d2 = CloneUtils.clone(d1); assertTrue(d1 != d2);",
        "ins1PreCode":"d1.add(2.0, 2.2, \"Series 1\");  CategoryTableXYDataset d2 = (CategoryTableXYDataset) d1.clone(); assertTrue(d1 != d2);",
        "ins2PreCode":"d1.setIntervalWidth(1.23);  CategoryTableXYDataset d2 = (CategoryTableXYDataset) d1.clone(); assertTrue(d1 != d2);",
        "label":1
    },
    {
        "ins1CurCode":"final PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<SingleObserver<? super Integer>> obs = new AtomicReference<>(); ",
        "ins1PreCode":"final PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<SingleObserver<? super Integer>> obs = new AtomicReference<SingleObserver<? super Integer>>(); ",
        "ins2PreCode":"final PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<MaybeObserver<? super Integer>> obs = new AtomicReference<MaybeObserver<? super Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSearchAllFields() { BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS); e.setField(\"title\", \"Fruity features\");",
        "ins1PreCode":"public void testSearchAllFields() { BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS.getName()); e.setField(\"title\", \"Fruity features\");",
        "ins2PreCode":"public void testSearchingForOpenBraketInBooktitle() { BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS.getName()); e.setField(FieldName.BOOKTITLE, \"Super Conference (SC)\");  SearchQuery searchQuery = new SearchQuery(\"booktitle=\\\"(\\\"\", false, false); assertTrue(searchQuery.isMatch(e));",
        "label":0
    },
    {
        "ins1CurCode":"})); EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint); assertThatExceptionOfType(MBeanException.class) .isThrownBy(() -> bean.invoke(\"testOperation\", NO_PARAMS, NO_SIGNATURE)) .withCauseInstanceOf(IllegalStateException.class) .withMessageContaining(\"test failure\"); ",
        "ins1PreCode":"})); EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint); this.thrown.expect(MBeanException.class); this.thrown.expectCause(instanceOf(IllegalStateException.class)); this.thrown.expectMessage(\"test failure\"); bean.invoke(\"testOperation\", NO_PARAMS, NO_SIGNATURE);",
        "ins2PreCode":"})); EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint); this.thrown.expect(MBeanException.class); this.thrown.expectCause(instanceOf(UnsupportedOperationException.class)); this.thrown.expectMessage(\"test failure\"); bean.invoke(\"testOperation\", NO_PARAMS, NO_SIGNATURE);",
        "label":1
    },
    {
        "ins1CurCode":"Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI());  LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); LatexParserResult expectedParserResult = new LatexParserResult(); ",
        "ins1PreCode":"Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI());  TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexParserResult expectedParserResult = new TexParserResult(); ",
        "ins2PreCode":"Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-15.tex\").toURI());  TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexParserResult expectedParserResult = new TexParserResult(); ",
        "label":1
    },
    {
        "ins1CurCode":"void shouldResolveArraySetterParam() { ReflectorFactory reflectorFactory = new DefaultReflectorFactory();",
        "ins1PreCode":"public void shouldResolveArraySetterParam() throws Exception { ReflectorFactory reflectorFactory = new DefaultReflectorFactory();",
        "ins2PreCode":"public void shouldResolveArrayGetterType() throws Exception { ReflectorFactory reflectorFactory = new DefaultReflectorFactory();",
        "label":1
    },
    {
        "ins1CurCode":"void testCallWithResultSet3() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testCallWithResultSet3() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testCallWithResultSet4() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDomainMarkerIndices() { XYDataset<String> dataset = new XYSeriesCollection<>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins1PreCode":"public void testDomainMarkerIndices() { XYDataset dataset = new XYSeriesCollection<String>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins2PreCode":"public void testRangeMarkerIndices() { XYDataset dataset = new XYSeriesCollection<String>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "label":1
    },
    {
        "ins1CurCode":"public void nonNotificationInstanceAfterDispose() { new Observable<Object>() { @Override protected void subscribeActual(Observer<? super Object> observer) { observer.onSubscribe(Disposable.empty()); observer.onNext(Notification.createOnComplete()); observer.onNext(1); } } .dematerialize(v -> (Notification<Object>)v) .test()",
        "ins1PreCode":"public void nonNotificationInstanceAfterDispose() { new Observable<Notification<Object>>() { @Override protected void subscribeActual(Observer<? super Notification<Object>> observer) { observer.onSubscribe(Disposable.empty()); observer.onNext(Notification.createOnComplete()); observer.onNext(Notification.<Object>createOnNext(1)); } } .dematerialize(Functions.<Notification<Object>>identity()) .test()",
        "ins2PreCode":"public void nonNotificationInstanceAfterDispose() { new Flowable<Notification<Object>>() { @Override protected void subscribeActual(Subscriber<? super Notification<Object>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(Notification.createOnComplete()); subscriber.onNext(Notification.<Object>createOnNext(1)); } } .dematerialize(Functions.<Notification<Object>>identity()) .test()",
        "label":1
    },
    {
        "ins1CurCode":"  expected.remove(ACMPortalFetcher.class); ",
        "ins1PreCode":"assertEquals(expected, getClasses(searchBasedFetchers)); }",
        "ins2PreCode":"void getFullTextFetchersReturnsAllFetcherDerivingFromFullTextFetcher() throws Exception { Set<FulltextFetcher> fullTextFetchers = WebFetchers.getFullTextFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(fullTextFetchers)); }",
        "label":0
    },
    {
        "ins1CurCode":" String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = new SortProcessor(randomAlphaOfLength(10), null, fieldName, order, fieldName); processor.execute(ingestDocument);",
        "ins1PreCode":" String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, order, fieldName); processor.execute(ingestDocument);",
        "ins2PreCode":" String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, order, fieldName); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1CurCode":"final CountDownLatch end = new CountDownLatch(count);  final List<Thread> threads = new ArrayList<>(); for (int i = 0; i < count; i++) {",
        "ins1PreCode":"final CountDownLatch end = new CountDownLatch(count);  final List<Thread> threads = new ArrayList<Thread>(); for (int i = 0; i < count; i++) {",
        "ins2PreCode":"final CountDownLatch end = new CountDownLatch(count);  final List<Thread> threads = new ArrayList<Thread>(); for (int i = 0; i < count; i++) {",
        "label":1
    },
    {
        "ins1CurCode":"XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0, 1.9, 2.1); XYIntervalDataItem item2 = CloneUtils.clone(item1); assertTrue(item1 != item2);",
        "ins1PreCode":"XYIntervalDataItem item1 = new XYIntervalDataItem(1.0, 0.5, 1.5, 2.0, 1.9, 2.1); XYIntervalDataItem item2 = (XYIntervalDataItem) item1.clone(); assertTrue(item1 != item2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCItem item1 = new OHLCItem(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCItem item2 = CloneUtils.clone(item1); assertTrue(item1 != item2); assertTrue(item1.getClass() == item2.getClass()); assertTrue(item1.equals(item2));",
        "label":0
    },
    {
        "ins1CurCode":"public void exceptionsIncludeClassPackaging() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins1PreCode":"public void exceptionsIncludeClassPackaging() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins2PreCode":"public void exceptionsIncludeClassPackaging() throws Exception { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "label":1
    },
    {
        "ins1CurCode":"public void multipleErrors2() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins1PreCode":"public void multipleErrors2() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins2PreCode":"public void multipleErrors3() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "label":1
    },
    {
        "ins1CurCode":"final Path geoIpDir = createTempDir(); final Path configDir = createTempDir(); final Path geoIpConfigDir = configDir.resolve(\"ingest-geoip\"); Files.createDirectories(geoIpConfigDir);",
        "ins1PreCode":"  assumeFalse(\"windows deletion behavior is asinine\", Constants.WINDOWS); final Path geoIpDir = createTempDir();",
        "ins2PreCode":"public void testLoadingCustomDatabase() throws IOException { final Path geoIpDir = createTempDir(); final Path configDir = createTempDir(); final Path geoIpConfigDir = configDir.resolve(\"ingest-geoip\"); Files.createDirectories(geoIpConfigDir); copyDatabaseFiles(geoIpDir);  copyDatabaseFile(geoIpConfigDir, \"GeoLite2-City.mmdb\"); Files.move(geoIpConfigDir.resolve(\"GeoLite2-City.mmdb\"), geoIpConfigDir.resolve(\"GeoIP2-City.mmdb\"));      final Map<String, DatabaseReaderLazyLoader> databaseReaders = IngestGeoIpPlugin.loadDatabaseReaders(geoIpDir, geoIpConfigDir); final GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)); for (DatabaseReaderLazyLoader lazyLoader : databaseReaders.values()) { assertNull(lazyLoader.databaseReader.get()); }  final Map<String, Object> field = Collections.singletonMap(\"_field\", \"1.1.1.1\"); final IngestDocument document = new IngestDocument(\"index\", \"type\", \"id\", \"routing\", 1L, VersionType.EXTERNAL, field);  Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config);   assertNull(databaseReaders.get(\"GeoIP2-City.mmdb\").databaseReader.get()); city.execute(document);  assertNotNull(databaseReaders.get(\"GeoIP2-City.mmdb\").databaseReader.get());",
        "label":0
    },
    {
        "ins1CurCode":"protected GreenplumSchema fetchObject(@NotNull JDBCSession session, @NotNull PostgreDatabase owner, @NotNull JDBCResultSet resultSet) throws SQLException { String name = JDBCUtils.safeGetString(resultSet, \"nspname\");",
        "ins1PreCode":"protected GreenplumSchema fetchObject(@NotNull JDBCSession session, @NotNull PostgreDatabase owner, @NotNull JDBCResultSet resultSet) throws SQLException, DBException { String name = JDBCUtils.safeGetString(resultSet, \"nspname\");",
        "ins2PreCode":"protected PostgreSchema fetchObject(@NotNull JDBCSession session, @NotNull PostgreDatabase owner, @NotNull JDBCResultSet resultSet) throws SQLException, DBException { String name = JDBCUtils.safeGetString(resultSet, \"nspname\"); if (name == null) { return null; } if (PostgreSchema.isUtilitySchema(name) && !owner.getDataSource().getContainer().isShowUtilityObjects()) { return null; } return new PostgreSchema(owner, name, resultSet);",
        "label":0
    },
    {
        "ins1CurCode":"return Boolean.FALSE; } return (compare(ctx, obj0, obj1) <= 0) ? Boolean.TRUE : Boolean.FALSE;",
        "ins1PreCode":"return Boolean.FALSE; } return (compare(obj0, obj1) <= 0) ? Boolean.TRUE : Boolean.FALSE;",
        "ins2PreCode":"return Boolean.FALSE; } return (compare(obj0, obj1) >= 0) ? Boolean.TRUE : Boolean.FALSE;",
        "label":1
    },
    {
        "ins1CurCode":"void completeValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); database.insertEntry(entry);  Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1PreCode":"public void completeValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"public void completeBeginnigOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"test\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, ignored -> fieldData, null);",
        "ins1PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(Settings.EMPTY); lookup = new SearchLookup(mapperService, ignored -> fieldData, null);",
        "ins2PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(Settings.EMPTY); lookup = new SearchLookup(mapperService, ignored -> fieldData, null);",
        "label":1
    },
    {
        "ins1CurCode":"stmt += caseSensitive ?             \" COLUMN_NAME LIKE ?\" : \" UPPER(COLUMN_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY SCHEMA_NAME, TABLE_NAME, COLUMN_NAME LIMIT \" + maxResults; ",
        "ins1PreCode":"stmt += caseSensitive ?             \" COLUMN_NAME LIKE ?\" : \" UPPER(COLUMN_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY COLUMN_NAME LIMIT \" + maxResults; ",
        "ins2PreCode":"stmt += caseSensitive ?             \" COLUMN_NAME LIKE ?\" : \" UPPER(COLUMN_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY COLUMN_NAME LIMIT \" + maxResults; ",
        "label":1
    },
    {
        "ins1CurCode":"if (block) { long timeout = getReadTimeout(); long startNanos = 0; do { if (startNanos > 0) { long elapsedMillis = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos); if (elapsedMillis == 0) { elapsedMillis = 1; } timeout -= elapsedMillis; if (timeout <= 0) { throw new SocketTimeoutException(); } } n = socket.read(buffer); if (n == -1) { throw new EOFException(); } else if (n == 0) { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { startNanos = System.nanoTime(); readLock.wait(timeout);",
        "ins1PreCode":"throw new EOFException(); } if (n == 0) { readBlocking = true;",
        "ins2PreCode":"throw new EOFException(); } if (n == 0) { writeBlocking = true;",
        "label":0
    },
    {
        "ins1CurCode":"public int read() throws IOException { if (!getInitialized()) {",
        "ins1PreCode":"public final int read() throws IOException { if (!getInitialized()) {",
        "ins2PreCode":"public final int read() throws IOException { if (!getInitialized()) {",
        "label":1
    },
    {
        "ins1CurCode":"int nextChar() { if (!hasMoreInput())",
        "ins1PreCode":"int nextChar() throws JasperException { if (!hasMoreInput())",
        "ins2PreCode":"private int nextChar(Mark mark) throws JasperException { if (!hasMoreInput()) {",
        "label":1
    },
    {
        "ins1CurCode":" if (varInfos.length > 0) { for (VariableInfo varInfo : varInfos) { if (varInfo.getScope() != scope) continue;   if (declaredVariables.contains(varInfo)) continue; String varName = varInfo.getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(tmpVarName); out.print(\" = \"); out.print(varName); out.println(\";\"); } } else { for (TagVariableInfo tagVarInfo : tagVarInfos) { if (tagVarInfo.getScope() != scope) continue;   if (declaredVariables.contains(tagVarInfo)) continue; String varName = tagVarInfo.getNameGiven(); if (varName == null) { varName = n.getTagData().getAttributeString( tagVarInfo.getNameFromAttribute()); } else if (tagVarInfo.getNameFromAttribute() != null) { ",
        "ins1PreCode":" if (varInfos.length > 0) { for (int i = 0; i < varInfos.length; i++) { if (varInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(tmpVarName); out.print(\" = \"); out.print(varName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(tagVarInfos[i])) continue; String varName = tagVarInfos[i].getNameGiven(); if (varName == null) { varName = n.getTagData().getAttributeString( tagVarInfos[i].getNameFromAttribute()); } else if (tagVarInfos[i].getNameFromAttribute() != null) { ",
        "ins2PreCode":" if (varInfos.length > 0) { for (int i = 0; i < varInfos.length; i++) { if (varInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(varName); out.print(\" = \"); out.print(tmpVarName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(tagVarInfos[i])) continue; String varName = tagVarInfos[i].getNameGiven(); if (varName == null) { varName = n.getTagData().getAttributeString( tagVarInfos[i].getNameFromAttribute()); } else if (tagVarInfos[i].getNameFromAttribute() != null) { ",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual( Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); sub[count++] = observer;",
        "ins1PreCode":"protected void subscribeActual( Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); sub[count++] = observer;",
        "ins2PreCode":"Observer<? super Integer> observer) { assertFalse(((Disposable)observer).isDisposed()); observer.onSubscribe(Disposables.empty()); sub[count++] = observer;",
        "label":1
    },
    {
        "ins1CurCode":"final CountDownLatch l1 = new CountDownLatch(100); final CountDownLatch l2 = new CountDownLatch(150); TestSubscriber<Long> ts = new TestSubscriber<>(new DefaultSubscriber<Long>() { ",
        "ins1PreCode":"final CountDownLatch l1 = new CountDownLatch(100); final CountDownLatch l2 = new CountDownLatch(150); TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() { ",
        "ins2PreCode":"final CountDownLatch l1 = new CountDownLatch(100); final CountDownLatch l2 = new CountDownLatch(150); TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() { ",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetYValue() { DefaultIntervalXYDataset<String> d = createSampleDataset1(); assertEquals(4.0, d.getYValue(0, 0), EPSILON);",
        "ins1PreCode":"public void testGetYValue() { DefaultIntervalXYDataset d = createSampleDataset1(); assertEquals(4.0, d.getYValue(0, 0), EPSILON);",
        "ins2PreCode":"public void testGetStartXValue() { DefaultIntervalXYDataset d = createSampleDataset1(); assertEquals(0.9, d.getStartXValue(0, 0), EPSILON);",
        "label":1
    },
    {
        "ins1CurCode":"StatisticalLineAndShapeRenderer r1 = new StatisticalLineAndShapeRenderer(); StatisticalLineAndShapeRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"StatisticalLineAndShapeRenderer r1 = new StatisticalLineAndShapeRenderer(); StatisticalLineAndShapeRenderer r2 = (StatisticalLineAndShapeRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); CustomCache customCache = unwrap(sqlSessionFactory.getConfiguration().getCache(Mapper.class.getName())); Assert.assertEquals(\"User1\", user.getName()); Assert.assertEquals(\"foo\", customCache.getStringValue()); Assert.assertEquals(10, customCache.getIntegerValue().intValue()); Assert.assertEquals(1000, customCache.getLongValue()); } finally {",
        "ins1PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); Assert.assertEquals(\"User1\", user.getName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"AnnotationMapper mapper = sqlSession.getMapper(AnnotationMapper.class); User user = mapper.getUser(1); Assert.assertEquals(\"User1\", user.getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) { try { DescribableList r = (DescribableList) context.getRequiredType().asSubclass(DescribableList.class).getDeclaredConstructor().newInstance(); CopyOnWriteList core = copyOnWriteListConverter.unmarshal(reader, context); r.data.replaceBy(core); return r; } catch (NoSuchMethodException e) { NoSuchMethodError x = new NoSuchMethodError(); x.initCause(e); throw x; } catch (InstantiationException e) { InstantiationError x = new InstantiationError(); x.initCause(e); throw x; } catch (IllegalAccessException e) { IllegalAccessError x = new IllegalAccessError(); x.initCause(e); throw x; } catch (InvocationTargetException e) { Throwable t = e.getCause(); if (t instanceof RuntimeException) { throw (RuntimeException) t; } else if (t instanceof IOException) { throw new UncheckedIOException((IOException) t); } else if (t instanceof Exception) { throw new RuntimeException(t); } else if (t instanceof Error) { throw (Error) t; } else { throw new Error(e); }",
        "ins1PreCode":"public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) { try { DescribableList r = (DescribableList) context.getRequiredType().asSubclass(DescribableList.class).newInstance(); CopyOnWriteList core = copyOnWriteListConverter.unmarshal(reader, context);",
        "ins2PreCode":" try { PersistedList r = (PersistedList)context.getRequiredType().newInstance(); r.data.replaceBy(core);",
        "label":1
    },
    {
        "ins1CurCode":"public Hashtable getDataTypeDefinitions() { synchronized (typeClassDefinitions) { synchronized (antTypeTable) { if (rebuildTypeClassDefinitions) { typeClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = (Class) antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (!(Task.class.isAssignableFrom(clazz))) { typeClassDefinitions.put(",
        "ins1PreCode":"public Hashtable getDataTypeDefinitions() { synchronized(typeClassDefinitions) { synchronized (antTypeTable) { if (rebuildTypeClassDefinitions) { typeClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = (Class) antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (! Task.class.isAssignableFrom(clazz)) { typeClassDefinitions.put(",
        "ins2PreCode":"public Hashtable getTaskDefinitions() { synchronized(taskClassDefinitions) { synchronized (antTypeTable) { if (rebuildTaskClassDefinitions) { taskClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = (Class) antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (Task.class.isAssignableFrom(clazz)) { taskClassDefinitions.put( name, antTypeTable.getTypeClass(name)); } } rebuildTaskClassDefinitions = false; } } } return taskClassDefinitions;",
        "label":0
    },
    {
        "ins1CurCode":"{ case 99: return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L); default :",
        "ins1PreCode":"{ case 99: return jjMoveStringLiteralDfa7_1(active0, 0x40000000000L); default :",
        "ins2PreCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x40000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"void incrementalEndpointBuildChangeGeneralEnabledFlag() throws Exception { TestProject project = new TestProject(this.tempDir, IncrementalEndpoint.class); ConfigurationMetadata metadata = project.fullBuild();",
        "ins1PreCode":"public void incrementalEndpointBuildChangeGeneralEnabledFlag() throws Exception { TestProject project = new TestProject(this.temporaryFolder, IncrementalEndpoint.class); ConfigurationMetadata metadata = project.fullBuild();",
        "ins2PreCode":"public void incrementalEndpointBuildChangeCacheFlag() throws Exception { TestProject project = new TestProject(this.temporaryFolder, IncrementalEndpoint.class); ConfigurationMetadata metadata = project.fullBuild();",
        "label":1
    },
    {
        "ins1CurCode":"private void assertMapValuesCleared(TestMapOrBuilder testMapOrBuilder) { assertEquals(0, testMapOrBuilder.getInt32ToInt32Field().size()); assertEquals(0, testMapOrBuilder.getInt32ToInt32FieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToStringField().size()); assertEquals(0, testMapOrBuilder.getInt32ToStringFieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToBytesField().size()); assertEquals(0, testMapOrBuilder.getInt32ToBytesFieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToEnumField().size()); assertEquals(0, testMapOrBuilder.getInt32ToEnumFieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToMessageField().size()); assertEquals(0, testMapOrBuilder.getInt32ToMessageFieldCount()); assertEquals(0, testMapOrBuilder.getStringToInt32Field().size()); assertEquals(0, testMapOrBuilder.getStringToInt32FieldCount());",
        "ins1PreCode":"private void assertMapValuesCleared(TestMap message) { assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToStringField().size()); assertEquals(0, message.getInt32ToBytesField().size()); assertEquals(0, message.getInt32ToEnumField().size()); assertEquals(0, message.getInt32ToMessageField().size()); assertEquals(0, message.getStringToInt32Field().size());",
        "ins2PreCode":"private void assertMapValuesCleared(TestMap message) { assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToStringField().size()); assertEquals(0, message.getInt32ToBytesField().size()); assertEquals(0, message.getInt32ToEnumField().size()); assertEquals(0, message.getInt32ToMessageField().size()); assertEquals(0, message.getStringToInt32Field().size());",
        "label":1
    },
    {
        "ins1CurCode":" StringBuilder expectedURL = new StringBuilder(\"jar:war:\"); expectedURL.append(docBase.getCanonicalFile().toURI().toURL().toString()); expectedURL.append(\"*/WEB-INF/lib/test.jar!/META-INF/resources/index.html\");  Assert.assertEquals(expectedURL.toString(), webResource.getURL().toString());",
        "ins1PreCode":" StringBuilder expectedURL = new StringBuilder(\"jar:war:\"); expectedURL.append(docBase.getAbsoluteFile().toURI().toURL().toString()); expectedURL.append(\"*/WEB-INF/lib/test.jar!/META-INF/resources/index.html\");  String expected = expectedURL.toString(); String actual = webResource.getURL().toString();  if (JrePlatform.IS_WINDOWS){ expected = expected.toLowerCase(); actual = actual.toLowerCase(); }  Assert.assertEquals(expected, actual);",
        "ins2PreCode":" StringBuilder expectedURL = new StringBuilder(\"jar:\"); expectedURL.append(docBase.getAbsoluteFile().toURI().toURL().toString()); expectedURL.append(\"WEB-INF/lib/test-lib.jar!/META-INF/tags/echo.tag\");  String expected = expectedURL.toString(); String actual = webResource.getURL().toString();  if (JrePlatform.IS_WINDOWS){ expected = expected.toLowerCase(); actual = actual.toLowerCase(); }  Assert.assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1CurCode":" enableSizeChecking(true); super.setStandardBounds(X0, Y0, WIDTH, NAME_FIG_HEIGHT + ROWHEIGHT);",
        "ins1PreCode":" enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "ins2PreCode":" enableSizeChecking(true); setBounds(X0, Y0, WIDTH, 21 + ROWHEIGHT);",
        "label":0
    },
    {
        "ins1CurCode":"public void setDataset(int index, XYDataset<S> dataset) { XYDataset<S> existing = getDataset(index); if (existing != null) {",
        "ins1PreCode":"public void setDataset(int index, XYDataset dataset) { XYDataset existing = getDataset(index); if (existing != null) {",
        "ins2PreCode":"public void setDataset(int index, ValueDataset dataset) {  ValueDataset existing = (ValueDataset) this.datasets.get(index); if (existing != null) { existing.removeChangeListener(this); } this.datasets.set(index, dataset); if (dataset != null) { dataset.addChangeListener(this); }   DatasetChangeEvent event = new DatasetChangeEvent(this, dataset); datasetChanged(event); ",
        "label":0
    },
    {
        "ins1CurCode":"  validateAccessLog(alv, 1, 200, Bug49528Servlet.THREAD_SLEEP_TIME, Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins1PreCode":"  List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > Bug49528Servlet.THREAD_SLEEP_TIME); assertTrue(entry.toString(), entry.getTime() < Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins2PreCode":"  List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > Bug49567Servlet.THREAD_SLEEP_TIME); assertTrue(entry.toString(), entry.getTime() < Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "label":1
    },
    {
        "ins1CurCode":" if (r == Long.MAX_VALUE) { fastPath(a, iterator); return;",
        "ins1PreCode":" if (r == Long.MAX_VALUE) { slowPath(a, iterator); return;",
        "ins2PreCode":"void drain() { if (getAndIncrement() != 0) { return; }  Subscriber<? super R> a = downstream; Iterator<? extends R> iterator = this.it;  if (outputFused && iterator != null) { a.onNext(null); a.onComplete(); return; }  int missed = 1;  for (;;) {  if (iterator != null) { long r = requested.get();  if (r == Long.MAX_VALUE) { fastPath(a, iterator); return; }  long e = 0L;  while (e != r) { if (cancelled) { return; }  R v;  try { v = Objects.requireNonNull(iterator.next(), \"The iterator returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); a.onError(ex); return; }  a.onNext(v);  if (cancelled) { return; }  e++;  boolean b;  try { b = iterator.hasNext(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); a.onError(ex); return; }  if (!b) { a.onComplete(); return; } }  if (e != 0L) { BackpressureHelper.produced(requested, e); } }  missed = addAndGet(-missed); if (missed == 0) { break; }  if (iterator == null) { iterator = it; } }",
        "label":0
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> concat( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4) {",
        "ins1PreCode":"public static <T> Flowable<T> concat( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4) {",
        "ins2PreCode":"public static <T> Flowable<T> merge( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2,",
        "label":1
    },
    {
        "ins1CurCode":"for (N otherNode : network.nodes()) { Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode)); switch (edgesConnecting.size()) { case 0: assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull(); assertThat(network.edgeConnecting(node, otherNode).isPresent()).isFalse(); break; case 1: E edge = edgesConnecting.iterator().next(); assertThat(network.edgeConnectingOrNull(node, otherNode)).isEqualTo(edge); assertThat(network.edgeConnecting(node, otherNode).get()).isEqualTo(edge); break; default: try { network.edgeConnectingOrNull(node, otherNode); fail(); } catch (IllegalArgumentException expected) {} try { network.edgeConnecting(node, otherNode); fail(); } catch (IllegalArgumentException expected) {} }",
        "ins1PreCode":"for (N otherNode : network.nodes()) { Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));  boolean isSelfLoop = node.equals(otherNode); boolean connected = !edgesConnecting.isEmpty(); if (network.isDirected() || !isSelfLoop) { assertThat(edgesConnecting) .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode))); } if (!network.allowsParallelEdges()) { assertThat(edgesConnecting.size()).isAtMost(1); } if (!network.allowsSelfLoops() && isSelfLoop) { assertThat(connected).isFalse(); }  assertThat(network.successors(node).contains(otherNode)).isEqualTo(connected); assertThat(network.predecessors(otherNode).contains(node)).isEqualTo(connected); for (E edge : edgesConnecting) { assertThat(network.incidentNodes(edge)) .isEqualTo(EndpointPair.of(network, node, otherNode)); assertThat(network.outEdges(node)).contains(edge);",
        "ins2PreCode":"for (N otherNode : network.nodes()) { Set<E> edgesConnecting = sanityCheckSet(network.edgesConnecting(node, otherNode));  boolean isSelfLoop = node.equals(otherNode); boolean connected = !edgesConnecting.isEmpty(); if (network.isDirected() || !isSelfLoop) { assertThat(edgesConnecting) .isEqualTo(Sets.intersection(network.outEdges(node), network.inEdges(otherNode))); } if (!network.allowsParallelEdges()) { assertThat(edgesConnecting.size()).isAtMost(1); } if (!network.allowsSelfLoops() && isSelfLoop) { assertThat(connected).isFalse(); } ",
        "label":0
    },
    {
        "ins1CurCode":"\"Test Chart\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, false, false, false); XYPlot<?> plot = (XYPlot) chart.getPlot(); NumberAxis domainAxis = (NumberAxis) plot.getDomainAxis();",
        "ins1PreCode":"\"Test Chart\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, false, false, false); XYPlot plot = (XYPlot) chart.getPlot(); NumberAxis domainAxis = (NumberAxis) plot.getDomainAxis();",
        "ins2PreCode":"\"Test Chart\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, false, false, false); XYPlot plot = (XYPlot) chart.getPlot(); NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis();",
        "label":1
    },
    {
        "ins1CurCode":"public void merge1AsyncStreamOf1() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(1, 1).subscribe(ts);",
        "ins1PreCode":"public void merge1AsyncStreamOf1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(1, 1).subscribe(ts);",
        "ins2PreCode":"public void merge1AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(1, 1000).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); TestUtils.checkIndependence(r1, r2);",
        "ins1PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"comment{some text and \\\\latex\" + \"@article{test,author={Ed von Test}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"comment{some text and \\\\latex\" + \"@article{test,author={Ed von Test}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test}}\" + \"comment{some text and \\\\latex\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void applyProfile(Object handle, Object profile) { if (profile instanceof Profile) { if (handle instanceof Model) { ((Model) handle).applyProfile((Profile) profile);",
        "ins1PreCode":"public void applyProfile(Object handle, Object profile) { if (profile instanceof Profile) { if (handle instanceof Package) { ((Model) handle).applyProfile((Profile) profile);",
        "ins2PreCode":"public void unapplyProfile(Object handle, Object profile) { if (profile instanceof Profile) { if (handle instanceof Package) { ((Model) handle).unapplyProfile((Profile) profile); } else if (handle instanceof Profile) { ((Profile) handle).unapplyProfile((Profile) profile); } }",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r2 = (DefaultCategoryItemRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedBarRenderer r1 = new StackedBarRenderer(); StackedBarRenderer r2 = (StackedBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); DocumentFieldMappers fieldMappers = new DocumentFieldMappers(Collections.singleton(joinFieldMapper), Collections.emptyList(), null); DocumentMapper mockMapper = mock(DocumentMapper.class);",
        "ins1PreCode":"when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); DocumentFieldMappers fieldMappers = new DocumentFieldMappers(Collections.singleton(joinFieldMapper), Collections.emptyList(), null, null, null); DocumentMapper mockMapper = mock(DocumentMapper.class);",
        "ins2PreCode":"when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); DocumentFieldMappers fieldMappers = new DocumentFieldMappers(Collections.singleton(joinFieldMapper), Collections.emptyList(), null, null, null); DocumentMapper mockMapper = mock(DocumentMapper.class);",
        "label":1
    },
    {
        "ins1CurCode":"try { Author author = session.selectOne( \"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", new Author(101)); assertEquals(101, author.getId());",
        "ins1PreCode":"try { Author author = session.selectOne( \"domain.blog.mappers.AuthorMapper.selectAuthor\", new Author(101)); assertEquals(101, author.getId());",
        "ins2PreCode":"try { ImmutableAuthor author = session.selectOne( \"domain.blog.mappers.AuthorMapper.selectImmutableAuthor\", new Author(101)); assertEquals(101, author.getId());",
        "label":1
    },
    {
        "ins1CurCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "label":1
    },
    {
        "ins1CurCode":"}  return result.toArray(new String[0]);",
        "ins1PreCode":"}  return result.toArray(new String[result.size()]);",
        "ins2PreCode":"}  return result.toArray(new String[result.size()]);",
        "label":1
    },
    {
        "ins1CurCode":"Flowable.range(1, 1000000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Integer> v) throws Exception {",
        "ins1PreCode":"Flowable.range(1, 1000000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @SuppressWarnings(\"unchecked\") @Override",
        "ins2PreCode":"Flowable.range(1, 100000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @SuppressWarnings(\"unchecked\") @Override",
        "label":1
    },
    {
        "ins1CurCode":"source.connect();  TestSubscriber<Integer> ts1 = new TestSubscriber<>(2L);  source.subscribe(ts1);  ts1.assertValues(1, 2); ts1.assertNoErrors(); ts1.cancel();  TestSubscriber<Integer> ts11 = new TestSubscriber<>(2L);  source.subscribe(ts11);  ts11.assertValues(1, 2); ts11.assertNoErrors(); ts11.cancel();  TestSubscriber<Integer> ts2 = new TestSubscriber<>(3L);  source.subscribe(ts2);  ts2.assertValues(1, 2, 3); ts2.assertNoErrors(); ts2.cancel();  TestSubscriber<Integer> ts21 = new TestSubscriber<>(1L);  source.subscribe(ts21);  ts21.assertValues(2); ts21.assertNoErrors(); ts21.cancel();  TestSubscriber<Integer> ts22 = new TestSubscriber<>(1L);  source.subscribe(ts22);  ts22.assertValues(2); ts22.assertNoErrors(); ts22.cancel();  TestSubscriber<Integer> ts3 = new TestSubscriber<>(); ",
        "ins1PreCode":"source.connect();  TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(2L);  source.subscribe(ts1);  ts1.assertValues(1, 2); ts1.assertNoErrors(); ts1.cancel();  TestSubscriber<Integer> ts11 = new TestSubscriber<Integer>(2L);  source.subscribe(ts11);  ts11.assertValues(1, 2); ts11.assertNoErrors(); ts11.cancel();  TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(3L);  source.subscribe(ts2);  ts2.assertValues(1, 2, 3); ts2.assertNoErrors(); ts2.cancel();  TestSubscriber<Integer> ts21 = new TestSubscriber<Integer>(1L);  source.subscribe(ts21);  ts21.assertValues(2); ts21.assertNoErrors(); ts21.cancel();  TestSubscriber<Integer> ts22 = new TestSubscriber<Integer>(1L);  source.subscribe(ts22);  ts22.assertValues(2); ts22.assertNoErrors(); ts22.cancel();  TestSubscriber<Integer> ts3 = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"source.connect();  TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(2L);  source.subscribe(ts1);  ts1.assertValues(1, 2); ts1.assertNoErrors(); ts1.cancel();  TestSubscriber<Integer> ts11 = new TestSubscriber<Integer>(2L);  source.subscribe(ts11);  ts11.assertValues(1, 2); ts11.assertNoErrors(); ts11.cancel();  TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(3L);  source.subscribe(ts2);  ts2.assertValues(1, 2, 3); ts2.assertNoErrors(); ts2.cancel();  TestSubscriber<Integer> ts21 = new TestSubscriber<Integer>(1L);  source.subscribe(ts21);  ts21.assertValues(2); ts21.assertNoErrors(); ts21.cancel();  TestSubscriber<Integer> ts22 = new TestSubscriber<Integer>(1L);  source.subscribe(ts22);  ts22.assertValues(2); ts22.assertNoErrors(); ts22.cancel();  TestSubscriber<Integer> ts3 = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"config.setReadBufferSize(65536); udpServer = new NioUdpServer(config); udpServer.setIoHandler(new AbstractIoHandler() { @Override",
        "ins1PreCode":"config.setReadBufferSize(65536); udpServer = new NioUdpServer(config); udpServer.setIoHandler(new IoHandler() { @Override",
        "ins2PreCode":"config.setReadBufferSize(65536); udpServer = new BioUdpServer(config, null); udpServer.setIoHandler(new IoHandler() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapContext, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins1PreCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "ins2PreCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofExisting(propertySource); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(contributor)); Binder binder = contributors.getBinder(this.activationContext);",
        "label":1
    },
    {
        "ins1CurCode":"  alv.validateAccessLog(1, 200, 0, REQUEST_TIME);",
        "ins1PreCode":"  validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);",
        "ins2PreCode":"  validateAccessLog(alv, 1, 200, 0, REQUEST_TIME);",
        "label":1
    },
    {
        "ins1CurCode":"public Object evaluateScript(String execName) throws BuildException { checkLanguage(); ClassLoader origLoader = replaceContextLoader(); try { BSFManager m = createManager(); declareBeans(m);  if (engine == null) { return m.eval(getLanguage(), execName, 0, 0, getScript()); } return engine.eval(execName, 0, 0, getScript()); } catch (BSFException be) { throw getBuildException(be); } finally {",
        "ins1PreCode":"public Object evaluateScript(String execName) throws BuildException { checkLanguage(); ClassLoader origLoader = replaceContextLoader(); try { BSFManager m = createManager(); declareBeans(m);  if (engine == null) { return m.eval(getLanguage(), execName, 0, 0, getScript()); } else { return engine.eval(execName, 0, 0, getScript()); } } catch (BSFException be) { throwBuildException(be);  return null; } finally {",
        "ins2PreCode":"} } catch (BSFException be) { throwBuildException(be); } finally {",
        "label":0
    },
    {
        "ins1CurCode":"StringBuilder buffer = new StringBuilder( 256 );  buffer.append( LS ).append( \"Artifact Metadata\" ).append( LS ).append( \"--------------------------\" ); buffer.append( LS ).append( \"GroupId: \" ).append( getGroupId() ); buffer.append( LS ).append( \"ArtifactId: \" ).append( getArtifactId() ); buffer.append( LS ).append( \"Metadata Type: \" ).append( getClass().getName() ); ",
        "ins1PreCode":"StringBuilder buffer = new StringBuilder( 256 );  buffer.append( \"\\nArtifact Metadata\\n--------------------------\" ); buffer.append( \"\\nGroupId: \" ).append( getGroupId() ); buffer.append( \"\\nArtifactId: \" ).append( getArtifactId() ); buffer.append( \"\\nMetadata Type: \" ).append( getClass().getName() ); ",
        "ins2PreCode":"StringBuilder buffer = new StringBuilder( 256 );  buffer.append( \"\\nRepository Metadata\\n--------------------------\" ); buffer.append( \"\\nGroupId: \" ).append( getGroupId() ); buffer.append( \"\\nArtifactId: \" ).append( getArtifactId() ); buffer.append( \"\\nMetadata Type: \" ).append( getClass().getName() ); ",
        "label":1
    },
    {
        "ins1CurCode":".invokeAnd((c) -> c.handle(argument)); assertThat(result.hasResult()).isFalse(); verifyNoInteractions(callbackInstance);",
        "ins1PreCode":".invokeAnd((c) -> c.handle(argument)); assertThat(result.hasResult()).isFalse(); verifyZeroInteractions(callbackInstance);",
        "ins2PreCode":"void callbackInvokeAndWhenLambdaMismatchShouldSwallowException() { GenericFactory<StringBuilder> callbackInstance = (s) -> { fail(\"Should not get here\"); return 123; }; String argument = \"foo\"; InvocationResult<Integer> result = LambdaSafe.callback(GenericFactory.class, callbackInstance, argument) .invokeAnd((c) -> c.handle(argument)); assertThat(result.hasResult()).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":" GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R> parent = new GroupJoinDisposable<>(observer, leftEnd, rightEnd, resultSelector); ",
        "ins1PreCode":" GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R> parent = new GroupJoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>(observer, leftEnd, rightEnd, resultSelector); ",
        "ins2PreCode":" JoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R> parent = new JoinDisposable<TLeft, TRight, TLeftEnd, TRightEnd, R>( observer, leftEnd, rightEnd, resultSelector);",
        "label":1
    },
    {
        "ins1CurCode":"public void mainError() { final TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void mainError() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void mainError() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLocationResolver<?>> instantiator = new Instantiator<>(ConfigDataLocationResolver.class, (availableParameters) -> { availableParameters.add(Log.class, logFactory::getLog); availableParameters.add(Binder.class, binder); availableParameters.add(ResourceLoader.class, resourceLoader); availableParameters.add(ConfigurableBootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapRegistry.class, bootstrapContext); });",
        "ins1PreCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass());",
        "ins2PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> availableParameters.add(Log.class, logFactory::getLog)); this.loaders = instantiator.instantiate(names);",
        "label":0
    },
    {
        "ins1CurCode":" Function4<Time, String, Optional<Integer>, State<Boolean>, Optional<Double>> mappingFunc = (time, word, one, state) -> {  state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); };  JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = wordsDstream.mapWithState( StateSpec.function(mappingFunc) .initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));  stateDstream.stateSnapshots();  Function3<String, Optional<Integer>, State<Boolean>, Double> mappingFunc2 = (key, one, state) -> { ",
        "ins1PreCode":" Function4<Time, String, Optional<Integer>, State<Boolean>, Optional<Double>> mappingFunc = new Function4<Time, String, Optional<Integer>, State<Boolean>, Optional<Double>>() { @Override public Optional<Double> call( Time time, String word, Optional<Integer> one, State<Boolean> state) {  state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); } };  JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = wordsDstream.mapWithState( StateSpec.function(mappingFunc) .initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));  stateDstream.stateSnapshots();  Function3<String, Optional<Integer>, State<Boolean>, Double> mappingFunc2 = new Function3<String, Optional<Integer>, State<Boolean>, Double>() { @Override public Double call(String key, Optional<Integer> one, State<Boolean> state) { ",
        "ins2PreCode":"public void testMapWithStateAPI() { JavaPairRDD<String, Boolean> initialRDD = null; JavaPairDStream<String, Integer> wordsDstream = null;  JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream = wordsDstream.mapWithState( StateSpec.<String, Integer, Boolean, Double>function((time, key, value, state) -> {  state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return Optional.of(2.0); }).initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));  JavaPairDStream<String, Boolean> emittedRecords = stateDstream.stateSnapshots();  JavaMapWithStateDStream<String, Integer, Boolean, Double> stateDstream2 = wordsDstream.mapWithState( StateSpec.<String, Integer, Boolean, Double>function((key, value, state) -> { state.exists(); state.get(); state.isTimingOut(); state.remove(); state.update(true); return 2.0; }).initialState(initialRDD) .numPartitions(10) .partitioner(new HashPartitioner(10)) .timeout(Durations.seconds(10)));  JavaPairDStream<String, Boolean> mappedDStream = stateDstream2.stateSnapshots();",
        "label":0
    },
    {
        "ins1CurCode":"public void testImportEntries1() throws IOException, URISyntaxException { Path file = Paths.get(IsiImporterTest.class.getResource(\"IsiImporterTest1.isi\").toURI()); List<BibEntry> entries = importer.importDatabase(file, StandardCharsets.UTF_8).getDatabase().getEntries(); BibEntry entry = entries.get(0);  assertEquals(1, entries.size()); assertEquals(Optional.of(\"Optical properties of MgO doped LiNbO$_3$ single crystals\"), entry.getField(\"title\")); assertEquals( Optional.of( \"James Brown and James Marc Brown and Brown, J. M. and Brown, J. and Brown, J. M. and Brown, J.\"), entry.getField(\"author\")); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Optical Materials\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"28\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"5\"), entry.getField(\"number\")); assertEquals(Optional.of(\"467--72\"), entry.getField(\"pages\"));",
        "ins1PreCode":"public void testImportEntries1() throws IOException, URISyntaxException { Path file = Paths.get(IsiImporterTest.class.getResource(\"IsiImporterTest1.isi\").toURI()); List<BibEntry> entries = importer.importDatabase(file, StandardCharsets.UTF_8).getDatabase().getEntries(); assertEquals(1, entries.size()); BibEntry entry = entries.get(0); assertEquals(Optional.of(\"Optical properties of MgO doped LiNbO$_3$ single crystals\"), entry.getField(\"title\")); assertEquals( Optional.of( \"James Brown and James Marc Brown and Brown, J. M. and Brown, J. and Brown, J. M. and Brown, J.\"), entry.getField(\"author\"));  assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Optical Materials\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"28\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"5\"), entry.getField(\"number\")); assertEquals(Optional.of(\"467--72\"), entry.getField(\"pages\"));",
        "ins2PreCode":"public void testImportEntries2() throws IOException, URISyntaxException { Path file = Paths.get(IsiImporterTest.class.getResource(\"IsiImporterTest2.isi\").toURI()); List<BibEntry> entries = importer.importDatabase(file, StandardCharsets.UTF_8).getDatabase().getEntries(); assertEquals(3, entries.size()); BibEntry entry = entries.get(0); assertEquals(Optional.of(\"Optical properties of MgO doped LiNbO$_3$ single crystals\"), entry.getField(\"title\"));  assertEquals(\"misc\", entry.getType()); assertEquals(Optional.of(\"Optical Materials\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"28\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"5\"), entry.getField(\"number\")); assertEquals(Optional.of(\"467-72\"), entry.getField(\"pages\"));",
        "label":1
    },
    {
        "ins1CurCode":"mock(Map.class)));  assertThat(taImpl.getInternalState()) .withFailMessage(\"Task attempt is not in ASSIGNED state\") .isEqualTo(TaskAttemptStateInternal.ASSIGNED); taImpl.handle(new TaskAttemptEvent(attemptId, TaskAttemptEventType.TA_KILL)); assertThat(taImpl.getInternalState()) .withFailMessage(\"Task should be in KILL_CONTAINER_CLEANUP state\") .isEqualTo(TaskAttemptStateInternal.KILL_CONTAINER_CLEANUP);",
        "ins1PreCode":"taImpl.handle(new TaskAttemptContainerAssignedEvent(attemptId, container, mock(Map.class))); assertEquals(\"Task attempt is not in assinged state\", taImpl.getInternalState(), TaskAttemptStateInternal.ASSIGNED); taImpl.handle(new TaskAttemptEvent(attemptId, TaskAttemptEventType.TA_KILL)); assertEquals(\"Task should be in KILL_CONTAINER_CLEANUP state\", TaskAttemptStateInternal.KILL_CONTAINER_CLEANUP, taImpl.getInternalState());",
        "ins2PreCode":"mock(Map.class))); taImpl.handle(new TaskAttemptContainerLaunchedEvent(attemptId, 0)); assertEquals(\"Task attempt is not in running state\", taImpl.getState(), TaskAttemptState.RUNNING); taImpl.handle(new TaskAttemptEvent(attemptId, TaskAttemptEventType.TA_KILL)); assertFalse(\"InternalError occurred trying to handle TA_KILL\", eventHandler.internalError); assertEquals(\"Task should be in KILL_CONTAINER_CLEANUP state\", TaskAttemptStateInternal.KILL_CONTAINER_CLEANUP, taImpl.getInternalState());",
        "label":1
    },
    {
        "ins1CurCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); assertEquals(2, vm.getStack().pop()); assertEquals(0, vm.getStack().size());",
        "ins1PreCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(2, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "ins2PreCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(1, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "label":1
    },
    {
        "ins1CurCode":"return empty(); } Objects.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins1PreCode":"return empty(); } ObjectHelper.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"public static <T, R> Flowable<R> combineLatestArray(Publisher<? extends T>[] sources, Function<? super Object[], ? extends R> combiner, int bufferSize) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } ObjectHelper.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":0
    },
    {
        "ins1CurCode":"try { conn = pconn.getConnection(); valid = conn.isValid(timeout); } catch (SQLException e) {",
        "ins1PreCode":"} try { valid = pconn.getConnection().isValid(timeout); } catch (SQLException e) {",
        "ins2PreCode":"} try { valid = pconn.getConnection().isValid(timeout); } catch (SQLException e) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetDomainAxisForDataset() { XYDataset<String> dataset = new XYSeriesCollection<>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins1PreCode":"public void testGetDomainAxisForDataset() { XYDataset dataset = new XYSeriesCollection<String>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins2PreCode":"public void testGetRangeAxisForDataset() { XYDataset dataset = new XYSeriesCollection<String>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "label":1
    },
    {
        "ins1CurCode":"runner.setLogWriter(null); runner.runScript(reader); conn.close(); reader.close();",
        "ins1PreCode":"runner.setLogWriter(null); runner.runScript(reader); reader.close(); session.close();",
        "ins2PreCode":"public void setUp() throws Exception { Connection conn = null;  try { Class.forName(\"org.hsqldb.jdbcDriver\"); conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:lname\", \"sa\", \"\");  Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/CreateDB.sql\");  ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); runner.runScript(reader); conn.commit(); reader.close();  reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/MapperConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class); } finally { if (conn != null) { conn.close(); } }",
        "label":0
    },
    {
        "ins1CurCode":"MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());",
        "ins1PreCode":"MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());",
        "ins2PreCode":"MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(buildServerRequest(request, error), false, true); assertThat(attributes.get(\"error\")).isEqualTo(HttpStatus.I_AM_A_TEAPOT.getReasonPhrase());",
        "label":1
    },
    {
        "ins1CurCode":"File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs() || dir.exists(); if (!done) {",
        "ins1PreCode":"File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs(); if (!done) {",
        "ins2PreCode":"protected String getLocalPath() { if (localPath == null) { return getProject().getBaseDir().getAbsolutePath(); } else {  File dir = getProject().resolveFile(localPath); if (!dir.exists()) { boolean done = dir.mkdirs() || dir.isDirectory(); if (!done) { String msg = \"Directory \" + localPath + \" creation was not \" + \"successful for an unknown reason\"; throw new BuildException(msg, getLocation()); } getProject().log(\"Created dir: \" + dir.getAbsolutePath()); } return dir.getAbsolutePath(); }",
        "label":0
    },
    {
        "ins1CurCode":"new SQLDatabasePersistAction( \"Rename column\", \"ALTER TABLE \" + column.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" RENAME COLUMN \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) +",
        "ins1PreCode":"new SQLDatabasePersistAction( \"Rename column\", \"ALTER TABLE \" + DBUtils.getQuotedIdentifier(column.getTable()) + \" RENAME COLUMN \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) +",
        "ins2PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final OracleTableColumn column = command.getObject();  actions.add( new SQLDatabasePersistAction( \"Rename column\", \"ALTER TABLE \" + column.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" RENAME COLUMN \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getOldName()) + \" TO \" + DBUtils.getQuotedIdentifier(column.getDataSource(), command.getNewName())) );",
        "label":0
    },
    {
        "ins1CurCode":"public void edgesConnecting_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  assume().that(graphIsMutable()).isTrue();  addNode(N1);",
        "ins1PreCode":"public void edgesConnecting_checkReturnedSetMutability() { addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23);",
        "ins2PreCode":"public void edgesConnecting_checkReturnedSetMutability() { addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting); }",
        "label":0
    },
    {
        "ins1CurCode":"} }) .take(3) .test()",
        "ins1PreCode":"} }) .limit(3) .test()",
        "ins2PreCode":"} }) .limit(3) .test()",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void onComplete() { lists.add(new ArrayList<>(list)); list.clear();",
        "ins1PreCode":"@Override public void onComplete() { lists.add(new ArrayList<T>(list)); list.clear();",
        "ins2PreCode":"@Override public void onComplete() { lists.add(new ArrayList<T>(list)); list.clear();",
        "label":1
    },
    {
        "ins1CurCode":"series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1); return ChartFactory.createScatterPlot(\"Scatter Plot\", \"Domain\",",
        "ins1PreCode":"series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createScatterPlot(\"Scatter Plot\", \"Domain\",",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"public void testEquals_ObjectList2() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);",
        "ins1PreCode":"public void testEquals_ObjectList2() { CategoryPlot p1 = new CategoryPlot(); p1.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot p2 = new CategoryPlot(); p2.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);",
        "ins2PreCode":"public void testEquals_ObjectList4() { CategoryPlot p1 = new CategoryPlot(); p1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot p2 = new CategoryPlot(); p2.setRangeAxisLocation(AxisLocation.BOTTOM_OR_RIGHT);",
        "label":1
    },
    {
        "ins1CurCode":" postWelcomeFiles(); fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name); ",
        "ins1PreCode":" postWelcomeFiles(); fireContainerEvent(\"removeWelcomeFile\", name); ",
        "ins2PreCode":"public void removeWatchedResource(String name) {  synchronized (watchedResourcesLock) {   int n = -1; for (int i = 0; i < watchedResources.length; i++) { if (watchedResources[i].equals(name)) { n = i; break; } } if (n < 0) return;   int j = 0; String results[] = new String[watchedResources.length - 1]; for (int i = 0; i < watchedResources.length; i++) { if (i != n) results[j++] = watchedResources[i]; } watchedResources = results;  }  fireContainerEvent(\"removeWatchedResource\", name); ",
        "label":0
    },
    {
        "ins1CurCode":"public void setUp() { MockitoAnnotations.initMocks(this); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear();",
        "ins1PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); sparkConf = new SparkConf(); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\");",
        "ins2PreCode":"public void setup() { memoryManager = new TestMemoryManager( new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);  tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments();  return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "label":0
    },
    {
        "ins1CurCode":"public Class<?> getType(EvaluationContext ctx) throws ELException { VariableMapper varMapper = ctx.getVariableMapper();",
        "ins1PreCode":"public Class getType(EvaluationContext ctx) throws ELException { VariableMapper varMapper = ctx.getVariableMapper();",
        "ins2PreCode":"public boolean isReadOnly(EvaluationContext ctx) throws ELException { VariableMapper varMapper = ctx.getVariableMapper(); if (varMapper != null) { ValueExpression expr = varMapper.resolveVariable(this.image); if (expr != null) { return expr.isReadOnly(ctx.getELContext()); } } ctx.setPropertyResolved(false); return ctx.getELResolver().isReadOnly(ctx, null, this.image);",
        "label":0
    },
    {
        "ins1CurCode":".read() .format(\"json\") .schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>, \" + \"ints array<int>\") .load(\"src/test/resources/test-data/with-array-fields.json\")",
        "ins1PreCode":".read() .format(\"json\") .schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>\") .load(\"src/test/resources/test-data/with-array-fields.json\")",
        "ins2PreCode":"public void testBeanWithMapFieldsDeserialization() {  Encoder<MapRecord> encoder = Encoders.bean(MapRecord.class);  Dataset<MapRecord> dataset = spark .read() .format(\"json\") .schema(\"id int, intervals map<string, struct<startTime: bigint, endTime: bigint>>\") .load(\"src/test/resources/test-data/with-map-fields.json\") .as(encoder);  List<MapRecord> records = dataset.collectAsList();  Assert.assertEquals(records, MAP_RECORDS);",
        "label":0
    },
    {
        "ins1CurCode":"public void entriesAreParsedNoHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibNoHeader, importFormatPreferences, fileMonitor); BibDatabase db = result.getDatabase();",
        "ins1PreCode":"public void entriesAreParsedNoHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibNoHeader, importFormatPreferences); BibDatabase db = result.getDatabase();",
        "ins2PreCode":"public void entriesAreParsedHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeader, importFormatPreferences); BibDatabase db = result.getDatabase();",
        "label":1
    },
    {
        "ins1CurCode":"state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state == AsyncState.READ_WRITE_OP || state == AsyncState.TIMING_OUT ||",
        "ins1PreCode":"state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) {",
        "ins2PreCode":"public synchronized boolean asyncComplete() { boolean doComplete = false;  if (state == AsyncState.STARTING) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.STARTED) { state = AsyncState.COMPLETING; doComplete = true; } else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.READ_WRITE_OP) { clearNonBlockingListeners(); state = AsyncState.MUST_COMPLETE; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncComplete()\", state));  } return doComplete;",
        "label":0
    },
    {
        "ins1CurCode":"Flowable<Integer> f2 = createInfiniteFlowable(generatedB);  TestSubscriber<String> ts = new TestSubscriber<>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "ins1PreCode":"Flowable<Integer> f2 = createInfiniteFlowable(generatedB);  TestSubscriber<String> ts = new TestSubscriber<String>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "ins2PreCode":"Flowable<Integer> f2 = createInfiniteFlowable(generatedB).subscribeOn(Schedulers.computation());  TestSubscriber<String> ts = new TestSubscriber<String>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "label":1
    },
    {
        "ins1CurCode":"public void liveReloadDisabled() throws Exception { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.livereload.enabled\", false); this.context = getContext(() -> initializeAndRun(Config.class, properties)); assertThatExceptionOfType(NoSuchBeanDefinitionException.class)",
        "ins1PreCode":"public void liveReloadDisabled() { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.livereload.enabled\", false); this.context = initializeAndRun(Config.class, properties); assertThatExceptionOfType(NoSuchBeanDefinitionException.class)",
        "ins2PreCode":"public void restartDisabled() { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.restart.enabled\", false); this.context = initializeAndRun(Config.class, properties); assertThatExceptionOfType(NoSuchBeanDefinitionException.class)",
        "label":1
    },
    {
        "ins1CurCode":"append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins1PreCode":"append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizer, this.interceptors);",
        "ins2PreCode":"return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizer,",
        "label":1
    },
    {
        "ins1CurCode":" String hostName = null; List<Cipher> clientRequestedCiphers = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NOT_PRESENT:  break; case NEED_READ: sc.read(netInBuffer, socket, handshakeReadCompletionHandler); return 1; case UNDERFLOW:  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniDefault\")); } hostName = endpoint.getDefaultSSLHostConfigName(); break; }  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); }  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers); ",
        "ins1PreCode":"}  sslEngine = endpoint.createSSLEngine(hostName); ",
        "ins2PreCode":"}  sslEngine = endpoint.createSSLEngine(hostName); ",
        "label":1
    },
    {
        "ins1CurCode":" String actualXForwardedFor = remoteAddrAndHostTrackerValve.getForwardedFor(); Assert.assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);  String actualXForwardedBy = request.getHeader(\"x-forwarded-by\"); Assert.assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);  String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr(); Assert.assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);  String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost(); Assert.assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);  String actualPostInvokeRemoteAddr = request.getRemoteAddr(); Assert.assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);  String actualPostInvokeRemoteHost = request.getRemoteHost(); Assert.assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);   String actualScheme = remoteAddrAndHostTrackerValve.getScheme(); Assert.assertEquals(\"x-forwarded-proto is null\", \"http\", actualScheme);  int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort(); Assert.assertEquals(\"x-forwarded-proto is null\", 8080, actualServerPort);  boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure(); Assert.assertFalse(\"x-forwarded-proto is null\", actualSecure);  boolean actualPostInvokeSecure = request.isSecure(); Assert.assertFalse(\"postInvoke secure\", actualPostInvokeSecure);  int actualPostInvokeServerPort = request.getServerPort(); Assert.assertEquals(\"postInvoke serverPort\", 8080, actualPostInvokeServerPort);  String actualPostInvokeScheme = request.getScheme(); Assert.assertEquals(\"postInvoke scheme\", \"http\", actualPostInvokeScheme);",
        "ins1PreCode":" String actualXForwardedFor = remoteAddrAndHostTrackerValve.getForwardedFor(); assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);  String actualXForwardedBy = request.getHeader(\"x-forwarded-by\"); assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);  String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr(); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);  String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost(); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);  String actualPostInvokeRemoteAddr = request.getRemoteAddr(); assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);  String actualPostInvokeRemoteHost = request.getRemoteHost(); assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);   String actualScheme = remoteAddrAndHostTrackerValve.getScheme(); assertEquals(\"x-forwarded-proto is null\", \"http\", actualScheme);  int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort(); assertEquals(\"x-forwarded-proto is null\", 8080, actualServerPort);  boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure(); assertFalse(\"x-forwarded-proto is null\", actualSecure);  boolean actualPostInvokeSecure = request.isSecure(); assertFalse(\"postInvoke secure\", actualPostInvokeSecure);  int actualPostInvokeServerPort = request.getServerPort(); assertEquals(\"postInvoke serverPort\", 8080, actualPostInvokeServerPort);  String actualPostInvokeScheme = request.getScheme(); assertEquals(\"postInvoke scheme\", \"http\", actualPostInvokeScheme);",
        "ins2PreCode":" String actualXForwardedFor = remoteAddrAndHostTrackerValve.getForwardedFor(); assertNull(\"no intermediate non-trusted proxy, x-forwarded-for must be null\", actualXForwardedFor);  String actualXForwardedBy = request.getHeader(\"x-forwarded-by\"); assertNull(\"no intermediate trusted proxy\", actualXForwardedBy);  String actualRemoteAddr = remoteAddrAndHostTrackerValve.getRemoteAddr(); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);  String actualRemoteHost = remoteAddrAndHostTrackerValve.getRemoteHost(); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);  String actualPostInvokeRemoteAddr = request.getRemoteAddr(); assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteAddr);  String actualPostInvokeRemoteHost = request.getRemoteHost(); assertEquals(\"postInvoke remoteAddr\", \"192.168.0.10\", actualPostInvokeRemoteHost);   String actualScheme = remoteAddrAndHostTrackerValve.getScheme(); assertEquals(\"x-forwarded-proto is null\", \"https\", actualScheme);  int actualServerPort = remoteAddrAndHostTrackerValve.getServerPort(); assertEquals(\"x-forwarded-proto is null\", 8443, actualServerPort);  boolean actualSecure = remoteAddrAndHostTrackerValve.isSecure(); assertTrue(\"x-forwarded-proto is null\", actualSecure);  boolean actualPostInvokeSecure = request.isSecure(); assertTrue(\"postInvoke secure\", actualPostInvokeSecure);  int actualPostInvokeServerPort = request.getServerPort(); assertEquals(\"postInvoke serverPort\", 8443, actualPostInvokeServerPort);  String actualPostInvokeScheme = request.getScheme(); assertEquals(\"postInvoke scheme\", \"https\", actualPostInvokeScheme);",
        "label":1
    },
    {
        "ins1CurCode":"  XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(10.0, 12353.3); series1.add(20.0, 13734.4); series1.add(30.0, 14525.3); series1.add(40.0, 13984.3); series1.add(50.0, 12999.4); series1.add(60.0, 14274.3); series1.add(70.0, 15943.5); series1.add(80.0, 14845.3); series1.add(90.0, 14645.4); series1.add(100.0, 16234.6); series1.add(110.0, 17232.3); series1.add(120.0, 14232.2); series1.add(130.0, 13102.2); series1.add(140.0, 14230.2); series1.add(150.0, 11235.2);  XYSeries<String> series2 = new XYSeries<>(\"Series 2\"); series2.add(10.0, 15000.3); series2.add(20.0, 11000.4); series2.add(30.0, 17000.3); series2.add(40.0, 15000.3); series2.add(50.0, 14000.4); series2.add(60.0, 12000.3); series2.add(70.0, 11000.5); series2.add(80.0, 12000.3); series2.add(90.0, 13000.4); series2.add(100.0, 12000.6); series2.add(110.0, 13000.3); series2.add(120.0, 17000.2); series2.add(130.0, 18000.2); series2.add(140.0, 16000.2); series2.add(150.0, 17000.2);  XYSeriesCollection<String> collection = new XYSeriesCollection<>(); collection.addSeries(series1);",
        "ins1PreCode":"  XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 12353.3); series1.add(20.0, 13734.4); series1.add(30.0, 14525.3); series1.add(40.0, 13984.3); series1.add(50.0, 12999.4); series1.add(60.0, 14274.3); series1.add(70.0, 15943.5); series1.add(80.0, 14845.3); series1.add(90.0, 14645.4); series1.add(100.0, 16234.6); series1.add(110.0, 17232.3); series1.add(120.0, 14232.2); series1.add(130.0, 13102.2); series1.add(140.0, 14230.2); series1.add(150.0, 11235.2);  XYSeries series2 = new XYSeries(\"Series 2\"); series2.add(10.0, 15000.3); series2.add(20.0, 11000.4); series2.add(30.0, 17000.3); series2.add(40.0, 15000.3); series2.add(50.0, 14000.4); series2.add(60.0, 12000.3); series2.add(70.0, 11000.5); series2.add(80.0, 12000.3); series2.add(90.0, 13000.4); series2.add(100.0, 12000.6); series2.add(110.0, 13000.3); series2.add(120.0, 17000.2); series2.add(130.0, 18000.2); series2.add(140.0, 16000.2); series2.add(150.0, 17000.2);  XYSeriesCollection collection = new XYSeriesCollection(); collection.addSeries(series1);",
        "ins2PreCode":"private XYDataset createDataset1() {  XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 12353.3); series1.add(20.0, 13734.4); series1.add(30.0, 14525.3); series1.add(40.0, 13984.3); series1.add(50.0, 12999.4); series1.add(60.0, 14274.3); series1.add(70.0, 15943.5); series1.add(80.0, 14845.3); series1.add(90.0, 14645.4); series1.add(100.0, 16234.6); series1.add(110.0, 17232.3); series1.add(120.0, 14232.2); series1.add(130.0, 13102.2); series1.add(140.0, 14230.2); series1.add(150.0, 11235.2);  XYSeries series2 = new XYSeries(\"Series 2\"); series2.add(10.0, 15000.3); series2.add(20.0, 11000.4); series2.add(30.0, 17000.3); series2.add(40.0, 15000.3); series2.add(50.0, 14000.4); series2.add(60.0, 12000.3); series2.add(70.0, 11000.5); series2.add(80.0, 12000.3); series2.add(90.0, 13000.4); series2.add(100.0, 12000.6); series2.add(110.0, 13000.3); series2.add(120.0, 17000.2); series2.add(130.0, 18000.2); series2.add(140.0, 16000.2); series2.add(150.0, 17000.2);  XYSeriesCollection collection = new XYSeriesCollection(); collection.addSeries(series1);",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\")); ",
        "ins1PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "ins2PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, getRelativeClasspathLocation(\"log4j2-file.xml\"), getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\")));",
        "ins1PreCode":"this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\")));",
        "ins2PreCode":"void customExceptionConversionWord(CapturedOutput output) { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); assertThat(output).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); } finally { System.clearProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD); }",
        "label":0
    },
    {
        "ins1CurCode":" try { when = Objects.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { when = ObjectHelper.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { when = ObjectHelper.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"public void sslEnabledMultiProtocolsConfiguration() { Ssl ssl = new Ssl();",
        "ins1PreCode":"public void sslEnabledMultiProtocolsConfiguration() throws Exception { Ssl ssl = new Ssl();",
        "ins2PreCode":"public void sslEnabledProtocolsConfiguration() throws Exception { Ssl ssl = new Ssl();",
        "label":1
    },
    {
        "ins1CurCode":"} } catch (Throwable ignore) { ExceptionUtils.handleThrowable(ignore); }",
        "ins1PreCode":"} } catch (Throwable ignore) {  }",
        "ins2PreCode":"} } catch (Throwable ignore) {  }",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"dataset1.addValue(25.0, \"R5\", \"C1\"); CategoryStepRenderer r = new CategoryStepRenderer(); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r);",
        "ins1PreCode":"dataset1.addValue(25.0, \"R5\", \"C1\"); CategoryStepRenderer r = new CategoryStepRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r);",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset<String, String> dataset0 = new DefaultCategoryDataset<>(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\"); dataset1.addValue(25.0, \"R5\", \"C1\"); LineAndShapeRenderer r = new LineAndShapeRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, dataset1); new JFreeChart(plot); LegendItem li = r.getLegendItem(1, 2); assertEquals(\"R5\", li.getLabel()); assertEquals(1, li.getDatasetIndex()); assertEquals(2, li.getSeriesIndex());",
        "label":0
    },
    {
        "ins1CurCode":"} catch (InterruptedException e) { e.printStackTrace(); Assert.fail(e.getMessage()); }",
        "ins1PreCode":"} catch (InterruptedException e) { e.printStackTrace(); fail(e.getMessage()); }",
        "ins2PreCode":"} catch (InterruptedException e) { e.printStackTrace(); fail(e.getMessage()); }",
        "label":1
    },
    {
        "ins1CurCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); assertTrue(author2 instanceof Factory);",
        "ins1PreCode":"Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); assertTrue(author2.getClass().getName().contains(\"CGLIB\"));",
        "ins2PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy));  assertTrue(author2 instanceof Proxy);",
        "label":0
    },
    {
        "ins1CurCode":"void shouldNotLetReadUnloadedPropertyAfterSerialization() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); Assertions.assertThrows(ExecutorException.class, author2::getId);",
        "ins1PreCode":"public void shouldNotLetReadUnloadedPropertyAfterSerialization() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins2PreCode":"public void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueSequence() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void assertValueSequence() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void assertValueSequence() { TestObserver<Integer> to = TestObserver.create();  to.onSubscribe(Disposable.empty());  to.onNext(1); to.onNext(2);  try { to.assertValueSequence(Collections.<Integer>emptyList()); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError expected) { assertTrue(expected.getMessage(), expected.getMessage().startsWith(\"More values received than expected (0)\")); }  try { to.assertValueSequence(Collections.singletonList(1)); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError expected) { assertTrue(expected.getMessage(), expected.getMessage().startsWith(\"More values received than expected (1)\")); }  to.assertValueSequence(Arrays.asList(1, 2));  try { to.assertValueSequence(Arrays.asList(1, 2, 3)); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError expected) { assertTrue(expected.getMessage(), expected.getMessage().startsWith(\"Fewer values received than expected (2)\")); }",
        "label":0
    },
    {
        "ins1CurCode":"if (prop.hasNext()) { MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName()); if (metaValue == SystemMetaObject.NULL_META_OBJECT) { return Object.class;",
        "ins1PreCode":"if (prop.hasNext()) { MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName()); if (metaValue == MetaObject.NULL_META_OBJECT) { return Object.class;",
        "ins2PreCode":"if (prop.hasNext()) { MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName()); if (metaValue == MetaObject.NULL_META_OBJECT) { return Object.class;",
        "label":1
    },
    {
        "ins1CurCode":"public UnsafeRow copy() { UnsafeRow rowCopy = new UnsafeRow(numFields); final byte[] rowDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes ); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); return rowCopy;",
        "ins1PreCode":"public UnsafeRow copy() { UnsafeRow rowCopy = new UnsafeRow(); final byte[] rowDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes ); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); return rowCopy;",
        "ins2PreCode":"public UnsafeMapData copy() { UnsafeMapData mapCopy = new UnsafeMapData(); final byte[] mapDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, mapDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); mapCopy.pointTo(mapDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); return mapCopy;",
        "label":0
    },
    {
        "ins1CurCode":"  Paint seriesPaint = getSeriesPaint(series); if (seriesPaint == null && this.autoPopulateSeriesPaint) { DrawingSupplier supplier = getDrawingSupplier();",
        "ins1PreCode":"  if (this.paint != null) { return this.paint; }",
        "ins2PreCode":"  if (this.fillPaint != null) { return this.fillPaint; }",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getEndpointId()) .isEqualTo(EndpointId.of(\"testrestcontroller\")); assertThat(endpoint.getController())",
        "ins1PreCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testrestcontroller\"); assertThat(endpoint.getController())",
        "ins2PreCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testrestcontroller\"); assertThat(endpoint.getController())",
        "label":1
    },
    {
        "ins1CurCode":"void tomcatListeners() { TomcatServletWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void tomcatListeners() { TomcatServletWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory();",
        "label":1
    },
    {
        "ins1CurCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32FieldMap()) .putAllInt32ToStringField(source.getInt32ToStringFieldMap()) .putAllInt32ToBytesField(source.getInt32ToBytesFieldMap()) .putAllInt32ToEnumField(source.getInt32ToEnumFieldMap()) .putAllInt32ToMessageField(source.getInt32ToMessageFieldMap()) .putAllStringToInt32Field(source.getStringToInt32FieldMap());",
        "ins1PreCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "ins2PreCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "label":1
    },
    {
        "ins1CurCode":"SecurityFilterChain configure(HttpSecurity http) throws Exception { http.authorizeRequests((requests) -> { requests.antMatchers(\"/css/**\").permitAll(); requests.anyRequest().fullyAuthenticated(); }); http.formLogin((form) -> { form.loginPage(\"/login\"); form.failureUrl(\"/login?error\").permitAll(); }); http.logout(LogoutConfigurer::permitAll); return http.build();",
        "ins1PreCode":"protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests((requests) -> {",
        "ins2PreCode":"protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests((requests) -> {",
        "label":1
    },
    {
        "ins1CurCode":"if (lname.equals(LAST_MODIFIED)) { try { synchronized(RFC1123_FORMAT) { lastModified = RFC1123_FORMAT.parse(value).getTime(); }",
        "ins1PreCode":"if (lname.equals(LAST_MODIFIED)) { try { synchronized(format) { lastModified = format.parse(value).getTime(); }",
        "ins2PreCode":"if (lname.equals(LAST_MODIFIED)) { try { synchronized(format) { lastModified = format.parse(value).getTime(); }",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) {",
        "ins2PreCode":"public void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { String sql = String.format(SQL_RENAME_TABLE,",
        "label":1
    },
    {
        "ins1CurCode":"void shouldUpdateAuthorCommit() { Author original;",
        "ins1PreCode":"public void shouldUpdateAuthorCommit() { Author original;",
        "ins2PreCode":"public void shouldUpdateAuthorIfNecessary() { Author original;",
        "label":1
    },
    {
        "ins1CurCode":"void shouldNotApplyTypeHandlerToParamMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldNotApplyTypeHandlerToParamMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldGetAUserFromAnnotation() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) {  do { if (getSocket().flush(true, selector, writeTimeout)) { break; }",
        "ins1PreCode":"protected void doWrite(boolean block) throws IOException { socketBufferHandler.configureWriteBufferForRead();  long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(socketBufferHandler.getWriteBuffer(), getSocket(), selector, writeTimeout, block); if (block) {  do { if (getSocket().flush(true, selector, writeTimeout)) break; } while (true);",
        "ins2PreCode":"private int fillReadBuffer(boolean block) throws IOException { int nRead; NioChannel channel = getSocket(); socketBufferHandler.configureReadBufferForWrite(); if (block) { Selector selector = null; try { selector = pool.get(); } catch ( IOException x ) {  } try { NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel.getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(socketBufferHandler.getReadBuffer(), channel, selector, att.getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(socketBufferHandler.getReadBuffer()); if (nRead == -1) { throw new EOFException(); } } return nRead;",
        "label":0
    },
    {
        "ins1CurCode":"void testUserSpecifiedNestedJarPath() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\");",
        "ins1PreCode":"public void testUserSpecifiedNestedJarPath() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\");",
        "ins2PreCode":"public void testUserSpecifiedJarPathWithDot() throws Exception { System.setProperty(\"loader.path\", \"./jars/app.jar\");",
        "label":1
    },
    {
        "ins1CurCode":"this.filter.addErrorPages(new ErrorPage(\"/error\")); setUpAsyncDispatch(); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new RuntimeException(\"BAD\"); }); this.filter.doFilter(this.request, this.response, this.chain);",
        "ins1PreCode":"this.filter.addErrorPages(new ErrorPage(\"/error\")); setUpAsyncDispatch(); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new RuntimeException(\"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "ins2PreCode":"this.filter.addErrorPages(new ErrorPage(\"/error\")); setUpAsyncDispatch(); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); ((HttpServletResponse) response).sendError(400, \"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldCheckGetterExistance() { ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory); assertTrue(meta.hasGetter(\"richField\"));",
        "ins1PreCode":"public void shouldCheckGetterExistance() { MetaClass meta = MetaClass.forClass(RichType.class); assertTrue(meta.hasGetter(\"richField\"));",
        "ins2PreCode":"public void shouldCheckSetterExistance() { MetaClass meta = MetaClass.forClass(RichType.class); assertTrue(meta.hasSetter(\"richField\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testMalformed01() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;x=1,en-gb;q=0.5\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testMalformed01() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;x=1\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testMalformed02() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=a\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "label":1
    },
    {
        "ins1CurCode":"public synchronized boolean asyncComplete() { pauseNonContainerThread(); boolean doComplete = false;",
        "ins1PreCode":"public synchronized boolean asyncComplete() { boolean doComplete = false;  if (state == AsyncState.STARTING) {",
        "ins2PreCode":"public synchronized boolean asyncDispatch() { boolean doDispatch = false; if (state == AsyncState.STARTING) {",
        "label":1
    },
    {
        "ins1CurCode":" try { h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "ins1PreCode":" try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "ins2PreCode":" try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) {",
        "label":1
    },
    {
        "ins1CurCode":"writer.println (sm.getString(\"hostManagerServlet.started\", name)); } catch (Exception e) { getServletContext().log (sm.getString(\"hostManagerServlet.startFailed\", name), e); writer.println (sm.getString(\"hostManagerServlet.startFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", e.toString())); return;",
        "ins1PreCode":"writer.println (sm.getString(\"hostManagerServlet.started\", name)); } catch (Throwable t) { getServletContext().log (sm.getString(\"hostManagerServlet.startFailed\", name), t); writer.println (sm.getString(\"hostManagerServlet.startFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", t.toString())); return;",
        "ins2PreCode":"writer.println (sm.getString(\"hostManagerServlet.stopped\", name)); } catch (Throwable t) { getServletContext().log (sm.getString(\"hostManagerServlet.stopFailed\", name), t); writer.println (sm.getString(\"hostManagerServlet.stopFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", t.toString())); return;",
        "label":1
    },
    {
        "ins1CurCode":"public final List<NodePropertyDescriptor> nodePropertyDescriptors(@CheckForNull Slave it) { List<NodePropertyDescriptor> result = new ArrayList<>(); Collection<NodePropertyDescriptor> list =",
        "ins1PreCode":"public final List<NodePropertyDescriptor> nodePropertyDescriptors(@CheckForNull Slave it) { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list =",
        "ins2PreCode":"public static List<NodePropertyDescriptor> getGlobalNodePropertyDescriptors() { List<NodePropertyDescriptor> result = new ArrayList<NodePropertyDescriptor>(); Collection<NodePropertyDescriptor> list = (Collection) Jenkins.get().getDescriptorList(NodeProperty.class);",
        "label":1
    },
    {
        "ins1CurCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\na\".getBytes()), context); assertNotNull(results); assertEquals(\"a string\", results); assertEquals(1, context.getBuffer().position()); results = decoder.decode(ByteBuffer.wrap(\" string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(\"a string\", results); assertEquals(0, context.getBuffer().position());",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\na\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(1, context.getBuffer().position()); results = decoder.decode(ByteBuffer.wrap(\" string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\na\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(1, context.getBuffer().position()); results = decoder.decode(ByteBuffer.wrap(\" string\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1CurCode":"public void assertEqualContent(File expect, File result) throws IOException { assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists()); ",
        "ins1PreCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { if (!result.exists()) { fail(\"Expected file \" + result + \" doesn\\'t exist\"); }",
        "ins2PreCode":"public void assertEqualContent(File expect, File result) throws AssertionFailedError, IOException { assertTrue(\"Expected file \" + result + \" doesn\\'t exist\", result.exists());  try (InputStream inExpect = new BufferedInputStream(new FileInputStream(expect)); InputStream inResult = new BufferedInputStream(new FileInputStream(result))) {  int expectedByte = inExpect.read(); while (expectedByte != -1) { assertEquals(expectedByte, inResult.read()); expectedByte = inExpect.read(); } assertEquals(\"End of file\", -1, inResult.read()); }",
        "label":0
    },
    {
        "ins1CurCode":"void generateProjectAndExtractUnsupportedArchive(@TempDir File tempDir) throws Exception { String fileName = UUID.randomUUID().toString() + \".zip\"; File file = new File(fileName); assertThat(file.exists()).as(\"file should not exist\").isFalse(); try { byte[] archive = createFakeZipArchive(\"test.txt\", \"Fake content\"); MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest(\"application/foobar\", fileName, archive); mockSuccessfulProjectGeneration(request); assertThat(this.command.run(\"--extract\", tempDir.getAbsolutePath())).isEqualTo(ExitStatus.OK); assertThat(file.exists()).as(\"file should have been saved instead\").isTrue();",
        "ins1PreCode":"public void generateProjectAndExtractUnsupportedArchive() throws Exception { File folder = this.temporaryFolder.newFolder(); String fileName = UUID.randomUUID().toString() + \".zip\"; File file = new File(fileName); assertThat(file.exists()).as(\"file should not exist\").isFalse(); try { byte[] archive = createFakeZipArchive(\"test.txt\", \"Fake content\"); MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest(\"application/foobar\", fileName, archive); mockSuccessfulProjectGeneration(request); assertThat(this.command.run(\"--extract\", folder.getAbsolutePath())).isEqualTo(ExitStatus.OK); assertThat(file.exists()).as(\"file should have been saved instead\").isTrue();",
        "ins2PreCode":"public void generateProjectAndExtractUnknownContentType() throws Exception { File folder = this.temporaryFolder.newFolder(); String fileName = UUID.randomUUID().toString() + \".zip\"; File file = new File(fileName); assertThat(file.exists()).as(\"file should not exist\").isFalse(); try { byte[] archive = createFakeZipArchive(\"test.txt\", \"Fake content\"); MockHttpProjectGenerationRequest request = new MockHttpProjectGenerationRequest(null, fileName, archive); mockSuccessfulProjectGeneration(request); assertThat(this.command.run(\"--extract\", folder.getAbsolutePath())).isEqualTo(ExitStatus.OK); assertThat(file.exists()).as(\"file should have been saved instead\").isTrue();",
        "label":1
    },
    {
        "ins1CurCode":".expectedNodeCount(NODE_COUNT) .build(); assertThat(undirectedGraph.addEdgeV2(N1, N2, E12)).isTrue(); assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12));",
        "ins1PreCode":".expectedNodeCount(NODE_COUNT) .build(); assertThat(undirectedGraph.addEdge(E12, N1, N2)).isTrue(); assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12));",
        "ins2PreCode":".expectedEdgeCount(EDGE_COUNT) .build(); assertThat(directedGraph.addEdge(E12, N1, N2)).isTrue(); assertThat(directedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12));",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article(test,author={Ed von Test})\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":".parse(new StringReader(\"@article(test,author={Ed von Test})\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":".parse(new StringReader(\"@article{test,author={Ed von Test},}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int months = Platform.getInt(baseObject, baseOffset + offset); final int days = Platform.getInt(baseObject, baseOffset + offset + 4); final long microseconds = Platform.getLong(baseObject, baseOffset + offset + 8); return new CalendarInterval(months, days, microseconds);",
        "ins1PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int months = (int) Platform.getLong(baseObject, baseOffset + offset); final long microseconds = Platform.getLong(baseObject, baseOffset + offset + 8); return new CalendarInterval(months, microseconds);",
        "ins2PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int months = (int) Platform.getLong(baseObject, baseOffset + offset); final long microseconds = Platform.getLong(baseObject, baseOffset + offset + 8); return new CalendarInterval(months, microseconds); }",
        "label":1
    },
    {
        "ins1CurCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\"), TooltipTextUtil.createText(\" author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription();",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription();",
        "ins2PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindRangeBounds() { TableXYDataset<String> dataset = RendererXYPackageUtils.createTestTableXYDataset();",
        "ins1PreCode":"public void testFindRangeBounds() { TableXYDataset dataset = RendererXYPackageUtils.createTestTableXYDataset();",
        "ins2PreCode":"public void testFindDomainBounds() { XYSeriesCollection dataset = RendererXYPackageUtils.createTestXYSeriesCollection();",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindDomainBounds() { XYSeriesCollection<String> dataset = RendererXYPackageUtils.createTestXYSeriesCollection();",
        "ins1PreCode":"public void testFindDomainBounds() { XYSeriesCollection dataset = RendererXYPackageUtils.createTestXYSeriesCollection();",
        "ins2PreCode":"public void testFindRangeBounds() { TableXYDataset dataset = RendererXYPackageUtils.createTestTableXYDataset();",
        "label":1
    },
    {
        "ins1CurCode":"public MeterFilter metricsHttpServerUriTagFilter() { String metricName = this.properties.getWeb().getServer().getRequest() .getMetricName(); MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(() -> String",
        "ins1PreCode":"public MeterFilter metricsHttpServerUriTagFilter() { String metricName = this.properties.getWeb().getServer().getRequestsMetricName(); MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(() -> String",
        "ins2PreCode":"public MeterFilter metricsHttpServerUriTagFilter() { String metricName = this.properties.getWeb().getServer().getRequestsMetricName(); MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(() -> String",
        "label":1
    },
    {
        "ins1CurCode":"JavaPairDStream<String, Tuple2<String, String>> joined = pairStream1.transformWithToPair( pairStream2, (rdd1, rdd2, time) -> rdd1.join(rdd2) );",
        "ins1PreCode":"JavaPairDStream<String, Tuple2<String, String>> joined = pairStream1.transformWithToPair( pairStream2, new Function3< JavaPairRDD<String, String>, JavaPairRDD<String, String>, Time, JavaPairRDD<String, Tuple2<String, String>>>() { @Override public JavaPairRDD<String, Tuple2<String, String>> call( JavaPairRDD<String, String> rdd1, JavaPairRDD<String, String> rdd2, Time time) { return rdd1.join(rdd2); }",
        "ins2PreCode":"JavaTestUtils.attachTestOutputStream(joined); List<List<Tuple2<String, Tuple2<String, String>>>> result = JavaTestUtils.runStreams(ssc, 2, 2); List<Set<Tuple2<String, Tuple2<String, String>>>> unorderedResult = Lists.newArrayList(); for (List<Tuple2<String, Tuple2<String, String>>> res : result) {",
        "label":0
    },
    {
        "ins1CurCode":"public void testInsertWithMapper() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { Mapper userMapper = sqlSession.getMapper(Mapper.class); User user1 = new User(null, \"Pocoyo\"); userMapper.insert(user1); User user2 = new User(null, \"Valentina\"); userMapper.insert(user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); }  try { sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2); } finally { sqlSession.close(); }",
        "ins1PreCode":"public void testInsertWithMapper() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { Mapper userMapper = sqlSession.getMapper(Mapper.class); User user1 = new User(null, \"Pocoyo\"); userMapper.insert(user1); User user2 = new User(null, \"Valentina\"); userMapper.insert(user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); }  sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2);",
        "ins2PreCode":"public void testInsertMapperJdbc3() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { Mapper userMapper = sqlSession.getMapper(Mapper.class); User user1 = new User(null, \"Pocoyo\"); userMapper.insertIdentity(user1); User user2 = new User(null, \"Valentina\"); userMapper.insertIdentity(user2); sqlSession.flushStatements(); assertEquals(Integer.valueOf(0), user1.getId()); assertEquals(Integer.valueOf(1), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); }  sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"selectIdentity\"); Assert.assertTrue(users.size() == 2);",
        "label":1
    },
    {
        "ins1CurCode":"private void setUpLogin() throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(SHORT_TIMEOUT_MINS);   Tomcat.addServlet(ctxt, \"TesterServlet3\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); ctxt.addConstraint(sc);   Tomcat.addServlet(ctxt, \"TesterServlet4\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet4\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); ctxt.setLoginConfig(lc); basicAuthenticator = new BasicAuthenticator(); ctxt.getPipeline().addValve(basicAuthenticator);",
        "ins1PreCode":"private void setUpLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet3\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); ctxt.addConstraint(sc);   Tomcat.addServlet(ctxt, \"TesterServlet4\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet4\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new BasicAuthenticator());",
        "ins2PreCode":"private void setUpLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(SHORT_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet3\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet3\");  SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); ctxt.addConstraint(sc);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new BasicAuthenticator());",
        "label":0
    },
    {
        "ins1CurCode":"vm.run(v);  assertEquals(VM.FALSE, vm.getStack().pop()); assertEquals(VM.TRUE, vm.getStack().pop()); assertEquals(VM.FALSE, vm.getStack().pop()); assertEquals(VM.TRUE, vm.getStack().pop()); assertEquals(VM.FALSE, vm.getStack().pop()); assertEquals(VM.FALSE, vm.getStack().pop()); assertEquals(VM.FALSE, vm.getStack().pop()); assertEquals(VM.TRUE, vm.getStack().pop()); assertEquals(VM.FALSE, vm.getStack().pop()); assertEquals(VM.TRUE, vm.getStack().pop()); assertEquals(0, vm.getStack().size());",
        "ins1PreCode":"vm.run(v);  Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "ins2PreCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.FALSE, vm.getStack().pop()); Assert.assertEquals(VM.TRUE, vm.getStack().pop()); Assert.assertEquals(0, vm.getStack().size());",
        "label":1
    },
    {
        "ins1CurCode":"public void testUpdateFieldSetToNullCorrectFieldChangeContents() { entry.setField(StandardField.YEAR, \"2016\"); Optional<FieldChange> change = UpdateField.updateField(entry, StandardField.YEAR, null); assertNull(change.get().getNewValue()); assertEquals(StandardField.YEAR, change.get().getField()); assertEquals(\"2016\", change.get().getOldValue());",
        "ins1PreCode":"public void testUpdateFieldSetToNullCorrectFieldChangeContents() { entry.setField(\"year\", \"2016\"); Optional<FieldChange> change = UpdateField.updateField(entry, \"year\", null); assertNull(change.get().getNewValue()); assertEquals(\"year\", change.get().getField()); assertEquals(\"2016\", change.get().getOldValue());",
        "ins2PreCode":"public void testUpdateFieldSameContentHasCorrectFieldChange() { entry.setField(\"year\", \"2016\"); Optional<FieldChange> change = UpdateField.updateField(entry, \"year\", \"2016\", true); assertNull(change.get().getNewValue()); assertEquals(\"year\", change.get().getField()); assertEquals(\"2016\", change.get().getOldValue());",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetEstimatedDurationWithFailedRun() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<>();  Job project = createMockProject(runs);  TestBuild lastBuild = new TestBuild(project, Result.FAILURE, 42, null); runs.put(1, lastBuild);  assertEquals(42, project.getEstimatedDuration());",
        "ins1PreCode":"public void testGetEstimatedDurationWithFailedRun() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<Integer, TestBuild>();  Job project = createMockProject(runs);  TestBuild lastBuild = new TestBuild(project, Result.FAILURE, 42, null); runs.put(1, lastBuild);  assertEquals(-1, project.getEstimatedDuration());",
        "ins2PreCode":"public void testGetEstimatedDurationIfNoSuccessfulBuildTakeDurationOfFailedBuild() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<Integer, TestBuild>(); ",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() { addMapper(); try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() throws Exception { addMapper(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); Product product = mapper.getProductByName(\"iPad\"); assertEquals(Integer.valueOf(2), product.getId().getValue()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldApplyTypeHandlerUsingConstructor() throws Exception { addMapper(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); Product product = mapper.getProductByName(\"iPad\"); assertEquals(Integer.valueOf(2), product.getId().getValue()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":" this.getDatabase().registerListener(new SearchListener()); this.getDatabase().registerListener(new IndexUpdateListener()); this.getDatabase().registerListener(new EntriesRemovedListener());",
        "ins1PreCode":" this.getDatabase().registerListener(new SearchListener()); this.getDatabase().registerListener(new EntriesRemovedListener()); ",
        "ins2PreCode":"public void feedData(BibDatabaseContext bibDatabaseContext) { cleanUp();  this.bibDatabaseContext = Objects.requireNonNull(bibDatabaseContext);  bibDatabaseContext.getDatabase().registerListener(this); bibDatabaseContext.getMetaData().registerListener(this);  this.tableModel = new MainTableDataModel(getBibDatabaseContext(), preferencesService, Globals.stateManager); citationStyleCache = new CitationStyleCache(bibDatabaseContext); annotationCache = new FileAnnotationCache(bibDatabaseContext, preferencesService.getFilePreferences());  setupMainPanel(); setupAutoCompletion();  this.getDatabase().registerListener(new SearchListener()); this.getDatabase().registerListener(new EntriesRemovedListener());   this.bibDatabaseContext.getDatabase().registerListener(new GroupTreeListener());  this.bibDatabaseContext.getDatabase().registerListener(this);  this.getDatabase().registerListener(new UpdateTimestampListener(preferencesService));  this.entryEditor = new EntryEditor(this, externalFileTypes);  Platform.runLater(() -> { EasyBind.subscribe(changedProperty, this::updateTabTitle); Globals.stateManager.getOpenDatabases().addListener((ListChangeListener<BibDatabaseContext>) c -> updateTabTitle(changedProperty.getValue())); });  if (isDatabaseReadyForAutoSave(bibDatabaseContext)) { AutosaveManager autoSaver = AutosaveManager.start(bibDatabaseContext); autoSaver.registerListener(new AutosaveUiManager(this)); }  BackupManager.start(this.bibDatabaseContext, Globals.entryTypesManager, Globals.prefs);",
        "label":0
    },
    {
        "ins1CurCode":" r.setAutoPopulateSeriesPaint(true); CategoryPlot<String, String> plot = new CategoryPlot<>(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r);",
        "ins1PreCode":" r.setAutoPopulateSeriesPaint(true); CategoryPlot plot = new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r);",
        "ins2PreCode":" r.setAutoPopulateSeriesFillPaint(true); new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r); assertEquals(DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE[0],",
        "label":0
    },
    {
        "ins1CurCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory()) { if (!\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "ins1PreCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory() && !\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "ins2PreCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory() && !\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "label":1
    },
    {
        "ins1CurCode":"Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>07-hello world</p>\") > 0);",
        "ins1PreCode":"Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"public void testServlet22NoEL() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-2.2\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/el-as-literal.jsp\");  String result = res.toString();  Assert.assertTrue(result.indexOf(\"<p>00-${'hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>01-#{'hello world'}</p>\") > 0);",
        "label":0
    },
    {
        "ins1CurCode":"SpscLinkedArrayQueue<R> q = queue.get();  if (checkTerminate(d, q)) { errors.tryTerminateConsumer(downstream);",
        "ins1PreCode":"SpscLinkedArrayQueue<R> q = queue.get();  if (d && (q == null || q.isEmpty())) { errors.tryTerminateConsumer(downstream);",
        "ins2PreCode":"void innerSuccess(InnerObserver inner, R value) { set.delete(inner); if (get() == 0 && compareAndSet(0, 1)) { boolean d = active.decrementAndGet() == 0; if (requested.get() != 0) { downstream.onNext(value);  SpscLinkedArrayQueue<R> q = queue.get();  if (d && (q == null || q.isEmpty())) { errors.tryTerminateConsumer(downstream); return; } BackpressureHelper.produced(requested, 1); if (maxConcurrency != Integer.MAX_VALUE) { upstream.request(1); } } else { SpscLinkedArrayQueue<R> q = getOrCreateQueue(); synchronized (q) { q.offer(value); } } if (decrementAndGet() == 0) { return; } } else { SpscLinkedArrayQueue<R> q = getOrCreateQueue(); synchronized (q) { q.offer(value); } active.decrementAndGet(); if (getAndIncrement() != 0) { return; } } drainLoop();",
        "label":0
    },
    {
        "ins1CurCode":"void testMongoIsDown() { ReactiveMongoTemplate reactiveMongoTemplate = mock(ReactiveMongoTemplate.class);",
        "ins1PreCode":"public void testMongoIsDown() { ReactiveMongoTemplate reactiveMongoTemplate = mock(ReactiveMongoTemplate.class);",
        "ins2PreCode":"public void testCassandraIsDown() { ReactiveCassandraOperations reactiveCassandraOperations = mock(ReactiveCassandraOperations.class);",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual(Observer<? super T> t) { CacheDisposable<T> consumer = new CacheDisposable<>(t, this); t.onSubscribe(consumer);",
        "ins1PreCode":"protected void subscribeActual(Observer<? super T> t) { CacheDisposable<T> consumer = new CacheDisposable<T>(t, this); t.onSubscribe(consumer);",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super T> t) { CacheSubscription<T> consumer = new CacheSubscription<T>(t, this); t.onSubscribe(consumer);",
        "label":1
    },
    {
        "ins1CurCode":"public void setLevel() { this.loggingSystem.beforeInitialize();",
        "ins1PreCode":"public void setLevel() throws Exception { this.loggingSystem.beforeInitialize();",
        "ins2PreCode":"public void setLevelToNull() throws Exception { this.loggingSystem.beforeInitialize();",
        "label":1
    },
    {
        "ins1CurCode":"return current; } return queue.get();",
        "ins1PreCode":"SpscLinkedArrayQueue<R> getOrCreateQueue() { for (;;) { SpscLinkedArrayQueue<R> current = queue.get();",
        "ins2PreCode":"SpscLinkedArrayQueue<R> getOrCreateQueue() { for (;;) { SpscLinkedArrayQueue<R> current = queue.get();",
        "label":1
    },
    {
        "ins1CurCode":"  LinkedHashSet<K> set = new LinkedHashSet<>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();",
        "ins1PreCode":"  LinkedHashSet<K> set = new LinkedHashSet<K>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();",
        "ins2PreCode":"public Set<Map.Entry<K,V>> entrySet() { LinkedHashSet<Map.Entry<K,V>> set = new LinkedHashSet<Map.Entry<K,V>>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();",
        "label":0
    },
    {
        "ins1CurCode":"Settings settings = Settings.builder() .put(\"network.host\", host) .put(TransportSettings.PORT.getKey(), 22) .put(\"transport.profiles.default.port\", 0)",
        "ins1PreCode":"Settings settings = Settings.builder() .put(\"network.host\", host) .put(TcpTransport.PORT.getKey(), 22) .put(\"transport.profiles.default.port\", 0)",
        "ins2PreCode":"Settings settings = Settings.builder() .put(\"network.host\", host) .put(TcpTransport.PORT.getKey(), 0) .put(\"transport.profiles.client1.port\", 0)",
        "label":1
    },
    {
        "ins1CurCode":"void testAnnotatedInsertTable2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testAnnotatedInsertTable2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer(); ClusteredXYBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { ClusteredXYBarRenderer r1 = new ClusteredXYBarRenderer(); ClusteredXYBarRenderer r2 = (ClusteredXYBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { XYBoxAndWhiskerRenderer r1 = new XYBoxAndWhiskerRenderer(); XYBoxAndWhiskerRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposable.fromRunnable(new Runnable() { ",
        "ins1PreCode":"final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposables.fromRunnable(new Runnable() { ",
        "ins2PreCode":"final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposables.fromRunnable(new Runnable() {  @Override public void run() { counter.incrementAndGet(); }  }));  cd.add(Disposables.fromRunnable(new Runnable() { ",
        "label":0
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<>(); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<Subscriber<? super Object>>(); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Observer<? super Object>> ref = new AtomicReference<Observer<? super Object>>(); ",
        "label":1
    },
    {
        "ins1CurCode":" ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts(), \"Check artifact list\" );",
        "ins1PreCode":" ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "ins2PreCode":" ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.output.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\") .contains(\"Are you using 'uriVariables'?\");",
        "ins1PreCode":"assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.output.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output.toString()) .contains(\"Are you using 'uriVariables'?\");",
        "ins2PreCode":"assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.output.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output.toString()) .contains(\"Are you using 'uriVariables'?\");",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node));  for (Integer otherNode : graph.nodes()) { boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); }",
        "ins1PreCode":"assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node));  }",
        "ins2PreCode":"assertThat(graph.outDegree(node)).isEqualTo(asGraph.outDegree(node));  }",
        "label":1
    },
    {
        "ins1CurCode":"  assertEquals(100, eventCounter.get());",
        "ins1PreCode":"fail(\"timed out - never got completion\"); } assertEquals(2, eventCounter.get());",
        "ins2PreCode":"fail(\"timed out - never got completion\"); } assertEquals(2, eventCounter.get());",
        "label":1
    },
    {
        "ins1CurCode":"Date end = new Date(apr22007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnitType.DAY, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d4.getTime());",
        "ins1PreCode":"Date end = new Date(apr22007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.DAY, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "ins2PreCode":"Date end = new Date(apr22007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.DAY, 7); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = plot.getSubplots().get(0); NumberAxis xAxis = (NumberAxis) subplot1.getDomainAxis();",
        "ins1PreCode":"JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = (XYPlot) plot.getSubplots().get(0); NumberAxis xAxis = (NumberAxis) subplot1.getDomainAxis();",
        "ins2PreCode":"public void testNotification() { CombinedRangeCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = (CategoryPlot) plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero()); assertEquals(1, this.events.size());   BufferedImage image = new BufferedImage(200, 100, BufferedImage.TYPE_INT_RGB); Graphics2D g2 = image.createGraphics(); this.events.clear(); chart.draw(g2, new Rectangle2D.Double(0.0, 0.0, 200.0, 100.0)); assertTrue(this.events.isEmpty());",
        "label":0
    },
    {
        "ins1CurCode":"Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Observer<Integer> mockSubscriber = TestHelper.mockObserver(); oi.subscribe(new TestObserverEx<>(mockSubscriber)); ",
        "ins1PreCode":"Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Observer<Integer> mockSubscriber = TestHelper.mockObserver(); oi.subscribe(new TestObserverEx<Integer>(mockSubscriber)); ",
        "ins2PreCode":"Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber();  oi.subscribe(new TestSubscriber<Integer>(mockSubscriber)); ",
        "label":1
    },
    {
        "ins1CurCode":"TestObserver<String> to = new TestObserver<>(observer);  TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2)); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "ins1PreCode":"TestObserver<String> to = new TestObserver<>(observer);  @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2));",
        "ins2PreCode":"public void concatUnsubscribe() { final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<>(subscriber, 0L);  final Flowable<String> concat = Flowable.concat(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2));  try {  concat.subscribe(ts);  callOnce.await();  ts.cancel();  okToContinue.countDown(); w1.t.join(); w2.t.join(); } catch (Throwable e) { e.printStackTrace(); fail(e.getMessage()); }  InOrder inOrder = inOrder(subscriber); inOrder.verify(subscriber, times(1)).onNext(\"one\"); inOrder.verify(subscriber, times(1)).onNext(\"two\"); inOrder.verify(subscriber, times(1)).onNext(\"three\"); inOrder.verify(subscriber, times(1)).onNext(\"four\"); inOrder.verify(subscriber, never()).onNext(\"five\"); inOrder.verify(subscriber, never()).onNext(\"six\"); inOrder.verify(subscriber, never()).onComplete(); ",
        "label":0
    },
    {
        "ins1CurCode":"protected void subscribeActual(Observer<? super Integer> observer) { o[0] = observer; observer.onSubscribe(Disposable.empty()); observer.onError(new TestException(\"First\"));",
        "ins1PreCode":"protected void subscribeActual(Observer<? super Integer> observer) { o[0] = observer; observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\"));",
        "ins2PreCode":"public void badEndSource() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { @SuppressWarnings(\"rawtypes\") final Subscriber[] o = { null };  TestSubscriberEx<Integer> ts = Flowable.just(1) .join(Flowable.just(2), Functions.justFunction(Flowable.never()), Functions.justFunction(new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { o[0] = subscriber; subscriber.onSubscribe(new BooleanSubscription()); subscriber.onError(new TestException(\"First\")); } }), new BiFunction<Integer, Integer, Integer>() { @Override public Integer apply(Integer a, Integer b) throws Exception { return a + b; } }) .to(TestHelper.<Integer>testConsumer());  o[0].onError(new TestException(\"Second\"));  ts .assertFailureAndMessage(TestException.class, \"First\");  TestHelper.assertUndeliverable(errors, 0, TestException.class, \"Second\"); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void autoConfiguredHikariDataSourceIsInstrumented() { this.contextRunner .withConfiguration( AutoConfigurations.of(DataSourceAutoConfiguration.class)) .run((context) -> { context.getBean(DataSource.class).getConnection();",
        "ins1PreCode":"public void autoConfiguredHikariDataSourceIsInstrumented() { this.contextRunner.run((context) -> { context.getBean(DataSource.class).getConnection();",
        "ins2PreCode":".withPropertyValues( \"spring.datasource.schema:db/create-custom-schema.sql\") .run((context) -> { context.getBean(DataSource.class).getConnection(); MeterRegistry registry = context.getBean(MeterRegistry.class);",
        "label":1
    },
    {
        "ins1CurCode":"requested.decrementAndGet(); } if (maxConcurrency != Integer.MAX_VALUE && !cancelled && ++scalarEmitted == scalarLimit) { scalarEmitted = 0; upstream.request(scalarLimit); } } else { if (q == null) { q = getMainQueue(); } if (!q.offer(value)) { onError(new MissingBackpressureException(\"Scalar queue full?!\")); } } if (decrementAndGet() == 0) { return; } } else { SimpleQueue<U> q = getMainQueue(); if (!q.offer(value)) { onError(new MissingBackpressureException(\"Scalar queue full?!\")); return;",
        "ins1PreCode":"requested.decrementAndGet(); } if (maxConcurrency != Integer.MAX_VALUE && !cancelled && ++scalarEmitted == scalarLimit) { scalarEmitted = 0; upstream.request(scalarLimit); } } else { if (q == null) { q = getMainQueue(); } if (!q.offer(value)) { onError(new IllegalStateException(\"Scalar queue full?!\")); return; } } if (decrementAndGet() == 0) { return; } } else { SimpleQueue<U> q = getMainQueue(); if (!q.offer(value)) { onError(new IllegalStateException(\"Scalar queue full?!\")); return;",
        "ins2PreCode":"} else { if (q == null) { q = getInnerQueue(inner); }",
        "label":0
    },
    {
        "ins1CurCode":"throw new TestException(); } return new ArrayList<>(); }",
        "ins1PreCode":"throw new TestException(); } return new ArrayList<Integer>(); }",
        "ins2PreCode":"throw new TestException(); } return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryDataset<String, String> u1 = new DefaultCategoryDataset<>(); u1.addValue(1.0, \"R1\", \"C1\"); u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); SlidingCategoryDataset<String, String> d2; d2 = (SlidingCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\");",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryDataset u1 = new DefaultCategoryDataset(); u1.addValue(1.0, \"R1\", \"C1\"); u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2; d2 = (SlidingCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\");",
        "ins2PreCode":"public void testSerialization() { DefaultCategoryDataset u1 = new DefaultCategoryDataset(); u1.addValue(1.0, \"R1\", \"C1\"); u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2 = (SlidingCategoryDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset();",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> merge( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Flowable<T> merge( Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3, Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> mergeDelayError( Publisher<? extends T> source1, Publisher<? extends T> source2, Publisher<? extends T> source3, Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testOverwriteTrue() { buildRule.executeTarget(\"testSimpleScale\"); assumeNotNull(\"JPEG codec is unavailable in classpath\", buildRule.getProject().getProperty(\"jpeg.codec.available\")); assertThat(buildRule.getLog(), containsString(\"Processing File\"));",
        "ins1PreCode":"public void testOverwriteTrue() { buildRule.executeTarget(\"testSimpleScale\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); File f = new File(buildRule.getOutputDir(), LARGEIMAGE); assumeTrue(\"Could not change file modification date\",",
        "ins2PreCode":"public void testOverwriteTrue() { buildRule.executeTarget(\"testSimpleScale\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); File f = new File(buildRule.getOutputDir(), LARGEIMAGE); assumeTrue(\"Could not change file modification date\", f.setLastModified(f.lastModified() - FILE_UTILS.getFileTimestampGranularity() * 2)); long lastModified = f.lastModified(); buildRule.executeTarget(\"testOverwriteTrue\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); f = new File(buildRule.getOutputDir(), LARGEIMAGE); long overwrittenLastModified = f.lastModified(); assertTrue(\"File was not overwritten.\", lastModified < overwrittenLastModified);",
        "label":0
    },
    {
        "ins1CurCode":" char[] c = {'a', 'b', 'c'}; StringBuilder target = new StringBuilder(\"testNested4x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\"); } catch (BuildException ex) {",
        "ins1PreCode":" char[] c = {'a', 'b', 'c'}; StringBuffer target = new StringBuffer(\"testNested4x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\") ; } catch (BuildException ex) {",
        "ins2PreCode":" char[] c = {'a', 'b'}; StringBuffer target = new StringBuffer(\"testNested7x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\") ; } catch (BuildException ex) {",
        "label":1
    },
    {
        "ins1CurCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); Assert.assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); Assert.assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); Assert.assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { Assert.assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); }",
        "ins1PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); }",
        "ins2PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "label":1
    },
    {
        "ins1CurCode":"void cloudFoundryPlatformActive() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\",",
        "ins1PreCode":"public void cloudFoundryPlatformActive() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\",",
        "ins2PreCode":"public void cloudFoundryPlatformActive() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\",",
        "label":1
    },
    {
        "ins1CurCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) { Objects.requireNonNull(onError, \"onError is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<>(this, Functions.emptyConsumer(),",
        "ins1PreCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) { Objects.requireNonNull(onError, \"onError is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(),",
        "ins2PreCode":"public final ParallelFlowable<T> doOnComplete(@NonNull Action onComplete) { Objects.requireNonNull(onComplete, \"onComplete is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(),",
        "label":1
    },
    {
        "ins1CurCode":"public void testWithComplex2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "ins1PreCode":"public void testWithComplex2() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex2(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); sqlSession.close(); ",
        "ins2PreCode":"public void testWithComplex3() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); sqlSession.close(); ",
        "label":1
    },
    {
        "ins1CurCode":" FutureTask task = new FutureTask(new Callable() { @Override public Object call() {",
        "ins1PreCode":" FutureTask task = new FutureTask(new Callable() { public Object call() { final CLICommandInvoker.Result result = command",
        "ins2PreCode":"boolean timeoutOccurred = false; FutureTask task = new FutureTask(new Callable() { public Object call() { final CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"StringReader input = new StringReader(header);  Map<String,String> result = Authorization.parseAuthorizationDigest(input); ",
        "ins1PreCode":"StringReader input = new StringReader(header);  Map<String,String> result = HttpParser.parseAuthorizationDigest(input); ",
        "ins2PreCode":"StringReader input = new StringReader(header);  Map<String,String> result = HttpParser.parseAuthorizationDigest(input); ",
        "label":1
    },
    {
        "ins1CurCode":"ObjectHelper.verifyPositive(capacityHint, \"capacityHint\"); int ch = capacityHint / parallelism() + 1; ParallelFlowable<List<T>> railReduced = reduce(Functions.createArrayList(ch), ListAddBiConsumer.instance()); ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<>(comparator)); ",
        "ins1PreCode":"ObjectHelper.verifyPositive(capacityHint, \"capacityHint\"); int ch = capacityHint / parallelism() + 1; ParallelFlowable<List<T>> railReduced = reduce(Functions.<T>createArrayList(ch), ListAddBiConsumer.<T>instance()); ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<T>(comparator)); ",
        "ins2PreCode":" int ch = capacityHint / parallelism() + 1; ParallelFlowable<List<T>> railReduced = reduce(Functions.<T>createArrayList(ch), ListAddBiConsumer.<T>instance()); ParallelFlowable<List<T>> railSorted = railReduced.map(new SorterFunction<T>(comparator));  Flowable<List<T>> merged = railSorted.reduce(new MergerBiFunction<T>(comparator)); ",
        "label":1
    },
    {
        "ins1CurCode":"if (beanNames.length == 0) { throw new ApplicationContextException( \"Unable to start ReactiveWebApplicationContext due to missing ReactiveWebServerFactory bean.\"); }",
        "ins1PreCode":"if (beanNames.length == 0) { throw new ApplicationContextException( \"Unable to start ReactiveWebApplicationContext due to missing \" + \"ReactiveWebServerFactory bean.\"); }",
        "ins2PreCode":"protected ServletWebServerFactory getWebServerFactory() {  String[] beanNames = getBeanFactory() .getBeanNamesForType(ServletWebServerFactory.class); if (beanNames.length == 0) { throw new ApplicationContextException( \"Unable to start ServletWebServerApplicationContext due to missing \" + \"ServletWebServerFactory bean.\"); } if (beanNames.length > 1) { throw new ApplicationContextException( \"Unable to start ServletWebServerApplicationContext due to multiple \" + \"ServletWebServerFactory beans : \" + StringUtils.arrayToCommaDelimitedString(beanNames)); } return getBeanFactory().getBean(beanNames[0], ServletWebServerFactory.class);",
        "label":0
    },
    {
        "ins1CurCode":" SimpleBindings bindings = new SimpleBindings(); boolean needsScores = false; ReplaceableConstDoubleValueSource specialValue = null; for (String variable : expr.variables) { try { if (variable.equals(\"_score\")) { bindings.add(new SortField(\"_score\", SortField.Type.SCORE)); needsScores = true; } else if (variable.equals(\"_value\")) { specialValue = new ReplaceableConstDoubleValueSource(); bindings.add(\"_value\", specialValue);     } else if (vars != null && vars.containsKey(variable)) { bindFromParams(vars, bindings, variable); } else {   final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {  throw convertToScriptException(\"link error\", expr.sourceText, variable, e); } } return new ExpressionAggregationScript(expr, bindings, needsScores, specialValue);",
        "ins1PreCode":"for (String variable : expr.variables) { try { if (variable.equals(\"_value\")) { specialValue = new ReplaceableConstDoubleValueSource(); bindings.add(\"_value\", specialValue);     } else if (vars != null && vars.containsKey(variable)) { bindFromParams(vars, bindings, variable); } else {   final ValueSource valueSource = getDocValueSource(variable, lookup); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {  throw convertToScriptException(\"link error\", expr.sourceText, variable, e); } } return new ExpressionAggregationScript(expr, bindings, specialValue);",
        "ins2PreCode":"private ScoreScript.LeafFactory newScoreScript(Expression expr, SearchLookup lookup, @Nullable Map<String, Object> vars) {   SimpleBindings bindings = new SimpleBindings(); ReplaceableConstDoubleValueSource specialValue = null; boolean needsScores = false; for (String variable : expr.variables) { try { if (variable.equals(\"_score\")) { bindings.add(new SortField(\"_score\", SortField.Type.SCORE)); needsScores = true; } else if (variable.equals(\"_value\")) { specialValue = new ReplaceableConstDoubleValueSource(); bindings.add(\"_value\", specialValue);    } else if (vars != null && vars.containsKey(variable)) { bindFromParams(vars, bindings, variable); } else {   final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {  throw convertToScriptException(\"link error\", expr.sourceText, variable, e); } } return new ExpressionScoreScript(expr, bindings, needsScores);",
        "label":0
    },
    {
        "ins1CurCode":"Tomcat tomcat = getTomcatInstance();  Context ctx = tomcat.addContext(\"\", null); ctx.addApplicationListener(TesterEchoServer.Config.class.getName());",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();  Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName());",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance();  Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); ctx.addApplicationListener(TesterEchoServer.Config.class.getName());",
        "label":1
    },
    {
        "ins1CurCode":"void bindToMapWithNoDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToMapWithNoDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToMapWithDefaultConstructor() { ",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Integer> sub) { sub.onSubscribe(Disposable.empty()); sub.onNext(1);",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Integer> sub) { sub.onSubscribe(Disposables.empty()); sub.onNext(1);",
        "ins2PreCode":"public void groupsWithNestedSubscribeOn() throws InterruptedException { final ArrayList<String> results = new ArrayList<String>(); Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(Subscriber<? super Integer> sub) { sub.onSubscribe(new BooleanSubscription()); sub.onNext(1); sub.onNext(2); sub.onNext(1); sub.onNext(2); sub.onComplete(); }  }).groupBy(new Function<Integer, Integer>() {  @Override public Integer apply(Integer t) { return t; }  }).flatMap(new Function<GroupedFlowable<Integer, Integer>, Flowable<String>>() {  @Override public Flowable<String> apply(final GroupedFlowable<Integer, Integer> group) { return group.subscribeOn(Schedulers.newThread()).map(new Function<Integer, String>() {  @Override public String apply(Integer t1) { System.out.println(\"Received: \" + t1 + \" on group : \" + group.getKey()); return \"first groups: \" + t1; }  }); }  }).doOnEach(new Consumer<Notification<String>>() {  @Override public void accept(Notification<String> t1) { System.out.println(\"notification => \" + t1); }  }).blockingForEach(new Consumer<String>() {  @Override public void accept(String s) { results.add(s); }  });  System.out.println(\"Results: \" + results); assertEquals(4, results.size());",
        "label":0
    },
    {
        "ins1CurCode":"NumberAxis rangeAxis = new NumberAxis(\"Range\"); BarRenderer renderer = new BarRenderer(); CategoryPlot<String, String> p1 = new CategoryPlot<>(dataset, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.HORIZONTAL); CategoryPlot<String, String> p2 = TestUtils.serialised(p1); assertTrue(p1.equals(p2));",
        "ins1PreCode":"NumberAxis rangeAxis = new NumberAxis(\"Range\"); BarRenderer renderer = new BarRenderer(); CategoryPlot p1 = new CategoryPlot(dataset, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.HORIZONTAL); CategoryPlot p2 = TestUtils.serialised(p1); assertTrue(p1.equals(p2));",
        "ins2PreCode":"NumberAxis rangeAxis = new NumberAxis(\"Range\"); BarRenderer renderer = new BarRenderer(); CategoryPlot p1 = new CategoryPlot(data, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.VERTICAL); CategoryPlot p2 = TestUtils.serialised(p1); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1CurCode":"ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ApplicationConfigurationProperties applicationProperties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = applicationProperties .getContexts().get(context.getId()).getBeans().get(\"foo\"); assertThat(foo).isNotNull();",
        "ins1PreCode":"ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull();",
        "ins2PreCode":"ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull();",
        "label":1
    },
    {
        "ins1CurCode":"  Assertions.assertEquals(6, orderDetails.size());    for(OrderDetail orderDetail : orderDetails){ Assertions.assertNotNull(orderDetail.getOrderHeader()); }",
        "ins1PreCode":"  Assert.assertEquals(6, orderDetails.size());    for(OrderDetail orderDetail : orderDetails){ Assert.assertNotNull(orderDetail.getOrderHeader()); }",
        "ins2PreCode":"  Assert.assertEquals(6, orderDetails.size());    for(OrderDetail orderDetail : orderDetails){ Assert.assertNotNull(orderDetail.getOrderHeader()); }",
        "label":1
    },
    {
        "ins1CurCode":"} catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); }",
        "ins1PreCode":"} catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); } reader.moveUp(); }",
        "ins2PreCode":"} catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); } reader.moveUp(); }",
        "label":1
    },
    {
        "ins1CurCode":"Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<>(observer); ",
        "ins1PreCode":"Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<String>(observer); ",
        "ins2PreCode":"Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<String>(observer); ",
        "label":1
    },
    {
        "ins1CurCode":"if ( dep != null ) { Artifact art = dep.getArtifact(); ",
        "ins1PreCode":"if ( dep != null ) { org.eclipse.aether.artifact.Artifact art = dep.getArtifact(); ",
        "ins2PreCode":"public boolean visitEnter( DependencyNode node ) { StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.eclipse.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  String premanagedScope = DependencyManagerUtils.getPremanagedScope( node ); if ( premanagedScope != null && !premanagedScope.equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( premanagedScope ); appendManagementSource( buffer, art, \"scope\" ); buffer.append( \")\" ); }  String premanagedVersion = DependencyManagerUtils.getPremanagedVersion( node ); if ( premanagedVersion != null && !premanagedVersion.equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( premanagedVersion ); appendManagementSource( buffer, art, \"version\" ); buffer.append( \")\" ); } } else { buffer.append( project.getGroupId() ); buffer.append( ':' ).append( project.getArtifactId() ); buffer.append( ':' ).append( project.getPackaging() ); buffer.append( ':' ).append( project.getVersion() ); }  logger.debug( buffer.toString() ); indent += \"   \"; return true;",
        "label":0
    },
    {
        "ins1CurCode":"XYBarRenderer r1 = new XYBarRenderer(); r1.setLegendItemToolTipGenerator(generator); XYBarRenderer r2 = CloneUtils.clone(r1); ",
        "ins1PreCode":"XYBarRenderer r1 = new XYBarRenderer(); r1.setLegendItemToolTipGenerator(generator); XYBarRenderer r2 = (XYBarRenderer) r1.clone(); ",
        "ins2PreCode":"XYBarRenderer r1 = new XYBarRenderer(); r1.setLegendItemURLGenerator(generator); XYBarRenderer r2 = (XYBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(Shell.class,builders.get(0).getClass()); assertEquals(\"echo hello\",((Shell)builders.get(0)).getCommand().trim()); assertNotSame(builders.get(0), shell);",
        "ins1PreCode":"assertEquals(Shell.class,builders.get(0).getClass()); assertEquals(\"echo hello\",((Shell)builders.get(0)).getCommand().trim()); assertTrue(builders.get(0)!=shell);",
        "ins2PreCode":"assertEquals(Shell.class,builders.get(0).getClass()); assertEquals(\"echo hello\",((Shell)builders.get(0)).getCommand().trim()); assertTrue(builders.get(0)!=shell); System.out.println(project.getConfigFile().asString());",
        "label":1
    },
    {
        "ins1CurCode":" Assert.assertTrue(principal instanceof GenericPrincipal); Assert.assertEquals(USER, principal.getName());",
        "ins1PreCode":" Assert.assertTrue(principal instanceof GenericPrincipal); Assert.assertEquals(PASSWORD, ((GenericPrincipal)principal).getPassword());",
        "ins2PreCode":" Assert.assertTrue(principal instanceof GenericPrincipal); Assert.assertEquals(ha1(), ((GenericPrincipal)principal).getPassword());",
        "label":1
    },
    {
        "ins1CurCode":"} StringBuilder report = new StringBuilder(); report.append(String .format(\"%nThe use of configuration keys that have been renamed was found in the environment:%n%n\")); append(report, content);",
        "ins1PreCode":"} StringBuilder report = new StringBuilder(); report.append(String.format( \"%nThe use of configuration keys that have been \" + \"renamed was found in the environment:%n%n\")); append(report, content);",
        "ins2PreCode":"StringBuilder report = new StringBuilder(); report.append(String.format( \"%nThe use of configuration keys that are no longer \" + \"supported was found in the environment:%n%n\")); append(report, content); report.append(String.format(\"%n\")); report.append(\"Please refer to the migration guide or reference guide for \" + \"potential alternatives.\"); report.append(String.format(\"%n\"));",
        "label":0
    },
    {
        "ins1CurCode":"@Test public void setBuildDescriptionShouldFailWithoutJobReadPermission() throws Exception { FreeStyleProject project = j.createFreeStyleProject(\"aProject\"); project.getBuildersList().add(createScriptBuilder(\"echo 1\")); assertThat(project.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "ins1PreCode":"@Test public void setBuildDescriptionShouldFailWithoutJobReadPermission() throws Exception { FreeStyleProject project = j.createFreeStyleProject(\"aProject\"); project.getBuildersList().add(new Shell(\"echo 1\")); assertThat(project.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "ins2PreCode":"@Test public void setBuildDescriptionShouldFailWithoutRunUpdatePermission1() throws Exception { FreeStyleProject project = j.createFreeStyleProject(\"aProject\"); project.getBuildersList().add(new Shell(\"echo 1\")); assertThat(project.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValuesUsingAccessors(sourceBuilder); TestMap source = sourceBuilder.build();",
        "ins1PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValuesUsingMutableMap(sourceBuilder); TestMap source = sourceBuilder.build();",
        "ins2PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValuesUsingMutableMap(sourceBuilder); TestMap source = sourceBuilder.build();",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Item.READ, Item.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "ins2PreCode":"@Test public void connectNodeShouldFailIfNodeDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Computer.CONNECT, Jenkins.READ) .invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "label":0
    },
    {
        "ins1CurCode":"return Observable.just(v).hide(); } }, false, 2, ImmediateThinScheduler.INSTANCE); }",
        "ins1PreCode":"return Observable.just(v).hide(); } }, 2, false, ImmediateThinScheduler.INSTANCE); }",
        "ins2PreCode":"return Observable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { FastScatterPlot p1 = new FastScatterPlot(); FastScatterPlot p2 = CloneUtils.clone(p1); assertTrue(p1 != p2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { FastScatterPlot p1 = new FastScatterPlot(); FastScatterPlot p2 = (FastScatterPlot) p1.clone(); assertTrue(p1 != p2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DialPlot p1 = new DialPlot(); DialPlot p2 = (DialPlot) p1.clone(); assertTrue(p1 != p2); assertTrue(p1.getClass() == p2.getClass()); assertTrue(p1.equals(p2));",
        "label":0
    },
    {
        "ins1CurCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(HistoryPageEntry.getEntryId(5), historyPageFilter.newestOnPage); Assert.assertEquals(HistoryPageEntry.getEntryId(1), historyPageFilter.oldestOnPage);",
        "ins1PreCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(5, historyPageFilter.newestOnPage); Assert.assertEquals(1, historyPageFilter.oldestOnPage);",
        "ins2PreCode":"Assert.assertEquals(5, historyPageFilter.runs.size());  Assert.assertEquals(10, historyPageFilter.newestOnPage); Assert.assertEquals(6, historyPageFilter.oldestOnPage);",
        "label":1
    },
    {
        "ins1CurCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) { Objects.requireNonNull(onError, \"onError is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "ins1PreCode":"public final ParallelFlowable<T> doOnError(@NonNull Consumer<Throwable> onError) { ObjectHelper.requireNonNull(onError, \"onError is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "ins2PreCode":"public final ParallelFlowable<T> doOnComplete(@NonNull Action onComplete) { ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "label":1
    },
    {
        "ins1CurCode":"public void resolvedLinksContainsALinkForServletEndpoint() { ExposableServletEndpoint servletEndpoint = mock(ExposableServletEndpoint.class); given(servletEndpoint.getEndpointId()).willReturn(EndpointId.of(\"alpha\")); given(servletEndpoint.isEnableByDefault()).willReturn(true);",
        "ins1PreCode":"public void resolvedLinksContainsALinkForServletEndpoint() { ExposableServletEndpoint servletEndpoint = mock(ExposableServletEndpoint.class); given(servletEndpoint.getId()).willReturn(\"alpha\"); given(servletEndpoint.isEnableByDefault()).willReturn(true);",
        "ins2PreCode":"ExposableControllerEndpoint controllerEndpoint = mock( ExposableControllerEndpoint.class); given(controllerEndpoint.getId()).willReturn(\"alpha\"); given(controllerEndpoint.isEnableByDefault()).willReturn(true);",
        "label":1
    },
    {
        "ins1CurCode":"} assertEquals(newMap(1, \"1\"), builder.getInt32ToStringField()); builder.putInt32ToStringField(2, \"2\"); assertEquals( newMap(1, \"1\", 2, \"2\"), builder.getInt32ToStringField());  Map<Integer, TestMap.MessageValue> messageMap = builder.getMutableInt32ToMessageField(); messageMap.put(1, TestMap.MessageValue.getDefaultInstance()); assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.build().getInt32ToMessageField()); try { messageMap.put(2, TestMap.MessageValue.getDefaultInstance()); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.getInt32ToMessageField()); builder.putInt32ToMessageField(2, TestMap.MessageValue.getDefaultInstance()); assertEquals(",
        "ins1PreCode":"} assertEquals(newMap(1, \"1\"), builder.getInt32ToStringField()); builder.getMutableInt32ToStringField().put(2, \"2\"); assertEquals( newMap(1, \"1\", 2, \"2\"), builder.getInt32ToStringField());  Map<Integer, TestMap.MessageValue> messageMap = builder.getMutableInt32ToMessageField(); messageMap.put(1, TestMap.MessageValue.getDefaultInstance()); assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.build().getInt32ToMessageField()); try { messageMap.put(2, TestMap.MessageValue.getDefaultInstance()); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.getInt32ToMessageField()); builder.getMutableInt32ToMessageField().put(2, TestMap.MessageValue.getDefaultInstance()); assertEquals(",
        "ins2PreCode":"public void testMutableMapLifecycle() { TestMap.Builder builder = TestMap.newBuilder(); Map<Integer, Integer> intMap = builder.getMutableInt32ToInt32Field(); intMap.put(1, 2); assertEquals(newMap(1, 2), builder.build().getInt32ToInt32Field()); try { intMap.put(2, 3); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, 2), builder.getInt32ToInt32Field()); builder.getMutableInt32ToInt32Field().put(2, 3); assertEquals(newMap(1, 2, 2, 3), builder.getInt32ToInt32Field());  Map<Integer, TestMap.EnumValue> enumMap = builder.getMutableInt32ToEnumField(); enumMap.put(1, TestMap.EnumValue.BAR); assertEquals(newMap(1, TestMap.EnumValue.BAR), builder.build().getInt32ToEnumField()); try { enumMap.put(2, TestMap.EnumValue.FOO); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, TestMap.EnumValue.BAR), builder.getInt32ToEnumField()); builder.getMutableInt32ToEnumField().put(2, TestMap.EnumValue.FOO); assertEquals( newMap(1, TestMap.EnumValue.BAR, 2, TestMap.EnumValue.FOO), builder.getInt32ToEnumField());  Map<Integer, String> stringMap = builder.getMutableInt32ToStringField(); stringMap.put(1, \"1\"); assertEquals(newMap(1, \"1\"), builder.build().getInt32ToStringField()); try { stringMap.put(2, \"2\"); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, \"1\"), builder.getInt32ToStringField()); builder.getMutableInt32ToStringField().put(2, \"2\"); assertEquals( newMap(1, \"1\", 2, \"2\"), builder.getInt32ToStringField());  Map<Integer, TestMap.MessageValue> messageMap = builder.getMutableInt32ToMessageField(); messageMap.put(1, TestMap.MessageValue.getDefaultInstance()); assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.build().getInt32ToMessageField()); try { messageMap.put(2, TestMap.MessageValue.getDefaultInstance()); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.getInt32ToMessageField()); builder.getMutableInt32ToMessageField().put(2, TestMap.MessageValue.getDefaultInstance()); assertEquals( newMap(1, TestMap.MessageValue.getDefaultInstance(), 2, TestMap.MessageValue.getDefaultInstance()), builder.getInt32ToMessageField());",
        "label":0
    },
    {
        "ins1CurCode":"st.close(); } finally { if (con!=null) { try { con.close(); } catch (Exception ignore) { ",
        "ins1PreCode":"st.close(); } finally { if (con!=null) try {con.close();}catch (Exception ignore) {} }",
        "ins2PreCode":"try { Thread.sleep(100); }catch (InterruptedException x) { Thread.interrupted(); } } con = future.get(); Statement st = con.createStatement(); ResultSet rs = st.executeQuery(\"select * from user\"); int cnt = 1; while (rs.next()) { System.out.println((cnt++)+\". Host:\" +rs.getString(\"Host\")+\" User:\"+rs.getString(\"User\")+\" Password:\"+rs.getString(\"Password\")); } rs.close(); st.close(); } finally { if (con!=null) try {con.close();}catch (Exception ignore) {} }",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StackedXYBarRenderer r1 = new StackedXYBarRenderer(); StackedXYBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYBarRenderer r1 = new StackedXYBarRenderer(); StackedXYBarRenderer r2 = (StackedXYBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { XYStepRenderer r1 = new XYStepRenderer(); XYStepRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"if (bytesRead == -1) {  return -1; }",
        "ins1PreCode":"if (bytesRead == -1) {   return 0;",
        "ins2PreCode":"private int processSNI() throws IOException {    if (netInBuffer.position() == 0) { sc.read(netInBuffer, socket, handshakeReadCompletionHandler); return 1; }  TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer);  while (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer); extractor = new TLSClientHelloExtractor(netInBuffer); }  String hostName = null; List<Cipher> clientRequestedCiphers = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: sc.read(netInBuffer, socket, handshakeReadCompletionHandler); return 1; case UNDERFLOW:  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniDefault\")); } hostName = endpoint.getDefaultSSLHostConfigName(); clientRequestedCiphers = Collections.emptyList(); break; }  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", hostName)); }  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers);    getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize()); if (netOutBuffer.capacity() < sslEngine.getSession().getApplicationBufferSize()) {  log.info(sm.getString(\"channel.nio.ssl.expandNetOutBuffer\", Integer.toString(sslEngine.getSession().getApplicationBufferSize()))); } netInBuffer = ByteBufferUtils.expand(netInBuffer, sslEngine.getSession().getPacketBufferSize()); netOutBuffer = ByteBufferUtils.expand(netOutBuffer, sslEngine.getSession().getPacketBufferSize());   netOutBuffer.position(0); netOutBuffer.limit(0);   sslEngine.beginHandshake(); handshakeStatus = sslEngine.getHandshakeStatus();  return 0;",
        "label":0
    },
    {
        "ins1CurCode":"  List<Row> data = Arrays.asList( RowFactory.create(0, Vectors.dense(1.0, 0.1, -1.0)), RowFactory.create(1, Vectors.dense(2.0, 1.1, 1.0)), RowFactory.create(2, Vectors.dense(3.0, 10.1, 3.0)) ); StructType schema = new StructType(new StructField[]{ new StructField(\"id\", DataTypes.IntegerType, false, Metadata.empty()), new StructField(\"features\", new VectorUDT(), false, Metadata.empty()) }); Dataset<Row> dataFrame = spark.createDataFrame(data, schema);  MinMaxScaler scaler = new MinMaxScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MinMaxScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); System.out.println(\"Features scaled to range: [\" + scaler.getMin() + \", \" + scaler.getMax() + \"]\"); scaledData.select(\"features\", \"scaledFeatures\").show(); ",
        "ins1PreCode":"  Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); MinMaxScaler scaler = new MinMaxScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MinMaxScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show(); ",
        "ins2PreCode":"  Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show(); ",
        "label":0
    },
    {
        "ins1CurCode":"void getIdFetchersReturnsAllFetcherDerivingFromIdFetcher() throws Exception { Set<IdFetcher<?>> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(IdFetcher.class.getCanonicalName()); Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses()); ",
        "ins1PreCode":"void getIdFetchersReturnsAllFetcherDerivingFromIdFetcher() throws Exception { Set<IdFetcher> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(IdFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); ",
        "ins2PreCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(fullTextFetchers));",
        "label":0
    },
    {
        "ins1CurCode":"this.datasource.setValidationQueryTimeout(TIMEOUT);  isTimeoutSet = false;",
        "ins1PreCode":"this.datasource.setValidationQueryTimeout(TIMEOUT);  TIMEOUT = 10; isTimeoutSet = false;",
        "ins2PreCode":"public void setUp() throws SQLException { DriverManager.registerDriver(new MockDriver());   this.datasource.setDriverClassName(MockDriver.class.getName()); this.datasource.setUrl(MockDriver.url);   this.datasource.setInitialSize(1); this.datasource.setTestOnBorrow(true); this.datasource.setValidationInterval(-1); this.datasource.setValidationQuery(\"SELECT 1\"); this.datasource.setMaxActive(1); this.datasource.setJdbcInterceptors(SlowQueryReportJmx.class.getName()+\"(threshold=50,notifyPool=false)\");",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetStartValue() { TaskSeriesCollection<String, String> c = createCollection1(); assertEquals(1L, c.getStartValue(\"S1\", \"Task 1\")); assertEquals(3L, c.getStartValue(\"S1\", \"Task 2\")); assertEquals(5L, c.getStartValue(\"S2\", \"Task 3\"));  assertEquals(1L, c.getStartValue(0, 0)); assertEquals(3L, c.getStartValue(0, 1)); assertEquals(null, c.getStartValue(0, 2)); assertEquals(null, c.getStartValue(1, 0)); assertEquals(null, c.getStartValue(1, 1)); assertEquals(5L, c.getStartValue(1, 2));   TaskSeriesCollection<String, String> c3 = createCollection3(); assertEquals(100L, c3.getStartValue(0, 0));",
        "ins1PreCode":"public void testGetStartValue() { TaskSeriesCollection c = createCollection1(); assertEquals(1L, c.getStartValue(\"S1\", \"Task 1\")); assertEquals(3L, c.getStartValue(\"S1\", \"Task 2\")); assertEquals(5L, c.getStartValue(\"S2\", \"Task 3\"));  assertEquals(1L, c.getStartValue(0, 0)); assertEquals(3L, c.getStartValue(0, 1)); assertEquals(null, c.getStartValue(0, 2)); assertEquals(null, c.getStartValue(1, 0)); assertEquals(null, c.getStartValue(1, 1)); assertEquals(5L, c.getStartValue(1, 2));   TaskSeriesCollection c3 = createCollection3(); assertEquals(100L, c3.getStartValue(0, 0));",
        "ins2PreCode":"public void testGetEndValue() { TaskSeriesCollection c = createCollection1(); assertEquals(2L, c.getEndValue(\"S1\", \"Task 1\")); assertEquals(4L, c.getEndValue(\"S1\", \"Task 2\")); assertEquals(6L, c.getEndValue(\"S2\", \"Task 3\"));  assertEquals(2L, c.getEndValue(0, 0)); assertEquals(4L, c.getEndValue(0, 1)); assertEquals(null, c.getEndValue(0, 2)); assertEquals(null, c.getEndValue(1, 0)); assertEquals(null, c.getEndValue(1, 1)); assertEquals(6L, c.getEndValue(1, 2));   TaskSeriesCollection c3 = createCollection3(); assertEquals(200L, c3.getEndValue(0, 0));",
        "label":1
    },
    {
        "ins1CurCode":"void enabled() { SpringApplication application = new SpringApplication(Config.class);",
        "ins1PreCode":"public void enabled() { SpringApplication application = new SpringApplication(Config.class);",
        "ins2PreCode":"public void disabled() { SpringApplication application = new SpringApplication(Config.class);",
        "label":1
    },
    {
        "ins1CurCode":"Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset<String, String> dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedBarChart(\"Stacked Bar Chart\",",
        "ins1PreCode":"Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedBarChart(\"Stacked Bar Chart\",",
        "ins2PreCode":"Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart(\"Waterfall Chart\",",
        "label":1
    },
    {
        "ins1CurCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "ins2PreCode":"this.chart.addChangeListener(l);  XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "label":0
    },
    {
        "ins1CurCode":"public void testFilterChain() throws IOException { executeTarget(\"testFilterChain\"); File tmp  = new File(getOutputDir(), \"copy.filterchain.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\");",
        "ins1PreCode":"public void testFilterChain() throws IOException { executeTarget(\"testFilterChain\"); File tmp  = new File(getProjectDir(), \"copy.filterchain.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\");",
        "ins2PreCode":"public void testFilterSet() throws IOException { executeTarget(\"testFilterSet\"); File tmp  = new File(getProjectDir(), \"move.filterset.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\");",
        "label":1
    },
    {
        "ins1CurCode":"parser.nextToken(); parser.nextToken(); XContentParseException exception = expectThrows(XContentParseException.class, () -> MeanReciprocalRank.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[reciprocal_rank] unknown field\")); }",
        "ins1PreCode":"parser.nextToken(); parser.nextToken(); IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> MeanReciprocalRank.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[reciprocal_rank] unknown field\")); }",
        "ins2PreCode":"parser.nextToken(); parser.nextToken(); IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> DiscountedCumulativeGain.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[dcg_at] unknown field\")); }",
        "label":1
    },
    {
        "ins1CurCode":"Integer key = index; if (this.backgroundDomainMarkers != null) { Collection<CategoryMarker> markers = this.backgroundDomainMarkers.get(key); if (markers != null) { for (CategoryMarker m : markers) { m.removeChangeListener(this); } markers.clear(); } } if (this.foregroundDomainMarkers != null) { Collection<CategoryMarker> markers = this.foregroundDomainMarkers.get(key);",
        "ins1PreCode":"Integer key = index; if (this.backgroundDomainMarkers != null) { Collection<Marker> markers = this.backgroundDomainMarkers.get(key); if (markers != null) { for (Marker m : markers) { m.removeChangeListener(this); } markers.clear(); } } if (this.foregroundDomainMarkers != null) { Collection<Marker> markers = this.foregroundDomainMarkers.get(key);",
        "ins2PreCode":"public void clearRangeMarkers(int index) { Integer key = index; if (this.backgroundRangeMarkers != null) { Collection<Marker> markers = this.backgroundRangeMarkers.get(key); if (markers != null) { for (Marker m : markers) { m.removeChangeListener(this); } markers.clear(); } } if (this.foregroundRangeMarkers != null) { Collection<Marker> markers = this.foregroundRangeMarkers.get(key); if (markers != null) { for (Marker m : markers) { m.removeChangeListener(this); } markers.clear(); } } fireChangeEvent();",
        "label":0
    },
    {
        "ins1CurCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toFlowable();  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"a\");",
        "ins1PreCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toFlowable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "ins2PreCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toFlowable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\");",
        "label":1
    },
    {
        "ins1CurCode":"nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins1PreCode":"nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins2PreCode":"nMatchingItems++; } fireTreeNodesInserted(this, path, childIndices, children); }",
        "label":1
    },
    {
        "ins1CurCode":"public ANode visitBinary(BinaryContext ctx) { AExpression left = (AExpression)visit(ctx.noncondexpression(0)); AExpression right = (AExpression)visit(ctx.noncondexpression(1)); final Operation operation;",
        "ins1PreCode":"public ANode visitBinary(BinaryContext ctx) { AExpression left = (AExpression)visit(ctx.expression(0)); AExpression right = (AExpression)visit(ctx.expression(1)); final Operation operation;",
        "ins2PreCode":"public ANode visitAssignment(AssignmentContext ctx) { AExpression lhs = (AExpression)visit(ctx.expression(0)); AExpression rhs = (AExpression)visit(ctx.expression(1)); ",
        "label":0
    },
    {
        "ins1CurCode":"  s1.remove(1.0); assertFalse(s1.equals(s2)); s2.remove(1.0); assertTrue(s2.equals(s1));",
        "ins1PreCode":"  s1.remove(new Double(1.0)); assertFalse(s1.equals(s2)); s2.remove(new Double(1.0)); assertTrue(s2.equals(s1));",
        "ins2PreCode":"  s1.remove(new Double(1.0)); assertFalse(s1.equals(s2)); s2.remove(new Double(1.0)); assertTrue(s2.equals(s1));",
        "label":1
    },
    {
        "ins1CurCode":"s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); XIntervalSeriesCollection c2 = CloneUtils.clone(c1); assertTrue(c1 != c2);",
        "ins1PreCode":"s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); XIntervalSeriesCollection c2 = (XIntervalSeriesCollection) c1.clone(); assertTrue(c1 != c2);",
        "ins2PreCode":"s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); YIntervalSeriesCollection c2 = (YIntervalSeriesCollection) c1.clone(); assertTrue(c1 != c2);",
        "label":1
    },
    {
        "ins1CurCode":"void unknownSettings() { final String MAPPER_CONFIG = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"",
        "ins1PreCode":"public void unknownSettings() { final String MAPPER_CONFIG = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"",
        "ins2PreCode":"public void unknownJavaTypeOnTypeHandler() { final String MAPPER_CONFIG = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"",
        "label":1
    },
    {
        "ins1CurCode":"SNIExtractor extractor = new SNIExtractor(netInBuffer);  while (extractor.getResult() == SNIResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer); extractor = new SNIExtractor(netInBuffer); }  String hostName = null; switch (extractor.getResult()) { case FOUND: hostName = extractor.getSNIValue(); break; case NOT_PRESENT:  break; case NEED_READ: sc.read(netInBuffer, socket, handshakeReadCompletionHandler); return 1; case UNDERFLOW:  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniDefault\")); } hostName = endpoint.getDefaultSSLHostConfigName(); break;",
        "ins1PreCode":"SNIExtractor extractor = new SNIExtractor(netInBuffer);  while (extractor.getResult() == SNIResult.UNDERFLOW) {   log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(netInBuffer.capacity() * 2)));  netInBuffer = ByteBufferUtils.expand(netInBuffer); sc.read(netInBuffer);",
        "ins2PreCode":"SNIExtractor extractor = new SNIExtractor(netInBuffer);  while (extractor.getResult() == SNIResult.UNDERFLOW) {   log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(netInBuffer.capacity() * 2)));  netInBuffer = ByteBufferUtils.expand(netInBuffer); sc.read(netInBuffer);",
        "label":1
    },
    {
        "ins1CurCode":"properties.put(\"spring.devtools.livereload.enabled\", false); this.context = initializeAndRun(Config.class, properties); assertThatExceptionOfType(NoSuchBeanDefinitionException.class) .isThrownBy(() -> this.context.getBean(OptionalLiveReloadServer.class));",
        "ins1PreCode":"properties.put(\"spring.devtools.livereload.enabled\", false); this.context = initializeAndRun(Config.class, properties); this.thrown.expect(NoSuchBeanDefinitionException.class); this.context.getBean(OptionalLiveReloadServer.class);",
        "ins2PreCode":"properties.put(\"spring.devtools.restart.enabled\", false); this.context = initializeAndRun(Config.class, properties); this.thrown.expect(NoSuchBeanDefinitionException.class); this.context.getBean(ClassPathFileSystemWatcher.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdgeV2(\"A\", \"A\", \"AA\"); mutableGraph.addEdgeV2(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);",
        "ins1PreCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdge(\"AA\", \"A\", \"A\"); mutableGraph.addEdge(\"AB\", \"A\", \"B\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);",
        "ins2PreCode":"public void edgesConnecting_undirected() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.undirected().build(); mutableGraph.addEdge(\"AA\", \"A\", \"A\"); mutableGraph.addEdge(\"AB\", \"A\", \"B\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);",
        "label":1
    },
    {
        "ins1CurCode":"public void setExcludePackageNames(String packages) { StringTokenizer tok = new StringTokenizer(packages, \",\"); while (tok.hasMoreTokens()) {",
        "ins1PreCode":"public void setExcludePackageNames(String src) { StringTokenizer tok = new StringTokenizer(src, \",\"); while (tok.hasMoreTokens()) {",
        "ins2PreCode":"public void setPackages(String src) { StringTokenizer tok = new StringTokenizer(src, \",\"); while (tok.hasMoreTokens()) { String p = tok.nextToken(); PackageName pn = new PackageName(); pn.setName(p); addPackage(pn); }",
        "label":0
    },
    {
        "ins1CurCode":"else { for (int i = 0; i < this.data.size(); i++) { XYDataItem item = this.data.get(i); if (item.getX().equals(x)) {",
        "ins1PreCode":"else { for (int i = 0; i < this.data.size(); i++) { XYDataItem item = (XYDataItem) this.data.get(i); if (item.getX().equals(x)) {",
        "ins2PreCode":"public int indexOf(Comparable x) { if (this.autoSort) { return Collections.binarySearch(this.data, new ComparableObjectItem( x, null)); } else { for (int i = 0; i < this.data.size(); i++) { ComparableObjectItem item = (ComparableObjectItem) this.data.get(i); if (item.getComparable().equals(x)) { return i; } } return -1; }",
        "label":0
    },
    {
        "ins1CurCode":"}  if (context.getName().equals(this.context.getName())) { writer.println(smClient.getString(\"managerServlet.noSelf\"));",
        "ins1PreCode":"}  if (context.getPath().equals(this.context.getPath())) { writer.println(smClient.getString(\"managerServlet.noSelf\"));",
        "ins2PreCode":"protected void start(PrintWriter writer, String path, StringManager smClient) {  if (debug >= 1) log(\"start: Starting web application at '\" + path + \"'\");  if ((path == null) || (!path.startsWith(\"/\") && path.equals(\"\"))) { writer.println(smClient.getString(\"managerServlet.invalidPath\", RequestUtil.filter(path))); return; } String displayPath = path; if( path.equals(\"/\") ) path = \"\";  try { Context context = (Context) host.findChild(path); if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", RequestUtil.filter(displayPath))); return; } context.start(); if (context.getAvailable()) writer.println(smClient.getString(\"managerServlet.started\", displayPath)); else writer.println(smClient.getString(\"managerServlet.startFailed\", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getServletContext().log(sm.getString(\"managerServlet.startFailed\", displayPath), t); writer.println(smClient.getString(\"managerServlet.startFailed\", displayPath)); writer.println(smClient.getString(\"managerServlet.exception\", t.toString())); } ",
        "label":0
    },
    {
        "ins1CurCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void fusedNoSync() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.SYNC);  Maybe.just(1).flattenAsFlowable(new Function<Integer, Iterable<Integer>>() { @Override public Iterable<Integer> apply(Integer v) throws Exception { return Arrays.asList(v, v + 1); } }) .subscribe(ts);  ts.assertFuseable() .assertFusionMode(QueueFuseable.NONE) .assertResult(1, 2); ;",
        "label":0
    },
    {
        "ins1CurCode":"public void testCopyNoRemove() { buildRule.executeTarget(\"copynoremove\"); String d = buildRule.getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsPresent(d); String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(buildRule.getFullLog().indexOf(\"Removing orphan file:\") == -1);",
        "ins1PreCode":"public void testCopyNoRemove() { executeTarget(\"copynoremove\"); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsPresent(d); String f = getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(getFullLog().indexOf(\"Removing orphan file:\") == -1);",
        "ins2PreCode":"public void testCopyNoRemoveSelectors() { executeTarget(\"copynoremove-selectors\"); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsPresent(d); String f = getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(getFullLog().indexOf(\"Removing orphan file:\") == -1);",
        "label":1
    },
    {
        "ins1CurCode":"Observable.just(source, source, source).concatMapEager((Function)Functions.identity(), 10, -99); } catch (IllegalArgumentException ex) { assertEquals(\"bufferSize > 0 required but it was -99\", ex.getMessage()); }",
        "ins1PreCode":"Observable.just(source, source, source).concatMapEager((Function)Functions.identity(), 10, -99); } catch (IllegalArgumentException ex) { assertEquals(\"prefetch > 0 required but it was -99\", ex.getMessage()); }",
        "ins2PreCode":"public void mappingBadCapacityHint() throws Exception { Flowable<Integer> source = Flowable.just(1); try { Flowable.just(source, source, source).concatMapEager((Function)Functions.identity(), 10, -99); } catch (IllegalArgumentException ex) { assertEquals(\"prefetch > 0 required but it was -99\", ex.getMessage()); } ",
        "label":0
    },
    {
        "ins1CurCode":"try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"SELECT s.*, sq.SQL_TEXT\\n\" + \"FROM V$SESSION s, V$SQL sq\\n\" + \"WHERE sq.ADDRESS(+) = s.SQL_ADDRESS AND s.TYPE = 'USER'\")) {",
        "ins1PreCode":"try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"SELECT s.*,sq.SQL_TEXT FROM V$SESSION s\\n\" + \"LEFT OUTER JOIN V$SQL sq ON sq.SQL_ID=s.SQL_ID\\n\" + \"WHERE s.TYPE='USER'\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) {",
        "ins2PreCode":"public Collection<PostgreSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>(); while (dbResult.next()) { sessions.add(new PostgreSession(dbResult)); } return sessions; } } } catch (SQLException e) { throw new DBException(e, session.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":"int e = 0; for (;;) { if (size > 1) { if (size > limit) {",
        "ins1PreCode":"int e = 0; for (;;) { if (next != null && size > 1) { if (size > limit) {",
        "ins2PreCode":"int e = 0; for (;;) { if (next != null && size > 1) { if (size > limit) {",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, entries.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(StandardField.JOURNAL)); assertEquals(Optional.of(\"Improving Urban Road Extraction in High-Resolution \" + \"Images Exploiting Directional Filtering, Perceptual \" + \"Grouping, and Simple Topological Concepts\"), entry.getField(StandardField.TITLE)); assertEquals(Optional.of(\"4\"), entry.getField(StandardField.VOLUME)); assertEquals(Optional.of(\"3\"), entry.getField(StandardField.NUMBER)); assertEquals(Optional.of(\"1545-598X\"), entry.getField(new UnknownField(\"SN\"))); assertEquals(Optional.of(\"387--391\"), entry.getField(StandardField.PAGES)); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(StandardField.AUTHOR)); assertEquals(Optional.of(\"2006\"), entry.getField(StandardField.YEAR)); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), entry.getField(StandardField.KEYWORDS)); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(StandardField.ABSTRACT));",
        "ins1PreCode":" assertEquals(1, entries.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(\"journal\")); assertEquals(Optional.of(\"Improving Urban Road Extraction in High-Resolution \" + \"Images Exploiting Directional Filtering, Perceptual \" + \"Grouping, and Simple Topological Concepts\"), entry.getField(\"title\")); assertEquals(Optional.of(\"4\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"3\"), entry.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), entry.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), entry.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(\"author\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), entry.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(\"abstract\"));",
        "ins2PreCode":" assertEquals(1, entries.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"Geoscience and Remote Sensing Letters, IEEE\"), entry.getField(\"journal\")); assertEquals( Optional.of( \"Improving Urban Road Extraction in High-Resolution Images Exploiting Directional Filtering, Perceptual Grouping, and Simple Topological Concepts\"), entry.getField(\"title\")); assertEquals(Optional.of(\"4\"), entry.getField(\"volume\")); assertEquals(Optional.of(\"3\"), entry.getField(\"number\")); assertEquals(Optional.of(\"1545-598X\"), entry.getField(\"SN\")); assertEquals(Optional.of(\"387--391\"), entry.getField(\"pages\")); assertEquals(Optional.of(\"Gamba, P. and Dell'Acqua, F. and Lisini, G.\"), entry.getField(\"author\")); assertEquals(Optional.of(\"2006\"), entry.getField(\"year\")); assertEquals(Optional.of(\"Perceptual grouping, street extraction, urban remote sensing\"), entry.getField(\"keywords\")); assertEquals(Optional.of(\"Lorem ipsum abstract\"), entry.getField(\"abstract\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void testIndexOf() { XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 2.0);",
        "ins1PreCode":"public void testIndexOf() { XIntervalSeries s1 = new XIntervalSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 2.0);",
        "ins2PreCode":"public void testIndexOf() { VectorSeries s1 = new VectorSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 2.0);",
        "label":1
    },
    {
        "ins1CurCode":" try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS))) { transport.start();",
        "ins1PreCode":" try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) { transport.start();",
        "ins2PreCode":"}  try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher)) { transport.start();",
        "label":0
    },
    {
        "ins1CurCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins1PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "label":1
    },
    {
        "ins1CurCode":" configuration.addMapper(MultipleReverseIncludePersonMapper.class); c.close(); ",
        "ins1PreCode":" configuration.addMapper(MultipleReverseIncludePersonMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":" configuration.addMapper(ReverseIncludePersonMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = poissonJavaVectorRDD(jsc, mean, m, n); JavaRDD<Vector> rdd2 = poissonJavaVectorRDD(jsc, mean, m, n, p); JavaRDD<Vector> rdd3 = poissonJavaVectorRDD(jsc, mean, m, n, p, seed); for (JavaRDD<Vector> rdd : Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "ins1PreCode":"int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = poissonJavaVectorRDD(sc, mean, m, n); JavaRDD<Vector> rdd2 = poissonJavaVectorRDD(sc, mean, m, n, p); JavaRDD<Vector> rdd3 = poissonJavaVectorRDD(sc, mean, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "ins2PreCode":"int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = exponentialJavaVectorRDD(sc, mean, m, n); JavaRDD<Vector> rdd2 = exponentialJavaVectorRDD(sc, mean, m, n, p); JavaRDD<Vector> rdd3 = exponentialJavaVectorRDD(sc, mean, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count());",
        "label":1
    },
    {
        "ins1CurCode":"  TestMap.Builder b1 = TestMap.newBuilder() .putInt32ToInt32Field(1, 2) .putInt32ToInt32Field(3, 4) .putInt32ToInt32Field(5, 6); TestMap m1 = b1.build();  TestMap.Builder b2 = TestMap.newBuilder() .putInt32ToInt32Field(5, 6) .putInt32ToInt32Field(1, 2) .putInt32ToInt32Field(3, 4); TestMap m2 = b2.build();  assertEquals(m1, m2); assertEquals(m1.hashCode(), m2.hashCode());   b2.putInt32ToInt32Field(1, 0); m2 = b2.build();",
        "ins1PreCode":"  TestMap.Builder b1 = TestMap.newBuilder(); b1.getMutableInt32ToInt32Field().put(1, 2); b1.getMutableInt32ToInt32Field().put(3, 4); b1.getMutableInt32ToInt32Field().put(5, 6); TestMap m1 = b1.build();  TestMap.Builder b2 = TestMap.newBuilder(); b2.getMutableInt32ToInt32Field().put(5, 6); b2.getMutableInt32ToInt32Field().put(1, 2); b2.getMutableInt32ToInt32Field().put(3, 4); TestMap m2 = b2.build();  assertEquals(m1, m2); assertEquals(m1.hashCode(), m2.hashCode());   b2.getMutableInt32ToInt32Field().put(1, 0); m2 = b2.build();",
        "ins2PreCode":"  TestMap.Builder b1 = TestMap.newBuilder(); b1.getMutableInt32ToInt32Field().put(1, 2); b1.getMutableInt32ToInt32Field().put(3, 4); b1.getMutableInt32ToInt32Field().put(5, 6); TestMap m1 = b1.build();  TestMap.Builder b2 = TestMap.newBuilder(); b2.getMutableInt32ToInt32Field().put(5, 6); b2.getMutableInt32ToInt32Field().put(1, 2); b2.getMutableInt32ToInt32Field().put(3, 4); TestMap m2 = b2.build();  assertEquals(m1, m2); assertEquals(m1.hashCode(), m2.hashCode());   b2.getMutableInt32ToInt32Field().put(1, 0); m2 = b2.build(); assertFalse(m1.equals(m2));      b2.getMutableInt32ToInt32Field().remove(1); m2 = b2.build();",
        "label":1
    },
    {
        "ins1CurCode":" WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class,",
        "ins1PreCode":" WebSocketContainer wsContainer = ContainerProvider.createClientContainer(); wsContainer.connectToServer(TesterEndpoint.class,",
        "ins2PreCode":" WebSocketContainer wsContainer = ContainerProvider.createClientContainer(); wsContainer.connectToServer(TesterEndpoint.class,",
        "label":1
    },
    {
        "ins1CurCode":"for (int i = 0; i < 10; i++) { Flowable<Integer> merge = Flowable.merge(f, f, f); TestSubscriber<Integer> ts = new TestSubscriber<>(); merge.subscribe(ts);",
        "ins1PreCode":"for (int i = 0; i < 10; i++) { Flowable<Integer> merge = Flowable.merge(f, f, f); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); merge.subscribe(ts);",
        "ins2PreCode":"for (int i = 0; i < 10; i++) { Flowable<Integer> merge = Flowable.merge(f.onBackpressureBuffer(), f.onBackpressureBuffer(), f.onBackpressureBuffer()); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); merge.subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1PreCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins2PreCode":"original.setEmail(\"new@email.com\"); original.setBio(null); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthorIfNecessary\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "label":1
    },
    {
        "ins1CurCode":"byte[] destination = new byte[destinationOffset + length]; int sourceOffset = 213; testString.copyTo(destination, sourceOffset, destinationOffset, length); boolean stillEqual = true;",
        "ins1PreCode":"byte[] destination = new byte[destinationOffset + length]; int sourceOffset = 213; TEST_STRING.copyTo(destination, sourceOffset, destinationOffset, length); boolean stillEqual = true;",
        "ins2PreCode":"public void testCopyTo_ByteArrayOffsetLength() { int destinationOffset = 50; int length = 100; byte[] destination = new byte[destinationOffset + length]; int sourceOffset = 213; stringUnderTest.copyTo(destination, sourceOffset, destinationOffset, length); boolean stillEqual = true; for (int i = 0; stillEqual && i < length; ++i) { stillEqual = referenceBytes[i + sourceOffset] == destination[i + destinationOffset]; } assertTrue(classUnderTest + \".copyTo(4 arg) must give the expected bytes\", stillEqual);",
        "label":0
    },
    {
        "ins1CurCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1);  TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(callOnce, okToContinue, odds, even);",
        "ins1PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(callOnce, okToContinue, odds, even);",
        "ins2PreCode":"final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); @SuppressWarnings(\"unchecked\") TestObservable<Flowable<String>> observableOfObservables = new TestObservable<>(callOnce, okToContinue, odds, even);",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); System.out.println(\"TestObservable subscribed to ...\");",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestObservable subscribed to ...\");",
        "ins2PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestSingleThreadedObservable subscribed to ...\");",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> concatArray(@NonNull Publisher<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return empty(); } else if (sources.length == 1) { return fromPublisher(sources[0]); } return RxJavaPlugins.onAssembly(new FlowableConcatArray<>(sources, false));",
        "ins1PreCode":"public static <T> Flowable<T> concatArray(Publisher<? extends T>... sources) { if (sources.length == 0) { return empty(); } else if (sources.length == 1) { return fromPublisher(sources[0]); } return RxJavaPlugins.onAssembly(new FlowableConcatArray<T>(sources, false));",
        "ins2PreCode":"public static <T> Flowable<T> concatArrayDelayError(Publisher<? extends T>... sources) { if (sources.length == 0) { return empty(); } else if (sources.length == 1) { return fromPublisher(sources[0]); } return RxJavaPlugins.onAssembly(new FlowableConcatArray<T>(sources, true));",
        "label":1
    },
    {
        "ins1CurCode":"public void onStartRequestsAreAdditive() { final List<Integer> list = new ArrayList<>(); Flowable.just(1, 2, 3, 4, 5)",
        "ins1PreCode":"public void onStartRequestsAreAdditive() { final List<Integer> list = new ArrayList<Integer>(); Flowable.just(1, 2, 3, 4, 5)",
        "ins2PreCode":"public void onStartRequestsAreAdditiveAndOverflowBecomesMaxValue() { final List<Integer> list = new ArrayList<Integer>(); Flowable.just(1, 2, 3, 4, 5).subscribe(new DefaultSubscriber<Integer>() {",
        "label":1
    },
    {
        "ins1CurCode":"return; }  List<Name> newdomains = new ArrayList<>(domains.length); for (String domain : domains) { newdomains.add(Name.fromString(domain, Name.root)); }  defaultSearchPath = newdomains;",
        "ins1PreCode":"return; } Name[] newdomains = new Name[domains.length]; for (int i = 0; i < domains.length; i++) { newdomains[i] = Name.fromString(domains[i], Name.root); }",
        "ins2PreCode":"return; } Name[] newdomains = new Name[domains.length]; for (int i = 0; i < domains.length; i++) { newdomains[i] = Name.fromString(domains[i], Name.root); }",
        "label":1
    },
    {
        "ins1CurCode":"void shouldUpdateUserSelective() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldUpdateUserSelective() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = new User(); user.setId(999); user.setName(\"MyBatis\"); mapper.insert(user);  user.setName(null); mapper.updateSelective(user);  User loadedUser = mapper.getUser(999); assertEquals(\"MyBatis\", loadedUser.getName());  } finally { sqlSession.close(); }",
        "ins2PreCode":"void shouldInsertUser() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = new User(); user.setId(999); user.setName(\"MyBatis\"); mapper.insert(user);  User loadedUser = mapper.getUser(999); assertEquals(\"MyBatis\", loadedUser.getName()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsObservable() { try { final List<Throwable> list = new CopyOnWriteArrayList<>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "ins1PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsObservable() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "ins2PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissions() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "label":1
    },
    {
        "ins1CurCode":"public void draggedOnTopOfGroupAddsBeforeIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, StandardField.KEYWORDS, \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "ins1PreCode":"public void draggedOnTopOfGroupAddsBeforeIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "ins2PreCode":"public void draggedOnBottomOfGroupAddsAfterIt() throws Exception { GroupNodeViewModel rootViewModel = getViewModelForGroup(new WordKeywordGroup(\"root\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true)); WordKeywordGroup groupA = new WordKeywordGroup(\"A\", GroupHierarchyType.INCLUDING, \"keywords\", \"A\", true, ',', true); WordKeywordGroup groupB = new WordKeywordGroup(\"B\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B\", true, ',', true); WordKeywordGroup groupC = new WordKeywordGroup(\"C\", GroupHierarchyType.INCLUDING, \"keywords\", \"A > B > B1\", true, ',', true); GroupNodeViewModel groupAViewModel = getViewModelForGroup(rootViewModel.addSubgroup(groupA));",
        "label":1
    },
    {
        "ins1CurCode":"private static JFreeChart createWaterfallChart() { Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart(\"Waterfall Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true); ",
        "ins1PreCode":"private static JFreeChart createWaterfallChart() { Number[][] data = new Integer[][] {{new Integer(-3), new Integer(-2)}, {new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createWaterfallChart( \"Waterfall Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true ); ",
        "ins2PreCode":"private static JFreeChart createChart() { Number[][] data = new Integer[][] {{new Integer(-3), new Integer(-2)}, {new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; ",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"target_field\", \"new_field\"); try { factory.create(null, null, null, config); fail(\"factory create should have failed\");",
        "ins1PreCode":"config.put(\"target_field\", \"new_field\"); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "ins2PreCode":"config.put(\"field\", \"old_field\"); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "label":1
    },
    {
        "ins1CurCode":"public void timedAndCount() { final List<String> list = new ArrayList<>(); final List<List<String>> lists = new ArrayList<>(); ",
        "ins1PreCode":"public void timedAndCount() { final List<String> list = new ArrayList<String>(); final List<List<String>> lists = new ArrayList<List<String>>(); ",
        "ins2PreCode":"public void timedAndCount() { final List<String> list = new ArrayList<String>(); final List<List<String>> lists = new ArrayList<List<String>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); observer.onComplete();",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "ins2PreCode":"public void seedBadSource() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onComplete(); subscriber.onNext(1); subscriber.onError(new TestException()); subscriber.onComplete(); } } .reduce(0, new BiFunction<Integer, Integer, Integer>() { @Override public Integer apply(Integer a, Integer b) throws Exception { return a; } }) .test() .assertResult(0);  TestHelper.assertUndeliverable(errors, 0, TestException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(range.getLowerBound() <= 10, \"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound()); assertTrue(range.getUpperBound() >= 30, \"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound());",
        "ins1PreCode":"ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "ins2PreCode":"ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "label":1
    },
    {
        "ins1CurCode":"} } for (XYDataset<S> dataset : this.datasets.values()) { if (dataset != null) {",
        "ins1PreCode":"} } for (XYDataset dataset : this.datasets.values()) { if (dataset != null) {",
        "ins2PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {  stream.defaultReadObject(); this.domainGridlineStroke = SerialUtils.readStroke(stream); this.domainGridlinePaint = SerialUtils.readPaint(stream); this.rangeGridlineStroke = SerialUtils.readStroke(stream); this.rangeGridlinePaint = SerialUtils.readPaint(stream); this.rangeCrosshairStroke = SerialUtils.readStroke(stream); this.rangeCrosshairPaint = SerialUtils.readPaint(stream); this.domainCrosshairStroke = SerialUtils.readStroke(stream); this.domainCrosshairPaint = SerialUtils.readPaint(stream); this.rangeMinorGridlineStroke = SerialUtils.readStroke(stream); this.rangeMinorGridlinePaint = SerialUtils.readPaint(stream); this.rangeZeroBaselineStroke = SerialUtils.readStroke(stream); this.rangeZeroBaselinePaint = SerialUtils.readPaint(stream);  for (CategoryAxis xAxis : this.domainAxes.values()) { if (xAxis != null) { xAxis.setPlot(this); xAxis.addChangeListener(this); } } for (ValueAxis yAxis : this.rangeAxes.values()) { if (yAxis != null) { yAxis.setPlot(this); yAxis.addChangeListener(this); } } for (CategoryDataset<R, C> dataset : this.datasets.values()) { if (dataset != null) { dataset.addChangeListener(this); } } for (CategoryItemRenderer renderer : this.renderers.values()) { if (renderer != null) { renderer.addChangeListener(this); } } ",
        "label":0
    },
    {
        "ins1CurCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper, boolean tillTheEnd, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch, boolean tillTheEnd) { ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins2PreCode":"public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));",
        "label":0
    },
    {
        "ins1CurCode":"void setUp() throws Exception { ",
        "ins1PreCode":"public void setUp() throws Exception { ",
        "ins2PreCode":"public static void initDatabase() throws Exception { try (Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/enumtypehandler_on_annotation/mybatis-config.xml\")) {",
        "label":1
    },
    {
        "ins1CurCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.log(Level.FINE, \"toDoItemsChanged\"); List<ToDoItem> items = tde.getToDoItemList();",
        "ins1PreCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.debug(\"toDoItemsChanged\"); List<ToDoItem> items = tde.getToDoItemList();",
        "ins2PreCode":"public void toDoItemsAdded(ToDoListEvent tde) { LOG.debug(\"toDoItemAdded\"); List<ToDoItem> items = tde.getToDoItemList();",
        "label":1
    },
    {
        "ins1CurCode":"Observable<Long> o = Observable.unsafeCreate(so).retry(5);  AsyncObserver<Long> async = new AsyncObserver<>(observer); ",
        "ins1PreCode":"Observable<Long> o = Observable.unsafeCreate(so).retry(5);  AsyncObserver<Long> async = new AsyncObserver<Long>(observer); ",
        "ins2PreCode":"Observable<Long> o = Observable.unsafeCreate(so).timeout(80, TimeUnit.MILLISECONDS).retry(5);  AsyncObserver<Long> async = new AsyncObserver<Long>(observer); ",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "ins1PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins2PreCode":"@Test public void onlineNodeShouldFailIfNodeDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Computer.CONNECT, Jenkins.READ) .invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); ",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldExecuteBoundSelectOneBlogStatementWithConstructor() { try (SqlSession session = sqlSessionFactory.openSession()) { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class);",
        "ins1PreCode":"public void shouldExecuteBoundSelectOneBlogStatementWithConstructor() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); Blog blog = mapper.selectBlogUsingConstructor(1); assertEquals(1, blog.getId()); assertEquals(\"Jim Business\", blog.getTitle()); assertNotNull(\"author should not be null\", blog.getAuthor()); List<Post> posts = blog.getPosts(); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldExecuteBoundSelectOneBlogStatementWithConstructorUsingXMLConfig() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); Blog blog = mapper.selectBlogByIdUsingConstructor(1); assertEquals(1, blog.getId()); assertEquals(\"Jim Business\", blog.getTitle()); assertNotNull(\"author should not be null\", blog.getAuthor()); List<Post> posts = blog.getPosts(); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).apply(springSecurity()).addFilter(filter) .build(); mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + \"/restart\").header(DEFAULT_SECRET_HEADER_NAME,",
        "ins1PreCode":"this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) .addFilter(filter).build(); mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + \"/restart\").header(DEFAULT_SECRET_HEADER_NAME,",
        "ins2PreCode":"\"server.servlet.context-path:/test\", \"spring.devtools.remote.context-path:/custom\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) .addFilter(filter).build(); mockMvc.perform(",
        "label":1
    },
    {
        "ins1CurCode":"  LOG.log(Level.FINE, \"buildModelList threw exception for target \"+ getTarget() + \": \", exception); } finally {",
        "ins1PreCode":"  LOG.debug(\"buildModelList threw exception for target \" + getTarget() + \": \" + exception); } finally {",
        "ins2PreCode":"  LOG.debug(\"buildModelList threw exception for target \" + getTarget() + \": \" + exception); } finally {",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> merge( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2,",
        "ins1PreCode":"public static <T> Flowable<T> merge( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2,",
        "ins2PreCode":"public static <T> Flowable<T> mergeDelayError( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2,",
        "label":1
    },
    {
        "ins1CurCode":"public final PostfixContext postfix() throws RecognitionException { PostfixContext _localctx = new PostfixContext(_ctx, getState()); enterRule(_localctx, 50, RULE_postfix); try { setState(420); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,38,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(417); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(418); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(419); braceaccess();",
        "ins1PreCode":"public final PostfixContext postfix() throws RecognitionException { PostfixContext _localctx = new PostfixContext(_ctx, getState()); enterRule(_localctx, 40, RULE_postfix); try { setState(359); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(356); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(357); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(358); braceaccess();",
        "ins2PreCode":"public final PostdotContext postdot() throws RecognitionException { PostdotContext _localctx = new PostdotContext(_ctx, getState()); enterRule(_localctx, 42, RULE_postdot); try { setState(363); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,31,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(361); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(362); fieldaccess();",
        "label":0
    },
    {
        "ins1CurCode":"public void cancelAfterOnComplete() { final List<Object> list = new ArrayList<>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "ins1PreCode":"public void cancelAfterOnComplete() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "ins2PreCode":"public void cancelAfterOnError() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "label":1
    },
    {
        "ins1CurCode":"boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge); }",
        "ins1PreCode":"boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrNull(node, otherNode) != null).isEqualTo(hasEdge); }",
        "ins2PreCode":"boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrNull(node, otherNode) != null).isEqualTo(hasEdge); }",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); observer.onComplete();",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "label":1
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[43] = jj_gen; break label_16; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[44] = jj_gen; ;",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_14: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_14; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[37] = jj_gen; ;",
        "ins2PreCode":"case IDENTIFIER: MapEntry(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[38] = jj_gen; break label_15; } jj_consume_token(COMMA); MapEntry(); } break; default: jj_la1[39] = jj_gen; ; } jj_consume_token(RCURL); } catch (Throwable jjte000) {",
        "label":1
    },
    {
        "ins1CurCode":"public void setPackagenames(final String packages) { final StringTokenizer tok = new StringTokenizer(packages, \",\"); while (tok.hasMoreTokens()) { final String p = tok.nextToken(); final PackageName pn = new PackageName(); pn.setName(p);",
        "ins1PreCode":"public void setPackagenames(String packages) { StringTokenizer tok = new StringTokenizer(packages, \",\"); while (tok.hasMoreTokens()) { String p = tok.nextToken(); PackageName pn = new PackageName(); pn.setName(p);",
        "ins2PreCode":"public void setExcludePackageNames(String packages) { StringTokenizer tok = new StringTokenizer(packages, \",\"); while (tok.hasMoreTokens()) { String p = tok.nextToken(); PackageName pn = new PackageName(); pn.setName(p);",
        "label":1
    },
    {
        "ins1CurCode":"ControllerEndpointsSupplier controllerEndpointsSupplier) { CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, null, Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(",
        "ins1PreCode":"ControllerEndpointsSupplier controllerEndpointsSupplier) { CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, PathMapper.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(",
        "ins2PreCode":"ControllerEndpointsSupplier controllerEndpointsSupplier) { CloudFoundryWebEndpointDiscoverer discoverer = new CloudFoundryWebEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, PathMapper.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor(",
        "label":1
    },
    {
        "ins1CurCode":"void shouldInsertNewAuthor() throws Exception { ",
        "ins1PreCode":"public void shouldInsertNewAuthor() throws Exception { ",
        "ins2PreCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception { ",
        "label":1
    },
    {
        "ins1CurCode":"String fooReference1 = new String(\"foo\"); String fooReference2 = new String(\"foo\"); assertThat(fooReference1).isNotSameInstanceAs(fooReference2); ",
        "ins1PreCode":"String fooReference1 = new String(\"foo\"); String fooReference2 = new String(\"foo\"); assertThat(fooReference1).isNotSameAs(fooReference2); ",
        "ins2PreCode":"String fooReference1 = new String(\"foo\"); String fooReference2 = new String(\"foo\"); assertThat(fooReference1).isNotSameAs(fooReference2); ",
        "label":1
    },
    {
        "ins1CurCode":"} line = headFilter(line); if (eof) { return -1;",
        "ins1PreCode":"} line = headFilter(line); linePos = 0; }",
        "ins2PreCode":"public int read() throws IOException { if (!getInitialized()) { initialize(); setInitialized(true); }  while (line == null || line.length() == 0) { line = lineTokenizer.getToken(in); line = tailFilter(line); if (line == null) { return -1; } linePos = 0; }  int ch = line.charAt(linePos); linePos++; if (linePos == line.length()) { line = null; } return ch;",
        "label":0
    },
    {
        "ins1CurCode":"void testMultipleDiscriminator() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testMultipleDiscriminator() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testMultipleDiscriminator2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":".retry(retry5);  FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<>(subscriber); ",
        "ins1PreCode":".retry(retry5);  FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber); ",
        "ins2PreCode":".retry(retry5);  ObservableRetryTest.AsyncObserver<Long> async = new ObservableRetryTest.AsyncObserver<Long>(observer); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testCalculateColumnTotal2() { DefaultKeyedValues2D table = new DefaultKeyedValues2D(); table.addValue(1.0, \"R0\", \"C0\"); table.addValue(2.0, \"R0\", \"C1\"); table.addValue(3.0, \"R1\", \"C0\"); table.addValue(4.0, \"R1\", \"C1\"); assertEquals(4.0, DataUtils.calculateColumnTotal(table, 0,",
        "ins1PreCode":"public void testCalculateColumnTotal2() { DefaultKeyedValues2D table = new DefaultKeyedValues2D(); table.addValue(new Double(1.0), \"R0\", \"C0\"); table.addValue(new Double(2.0), \"R0\", \"C1\"); table.addValue(new Double(3.0), \"R1\", \"C0\"); table.addValue(new Double(4.0), \"R1\", \"C1\"); assertEquals(4.0, DataUtils.calculateColumnTotal(table, 0,",
        "ins2PreCode":"public void testCalculateRowTotal2() { DefaultKeyedValues2D table = new DefaultKeyedValues2D(); table.addValue(new Double(1.0), \"R0\", \"C0\"); table.addValue(new Double(2.0), \"R0\", \"C1\"); table.addValue(new Double(3.0), \"R1\", \"C0\"); table.addValue(new Double(4.0), \"R1\", \"C1\"); assertEquals(3.0, DataUtils.calculateRowTotal(table, 0,",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetMinY2() { TimeSeries<String> ts = new TimeSeries<>(\"Time Series\"); assertTrue(Double.isNaN(ts.getMinY()));",
        "ins1PreCode":"public void testGetMinY2() { TimeSeries ts = new TimeSeries(\"Time Series\"); assertTrue(Double.isNaN(ts.getMinY()));",
        "ins2PreCode":"public void testGetMaxY2() { TimeSeries ts = new TimeSeries(\"Time Series\"); assertTrue(Double.isNaN(ts.getMaxY()));",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldApplyHashMapTypeHandler() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldApplyHashMapTypeHandler() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<String, String>(); map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandler(map); Assert.assertNotNull(user); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldApplyHashMapTypeHandlerXml() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<String, String>(); map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandlerXml(map); Assert.assertNotNull(user); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"field.getOptions().getExtension(UnittestCustomOptions.fieldOpt1));  OneofDescriptor oneof = descriptor.getOneofs().get(0); assertNotNull(oneof);  assertTrue( oneof.getOptions().hasExtension(UnittestCustomOptions.oneofOpt1)); assertEquals(Integer.valueOf(-99), oneof.getOptions().getExtension(UnittestCustomOptions.oneofOpt1)); ",
        "ins1PreCode":"field.getOptions().getExtension(UnittestCustomOptions.fieldOpt1));  EnumDescriptor enumType = UnittestCustomOptions.TestMessageWithCustomOptions.AnEnum.getDescriptor();  assertTrue( enumType.getOptions().hasExtension(UnittestCustomOptions.enumOpt1)); assertEquals(Integer.valueOf(-789), enumType.getOptions().getExtension(UnittestCustomOptions.enumOpt1)); ",
        "ins2PreCode":"public void testCustomOptions() throws Exception { Descriptor descriptor = UnittestCustomOptions.TestMessageWithCustomOptions.getDescriptor();  assertTrue( descriptor.getOptions().hasExtension(UnittestCustomOptions.messageOpt1)); assertEquals(Integer.valueOf(-56), descriptor.getOptions().getExtension(UnittestCustomOptions.messageOpt1));  FieldDescriptor field = descriptor.findFieldByName(\"field1\"); assertNotNull(field);  assertTrue( field.getOptions().hasExtension(UnittestCustomOptions.fieldOpt1)); assertEquals(Long.valueOf(8765432109L), field.getOptions().getExtension(UnittestCustomOptions.fieldOpt1));  EnumDescriptor enumType = UnittestCustomOptions.TestMessageWithCustomOptions.AnEnum.getDescriptor();  assertTrue( enumType.getOptions().hasExtension(UnittestCustomOptions.enumOpt1)); assertEquals(Integer.valueOf(-789), enumType.getOptions().getExtension(UnittestCustomOptions.enumOpt1));  ServiceDescriptor service = UnittestCustomOptions.TestServiceWithCustomOptions.getDescriptor();  assertTrue( service.getOptions().hasExtension(UnittestCustomOptions.serviceOpt1)); assertEquals(Long.valueOf(-9876543210L), service.getOptions().getExtension(UnittestCustomOptions.serviceOpt1));  MethodDescriptor method = service.findMethodByName(\"Foo\"); assertNotNull(method);  assertTrue( method.getOptions().hasExtension(UnittestCustomOptions.methodOpt1)); assertEquals(UnittestCustomOptions.MethodOpt1.METHODOPT1_VAL2, method.getOptions().getExtension(UnittestCustomOptions.methodOpt1));",
        "label":0
    },
    {
        "ins1CurCode":"wsContainer.connectToServer(TesterEndpoint.class, new DefaultClientConfiguration(), new URI(\"ftp://localhost:\" + getPort() + EchoConfig.PATH_ASYNC));",
        "ins1PreCode":"wsContainer.connectToServer(TesterEndpoint.class, new DefaultClientConfiguration(), new URI(\"ftp://localhost:\" + getPort() + EchoConfig.PATH));",
        "ins2PreCode":"wsContainer.connectToServer(TesterEndpoint.class, new DefaultClientConfiguration(), new URI(\"http://\" + EchoConfig.PATH));",
        "label":1
    },
    {
        "ins1CurCode":"public void setUp() { spark = SparkSession.builder() .master(\"local\") .appName(\"JavaLogisticRegressionSuite\") .getOrCreate(); jsc = new JavaSparkContext(spark.sparkContext());  List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2); dataset = spark.createDataFrame(datasetRDD, LabeledPoint.class); dataset.registerTempTable(\"dataset\");",
        "ins1PreCode":"public void setUp() { jsc = new JavaSparkContext(\"local\", \"JavaLogisticRegressionSuite\"); jsql = new SQLContext(jsc); List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2); dataset = jsql.createDataFrame(datasetRDD, LabeledPoint.class); dataset.registerTempTable(\"dataset\");",
        "ins2PreCode":"public void setUp() { jsc = new JavaSparkContext(\"local\", \"JavaLinearRegressionSuite\"); jsql = new SQLContext(jsc); List<LabeledPoint> points = generateLogisticInputAsList(1.0, 1.0, 100, 42); datasetRDD = jsc.parallelize(points, 2); dataset = jsql.createDataFrame(datasetRDD, LabeledPoint.class); dataset.registerTempTable(\"dataset\");",
        "label":1
    },
    {
        "ins1CurCode":"void validateConfiguration() throws SQLException { assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2);",
        "ins1PreCode":"public void validateConfiguration() throws SQLException { assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2);",
        "ins2PreCode":"public void validateConfiguration() throws SQLException { assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2);",
        "label":1
    },
    {
        "ins1CurCode":"ClientHttpRequestFactory requestFactory = this.builder .requestFactory(HttpComponentsClientHttpRequestFactory.class) .setConnectTimeout(Duration.ofMillis(1234)).build().getRequestFactory(); assertThat(((RequestConfig) ReflectionTestUtils.getField(requestFactory,",
        "ins1PreCode":"ClientHttpRequestFactory requestFactory = this.builder .requestFactory(HttpComponentsClientHttpRequestFactory.class) .setConnectTimeout(1234).build().getRequestFactory(); assertThat(((RequestConfig) ReflectionTestUtils.getField(requestFactory,",
        "ins2PreCode":"ClientHttpRequestFactory requestFactory = this.builder .requestFactory(HttpComponentsClientHttpRequestFactory.class) .setReadTimeout(1234).build().getRequestFactory(); assertThat(((RequestConfig) ReflectionTestUtils.getField(requestFactory,",
        "label":1
    },
    {
        "ins1CurCode":"PublishSubject<Integer> ps3 = PublishSubject.create();  TestObserver<Integer> to = Observable.concatArrayEagerDelayError(2, 2, ps1, ps2, ps3) .test();",
        "ins1PreCode":"PublishSubject<Integer> ps3 = PublishSubject.create();  @SuppressWarnings(\"unchecked\") TestObserver<Integer> to = Observable.concatArrayEagerDelayError(2, 2, ps1, ps2, ps3)",
        "ins2PreCode":"PublishSubject<Integer> ps3 = PublishSubject.create();  @SuppressWarnings(\"unchecked\") TestObserver<Integer> to = Observable.concatArrayEagerDelayError(2, 2, ps1, ps2, ps3)",
        "label":1
    },
    {
        "ins1CurCode":"public void interruptTerminalEventAwait() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void interruptTerminalEventAwait() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void interruptTerminalEventAwaitTimed() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public static void main(String[] args) throws Exception { int size = 43800; if (args.length > 0 ) { try { size = Integer.parseInt(args[0]); } catch (Exception e){  } } XByteBuffer xbuf = new XByteBuffer(43800,true); try (ServerSocket srvSocket = new ServerSocket(9999)) { System.out.println(\"Listening on 9999\"); Socket socket = srvSocket.accept(); socket.setReceiveBufferSize(size); InputStream in = socket.getInputStream(); Thread t = new Thread() { @Override public void run() { while ( true ) { try { Thread.sleep(1000); printStats(start, mb, count, df, total); }catch ( Exception x ) {  } } } }; t.setDaemon(true); t.start();  while ( true ) { if ( first ) { first = false; start = System.currentTimeMillis(); } int len = in.read(buf); if ( len == -1 ) { printStats(start, mb, count, df, total); System.exit(1); } xbuf.append(buf,0,len); if ( bytes.intValue() != len ) { bytes = new BigDecimal((double)len); }",
        "ins1PreCode":"public static void main(String[] args) throws Exception { int size = 43800; if (args.length > 0 ) try {size=Integer.parseInt(args[0]);}catch(Exception x){  } XByteBuffer xbuf = new XByteBuffer(43800,true); ServerSocket srvSocket = new ServerSocket(9999); System.out.println(\"Listening on 9999\"); Socket socket = srvSocket.accept(); socket.setReceiveBufferSize(size); InputStream in = socket.getInputStream(); Thread t = new Thread() { @Override public void run() { while ( true ) { try { Thread.sleep(1000); printStats(start, mb, count, df, total); }catch ( Exception x ) {  } } } }; t.setDaemon(true); t.start();  while ( true ) { if ( first ) { first = false; start = System.currentTimeMillis();} int len = in.read(buf); if ( len == -1 ) { printStats(start, mb, count, df, total); System.exit(1); } xbuf.append(buf,0,len); if ( bytes.intValue() != len ) bytes = new BigDecimal((double)len); total = total.add(bytes);",
        "ins2PreCode":"if (args.length > 0 ) try {size=Integer.parseInt(args[0]);}catch(Exception x){  }  ServerSocket srvSocket = new ServerSocket(9999); System.out.println(\"Listening on 9999\"); Socket socket = srvSocket.accept(); socket.setReceiveBufferSize(size); InputStream in = socket.getInputStream(); MyDataReader reader = new MyDataReader(50000); Thread t = new Thread() { @Override public void run() { while ( true ) { try { Thread.sleep(1000); printStats(start, mb, count, df, total); }catch ( Exception x ) {  } } } }; t.setDaemon(true); t.start();  while ( true ) { if ( first ) { first = false; start = System.currentTimeMillis();} int len = in.read(buf); if ( len == -1 ) { printStats(start, mb, count, df, total); System.exit(1); } count += reader.append(buf,0,len);  if ( bytes.intValue() != len ) bytes = new BigDecimal((double)len); total = total.add(bytes);",
        "label":0
    },
    {
        "ins1CurCode":"T next; try { next = Objects.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\"); } catch (Throwable ex) {",
        "ins1PreCode":"T next; try { next = ObjectHelper.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\"); } catch (Throwable ex) {",
        "ins2PreCode":"T next; try { next = ObjectHelper.requireNonNull(iterator.next(), \"The Stream's Iterator returned a null value\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isSameAs(metadataReader2); verify(factory, times(1)).createMetadataReader(any(Resource.class));",
        "ins1PreCode":"MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isSameAs(metadataReader2); verify(factory, times(1)).createMetadataReader((Resource) any());",
        "ins2PreCode":"MetadataReader metadataReader2 = factory.getMetadataReader(getClass().getName()); assertThat(metadataReader1).isNotEqualTo(sameInstance(metadataReader2)); verify(factory, times(2)).createMetadataReader((Resource) any());",
        "label":1
    },
    {
        "ins1CurCode":"public void onError(Throwable e) { ExceptionHelper.nullCheck(e, \"onError called with a null Throwable.\"); if (once.compareAndSet(false, true)) {",
        "ins1PreCode":"public void onError(Throwable e) { ObjectHelper.requireNonNull(e, \"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (once.compareAndSet(false, true)) {",
        "ins2PreCode":"public void onError(Throwable e) { ObjectHelper.requireNonNull(e, \"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (once.compareAndSet(false, true)) {",
        "label":1
    },
    {
        "ins1CurCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"byte o = 0; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"byte o = 0; ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"byte o = 0; ArrayList b = (ArrayList)o;\"));",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"byte o = 0; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"byte o = Byte.valueOf((byte)0); ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"byte o = Byte.valueOf((byte)0); ArrayList b = (ArrayList)o;\"));",
        "ins2PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"short o = 0; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"short o = Byte.valueOf((short)0); ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"short o = Byte.valueOf((short)0); ArrayList b = (ArrayList)o;\"));",
        "label":1
    },
    {
        "ins1CurCode":"Observer<? super Integer> observer) { assertFalse(((Disposable)observer).isDisposed()); observer.onSubscribe(Disposable.empty()); sub[count++] = observer;",
        "ins1PreCode":"Observer<? super Integer> observer) { assertFalse(((Disposable)observer).isDisposed()); observer.onSubscribe(Disposables.empty()); sub[count++] = observer;",
        "ins2PreCode":"Observer<? super Integer> observer) { assertFalse(((Disposable)observer).isDisposed()); observer.onSubscribe(Disposables.empty()); sub[count++] = observer;",
        "label":1
    },
    {
        "ins1CurCode":"public void testPoolThreads10Connections10ValidateFair() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "ins1PreCode":"public void testPoolThreads10Connections10ValidateFair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testDBCPThreads20Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":"Publisher<B> open, Function<? super B, ? extends Publisher<V>> closingIndicator, int bufferSize) { this.downstream = actual; this.queue = new MpscLinkedQueue<>(); this.open = open; this.closingIndicator = closingIndicator; this.bufferSize = bufferSize; this.resources = new CompositeDisposable(); this.windows = new ArrayList<>(); this.windowCount = new AtomicLong(1L); this.downstreamCancelled = new AtomicBoolean(); this.error = new AtomicThrowable(); this.startSubscriber = new WindowStartSubscriber<>(this); this.requested = new AtomicLong();",
        "ins1PreCode":"Publisher<B> open, Function<? super B, ? extends Publisher<V>> closingIndicator, int bufferSize) { this.downstream = actual; this.queue = new MpscLinkedQueue<Object>(); this.open = open; this.closingIndicator = closingIndicator; this.bufferSize = bufferSize; this.resources = new CompositeDisposable(); this.windows = new ArrayList<UnicastProcessor<T>>(); this.windowCount = new AtomicLong(1L); this.downstreamCancelled = new AtomicBoolean(); this.error = new AtomicThrowable(); this.startSubscriber = new WindowStartSubscriber<B>(this); this.requested = new AtomicLong();",
        "ins2PreCode":"ObservableSource<B> open, Function<? super B, ? extends ObservableSource<V>> closingIndicator, int bufferSize) { this.downstream = downstream; this.queue = new MpscLinkedQueue<Object>(); this.open = open; this.closingIndicator = closingIndicator; this.bufferSize = bufferSize; this.resources = new CompositeDisposable(); this.windows = new ArrayList<UnicastSubject<T>>(); this.windowCount = new AtomicLong(1L); this.downstreamDisposed = new AtomicBoolean(); this.error = new AtomicThrowable(); this.startObserver = new WindowStartObserver<B>(this); this.requested = new AtomicLong();",
        "label":0
    },
    {
        "ins1CurCode":"long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "ins1PreCode":"long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",Driver.connectCount.get(),10); tearDown();",
        "ins2PreCode":"long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10FairAsync\",this.datasource.getSize(),10); tearDown();",
        "label":1
    },
    {
        "ins1CurCode":"NumberAxis valueAxis = new NumberAxis(valueAxisLabel); HighLowRenderer renderer = new HighLowRenderer(); renderer.setDefaultToolTipGenerator(new HighLowItemLabelGenerator()); XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, renderer);",
        "ins1PreCode":"NumberAxis valueAxis = new NumberAxis(valueAxisLabel); HighLowRenderer renderer = new HighLowRenderer(); renderer.setBaseToolTipGenerator(new HighLowItemLabelGenerator()); XYPlot plot = new XYPlot(dataset, timeAxis, valueAxis, renderer);",
        "ins2PreCode":" BoxAndWhiskerRenderer renderer = new BoxAndWhiskerRenderer(); renderer.setBaseToolTipGenerator(new BoxAndWhiskerToolTipGenerator()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()) .willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier .create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .consumeErrorWith((ex) -> { assertThat(ex).isExactlyInstanceOf( CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) ex).getReason()) .isEqualTo(Reason.TOKEN_EXPIRED); }).verify();",
        "ins1PreCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier.create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))).consumeErrorWith(throwable -> { assertThat(throwable).isExactlyInstanceOf(CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) throwable) .getReason()).isEqualTo(Reason.TOKEN_EXPIRED); }).verify();",
        "ins2PreCode":"throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"foo.bar\\\"]}\"; StepVerifier.create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))).consumeErrorWith(throwable -> { assertThat(throwable).isExactlyInstanceOf(CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) throwable) .getReason()).isEqualTo(Reason.INVALID_AUDIENCE); }).verify();",
        "label":1
    },
    {
        "ins1CurCode":"public void testRemove() { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingAccessors(builder); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1));",
        "ins1PreCode":"public void testRemove() { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1));",
        "ins2PreCode":"public void testRemove() { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); assertEquals(11, builder.getInt32ToInt32FieldOrThrow(1)); for (int times = 0; times < 2; times++) { builder.removeInt32ToInt32Field(1); assertEquals(-1, builder.getInt32ToInt32FieldOrDefault(1, -1)); }  assertEquals(\"11\", builder.getInt32ToStringFieldOrThrow(1)); for (int times = 0; times < 2; times++) { builder.removeInt32ToStringField(1); assertNull(builder.getInt32ToStringFieldOrDefault(1, null)); }  assertEquals(TestUtil.toBytes(\"11\"), builder.getInt32ToBytesFieldOrThrow(1)); for (int times = 0; times < 2; times++) { builder.removeInt32ToBytesField(1); assertNull(builder.getInt32ToBytesFieldOrDefault(1, null)); }  assertEquals(TestMap.EnumValue.FOO, builder.getInt32ToEnumFieldOrThrow(1)); for (int times = 0; times < 2; times++) { builder.removeInt32ToEnumField(1); assertNull(builder.getInt32ToEnumFieldOrDefault(1, null)); }  assertEquals(11, builder.getStringToInt32FieldOrThrow(\"1\")); for (int times = 0; times < 2; times++) { builder.removeStringToInt32Field(\"1\"); assertEquals(-1, builder.getStringToInt32FieldOrDefault(\"1\", -1)); }  try { builder.removeStringToInt32Field(null); fail(); } catch (NullPointerException e) {  }",
        "label":0
    },
    {
        "ins1CurCode":"void registerUrlProtocolHandlerWithNoExistingRegistration() { String original = System.getProperty(PROTOCOL_HANDLER);",
        "ins1PreCode":"public void registerUrlProtocolHandlerWithNoExistingRegistration() { String original = System.getProperty(PROTOCOL_HANDLER);",
        "ins2PreCode":"public void registerUrlProtocolHandlerAddsToExistingRegistration() { String original = System.getProperty(PROTOCOL_HANDLER);",
        "label":1
    },
    {
        "ins1CurCode":"void encodeWithBCryptShouldUseBCrypt() throws Exception { EncodePasswordCommand command = new EncodePasswordCommand();",
        "ins1PreCode":"public void encodeWithBCryptShouldUseBCrypt() throws Exception { EncodePasswordCommand command = new EncodePasswordCommand();",
        "ins2PreCode":"public void encodeWithPbkdf2ShouldUsePbkdf2() throws Exception { EncodePasswordCommand command = new EncodePasswordCommand();",
        "label":1
    },
    {
        "ins1CurCode":"JavaRDD<Integer> rdd1 = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5, 6, 7), 3);  JavaPairRDD<Integer, Integer> rdd2 = rdd1.mapToPair(i -> new Tuple2<>(i, i % 2)); ",
        "ins1PreCode":"JavaRDD<Integer> rdd1 = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5, 6, 7), 3);  JavaPairRDD<Integer, Integer> rdd2 = rdd1.mapToPair( new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer i) { return new Tuple2<>(i, i % 2); } }); ",
        "ins2PreCode":"public void collectPartitions() { JavaRDD<Integer> rdd1 = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5, 6, 7), 3);  JavaPairRDD<Integer, Integer> rdd2 = rdd1.mapToPair(i -> new Tuple2<>(i, i % 2)); List<Integer>[] parts = rdd1.collectPartitions(new int[]{0}); Assert.assertEquals(Arrays.asList(1, 2), parts[0]);  parts = rdd1.collectPartitions(new int[]{1, 2}); Assert.assertEquals(Arrays.asList(3, 4), parts[0]); Assert.assertEquals(Arrays.asList(5, 6, 7), parts[1]);  Assert.assertEquals(Arrays.asList(new Tuple2<>(1, 1), new Tuple2<>(2, 0)), rdd2.collectPartitions(new int[]{0})[0]);  List<Tuple2<Integer, Integer>>[] parts2 = rdd2.collectPartitions(new int[]{1, 2}); Assert.assertEquals(Arrays.asList(new Tuple2<>(3, 1), new Tuple2<>(4, 0)), parts2[0]); Assert.assertEquals(Arrays.asList(new Tuple2<>(5, 1), new Tuple2<>(6, 0), new Tuple2<>(7, 1)), parts2[1]);",
        "label":0
    },
    {
        "ins1CurCode":"public void addLogFileProperty() { addPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\",",
        "ins1PreCode":"public void addLogFileProperty() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\",",
        "ins2PreCode":"public void addLogPathProperty() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.path=\" + this.logFile); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class); String existingOutput = this.outputCapture.toString(); logger.info(\"Hello world\"); String output = this.outputCapture.toString().substring(existingOutput.length()) .trim(); assertThat(output).startsWith(this.logFile.getAbsolutePath());",
        "label":0
    },
    {
        "ins1CurCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + path); Assert.assertEquals(expected, res.toString());",
        "ins1PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + path); assertEquals(expected, res.toString());",
        "ins2PreCode":"public void testBug53071() throws Exception { Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));  Tomcat.addServlet(ctx, \"errorServlet\", new ErrorServlet()); ctx.addServletMapping(\"/\", \"errorServlet\");  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort());  Assert.assertTrue(res.toString().contains(\"<p><b>message</b> <u>\" + ErrorServlet.ERROR_TEXT + \"</u></p>\"));",
        "label":0
    },
    {
        "ins1CurCode":"String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(!buildRule.getFullLog().contains(\"Removing orphan file:\"));",
        "ins1PreCode":"String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(buildRule.getFullLog().indexOf(\"Removing orphan file:\") == -1);",
        "ins2PreCode":"String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(buildRule.getFullLog().indexOf(\"Removing orphan file:\") == -1);",
        "label":1
    },
    {
        "ins1CurCode":"if (o instanceof ObservableSource) { ObservableSource<?> os = (ObservableSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof Publisher) { Publisher<?> os = (Publisher<?>) o; TestSubscriberEx<Object> ts = new TestSubscriberEx<>();  os.subscribe(ts);  ts.awaitDone(5, TimeUnit.SECONDS);  ts.assertSubscribed();  if (expected != null) { ts.assertValues(expected); } if (error) { ts.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { ts.assertNoErrors().assertComplete(); } }  if (o instanceof SingleSource) { SingleSource<?> os = (SingleSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof MaybeSource) { MaybeSource<?> os = (MaybeSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof CompletableSource) { CompletableSource os = (CompletableSource) o; TestObserverEx<Object> to = new TestObserverEx<>(); ",
        "ins1PreCode":"if (o instanceof ObservableSource) { ObservableSource<?> os = (ObservableSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof Publisher) { Publisher<?> os = (Publisher<?>) o; TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>();  os.subscribe(ts);  ts.awaitDone(5, TimeUnit.SECONDS);  ts.assertSubscribed();  if (expected != null) { ts.assertValues(expected); } if (error) { ts.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { ts.assertNoErrors().assertComplete(); } }  if (o instanceof SingleSource) { SingleSource<?> os = (SingleSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof MaybeSource) { MaybeSource<?> os = (MaybeSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof CompletableSource) { CompletableSource os = (CompletableSource) o; TestObserverEx<Object> to = new TestObserverEx<Object>(); ",
        "ins2PreCode":"if (o instanceof ObservableSource) { ObservableSource<?> os = (ObservableSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof Publisher) { Publisher<?> os = (Publisher<?>) o; TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>();  os.subscribe(ts);  ts.awaitDone(5, TimeUnit.SECONDS);  ts.assertSubscribed();  if (expected != null) { ts.assertValues(expected); } if (error) { ts.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { ts.assertNoErrors().assertComplete(); } }  if (o instanceof SingleSource) { SingleSource<?> os = (SingleSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof MaybeSource) { MaybeSource<?> os = (MaybeSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof CompletableSource) { CompletableSource os = (CompletableSource) o; TestObserverEx<Object> to = new TestObserverEx<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); @SuppressWarnings(\"unchecked\") XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "ins2PreCode":"public void testReplaceDataset() {   XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1);  LocalListener l = new LocalListener(); this.chart.addChangeListener(l);  @SuppressWarnings(\"unchecked\") XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "label":0
    },
    {
        "ins1CurCode":"public void test_olderThan_gt_newest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 11L); Iterable<ModelObject> itemList = newRuns(1, 10); ",
        "ins1PreCode":"public void test_olderThan_gt_newest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 11L); List<ModelObject> itemList = newRuns(1, 10); ",
        "ins2PreCode":"public void test_olderThan_leaving_part_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L); List<ModelObject> itemList = newRuns(1, 10); ",
        "label":1
    },
    {
        "ins1CurCode":" Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValueOne\", \"testValueTwo\"), result);",
        "ins1PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); Assert.assertEquals(Arrays.asList(\"testValueOne\", \"testValueTwo\"), result);",
        "ins2PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); Assert.assertEquals(Arrays.asList(\"testValueOne\", \"testValueTwo\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( @NonNull Publisher<@NonNull ? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<@NonNull TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<@NonNull TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super TRight, ? extends R> resultSelector) {",
        "ins2PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> join( @NonNull ObservableSource<? extends TRight> other,",
        "label":1
    },
    {
        "ins1CurCode":"if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeRow row = new UnsafeRow(numFields); row.pointTo(baseObject, baseOffset + offset, size); return row;",
        "ins1PreCode":"if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size); return row;",
        "ins2PreCode":"final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size); return row;",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,a = {a\\tb}}\"));  Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins1PreCode":".parse(new StringReader(\"@article{test,a = {a\\tb}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\"));",
        "ins2PreCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = BibtexParser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\"), importFormatPreferences, fileMonitor); Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"ups  \\tsala\"), e.getField(FieldName.ABSTRACT));",
        "label":1
    },
    {
        "ins1CurCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() { addPropertiesToEnvironment(this.context, \"logging.config=-Djava.util.logging.config.file=\\\"d:\\\\home\\\\site\\\\wwwroot\\\\bin\\\\apache-tomcat-7.0.52\\\\conf\\\\logging.properties\\\"\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins1PreCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config: -Djava.util.logging.config.file=\\\"d:\\\\home\\\\site\\\\wwwroot\\\\bin\\\\apache-tomcat-7.0.52\\\\conf\\\\logging.properties\\\"\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins2PreCode":"public void tomcatNopLoggingConfigDoesNotCauseAFailure() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"LOGGING_CONFIG: -Dnop\"); this.initializer.initialize(this.context.getEnvironment(),",
        "label":1
    },
    {
        "ins1CurCode":"}  repository.setBlocked( mirror.isBlocked() ); }",
        "ins1PreCode":"} }",
        "ins2PreCode":"} }",
        "label":1
    },
    {
        "ins1CurCode":" if (iterator != null) { R v = Objects.requireNonNull(iterator.next(), \"The iterator returned a null value\"); if (!iterator.hasNext()) {",
        "ins1PreCode":" if (iterator != null) { R v = ObjectHelper.requireNonNull(iterator.next(), \"The iterator returned a null value\"); if (!iterator.hasNext()) {",
        "ins2PreCode":" if (iterator != null) { R v = ObjectHelper.requireNonNull(iterator.next(), \"The iterator returned a null value\"); if (!iterator.hasNext()) {",
        "label":1
    },
    {
        "ins1CurCode":" Collection<String> result = autoCompleter.call(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"test value\"), result);",
        "ins1PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"val\"))); Assert.assertEquals(Collections.singletonList(\"test value\"), result);",
        "ins2PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"lue\"))); Assert.assertEquals(Collections.singletonList(\"test value\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "ins1PreCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); ASSERT.that(m).isEqualTo(expected); ASSERT.that(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "ins2PreCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); ASSERT.that(m).isEqualTo(expected); ASSERT.that(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValuePredicateMatch() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void assertValuePredicateMatch() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void assertValuePredicateMatch() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"boolean legend, boolean tooltips, boolean urls) {  Args.nullNotPermitted(orientation, \"orientation\"); ",
        "ins1PreCode":"boolean legend, boolean tooltips, boolean urls) {  ParamChecks.nullNotPermitted(orientation, \"orientation\"); ",
        "ins2PreCode":"boolean legend, boolean tooltips, boolean urls) {  ParamChecks.nullNotPermitted(orientation, \"orientation\"); CategoryAxis categoryAxis = new CategoryAxis(categoryAxisLabel);",
        "label":1
    },
    {
        "ins1CurCode":"XIntervalSeries s1 = new XIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); XIntervalSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "ins1PreCode":"XIntervalSeries s1 = new XIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); XIntervalSeries s2 = (XIntervalSeries) s1.clone(); assertTrue(s1 != s2);",
        "ins2PreCode":"VectorSeries s1 = new VectorSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); VectorSeries s2 = (VectorSeries) s1.clone(); assertTrue(s1 != s2);",
        "label":0
    },
    {
        "ins1CurCode":" FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(createScriptBuilder(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(createScriptBuilder(\"echo 1\")); ",
        "ins1PreCode":" FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\")); ",
        "ins2PreCode":" FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\")); ",
        "label":1
    },
    {
        "ins1CurCode":"void liquibaseReportIsReturned() { this.contextRunner.withUserConfiguration(Config.class).run((context) -> {",
        "ins1PreCode":"public void liquibaseReportIsReturned() { this.contextRunner.withUserConfiguration(Config.class).run((context) -> {",
        "ins2PreCode":"public void invokeWithCustomSchema() { this.contextRunner.withUserConfiguration(Config.class)",
        "label":1
    },
    {
        "ins1CurCode":"public void testPerformExportForSingleEditor(@TempDirectory.TempDir Path testFolder) throws Exception { Path path = testFolder.resolve(\"ThisIsARandomlyNamedFile\"); File tmpFile = path.toFile(); BibEntry entry = new BibEntry();",
        "ins1PreCode":"public void testPerformExportForSingleEditor() throws Exception { File tmpFile = testFolder.newFile(); BibEntry entry = new BibEntry();",
        "ins2PreCode":"public void testPerformExportForMultipleEditors() throws Exception { File tmpFile = testFolder.newFile(); BibEntry entry = new BibEntry();",
        "label":1
    },
    {
        "ins1CurCode":"false, \"Y\", dataset, PlotOrientation.VERTICAL, false, false, false); XYPlot<String> plot = (XYPlot) chart.getPlot(); NumberAxis domainAxis = (NumberAxis) plot.getDomainAxis();",
        "ins1PreCode":"false, \"Y\", dataset, PlotOrientation.VERTICAL, false, false, false); XYPlot plot = (XYPlot) chart.getPlot(); NumberAxis domainAxis = (NumberAxis) plot.getDomainAxis();",
        "ins2PreCode":"public void testFindRangeBounds() { TableXYDataset<String> dataset = RendererXYPackageUtils.createTestTableXYDataset(); JFreeChart chart = ChartFactory.createXYLineChart( \"Test Chart\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, false, false, false); XYPlot plot = (XYPlot) chart.getPlot(); NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis(); rangeAxis.setAutoRangeIncludesZero(false); Range bounds = rangeAxis.getRange(); assertFalse(bounds.contains(1.0)); assertTrue(bounds.contains(2.0)); assertTrue(bounds.contains(5.0)); assertFalse(bounds.contains(6.0));",
        "label":0
    },
    {
        "ins1CurCode":"flags |= getFlag(STEM_ENGLISH_POSSESSIVE, settings, \"stem_english_possessive\", true);  flags |= getFlag(IGNORE_KEYWORDS, settings, \"ignore_keywords\", false); ",
        "ins1PreCode":"flags |= getFlag(STEM_ENGLISH_POSSESSIVE, settings, \"stem_english_possessive\", true);  Set<?> protectedWords = Analysis.getWordSet(env, settings, \"protected_words\"); this.protoWords = protectedWords == null ? null : CharArraySet.copy(protectedWords);",
        "ins2PreCode":"public WordDelimiterTokenFilterFactory(IndexSettings indexSettings, Environment env, String name, Settings settings) { super(indexSettings, name, settings);        List<String> charTypeTableValues = Analysis.getWordList(env, settings, \"type_table\"); if (charTypeTableValues == null) { this.charTypeTable = WordDelimiterIterator.DEFAULT_WORD_DELIM_TABLE; } else { this.charTypeTable = parseTypes(charTypeTableValues); } int flags = 0;  flags |= getFlag(GENERATE_WORD_PARTS, settings, \"generate_word_parts\", true);  flags |= getFlag(GENERATE_NUMBER_PARTS, settings, \"generate_number_parts\", true);  flags |= getFlag(CATENATE_WORDS, settings, \"catenate_words\", false);  flags |= getFlag(CATENATE_NUMBERS, settings, \"catenate_numbers\", false);  flags |= getFlag(CATENATE_ALL, settings, \"catenate_all\", false);  flags |= getFlag(SPLIT_ON_CASE_CHANGE, settings, \"split_on_case_change\", true);  flags |= getFlag(PRESERVE_ORIGINAL, settings, \"preserve_original\", false);  flags |= getFlag(SPLIT_ON_NUMERICS, settings, \"split_on_numerics\", true);  flags |= getFlag(STEM_ENGLISH_POSSESSIVE, settings, \"stem_english_possessive\", true);  Set<?> protectedWords = Analysis.getWordSet(env, settings, \"protected_words\"); this.protoWords = protectedWords == null ? null : CharArraySet.copy(protectedWords); this.flags = flags;",
        "label":0
    },
    {
        "ins1CurCode":"stmt += caseSensitive ?             \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt +=    \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY SCHEMA_NAME, VIEW_NAME LIMIT \" + maxResults; ",
        "ins1PreCode":"stmt += caseSensitive ?             \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt +=    \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY VIEW_NAME LIMIT \" + maxResults; ",
        "ins2PreCode":"stmt += caseSensitive ?             \" PROCEDURE_NAME LIKE ?\" : \" UPPER(PROCEDURE_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY PROCEDURE_NAME LIMIT \" + maxResults; ",
        "label":1
    },
    {
        "ins1CurCode":"void shouldApplyHashMapTypeHandler() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void shouldApplyHashMapTypeHandler() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldApplyHashMapTypeHandlerXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":" User user = (User) this.resource; List<String> results = new ArrayList<>(); Iterator<Role> roles = user.getRoles();",
        "ins1PreCode":" User user = (User) this.resource; ArrayList<String> results = new ArrayList<>(); Iterator<Role> roles = user.getRoles();",
        "ins2PreCode":" Group group = (Group) this.resource; ArrayList<String> results = new ArrayList<>(); Iterator<Role> roles = group.getRoles();",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsedEntries.size()); assertEquals(\"article\", parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), parsedEntry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotated(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<>(); parms.put(\"lowestId\", 3);",
        "ins1PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotated(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 3);",
        "ins2PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNamesAnnotated(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2);",
        "label":1
    },
    {
        "ins1CurCode":" FailingWebappLoader loader = new FailingWebappLoader(); File root = new File(\"test/webapp\"); Context context = tomcat.addWebapp(\"\", root.getAbsolutePath());",
        "ins1PreCode":" FailingWebappLoader loader = new FailingWebappLoader(); File root = new File(\"test/webapp-3.0\"); Context context = tomcat.addWebapp(\"\", root.getAbsolutePath());",
        "ins2PreCode":" FailingLifecycleListener listener = new FailingLifecycleListener(); File root = new File(\"test/webapp-3.0\"); Context context = tomcat.addWebapp(\"\", root.getAbsolutePath());",
        "label":1
    },
    {
        "ins1CurCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.shouldSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "ins1PreCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "ins2PreCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "label":1
    },
    {
        "ins1CurCode":"File file2 = new File(System.getProperty(\"root\"), name2);  if (!file1.exists() || !file2.exists() || file1.length() != file2.length()) { return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  try (FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2)) { int read = 0;",
        "ins1PreCode":"  if (!file1.exists() || !file2.exists()) { return false; }  if (file1.length() != file2.length()) { return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  @SuppressWarnings(\"resource\") FileInputStream fis1 = new FileInputStream(file1); @SuppressWarnings(\"resource\") FileInputStream fis2 = new FileInputStream(file2); int read = 0;",
        "ins2PreCode":"private boolean compareFiles(File file1, File file2) throws IOException { if (!file1.exists() || !file2.exists()) { return false; }  if (file1.length() != file2.length()) { return false; }   byte[] buffer1 = new byte[BUF_SIZE]; byte[] buffer2 = new byte[BUF_SIZE];  try (FileInputStream fis1 = new FileInputStream(file1)) { try (FileInputStream fis2 = new FileInputStream(file2)) { int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i) { if (buffer1[i] != buffer2[i]) { return false; } } } } } return true;",
        "label":0
    },
    {
        "ins1CurCode":"String description = dbResult.getString(4); GenericSchema schema = parentSchema != null ? parentSchema : dataSource.getSchema(schemaName); if (schema == null) continue; ",
        "ins1PreCode":"String description = dbResult.getString(4); GenericSchema schema = parentSchema != null ? parentSchema : dataSource.getSchema(schemaName);  result.add(new AbstractObjectReference(objectName, schema, description, GenericTableColumn.class, RelationalObjectType.TYPE_TABLE_COLUMN) {",
        "ins2PreCode":"String description = dbResult.getString(4); GenericSchema schema = parentSchema != null ? parentSchema : dataSource.getSchema(schemaName);  result.add(new AbstractObjectReference(objectName, schema, description, GenericTableColumn.class, RelationalObjectType.TYPE_TABLE_COLUMN) {",
        "label":1
    },
    {
        "ins1CurCode":"public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<>(); } else { return new HashSet<>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<>(); } };  Flowable<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<>(Arrays.asList(\"eee\"))); ",
        "ins1PreCode":"public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<String>(); } else { return new HashSet<String>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<Integer, Collection<String>>(); } };  Flowable<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\"))); ",
        "ins2PreCode":"public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<String>(); } else { return new HashSet<String>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<Integer, Collection<String>>(); } };  Observable<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory).toObservable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\"))); ",
        "label":1
    },
    {
        "ins1CurCode":" Collection<String> result = autoCompleter.call(getRequest((\"\"))); assertEquals(Collections.emptyList(), result);",
        "ins1PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"\"))); Assert.assertEquals(Collections.emptyList(), result);",
        "ins2PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"\"))); Assert.assertEquals(Collections.emptyList(), result);",
        "label":1
    },
    {
        "ins1CurCode":"ValueExpression ve = factory.createValueExpression(context, \"#{beanA.name}\", java.lang.String.class); Assert.assertEquals(\"New value\", ve.getValue(context));",
        "ins1PreCode":"ValueExpression ve = factory.createValueExpression(context, \"#{beanA.name}\", java.lang.String.class); assertEquals(\"New value\", ve.getValue(context));",
        "ins2PreCode":"ValueExpression ve = factory.createValueExpression(context, \"#{beanA.valLong}\", java.lang.String.class); assertEquals(\"5\", ve.getValue(context));",
        "label":1
    },
    {
        "ins1CurCode":"Date end = new Date(y2007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnitType.YEAR, 10); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d4.getTime());",
        "ins1PreCode":"Date end = new Date(y2007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.YEAR, 10); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "ins2PreCode":"Date end = new Date(dec2006.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.MONTH, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "label":1
    },
    {
        "ins1CurCode":"if (metaClass.hasSetter(prop.getIndexedName())) { MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName()); if (metaValue == SystemMetaObject.NULL_META_OBJECT) { return metaClass.hasSetter(name);",
        "ins1PreCode":"if (metaClass.hasSetter(prop.getIndexedName())) { MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName()); if (metaValue == MetaObject.NULL_META_OBJECT) { return metaClass.hasSetter(name);",
        "ins2PreCode":"if (metaClass.hasGetter(prop.getIndexedName())) { MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName()); if (metaValue == MetaObject.NULL_META_OBJECT) { return metaClass.hasGetter(name);",
        "label":1
    },
    {
        "ins1CurCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses()); assertEquals(expected, getClasses(fullTextFetchers));",
        "ins1PreCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(fullTextFetchers));",
        "ins2PreCode":"try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(SearchBasedFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); ",
        "label":0
    },
    {
        "ins1CurCode":"void shouldSelectDiscriminatedPost() throws Exception { ",
        "ins1PreCode":"public void shouldSelectDiscriminatedPost() throws Exception { ",
        "ins2PreCode":"public void shouldSelect2DiscriminatedPosts() throws Exception { ",
        "label":1
    },
    {
        "ins1CurCode":"Role role = user.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(sm.getString(\"userMBean.invalidRole\", rolename)); }",
        "ins1PreCode":"Role role = user.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\"); }",
        "ins2PreCode":"Role role = user.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\"); }",
        "label":1
    },
    {
        "ins1CurCode":"void completeBeginnigOfSecondWordReturnsWord() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); database.insertEntry(entry);  Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"value\"), result);",
        "ins1PreCode":"public void completeBeginnigOfSecondWordReturnsWord() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"value\"), result);",
        "ins2PreCode":"public void completePartOfWordReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"lue\"))); assertEquals(Collections.singletonList(\"value\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"void loadGroovyResource() { ClassPathResource resource = new ClassPathResource(\"sample-beans.groovy\", getClass());",
        "ins1PreCode":"public void loadGroovyResource() { ClassPathResource resource = new ClassPathResource(\"sample-beans.groovy\", getClass());",
        "ins2PreCode":"public void loadGroovyResourceWithNamespace() { ClassPathResource resource = new ClassPathResource(\"sample-namespace.groovy\", getClass());",
        "label":1
    },
    {
        "ins1CurCode":"createObjectProvider(this.customizers), createObjectProvider(this.filters), createObjectProvider(this.binders), false, false); configurer.configure(this.mockRegistry);",
        "ins1PreCode":"createObjectProvider(this.customizers), createObjectProvider(this.filters), createObjectProvider(this.binders), false); configurer.configure(this.mockRegistry);",
        "ins2PreCode":"createObjectProvider(this.customizers), createObjectProvider(this.filters), createObjectProvider(this.binders), false); configurer.configure(this.mockRegistry);",
        "label":1
    },
    {
        "ins1CurCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Byte.class.getCanonicalName()); }",
        "ins1PreCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Byte.class.getCanonicalName()); }",
        "ins2PreCode":"return ((Number)value).doubleValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); }",
        "label":0
    },
    {
        "ins1CurCode":"private List<XYDataset<S>> getDatasetsMappedToDomainAxis(Integer axisIndex) { Args.nullNotPermitted(axisIndex, \"axisIndex\"); List<XYDataset<S>> result = new ArrayList<>();",
        "ins1PreCode":"private List<XYDataset<S>> getDatasetsMappedToDomainAxis(Integer axisIndex) { Objects.requireNonNull(axisIndex, \"axisIndex\"); List<XYDataset<S>> result = new ArrayList<>();",
        "ins2PreCode":"private List<XYDataset<S>> getDatasetsMappedToRangeAxis(Integer axisIndex) { Objects.requireNonNull(axisIndex, \"axisIndex\"); List<XYDataset<S>> result = new ArrayList<>();",
        "label":1
    },
    {
        "ins1CurCode":"void activeAndIncludedProfilesFromDefaultProperties() { Map<String, Object> source = new HashMap<>();",
        "ins1PreCode":"public void activeAndIncludedProfilesFromDefaultProperties() { Map<String, Object> source = new HashMap<>();",
        "ins2PreCode":"public void activeFromDefaultPropertiesShouldNotApplyIfProfilesHaveBeenActivatedBefore() { Map<String, Object> source = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":" int start = authHeader.indexOf(\"nonce=\\\"\") + 7; int end = authHeader.indexOf('\\'', start); return authHeader.substring(start, end);",
        "ins1PreCode":" int start = authHeader.indexOf(\"nonce=\\\"\") + 7; int end = authHeader.indexOf(\"\\\"\", start); return authHeader.substring(start, end);",
        "ins2PreCode":" int start = authHeader.indexOf(\"opaque=\\\"\") + 8; int end = authHeader.indexOf(\"\\\"\", start); return authHeader.substring(start, end);",
        "label":1
    },
    {
        "ins1CurCode":"public void singleDoesNotRequestMoreThanItNeedsIf3RequestedFlowable() { final List<Long> requests = new ArrayList<>(); Flowable.just(1)",
        "ins1PreCode":"public void singleDoesNotRequestMoreThanItNeedsIf3RequestedFlowable() { final List<Long> requests = new ArrayList<Long>(); Flowable.just(1)",
        "ins2PreCode":"public void singleRequestsExactlyWhatItNeedsIf1RequestedFlowable() { final List<Long> requests = new ArrayList<Long>(); Flowable.just(1)",
        "label":1
    },
    {
        "ins1CurCode":"String getQualifiedName(Element element) { if (element == null) {",
        "ins1PreCode":"public String getQualifiedName(Element element) { if (element == null) {",
        "ins2PreCode":"static String getQualifiedName(Element element) { if (element != null) { TypeElement enclosingElement = getEnclosingTypeElement(element.asType()); if (enclosingElement != null) { return getQualifiedName(enclosingElement) + \"$\" + ((DeclaredType) element.asType()).asElement().getSimpleName() .toString(); } if (element instanceof TypeElement) { return ((TypeElement) element).getQualifiedName().toString(); } } return null;",
        "label":0
    },
    {
        "ins1CurCode":"void javaBeanPropertyWithDefaultValue() throws IOException { process(SimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanPropertyWithDefaultValue() throws IOException { process(SimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokPropertyWithDescription() throws IOException { process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(\"source\" + (j + 1) + \" is null\", ex.getCause().getMessage()); } else { assertEquals(\"zipper is null\", ex.getCause().getMessage()); }",
        "ins1PreCode":"assertEquals(\"source\" + (j + 1) + \" is null\", ex.getCause().getMessage()); } else { assertEquals(\"f is null\", ex.getCause().getMessage()); }",
        "ins2PreCode":"assertEquals(\"source\" + (j + 1) + \" is null\", ex.getCause().getMessage()); } else { assertEquals(\"f is null\", ex.getCause().getMessage()); }",
        "label":0
    },
    {
        "ins1CurCode":"if (valve != null) { container.getPipeline().removeValve(valve); valve.setCluster(null); }",
        "ins1PreCode":"if (valve != null) { container.getPipeline().removeValve(valve); valve.setCluster(this); }",
        "ins2PreCode":"protected void registerClusterValve() { if(container != null ) { for (Iterator<Valve> iter = valves.iterator(); iter.hasNext();) { ClusterValve valve = (ClusterValve) iter.next(); if (log.isDebugEnabled()) log.debug(\"Invoking addValve on \" + getContainer() + \" with class=\" + valve.getClass().getName()); if (valve != null) { container.getPipeline().addValve(valve); valve.setCluster(this); } } }",
        "label":0
    },
    {
        "ins1CurCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(@NotNull Throwable error) { String message = error.getMessage();",
        "ins1PreCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(Throwable error) { String message = error.getMessage();",
        "ins2PreCode":"public ErrorPosition[] getErrorPosition(@NotNull Throwable error) { String message = error.getMessage(); if (!CommonUtils.isEmpty(message)) { Matcher matcher = ERROR_POSITION_PATTERN.matcher(message); if (matcher.find()) { DBPErrorAssistant.ErrorPosition pos = new DBPErrorAssistant.ErrorPosition(); pos.line = Integer.parseInt(matcher.group(1)) - 1; return new ErrorPosition[] { pos }; } } return null;",
        "label":0
    },
    {
        "ins1CurCode":"Observer<Integer> mockSubscriber = TestHelper.mockObserver();  oi.subscribe(new TestObserverEx<>(mockSubscriber)); ",
        "ins1PreCode":"Observer<Integer> mockSubscriber = TestHelper.mockObserver();  oi.subscribe(new TestObserverEx<Integer>(mockSubscriber)); ",
        "ins2PreCode":"Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Observer<Integer> mockSubscriber = TestHelper.mockObserver(); oi.subscribe(new TestObserverEx<Integer>(mockSubscriber)); ",
        "label":1
    },
    {
        "ins1CurCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for user \" + user); iae.initCause(e); throw iae;",
        "ins1PreCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for user \" + user); jdkCompat.chainException(iae, e); throw iae;",
        "ins2PreCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying user \" + user + \" MBean\"); jdkCompat.chainException(iae, e); throw iae;",
        "label":1
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":".run(assertDiscoverer((discoverer) -> { Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints(); List<EndpointId> ids = endpoints.stream().map(ExposableServletEndpoint::getEndpointId) .collect(Collectors.toList());",
        "ins1PreCode":".run(assertDiscoverer((discoverer) -> { Collection<ExposableServletEndpoint> endpoints = discoverer.getEndpoints(); List<EndpointId> ids = endpoints.stream().map(ExposableEndpoint::getEndpointId) .collect(Collectors.toList());",
        "ins2PreCode":".run(assertDiscoverer((discoverer) -> { Collection<ExposableControllerEndpoint> endpoints = discoverer.getEndpoints(); List<EndpointId> ids = endpoints.stream().map(ExposableEndpoint::getEndpointId) .collect(Collectors.toList());",
        "label":0
    },
    {
        "ins1CurCode":"String serverCredentials = getPassword(username);  boolean validated = compareCredentials(credentials, serverCredentials); if (!validated) { if (containerLog.isTraceEnabled()) {",
        "ins1PreCode":"String serverCredentials = getPassword(username);  boolean validated ; if ( serverCredentials == null ) { validated = false; } else if(hasMessageDigest()) { validated = serverCredentials.equalsIgnoreCase(digest(credentials)); } else { validated = serverCredentials.equals(credentials); } if(! validated ) { if (containerLog.isTraceEnabled()) {",
        "ins2PreCode":"protected Principal authenticate(Connection dbConnection, String username, String credentials) {  String dbCredentials = getPassword(dbConnection, username);   boolean validated = false; if (hasMessageDigest()) {  validated = (digest(credentials).equalsIgnoreCase(dbCredentials)); } else validated = (digest(credentials).equals(dbCredentials));  if (validated) { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateSuccess\", username)); } else { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateFailure\", username)); return (null); }  ArrayList<String> list = getRoles(dbConnection, username);   return (new GenericPrincipal(username, credentials, list)); ",
        "label":0
    },
    {
        "ins1CurCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws Exception { doWithBlockedPort((port) -> {",
        "ins1PreCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "ins2PreCode":"void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> { assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> { AbstractReactiveWebServerFactory factory = getFactory(); factory.setPort(port); this.webServer = factory.getWebServer(mock(HttpHandler.class)); this.webServer.start(); }).satisfies((ex) -> handleExceptionCausedByBlockedPortOnPrimaryConnector(ex, port)); });",
        "label":0
    },
    {
        "ins1CurCode":"protected WebResource getResource(String path, boolean useClassLoaderResources) {  if (noCache(path)) { return root.getResourceInternal(path, useClassLoaderResources); }  lookupCount.incrementAndGet();  CachedResource cacheEntry = resourceCache.get(path);  if (cacheEntry != null && !cacheEntry.validateResource(useClassLoaderResources)) { removeCacheEntry(path); cacheEntry = null; }  if (cacheEntry == null) {  int objectMaxSizeBytes = getObjectMaxSizeBytes(); CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);    cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);  if (cacheEntry == null) {  cacheEntry = newCacheEntry; cacheEntry.validateResource(useClassLoaderResources);     long delta = cacheEntry.getSize(); size.addAndGet(delta);  if (size.get() > maxSize) {     long targetSize = maxSize * (100 - TARGET_FREE_PERCENT_GET) / 100; long newSize = evict( targetSize, resourceCache.values().iterator()); if (newSize > maxSize) {   removeCacheEntry(path); log.warn(sm.getString(\"cache.addFail\", path)); } } } else {   cacheEntry.validateResource(useClassLoaderResources); } } else { hitCount.incrementAndGet(); }  return cacheEntry;",
        "ins1PreCode":"protected WebResource getResource(String path, boolean useClassLoaderResources) {  lookupCount.incrementAndGet();  if (noCache(path)) { return root.getResourceInternal(path, useClassLoaderResources); }  CachedResource cacheEntry = resourceCache.get(path);  if (cacheEntry != null && !cacheEntry.validateResource(useClassLoaderResources)) { removeCacheEntry(path); cacheEntry = null; }  if (cacheEntry == null) {  int objectMaxSizeBytes = getObjectMaxSizeBytes(); CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);    cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);  if (cacheEntry == null) {  cacheEntry = newCacheEntry; cacheEntry.validateResource(useClassLoaderResources);     long delta = cacheEntry.getSize(); size.addAndGet(delta);  if (size.get() > maxSize) {     long targetSize = maxSize * (100 - TARGET_FREE_PERCENT_GET) / 100; long newSize = evict( targetSize, resourceCache.values().iterator()); if (newSize > maxSize) {   removeCacheEntry(path); log.warn(sm.getString(\"cache.addFail\", path)); } } } else {   cacheEntry.validateResource(useClassLoaderResources); } } else { hitCount.incrementAndGet(); }  return cacheEntry;",
        "ins2PreCode":"protected WebResource[] getResources(String path, boolean useClassLoaderResources) { lookupCount.incrementAndGet();     CachedResource cacheEntry = resourceCache.get(path);  if (cacheEntry != null && !cacheEntry.validateResources(useClassLoaderResources)) { removeCacheEntry(path); cacheEntry = null; }  if (cacheEntry == null) {  int objectMaxSizeBytes = getObjectMaxSizeBytes(); CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);    cacheEntry = resourceCache.putIfAbsent(path, newCacheEntry);  if (cacheEntry == null) {  cacheEntry = newCacheEntry; cacheEntry.validateResources(useClassLoaderResources);   long delta = cacheEntry.getSize(); size.addAndGet(delta);  if (size.get() > maxSize) {     long targetSize = maxSize * (100 - TARGET_FREE_PERCENT_GET) / 100; long newSize = evict( targetSize, resourceCache.values().iterator()); if (newSize > maxSize) {   removeCacheEntry(path); log.warn(sm.getString(\"cache.addFail\", path)); } } } else {   cacheEntry.validateResources(useClassLoaderResources); } } else { hitCount.incrementAndGet(); }  return cacheEntry.getWebResources();",
        "label":0
    },
    {
        "ins1CurCode":"private WeakReference<ClassLoader> doTestUnloadableInStaticFieldIfClosed() throws Exception { final ClassLoader myLoader = getClass().getClassLoader(); URLClassLoader sepLoader = new URLClassLoader(getClassPathUrls(), myLoader.getParent()); ",
        "ins1PreCode":"private WeakReference<ClassLoader> doTestUnloadableInStaticFieldIfClosed() throws Exception { final URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader(); final URL[] urls = myLoader.getURLs(); URLClassLoader sepLoader = new URLClassLoader(urls, myLoader.getParent()); ",
        "ins2PreCode":"private WeakReference<ClassLoader> doTestUnloadableInStaticFieldIfClosed() throws Exception { final URLClassLoader myLoader = (URLClassLoader) getClass().getClassLoader(); final URL[] urls = myLoader.getURLs(); URLClassLoader sepLoader = new URLClassLoader(urls, myLoader.getParent()); ",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins2PreCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "label":1
    },
    {
        "ins1CurCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {  socketBufferHandler.configureReadBufferForRead(); ByteBuffer readBuffer = socketBufferHandler.getReadBuffer(); int remaining = readBuffer.remaining();   if (remaining >= len) { readBuffer.get(b, off, len); return len; }   if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining;        }   int nRead = fillReadBuffer(block);    if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead; }",
        "ins1PreCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {    if (closed) { throw new IOException(sm.getString(\"socket.apr.closed\", getSocket())); }  if (returnedInput != null) { if (returnedInput.remaining() < len) { len = returnedInput.remaining(); } returnedInput.get(b, off, len); if (returnedInput.remaining() == 0) { returnedInput = null; } return len; }  Lock readLock = getBlockingStatusReadLock(); WriteLock writeLock = getBlockingStatusWriteLock();  boolean readDone = false; int result = 0; readLock.lock(); try { if (getBlockingStatus() == block) { if (block) { Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000); } result = Socket.recv(getSocket().longValue(), b, off, len); readDone = true; } } finally { readLock.unlock(); }  if (!readDone) { writeLock.lock(); try {  setBlockingStatus(block); if (block) { Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000); } else { Socket.timeoutSet(getSocket().longValue(), 0); }  readLock.lock(); try { writeLock.unlock(); result = Socket.recv(getSocket().longValue(), b, off, len); } finally { readLock.unlock(); } } finally {   if (writeLock.isHeldByCurrentThread()) { writeLock.unlock(); } } }  if (result > 0) { eagain = false; return result; } else if (-result == Status.EAGAIN) { eagain = true; return 0; } else if (-result == Status.APR_EGENERAL && isSecure()) {    if (log.isDebugEnabled()) { log.debug(sm.getString(\"socket.apr.read.sslGeneralError\", getSocket(), this)); } eagain = true; return 0; } else if ((-result) == Status.ETIMEDOUT || (-result) == Status.TIMEUP) { if (block) { throw new SocketTimeoutException( sm.getString(\"iib.readtimeout\")); } else {       return 0; } } else if (-result == Status.APR_EOF) { return -1; } else if ((OS.IS_WIN32 || OS.IS_WIN64) && (-result == Status.APR_OS_START_SYSERR + 10053)) {  throw new EOFException(sm.getString(\"socket.apr.clientAbort\")); } else { throw new IOException(sm.getString(\"socket.apr.read.error\", Integer.valueOf(-result), getSocket(), this)); }",
        "ins2PreCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {  socketBufferHandler.configureReadBufferForRead(); ByteBuffer readBuffer = socketBufferHandler.getReadBuffer(); int remaining = readBuffer.remaining();   if (remaining >= len) { readBuffer.get(b, off, len); return len; }   if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining;        }   int nRead = fillReadBuffer(block);    if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead; }",
        "label":0
    },
    {
        "ins1CurCode":"String nodeString = graphString.substring(nodeStart, edgeStart);  Set<EndpointPair<N>> allEndpointPairs = new HashSet<>(); ",
        "ins1PreCode":"String nodeString = graphString.substring(nodeStart, edgeStart);  Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>(); ",
        "ins2PreCode":"String nodeString = graphString.substring(nodeStart, edgeStart);  Set<EndpointPair<N>> allEndpointPairs = new HashSet<EndpointPair<N>>(); ",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"Include\", new IncludeServlet()); ctx.addServletMappingDecoded(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMappingDecoded(\"/mapping\", \"Mapping\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"Include\", new IncludeServlet()); ctx.addServletMapping(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"Include\", new NamedIncludeServlet()); ctx.addServletMapping(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); ",
        "label":1
    },
    {
        "ins1CurCode":"historyPageFilter.add(runs, queueItems);  Assert.assertFalse(historyPageFilter.hasUpPage); Assert.assertTrue(historyPageFilter.hasDownPage); Assert.assertEquals(2, historyPageFilter.queueItems.size());",
        "ins1PreCode":"historyPageFilter.add(runs, queueItems);  Assert.assertEquals(false, historyPageFilter.hasUpPage); Assert.assertEquals(true, historyPageFilter.hasDownPage); Assert.assertEquals(2, historyPageFilter.queueItems.size());",
        "ins2PreCode":"historyPageFilter.add(runs, queueItems);  Assert.assertEquals(false, historyPageFilter.hasUpPage); Assert.assertEquals(false, historyPageFilter.hasDownPage); Assert.assertEquals(2, historyPageFilter.queueItems.size());",
        "label":0
    },
    {
        "ins1CurCode":"void testMaxHistoryProperty() { this.environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\");",
        "ins1PreCode":"void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\");",
        "ins2PreCode":"void testMaxHistoryPropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile); this.logger.info(\"Hello world\");",
        "label":1
    },
    {
        "ins1CurCode":"public void removeNode_queryAfterRemoval() { assume().that(graphIsMutable()).isTrue();  addNode(N1); @SuppressWarnings(\"unused\") Set<Integer> unused = networkAsMutableNetwork.adjacentNodes(N1); assertTrue(networkAsMutableNetwork.removeNode(N1)); try { networkAsMutableNetwork.adjacentNodes(N1); fail(ERROR_NODE_NOT_IN_GRAPH);",
        "ins1PreCode":"addNode(N1); @SuppressWarnings(\"unused\") Set<Integer> unused = network.adjacentNodes(N1); assertTrue(network.removeNode(N1)); try { network.adjacentNodes(N1); fail(ERROR_NODE_NOT_IN_GRAPH);",
        "ins2PreCode":"addNode(N1); @SuppressWarnings(\"unused\") Set<Integer> unused = network.adjacentNodes(N1); assertTrue(network.removeNode(N1)); try { network.adjacentNodes(N1); fail(ERROR_NODE_NOT_IN_GRAPH);",
        "label":1
    },
    {
        "ins1CurCode":"void allFieldsPresentDefault() { BibEntry e = new BibEntry(StandardEntryType.Article);",
        "ins1PreCode":"public void allFieldsPresentDefault() { BibEntry e = new BibEntry(StandardEntryType.Article);",
        "ins2PreCode":"public void allFieldsPresentOr() { BibEntry e = new BibEntry(StandardEntryType.Article);",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValuePredicateMatchButMore() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void assertValuePredicateMatchButMore() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void assertValueAtPredicateMatch() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual(@NonNull Observer<? super R> observer) { A container; BiConsumer<A, ? super T> accumulator; Function<A, R> finisher;",
        "ins1PreCode":"protected void subscribeActual(@NonNull Observer<? super R> observer) { A container; BiConsumer<A, T> accumulator; Function<A, R> finisher;",
        "ins2PreCode":"protected void subscribeActual(@NonNull SingleObserver<? super R> observer) { A container; BiConsumer<A, T> accumulator; Function<A, R> finisher;",
        "label":1
    },
    {
        "ins1CurCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins1PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins2PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "label":0
    },
    {
        "ins1CurCode":"public void onNextOnErrorRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<>();  final SerializedObserver<Integer> so = new SerializedObserver<>(to); ",
        "ins1PreCode":"public void onNextOnErrorRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<Integer>();  final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to); ",
        "ins2PreCode":"public void onNextOnErrorRaceDelayError() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<Integer>();  final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to, true); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetMinMiddleIndex() { TimePeriodValues<String> s = new TimePeriodValues<>(\"Test\"); assertEquals(-1, s.getMinMiddleIndex());",
        "ins1PreCode":"public void testGetMinMiddleIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMinMiddleIndex());",
        "ins2PreCode":"public void testGetMaxMiddleIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMaxMiddleIndex());",
        "label":1
    },
    {
        "ins1CurCode":"void diskSpaceIsUp() { given(this.fileMock.exists()).willReturn(true); long freeSpace = THRESHOLD.toBytes() + 10;",
        "ins1PreCode":"void diskSpaceIsUp() { long freeSpace = THRESHOLD.toBytes() + 10; given(this.fileMock.getUsableSpace()).willReturn(freeSpace);",
        "ins2PreCode":"void diskSpaceIsDown() { long freeSpace = THRESHOLD.toBytes() - 10; given(this.fileMock.getUsableSpace()).willReturn(freeSpace);",
        "label":1
    },
    {
        "ins1CurCode":"sample.oneDeclared(); fail(); } catch (SomeCheckedException expected) { }",
        "ins1PreCode":"sample.oneDeclared(); fail(); } catch (SomeCheckedException e) { }",
        "ins2PreCode":"public void testPropagate_NoneDeclared_CheckedThrown() { Sample sample = new Sample() { @Override public void noneDeclared() { try { methodThatThrowsChecked(); } catch (Throwable t) { throw Throwables.propagate(t); } } };   try { sample.noneDeclared(); fail(); } catch (RuntimeException expected) { assertTrue(expected.getCause() instanceof SomeCheckedException); }",
        "label":0
    },
    {
        "ins1CurCode":"void testAsciiDocFormat() { String expectedCitation = \"[1] B. Smith, B. Jones, and J. Williams, ``Title of the test entry,'' __BibTeX Journal__, vol. 34, no. 3, pp. 45\u201367, Jul. 2016.\\n\";",
        "ins1PreCode":"public void testAsciiDocFormat() { String expectedCitation = \"[1] B. Smith, B. Jones, and J. Williams, ``Title of the test entry,'' __BibTeX Journal__, vol. 34, no. 3, pp. 45\u201367, Jul. 2016.\\n\";",
        "ins2PreCode":"public void testHtmlFormat() { String expectedCitation = \"  <div class=\\\"csl-entry\\\">\\n\" +",
        "label":1
    },
    {
        "ins1CurCode":" URL resultUrl = result.getUrl(); assertEquals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl(), resultUrl.toString());",
        "ins1PreCode":" URL resultUrl = result.getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "ins2PreCode":" URL resultUrl = result.getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); SetProcessor setProcessor = factory.create(null, processorTag, null, config); assertThat(setProcessor.getTag(), equalTo(processorTag));",
        "ins1PreCode":"config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); SetProcessor setProcessor = factory.create(null, processorTag, config); assertThat(setProcessor.getTag(), equalTo(processorTag));",
        "ins2PreCode":"config.put(\"override\", overrideEnabled); String processorTag = randomAlphaOfLength(10); SetProcessor setProcessor = factory.create(null, processorTag, config); assertThat(setProcessor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"return current; } current = new SpscLinkedArrayQueue<>(Observable.bufferSize()); if (queue.compareAndSet(null, current)) {",
        "ins1PreCode":"return current; } current = new SpscLinkedArrayQueue<R>(Observable.bufferSize()); if (queue.compareAndSet(null, current)) {",
        "ins2PreCode":"return current; } current = new SpscLinkedArrayQueue<R>(Flowable.bufferSize()); if (queue.compareAndSet(null, current)) {",
        "label":1
    },
    {
        "ins1CurCode":"propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory()); if (metaClass.hasGetter(property)) {",
        "ins1PreCode":"propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType); if (metaClass.hasGetter(property)) {",
        "ins2PreCode":"propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType); if (metaClass.hasGetter(property)) {",
        "label":1
    },
    {
        "ins1CurCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<@NonNull ? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T, R> Flowable<R> zipArray(@NonNull Function<? super Object[], ? extends R> zipper, boolean delayError, int bufferSize, @NonNull Publisher<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "label":1
    },
    {
        "ins1CurCode":"void nested() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty();",
        "ins1PreCode":"public void nested() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty();",
        "ins2PreCode":"public void prefixed() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty();",
        "label":1
    },
    {
        "ins1CurCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); ",
        "ins1PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map( new Function<Tuple2<String, Integer>, Integer>() { @Override public Integer call(Tuple2<String, Integer> in) { return in._2(); } }); ",
        "ins2PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); JavaTestUtils.attachTestOutputStream(reversed);",
        "label":0
    },
    {
        "ins1CurCode":"public void fromPropertySourceShouldFlattenPropertySources() throws Exception { StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst( new MapPropertySource(\"foo\", Collections.singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst( new MapPropertySource(\"far\", Collections.singletonMap(\"far\", \"far\"))); MutablePropertySources sources = new MutablePropertySources(); sources.addFirst(new PropertySource<Environment>(\"env\", environment) {  @Override public String getProperty(String key) { return this.source.getProperty(key); }  }); sources.addLast( new MapPropertySource(\"baz\", Collections.singletonMap(\"baz\", \"barf\"))); Iterable<ConfigurationPropertySource> configurationSources = ConfigurationPropertySources",
        "ins1PreCode":"public void fromPropertySourceShouldFlattenPropertySources() throws Exception { StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.<String, Object>singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst(new MapPropertySource(\"far\", Collections.<String, Object>singletonMap(\"far\", \"far\"))); MutablePropertySources sources = new MutablePropertySources(); sources.addFirst(new PropertySource<Environment>(\"env\", environment) {  @Override public String getProperty(String key) { return this.source.getProperty(key); }  }); sources.addLast(new MapPropertySource(\"baz\", Collections.<String, Object>singletonMap(\"baz\", \"barf\"))); Iterable<ConfigurationPropertySource> configurationSources = ConfigurationPropertySources",
        "ins2PreCode":"public void shouldFlattenEnvironment() throws Exception { StandardEnvironment environment = new StandardEnvironment(); environment.getPropertySources().addFirst(new MapPropertySource(\"foo\", Collections.<String, Object>singletonMap(\"foo\", \"bar\"))); environment.getPropertySources().addFirst(new MapPropertySource(\"far\", Collections.<String, Object>singletonMap(\"far\", \"far\"))); MutablePropertySources sources = new MutablePropertySources(); sources.addFirst(new PropertySource<Environment>(\"env\", environment) {  @Override public String getProperty(String key) { return this.source.getProperty(key); }  }); sources.addLast(new MapPropertySource(\"baz\", Collections.<String, Object>singletonMap(\"baz\", \"barf\"))); SpringConfigurationPropertySources configurationSources = new SpringConfigurationPropertySources(",
        "label":1
    },
    {
        "ins1CurCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L); default :",
        "ins1PreCode":"{ case 101: return jjMoveStringLiteralDfa8_1(active0, 0x100000000000L); default :",
        "ins2PreCode":"{ case 111: return jjMoveStringLiteralDfa9_1(active0, 0x100000000000L); default :",
        "label":1
    },
    {
        "ins1CurCode":"public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) { List<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundRangeMarkers.get(index); if (markers == null) { markers = new ArrayList<>(); this.foregroundRangeMarkers.put(index, markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = this.backgroundRangeMarkers.get(index); if (markers == null) { markers = new ArrayList<>(); this.backgroundRangeMarkers.put(index, markers); }",
        "ins1PreCode":"public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) { Collection markers; if (layer == Layer.FOREGROUND) { markers = (Collection) this.foregroundRangeMarkers.get( new Integer(index)); if (markers == null) { markers = new java.util.ArrayList(); this.foregroundRangeMarkers.put(new Integer(index), markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = (Collection) this.backgroundRangeMarkers.get( new Integer(index)); if (markers == null) { markers = new java.util.ArrayList(); this.backgroundRangeMarkers.put(new Integer(index), markers); }",
        "ins2PreCode":"public void addDomainMarker(int index, CategoryMarker marker, Layer layer, boolean notify) { Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\"); Collection<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundDomainMarkers.get(index); if (markers == null) { markers = new java.util.ArrayList<Marker>(); this.foregroundDomainMarkers.put(index, markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = this.backgroundDomainMarkers.get(index); if (markers == null) { markers = new java.util.ArrayList<Marker>(); this.backgroundDomainMarkers.put(index, markers); } markers.add(marker); } marker.addChangeListener(this); if (notify) { fireChangeEvent(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void singleElementOperatorDoNotSwallowExceptionWhenDone() { final Throwable exception = new RuntimeException(\"some error\"); final AtomicReference<Throwable> error = new AtomicReference<>(); ",
        "ins1PreCode":"public void singleElementOperatorDoNotSwallowExceptionWhenDone() { final Throwable exception = new RuntimeException(\"some error\"); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); ",
        "ins2PreCode":"public void singleElementOperatorDoNotSwallowExceptionWhenDone() { final Throwable exception = new RuntimeException(\"some error\"); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); ",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_LONG, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_LONG, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_LONG, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"cache.test();  final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"cache.test();  final TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"cache.test();  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"}  Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<>();  for ( ArtifactRepository repository : repositories ) { String key = repository.getId();  List<ArtifactRepository> aliasedRepos = reposByKey.get( key );  if ( aliasedRepos == null ) { aliasedRepos = new ArrayList<>(); reposByKey.put( key, aliasedRepos ); }  aliasedRepos.add( repository ); }  List<ArtifactRepository> effectiveRepositories = new ArrayList<>();  for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() ) { List<ArtifactRepository> mirroredRepos = new ArrayList<>();  List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<>( aliasedRepos.size() );  for ( ArtifactRepository aliasedRepo : aliasedRepos ) { releasePolicies.add( aliasedRepo.getReleases() ); mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() ); }  ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );  List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<>( aliasedRepos.size() ); ",
        "ins1PreCode":"}  Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>();  for ( ArtifactRepository repository : repositories ) { String key = repository.getId();  List<ArtifactRepository> aliasedRepos = reposByKey.get( key );  if ( aliasedRepos == null ) { aliasedRepos = new ArrayList<ArtifactRepository>(); reposByKey.put( key, aliasedRepos ); }  aliasedRepos.add( repository ); }  List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>();  for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() ) { List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>();  List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );  for ( ArtifactRepository aliasedRepo : aliasedRepos ) { releasePolicies.add( aliasedRepo.getReleases() ); mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() ); }  ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );  List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() ); ",
        "ins2PreCode":"}  Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>();  for ( ArtifactRepository repository : repositories ) { String key = repository.getId();  List<ArtifactRepository> aliasedRepos = reposByKey.get( key );  if ( aliasedRepos == null ) { aliasedRepos = new ArrayList<ArtifactRepository>(); reposByKey.put( key, aliasedRepos ); }  aliasedRepos.add( repository ); }  List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>();  for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() ) { List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>();  List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );  for ( ArtifactRepository aliasedRepo : aliasedRepos ) { releasePolicies.add( aliasedRepo.getReleases() ); mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() ); }  ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );  List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() ); ",
        "label":1
    },
    {
        "ins1CurCode":"private StringManager(String packageName) { ResourceBundle b = null;  String bundleName = packageName + \".LocalStrings\"; try { b = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { b = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) {  } } }  this.bundle = b; if (bundle != null) { locale = bundle.getLocale(); } else { locale = null; }",
        "ins1PreCode":"String bundleName = packageName + \".LocalStrings\"; try { bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { bundle = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl);",
        "ins2PreCode":"private StringManager(String packageName, Locale locale) { String bundleName = packageName + \".LocalStrings\"; ResourceBundle bnd = null; try { bnd = ResourceBundle.getBundle(bundleName, locale); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { bnd = ResourceBundle.getBundle(bundleName, locale, cl); } catch(MissingResourceException ex2) {  } } } bundle = bnd;  if (bundle != null) { this.locale = bundle.getLocale(); } else { this.locale = null; }",
        "label":0
    },
    {
        "ins1CurCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<>(2, 2000, TimeUnit.MILLISECONDS, test, false);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<>(); ",
        "ins1PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":" MemoryBlock overflowPage = taskMemoryManager.allocatePage(overflowPageSize); if (overflowPage == null) { spill(); overflowPage = taskMemoryManager.allocatePage(overflowPageSize); if (overflowPage == null) { throw new IOException(\"Unable to acquire \" + overflowPageSize + \" bytes of memory\");",
        "ins1PreCode":"  final long memoryGranted = shuffleMemoryManager.tryToAcquire(overflowPageSize); if (memoryGranted != overflowPageSize) { shuffleMemoryManager.release(memoryGranted); spill(); final long memoryGrantedAfterSpill = shuffleMemoryManager.tryToAcquire(overflowPageSize); if (memoryGrantedAfterSpill != overflowPageSize) { shuffleMemoryManager.release(memoryGrantedAfterSpill); throw new IOException(\"Unable to acquire \" + overflowPageSize + \" bytes of memory\");",
        "ins2PreCode":"  final long memoryGranted = shuffleMemoryManager.tryToAcquire(overflowPageSize); if (memoryGranted != overflowPageSize) { shuffleMemoryManager.release(memoryGranted); spill(); final long memoryGrantedAfterSpill = shuffleMemoryManager.tryToAcquire(overflowPageSize); if (memoryGrantedAfterSpill != overflowPageSize) { shuffleMemoryManager.release(memoryGrantedAfterSpill); throw new IOException(\"Unable to acquire \" + overflowPageSize + \" bytes of memory\");",
        "label":1
    },
    {
        "ins1CurCode":"new HashMap<String,List<String>>());  Assert.assertEquals(200, sc); assertEcho(res.toString(), \"OK\");",
        "ins1PreCode":"new HashMap<String,List<String>>());  assertEquals(200, sc); assertEcho(res.toString(), \"OK\");",
        "ins2PreCode":"new HashMap<String,List<String>>());  assertEquals(200, sc); assertEcho(res.toString(), \"OK\");",
        "label":1
    },
    {
        "ins1CurCode":"protected List<String> getArguments(File archive, File serverPortFile) { try { explodeArchive(archive, this.exploded); deleteLauncherClasses(); File builtClasses = populateBuiltClasses(archive); File dependencies = populateDependencies(archive); File resourcesProject = explodedResourcesProject(dependencies); if (archive.getName().endsWith(\".war\")) { populateSrcMainWebapp(); } List<String> classpath = new ArrayList<>(); classpath.add(builtClasses.getAbsolutePath()); for (File dependency : dependencies.listFiles()) { classpath.add(dependency.getAbsolutePath()); } classpath.add(resourcesProject.getAbsolutePath()); return Arrays.asList(\"-cp\", StringUtils.collectionToDelimitedString(classpath, File.pathSeparator), \"com.example.ResourceHandlingApplication\", serverPortFile.getAbsolutePath()); }",
        "ins1PreCode":"protected List<String> getArguments(File archive) { try { explodeArchive(archive, this.exploded); deleteLauncherClasses(); File targetClasses = populateTargetClasses(archive); File dependencies = populateDependencies(archive); File resourcesProject = explodedResourcesProject(dependencies); if (archive.getName().endsWith(\".war\")) { populateSrcMainWebapp(); } List<String> classpath = new ArrayList<>(); classpath.add(targetClasses.getAbsolutePath()); for (File dependency : dependencies.listFiles()) { classpath.add(dependency.getAbsolutePath()); } classpath.add(resourcesProject.getAbsolutePath()); return Arrays.asList(\"-cp\", StringUtils.collectionToDelimitedString(classpath, File.pathSeparator), \"com.example.ResourceHandlingApplication\"); }",
        "ins2PreCode":"protected List<String> getArguments(File archive) { try { explodeArchive(archive); deleteLauncherClasses(); File targetClasses = populateTargetClasses(archive); File dependencies = populateDependencies(archive); if (archive.getName().endsWith(\".war\")) { populateSrcMainWebapp(); } List<String> classpath = new ArrayList<>(); classpath.add(targetClasses.getAbsolutePath()); for (File dependency : dependencies.listFiles()) { classpath.add(dependency.getAbsolutePath()); } return Arrays.asList(\"-cp\", StringUtils.collectionToDelimitedString(classpath, File.pathSeparator), \"com.example.ResourceHandlingApplication\"); }",
        "label":0
    },
    {
        "ins1CurCode":"JSONObject json = JSONObject.fromObject(DownloadService.loadJSONHTML(resource)); @SuppressWarnings(\"unchecked\") Set<String> keySet = json.keySet(); assertEquals(expected, new TreeSet<>(keySet).toString());",
        "ins1PreCode":"JSONObject json = JSONObject.fromObject(DownloadService.loadJSONHTML(resource)); @SuppressWarnings(\"unchecked\") Set<String> keySet = json.keySet(); assertEquals(expected, new TreeSet<String>(keySet).toString());",
        "ins2PreCode":"JSONObject json = JSONObject.fromObject(DownloadService.loadJSON(resource)); @SuppressWarnings(\"unchecked\") Set<String> keySet = json.keySet(); assertEquals(expected, new TreeSet<String>(keySet).toString());",
        "label":1
    },
    {
        "ins1CurCode":"final Completable c = ps.ignoreElements().cache();  final TestObserver<Void> to1 = new TestObserver<>();  final TestObserver<Void> to2 = new TestObserver<>(); ",
        "ins1PreCode":"final Completable c = ps.ignoreElements().cache();  final TestObserver<Void> to1 = new TestObserver<Void>();  final TestObserver<Void> to2 = new TestObserver<Void>(); ",
        "ins2PreCode":"final TestObserver<Void> to1 = c.test();  final TestObserver<Void> to2 = new TestObserver<Void>(); ",
        "label":0
    },
    {
        "ins1CurCode":"public void visitDecimal(EDecimal userDecimalNode, ScriptScope scriptScope) { Class<?> valueType = scriptScope.getDecoration(userDecimalNode, ValueType.class).getValueType(); Object constant = scriptScope.getDecoration(userDecimalNode, StandardConstant.class).getStandardConstant();  ConstantNode irConstantNode = new ConstantNode(userDecimalNode.getLocation()); irConstantNode.attachDecoration(new IRDExpressionType(valueType)); irConstantNode.setConstant(constant); ",
        "ins1PreCode":"public void visitDecimal(EDecimal userDecimalNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userDecimalNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userDecimalNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userDecimalNode, StandardConstant.class).getStandardConstant()); ",
        "ins2PreCode":"public void visitString(EString userStringNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userStringNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userStringNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userStringNode, StandardConstant.class).getStandardConstant()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldSelectBlogWithPostsAndAuthorUsingJoin() { try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);",
        "ins1PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingJoin() throws Exception { SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle());  final Author author = blog.getAuthor(); assertEquals(101, author.getId()); assertEquals(\"jim\", author.getUsername());  final List<Post> posts = blog.getPosts(); assertEquals(2, posts.size());  final Post post = blog.getPosts().get(0); assertEquals(1, post.getId()); assertEquals(\"Corn nuts\", post.getSubject());  final List<Comment> comments = post.getComments(); assertEquals(2, comments.size());  final List<Tag> tags = post.getTags(); assertEquals(3, tags.size());  final Comment comment = comments.get(0); assertEquals(1, comment.getId());  assertEquals(DraftPost.class, blog.getPosts().get(0).getClass()); assertEquals(Post.class, blog.getPosts().get(1).getClass());  } finally { session.close(); }",
        "ins2PreCode":"public void shouldSelectNestedBlogWithPostsAndAuthorUsingJoin() throws Exception { SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle());  final Author author = blog.getAuthor(); assertEquals(101, author.getId()); assertEquals(\"jim\", author.getUsername());  final List<Post> posts = blog.getPosts(); assertEquals(2, posts.size());  final Post post = blog.getPosts().get(0); assertEquals(1, post.getId()); assertEquals(\"Corn nuts\", post.getSubject());  final List<Comment> comments = post.getComments(); assertEquals(2, comments.size());  final List<Tag> tags = post.getTags(); assertEquals(3, tags.size());  final Comment comment = comments.get(0); assertEquals(1, comment.getId());  assertEquals(DraftPost.class, blog.getPosts().get(0).getClass()); assertEquals(Post.class, blog.getPosts().get(1).getClass());  } finally { session.close(); }",
        "label":1
    },
    {
        "ins1CurCode":".isEqualTo(\"The dependencies of some of the beans in the application context form a cycle:\"); assertThat(lines.get(1)).isEqualTo(\"\"); assertThat(lines.get(2)).contains(\"refererOne (field \" + RefererTwo.class.getName()); assertThat(lines.get(3)).isEqualTo(\"      \u2193\"); assertThat(lines.get(4)).contains(\"refererTwo (field \" + BeanOne.class.getName()); assertThat(lines.get(5)).isEqualTo(\"\u250c\u2500\u2500\u2500\u2500\u2500\u2510\");",
        "ins1PreCode":".isEqualTo(\"The dependencies of some of the beans in the application context form a cycle:\"); assertThat(lines.get(1)).isEqualTo(\"\"); assertThat(lines.get(2)).contains(\"refererOne \" + \"(field \" + RefererTwo.class.getName()); assertThat(lines.get(3)).isEqualTo(\"      \u2193\"); assertThat(lines.get(4)).contains(\"refererTwo \" + \"(field \" + BeanOne.class.getName()); assertThat(lines.get(5)).isEqualTo(\"\u250c\u2500\u2500\u2500\u2500\u2500\u2510\");",
        "ins2PreCode":"void cyclicBeanMethods() throws IOException { FailureAnalysis analysis = performAnalysis(CyclicBeanMethodsConfiguration.class); List<String> lines = readDescriptionLines(analysis); assertThat(lines).hasSize(9); assertThat(lines.get(0)) .isEqualTo(\"The dependencies of some of the beans in the application context form a cycle:\"); assertThat(lines.get(1)).isEqualTo(\"\"); assertThat(lines.get(2)).isEqualTo(\"\u250c\u2500\u2500\u2500\u2500\u2500\u2510\"); assertThat(lines.get(3)).startsWith(\"|  one defined in \" + InnerInnerConfiguration.class.getName()); assertThat(lines.get(4)).isEqualTo(\"\u2191     \u2193\"); assertThat(lines.get(5)).startsWith(\"|  two defined in \" + InnerConfiguration.class.getName()); assertThat(lines.get(6)).isEqualTo(\"\u2191     \u2193\"); assertThat(lines.get(7)).startsWith(\"|  three defined in \" + CyclicBeanMethodsConfiguration.class.getName()); assertThat(lines.get(8)).isEqualTo(\"\u2514\u2500\u2500\u2500\u2500\u2500\u2518\");",
        "label":0
    },
    {
        "ins1CurCode":"public void setUp() { MockitoAnnotations.initMocks(this); sparkConf = new SparkConf(); tempDir = new File(Utils.createTempDir$default$1());",
        "ins1PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); tempDir = new File(Utils.createTempDir$default$1()); shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE);",
        "ins2PreCode":"public void setup() { shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE); taskMemoryManager = new TaskMemoryManager(new ExecutorMemoryManager(getMemoryAllocator()));   sizeLimitedTaskMemoryManager = mock(TaskMemoryManager.class); when(sizeLimitedTaskMemoryManager.allocate(geq(1L << 20))).thenAnswer( new Answer<MemoryBlock>() { @Override public MemoryBlock answer(InvocationOnMock invocation) throws Throwable { if (((Long) invocation.getArguments()[0] / 8) > Integer.MAX_VALUE) { throw new OutOfMemoryError(\"Requested array size exceeds VM limit\"); } return new MemoryBlock(null, 0, (Long) invocation.getArguments()[0]); } } );",
        "label":0
    },
    {
        "ins1CurCode":";  assertThat(result, failedWith(6)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Slave/Delete permission\"));",
        "ins1PreCode":";  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"user is missing the Slave/Delete permission\"));",
        "ins2PreCode":".invokeWithArgs(\"aNode\");  assertThat(result, failedWith(1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"user is missing the Slave/Connect permission\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void testRewriteZeroPermissions() throws IOException { buildRule.executeTarget(\"rewriteZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "ins1PreCode":"public void testRewriteZeroPermissions() throws IOException { executeTarget(\"rewriteZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "ins2PreCode":"public void testAcceptZeroPermissions() throws IOException { executeTarget(\"acceptZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\");",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(forEachProcessor, Matchers.notNullValue()); assertThat(forEachProcessor.getField(), equalTo(\"_field\")); assertThat(forEachProcessor.getInnerProcessor(), Matchers.sameInstance(processor)); assertFalse(forEachProcessor.isIgnoreMissing());",
        "ins1PreCode":"assertThat(forEachProcessor, Matchers.notNullValue()); assertThat(forEachProcessor.getField(), equalTo(\"_field\")); assertThat(forEachProcessor.getProcessor(), Matchers.sameInstance(processor)); assertFalse(forEachProcessor.isIgnoreMissing());",
        "ins2PreCode":"assertThat(forEachProcessor, Matchers.notNullValue()); assertThat(forEachProcessor.getField(), equalTo(\"_field\")); assertThat(forEachProcessor.getProcessor(), Matchers.sameInstance(processor)); assertTrue(forEachProcessor.isIgnoreMissing());",
        "label":1
    },
    {
        "ins1CurCode":"public void removeApplicationListener(String listener) {  synchronized (applicationListenersLock) { ",
        "ins1PreCode":"public void removeApplicationListener(String listener) {  synchronized (applicationListeners) { ",
        "ins2PreCode":"  synchronized (wrapperListeners) { ",
        "label":1
    },
    {
        "ins1CurCode":"static String add_escapes(String str) { StringBuilder retval = new StringBuilder();",
        "ins1PreCode":"protected String add_escapes(String str) { StringBuilder retval = new StringBuilder();",
        "ins2PreCode":"protected static final String addEscapes(String str) { StringBuilder retval = new StringBuilder(); char ch; for (int i = 0; i < str.length(); i++) { switch (str.charAt(i)) { case 0 : continue; case '\\b': retval.append(\"\\\\b\"); continue; case '\\t': retval.append(\"\\\\t\"); continue; case '\\n': retval.append(\"\\\\n\"); continue; case '\\f': retval.append(\"\\\\f\"); continue; case '\\r': retval.append(\"\\\\r\"); continue; case '\\\"': retval.append(\"\\\\\\\"\"); continue; case '\\'': retval.append(\"\\\\\\'\"); continue; case '\\\\': retval.append(\"\\\\\\\\\"); continue; default: if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) { String s = \"0000\" + Integer.toString(ch, 16); retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length())); } else { retval.append(ch); } continue; } } return retval.toString();",
        "label":0
    },
    {
        "ins1CurCode":"public void groupsWithNestedSubscribeOn() throws InterruptedException { final ArrayList<String> results = new ArrayList<>(); Flowable.unsafeCreate(new Publisher<Integer>() {",
        "ins1PreCode":"public void groupsWithNestedSubscribeOn() throws InterruptedException { final ArrayList<String> results = new ArrayList<String>(); Flowable.unsafeCreate(new Publisher<Integer>() {",
        "ins2PreCode":"public void groupsWithNestedSubscribeOn() throws InterruptedException { final ArrayList<String> results = new ArrayList<String>(); Observable.unsafeCreate(new ObservableSource<Integer>() {",
        "label":1
    },
    {
        "ins1CurCode":"}  String template; if (enable) { template = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; } else { template = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; } template = template.replace(TABLE_NAME_PLACEHOLDER, getFullyQualifiedName(DBPEvaluationContext.DDL));  try (JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Changing referential integrity\")) { try (JDBCStatement statement = session.createStatement()) { for (DBPNamedObject fk: foreignKeys) { String sql = template.replace(FOREIGN_KEY_NAME_PLACEHOLDER,  fk.getName()); statement.executeUpdate(sql); }",
        "ins1PreCode":"}  String sql; if (enable) { sql = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; } else { sql = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; }  try (JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Changing referential integrity\")) { try (JDBCPreparedStatement statement = session.prepareStatement(sql)) { statement.setString(1, getFullyQualifiedName(DBPEvaluationContext.DDL)); for (DBPNamedObject fk: foreignKeys) { statement.setString(2, fk.getName()); statement.executeUpdate(); }",
        "ins2PreCode":"}  String sql; if (enable) { sql = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; } else { sql = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; }  try (JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Changing referential integrity\")) { try (JDBCPreparedStatement statement = session.prepareStatement(sql)) { statement.setString(1, getFullyQualifiedName(DBPEvaluationContext.DDL)); for (DBPNamedObject fk: foreignKeys) { statement.setString(2, fk.getName()); statement.executeUpdate(); }",
        "label":1
    },
    {
        "ins1CurCode":"void javaBeanNestedPropertySameClass() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanNestedPropertySameClass() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokNestedPropertySameClass() throws IOException { process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public T borrowObject(final long borrowMaxWaitMillis) throws Exception { assertOpen();  final AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3) ) { removeAbandoned(ac); }  PooledObject<T> p = null;    final boolean blockWhenExhausted = getBlockWhenExhausted();  boolean create; final long waitTime = System.currentTimeMillis();  while (p == null) { create = false; p = idleObjects.pollFirst(); if (p == null) { p = create(); if (p != null) { create = true; } } if (blockWhenExhausted) { if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } } else { if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } } if (!p.allocate()) { p = null; }  if (p != null) { try { factory.activateObject(p); } catch (final Exception e) { try { destroy(p); } catch (final Exception e1) {  } p = null; if (create) { final NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (final Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (final Exception e) {  } p = null; if (create) { final NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\");",
        "ins1PreCode":"public T borrowObject(long borrowMaxWaitMillis) throws Exception { assertOpen();  AbandonedConfig ac = this.abandonedConfig; if (ac != null && ac.getRemoveAbandonedOnBorrow() && (getNumIdle() < 2) && (getNumActive() > getMaxTotal() - 3) ) { removeAbandoned(ac); }  PooledObject<T> p = null;    boolean blockWhenExhausted = getBlockWhenExhausted();  boolean create; long waitTime = System.currentTimeMillis();  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { p = create(); if (p != null) { create = true; } } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { p = create(); if (p != null) { create = true; } } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\");",
        "ins2PreCode":"public T borrowObject(K key, long borrowMaxWaitMillis) throws Exception { assertOpen();  PooledObject<T> p = null;    boolean blockWhenExhausted = getBlockWhenExhausted();  boolean create; long waitTime = System.currentTimeMillis(); ObjectDeque<T> objectDeque = register(key);  try { while (p == null) { create = false; if (blockWhenExhausted) { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { p = create(key); if (p != null) { create = true; } } if (p == null) { if (borrowMaxWaitMillis < 0) { p = objectDeque.getIdleObjects().takeFirst(); } else { p = objectDeque.getIdleObjects().pollFirst( borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { p = create(key); if (p != null) { create = true; } } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(key, p); } catch (Exception e) { try { destroy(key, p, true); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(key, p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(key, p, true); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\");",
        "label":1
    },
    {
        "ins1CurCode":"void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "label":1
    },
    {
        "ins1CurCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(),",
        "ins1PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfig.Builder.create().build(),",
        "ins2PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfig.Builder.create().build(),",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"test\", new Bug51653ErrorTrigger()); ctx.addServletMappingDecoded(\"/test\", \"test\");   Tomcat.addServlet(ctx, \"errorPage\", new Bug51653ErrorPage(trace)); ctx.addServletMappingDecoded(\"/error\", \"errorPage\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"test\", new Bug51653ErrorTrigger()); ctx.addServletMapping(\"/test\", \"test\");   Tomcat.addServlet(ctx, \"errorPage\", new Bug51653ErrorPage(trace)); ctx.addServletMapping(\"/error\", \"errorPage\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"errorPage\", new Bug51653ErrorPage(trace)); ctx.addServletMapping(\"/error\", \"errorPage\"); ",
        "label":0
    },
    {
        "ins1CurCode":"void findMatchesWorksForRefiningGroups() { GroupTreeNode grandParent = getNodeInSimpleTree();",
        "ins1PreCode":"void findMatchesWorksForRefiningGroups() throws Exception { GroupTreeNode grandParent = getNodeInSimpleTree();",
        "ins2PreCode":"void findMatchesWorksForHierarchyOfIndependentGroups() throws Exception { GroupTreeNode grandParent = getNodeInSimpleTree();",
        "label":1
    },
    {
        "ins1CurCode":" j.createFreeStyleProject(); ACL.impersonate2(Jenkins.ANONYMOUS2, new Runnable() { @Override",
        "ins1PreCode":" j.createFreeStyleProject(); ACL.impersonate(Jenkins.ANONYMOUS, new Runnable() { @Override",
        "ins2PreCode":" j.createFreeStyleProject(); ACL.impersonate(Jenkins.ANONYMOUS, new Runnable() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"public void testMalformed02() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=a,en-gb;q=0.5\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testMalformed02() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=a\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testMalformed03() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5a\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "label":1
    },
    {
        "ins1CurCode":"public void setIgnoreBeanInfoPropertyByDefault() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins1PreCode":"public void setIgnoreBeanInfoPropertyByDefault() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins2PreCode":"public void disableIgnoreBeanInfoProperty() throws Exception { System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME,",
        "label":1
    },
    {
        "ins1CurCode":"void shouldRemoveItemOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\"));",
        "ins1PreCode":"public void shouldRemoveItemOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\"));",
        "ins2PreCode":"public void shouldRemoveItemOnDemand() { Cache cache = new LruCache(new PerpetualCache(\"default\"));",
        "label":1
    },
    {
        "ins1CurCode":"String value = \"0xnotanumber\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, value); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), null, fieldName, fieldName, Type.INTEGER, false); IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> processor.execute(ingestDocument));",
        "ins1PreCode":"String value = \"0xnotanumber\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, value); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.INTEGER, false); IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> processor.execute(ingestDocument));",
        "ins2PreCode":"String value = \"0xnotanumber\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, value); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.LONG, false); IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> processor.execute(ingestDocument));",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists());  try (InputStream inExpect = new BufferedInputStream(Files.newInputStream(expect.toPath())); InputStream inResult = new BufferedInputStream(Files.newInputStream(result.toPath()))) { int expectedByte = inExpect.read();",
        "ins1PreCode":"assertTrue(\"Expected file \" + result + \" doesn't exist\", result.exists());  try (InputStream inExpect = new BufferedInputStream(new FileInputStream(expect)); InputStream inResult = new BufferedInputStream(new FileInputStream(result))) { int expectedByte = inExpect.read();",
        "ins2PreCode":"assertTrue(\"Expected file \" + result + \" doesn\\'t exist\", result.exists());  try (InputStream inExpect = new BufferedInputStream(new FileInputStream(expect)); InputStream inResult = new BufferedInputStream(new FileInputStream(result))) { ",
        "label":1
    },
    {
        "ins1CurCode":"public void handlerAdaptersCreated() { this.contextRunner.run((context) -> { assertThat(context).getBeans(HandlerAdapter.class).hasSize(4); assertThat(context.getBean(RequestMappingHandlerAdapter.class)",
        "ins1PreCode":"public void handlerAdaptersCreated() { this.contextRunner.run((context) -> { assertThat(context).getBeans(HandlerAdapter.class).hasSize(3); assertThat(context.getBean(RequestMappingHandlerAdapter.class)",
        "ins2PreCode":"public void primaryExporterIsAllowed() { this.contextRunner.withPropertyValues(\"spring.jmx.enabled=true\") .withUserConfiguration(CustomMBeanExporter.class).run((context) -> { assertThat(context).getBeans(MBeanExporter.class).hasSize(2); assertThat(context.getBean(MBeanExporter.class)) .isSameAs(context.getBean(\"myMBeanExporter\")); });",
        "label":0
    },
    {
        "ins1CurCode":"public boolean contains(Object o) { if (o == null) { return false; } lock.lock(); try { for (Node<E> p = first; p != null; p = p.next) { if (o.equals(p.item)) { return true;",
        "ins1PreCode":"public boolean contains(Object o) { if (o == null) return false; lock.lock(); try { for (Node<E> p = first; p != null; p = p.next) if (o.equals(p.item)) return true;",
        "ins2PreCode":"public boolean removeLastOccurrence(Object o) { if (o == null) return false; lock.lock();",
        "label":0
    },
    {
        "ins1CurCode":"void envVar() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty();",
        "ins1PreCode":"public void envVar() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty();",
        "ins2PreCode":"public void nested() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty();",
        "label":1
    },
    {
        "ins1CurCode":"Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber();  oi.subscribe(new TestSubscriber<>(mockSubscriber)); ",
        "ins1PreCode":"Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber();  oi.subscribe(new TestSubscriber<Integer>(mockSubscriber)); ",
        "ins2PreCode":"Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9)).take(2); Subscriber<Integer> mockSubscriber = TestHelper.mockSubscriber(); oi.subscribe(new TestSubscriber<Integer>(mockSubscriber)); ",
        "label":1
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_adjacentNodes_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void fusedNoSync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC); ",
        "label":1
    },
    {
        "ins1CurCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(\"a string\", results); assertEquals(0, context.getBuffer().position());",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNotNull(results); assertEquals(0, results.length); assertEquals(9, context.getBuffer().position());",
        "label":0
    },
    {
        "ins1CurCode":"j.assertGoodStatus(result);  URL resultUrl = result.getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "ins1PreCode":"j.assertGoodStatus(result);  URL resultUrl = result.getWebResponse().getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "ins2PreCode":"j.assertGoodStatus(result);  URL resultUrl = result.getWebResponse().getUrl(); assertTrue(resultUrl.toString().equals(j.getInstance().getRootUrl() + myFreeStyleProject.getUrl()));",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldCheckTypeForEachGetter() { ReflectorFactory reflectorFactory = new DefaultReflectorFactory(); MetaClass meta = MetaClass.forClass(RichType.class, reflectorFactory); assertEquals(String.class, meta.getGetterType(\"richField\"));",
        "ins1PreCode":"public void shouldCheckTypeForEachGetter() { MetaClass meta = MetaClass.forClass(RichType.class); assertEquals(String.class, meta.getGetterType(\"richField\"));",
        "ins2PreCode":"public void shouldCheckTypeForEachSetter() { MetaClass meta = MetaClass.forClass(RichType.class); assertEquals(String.class, meta.getSetterType(\"richField\"));",
        "label":1
    },
    {
        "ins1CurCode":"void bindShouldValidateIfOtherHandlersInChainIgnoreError() { TestHandler testHandler = new TestHandler(null); this.handler = new ValidationBindHandler(testHandler, this.validator);",
        "ins1PreCode":"void bindShouldValidateIfOtherHandlersInChainIgnoreError() { TestHandler testHandler = new TestHandler(); this.handler = new ValidationBindHandler(testHandler, this.validator);",
        "ins2PreCode":"void bindShouldNotValidateIfOtherHandlersInChainThrowError() { this.sources.add(new MockConfigurationPropertySource(\"foo\", \"hello\")); ExampleValidatedBean bean = new ExampleValidatedBean(); assertThatExceptionOfType(BindException.class) .isThrownBy(() -> this.binder.bind(\"foo\", Bindable.of(ExampleValidatedBean.class).withExistingValue(bean), this.handler)) .withCauseInstanceOf(ConverterNotFoundException.class);",
        "label":0
    },
    {
        "ins1CurCode":"void addFieldWithLongerLength() throws IOException {  String bibtexEntry = OS.NEWLINE + OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author =  {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number =  {1},\" + OS.NEWLINE + \"  note =    {some note},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.HOWPUBLISHED, \"asdf\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins1PreCode":"void addFieldWithLongerLength() throws IOException {  String bibtexEntry = OS.NEWLINE + OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author =  {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number =  {1},\" + OS.NEWLINE + \"  note =    {some note},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.HOWPUBLISHED, \"asdf\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1CurCode":"\"TXT 13 0 3600 19700101000003 19700101000000 46271 . dRwMEthIeGiucMcEcDmwixM8/LZcZ+W6lMM0KDSY5rwAGrm1j7tS/VU6xs+rpD5dSRmBYosinkWD6Jk3zRmyBQ==\", Name.root);  RRset<TXTRecord> rrset = new RRset<>(); rrset.addRR(txt);",
        "ins1PreCode":"\"TXT 13 0 3600 19700101000003 19700101000000 46271 . dRwMEthIeGiucMcEcDmwixM8/LZcZ+W6lMM0KDSY5rwAGrm1j7tS/VU6xs+rpD5dSRmBYosinkWD6Jk3zRmyBQ==\", Name.root);  RRset rrset = new RRset(); rrset.addRR(txt);",
        "ins2PreCode":"\"TXT 13 0 3600 19700101000003 19700101000000 25719 . m6sD/b0ZbfBXsQruhq5dYTnHGaA+PRTL5Y1W36rMdnGBb7eOJRRzDS5Wk5hZlrS4RUKQ/tKMCn7lsl9fn4U2lw==\", Name.root);  RRset rrset = new RRset(); rrset.addRR(txt);",
        "label":1
    },
    {
        "ins1CurCode":"public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) { Map<String, Object> errorAttributes = getErrorAttributes(request, options.isIncluded(Include.STACK_TRACE)); if (Boolean.TRUE.equals(this.includeException)) { options = options.including(Include.EXCEPTION);",
        "ins1PreCode":"public Map<String, Object> getErrorAttributes(ServerRequest request, ErrorAttributeOptions options) { Map<String, Object> errorAttributes = getErrorAttributes(request, options.isIncluded(Include.STACK_TRACE)); if (this.includeException != null) { options = options.including(Include.EXCEPTION);",
        "ins2PreCode":"public Map<String, Object> getErrorAttributes(WebRequest webRequest, ErrorAttributeOptions options) { Map<String, Object> errorAttributes = getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE)); if (this.includeException != null) { options = options.including(Include.EXCEPTION);",
        "label":1
    },
    {
        "ins1CurCode":" if (t == null) { Throwable ex = ExceptionHelper.createNullPointerException(\"onNext called with a null Throwable.\"); try {",
        "ins1PreCode":" if (t == null) { Throwable ex = new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"); try {",
        "ins2PreCode":" if (t == null) { Throwable ex = new NullPointerException(\"onNext called with null. Null values are generally not allowed in 2.x operators and sources.\"); try {",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"ignore_missing\", true);  AbstractStringProcessor<?> processor = factory.create(null, processorTag, modifyConfig(config)); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins1PreCode":"config.put(\"ignore_missing\", true);  AbstractStringProcessor processor = factory.create(null, processorTag, modifyConfig(config)); assertThat(processor.getTag(), equalTo(processorTag));",
        "ins2PreCode":"config.put(\"target_field\", targetFieldName);  AbstractStringProcessor processor = factory.create(null, processorTag, modifyConfig(config)); assertThat(processor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"filterDef.addInitParameter(\"internalProxies\", \"192\\\\.168\\\\.0\\\\.10, 192\\\\.168\\\\.0\\\\.11\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIpHeader\", \"x-forwarded-for\"); filterDef.addInitParameter(\"proxiesHeader\", \"x-forwarded-by\");",
        "ins1PreCode":"filterDef.addInitParameter(\"internalProxies\", \"192\\\\.168\\\\.0\\\\.10, 192\\\\.168\\\\.0\\\\.11\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIPHeader\", \"x-forwarded-for\"); filterDef.addInitParameter(\"proxiesHeader\", \"x-forwarded-by\");",
        "ins2PreCode":"filterDef.addInitParameter(\"internalProxies\", \"127\\\\.0\\\\.0\\\\.1, 192\\\\.168\\\\..*, another-internal-proxy\"); filterDef.addInitParameter(\"trustedProxies\", \"proxy1, proxy2, proxy3\"); filterDef.addInitParameter(\"remoteIPHeader\", \"x-forwarded-for\"); filterDef.addInitParameter(\"proxiesHeader\", \"x-forwarded-by\");",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(yAxis2, plot.getRangeAxisForDataset(0));  List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {1, 2}); plot.mapDatasetToRangeAxes(0, axisIndices);",
        "ins1PreCode":"assertEquals(yAxis2, plot.getRangeAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToRangeAxes(0, axisIndices);",
        "ins2PreCode":"assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToDomainAxes(0, axisIndices);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeriesCollection<String> c1 = new XYIntervalSeriesCollection<>(); XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); XYIntervalSeriesCollection<String> c2 = CloneUtils.clone(c1); assertTrue(c1 != c2); assertTrue(c1.getClass() == c2.getClass()); assertTrue(c1.equals(c2));   c1.addSeries(new XYIntervalSeries<>(\"Empty\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries<>(\"Empty\")); assertTrue(c1.equals(c2));",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); XYIntervalSeriesCollection c2 = CloneUtils.clone(c1); assertTrue(c1 != c2); assertTrue(c1.getClass() == c2.getClass()); assertTrue(c1.equals(c2));   c1.addSeries(new XYIntervalSeries(\"Empty\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries(\"Empty\")); assertTrue(c1.equals(c2));",
        "ins2PreCode":"public void testSerialization() { XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); XYIntervalSeriesCollection c2 = TestUtils.serialised(c1); assertEquals(c1, c2);   c1.addSeries(new XYIntervalSeries(\"Empty\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries(\"Empty\")); assertTrue(c1.equals(c2));",
        "label":1
    },
    {
        "ins1CurCode":"Subscriber<Object> subscriber = TestHelper.mockSubscriber();  TestSubscriber<Object> ts = new TestSubscriber<>(subscriber); Flowable<Object> futureObservable = Flowable.fromFuture(future);",
        "ins1PreCode":"Subscriber<Object> subscriber = TestHelper.mockSubscriber();  TestSubscriber<Object> ts = new TestSubscriber<Object>(subscriber); Flowable<Object> futureObservable = Flowable.fromFuture(future);",
        "ins2PreCode":"Observer<Object> o = TestHelper.mockObserver();  TestObserver<Object> to = new TestObserver<Object>(o); Observable<Object> futureObservable = Observable.fromFuture(future);",
        "label":1
    },
    {
        "ins1CurCode":"model.save(sc.sc(), outputPath); @SuppressWarnings(\"unchecked\") FPGrowthModel<String> newModel = (FPGrowthModel<String>) FPGrowthModel.load(sc.sc(), outputPath); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD()",
        "ins1PreCode":"try { model.save(sc.sc(), outputPath); FPGrowthModel newModel = FPGrowthModel.load(sc.sc(), outputPath); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD()",
        "ins2PreCode":"public void runFPGrowth() {  @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  List<FPGrowth.FreqItemset<String>> freqItemsets = model.freqItemsets().toJavaRDD().collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {  List<String> items = itemset.javaItems(); long freq = itemset.freq(); }",
        "label":0
    },
    {
        "ins1CurCode":"}  stderr.println(node_s + \": \" + e.getMessage()); errorOccurred = true;",
        "ins1PreCode":"}  stderr.println(String.format(node_s + \": \" + e.getMessage())); errorOccurred = true;",
        "ins2PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.get(); final HashSet<String> hs = new HashSet<>(nodes); List<String> names = null;  for (String node_s : hs) { try { Computer computer = jenkins.getComputer(node_s); if (computer == null) { if (names == null) { names = ComputerSet.getComputerNames(); } String adv = EditDistance.findNearest(node_s, names); throw new IllegalArgumentException(adv == null ? hudson.model.Messages.Computer_NoSuchSlaveExistsWithoutAdvice(node_s) : hudson.model.Messages.Computer_NoSuchSlaveExists(node_s, adv)); } computer.cliOffline(cause); } catch (Exception e) { if (hs.size() == 1) { throw e; }  stderr.println(node_s + \": \" + e.getMessage()); errorOccurred = true; continue; } }  if (errorOccurred) { throw new AbortException(CLI_LISTPARAM_SUMMARY_ERROR_TEXT); } return 0;",
        "label":0
    },
    {
        "ins1CurCode":"Object target = TargetManager.getInstance().getModelTarget(); Object ns = null; if (Model.getFacade().isANamespace(target)) { ns = target; } if (Model.getFacade().isAParameter(target)) { if (Model.getFacade().getBehavioralFeature(target) != null) { target = Model.getFacade().getBehavioralFeature(target); } } if (Model.getFacade().isAFeature(target)) { if (Model.getFacade().getOwner(target) != null) { target = Model.getFacade().getOwner(target); } } if (Model.getFacade().isAEvent(target)) { ns = Model.getFacade().getNamespace(target); } if (Model.getFacade().isAClassifier(target)) { ns = Model.getFacade().getNamespace(target);",
        "ins1PreCode":"Object target = TargetManager.getInstance().getModelTarget(); Object ns = null; if (Model.getFacade().isANamespace(target)) ns = target; if (Model.getFacade().isAParameter(target)) if (Model.getFacade().getBehavioralFeature(target) != null) target = Model.getFacade().getBehavioralFeature(target); if (Model.getFacade().isAFeature(target)) if (Model.getFacade().getOwner(target) != null) target = Model.getFacade().getOwner(target); if (Model.getFacade().isAEvent(target)) ns = Model.getFacade().getNamespace(target); if (Model.getFacade().isAClassifier(target)) ns = Model.getFacade().getNamespace(target);",
        "ins2PreCode":"Object target = TargetManager.getInstance().getModelTarget(); Object ns = null; if (Model.getFacade().isANamespace(target)) ns = target; if (Model.getFacade().isAParameter(target)) if (Model.getFacade().getBehavioralFeature(target) != null) target = Model.getFacade().getBehavioralFeature(target); if (Model.getFacade().isAFeature(target)) if (Model.getFacade().getOwner(target) != null) target = Model.getFacade().getOwner(target); if (Model.getFacade().isAEvent(target)) ns = Model.getFacade().getNamespace(target); if (Model.getFacade().isAClassifier(target)) ns = Model.getFacade().getNamespace(target);",
        "label":1
    },
    {
        "ins1CurCode":"  int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 20000, null, null);",
        "ins1PreCode":"  int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 10000, null, null);",
        "ins2PreCode":"private void assertPageContains(String pageUrl, String expectedBody, int expectedStatus) throws IOException { ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, null);  Assert.assertEquals(expectedStatus, sc);  if (expectedStatus == 200) { String result = res.toString(); Assert.assertTrue(result, result.indexOf(expectedBody) > 0); }",
        "label":0
    },
    {
        "ins1CurCode":"public void createDelegate() { TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<>();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(ts1); ",
        "ins1PreCode":"public void createDelegate() { TestSubscriberEx<Integer> ts1 = new TestSubscriberEx<Integer>();  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(ts1); ",
        "ins2PreCode":"public void createDelegate() { TestSubscriber<Integer> ts1 = TestSubscriber.create();  TestSubscriber<Integer> ts = TestSubscriber.create(ts1);  assertFalse(ts.hasSubscription());  ts.onSubscribe(new BooleanSubscription());  assertTrue(ts.hasSubscription());  assertFalse(ts.isDisposed());  ts.onNext(1); ts.onError(new TestException()); ts.onComplete();  ts1.assertValue(1).assertError(TestException.class).assertComplete();  ts.dispose();  assertTrue(ts.isDisposed());  try { ts.assertNoValues(); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  try { ts.assertValueCount(0); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }  ts.assertValueSequence(Collections.singletonList(1));  try { ts.assertValueSequence(Collections.singletonList(2)); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError exc) {  }",
        "label":0
    },
    {
        "ins1CurCode":"s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimeSeries s2 = (TimeSeries) TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "ins1PreCode":"s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimeSeries s2 = (TimeSeries) TestUtilities.serialised(s1); assertTrue(s1.equals(s2));",
        "ins2PreCode":"s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimePeriodValues s2 = (TimePeriodValues) TestUtilities.serialised(s1); assertTrue(s1.equals(s2));",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsInvalid() { CLICommandInvoker.Result result = command",
        "ins1PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsInvalid() throws Exception { CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void dummyRangeNumberMultiShouldFailIfBuildNumberIsSpace() throws Exception { CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"public void testOrder1() throws IOException, ManifestException { buildRule.executeTarget(\"testOrder1\"); ",
        "ins1PreCode":"public void testOrder1() throws IOException, ManifestException { executeTarget(\"testOrder1\"); ",
        "ins2PreCode":"public void testOrder2() throws IOException, ManifestException { executeTarget(\"testOrder2\"); ",
        "label":1
    },
    {
        "ins1CurCode":"private void sendDirectory(final Directory current, final InputStream in, final OutputStream out) throws IOException { for (final Iterator fileIt = current.filesIterator(); fileIt.hasNext();) { sendFileToRemote((File) fileIt.next(), in, out); } for (final Iterator dirIt = current.directoryIterator(); dirIt.hasNext();) { final Directory dir = (Directory) dirIt.next(); sendDirectoryToRemote(dir, in, out);",
        "ins1PreCode":"private void sendDirectory(Directory current, InputStream in, OutputStream out) throws IOException { for (Iterator fileIt = current.filesIterator(); fileIt.hasNext();) { sendFileToRemote((File) fileIt.next(), in, out); } for (Iterator dirIt = current.directoryIterator(); dirIt.hasNext();) { Directory dir = (Directory) dirIt.next(); sendDirectoryToRemote(dir, in, out);",
        "ins2PreCode":"private void sendDirectory(ChannelSftp channel, Directory current) throws IOException, SftpException { for (Iterator fileIt = current.filesIterator(); fileIt.hasNext();) { sendFileToRemote(channel, (File) fileIt.next(), null); } for (Iterator dirIt = current.directoryIterator(); dirIt.hasNext();) { Directory dir = (Directory) dirIt.next(); sendDirectoryToRemote(channel, dir);",
        "label":1
    },
    {
        "ins1CurCode":" try { v = Objects.requireNonNull(combiner.apply(objects), \"combiner returned a null value\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { v = ObjectHelper.requireNonNull(combiner.apply(objects), \"combiner returned a null value\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { v = ObjectHelper.requireNonNull(combiner.apply(objects), \"The combiner returned a null value\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"void bindToClassShouldBindToCollectionWithDelimiter() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToClassShouldBindToCollectionWithDelimiter() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToClassWhenHasNoSetterShouldBindToList() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf() .set(package$.MODULE$.MEMORY_OFFHEAP_ENABLED(), true) .set(package$.MODULE$.MEMORY_OFFHEAP_SIZE(), 10000L); final TaskMemoryManager memoryManager =",
        "ins1PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"true\") .set(\"spark.memory.offHeap.size\", \"10000\"); final TaskMemoryManager memoryManager =",
        "ins2PreCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.memory.offHeap.enabled\", \"false\"); final TaskMemoryManager memoryManager =",
        "label":0
    },
    {
        "ins1CurCode":"DumbSlave slave = j.createSlave(\"aNode\", \"\", null); if (slave.toComputer().isConnecting()) { System.out.println(\"Waiting until going online is in progress...\"); slave.toComputer().waitUntilOnline(); } assertThat(slave.toComputer().isOnline(), equalTo(true)); slave.toComputer().disconnect(); slave.toComputer().waitUntilOffline(); assertThat(slave.toComputer().isOffline(), equalTo(true));  final CLICommandInvoker.Result result = command .authorizedTo(Computer.CONNECT, Jenkins.READ) .invokeWithArgs(\"aNode\"); assertThat(result, succeededSilently()); if (slave.toComputer().isConnecting()) { System.out.println(\"Waiting until going online is in progress...\"); slave.toComputer().waitUntilOnline();",
        "ins1PreCode":" if (slave.toComputer().isConnecting()) { System.out.println(\"Waiting until online in progress...\"); slave.toComputer().waitUntilOnline(); }  assertThat(slave.toComputer().isOnline(), equalTo(true)); slave.toComputer().disconnect(); slave.toComputer().waitUntilOffline(); assertThat(slave.toComputer().isOffline(), equalTo(true));  CLICommandInvoker.Result result = command .authorizedTo(Computer.CONNECT, Jenkins.READ) .invokeWithArgs(\"aNode\");  assertThat(result, succeededSilently()); if (slave.toComputer().isConnecting()) { System.out.println(\"Waiting until online in progress...\"); slave.toComputer().waitUntilOnline();",
        "ins2PreCode":" if (slave.toComputer().isConnecting()) { System.out.println(\"Waiting until online in progress...\"); slave.toComputer().waitUntilOnline(); }  assertThat(slave.toComputer().isOnline(), equalTo(true)); slave.toComputer().disconnect();  CLICommandInvoker.Result result = command .authorizedTo(Computer.CONNECT, Jenkins.READ) .invokeWithArgs(\"aNode\");  assertThat(result, succeededSilently()); if (slave.toComputer().isConnecting()) { System.out.println(\"Waiting until online in progress...\"); slave.toComputer().waitUntilOnline();",
        "label":1
    },
    {
        "ins1CurCode":"context.getBean(DataSource.class)); context.close(); verify(statement, never()).execute(\"SHUTDOWN\");",
        "ins1PreCode":"context.getBean(DataSource.class)); context.close(); verify(statement, times(0)).execute(\"SHUTDOWN\");",
        "ins2PreCode":"public void inMemoryHsqlIsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class)); context.close(); verify(statement, times(1)).execute(\"SHUTDOWN\");",
        "label":0
    },
    {
        "ins1CurCode":"  if (Model.getUmlFactory().isContainmentValid( Model.getMetaTypes().getAttribute(), getOwner())) { addFig(new FigAttributesCompartment( getOwner(), DEFAULT_COMPARTMENT_BOUNDS, getSettings())); }",
        "ins1PreCode":" addFig(getOperationsFig()); addFig(getBorderFig());   setFilled(true); setFillColor(FILL_COLOR); setLineColor(LINE_COLOR); setLineWidth(LINE_WIDTH); ",
        "ins2PreCode":"private void constructFigs(Rectangle bounds) { enableSizeChecking(false); setSuppressCalcBounds(true);  getStereotypeFig().setKeyword(getKeyword()); getStereotypeFig().setVisible(true);    getNameFig().setTopMargin( getStereotypeFig().getMinimumSize().height);  addFig(getBigPort()); addFig(getNameFig()); addFig(getStereotypeFig()); addExtraCompartments(); addFig(getOperationsFig()); addFig(getBorderFig());   setFilled(true); setFillColor(FILL_COLOR); setLineColor(LINE_COLOR); setLineWidth(LINE_WIDTH);   if (bounds != null) { setLocation(bounds.x, bounds.y); }  setSuppressCalcBounds(false);  setBounds(getBounds()); enableSizeChecking(true);",
        "label":0
    },
    {
        "ins1CurCode":"final AtomicInteger subsCount = new AtomicInteger(0);  final TestObserver<String> to = new TestObserver<>(); ",
        "ins1PreCode":"final AtomicInteger subsCount = new AtomicInteger(0);  final TestObserver<String> to = new TestObserver<String>(); ",
        "ins2PreCode":"final AtomicInteger subsCount = new AtomicInteger(0);  final TestObserver<String> to = new TestObserver<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt = new StandardCategoryToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertSame(tt2, tt);",
        "label":0
    },
    {
        "ins1CurCode":"XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "ins1PreCode":"XYIntervalSeries s1 = new XYIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0, 1.9, 2.01); XYIntervalSeries s2 = (XYIntervalSeries) s1.clone(); assertTrue(s1 != s2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCSeries s1 = new OHLCSeries(\"s1\"); s1.add(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass()); assertTrue(s1.equals(s2));",
        "label":0
    },
    {
        "ins1CurCode":"void removeEmptyCiteKey() { BibEntry entry = new BibEntry(); entry.setCitationKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getNumberOfCitationKeyOccurrences(\"AAA\"));  entry.setCitationKey(\"\"); database.removeEntry(entry); assertEquals(0, database.getNumberOfCitationKeyOccurrences(\"AAA\"));",
        "ins1PreCode":"void removeEmptyCiteKey() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getNumberOfKeyOccurrences(\"AAA\"));  entry.setCiteKey(\"\"); database.removeEntry(entry); assertEquals(0, database.getNumberOfKeyOccurrences(\"AAA\"));",
        "ins2PreCode":"void addAndRemoveEntry() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getNumberOfKeyOccurrences(\"AAA\")); database.removeEntry(entry); assertEquals(0, database.getNumberOfKeyOccurrences(\"AAA\"));",
        "label":0
    },
    {
        "ins1CurCode":"Plot parent = getParent(); if (parent instanceof XYPlot) { @SuppressWarnings(\"unchecked\") XYPlot<S> xy = (XYPlot) parent; result = xy.getDomainAxis(index);",
        "ins1PreCode":"Plot parent = getParent(); if (parent instanceof XYPlot) { XYPlot xy = (XYPlot) parent; result = xy.getDomainAxis(index);",
        "ins2PreCode":"Plot parent = getParent(); if (parent instanceof XYPlot) { XYPlot xy = (XYPlot) parent; result = xy.getRangeAxis(index);",
        "label":1
    },
    {
        "ins1CurCode":"void deleteWhenRemoveChosenReturnsTrueButDoesNotDeletesFile() { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\");",
        "ins1PreCode":"void deleteWhenRemoveChosenReturnsTrueButDoesNotDeletesFile() throws IOException { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\");",
        "ins2PreCode":"void deleteWhenDeleteChosenReturnsTrueAndDeletesFile() throws IOException { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\");",
        "label":1
    },
    {
        "ins1CurCode":"MapperService mapperService = mock(MapperService.class); MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getJoinField()).thenReturn(\"join_field\"); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); DocumentFieldMappers fieldMappers = new DocumentFieldMappers(Collections.singleton(joinFieldMapper), Collections.emptyList(), null, null, null); DocumentMapper mockMapper = mock(DocumentMapper.class); when(mockMapper.mappers()).thenReturn(fieldMappers); when(mapperService.documentMapper()).thenReturn(mockMapper); return mapperService;",
        "ins1PreCode":"MapperService mapperService = mock(MapperService.class); MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType);",
        "ins2PreCode":"MapperService mapperService = mock(MapperService.class); MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType);",
        "label":1
    },
    {
        "ins1CurCode":"} }) .doOnNext(new Consumer<Observable<Object>>() { @Override public void accept(Observable<Object> w) throws Throwable { w.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer()); }",
        "ins1PreCode":"} }) .to(TestHelper.<Observable<Object>>testConsumer());  to .assertValueCount(1) .assertError(TestException.class)",
        "ins2PreCode":"} }) .to(TestHelper.<Flowable<Object>>testConsumer());  ts .assertValueCount(1) .assertError(TestException.class)",
        "label":1
    },
    {
        "ins1CurCode":"public void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment();",
        "ins1PreCode":"public void testMaxHistoryProperty() throws Exception { MockEnvironment environment = new MockEnvironment();",
        "ins2PreCode":"public void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment();",
        "label":1
    },
    {
        "ins1CurCode":" do { } while (!socket.flush(true, selector, writeTimeout)); } finally {",
        "ins1PreCode":" do { if (socket.flush(true, selector, writeTimeout)) { break; } } while (true); }",
        "ins2PreCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { nRead = pool.read(to, socket, selector, getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } return nRead;",
        "label":0
    },
    {
        "ins1CurCode":"public void completeReturnsMultipleResults() { BibEntry entryOne = new BibEntry(); entryOne.setField(StandardField.TITLE, \"testValueOne\"); autoCompleter.indexEntry(entryOne); BibEntry entryTwo = new BibEntry(); entryTwo.setField(StandardField.TITLE, \"testValueTwo\"); autoCompleter.indexEntry(entryTwo);",
        "ins1PreCode":"public void completeReturnsMultipleResults() { BibEntry entryOne = new BibEntry(); entryOne.setField(\"field\", \"testValueOne\"); autoCompleter.indexEntry(entryOne); BibEntry entryTwo = new BibEntry(); entryTwo.setField(\"field\", \"testValueTwo\"); autoCompleter.indexEntry(entryTwo);",
        "ins2PreCode":"public void completeReturnsMultipleResults() { BibEntry entryOne = new BibEntry(); entryOne.setField(\"field\", \"testValueOne\"); autoCompleter.indexEntry(entryOne); BibEntry entryTwo = new BibEntry(); entryTwo.setField(\"field\", \"testValueTwo\"); autoCompleter.indexEntry(entryTwo);",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"httptrace\")).isFalse(); });",
        "ins1PreCode":"assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"trace\")).isFalse(); });",
        "ins2PreCode":"assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"trace\")).isFalse(); });",
        "label":1
    },
    {
        "ins1CurCode":"  sqlSession.clearCache(); ",
        "ins1PreCode":" parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); names = spMapper.getNames(parms);",
        "ins2PreCode":"public void testCallWithResultSet3() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNames(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 3); names = spMapper.getNames(parms); assertEquals(1, names.size()); assertEquals(1, parms.get(\"totalRows\")); } finally { sqlSession.close(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testInsertWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH)) { Mapper userMapper = sqlSession.getMapper(Mapper.class); User user1 = new User(null, \"Pocoyo\"); userMapper.insert(user1); User user2 = new User(null, \"Valentina\"); userMapper.insert(user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); }  try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<User> users = sqlSession.selectList(\"select\");",
        "ins1PreCode":"public void testInsertWithMapper() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { Mapper userMapper = sqlSession.getMapper(Mapper.class); User user1 = new User(null, \"Pocoyo\"); userMapper.insert(user1); User user2 = new User(null, \"Valentina\"); userMapper.insert(user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); }  try { sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"select\"); Assert.assertTrue(users.size() == 2); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertMapperJdbc3() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { Mapper userMapper = sqlSession.getMapper(Mapper.class); User user1 = new User(null, \"Pocoyo\"); userMapper.insertIdentity(user1); User user2 = new User(null, \"Valentina\"); userMapper.insertIdentity(user2); sqlSession.flushStatements(); assertEquals(Integer.valueOf(0), user1.getId()); assertEquals(Integer.valueOf(1), user2.getId()); sqlSession.commit(); } finally { sqlSession.close(); }  try { sqlSession = sqlSessionFactory.openSession(); List<User> users = sqlSession.selectList(\"selectIdentity\"); Assert.assertTrue(users.size() == 2); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void predecessors_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N2);",
        "ins1PreCode":"public void predecessors_checkReturnedSetMutability() { addNode(N2); Set<Integer> predecessors = network.predecessors(N2); try {",
        "ins2PreCode":"public void predecessors_checkReturnedSetMutability() { addNode(N2); Set<Integer> predecessors = network.predecessors(N2); try { predecessors.add(N1); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.predecessors(N2)).containsExactlyElementsIn(predecessors); }",
        "label":0
    },
    {
        "ins1CurCode":"flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) { return Flowable.just(v); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) { return Single.just(v).toFlowable(); } });  flowableDedicated = source.switchMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) { return Single.just(v);",
        "ins1PreCode":"flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.just(v); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toFlowable(); } });  flowableDedicated = source.switchMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v);",
        "ins2PreCode":"flowablePlain = source.concatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.just(v); } });  flowableConvert = source.concatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toFlowable(); } });  flowableDedicated = source.concatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v);",
        "label":1
    },
    {
        "ins1CurCode":"public void parseTraceArg() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"trace\");",
        "ins1PreCode":"public void parseTraceArg() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"trace\");",
        "ins2PreCode":"public void parseLevels() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "label":1
    },
    {
        "ins1CurCode":"  List<Path> result = fileFinder.findAssociatedFiles(localEntry, List.of(directory), PDF_EXTENSION); List<Path> expected = List.of(directory.resolve(\"directory/subdirectory/pdfInSubdirectory.pdf\"));   assertEquals(expected, result);",
        "ins1PreCode":"localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[citationkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);   assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/pdfInSubdirectory.pdf\")), result);",
        "ins2PreCode":"localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[citationkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions); ",
        "label":0
    },
    {
        "ins1CurCode":"ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false)); ",
        "ins1PreCode":"ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false)); ",
        "ins2PreCode":"tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath()); ctx.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false)); ",
        "label":1
    },
    {
        "ins1CurCode":"Objects.requireNonNull( input, \"input cannot be null\" );  try ( InputStream in = input ) {",
        "ins1PreCode":"Objects.requireNonNull( input, \"input cannot be null\" );  try ( final InputStream in = input ) {",
        "ins2PreCode":"Objects.requireNonNull( input, \"input cannot be null\" );  try ( final Reader in = input ) {",
        "label":1
    },
    {
        "ins1CurCode":"private Observable<T> doOnEach(@NonNull Consumer<? super T> onNext, @NonNull Consumer<? super Throwable> onError, @NonNull Action onComplete, @NonNull Action onAfterTerminate) { Objects.requireNonNull(onNext, \"onNext is null\");",
        "ins1PreCode":"private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { Objects.requireNonNull(onNext, \"onNext is null\");",
        "ins2PreCode":"private Flowable<T> doOnEach(@NonNull Consumer<? super T> onNext, @NonNull Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { Objects.requireNonNull(onNext, \"onNext is null\"); Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new FlowableDoOnEach<>(this, onNext, onError, onComplete, onAfterTerminate));",
        "label":0
    },
    {
        "ins1CurCode":"return true; case WireFormat.WIRETYPE_FIXED64: skipRawBytes(FIXED64_SIZE); return true; case WireFormat.WIRETYPE_LENGTH_DELIMITED: skipRawBytes(readRawVarint32()); return true; case WireFormat.WIRETYPE_START_GROUP: skipMessage(); checkLastTagWas( WireFormat.makeTag(WireFormat.getTagFieldNumber(tag), WireFormat.WIRETYPE_END_GROUP)); return true; case WireFormat.WIRETYPE_END_GROUP: return false; case WireFormat.WIRETYPE_FIXED32: skipRawBytes(FIXED32_SIZE); return true;",
        "ins1PreCode":"return true; case WireFormat.WIRETYPE_FIXED64: skipRawBytes(FIXED_64_SIZE); return true; case WireFormat.WIRETYPE_LENGTH_DELIMITED: skipRawBytes(readRawVarint32()); return true; case WireFormat.WIRETYPE_START_GROUP: skipMessage(); checkLastTagWas( WireFormat.makeTag(WireFormat.getTagFieldNumber(tag), WireFormat.WIRETYPE_END_GROUP)); return true; case WireFormat.WIRETYPE_END_GROUP: return false; case WireFormat.WIRETYPE_FIXED32: skipRawBytes(FIXED_32_SIZE); return true;",
        "ins2PreCode":"return true; case WireFormat.WIRETYPE_FIXED64: skipRawBytes(FIXED_64_SIZE); return true; case WireFormat.WIRETYPE_LENGTH_DELIMITED: skipRawBytes(readRawVarint32()); return true; case WireFormat.WIRETYPE_START_GROUP: skipMessage(); checkLastTagWas( WireFormat.makeTag(WireFormat.getTagFieldNumber(tag), WireFormat.WIRETYPE_END_GROUP)); return true; case WireFormat.WIRETYPE_END_GROUP: return false; case WireFormat.WIRETYPE_FIXED32: skipRawBytes(FIXED_32_SIZE); return true;",
        "label":1
    },
    {
        "ins1CurCode":"public String toString() { StringBuilder sb = new StringBuilder(); sb.append( \"HTTP RESPONSE STATUS: \" ).append( status ).append( '\\n' ); sb.append( \"VERSION: \" ).append( version ).append( '\\n' );  sb.append( \"--- HEADER --- \\n\" );  for ( String key : headers.keySet() ) { String value = headers.get( key ); sb.append( key ).append( ':' ).append( value ).append( '\\n' ); }  return sb.toString();",
        "ins1PreCode":"public String toString() { String result = \"HTTP RESPONSE STATUS: \" + status + \"\\n\"; result += \"VERSION: \" + version + \"\\n\";  result += \"--- HEADER --- \\n\"; for (String key : headers.keySet()) { String value = headers.get(key); result += key + \":\" + value + \"\\n\"; }  return result;",
        "ins2PreCode":"public String toString() { String result = \"HTTP REQUEST METHOD: \" + method + \"\\n\"; result += \"VERSION: \" + version + \"\\n\"; result += \"PATH: \" + requestedPath + \"\\n\";  result += \"--- HEADER --- \\n\"; for (String key : headers.keySet()) { String value = headers.get(key); result += key + \":\" + value + \"\\n\"; }      return result;",
        "label":1
    },
    {
        "ins1CurCode":"void testRemoveTermList(@TempDir Path tempDir) { ",
        "ins1PreCode":"void testRemoveTermList(@TempDirectory.TempDir Path tempDir) { ",
        "ins2PreCode":"void testAddNewTermListSetsCorrectDescription(@TempDirectory.TempDir Path tempDir) { ",
        "label":1
    },
    {
        "ins1CurCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsFlowable() { try { final List<Throwable> list = new CopyOnWriteArrayList<>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "ins1PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsFlowable() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "ins2PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissions() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "label":1
    },
    {
        "ins1CurCode":"memoryManager = new TestMemoryManager( new SparkConf() .set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeapSize\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins1PreCode":"memoryManager = new TestMemoryManager( new SparkConf().set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator())); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);",
        "ins2PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); sparkConf = new SparkConf(); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments();  return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "label":0
    },
    {
        "ins1CurCode":"VectorSeries s1 = new VectorSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); VectorSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2);",
        "ins1PreCode":"VectorSeries s1 = new VectorSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); VectorSeries s2 = (VectorSeries) s1.clone(); assertTrue(s1 != s2);",
        "ins2PreCode":"XIntervalSeries s1 = new XIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); XIntervalSeries s2 = (XIntervalSeries) s1.clone(); assertTrue(s1 != s2);",
        "label":0
    },
    {
        "ins1CurCode":"this.downstream = actual; this.disposables = new CompositeDisposable(); this.queue = new SpscLinkedArrayQueue<>(bufferSize()); this.lefts = new LinkedHashMap<>(); this.rights = new LinkedHashMap<>(); this.error = new AtomicReference<>(); this.leftEnd = leftEnd;",
        "ins1PreCode":"this.downstream = actual; this.disposables = new CompositeDisposable(); this.queue = new SpscLinkedArrayQueue<Object>(bufferSize()); this.lefts = new LinkedHashMap<Integer, UnicastSubject<TRight>>(); this.rights = new LinkedHashMap<Integer, TRight>(); this.error = new AtomicReference<Throwable>(); this.leftEnd = leftEnd;",
        "ins2PreCode":"this.downstream = actual; this.disposables = new CompositeDisposable(); this.queue = new SpscLinkedArrayQueue<Object>(bufferSize()); this.lefts = new LinkedHashMap<Integer, TLeft>(); this.rights = new LinkedHashMap<Integer, TRight>(); this.error = new AtomicReference<Throwable>(); this.leftEnd = leftEnd;",
        "label":1
    },
    {
        "ins1CurCode":"final String allowedHttpMethods = CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + \",PUT\"; final String allowedOrigins = ANY_ORIGIN; final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;",
        "ins1PreCode":"final String allowedHttpMethods = CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + \",PUT\"; final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS; final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;",
        "ins2PreCode":"final String allowedHttpMethods = CorsFilter.DEFAULT_ALLOWED_HTTP_METHODS + \",PUT\"; final String allowedOrigins = CorsFilter.DEFAULT_ALLOWED_ORIGINS; final String exposedHeaders = CorsFilter.DEFAULT_EXPOSED_HEADERS;",
        "label":1
    },
    {
        "ins1CurCode":"public Collection loadModel(ProfileReference reference) throws ProfileException {  if (reader == null) { LOG.error(\"Profile not found\"); throw new ProfileException(\"Profile not found!\"); }  try {",
        "ins1PreCode":"public Collection loadModel(ProfileReference reference) throws ProfileException { if (reader != null) { try {",
        "ins2PreCode":"throws ProfileException {  if (inputStream != null) { try { XmiReader xmiReader = Model.getXmiReader(); InputSource inputSource = new InputSource(inputStream); inputSource.setPublicId(publicReference.toString()); Collection elements = xmiReader.parse(inputSource, true); return elements; } catch (UmlException e) { LOG.error(\"Exception while loading profile \", e); throw new ProfileException(\"Invalid XMI data!\"); }",
        "label":1
    },
    {
        "ins1CurCode":"NumberAxis domainAxisA = (NumberAxis) p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); XYSeriesCollection<?> datasetA = (XYSeriesCollection) p2.getDataset(0); StandardXYItemRenderer rendererA = (StandardXYItemRenderer) p2.getRenderer(0); NumberAxis domainAxisB = (NumberAxis) p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); XYSeriesCollection<?> datasetB = (XYSeriesCollection) p2.getDataset(1); StandardXYItemRenderer rendererB",
        "ins1PreCode":"NumberAxis domainAxisA = (NumberAxis) p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); XYSeriesCollection<String> datasetA = (XYSeriesCollection) p2.getDataset(0); StandardXYItemRenderer rendererA = (StandardXYItemRenderer) p2.getRenderer(0); NumberAxis domainAxisB = (NumberAxis) p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); XYSeriesCollection<String> datasetB = (XYSeriesCollection) p2.getDataset(1); StandardXYItemRenderer rendererB",
        "ins2PreCode":"public void testSerialization5() { DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>(); CategoryAxis domainAxis1 = new CategoryAxis(\"Domain 1\"); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); BarRenderer renderer1 = new BarRenderer(); CategoryPlot<String, String> p1 = new CategoryPlot<>(dataset1, domainAxis1, rangeAxis1, renderer1); CategoryAxis domainAxis2 = new CategoryAxis(\"Domain 2\"); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\"); BarRenderer renderer2 = new BarRenderer(); DefaultCategoryDataset<String, String> dataset2 = new DefaultCategoryDataset<>(); p1.setDataset(1, dataset2); p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); CategoryPlot<String, String> p2 = TestUtils.serialised(p1); assertEquals(p1, p2);    CategoryAxis domainAxisA = p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); @SuppressWarnings(\"unchecked\") DefaultCategoryDataset<String, String> datasetA = (DefaultCategoryDataset) p2.getDataset(0); BarRenderer rendererA = (BarRenderer) p2.getRenderer(0); CategoryAxis domainAxisB = p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); @SuppressWarnings(\"unchecked\") DefaultCategoryDataset<String, String> datasetB = (DefaultCategoryDataset) p2.getDataset(1); BarRenderer rendererB  = (BarRenderer) p2.getRenderer(1); assertTrue(datasetA.hasListener(p2)); assertTrue(domainAxisA.hasListener(p2)); assertTrue(rangeAxisA.hasListener(p2)); assertTrue(rendererA.hasListener(p2)); assertTrue(datasetB.hasListener(p2)); assertTrue(domainAxisB.hasListener(p2)); assertTrue(rangeAxisB.hasListener(p2)); assertTrue(rendererB.hasListener(p2));",
        "label":0
    },
    {
        "ins1CurCode":" if (_UNSAFE != null) { BOOLEAN_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(boolean[].class); BYTE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(byte[].class); SHORT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(short[].class); INT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(int[].class); LONG_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(long[].class); FLOAT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(float[].class); DOUBLE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(double[].class); } else { BOOLEAN_ARRAY_OFFSET = 0; BYTE_ARRAY_OFFSET = 0;",
        "ins1PreCode":" if (_UNSAFE != null) { BYTE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(byte[].class); SHORT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(short[].class); INT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(int[].class); LONG_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(long[].class); FLOAT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(float[].class); DOUBLE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(double[].class); } else { BYTE_ARRAY_OFFSET = 0; SHORT_ARRAY_OFFSET = 0; INT_ARRAY_OFFSET = 0;",
        "ins2PreCode":"private static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;  static { sun.misc.Unsafe unsafe; try { Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\"); unsafeField.setAccessible(true); unsafe = (sun.misc.Unsafe) unsafeField.get(null); } catch (Throwable cause) { unsafe = null; } _UNSAFE = unsafe;  if (_UNSAFE != null) { BYTE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(byte[].class); INT_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(int[].class); LONG_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(long[].class); DOUBLE_ARRAY_OFFSET = _UNSAFE.arrayBaseOffset(double[].class); } else { BYTE_ARRAY_OFFSET = 0; INT_ARRAY_OFFSET = 0; LONG_ARRAY_OFFSET = 0; DOUBLE_ARRAY_OFFSET = 0; }",
        "label":0
    },
    {
        "ins1CurCode":".take(10, TimeUnit.MILLISECONDS) , flatMapMaxConcurrency) .subscribeWith(new TestSubscriberEx<>()) .awaitDone(5, TimeUnit.SECONDS) .assertTerminated();",
        "ins1PreCode":".take(10, TimeUnit.MILLISECONDS) , flatMapMaxConcurrency) .test() .awaitDone(5, TimeUnit.SECONDS) .assertNoErrors() .assertComplete();",
        "ins2PreCode":".take(10, TimeUnit.MILLISECONDS) , flatMapMaxConcurrency) .test() .awaitDone(5, TimeUnit.SECONDS) .assertNoErrors() .assertComplete();",
        "label":1
    },
    {
        "ins1CurCode":"void testECDSALeadingZeroUndersize() throws IOException, DNSSECException {",
        "ins1PreCode":"public void testECDSALeadingZeroUndersize() throws IOException, DNSSECException {",
        "ins2PreCode":"public void testECDSALeadingZeroOversize() throws IOException, DNSSECException {",
        "label":1
    },
    {
        "ins1CurCode":"Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\"); Collection<CategoryMarker> markers; if (layer == Layer.FOREGROUND) {",
        "ins1PreCode":"Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\"); Collection<Marker> markers; if (layer == Layer.FOREGROUND) {",
        "ins2PreCode":"public void addRangeMarker(int index, Marker marker, Layer layer, boolean notify) { List<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundRangeMarkers.get(index); if (markers == null) { markers = new ArrayList<>(); this.foregroundRangeMarkers.put(index, markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = this.backgroundRangeMarkers.get(index); if (markers == null) { markers = new ArrayList<>(); this.backgroundRangeMarkers.put(index, markers); } markers.add(marker); } marker.addChangeListener(this); if (notify) { fireChangeEvent(); }",
        "label":0
    },
    {
        "ins1CurCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsANegativeNumber() { CLICommandInvoker.Result result = command",
        "ins1PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsANegativeNumber() throws Exception { CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeIsInverse() throws Exception { CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"char cc=name.charAt(0); if (cc=='C' || cc=='c') { if (checkSpecialHeader(name, value)) { return;",
        "ins1PreCode":"char cc=name.charAt(0); if (cc=='C' || cc=='c') { if (checkSpecialHeader(name, value)) return;",
        "ins2PreCode":"private void addHeader(String name, String value, Charset charset) {  if (name == null || name.length() == 0 || value == null) { return; }  if (isCommitted()) { return; }   if (included) { return; }  char cc=name.charAt(0); if (cc=='C' || cc=='c') { if (checkSpecialHeader(name, value)) return; }  getCoyoteResponse().addHeader(name, value, charset);",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(\"/foo##D\", cn15.getName()); assertEquals(\"/foo/bar##E\", cn16.getName()); assertEquals(\"\", cn17.getName()); assertEquals(\"/ROOT/bar\", cn18.getName()); assertEquals(\"/ROOT/bar##A\", cn19.getName()); assertEquals(\"##A\", cn20.getName());",
        "ins1PreCode":"assertEquals(\"/foo##D\", cn15.getName()); assertEquals(\"/foo/bar##E\", cn16.getName());",
        "ins2PreCode":"assertEquals(\"/foo##D\", cn15.getDisplayName()); assertEquals(\"/foo/bar##E\", cn16.getDisplayName());",
        "label":1
    },
    {
        "ins1CurCode":"Project p = new Project(); javac.setProject(p); javac.setCompiler(\"javac1.8\"); javac.setSource(\"6\");",
        "ins1PreCode":"Project p = new Project(); javac.setProject(p); javac.setCompiler(\"javac8\"); javac.setSource(\"6\");",
        "ins2PreCode":"public void releaseIsUsedForJava9() { LogCapturingJavac javac = new LogCapturingJavac(); Project p = new Project(); javac.setProject(p); javac.setCompiler(\"javac9\"); javac.setSource(\"6\"); javac.setTarget(\"6\"); javac.setRelease(\"6\"); javac.setSourcepath(new Path(p)); SourceTargetHelperNoOverride sth = new SourceTargetHelperNoOverride(); sth.setJavac(javac); Commandline cmd = new Commandline(); sth.setupModernJavacCommandlineSwitches(cmd); assertThat(javac.getLog(), containsString(\"Ignoring source, target and bootclasspath as release has been set\")); String[] args = cmd.getCommandline(); assertEquals(5, args.length); assertEquals(\"-classpath\", args[0]); assertEquals(\"-g:none\", args[2]); assertEquals(\"--release\", args[3]); assertEquals(\"6\", args[4]);",
        "label":0
    },
    {
        "ins1CurCode":"};  Disposable sub1 = Disposable.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposable.empty(); ",
        "ins1PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "ins2PreCode":"};  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Long> o) { o.onSubscribe(Disposable.empty()); System.out.println(\"********* Start Source Data ***********\");",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Long> o) { o.onSubscribe(Disposables.empty()); System.out.println(\"********* Start Source Data ***********\");",
        "ins2PreCode":"public void replaySubjectConcurrentSubscribersDoingReplayDontBlockEachOther() throws InterruptedException { final ReplayProcessor<Long> replay = ReplayProcessor.create(); Thread source = new Thread(new Runnable() {  @Override public void run() { Flowable.unsafeCreate(new Publisher<Long>() {  @Override public void subscribe(Subscriber<? super Long> subscriber) { System.out.println(\"********* Start Source Data ***********\"); for (long l = 1; l <= 10000; l++) { subscriber.onNext(l); } System.out.println(\"********* Finished Source Data ***********\"); subscriber.onComplete(); } }).subscribe(replay); } }); source.start();  long v = replay.blockingLast(); assertEquals(10000, v);   final CountDownLatch slowLatch = new CountDownLatch(1); Thread slowThread = new Thread(new Runnable() {  @Override public void run() { Subscriber<Long> slow = new DefaultSubscriber<Long>() {  @Override public void onComplete() { System.out.println(\"*** Slow Observer completed\"); slowLatch.countDown(); }  @Override public void onError(Throwable e) { }  @Override public void onNext(Long args) { if (args == 1) { System.out.println(\"*** Slow Observer STARTED\"); } try { if (args % 10 == 0) { Thread.sleep(1); } } catch (InterruptedException e) { e.printStackTrace(); } } }; replay.subscribe(slow); try { slowLatch.await(); } catch (InterruptedException e1) { e1.printStackTrace(); } } }); slowThread.start();  Thread fastThread = new Thread(new Runnable() {  @Override public void run() { final CountDownLatch fastLatch = new CountDownLatch(1); Subscriber<Long> fast = new DefaultSubscriber<Long>() {  @Override public void onComplete() { System.out.println(\"*** Fast Observer completed\"); fastLatch.countDown(); }  @Override public void onError(Throwable e) { }  @Override public void onNext(Long args) { if (args == 1) { System.out.println(\"*** Fast Observer STARTED\"); } } }; replay.subscribe(fast); try { fastLatch.await(); } catch (InterruptedException e1) { e1.printStackTrace(); } } }); fastThread.start(); fastThread.join();   assertEquals(1, slowLatch.getCount());  slowThread.join();",
        "label":0
    },
    {
        "ins1CurCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "ins1PreCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "ins2PreCode":"public void testDataSendACK() throws Exception { System.err.println(\"Starting ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { LayeredBarRenderer r1 = new LayeredBarRenderer(); LayeredBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { LayeredBarRenderer r1 = new LayeredBarRenderer(); LayeredBarRenderer r2 = (LayeredBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerRenderer r1 = new BoxAndWhiskerRenderer(); BoxAndWhiskerRenderer r2 = (BoxAndWhiskerRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) { return Observable.just(v); } });  observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) { return Maybe.just(v).toObservable(); } });  observableDedicated = source.flatMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) { return Maybe.just(v);",
        "ins1PreCode":"observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } });  observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v).toObservable(); } });  observableDedicated = source.flatMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v);",
        "ins2PreCode":"observablePlain = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } });  observableConvert = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v).toObservable(); } });  observableDedicated = source.concatMapMaybe(new Function<Integer, Maybe<? extends Integer>>() { @Override public Maybe<? extends Integer> apply(Integer v) throws Exception { return Maybe.just(v);",
        "label":1
    },
    {
        "ins1CurCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "ins2PreCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1CurCode":"public Object clone() throws CloneNotSupportedException { LineAndShapeRenderer clone = (LineAndShapeRenderer) super.clone(); clone.seriesLinesVisibleMap = new HashMap<>(this.seriesLinesVisibleMap); clone.seriesShapesVisibleMap = new HashMap<>(this.seriesShapesVisibleMap); clone.seriesShapesFilledMap = new HashMap<>(this.seriesShapesFilledMap); return clone;",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException { LineAndShapeRenderer clone = (LineAndShapeRenderer) super.clone(); clone.seriesLinesVisible = (BooleanList) this.seriesLinesVisible.clone(); clone.seriesShapesVisible = (BooleanList) this.seriesShapesVisible.clone(); clone.seriesShapesFilled = (BooleanList) this.seriesShapesFilled.clone(); return clone;",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { XYLineAndShapeRenderer clone = (XYLineAndShapeRenderer) super.clone(); clone.seriesLinesVisible = (BooleanList) this.seriesLinesVisible.clone(); if (this.legendLine != null) { clone.legendLine = ShapeUtils.clone(this.legendLine); } clone.seriesShapesVisible = (BooleanList) this.seriesShapesVisible.clone(); clone.seriesShapesFilled = (BooleanList) this.seriesShapesFilled.clone(); return clone;",
        "label":1
    },
    {
        "ins1CurCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void preHandleSuccessfulWithFullAccess() throws Exception { String accessToken = mockAccessToken(); given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) .willReturn(Mono.just(AccessLevel.FULL)); given(this.tokenValidator.validate(any())).willReturn(Mono.empty()); MockServerWebExchange exchange = MockServerWebExchange .from(MockServerHttpRequest.get(\"/a\") .header(HttpHeaders.AUTHORIZATION, \"bearer \" + mockAccessToken()) .build()); StepVerifier.create(this.interceptor.preHandle(exchange, \"/a\")) .consumeNextWith((response) -> { assertThat(response.getStatus()).isEqualTo(HttpStatus.OK); assertThat((AccessLevel) exchange .getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.FULL);",
        "ins1PreCode":"public void preHandleSuccessfulWithFullAccess() throws Exception { String accessToken = mockAccessToken(); BDDMockito.given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) .willReturn(Mono.just(AccessLevel.FULL)); BDDMockito.given(this.tokenValidator.validate(any())) .willReturn(Mono.empty()); MockServerWebExchange exchange = MockServerWebExchange .from(MockServerHttpRequest.get(\"/a\") .header(HttpHeaders.AUTHORIZATION, \"bearer \" + mockAccessToken()) .build()); StepVerifier.create(this.interceptor.preHandle(exchange, \"/a\")) .consumeNextWith(response -> { assertThat(response.getStatus()).isEqualTo(HttpStatus.OK); assertThat((AccessLevel) exchange.getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.FULL);",
        "ins2PreCode":"public void preHandleSuccessfulWithRestrictedAccess() throws Exception { String accessToken = mockAccessToken(); BDDMockito.given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) .willReturn(Mono.just(AccessLevel.RESTRICTED)); BDDMockito.given(this.tokenValidator.validate(any())) .willReturn(Mono.empty()); MockServerWebExchange exchange = MockServerWebExchange .from(MockServerHttpRequest.get(\"/info\") .header(HttpHeaders.AUTHORIZATION, \"bearer \" + mockAccessToken()) .build()); StepVerifier.create(this.interceptor.preHandle(exchange, \"info\")) .consumeNextWith(response -> { assertThat(response.getStatus()).isEqualTo(HttpStatus.OK); assertThat((AccessLevel) exchange.getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.RESTRICTED);",
        "label":1
    },
    {
        "ins1CurCode":"} else if (result instanceof Publisher) { TestSubscriberEx<Object> ts = new TestSubscriberEx<>(); disposable.set(Disposable.fromSubscription(ts)); ",
        "ins1PreCode":"} else if (result instanceof Publisher) { TestSubscriberEx<Object> ts = new TestSubscriberEx<>(); disposable.set(Disposables.fromSubscription(ts)); ",
        "ins2PreCode":"} else if (result instanceof Publisher) { TestSubscriberEx<Object> ts = new TestSubscriberEx<>(); disposable.set(Disposables.fromSubscription(ts)); ",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Item.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"1\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"1\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ, Run.DELETE) .invokeWithArgs(\"aProject\", \"0\");",
        "label":1
    },
    {
        "ins1CurCode":"public void setDataset(int index, CategoryDataset dataset) { CategoryDataset existing = this.datasets.get(index); if (existing != null) {",
        "ins1PreCode":"public void setDataset(int index, CategoryDataset dataset) { CategoryDataset existing = (CategoryDataset) this.datasets.get(index); if (existing != null) {",
        "ins2PreCode":"public void setDataset(int index, XYDataset dataset) { XYDataset existing = getDataset(index); if (existing != null) { existing.removeChangeListener(this); } this.datasets.set(index, dataset); if (dataset != null) { dataset.addChangeListener(this); }   DatasetChangeEvent event = new DatasetChangeEvent(this, dataset); datasetChanged(event);",
        "label":0
    },
    {
        "ins1CurCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); Assert.assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); Assert.assertEquals(\"The second result is not correct.\", \"Hello, Weaver #2!\", result); ",
        "ins1PreCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #2!\", result); ",
        "ins2PreCode":" String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #2!\", result); ",
        "label":1
    },
    {
        "ins1CurCode":"public void parseLevelsTrimsWhitespace() { addPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot= trace \");",
        "ins1PreCode":"public void parseLevelsTrimsWhitespace() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot= trace \");",
        "ins2PreCode":"public void parseLevelsWithPlaceholder() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"foo=TRACE\", \"logging.level.org.springframework.boot=${foo}\"); this.initializer.initialize(this.context.getEnvironment(),",
        "label":1
    },
    {
        "ins1CurCode":"protected void populateRemotePort() { AsynchronousSocketChannel sc = getSocket().getIOChannel(); if (sc != null) { SocketAddress socketAddress = null; try { socketAddress = sc.getRemoteAddress(); } catch (IOException e) {",
        "ins1PreCode":"SocketAddress socketAddress = null; try { socketAddress = getSocket().getIOChannel().getRemoteAddress(); } catch (IOException e) {",
        "ins2PreCode":"SocketAddress socketAddress = null; try { socketAddress = getSocket().getIOChannel().getLocalAddress(); } catch (IOException e) {",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsEmpty() { final CLICommandInvoker.Result result = command",
        "ins1PreCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsEmpty() throws Exception { final CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsComma() throws Exception { final CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatReactiveWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatReactiveWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void builderCustomizersShouldBeInvoked() { UndertowReactiveWebServerFactory factory = getFactory();",
        "label":1
    },
    {
        "ins1CurCode":"void testNdots1() throws Exception { Resolver mockResolver = Mockito.mock(Resolver.class); wireUpMockResolver(mockResolver, this::simpleAnswer); Lookup l = makeLookupWithResolver(mockResolver, \"example.com\"); l.setSearchPath(\"namespace.svc.cluster.local\", \"svc.cluster.local\", \"cluster.local\"); Record[] results = l.run(); verify(mockResolver).send(any(Message.class)); assertEquals(1, results.length);",
        "ins1PreCode":"void testNdots1() throws IOException { try { System.setProperty(CONFIGPROVIDER_SKIP_INIT, \"true\"); Resolver mockResolver = Mockito.mock(Resolver.class); Name queryName = Name.fromConstantString(\"example.com\"); when(mockResolver.send(any(Message.class))) .thenAnswer( (Answer<Message>) invocation -> { Message query = invocation.getArgument(0); Message answer = new Message(query.getHeader().getID()); answer.addRecord(query.getQuestion(), Section.QUESTION); answer.addRecord( new ARecord( query.getQuestion().getName(), DClass.IN, 60, InetAddress.getByName(\"127.0.0.1\")), Section.ANSWER); return answer; }); Lookup l = new Lookup(queryName, Type.A); l.setCache(null); l.setResolver(mockResolver); l.setSearchPath(\"namespace.svc.cluster.local\", \"svc.cluster.local\", \"cluster.local\"); Record[] results = l.run(); verify(mockResolver, times(1)).send(any(Message.class)); assertEquals(1, results.length); } finally { System.clearProperty(CONFIGPROVIDER_SKIP_INIT); }",
        "ins2PreCode":"void testNdotsFallbackToAbsolute() throws IOException { try { System.setProperty(CONFIGPROVIDER_SKIP_INIT, \"true\"); Resolver mockResolver = Mockito.mock(Resolver.class); Name queryName = Name.fromConstantString(\"example.com\"); when(mockResolver.send(any(Message.class))) .thenAnswer( (Answer<Message>) invocation -> { Message query = invocation.getArgument(0); Message answer = new Message(query.getHeader().getID()); answer.addRecord(query.getQuestion(), Section.QUESTION); if (query.getQuestion().getName().labels() == 3) { answer.addRecord( new ARecord( query.getQuestion().getName(), DClass.IN, 60, InetAddress.getByName(\"127.0.0.1\")), Section.ANSWER); } else { answer.getHeader().setRcode(Rcode.NXDOMAIN); } return answer; }); Lookup l = new Lookup(queryName, Type.A); l.setCache(null); l.setResolver(mockResolver); l.setNdots(5); l.setSearchPath(\"namespace.svc.cluster.local\", \"svc.cluster.local\", \"cluster.local\"); Record[] results = l.run(); verify(mockResolver, times(4)).send(any(Message.class)); assertEquals(1, results.length); } finally { System.clearProperty(CONFIGPROVIDER_SKIP_INIT); }",
        "label":1
    },
    {
        "ins1CurCode":"= (BooleanList) this.seriesLinesVisible.clone(); if (this.legendLine != null) { clone.legendLine = ShapeUtils.clone(this.legendLine); }",
        "ins1PreCode":"= (BooleanList) this.seriesLinesVisible.clone(); if (this.legendLine != null) { clone.legendLine = ShapeUtilities.clone(this.legendLine); }",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { LineAndShapeRenderer clone = (LineAndShapeRenderer) super.clone(); clone.seriesLinesVisible = (BooleanList) this.seriesLinesVisible.clone(); clone.seriesShapesVisible = (BooleanList) this.seriesShapesVisible.clone(); clone.seriesShapesFilled = (BooleanList) this.seriesShapesFilled.clone(); return clone;",
        "label":0
    },
    {
        "ins1CurCode":"Subscriber<? super R> downstream = this.downstream; ErrorMode errorMode = this.errorMode; SimpleQueue<T> queue = this.queue; AtomicThrowable errors = this.errors; AtomicLong requested = this.requested; int limit = prefetch - (prefetch >> 1); boolean syncFused = this.syncFused;  for (;;) {  for (;;) { if (cancelled) { queue.clear(); item = null; break; }  int s = state;  if (errors.get() != null) { if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) { queue.clear(); item = null; errors.tryTerminateConsumer(downstream); return; } }  if (s == STATE_INACTIVE) { boolean d = done; T v; try { v = queue.poll(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); upstream.cancel(); errors.tryAddThrowableOrReport(ex); errors.tryTerminateConsumer(downstream); return; } boolean empty = v == null;  if (d && empty) { errors.tryTerminateConsumer(downstream); return; }  if (empty) { break; }  if (!syncFused) { int c = consumed + 1;",
        "ins1PreCode":"Subscriber<? super R> downstream = this.downstream; ErrorMode errorMode = this.errorMode; SimplePlainQueue<T> queue = this.queue; AtomicThrowable errors = this.errors; AtomicLong requested = this.requested; int limit = prefetch - (prefetch >> 1);  for (;;) {  for (;;) { if (cancelled) { queue.clear(); item = null; break; }  int s = state;  if (errors.get() != null) { if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) { queue.clear(); item = null; errors.tryTerminateConsumer(downstream); return; } }  if (s == STATE_INACTIVE) { boolean d = done; T v = queue.poll(); boolean empty = v == null;",
        "ins2PreCode":"Subscriber<? super R> downstream = this.downstream; ErrorMode errorMode = this.errorMode; SimplePlainQueue<T> queue = this.queue; AtomicThrowable errors = this.errors; AtomicLong requested = this.requested; int limit = prefetch - (prefetch >> 1);  for (;;) {  for (;;) { if (cancelled) { queue.clear(); item = null; break; }  int s = state;  if (errors.get() != null) { if (errorMode == ErrorMode.IMMEDIATE || (errorMode == ErrorMode.BOUNDARY && s == STATE_INACTIVE)) { queue.clear(); item = null; errors.tryTerminateConsumer(downstream); return; } }  if (s == STATE_INACTIVE) { boolean d = done; T v = queue.poll(); boolean empty = v == null;",
        "label":1
    },
    {
        "ins1CurCode":"public void testEquals_ObjectList() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setDomainAxis(new CategoryAxis(\"A\")); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setDomainAxis(new CategoryAxis(\"A\"));",
        "ins1PreCode":"public void testEquals_ObjectList() { CategoryPlot p1 = new CategoryPlot(); p1.setDomainAxis(new CategoryAxis(\"A\")); CategoryPlot p2 = new CategoryPlot(); p2.setDomainAxis(new CategoryAxis(\"A\"));",
        "ins2PreCode":"public void testEquals_ObjectList3() { XYPlot p1 = new XYPlot(); p1.setRangeAxis(new NumberAxis(\"A\")); XYPlot p2 = new XYPlot(); p2.setRangeAxis(new NumberAxis(\"A\")); assertEquals(p1, p2); p2.setRangeAxis(1, new NumberAxis(\"B\")); assertNotEquals(p1, p2);",
        "label":0
    },
    {
        "ins1CurCode":"System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); this.launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins1PreCode":"System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins2PreCode":"System.setProperty(\"loader.path\", \"./jars/app.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); launcher.launch(new String[0]); waitFor(\"Hello World\");",
        "label":1
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_16; }",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_15; }",
        "ins2PreCode":"case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[43] = jj_gen; break label_16; }",
        "label":1
    },
    {
        "ins1CurCode":"public void assertTestSubscriberEx() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); oi.subscribe(ts);",
        "ins1PreCode":"public void assertTestSubscriberEx() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "ins2PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"Marker m = new ValueMarker(1.0); plot.addDomainMarker(m); List<EventListener> listeners = Arrays.asList(m.getListeners( MarkerChangeListener.class));",
        "ins1PreCode":"Marker m = new ValueMarker(1.0); plot.addDomainMarker(m); List listeners = Arrays.asList(m.getListeners( MarkerChangeListener.class));",
        "ins2PreCode":"Marker m = new ValueMarker(1.0); plot.addRangeMarker(m); List listeners = Arrays.asList(m.getListeners( MarkerChangeListener.class));",
        "label":1
    },
    {
        "ins1CurCode":"void forwardInSequence() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream();",
        "ins1PreCode":"public void forwardInSequence() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream();",
        "ins2PreCode":"public void forwardOutOfSequence() throws Exception { ByteArrayOutputStream out = new ByteArrayOutputStream();",
        "label":1
    },
    {
        "ins1CurCode":"public void onSuccess(T value) { ExceptionHelper.nullCheck(value, \"onSuccess called with a null value.\"); if (once.compareAndSet(false, true)) {",
        "ins1PreCode":"public void onSuccess(T value) { ObjectHelper.requireNonNull(value, \"onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (once.compareAndSet(false, true)) {",
        "ins2PreCode":"public void onSuccess(@NonNull T value) { ObjectHelper.requireNonNull(value, \"onSuccess called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (once.compareAndSet(false, true)) {",
        "label":1
    },
    {
        "ins1CurCode":"case 101: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(3, 17, 15); break; case 76: case 108: if ((active0 & 0x80000L) != 0L) return jjStartNfaWithStates_0(3, 19, 15); break;",
        "ins1PreCode":"case 101: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(3, 17, 17); break; case 76: case 108: if ((active0 & 0x80000L) != 0L) return jjStartNfaWithStates_0(3, 19, 17); break;",
        "ins2PreCode":"case 101: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 17); break;",
        "label":0
    },
    {
        "ins1CurCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData()); ",
        "ins1PreCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); ",
        "ins2PreCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); ",
        "label":1
    },
    {
        "ins1CurCode":"T t; try { t = Objects.requireNonNull(callable.call(), \"The callable returned a null value\"); } catch (Throwable ex) {",
        "ins1PreCode":"T t; try { t = ObjectHelper.requireNonNull(callable.call(), \"The callable returned a null value\"); } catch (Throwable ex) {",
        "ins2PreCode":"T t; try { t = ObjectHelper.requireNonNull(supplier.get(), \"The supplier returned a null value\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void filterShouldRecordTimer() { ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.statusCode()).willReturn(HttpStatus.OK);",
        "ins1PreCode":"public void filterShouldRecordTimer() { ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")).build(); given(this.response.statusCode()).willReturn(HttpStatus.OK);",
        "ins2PreCode":"ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")) .attribute(URI_TEMPLATE_ATTRIBUTE, \"/projects/{project}\").build();",
        "label":1
    },
    {
        "ins1CurCode":"TomcatServletWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4]; Arrays.setAll(listeners, (i) -> mock(LifecycleListener.class)); factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));",
        "ins1PreCode":"TomcatServletWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4]; Arrays.setAll(listeners, i -> mock(LifecycleListener.class)); factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));",
        "ins2PreCode":"TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; Arrays.setAll(listeners, i -> mock(TomcatContextCustomizer.class)); factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "label":1
    },
    {
        "ins1CurCode":"while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(PAUSE_TIME); }",
        "ins1PreCode":"while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(250); }",
        "ins2PreCode":"public void waitForString(String s, Integer timeout) { InputStream is = this.getInputStream(); try { StringBuffer sb = new StringBuffer(); if (timeout == null || timeout.intValue() == 0) { while (sb.toString().indexOf(s) == -1) { sb.append((char) is.read()); } } else { Calendar endTime = Calendar.getInstance(); endTime.add(Calendar.SECOND, timeout.intValue()); while (sb.toString().indexOf(s) == -1) { while (Calendar.getInstance().before(endTime) && is.available() == 0) { Thread.sleep(WAIT_INTERVAL); } if (is.available() == 0) { log(\"Read before running into timeout: \" + sb.toString(), Project.MSG_DEBUG); throw new BuildException( \"Response timed-out waiting for \\\"\" + s + '\\\"', getLocation()); } sb.append((char) is.read()); } } log(sb.toString(), Project.MSG_INFO); } catch (BuildException be) { throw be; } catch (Exception e) { throw new BuildException(e, getLocation()); }",
        "label":0
    },
    {
        "ins1CurCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Float.class.getCanonicalName()); }",
        "ins1PreCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Float.class.getCanonicalName()); }",
        "ins2PreCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Double.class.getCanonicalName()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void javaBeanDeprecatedPropertyOnClass() throws IOException { process(org.springframework.boot.configurationsample.simple.DeprecatedProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement( org.springframework.boot.configurationsample.simple.DeprecatedProperties.class); JavaBeanPropertyDescriptor property = createPropertyDescriptor( ownerElement, \"name\"); assertItemMetadata(metadataEnv, property).isProperty()",
        "ins1PreCode":"public void javaBeanDeprecatedPropertyOnClass() throws IOException { process(DeprecatedProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv .getRootElement(DeprecatedProperties.class); JavaBeanPropertyDescriptor property = createPropertyDescriptor(ownerElement, \"name\"); assertItemMetadata(metadataEnv, property).isProperty()",
        "ins2PreCode":"public void lombokDeprecatedPropertyOnClass() throws IOException { process(LombokDeprecatedProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv .getRootElement(LombokDeprecatedProperties.class); LombokPropertyDescriptor property = createPropertyDescriptor(ownerElement, \"name\"); assertItemMetadata(metadataEnv, property).isProperty()",
        "label":1
    },
    {
        "ins1CurCode":"return v == 2 ? Flowable.just(3) : Flowable.range(1, 2); } }, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts); ",
        "ins1PreCode":"return v == 2 ? Flowable.just(3) : Flowable.range(1, 2); } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts); ",
        "ins2PreCode":"public void innerWithScalar() { TestSubscriber<Integer> ts = TestSubscriber.create();  Flowable.range(1, 3) .concatMapDelayError(new Function<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Integer v) { return v == 2 ? Flowable.just(3) : Flowable.range(1, 2); } }).subscribe(ts);  ts.assertValues(1, 2, 3, 1, 2); ts.assertNoErrors(); ts.assertComplete();",
        "label":0
    },
    {
        "ins1CurCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\",",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\",",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createScatterPlot(\"Scatter Plot\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"int users = 80; int products = 160; Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, true);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features) .setIterations(iterations) .setImplicitPrefs(true) .setSeed(8675309L) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins1PreCode":"int users = 80; int products = 160; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, true);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.trainImplicit(data.rdd(), features, iterations); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins2PreCode":"int users = 100; int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false);",
        "label":0
    },
    {
        "ins1CurCode":"public static void execute(@NotNull final DBCExecutionContext context) { TasksJob.runTask(\"Commit transaction\", new DBRRunnableWithProgress() { @Override",
        "ins1PreCode":"public static void execute(Shell shell, @NotNull final DBCExecutionContext context) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } } } }); } catch (InvocationTargetException e) { UIUtils.showErrorDialog(shell, \"Commit\", \"Error while committing session\", e); } catch (InterruptedException e) {  }",
        "ins2PreCode":"public static void execute(Shell shell, final DBCExecutionContext context) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\"); try { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } } } }); } catch (InvocationTargetException e) { UIUtils.showErrorDialog(shell, \"Rollback\", \"Error during session rollback\", e); } catch (InterruptedException e) {  }",
        "label":1
    },
    {
        "ins1CurCode":"LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument) .invoke((c) -> c.handle(null)); verifyNoInteractions(callbackInstance);",
        "ins1PreCode":"LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument) .invoke((c) -> c.handle(null)); verifyZeroInteractions(callbackInstance);",
        "ins2PreCode":"void callbacksInvokeWhenHasGenericShouldInvokeCallback() { StringCallback callbackInstance = mock(StringCallback.class); String argument = \"foo\"; LambdaSafe.callbacks(GenericCallback.class, Collections.singleton(callbackInstance), argument) .invoke((c) -> c.handle(argument)); verify(callbackInstance).handle(argument);",
        "label":0
    },
    {
        "ins1CurCode":"}  source.subscribe(new UsingObserver<>(observer, resource, disposer, eager));",
        "ins1PreCode":"}  source.subscribe(new UsingObserver<R>(observer, resource, disposer, eager));",
        "ins2PreCode":"protected void subscribeActual(final SingleObserver<? super T> observer) {  final U resource;  try { resource = resourceSupplier.get(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptyDisposable.error(ex, observer); return; }  SingleSource<? extends T> source;  try { source = Objects.requireNonNull(singleFunction.apply(resource), \"The singleFunction returned a null SingleSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);  if (eager) { try { disposer.accept(resource); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); ex = new CompositeException(ex, exc); } } EmptyDisposable.error(ex, observer); if (!eager) { try { disposer.accept(resource); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); RxJavaPlugins.onError(exc); } } return; }  source.subscribe(new UsingSingleObserver<T, U>(observer, resource, eager, disposer));",
        "label":0
    },
    {
        "ins1CurCode":"public void testInvalidJoinFieldInsideMultiFields() throws Exception { MapperParsingException exc = expectThrows(MapperParsingException.class, () -> createMapperService(mapping(b -> { b.startObject(\"number\"); { b.field(\"type\", \"integer\"); b.startObject(\"fields\"); { b.startObject(\"join_field\"); { b.field(\"type\", \"join\").startObject(\"relations\").field(\"parent\", \"child\").endObject(); } b.endObject(); } b.endObject(); } b.endObject(); }))); assertThat( exc.getRootCause().getMessage(), containsString(\"join field [number.join_field] cannot be added inside an object or in a multi-field\") );",
        "ins1PreCode":"public void testInvalidJoinFieldInsideMultiFields() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"properties\") .startObject(\"number\") .field(\"type\", \"integer\") .startObject(\"fields\") .startObject(\"join_field\") .field(\"type\", \"join\") .startObject(\"relations\") .field(\"parent\", \"child\") .endObject() .endObject() .endObject() .endObject() .endObject().endObject()); IndexService indexService = createIndex(\"test\"); MapperParsingException exc = expectThrows(MapperParsingException.class, () -> indexService.mapperService().merge(\"type\", new CompressedXContent(mapping), MapperService.MergeReason.MAPPING_UPDATE)); assertThat(exc.getRootCause().getMessage(), containsString(\"join field [number.join_field] cannot be added inside an object or in a multi-field\"));",
        "ins2PreCode":"public void testInvalidJoinFieldInsideObject() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"properties\") .startObject(\"object\") .startObject(\"properties\") .startObject(\"join_field\") .field(\"type\", \"join\") .startObject(\"relations\") .field(\"parent\", \"child\") .endObject() .endObject() .endObject() .endObject() .endObject().endObject()); IndexService indexService = createIndex(\"test\"); MapperParsingException exc = expectThrows(MapperParsingException.class, () -> indexService.mapperService().merge(\"type\", new CompressedXContent(mapping), MapperService.MergeReason.MAPPING_UPDATE)); assertThat(exc.getRootCause().getMessage(),",
        "label":0
    },
    {
        "ins1CurCode":"public void testExcludeHasPrecedence() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {",
        "ins1PreCode":"public void testExcludeHasPrecedence() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {",
        "ins2PreCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {",
        "label":1
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposable.empty(); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public void mapWithError() { final List<Throwable> errors = new ArrayList<>(); ",
        "ins1PreCode":"public void mapWithError() { final List<Throwable> errors = new ArrayList<Throwable>(); ",
        "ins2PreCode":"public void mapWithError() { Observable<String> w = Observable.just(\"one\", \"fail\", \"two\", \"three\", \"fail\"); Observable<String> m = w.map(new Function<String, String>() { @Override public String apply(String s) { if (\"fail\".equals(s)) { throw new RuntimeException(\"Forced Failure\"); } return s; } }).doOnError(new Consumer<Throwable>() {  @Override public void accept(Throwable t1) { t1.printStackTrace(); }  });  m.subscribe(stringObserver); verify(stringObserver, times(1)).onNext(\"one\"); verify(stringObserver, never()).onNext(\"two\"); verify(stringObserver, never()).onNext(\"three\"); verify(stringObserver, never()).onComplete(); verify(stringObserver, times(1)).onError(any(Throwable.class));",
        "label":0
    },
    {
        "ins1CurCode":"void lombokInnerClassProperties() { ConfigurationMetadata metadata = compile(LombokInnerClassProperties.class);",
        "ins1PreCode":"public void lombokInnerClassProperties() { ConfigurationMetadata metadata = compile(LombokInnerClassProperties.class);",
        "ins2PreCode":"public void innerClassProperties() { ConfigurationMetadata metadata = compile(InnerClassProperties.class);",
        "label":1
    },
    {
        "ins1CurCode":"if (isUnixStyle) { assertEquals(\"no drives on Unix\", 2, l.length); assertThat(\"sys resolved relative to project's basedir\", l[0], endsWith(\"/sys\")); assertEquals(\"/test\", l[1]); } else if (isNetWare) { assertEquals(\"sys:\\\\test\", l[0].toLowerCase(Locale.US)); assertEquals(\"volumes on NetWare\", 1, l.length); } else { assertEquals(\"no multiple character-length volumes on Windows\", 2, l.length); assertThat(\"sys resolved relative to project's basedir\", l[0], endsWith(\"\\\\sys\")); assertThat(\"test resolved relative to project's basedir\", l[1], endsWith(\"\\\\test\"));",
        "ins1PreCode":"if (isUnixStyle) { assertEquals(\"no drives on Unix\", 2, l.length); assertThat(\"sys resolved relative to project\\'s basedir\", l[0], endsWith(\"/sys\")); assertEquals(\"/test\", l[1]); } else if (isNetWare) { assertEquals(\"sys:\\\\test\", l[0].toLowerCase(Locale.US)); assertEquals(\"volumes on NetWare\", 1, l.length); } else { assertEquals(\"no multiple character-length volumes on Windows\", 2, l.length); assertThat(\"sys resolved relative to project\\'s basedir\", l[0], endsWith(\"\\\\sys\")); assertThat(\"test resolved relative to project\\'s basedir\", l[1], endsWith(\"\\\\test\"));",
        "ins2PreCode":"if (isUnixStyle) { assertEquals(\"no drives on Unix\", 2, l.length); assertThat(\"sys resolved relative to project\\'s basedir\", l[0], endsWith(\"/sys\")); assertEquals(\"/test\", l[1]); } else if (isNetWare) { assertEquals(\"volumes on NetWare\", 1, l.length); assertEquals(\"sys:\\\\test\", l[0].toLowerCase(Locale.US)); } else { assertEquals(\"no multiple character-length volumes on Windows\", 2, l.length); assertThat(\"sys resolved relative to project\\'s basedir\", l[0], endsWith(\"\\\\sys\")); assertThat(\"test resolved relative to project\\'s basedir\", l[1], endsWith(\"\\\\test\"));",
        "label":1
    },
    {
        "ins1CurCode":" try { notification = Objects.requireNonNull(selector.apply(item), \"The selector returned a null Notification\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { notification = ObjectHelper.requireNonNull(selector.apply(item), \"The selector returned a null Notification\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { notification = ObjectHelper.requireNonNull(selector.apply(item), \"The selector returned a null Notification\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "ins2PreCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset( \"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1CurCode":"void testFindFileInSubdirectory() throws Exception {  BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCitationKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[citationkey].*\\\\\\\\.[extension]\", ','); ",
        "ins1PreCode":"public void testFindFileInSubdirectory() throws Exception {  BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ','); ",
        "ins2PreCode":"public void testFindFileNonRecursive() throws Exception {  BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[bibtexkey].*\\\\\\\\.[extension]\", ','); ",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtPredicateMatch() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ",
        "ins1PreCode":"public void assertValueAtPredicateMatch() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "ins2PreCode":"public void assertValueAtInvalidIndex() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"this, table.getAttribute(monitor, fkCol.getName()), this.columns.size(), table.getAttribute(monitor, fkCol.getReferencedColumn().getName())));",
        "ins1PreCode":"this, table.getAttribute(monitor, fkCol.getName()), fkCol.getOrdinalPosition(), table.getAttribute(monitor, fkCol.getReferencedColumn().getName())));",
        "ins2PreCode":"this, table.getAttribute(monitor, fkCol.getName()), fkCol.getOrdinalPosition(), table.getAttribute(monitor, fkCol.getReferencedColumn().getName())));",
        "label":1
    },
    {
        "ins1CurCode":"if (entry == null) { throw new NameNotFoundException (sm.getString(\"namingContext.nameNotBound\", name, name.get(0))); }",
        "ins1PreCode":"if (entry == null) { throw new NameNotFoundException (sm.getString(\"namingContext.nameNotBound\", name.get(0))); }",
        "ins2PreCode":"if (entry == null) { throw new NameNotFoundException (sm.getString(\"namingContext.nameNotBound\", name.get(0))); }",
        "label":1
    },
    {
        "ins1CurCode":"protected Object readResolve() throws ObjectStreamException { try { Class<?> messageClass = resolveMessageClass(); java.lang.reflect.Field defaultInstanceField =",
        "ins1PreCode":"protected Object readResolve() throws ObjectStreamException { try { Class<?> messageClass = Class.forName(messageClassName); java.lang.reflect.Field defaultInstanceField =",
        "ins2PreCode":"private Object readResolveFallback() throws ObjectStreamException { try { Class<?> messageClass = Class.forName(messageClassName); java.lang.reflect.Field defaultInstanceField =",
        "label":1
    },
    {
        "ins1CurCode":"public void fusedEmpty() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fusedEmpty() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void nonfusedEmpty() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.NONE); ",
        "label":1
    },
    {
        "ins1CurCode":"} }) .doOnNext(new Consumer<Observable<Integer>>() { @Override public void accept(Observable<Integer> w) throws Throwable { w.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer()); }",
        "ins1PreCode":"} }) .to(TestHelper.<Observable<Integer>>testConsumer()) .assertSubscribed() .assertNoErrors() .assertNotComplete() .dispose();",
        "ins2PreCode":"} }) .to(TestHelper.<Flowable<Integer>>testConsumer()) .assertSubscribed() .assertNoErrors() .assertNotComplete() .cancel();",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> concatArray(MaybeSource<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins1PreCode":"public static <T> Flowable<T> concatArray(MaybeSource<? extends T>... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins2PreCode":"public static <T> Flowable<T> mergeArray(MaybeSource<? extends T>... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\")); ",
        "ins1PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "ins2PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void assertTestObserver() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<>(); oi.subscribe(subscriber);",
        "ins1PreCode":"public void assertTestObserver() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber);",
        "ins2PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1CurCode":" Collection<Author> result = autoCompleter.call(getRequest((\"Eric\"))); assertEquals(Collections.singletonList(author), result);",
        "ins1PreCode":" Collection<Author> result = autoCompleter.call(getRequest((\"Eric\"))); Assert.assertEquals(Collections.singletonList(author), result);",
        "ins2PreCode":" Collection<Author> result = autoCompleter.call(getRequest((\"von\"))); Assert.assertEquals(Collections.singletonList(author), result);",
        "label":1
    },
    {
        "ins1CurCode":"protected List<String> getArguments(File archive, File serverPortFile) { try { explodeArchive(archive); deleteLauncherClasses(); File targetClasses = populateTargetClasses(archive); File dependencies = populateDependencies(archive); if (archive.getName().endsWith(\".war\")) { populateSrcMainWebapp(); } List<String> classpath = new ArrayList<>(); classpath.add(targetClasses.getAbsolutePath()); for (File dependency : dependencies.listFiles()) { classpath.add(dependency.getAbsolutePath()); } return Arrays.asList(\"-cp\", StringUtils.collectionToDelimitedString(classpath, File.pathSeparator), \"com.example.ResourceHandlingApplication\", serverPortFile.getAbsolutePath()); }",
        "ins1PreCode":"protected List<String> getArguments(File archive) { try { explodeArchive(archive); deleteLauncherClasses(); File targetClasses = populateTargetClasses(archive); File dependencies = populateDependencies(archive); if (archive.getName().endsWith(\".war\")) { populateSrcMainWebapp(); } List<String> classpath = new ArrayList<>(); classpath.add(targetClasses.getAbsolutePath()); for (File dependency : dependencies.listFiles()) { classpath.add(dependency.getAbsolutePath()); } return Arrays.asList(\"-cp\", StringUtils.collectionToDelimitedString(classpath, File.pathSeparator), \"com.example.ResourceHandlingApplication\"); }",
        "ins2PreCode":"protected List<String> getArguments(File archive) { try { explodeArchive(archive, this.exploded); deleteLauncherClasses(); File targetClasses = populateTargetClasses(archive); File dependencies = populateDependencies(archive); File resourcesProject = explodedResourcesProject(dependencies); if (archive.getName().endsWith(\".war\")) { populateSrcMainWebapp(); } List<String> classpath = new ArrayList<>(); classpath.add(targetClasses.getAbsolutePath()); for (File dependency : dependencies.listFiles()) { classpath.add(dependency.getAbsolutePath()); } classpath.add(resourcesProject.getAbsolutePath()); return Arrays.asList(\"-cp\", StringUtils.collectionToDelimitedString(classpath, File.pathSeparator), \"com.example.ResourceHandlingApplication\"); }",
        "label":0
    },
    {
        "ins1CurCode":"Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding)); ",
        "ins1PreCode":"Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences).parse(Importer.getReader(testBibtexFile, encoding)); ",
        "ins2PreCode":"Path testBibtexFile = Paths.get(\"src/test/resources/testbib/unknownMetaData.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences).parse(Importer.getReader(testBibtexFile, encoding)); ",
        "label":1
    },
    {
        "ins1CurCode":"public void setShowAssociationNames(final boolean showem) { if (diaDefault.isShowAssociationNames() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_ASSOCIATION_NAMES;  public void redo() { diaDefault.setShowAssociationNames(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { diaDefault.setShowAssociationNames(!showem); fireNotationEvent(key, showem, !showem); } }; doUndoable(memento);",
        "ins1PreCode":"public void setShowAssociationNames(final boolean showem) { if (showAssociationNames == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_ASSOCIATION_NAMES;  public void redo() { showAssociationNames = showem; fireNotationEvent(key, !showem, showem); }  public void undo() { showAssociationNames = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "ins2PreCode":"public void setShowProperties(final boolean showem) { if (showProperties == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES;  public void redo() { showProperties = showem; fireNotationEvent(key, !showem, showem); }  public void undo() { showProperties = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "label":1
    },
    {
        "ins1CurCode":"6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins1PreCode":"6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtilities.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testEquals() { DefaultBoxAndWhiskerXYDataset d1 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); DefaultBoxAndWhiskerXYDataset d2 = new DefaultBoxAndWhiskerXYDataset( \"Series\"); assertTrue(d1.equals(d2));  d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertFalse(d1.equals(d2)); d2.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertTrue(d1.equals(d2));",
        "label":0
    },
    {
        "ins1CurCode":"nMatchingItems++; } if (nMatchingItems == 0) { continue; } int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : tde.getToDoItemList()) { if (!item.supports(g)) { continue; } childIndices[nMatchingItems] = getIndexOfChild(g, item); children[nMatchingItems] = item; nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins1PreCode":"nMatchingItems++; } if (nMatchingItems == 0) continue; int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : tde.getToDoItemList()) { if (!item.supports(g)) { continue; } childIndices[nMatchingItems] = getIndexOfChild(g, item); children[nMatchingItems] = item; nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins2PreCode":"nMatchingItems++; } fireTreeNodesInserted(this, path, childIndices, children); }",
        "label":0
    },
    {
        "ins1CurCode":"public void loadDefaultPropertiesFile() { this.environment.setDefaultProfiles(\"thedefault\");",
        "ins1PreCode":"public void loadDefaultPropertiesFile() throws Exception { this.environment.setDefaultProfiles(\"thedefault\");",
        "ins2PreCode":"public void loadTwoPropertiesFile() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1CurCode":"public boolean validateObject(final UserPassKey key, final PooledObject<PooledConnectionAndInfo> p) { try { validateLifetime(p); } catch (final Exception e) { return false; } boolean valid = false; final PooledConnection pconn = p.getObject().getPooledConnection(); Connection conn = null; validatingSet.add(pconn); if (null == _validationQuery) { int timeout = _validationQueryTimeout; if (timeout < 0) { timeout = 0; } try { conn = pconn.getConnection(); valid = conn.isValid(timeout); } catch (final SQLException e) { valid = false; } finally { Utils.closeQuietly(conn); validatingSet.remove(pconn); } } else { Statement stmt = null; ResultSet rset = null;     validatingSet.add(pconn); try { conn = pconn.getConnection(); stmt = conn.createStatement(); rset = stmt.executeQuery(_validationQuery); if (rset.next()) { valid = true; } else { valid = false; } if (_rollbackAfterValidation) { conn.rollback(); } } catch(final Exception e) { valid = false;",
        "ins1PreCode":"public boolean validateObject(UserPassKey key, PooledObject<PooledConnectionAndInfo> p) { try { validateLifetime(p); } catch (Exception e) { return false; } boolean valid = false; PooledConnection pconn = p.getObject().getPooledConnection(); Connection conn = null; validatingSet.add(pconn); if (null == _validationQuery) { int timeout = _validationQueryTimeout; if (timeout < 0) { timeout = 0; } try { conn = pconn.getConnection(); valid = conn.isValid(timeout); } catch (SQLException e) { valid = false; } finally { Utils.closeQuietly(conn); validatingSet.remove(pconn); } } else { Statement stmt = null; ResultSet rset = null;     validatingSet.add(pconn); try { conn = pconn.getConnection(); stmt = conn.createStatement(); rset = stmt.executeQuery(_validationQuery); if (rset.next()) { valid = true; } else { valid = false; } if (_rollbackAfterValidation) { conn.rollback(); } } catch(Exception e) { valid = false;",
        "ins2PreCode":"public boolean validateObject(PooledObject<PooledConnectionAndInfo> p) { try { validateLifetime(p); } catch (Exception e) { return false; } boolean valid = false; PooledConnection pconn = p.getObject().getPooledConnection(); Connection conn = null; validatingSet.add(pconn); if (null == _validationQuery) { int timeout = _validationQueryTimeout; if (timeout < 0) { timeout = 0; } try { conn = pconn.getConnection(); valid = conn.isValid(timeout); } catch (SQLException e) { valid = false; } finally { Utils.closeQuietly(conn); validatingSet.remove(pconn); } } else { Statement stmt = null; ResultSet rset = null;     validatingSet.add(pconn); try { conn = pconn.getConnection(); stmt = conn.createStatement(); rset = stmt.executeQuery(_validationQuery); if (rset.next()) { valid = true; } else { valid = false; } if (_rollbackAfterValidation) { conn.rollback(); } } catch (Exception e) { valid = false;",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void asyncFusedBoundary() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ASYNC | QueueFuseable.BOUNDARY); ",
        "ins1PreCode":"public void asyncFusedBoundary() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ASYNC | QueueFuseable.BOUNDARY); ",
        "ins2PreCode":"public void asyncFusedBoundaryConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ASYNC | QueueFuseable.BOUNDARY); ",
        "label":1
    },
    {
        "ins1CurCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasBinaryContent(new byte[] { 3 }); }",
        "ins1PreCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "ins2PreCode":"JarURLConnection connection = JarURLConnection.get(url, this.jarFile); try (InputStream input = connection.getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "label":1
    },
    {
        "ins1CurCode":"TimeSeries series = new TimeSeries(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42);  TimeSeries clone; clone = (TimeSeries) series.clone(); clone.setKey(\"Clone Series\"); clone.update(jan1st2002, 10); ",
        "ins1PreCode":"TimeSeries series = new TimeSeries(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, new Integer(42));  TimeSeries clone; clone = (TimeSeries) series.clone(); clone.setKey(\"Clone Series\"); clone.update(jan1st2002, new Integer(10)); ",
        "ins2PreCode":"TimePeriodValues series = new TimePeriodValues(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, new Integer(42)); TimePeriodValues clone = (TimePeriodValues) series.clone(); clone.setKey(\"Clone Series\"); clone.update(0, new Integer(10)); ",
        "label":1
    },
    {
        "ins1CurCode":"}  Container host = engine.findChild(name);   if (host == null) { writer.println (sm.getString(\"hostManagerServlet.noHost\", name)); return; }   if (host == installedHost) { writer.println (sm.getString(\"hostManagerServlet.cannotStartOwnHost\", name)); return; }   try { host.start(); writer.println",
        "ins1PreCode":"  if (engine.findChild(name) == null) { writer.println (sm.getString(\"hostManagerServlet.noHost\", name)); return; }   if (engine.findChild(name) == installedHost) { writer.println (sm.getString(\"hostManagerServlet.cannotStartOwnHost\", name)); return; }   try { engine.findChild(name).start(); writer.println",
        "ins2PreCode":"  if (engine.findChild(name) == null) { writer.println (sm.getString(\"hostManagerServlet.noHost\", name)); return; }   if (engine.findChild(name) == installedHost) { writer.println (sm.getString(\"hostManagerServlet.cannotStopOwnHost\", name)); return; }   try { engine.findChild(name).stop(); writer.println",
        "label":1
    },
    {
        "ins1CurCode":"public void requestThroughTakeThatReducesRequest() { TestSubscriber<Integer> ts = new TestSubscriber<>(0L); ts.request(3);",
        "ins1PreCode":"public void requestThroughTakeThatReducesRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ts.request(3);",
        "ins2PreCode":"public void requestThroughTakeWhereRequestIsSmallerThanTake() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ts.request(3);",
        "label":1
    },
    {
        "ins1CurCode":"public static void main(String[] args) { SparkSession spark = SparkSession.builder().appName(\"JavaMinMaxScalerExample\").getOrCreate();   Dataset<Row> dataFrame = spark.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MinMaxScaler scaler = new MinMaxScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MinMaxScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  spark.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JaveMinMaxScalerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MinMaxScaler scaler = new MinMaxScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MinMaxScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  jsc.stop();",
        "ins2PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaMaxAbsScalerExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   Dataset<Row> dataFrame = jsql.read().format(\"libsvm\").load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  jsc.stop();",
        "label":0
    },
    {
        "ins1CurCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1); return ChartFactory.createXYLineChart(\"XY Line Chart\", \"Domain\",",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYLineChart(\"XY Line Chart\", \"Domain\",",
        "ins2PreCode":"private static JFreeChart createChart() { XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<String>(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset);",
        "label":0
    },
    {
        "ins1CurCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"TestObserver<Integer> to = new TestObserver<Integer>();  to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"byte[] token = dotConcat(Base64Utils.encodeUrlSafe(header), Base64Utils.encodeUrlSafe(claims), Base64Utils.encodeUrlSafe(crypto)); return new String(token, StandardCharsets.UTF_8);",
        "ins1PreCode":"byte[] token = dotConcat(Base64Utils.encodeUrlSafe(header), Base64Utils.encodeUrlSafe(claims), Base64Utils.encodeUrlSafe(crypto)); return new String(token, UTF_8);",
        "ins2PreCode":"byte[] token = dotConcat(Base64Utils.encodeUrlSafe(header), Base64Utils.encodeUrlSafe(claims), Base64Utils.encodeUrlSafe(crypto)); return new String(token, UTF_8);",
        "label":1
    },
    {
        "ins1CurCode":"}, mapFactory).toFlowable();  Map<Integer, String> expected = new LinkedHashMap<>(); expected.put(2, \"bb\");",
        "ins1PreCode":"}, mapFactory).toFlowable();  Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\");",
        "ins2PreCode":"}, mapFactory).toObservable();  Map<Integer, String> expected = new LinkedHashMap<Integer, String>(); expected.put(2, \"bb\");",
        "label":1
    },
    {
        "ins1CurCode":"private void testTotalSizeCapProperty(String sizeValue, String expectFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext( environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\"); assertThat(ReflectionTestUtils.getField(getRollingPolicy(), \"totalSizeCap\") .toString()).isEqualTo(expectFileSize);",
        "ins1PreCode":"public void testTotalSizeCapProperty() { String expectedSize = \"101 MB\"; MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", expectedSize); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext( environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\"); assertThat(ReflectionTestUtils.getField(getRollingPolicy(), \"totalSizeCap\") .toString()).isEqualTo(expectedSize);",
        "ins2PreCode":"public void testMaxHistoryPropertyWithXmlConfiguration() throws Exception { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext( environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\"); assertThat(getRollingPolicy().getMaxHistory()).isEqualTo(30);",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"public void testCreateWithInvalidPattern() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "ins1PreCode":"public void testCreateWithInvalidPattern() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap()); Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"public void testCreateWithInvalidPatternDefinition() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap()); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception(sm.getString(\"mBeanUtils.noManagedBean\", mname)); throw new MBeanException(e);",
        "ins1PreCode":"ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception(\"ManagedBean is not found with \"+mname); throw new MBeanException(e);",
        "ins2PreCode":"ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception(\"ManagedBean is not found with \"+mname); throw new MBeanException(e);",
        "label":1
    },
    {
        "ins1CurCode":"if (System.getProperty(\"print-thread-stats\")!=null) { System.out.println(\"[\"+getName()+\"] \"+ \"\\n\\tMax time to retrieve connection:\"+maxwait/1000000f+\" ms.\"+ \"\\n\\tTotal time to retrieve connection:\"+totalwait/1000000f+\" ms.\"+ \"\\n\\tAverage time to retrieve connection:\"+totalwait/1000000f/nroffetch+\" ms.\"+ \"\\n\\tMax time to close connection:\"+cmax/1000000f+\" ms.\"+ \"\\n\\tTotal time to close connection:\"+totalcmax/1000000f+\" ms.\"+ \"\\n\\tAverage time to close connection:\"+totalcmax/1000000f/nroffetch+\" ms.\"+ \"\\n\\tRun time:\"+totalruntime/1000000f+\" ms.\"+ \"\\n\\tNr of fetch:\"+nroffetch);",
        "ins1PreCode":"if (System.getProperty(\"print-thread-stats\")!=null) { System.out.println(\"[\"+getName()+\"] \"+ \"\\n\\tMax time to retrieve connection:\"+(((float)maxwait)/1000f/1000f)+\" ms.\"+ \"\\n\\tTotal time to retrieve connection:\"+(((float)totalwait)/1000f/1000f)+\" ms.\"+ \"\\n\\tAverage time to retrieve connection:\"+(((float)totalwait)/1000f/1000f)/(float)nroffetch+\" ms.\"+ \"\\n\\tMax time to close connection:\"+(((float)cmax)/1000f/1000f)+\" ms.\"+ \"\\n\\tTotal time to close connection:\"+(((float)totalcmax)/1000f/1000f)+\" ms.\"+ \"\\n\\tAverage time to close connection:\"+(((float)totalcmax)/1000f/1000f)/(float)nroffetch+\" ms.\"+ \"\\n\\tRun time:\"+(((float)totalruntime)/1000f/1000f)+\" ms.\"+ \"\\n\\tNr of fetch:\"+nroffetch);",
        "ins2PreCode":"if (System.getProperty(\"print-thread-stats\")!=null) { System.out.println(\"[\"+getName()+\"] \"+ \"\\n\\tMax time to retrieve connection:\"+(((float)maxwait)/1000f/1000f)+\" ms.\"+ \"\\n\\tTotal time to retrieve connection:\"+(((float)totalwait)/1000f/1000f)+\" ms.\"+ \"\\n\\tAverage time to retrieve connection:\"+(((float)totalwait)/1000f/1000f)/(float)nroffetch+\" ms.\"+ \"\\n\\tMax time to close connection:\"+(((float)cmax)/1000f/1000f)+\" ms.\"+ \"\\n\\tTotal time to close connection:\"+(((float)totalcmax)/1000f/1000f)+\" ms.\"+ \"\\n\\tAverage time to close connection:\"+(((float)totalcmax)/1000f/1000f)/(float)nroffetch+\" ms.\"+ \"\\n\\tRun time:\"+(((float)totalruntime)/1000f/1000f)+\" ms.\"+ \"\\n\\tNr of fetch:\"+nroffetch);",
        "label":1
    },
    {
        "ins1CurCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildSiteUrlInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins1PreCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins2PreCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "label":0
    },
    {
        "ins1CurCode":"public void edgeOrder_insertion() { MutableNetwork<Integer, String> network = NetworkBuilder .directed() .edgeOrder(insertion()) .build();  addEdges(network);  assertThat(network.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(network.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "ins1PreCode":"public void edgeOrder_insertion() { MutableNetwork<Integer, String> graph = NetworkBuilder .directed() .edgeOrder(insertion()) .build();  addEdges(graph);  assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "ins2PreCode":"public void edgeOrder_default() { MutableNetwork<Integer, String> graph = NetworkBuilder .directed() .build();  addEdges(graph);  assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtInvalidIndex() { assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1PreCode":"Flowable.just(1, 2).subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); ts.assertValueAt(2, new Predicate<Integer>() {",
        "ins2PreCode":"public void assertValueAtPredicateMatch() { TestSubscriber<Integer> ts = new TestSubscriber<>();  Flowable.just(1, 2).subscribe(ts);  ts.assertValueAt(1, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 2; } });",
        "label":0
    },
    {
        "ins1CurCode":"protected AbstractProject getBuildingDownstream() { Set<Task> unblockedTasks = Hudson.getInstance().getQueue().getUnblockedTasks();  for (AbstractProject tup : Hudson.getInstance().getDependencyGraph().getTransitiveDownstream(this)) { if (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup))) return tup;",
        "ins1PreCode":"protected AbstractProject getBuildingDownstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue(); ItemList<Queue.Item> unblockedItems = queue.getUnblockedItems(); for (AbstractProject tup : tups) { if(tup.isBuilding() || unblockedItems.containsKey(tup)) return tup;",
        "ins2PreCode":"protected AbstractProject getBuildingUpstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); for (AbstractProject tup : tups) { if(tup.isBuilding() || tup.isInQueue()) return tup;",
        "label":0
    },
    {
        "ins1CurCode":"if (storage == null && blob != null) { long contentLength = getContentLength(); DBPPlatform platform = executionContext.getDataSource().getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = blob.getBinaryStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, executionContext); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, executionContext); }",
        "ins1PreCode":"if (storage == null && blob != null) { long contentLength = getContentLength(); DBPPlatform platform = dataSource.getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = blob.getBinaryStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); }",
        "ins2PreCode":"openFile(); long contentLength = getContentLength(); DBPPlatform platform = dataSource.getContainer().getPlatform(); if (contentLength < platform.getPreferenceStore().getInt(ModelPreferences.MEMORY_CONTENT_MAX_SIZE)) { try { try (InputStream bs = getInputStream()) { storage = BytesContentStorage.createFromStream( bs, contentLength, getDefaultEncoding()); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + bfile.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = getInputStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); }",
        "label":0
    },
    {
        "ins1CurCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); skipTokens(st, 1); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins1PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins2PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "label":0
    },
    {
        "ins1CurCode":"  Assert.assertTrue(headers.get(\"Content-Type\").get(0).startsWith(\"text/html\"));",
        "ins1PreCode":"  assertTrue(headers.get(\"Content-Type\").get(0).startsWith(\"text/html\"));",
        "ins2PreCode":"  assertTrue(headers.get(\"Content-Type\").get(0).startsWith(\"text/plain\"));",
        "label":1
    },
    {
        "ins1CurCode":"if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && jreCompat.canAccess(null, field)) { return field.get(null);",
        "ins1PreCode":"if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && jreCompat.canAcccess(null, field)) { return field.get(null);",
        "ins2PreCode":"if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers) && jreCompat.canAcccess(null, field)) { return field.getType();",
        "label":1
    },
    {
        "ins1CurCode":"dataset1.addValue(25.0, \"R5\", \"C1\"); CategoryStepRenderer r = new CategoryStepRenderer(); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r);",
        "ins1PreCode":"dataset1.addValue(25.0, \"R5\", \"C1\"); CategoryStepRenderer r = new CategoryStepRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r);",
        "ins2PreCode":"dataset1.addValue(25.0, \"R5\", \"C1\"); BoxAndWhiskerRenderer r = new BoxAndWhiskerRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r);",
        "label":1
    },
    {
        "ins1CurCode":"Assert.assertTrue(body, body.contains(\"ServletName=[Include]\"));  Assert.assertTrue(body, body.contains(\"IncludeMatchValue=[mapping]\")); Assert.assertTrue(body, body.contains(\"IncludePattern=[/mapping]\"));",
        "ins1PreCode":"Assert.assertTrue(body, body.contains(\"ServletName=[Include]\"));  Assert.assertTrue(body, body.contains(\"IncludeMatchValue=[/mapping]\")); Assert.assertTrue(body, body.contains(\"IncludePattern=[/mapping]\"));",
        "ins2PreCode":"private void doTestMappingNamedInclude(String contextPath, String mapping, String requestPath, String matchValue, String matchType) throws Exception { Tomcat tomcat = getTomcatInstance();   Context ctx = tomcat.addContext(contextPath, null);  Tomcat.addServlet(ctx, \"Include\", new NamedIncludeServlet()); ctx.addServletMappingDecoded(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMappingDecoded(\"/mapping\", \"Mapping\");  tomcat.start();  ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + contextPath + requestPath); String body = bc.toString();  Assert.assertTrue(body, body.contains(\"MatchValue=[\" + matchValue + \"]\")); Assert.assertTrue(body, body.contains(\"Pattern=[\" + mapping + \"]\")); Assert.assertTrue(body, body.contains(\"MatchType=[\" + matchType + \"]\")); Assert.assertTrue(body, body.contains(\"ServletName=[Include]\"));",
        "label":0
    },
    {
        "ins1CurCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":".replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<>(); source.subscribe(to);  to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); to.assertNotComplete(); Assert.assertEquals(1, to.errors().size());  TestObserverEx<Integer> to2 = new TestObserverEx<>(); source.subscribe(to2);",
        "ins1PreCode":".replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); source.subscribe(to);  to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); to.assertNotComplete(); Assert.assertEquals(1, to.errors().size());  TestObserverEx<Integer> to2 = new TestObserverEx<Integer>(); source.subscribe(to2);",
        "ins2PreCode":".replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); source.subscribe(to);  to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); to.assertNotComplete(); Assert.assertEquals(1, to.errors().size());  TestObserverEx<Integer> to2 = new TestObserverEx<Integer>(); source.subscribe(to2);",
        "label":1
    },
    {
        "ins1CurCode":"  ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wlEntries.containsKey(filepath)) {   JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);  if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } } else {  log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile)); newJarStream.setLevel(0);   for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {  is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); }  if (genericLoader instanceof AntClassLoader) { AntClassLoader loader = (AntClassLoader)genericLoader; loader.cleanup(); }",
        "ins1PreCode":"  ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile); ",
        "ins2PreCode":"protected boolean isRebuildRequired(File genericJarFile, File websphereJarFile)  {  boolean rebuild = false;    JarFile genericJar = null;  JarFile wasJar = null;  File newwasJarFile = null;  JarOutputStream newJarStream = null;    try  {  log(\"Checking if websphere Jar needs to be rebuilt for jar \" + websphereJarFile.getName(),  Project.MSG_VERBOSE);    if (genericJarFile.exists() && genericJarFile.isFile()  && websphereJarFile.exists() && websphereJarFile.isFile())  {    genericJar = new JarFile(genericJarFile);  wasJar = new JarFile(websphereJarFile);    Hashtable genericEntries = new Hashtable();  Hashtable wasEntries = new Hashtable();  Hashtable replaceEntries = new Hashtable();      for (Enumeration e = genericJar.entries(); e.hasMoreElements();)  {  JarEntry je = (JarEntry)e.nextElement();  genericEntries.put(je.getName().replace('\\\\', '/'), je);  }    for (Enumeration e = wasJar.entries() ; e.hasMoreElements();)  {  JarEntry je = (JarEntry)e.nextElement();  wasEntries.put(je.getName(), je);  }      ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();)  {  String filepath = (String)e.nextElement();  if (wasEntries.containsKey(filepath))  {    JarEntry genericEntry = (JarEntry)genericEntries.get(filepath);  JarEntry wasEntry = (JarEntry)wasEntries.get(filepath);  if ((genericEntry.getCrc() !=  wasEntry.getCrc())  ||  (genericEntry.getSize() != wasEntry.getSize()) )  {  if (genericEntry.getName().endsWith(\".class\"))  {    String classname = genericEntry.getName().replace(File.separatorChar,'.');  classname = classname.substring(0,classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface())  {    log(\"Interface \" + genclass.getName() + \" has changed\",Project.MSG_VERBOSE);  rebuild = true;  break;  }  else  {    replaceEntries.put(filepath, genericEntry);  }  }  else  {    if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {    log(\"Non class file \" + genericEntry.getName() + \" has changed\",Project.MSG_VERBOSE);  rebuild = true;  }  break;  }  }  }  else  {  log(\"File \" + filepath + \" not present in websphere jar\",Project.MSG_VERBOSE);  rebuild =  true;  break;  }  }    if (!rebuild)  {  log(\"No rebuild needed - updating jar\",Project.MSG_VERBOSE);  newwasJarFile = new File(websphereJarFile.getAbsolutePath() + \".temp\");  if (newwasJarFile.exists()) {  newwasJarFile.delete();  }    newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile));  newJarStream.setLevel(0);      for (Enumeration e = wasEntries.elements() ; e.hasMoreElements();)  {  byte[] buffer = new byte[1024];  int bytesRead;  InputStream is;  JarEntry je = (JarEntry)e.nextElement();  if (je.getCompressedSize() == -1 ||  je.getCompressedSize() == je.getSize()) {  newJarStream.setLevel(0);  }  else {  newJarStream.setLevel(9);  }      if (replaceEntries.containsKey(je.getName()))  {  log(\"Updating Bean class from generic Jar \" + je.getName(),  Project.MSG_VERBOSE);    je = (JarEntry)replaceEntries.get(je.getName());  is = genericJar.getInputStream(je);  }  else  {  is = wasJar.getInputStream(je);  }  newJarStream.putNextEntry(new JarEntry(je.getName()));    while ((bytesRead = is.read(buffer)) != -1)  {  newJarStream.write(buffer,0,bytesRead);  }  is.close();  }  }  else  {  log(\"websphere Jar rebuild needed due to changed interface or XML\",Project.MSG_VERBOSE);  }  }  else  {  rebuild = true;  }  }  catch(ClassNotFoundException cnfe)  {  String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\"  + \". Details: \"  + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe);  }  catch(IOException ioe) {  String msg = \"IOException while processing ejb-jar file \"  + \". Details: \"  + ioe.getMessage();  throw new BuildException(msg, ioe);  }  finally {    if (genericJar != null) {  try {  genericJar.close();  }  catch (IOException closeException) {}  }    if (wasJar != null) {  try {  wasJar.close();  }  catch (IOException closeException) {}  }    if (newJarStream != null) {  try {  newJarStream.close();  }  catch (IOException closeException) {}    websphereJarFile.delete();  newwasJarFile.renameTo(websphereJarFile);  if (!websphereJarFile.exists()) {  rebuild = true;  }  }  }    return rebuild; ",
        "label":0
    },
    {
        "ins1CurCode":".test();  assertFalse(\"Subject still has observers!\", ps.hasObservers()); ",
        "ins1PreCode":".test();  assertFalse(\"Subject still has subscribers!\", ps.hasObservers()); ",
        "ins2PreCode":".test();  assertFalse(\"Subject still has subscribers!\", ps.hasObservers()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testClear() { VectorSeries<String> s1 = new VectorSeries<>(\"S1\"); s1.addChangeListener(this);",
        "ins1PreCode":"public void testClear() { VectorSeries s1 = new VectorSeries(\"S1\"); s1.addChangeListener(this);",
        "ins2PreCode":"public void testClear() { OHLCSeries s1 = new OHLCSeries(\"S1\"); s1.addChangeListener(this);",
        "label":1
    },
    {
        "ins1CurCode":"ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new INSPIREFetcher(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new ACMPortalFetcher(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new SpringerFetcher()); list.add(new CrossRef()); list.add(new CiteSeer()); list.add(new DOAJFetcher(importFormatPreferences)); list.add(new IEEE(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName));",
        "ins1PreCode":"ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new CrossRef()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"public static List<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<IdBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new IsbnFetcher(importFormatPreferences)); list.add(new DiVA(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new MedlineFetcher()); list.add(new TitleFetcher(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress(importFormatPreferences)); list.add(new IacrEprintFetcher(importFormatPreferences)); list.add(new RfcFetcher(importFormatPreferences)); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "label":0
    },
    {
        "ins1CurCode":"protected AbstractProject getBuildingUpstream() { Set<Task> unblockedTasks = Hudson.getInstance().getQueue().getUnblockedTasks();  for (AbstractProject tup : Hudson.getInstance().getDependencyGraph().getTransitiveUpstream(this)) { if (tup!=this && (tup.isBuilding() || unblockedTasks.contains(tup))) return tup;",
        "ins1PreCode":"protected AbstractProject getBuildingUpstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); for (AbstractProject tup : tups) { if(tup.isBuilding() || tup.isInQueue()) return tup;",
        "ins2PreCode":"protected AbstractProject getBuildingDownstream() { DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue(); ItemList<Queue.Item> unblockedItems = queue.getUnblockedItems(); for (AbstractProject tup : tups) { if(tup.isBuilding() || unblockedItems.containsKey(tup)) return tup;",
        "label":0
    },
    {
        "ins1CurCode":" builder = message.toBuilder(); setMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesUpdated(message);  builder = message.toBuilder(); builder.clear(); assertMapValuesCleared(builder); message = builder.build();",
        "ins1PreCode":" builder = message.toBuilder(); setMapValues(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build();",
        "ins2PreCode":"builder = message.toBuilder(); builder.clear(); message = builder.build(); assertMapValuesCleared(message);",
        "label":0
    },
    {
        "ins1CurCode":"ByteEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]); ",
        "ins1PreCode":"ByteEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = new Integer(countA[0]); ",
        "ins2PreCode":"CharEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = new Integer(countA[0]); ",
        "label":1
    },
    {
        "ins1CurCode":"return null; } else { return new ArrayList<>(); }",
        "ins1PreCode":"return null; } else { return new ArrayList<Integer>(); }",
        "ins2PreCode":"return null; } else { return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testPropertyContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyContext\");",
        "ins1PreCode":"public void testPropertyContext() throws Exception { final SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyContext\"); Map<String, String> map = results.get(0); assertEquals(2, map.size()); assertEquals(\"col_a value\", map.get(\"COL_A\")); assertEquals(\"col_b value\", map.get(\"COL_B\")); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testParametersInAttribute() throws Exception { final SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyInAttribute\"); Map<String, String> map = results.get(0); assertEquals(2, map.size()); assertEquals(\"col_a value\", map.get(\"COL_1\")); assertEquals(\"col_b value\", map.get(\"COL_2\")); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception { givenScheduleAtFixedRateWithReturnFuture(); PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry,",
        "ins1PreCode":"void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, ShutdownOperation.PUSH);",
        "ins2PreCode":"void shutdownWhenShutdownOperationIsNoneDoesNothing() { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, ShutdownOperation.NONE);",
        "label":1
    },
    {
        "ins1CurCode":"} assertTrue(CLASSNAME + \" must capture the right bytes\", stillEqual); assertFalse(CLASSNAME + \" must have exhausted the iterator\", iter.hasNext()); ",
        "ins1PreCode":"} assertTrue(CLASSNAME + \" must capture the right bytes\", stillEqual); assertFalse(CLASSNAME + \" must have exhausted the itertor\", iter.hasNext()); ",
        "ins2PreCode":"} assertTrue(classUnderTest + \" must capture the right bytes\", stillEqual); assertFalse(classUnderTest + \" must have exhausted the itertor\", iter.hasNext()); ",
        "label":1
    },
    {
        "ins1CurCode":"modelImpl, run, \"Set the # as the specific classifier \" + \"of the generalization #\", child, handle));",
        "ins1PreCode":"modelImpl, run, \"Set the # as the specific classifier of the generalization #\", child, handle));",
        "ins2PreCode":"modelImpl, run, \"Set the # as the general classifier of the generalization #\", parent, handle));",
        "label":1
    },
    {
        "ins1CurCode":"return; } Collection<Marker> markers = getDomainMarkers(index, layer); ValueAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { for (Marker marker : markers) { r.drawDomainMarker(g2, this, axis, marker, dataArea);",
        "ins1PreCode":"return; } Collection markers = getDomainMarkers(index, layer); ValueAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next(); r.drawDomainMarker(g2, this, axis, marker, dataArea);",
        "ins2PreCode":"return; } Collection markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next(); r.drawRangeMarker(g2, this, axis, marker, dataArea);",
        "label":1
    },
    {
        "ins1CurCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"long o = 0; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"long o = 0; ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"long o = 0; ArrayList b = (ArrayList)o;\"));",
        "ins1PreCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"long o = 0; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"long o = (long)0; ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"long o = (long)0; ArrayList b = (ArrayList)o;\"));",
        "ins2PreCode":"public void testPrimitiveIntCasts() { expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Object n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Object n = (Object)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Number n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Number n = (Number)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; String n = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; String n = (String)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; boolean b = (boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; byte b = o;\")); exec(\"int o = 0; byte b = (byte)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; short b = o;\")); exec(\"int o = 0; short b = (short)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; char b = o;\")); exec(\"int o = 0; char b = (char)o;\");  exec(\"int o = 0; int b = o;\"); exec(\"int o = 0; int b = (int)o;\");  exec(\"int o = 0; long b = o;\"); exec(\"int o = 0; long b = (long)o;\");  exec(\"int o = 0; float b = o;\"); exec(\"int o = 0; float b = (float)o;\");  exec(\"int o = 0; double b = o;\"); exec(\"int o = 0; double b = (double)o;\");  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Boolean b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Boolean b = (Boolean)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Byte b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Byte b = (Byte)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Short b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Short b = (Short)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Character b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Character b = (Character)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Integer b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Integer b = (Integer)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Long b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Long b = (Long)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Float b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Float b = (Float)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Double b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; Double b = (Double)o;\"));  expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; ArrayList b = o;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"int o = 0; ArrayList b = (ArrayList)o;\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void testCreateWithInvalidPattern() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "ins1PreCode":"public void testCreateWithInvalidPattern() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"public void testCreateWithInvalidPatternDefinition() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"return Observable.just(1); } }, true, 16));",
        "ins1PreCode":"return Observable.just(1); } }, 16, true));",
        "ins2PreCode":"return Flowable.just(1); } }, 16, true));",
        "label":1
    },
    {
        "ins1CurCode":"public void testDataSendASYNC() throws Exception { System.err.println(\"Starting ASYNC\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_UDP); ",
        "ins1PreCode":"public void testDataSendASYNC() throws Exception { System.err.println(\"Starting ASYNC\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_UDP); ",
        "ins2PreCode":"public void testDataSendASYNC() throws Exception { System.err.println(\"Starting ASYNC\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_MULTICAST); ",
        "label":1
    },
    {
        "ins1CurCode":"void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyObjectXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"Assume.assumeTrue( \"Only supported on NIO 2\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Nio2\")); ",
        "ins1PreCode":"Assume.assumeTrue( \"Only supported on NIO 2\", getTomcatInstance().getConnector().getProtocol() .equals(\"org.apache.coyote.http11.Http11Nio2Protocol\")); ",
        "ins2PreCode":"private void doTestMessages ( Class<? extends HttpUpgradeHandler> upgradeHandlerClass) throws Exception { UpgradeConnection uc = doUpgrade(upgradeHandlerClass); PrintWriter pw = new PrintWriter(uc.getWriter()); BufferedReader reader = uc.getReader();  pw.println(MESSAGE); pw.flush();  Thread.sleep(500);  pw.println(MESSAGE); pw.flush();  uc.shutdownOutput();    String response = reader.readLine(); Assert.assertEquals(MESSAGE, response); response = reader.readLine(); Assert.assertEquals(MESSAGE, response);  uc.shutdownInput();",
        "label":0
    },
    {
        "ins1CurCode":"public final <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull R> Observable<R> withLatestFrom( @NonNull ObservableSource<T1> source1, @NonNull ObservableSource<T2> source2,",
        "ins1PreCode":"public final <T1, T2, T3, R> Observable<R> withLatestFrom( @NonNull ObservableSource<T1> source1, @NonNull ObservableSource<T2> source2,",
        "ins2PreCode":"public final <T1, T2, T3, @NonNull R> Flowable<R> withLatestFrom( @NonNull Publisher<T1> source1, @NonNull Publisher<T2> source2,",
        "label":0
    },
    {
        "ins1CurCode":"configuration.addMapper(ResultMapReferencePersonMapper.class); configuration.addMapper(ResultMapReferencePetMapper.class); c.close(); ",
        "ins1PreCode":"configuration.addMapper(ResultMapReferencePersonMapper.class); configuration.addMapper(ResultMapReferencePetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"configuration.addMapper(PersonMapper.class); configuration.addMapper(PetMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindLiveItemsUpperBound_Unordered() { DefaultXYDataset<String> d = new DefaultXYDataset<>(); ",
        "ins1PreCode":"public void testFindLiveItemsUpperBound_Unordered() { DefaultXYDataset d = new DefaultXYDataset(); ",
        "ins2PreCode":"public void testFindLiveItemsLowerBound_Descending() { DefaultXYDataset d = new DefaultXYDataset() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"}  super.saveSettings(dataSource);",
        "ins1PreCode":"}  connectionInfo.setProviderProperty(PostgreConstants.PROP_SHOW_NON_DEFAULT_DB, String.valueOf(showNonDefault.getSelection())); connectionInfo.setProviderProperty(PostgreConstants.PROP_SHOW_TEMPLATES_DB, String.valueOf(showTemplates.getSelection())); super.saveSettings(dataSource);",
        "ins2PreCode":"public void saveSettings(DBPDataSourceContainer dataSource) { DBPConnectionConfiguration connectionInfo = dataSource.getConnectionConfiguration(); if (hostText != null) { connectionInfo.setHostName(hostText.getText().trim()); } if (portText != null) { connectionInfo.setHostPort(portText.getText().trim()); } if (dbText != null) { connectionInfo.setDatabaseName(dbText.getText().trim()); } if (warehouseText != null) { connectionInfo.setServerName(warehouseText.getText().trim()); } if (schemaText != null) { connectionInfo.setProviderProperty(SnowflakeConstants.PROP_SCHEMA, schemaText.getText().trim()); } if (usernameText != null) { connectionInfo.setUserName(usernameText.getText().trim()); } if (roleText != null) { connectionInfo.setProviderProperty(SnowflakeConstants.PROP_ROLE, roleText.getText().trim()); } if (authTypeCombo != null) { connectionInfo.setProviderProperty(SnowflakeConstants.PROP_AUTHENTICATOR, authTypeCombo.getText().trim()); } if (passwordText != null) { connectionInfo.setUserPassword(passwordText.getText()); } super.saveSettings(dataSource);",
        "label":0
    },
    {
        "ins1CurCode":"}  final int uaoSize = UnsafeAlignedOffset.getUaoSize();  final int required = length + uaoSize; allocateMemoryForRecordIfNecessary(required); ",
        "ins1PreCode":"}  growPointerArrayIfNecessary(); int uaoSize = UnsafeAlignedOffset.getUaoSize();  final int required = length + uaoSize; acquireNewPageIfNecessary(required); ",
        "ins2PreCode":"public void insertRecord(Object recordBase, long recordOffset, int length, int partitionId) throws IOException {   assert(inMemSorter != null); if (inMemSorter.numRecords() >= numElementsForSpillThreshold) { logger.info(\"Spilling data because number of spilledRecords crossed the threshold \" + numElementsForSpillThreshold); spill(); }  growPointerArrayIfNecessary(); final int uaoSize = UnsafeAlignedOffset.getUaoSize();  final int required = length + uaoSize; acquireNewPageIfNecessary(required);  assert(currentPage != null); final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); UnsafeAlignedOffset.putSize(base, pageCursor, length); pageCursor += uaoSize; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length; inMemSorter.insertRecord(recordAddress, partitionId);",
        "label":0
    },
    {
        "ins1CurCode":"JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));  List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2);   ssc.transform( listOfDStreams1, (listOfRDDs, time) -> { Assert.assertEquals(2, listOfRDDs.size()); return null; } );  List<JavaDStream<?>> listOfDStreams2 = Arrays.asList(stream1, stream2, pairStream1.toJavaDStream());  JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair( listOfDStreams2, (listOfRDDs, time) -> { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = (PairFunction<Integer, Integer, Integer>) i -> new Tuple2<>(i, i); return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);",
        "ins1PreCode":"JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));  List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2);   ssc.transform( listOfDStreams1, new Function2<List<JavaRDD<?>>, Time, JavaRDD<Long>>() { @Override public JavaRDD<Long> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(2, listOfRDDs.size()); return null; } } );  List<JavaDStream<?>> listOfDStreams2 = Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream());  JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair( listOfDStreams2, new Function2<List<JavaRDD<?>>, Time, JavaPairRDD<Integer, Tuple2<Integer, String>>>() { @Override public JavaPairRDD<Integer, Tuple2<Integer, String>> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer i) { return new Tuple2<>(i, i); } }; return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);",
        "ins2PreCode":"JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));  List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2);   JavaDStream<Long> transformed1 = ssc.transform( listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Assert.assertEquals(2, listOfRDDs.size()); return null; });  List<JavaDStream<?>> listOfDStreams2 = Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream()); ",
        "label":0
    },
    {
        "ins1CurCode":"final BehaviorProcessor<Object> p = BehaviorProcessor.create();  final TestSubscriber<Object> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"final BehaviorProcessor<Object> p = BehaviorProcessor.create();  final TestSubscriber<Object> ts = new TestSubscriber<Object>(); ",
        "ins2PreCode":"final BehaviorProcessor<Object> p = BehaviorProcessor.create();  final TestSubscriber<Object> ts = new TestSubscriber<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void parseRecognizesStringWithWhitespace() throws IOException { ParserResult result = parser",
        "ins1PreCode":"public void parseRecognizesStringWithWhitespace() throws IOException { ParserResult result = parser",
        "ins2PreCode":"public void parseRecognizesStringInParenthesis() throws IOException { ParserResult result = parser",
        "label":1
    },
    {
        "ins1CurCode":"try { return JSONCompare.compareJSON( (expectedJson != null ? expectedJson.toString() : null), this.actual.toString(), compareMode);",
        "ins1PreCode":"try { return JSONCompare.compareJSON( (expectedJson == null ? null : expectedJson.toString()), this.actual.toString(), compareMode);",
        "ins2PreCode":"try { return JSONCompare.compareJSON( (expectedJson == null ? null : expectedJson.toString()), this.actual.toString(), comparator);",
        "label":1
    },
    {
        "ins1CurCode":"private void setUpNonLogin() throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_MINS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); nonloginAuthenticator = new NonLoginAuthenticator(); ctxt.getPipeline().addValve(nonloginAuthenticator);",
        "ins1PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "ins2PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainXYPlot plot1 = createPlot(); CombinedDomainXYPlot plot2 = CloneUtils.clone(plot1); assertTrue(plot1 != plot2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainXYPlot plot1 = createPlot(); CombinedDomainXYPlot plot2 = (CombinedDomainXYPlot) plot1.clone(); assertTrue(plot1 != plot2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainCategoryPlot plot1 = createPlot(); CombinedDomainCategoryPlot plot2 = (CombinedDomainCategoryPlot) plot1.clone(); assertTrue(plot1 != plot2);",
        "label":1
    },
    {
        "ins1CurCode":"public void take() throws Exception { List<Flowable<Integer>> sourceList = new ArrayList<>(3);  sourceList.add(Flowable.range(0, 100000).subscribeOn(Schedulers.io())); sourceList.add(Flowable.range(0, 100000).subscribeOn(Schedulers.io())); sourceList.add(Flowable.range(0, 100000).subscribeOn(Schedulers.io()));  TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void take() throws Exception { List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(3);  sourceList.add(Flowable.range(0, 100000).subscribeOn(Schedulers.io())); sourceList.add(Flowable.range(0, 100000).subscribeOn(Schedulers.io())); sourceList.add(Flowable.range(0, 100000).subscribeOn(Schedulers.io()));  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void take() throws Exception { List<Observable<Integer>> sourceList = new ArrayList<Observable<Integer>>(3);  sourceList.add(Observable.range(0, 100000).subscribeOn(Schedulers.io())); sourceList.add(Observable.range(0, 100000).subscribeOn(Schedulers.io())); sourceList.add(Observable.range(0, 100000).subscribeOn(Schedulers.io()));  TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"protected void fireToDoItemsRemoved(List<ToDoItem> theItems) { List<ToDoItem> toDoItems = null;  Object[] listeners = listenerList.getListenerList(); ToDoListEvent e = null;   for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ToDoListListener.class) {  if (e == null) { toDoItems = Collections.unmodifiableList(theItems); e = new ToDoListEvent(toDoItems); }",
        "ins1PreCode":" if (e == null) { e = new ToDoListEvent(theItems); }",
        "ins2PreCode":"protected void fireToDoItemsAdded(List<ToDoItem> theItems) {  Object[] listeners = listenerList.getListenerList(); ToDoListEvent e = null;   for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == ToDoListListener.class) {  if (e == null) { e = new ToDoListEvent(theItems); } ((ToDoListListener) listeners[i + 1]).toDoItemsAdded(e); } }",
        "label":0
    },
    {
        "ins1CurCode":"setState(351); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,28,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(348); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(349); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(350); braceaccess();",
        "ins1PreCode":"enterRule(_localctx, 38, RULE_postfix); try { setState(354); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,29,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(351); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(352); fieldaccess(); } break; case 3: enterOuterAlt(_localctx, 3); { setState(353); braceaccess();",
        "ins2PreCode":"enterRule(_localctx, 40, RULE_postdot); try { setState(358); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,30,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(356); callinvoke(); } break; case 2: enterOuterAlt(_localctx, 2); { setState(357); fieldaccess();",
        "label":0
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"void initFieldsShouldSetNullFields() { InitFieldsTestClass test = new InitFieldsTestClass();",
        "ins1PreCode":"public void initFieldsShouldSetNullFields() { InitFieldsTestClass test = new InitFieldsTestClass();",
        "ins2PreCode":"public void initFieldsShouldSetNullFields() { InitFieldsTestClass test = new InitFieldsTestClass();",
        "label":1
    },
    {
        "ins1CurCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.addEntry(bibEntry); ",
        "ins1PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, EINSTEIN_B); expectedCrossingResult.insertEntry(database, EINSTEIN_A); expectedCrossingResult.insertEntry(database, EINSTEIN); expectedCrossingResult.insertEntry(database, EINSTEIN_C); expectedCrossingResult.addUnresolvedKey(EINSTEIN_21); expectedCrossingResult.addUnresolvedKey(UNRESOLVED); expectedCrossingResult.increaseCrossRefsCount(); ",
        "ins2PreCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database).resolveKeys(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  expectedCrossingResult.insertEntry(database, DARWIN); expectedCrossingResult.insertEntry(database, EINSTEIN); ",
        "label":0
    },
    {
        "ins1CurCode":"final BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"final BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(EMPTY_USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return Flowable.fromArray(source1, source2, source3, source4).flatMapSingle(Functions.identity(), true, Integer.MAX_VALUE);",
        "ins1PreCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return mergeDelayError(Flowable.fromArray(source1, source2, source3, source4));",
        "ins2PreCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return merge(Flowable.fromArray(source1, source2, source3, source4));",
        "label":0
    },
    {
        "ins1CurCode":"assertTrue(idStrategy.compare(\"user1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"user2\", \"user1\") > 0); assertEquals(0, idStrategy.compare(\"user1\", \"user1\")); assertTrue(idStrategy.compare(\"USER1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"USER2\", \"user1\") > 0); assertEquals(0, idStrategy.compare(\"User1\", \"user1\"));",
        "ins1PreCode":"assertTrue(idStrategy.compare(\"user1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"user2\", \"user1\") > 0); assertTrue(idStrategy.compare(\"user1\", \"user1\") == 0); assertTrue(idStrategy.compare(\"USER1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"USER2\", \"user1\") > 0); assertTrue(idStrategy.compare(\"User1\", \"user1\") == 0);",
        "ins2PreCode":"assertTrue(idStrategy.compare(\"user1\", \"user2\") < 0); assertTrue(idStrategy.compare(\"user2\", \"user1\") > 0); assertTrue(idStrategy.compare(\"user1\", \"user1\") == 0); assertTrue(idStrategy.compare(\"USER1\", \"user2\") < 0);",
        "label":0
    },
    {
        "ins1CurCode":"StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\");",
        "ins1PreCode":"StructType schema = DataTypes.createStructType(fields);  DataFrame df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\");",
        "ins2PreCode":"StructType schema = DataTypes.createStructType(fields);  DataFrame df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collect(); ",
        "label":0
    },
    {
        "ins1CurCode":"}  filesIncluded = new VectorSet<>(); filesNotIncluded = new Vector<>(); filesExcluded = new VectorSet<>(); dirsIncluded = new VectorSet<>(); dirsNotIncluded = new Vector<>(); dirsExcluded = new VectorSet<>(); ",
        "ins1PreCode":"}  filesIncluded = new VectorSet(); filesNotIncluded = new Vector(); filesExcluded = new VectorSet(); dirsIncluded = new VectorSet(); dirsNotIncluded = new Vector(); dirsExcluded = new VectorSet(); ",
        "ins2PreCode":"}  filesIncluded = new VectorSet(); filesNotIncluded = new Vector(); filesExcluded = new VectorSet(); dirsIncluded = new VectorSet(); dirsNotIncluded = new Vector(); dirsExcluded = new VectorSet(); ",
        "label":1
    },
    {
        "ins1CurCode":"value instanceof Long    || value instanceof Float   || value instanceof Double  || value instanceof BigInteger ) {",
        "ins1PreCode":"value instanceof Long    || value instanceof Float   || value instanceof Double ) {",
        "ins2PreCode":"public static float defTofloatExplicit(final Object value) { if (value instanceof Character) { return (char)value; } else if ( value instanceof Byte    || value instanceof Short   || value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double ) { return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"float [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + byte.class.getCanonicalName()); }",
        "label":0
    },
    {
        "ins1CurCode":"factory.setKeyStoreResource(Resource.newResource(url)); } catch (Exception ex) { throw new WebServerException( \"Could not load key store '\" + ssl.getKeyStore() + \"'\", ex); }",
        "ins1PreCode":"factory.setKeyStoreResource(Resource.newResource(url)); } catch (IOException ex) { throw new WebServerException( \"Could not find key store '\" + ssl.getKeyStore() + \"'\", ex); }",
        "ins2PreCode":"private void configureSslTrustStore(SslContextFactory factory, Ssl ssl) { if (ssl.getTrustStorePassword() != null) { factory.setTrustStorePassword(ssl.getTrustStorePassword()); } if (ssl.getTrustStore() != null) { try { URL url = ResourceUtils.getURL(ssl.getTrustStore()); factory.setTrustStoreResource(Resource.newResource(url)); } catch (IOException ex) { throw new WebServerException( \"Could not find trust store '\" + ssl.getTrustStore() + \"'\", ex); } } if (ssl.getTrustStoreType() != null) { factory.setTrustStoreType(ssl.getTrustStoreType()); } if (ssl.getTrustStoreProvider() != null) { factory.setTrustStoreProvider(ssl.getTrustStoreProvider()); }",
        "label":0
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet); wrapper.setAsyncSupported(true); ctx.addServletMappingDecoded(\"/\", \"servlet\"); ",
        "ins1PreCode":"Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "ins2PreCode":"Wrapper wrapper = Tomcat.addServlet(ctx, \"servlet\", servlet); wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/\", \"servlet\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSet() { list.add(2); list.add(4);  assertEquals(2, (int) list.set(0, 3)); assertEquals(3, (int) list.get(0));  assertEquals(4, (int) list.set(1, 0)); assertEquals(0, (int) list.get(1));  try { list.set(-1, 0); fail(); } catch (IndexOutOfBoundsException e) {  }  try { list.set(2, 0); fail(); } catch (IndexOutOfBoundsException e) { ",
        "ins1PreCode":"public void testSet() { list.add(2); list.add(6);  list.set(0, 1); assertEquals(1, (int) list.get(0)); list.set(1, 2); assertEquals(2, (int) list.get(1));",
        "ins2PreCode":"public void testSet() { list.addInt(2); list.addInt(4);  assertEquals(2, (int) list.set(0, 3)); assertEquals(3, list.getInt(0));  assertEquals(4, (int) list.set(1, 0)); assertEquals(0, list.getInt(1));  try { list.set(-1, 0); fail(); } catch (IndexOutOfBoundsException e) {  }  try { list.set(2, 0); fail(); } catch (IndexOutOfBoundsException e) {  }",
        "label":0
    },
    {
        "ins1CurCode":"con2.setCatalog(\"mysql\"); }catch (SQLException x) { Assert.assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); } Assert.assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); }catch (Exception x) { Assert.assertFalse(\"Connection got starved:\"+x.getMessage(),true); }finally {",
        "ins1PreCode":"public void testConnectionStarvation() throws Exception { init(); config(); Connection con1 = datasource.getConnection(); Connection con2 = null; try { con2 = datasource.getConnection(); try { con2.setCatalog(\"mysql\"); }catch (SQLException x) { assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); } assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); }catch (Exception x) { assertFalse(\"Connection got starved:\"+x.getMessage(),true); }finally {",
        "ins2PreCode":"con2.setCatalog(\"mysql\"); }catch (SQLException x) { assertFalse(\"2nd Connection is not valid:\"+x.getMessage(),true); } assertTrue(\"Connection 1 should be closed.\",con1.isClosed()); }catch (Exception x) { assertFalse(\"Connection got starved:\"+x.getMessage(),true); }finally {",
        "label":1
    },
    {
        "ins1CurCode":"public static SerialDate getPreviousDayOfWeek(int targetWeekday, SerialDate base) {   if (!SerialDate.isValidWeekdayCode(targetWeekday)) { throw new IllegalArgumentException(\"Invalid day-of-the-week code.\"); }   int adjust; int baseDOW = base.getDayOfWeek(); if (baseDOW > targetWeekday) { adjust = Math.min(0, targetWeekday - baseDOW); } else { adjust = -7 + Math.max(0, targetWeekday - baseDOW);",
        "ins1PreCode":"public static SerialDate getPreviousDayOfWeek(final int targetWeekday, final SerialDate base) {   if (!SerialDate.isValidWeekdayCode(targetWeekday)) { throw new IllegalArgumentException( \"Invalid day-of-the-week code.\" ); }   final int adjust; final int baseDOW = base.getDayOfWeek(); if (baseDOW > targetWeekday) { adjust = Math.min(0, targetWeekday - baseDOW); } else { adjust = -7 + Math.max(0, targetWeekday - baseDOW);",
        "ins2PreCode":"public static SerialDate getFollowingDayOfWeek(final int targetWeekday, final SerialDate base) {   if (!SerialDate.isValidWeekdayCode(targetWeekday)) { throw new IllegalArgumentException( \"Invalid day-of-the-week code.\" ); }   final int adjust; final int baseDOW = base.getDayOfWeek(); if (baseDOW > targetWeekday) { adjust = 7 + Math.min(0, targetWeekday - baseDOW); } else { adjust = Math.max(0, targetWeekday - baseDOW);",
        "label":1
    },
    {
        "ins1CurCode":"void testSelectLike() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.selectLike\", \"Ba\");  assertEquals(2, answer.size()); assertEquals(4, answer.get(0).get(\"ID\")); assertEquals(6, answer.get(1).get(\"ID\")); }",
        "ins1PreCode":"public void testSelectLike() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {  List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.selectLike\", \"Ba\");  assertTrue(answer.size() == 2); assertEquals(Integer.valueOf(4), answer.get(0).get(\"ID\")); assertEquals(Integer.valueOf(6), answer.get(1).get(\"ID\")); }",
        "ins2PreCode":"public void testOgnlStaticMethodCall() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.ognlStaticMethodCall\", \"Rock 'n Roll\"); assertTrue(answer.size() == 1); assertEquals(Integer.valueOf(7), answer.get(0).get(\"ID\")); }",
        "label":1
    },
    {
        "ins1CurCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc);  Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "ins1PreCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "ins2PreCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "label":1
    },
    {
        "ins1CurCode":"return; } this.curpwd = getCurpwdPlusFileSep() + currentPathElement;",
        "ins1PreCode":"return; } this.curpwd = this.curpwd + remoteFileSep + currentPathElement;",
        "ins2PreCode":"public AntFTPFile(AntFTPFile parent, String path) { this.parent = parent; this.client = parent.client; Vector pathElements = SelectorUtils.tokenizePath(path); try { boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());  if (!result) { return; } this.curpwd = parent.getAbsolutePath(); } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + parent.curpwd); } for (int fcount = 0; fcount < pathElements.size() - 1; fcount++) { String currentPathElement = (String) pathElements.elementAt(fcount); try { boolean result = this.client.changeWorkingDirectory(currentPathElement); if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } } else if (!result) { return; } this.curpwd = this.curpwd + task.getSeparator() + currentPathElement; } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + (String) pathElements.elementAt(fcount) + \" from \" + this.curpwd); }  } String lastpathelement = (String) pathElements.elementAt(pathElements.size() - 1); FTPFile [] theFiles = listFiles(this.curpwd); this.ftpFile = getFile(theFiles, lastpathelement);",
        "label":0
    },
    {
        "ins1CurCode":"basicContext = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\"));  ",
        "ins1PreCode":"basicContext = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); basicContext.setSessionTimeout(SHORT_SESSION_TIMEOUT_MINS); ",
        "ins2PreCode":"private void setUpLogin() throws Exception {   basicContext = tomcat.addContext(CONTEXT_PATH_LOGIN, System.getProperty(\"java.io.tmpdir\")); basicContext.setSessionTimeout(SHORT_SESSION_TIMEOUT_MINS);   Tomcat.addServlet(basicContext, \"TesterServlet3\", new TesterServletEncodeUrl()); basicContext.addServletMapping(URI_PROTECTED, \"TesterServlet3\"); SecurityCollection collection = new SecurityCollection(); collection.addPattern(URI_PROTECTED); SecurityConstraint sc = new SecurityConstraint(); sc.addAuthRole(ROLE); sc.addCollection(collection); basicContext.addConstraint(sc);   Tomcat.addServlet(basicContext, \"TesterServlet4\", new TesterServletEncodeUrl()); basicContext.addServletMapping(URI_PUBLIC, \"TesterServlet4\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); basicContext.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"BASIC\"); basicContext.setLoginConfig(lc); AuthenticatorBase basicAuthenticator = new BasicAuthenticator(); basicContext.getPipeline().addValve(basicAuthenticator);",
        "label":0
    },
    {
        "ins1CurCode":"void socketChannelClosedTriggersTunnelClose() throws Exception { TunnelClient client = new TunnelClient(0, this.tunnelConnection);",
        "ins1PreCode":"public void socketChannelClosedTriggersTunnelClose() throws Exception { TunnelClient client = new TunnelClient(0, this.tunnelConnection);",
        "ins2PreCode":"public void stopTriggersTunnelClose() throws Exception { TunnelClient client = new TunnelClient(0, this.tunnelConnection);",
        "label":1
    },
    {
        "ins1CurCode":"public void testRadio_ExistingData() throws Exception { rootAction.list.add(new FooRadio(\"1\", \"one\")); rootAction.list.add(new FooRadio(\"2\", \"two\")); rootAction.list.add(new FooRadio(\"three\", \"one\")); HtmlPage p = j.createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); getHtmlButton(f, \"Add\", false).click(); f.getInputByValue(\"\").setValueAttribute(\"txt 4\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click(); j.submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"1\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"2\\\"},\" + \"{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"three\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt 4\\\"}]\", rootAction.formData.get(\"foos\"));",
        "ins1PreCode":"public void testRadio_ExistingData() throws Exception { list.add(new FooRadio(\"1\", \"one\")); list.add(new FooRadio(\"2\", \"two\")); list.add(new FooRadio(\"three\", \"one\")); HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); getHtmlButton(f, \"Add\", false).click(); f.getInputByValue(\"\").setValueAttribute(\"txt 4\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(7).click(); submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"1\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"2\\\"},\" + \"{\\\"radio\\\":\\\"one\\\",\\\"txt\\\":\\\"three\\\"},{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt 4\\\"}]\", formData.get(\"foos\"));",
        "ins2PreCode":"public void testRadio() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testRadio\"); HtmlForm f = p.getFormByName(\"config\"); getHtmlButton(f, \"Add\", true).click(); f.getInputByValue(\"\").setValueAttribute(\"txt one\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(1).click(); getHtmlButton(f, \"Add\", false).click(); f.getInputByValue(\"\").setValueAttribute(\"txt two\"); f.getElementsByAttribute(\"INPUT\", \"type\", \"radio\").get(3).click(); submit(f); assertEqualsJsonArray(\"[{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt one\\\"},\" + \"{\\\"radio\\\":\\\"two\\\",\\\"txt\\\":\\\"txt two\\\"}]\", formData.get(\"foos\"));",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getEndpointId()) .isEqualTo(EndpointId.of(\"testcontroller\")); assertThat(endpoint.getController())",
        "ins1PreCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testcontroller\"); assertThat(endpoint.getController())",
        "ins2PreCode":"assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testcontroller\"); assertThat(endpoint.getController())",
        "label":1
    },
    {
        "ins1CurCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "label":1
    },
    {
        "ins1CurCode":"}  if (e != 0) { BackpressureHelper.produced(requested, e); }",
        "ins1PreCode":"}  if (e != 0 && r != Long.MAX_VALUE) { requested.addAndGet(-e); }  int w = get(); if (w == missed) { missed = addAndGet(-missed); if (missed == 0) { break; } } else { missed = w; }",
        "ins2PreCode":"}  if (e != 0 && r != Long.MAX_VALUE) { requested.addAndGet(-e); }  int w = get(); if (w == missed) { missed = addAndGet(-missed); if (missed == 0) { break; } } else { missed = w; }",
        "label":1
    },
    {
        "ins1CurCode":"void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); database.insertEntry(entry);  Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"testvalue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testvalue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"public void completeBeginnigOfSecondWordReturnsWord() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"value\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"SELECT s.*, sq.SQL_FULLTEXT\\n\" + \"FROM V$SESSION s, V$SQL sq\\n\" +",
        "ins1PreCode":"try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( \"SELECT s.*, sq.SQL_TEXT\\n\" + \"FROM V$SESSION s, V$SQL sq\\n\" +",
        "ins2PreCode":"public Collection<PostgreSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>(); while (dbResult.next()) { sessions.add(new PostgreSession(dbResult)); } return sessions; } } } catch (SQLException e) { throw new DBException(e, session.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":"String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertFalse(buildRule.getFullLog().contains(\"Removing orphan file:\"));",
        "ins1PreCode":"String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(!buildRule.getFullLog().contains(\"Removing orphan file:\"));",
        "ins2PreCode":"String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsPresent(f); assertTrue(!buildRule.getFullLog().contains(\"Removing orphan file:\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void setUp() { this.seriesA = new TimeSeries<>(\"Series A\"); this.seriesA.add(new Year(2000), 102000); this.seriesA.add(new Year(2001), 102001); this.seriesA.add(new Year(2002), 102002); this.seriesA.add(new Year(2003), 102003); this.seriesA.add(new Year(2004), 102004); this.seriesA.add(new Year(2005), 102005);  this.seriesB = new TimeSeries<>(\"Series B\"); this.seriesB.add(new Year(2006), 202006); this.seriesB.add(new Year(2007), 202007); this.seriesB.add(new Year(2008), 202008);  this.seriesC = new TimeSeries<>(\"Series C\"); this.seriesC.add(new Year(1999), 301999);",
        "ins1PreCode":"public void setUp() { this.seriesA = new TimeSeries(\"Series A\"); this.seriesA.add(new Year(2000), 102000); this.seriesA.add(new Year(2001), 102001); this.seriesA.add(new Year(2002), 102002); this.seriesA.add(new Year(2003), 102003); this.seriesA.add(new Year(2004), 102004); this.seriesA.add(new Year(2005), 102005);  this.seriesB = new TimeSeries(\"Series B\"); this.seriesB.add(new Year(2006), 202006); this.seriesB.add(new Year(2007), 202007); this.seriesB.add(new Year(2008), 202008);  this.seriesC = new TimeSeries(\"Series C\"); this.seriesC.add(new Year(1999), 301999);",
        "ins2PreCode":"public void setUp() { this.seriesA = new TimePeriodValues(\"Series A\"); this.seriesA.add(new Year(2000), 102000); this.seriesA.add(new Year(2001), 102001); this.seriesA.add(new Year(2002), 102002); this.seriesA.add(new Year(2003), 102003); this.seriesA.add(new Year(2004), 102004); this.seriesA.add(new Year(2005), 102005);  this.seriesB = new TimePeriodValues(\"Series B\"); this.seriesB.add(new Year(2006), 202006); this.seriesB.add(new Year(2007), 202007); this.seriesB.add(new Year(2008), 202008);  this.seriesC = new TimePeriodValues(\"Series C\"); this.seriesC.add(new Year(1999), 301999);",
        "label":1
    },
    {
        "ins1CurCode":"public void makeChange(BibDatabaseContext database, NamedCompound undoEdit) { try { database.getDatabase().removeString(string.getId()); undoEdit.addEdit(new UndoableRemoveString(database.getDatabase(), string));",
        "ins1PreCode":"public void makeChange(BibDatabaseContext database, NamedCompound undoEdit) { try { database.getDatabase().removeString(inMem.getId()); undoEdit.addEdit(new UndoableRemoveString(database.getDatabase(), string));",
        "ins2PreCode":"public void makeChange(BibDatabaseContext database, NamedCompound undoEdit) { try { database.getDatabase().addString(string); undoEdit.addEdit(new UndoableInsertString(database.getDatabase(), string)); } catch (KeyCollisionException ex) { LOGGER.warn(\"Error: could not add string '\" + string.getName() + \"': \" + ex.getMessage(), ex); }",
        "label":0
    },
    {
        "ins1CurCode":"void testSimpleQueryCaseSensitiveRegex() { String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, true);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1PreCode":"public void testSimpleQueryCaseSensitiveRegex() { double textSize = 13; String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, true);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testSimpleQueryCaseSensitive() { double textSize = 13; String query = \"a=b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1CurCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.REGULAR_EXPRESSION)); ",
        "ins1PreCode":"TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true); ",
        "ins2PreCode":"TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false); ",
        "label":0
    },
    {
        "ins1CurCode":"}; } for (Thread value : threads) { value.start(); } for (Thread thread : threads) { thread.join(); }",
        "ins1PreCode":"}; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} ",
        "ins2PreCode":"}; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} ",
        "label":1
    },
    {
        "ins1CurCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete();",
        "ins1PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "ins2PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1CurCode":"public void forEachWileWithError() { final List<Object> list = new ArrayList<>(); ",
        "ins1PreCode":"public void forEachWileWithError() { final List<Object> list = new ArrayList<Object>(); ",
        "ins2PreCode":"public void forEachWileWithError() { final List<Object> list = new ArrayList<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void putEdge_allowsSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void putEdge_allowsSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void putEdge_allowsSelfLoops() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"boolean notify) { Args.nullNotPermitted(marker, \"marker\"); Collection<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundRangeMarkers.get(index); } else { markers = this.backgroundRangeMarkers.get(index); }",
        "ins1PreCode":"boolean notify) { Args.nullNotPermitted(marker, \"marker\"); ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundRangeMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundRangeMarkers.get(index); }",
        "ins2PreCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundDomainMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundDomainMarkers.get(index); }",
        "label":0
    },
    {
        "ins1CurCode":"proceduresCache.clearCache(); triggerCache.clearCache(); tableTriggerCache.clearCache(); dataTypeCache.clearCache();",
        "ins1PreCode":"proceduresCache.clearCache(); triggerCache.clearCache(); dataTypeCache.clearCache(); sequenceCache.clearCache();",
        "ins2PreCode":"public DBSObject refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { if (sharedInstance == null && metaContext == null && executionContext == null) {  return this; } readDatabaseInfo(monitor);   roleCache.clearCache(); accessMethodCache.clearCache(); foreignDataWrapperCache.clearCache(); foreignServerCache.clearCache(); languageCache.clearCache(); encodingCache.clearCache(); extensionCache.clearCache(); availableExtensionCache.clearCache(); collationCache.clearCache(); tablespaceCache.clearCache(); schemaCache.clearCache(); cacheDataTypes(monitor, true);  return this;",
        "label":0
    },
    {
        "ins1CurCode":"void shouldInsertNewAuthorWithBeforeAutoKey() throws Exception { ",
        "ins1PreCode":"public void shouldInsertNewAuthorWithBeforeAutoKey() throws Exception { ",
        "ins2PreCode":"public void shouldInsertNewAuthorWithAutoKey() throws Exception { ",
        "label":1
    },
    {
        "ins1CurCode":"return false; } if (!Objects.equals(this.subplots, that.subplots)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream()).hasSize(2); map.put(\"key3\", \"value3\"); assertThat(adapter.stream()).hasSize(3);",
        "ins1PreCode":"SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(3);",
        "ins2PreCode":"SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(2);",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> fromArray(@NonNull T... items) { Objects.requireNonNull(items, \"items is null\"); if (items.length == 0) { return empty(); } if (items.length == 1) { return just(items[0]); } return RxJavaPlugins.onAssembly(new FlowableFromArray<>(items));",
        "ins1PreCode":"public static <T> Flowable<T> fromArray(T... items) { Objects.requireNonNull(items, \"items is null\"); if (items.length == 0) { return empty(); } if (items.length == 1) { return just(items[0]); } return RxJavaPlugins.onAssembly(new FlowableFromArray<T>(items));",
        "ins2PreCode":"return just(items[0]); } return RxJavaPlugins.onAssembly(new ObservableFromArray<T>(items));",
        "label":0
    },
    {
        "ins1CurCode":"  if(username == null || credentials == null) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateFailure\", username)); } return null; }   String serverCredentials = getPassword(username);  if (serverCredentials == null) {   if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateFailure\", username)); } return null; }  boolean validated = getCredentialHandler().matches(credentials, serverCredentials);  if (validated) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateSuccess\", username)); } return getPrincipal(username); } else { if (containerLog.isTraceEnabled()) {",
        "ins1PreCode":"String serverCredentials = getPassword(username);  if (credentials == null || serverCredentials == null) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateFailure\", username)); } return null; }  boolean validated = getCredentialHandler().matches(credentials, serverCredentials); if (!validated) { if (containerLog.isTraceEnabled()) {",
        "ins2PreCode":"String dbCredentials = getPassword(dbConnection, username);  if (credentials == null || dbCredentials == null) { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateFailure\", username)); return null; }   boolean validated = getCredentialHandler().matches(credentials, dbCredentials);  if (validated) { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateSuccess\", username)); } else { if (containerLog.isTraceEnabled()) containerLog.trace( sm.getString(\"dataSourceRealm.authenticateFailure\", username)); return (null); }",
        "label":0
    },
    {
        "ins1CurCode":"public void nearMaxValueWithoutBackpressure() { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.range(Integer.MAX_VALUE - 1, 2).subscribe(ts);",
        "ins1PreCode":"public void nearMaxValueWithoutBackpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(Integer.MAX_VALUE - 1, 2).subscribe(ts);",
        "ins2PreCode":"public void nearMaxValueWithBackpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(3L); Flowable.range(Integer.MAX_VALUE - 1, 2).subscribe(ts);",
        "label":1
    },
    {
        "ins1CurCode":"+ \"\\n Modified locally: \" + isModifiedLocally);  PreviewPanel previewPanel = new PreviewPanel(null, null, Globals.getKeyPrefs(), Globals.prefs.getPreviewPreferences(), new FXDialogService(), ExternalFileTypes.getInstance()); previewPanel.setEntry(memEntry);",
        "ins1PreCode":"+ \"\\n Modified locally: \" + isModifiedLocally);  PreviewPanel previewPanel = new PreviewPanel(null, null, Globals.getKeyPrefs(), Globals.prefs.getPreviewPreferences(), new FXDialogService()); previewPanel.setEntry(memEntry);",
        "ins2PreCode":"this.diskEntry = diskEntry;  PreviewPanel previewPanel = new PreviewPanel(null, null, Globals.getKeyPrefs(), Globals.prefs.getPreviewPreferences(), new FXDialogService()); previewPanel.setEntry(diskEntry);",
        "label":1
    },
    {
        "ins1CurCode":"private void setUp() { importFormatPreferences = mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS); timestampPreferences = mock(TimestampPreferences.class); when(importFormatPreferences.getEncoding()).thenReturn(StandardCharsets.UTF_8); when(timestampPreferences.getTimestampField()).then(invocation -> StandardField.TIMESTAMP); ",
        "ins1PreCode":"private void setUp() { importFormatPreferences = mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS); when(importFormatPreferences.getEncoding()).thenReturn(StandardCharsets.UTF_8);  database = new BibDatabase(); database2 = new BibDatabase();",
        "ins2PreCode":"private void setUp() { importFormatPreferences = mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS); when(importFormatPreferences.getEncoding()).thenReturn(StandardCharsets.UTF_8);  database = new BibDatabase();",
        "label":0
    },
    {
        "ins1CurCode":"void readOperationsThatReturnAResourceSupportRangeRequests() { load(ResourceEndpointConfiguration.class, (client) -> {",
        "ins1PreCode":"public void readOperationsThatReturnAResourceSupportRangeRequests() { load(ResourceEndpointConfiguration.class, (client) -> {",
        "ins2PreCode":"public void readOperationsThatReturnAResourceSupportRangeRequests() { load(ResourceEndpointConfiguration.class, (client) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void testSelectWithTeacher() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor(); try (SqlSession sqlSession = sqlSessionFactory.openSession()) { StudentConstructorMapper studentConstructorMapper = sqlSession.getMapper(StudentConstructorMapper.class);",
        "ins1PreCode":"public void testSelectWithTeacher() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { StudentConstructorMapper studentConstructorMapper = sqlSession.getMapper(StudentConstructorMapper.class); StudentConstructor testStudent = studentConstructorMapper.selectWithTeacherById(1); assertEquals(1, testStudent.getConstructors().size()); assertTrue(testStudent.getConstructors().contains(StudentConstructor.Constructor.ID_NAME)); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testSelectNoName() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { StudentConstructorMapper studentConstructorMapper = sqlSession.getMapper(StudentConstructorMapper.class); StudentConstructor testStudent = studentConstructorMapper.selectNoNameById(1); assertEquals(1, testStudent.getConstructors().size()); assertTrue(testStudent.getConstructors().contains(StudentConstructor.Constructor.ID)); assertNull(testStudent.getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory .of(TestEnvironmentPostProcessor.class); List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory, this.bootstrapRegistry); assertThat(processors).hasSize(1);",
        "ins1PreCode":"EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory .of(TestEnvironmentPostProcessor.class); List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory); assertThat(processors).hasSize(1);",
        "ins2PreCode":"EnvironmentPostProcessorsFactory factory = EnvironmentPostProcessorsFactory .of(TestEnvironmentPostProcessor.class.getName()); List<EnvironmentPostProcessor> processors = factory.getEnvironmentPostProcessors(this.logFactory); assertThat(processors).hasSize(1);",
        "label":1
    },
    {
        "ins1CurCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtils.writePaint(this.firstBarPaint, stream); SerialUtils.writePaint(this.lastBarPaint, stream); SerialUtils.writePaint(this.positiveBarPaint, stream); SerialUtils.writePaint(this.negativeBarPaint, stream);",
        "ins1PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.firstBarPaint, stream); SerialUtilities.writePaint(this.lastBarPaint, stream); SerialUtilities.writePaint(this.positiveBarPaint, stream); SerialUtilities.writePaint(this.negativeBarPaint, stream);",
        "ins2PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.dialBackgroundPaint, stream); SerialUtilities.writePaint(this.dialOutlinePaint, stream); SerialUtilities.writePaint(this.needlePaint, stream); SerialUtilities.writePaint(this.valuePaint, stream); SerialUtilities.writePaint(this.tickPaint, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "label":0
    },
    {
        "ins1CurCode":"void parseAddsEscapedOpenBracketToFieldValue() throws IOException { ParserResult result = parser",
        "ins1PreCode":"public void parseAddsEscapedOpenBracketToFieldValue() throws IOException { ParserResult result = parser",
        "ins2PreCode":"public void parseAddsEscapedClosingBracketToFieldValue() throws IOException { ParserResult result = parser",
        "label":1
    },
    {
        "ins1CurCode":"   if (renderer instanceof StatisticalBarRenderer) { StatisticalBarRenderer sbr = (StatisticalBarRenderer) renderer; sbr.setErrorIndicatorPaint(this.errorIndicatorPaint); }   if (renderer instanceof MinMaxCategoryRenderer) { MinMaxCategoryRenderer mmcr = (MinMaxCategoryRenderer) renderer; mmcr.setGroupPaint(this.errorIndicatorPaint);",
        "ins1PreCode":"  if (renderer instanceof BarRenderer3D) { BarRenderer3D br3d = (BarRenderer3D) renderer; br3d.setWallPaint(this.wallPaint); }   if (renderer instanceof LineRenderer3D) { LineRenderer3D lr3d = (LineRenderer3D) renderer; lr3d.setWallPaint(this.wallPaint); }",
        "ins2PreCode":"protected void applyToXYItemRenderer(XYItemRenderer renderer) { ParamChecks.nullNotPermitted(renderer, \"renderer\"); if (renderer instanceof AbstractRenderer) { applyToAbstractRenderer((AbstractRenderer) renderer); } renderer.setBaseItemLabelFont(this.regularFont); renderer.setBaseItemLabelPaint(this.itemLabelPaint); if (renderer instanceof XYBarRenderer) { XYBarRenderer br = (XYBarRenderer) renderer; br.setBarPainter(this.xyBarPainter); br.setShadowVisible(this.shadowVisible); }",
        "label":0
    },
    {
        "ins1CurCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET;",
        "ins1PreCode":"public final void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET;",
        "ins2PreCode":"public final void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET;",
        "label":1
    },
    {
        "ins1CurCode":"StandardCategorySeriesLabelGenerator g1 = new StandardCategorySeriesLabelGenerator(\"{1}\"); StandardCategorySeriesLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"StandardCategorySeriesLabelGenerator g1 = new StandardCategorySeriesLabelGenerator(\"{1}\"); StandardCategorySeriesLabelGenerator g2 = (StandardCategorySeriesLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator(); BubbleXYItemLabelGenerator g2 = (BubbleXYItemLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"append(report, content, (metadata) -> \"Reason: \" + (StringUtils.hasText(metadata.getDeprecation().getShortReason()) ? metadata.getDeprecation().getShortReason() : \"none\")); report.append(String.format(\"%n\"));",
        "ins1PreCode":"append(report, content, (metadata) -> \"Reason: \" + (StringUtils.hasText(metadata.getDeprecation().getReason()) ? metadata.getDeprecation().getReason() : \"none\")); report.append(String.format(\"%n\"));",
        "ins2PreCode":"public String getWarningReport() { Map<String, List<PropertyMigration>> content = getContent( LegacyProperties::getRenamed); if (content.isEmpty()) { return null; } StringBuilder report = new StringBuilder(); report.append(String.format(\"%nThe use of configuration keys that have been \" + \"renamed was found in the environment:%n%n\")); append(report, content, (metadata) -> \"Replacement: \" + metadata.getDeprecation().getReplacement()); report.append(String.format(\"%n\")); report.append(\"Each configuration key has been temporarily mapped to its \" + \"replacement for your convenience. To silence this warning, please \" + \"update your configuration to use the new keys.\"); report.append(String.format(\"%n\")); return report.toString();",
        "label":0
    },
    {
        "ins1CurCode":"void probesWhenPropertyEnabledAddsBeans() { this.contextRunner.withPropertyValues(\"management.endpoint.health.probes.enabled=true\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)",
        "ins1PreCode":"void probesWhenPropertyEnabledAddsBeans() { this.contextRunner.withPropertyValues(\"management.health.probes.enabled=true\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class)",
        "ins2PreCode":"void probesWhenKubernetesAddsBeans() { this.contextRunner.withPropertyValues(\"spring.main.cloud-platform=kubernetes\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class) .hasSingleBean(ReadinessStateHealthIndicator.class) .hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class));",
        "label":0
    },
    {
        "ins1CurCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>(); ",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) {",
        "ins1PreCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = Globals.entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) {",
        "ins2PreCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = Globals.entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) {",
        "label":1
    },
    {
        "ins1CurCode":"void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class)",
        "label":1
    },
    {
        "ins1CurCode":" Subscriber<String> w = TestHelper.mockSubscriber(); st.subscribe(new SafeSubscriber<>(new TestSubscriber<>(w))); ",
        "ins1PreCode":" Subscriber<String> w = TestHelper.mockSubscriber(); st.subscribe(new SafeSubscriber<String>(new TestSubscriber<String>(w))); ",
        "ins2PreCode":" Subscriber<String> w = TestHelper.mockSubscriber(); st.subscribe(new SafeSubscriber<String>(new TestSubscriber<String>(w))); ",
        "label":1
    },
    {
        "ins1CurCode":"RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.GRAY); g2.fill(shadow);",
        "ins1PreCode":"RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.gray); g2.fill(shadow);",
        "ins2PreCode":"RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.gray); g2.fill(shadow);",
        "label":1
    },
    {
        "ins1CurCode":"void exceptionsIncludeClassPackaging(CapturedOutput output) { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).contains(\"[junit-\"); assertThat(output).contains(\"[junit-\");",
        "ins1PreCode":"public void exceptionsIncludeClassPackaging() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins2PreCode":"public void exceptionsIncludeClassPackaging() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "label":1
    },
    {
        "ins1CurCode":"void testNotAllFound() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\");",
        "ins1PreCode":"public void testNotAllFound() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\");",
        "ins2PreCode":"public void testNestedAux() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\");",
        "label":1
    },
    {
        "ins1CurCode":"{  List<TaskSegment> taskSegments = buildListCalculator.calculateTaskSegments( session );  TaskSegment mergedSegment = new TaskSegment( false );  for ( TaskSegment taskSegment : taskSegments ) { mergedSegment.getTasks().addAll( taskSegment.getTasks() ); }  return lifecycleExecutionPlanCalculator.calculateExecutionPlan( session, session.getCurrentProject(), mergedSegment.getTasks() );",
        "ins1PreCode":"PluginVersionResolutionException { MavenProject project = session.getCurrentProject();  List<MojoExecution> lifecyclePlan = new ArrayList<MojoExecution>();  Set<String> requiredDependencyResolutionScopes = new HashSet<String>();  for ( String task : tasks ) { if ( task.indexOf( \":\" ) > 0 ) { calculateExecutionForIndividualGoal( session, lifecyclePlan, task ); } else { calculateExecutionForLifecyclePhase( session, lifecyclePlan, task ); } }    for ( MojoExecution mojoExecution : lifecyclePlan ) {      MojoDescriptor mojoDescriptor = mojoExecution.getMojoDescriptor();  if ( mojoDescriptor == null ) { mojoDescriptor = pluginManager.getMojoDescriptor( mojoExecution.getPlugin(), mojoExecution.getGoal(), getRepositoryRequest( session, project ) );  mojoExecution.setMojoDescriptor( mojoDescriptor ); }  populateMojoExecutionConfiguration( project, mojoExecution, MojoExecution.Source.CLI.equals( mojoExecution.getSource() ) );  extractMojoConfiguration( mojoExecution );  calculateForkedExecutions( mojoExecution, session, project, new HashSet<MojoDescriptor>() );  collectDependencyResolutionScopes( requiredDependencyResolutionScopes, mojoExecution ); }  return new MavenExecutionPlan( lifecyclePlan, requiredDependencyResolutionScopes );",
        "ins2PreCode":"MavenExecutionPlan calculateExecutionPlan( MavenSession session, String... tasks ) throws PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException, MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginManagerException, LifecyclePhaseNotFoundException, LifecycleNotFoundException, PluginVersionResolutionException { List<org.apache.maven.lifecycle.internal.TaskSegment> taskSegments = lifeCycleTaskSegmentCalculator.calculateTaskSegments( session, Arrays.asList( tasks ) );  org.apache.maven.lifecycle.internal.TaskSegment mergedSegment = new org.apache.maven.lifecycle.internal.TaskSegment( false );  for ( org.apache.maven.lifecycle.internal.TaskSegment taskSegment : taskSegments ) { mergedSegment.getTasks().addAll( taskSegment.getTasks() ); }  return lifeCycleExecutionPlanCalculator.calculateExecutionPlan( session, session.getCurrentProject(), mergedSegment.getTasks() );",
        "label":0
    },
    {
        "ins1CurCode":"SubscriptionHelper.cancel(upstream); boundarySubscriber.dispose(); errors.tryAddThrowableOrReport(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\")); done = true;",
        "ins1PreCode":"SubscriptionHelper.cancel(upstream); boundarySubscriber.dispose(); errors.addThrowable(new MissingBackpressureException(\"Could not deliver a window due to lack of requests\")); done = true;",
        "ins2PreCode":"void drain() { if (getAndIncrement() != 0) { return; }  int missed = 1; Observer<? super Observable<T>> downstream = this.downstream; MpscLinkedQueue<Object> queue = this.queue; AtomicThrowable errors = this.errors;  for (;;) {  for (;;) { if (windows.get() == 0) { queue.clear(); window = null; return; }  UnicastSubject<T> w = window;  boolean d = done;  if (d && errors.get() != null) { queue.clear(); Throwable ex = errors.terminate(); if (w != null) { window = null; w.onError(ex); } downstream.onError(ex); return; }  Object v = queue.poll();  boolean empty = v == null;  if (d && empty) { Throwable ex = errors.terminate(); if (ex == null) { if (w != null) { window = null; w.onComplete(); } downstream.onComplete(); } else { if (w != null) { window = null; w.onError(ex); } downstream.onError(ex); } return; }  if (empty) { break; }  if (v != NEXT_WINDOW) { w.onNext((T)v); continue; }  if (w != null) { window = null; w.onComplete(); }  if (!stopWindows.get()) { w = UnicastSubject.create(capacityHint, this); window = w; windows.getAndIncrement();  downstream.onNext(w); } }  missed = addAndGet(-missed); if (missed == 0) { break; } }",
        "label":0
    },
    {
        "ins1CurCode":"this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 0\",0,datasource.getPool().getActive()); con.close();",
        "ins1PreCode":"public void testDefaultAbandon() throws Exception { this.init(); this.datasource.setMaxActive(100); this.datasource.setMaxIdle(100); this.datasource.setInitialSize(0); this.datasource.getPoolProperties().setAbandonWhenPercentageFull(0); this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(100); this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); assertEquals(\"Number of connections active/busy should be 0\",0,datasource.getPool().getActive()); con.close();",
        "ins2PreCode":"public void testMaxedOutAbandon() throws Exception { int size = 100; this.init(); this.datasource.setMaxActive(size); this.datasource.setMaxIdle(size); this.datasource.setInitialSize(0); this.datasource.getPoolProperties().setAbandonWhenPercentageFull(100); this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(100); this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "label":1
    },
    {
        "ins1CurCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, null);  Assert.assertEquals(expectedStatus, sc);  if (expectedStatus == 200) { String result = res.toString(); Assert.assertTrue(result, result.indexOf(expectedBody) > 0); }",
        "ins1PreCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, null);  assertEquals(expectedStatus, sc);  if (expectedStatus == 200) { String result = res.toString(); assertTrue(result, result.indexOf(expectedBody) > 0); }",
        "ins2PreCode":"null, null);  assertEquals(expectedStatus, sc);  if (expectedStatus == 200) { String result = res.toString(); assertTrue(result, result.contains(expectedBody)); }",
        "label":1
    },
    {
        "ins1CurCode":"private static JFreeChart createBarChart() {  Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}}; CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createBarChart(\"Bar Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true);",
        "ins1PreCode":"  Number[][] data = new Integer[][] {{new Integer(-3), new Integer(-2)}, {new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);   return ChartFactory.createBarChart( \"Bar Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true ); ",
        "ins2PreCode":"private static JFreeChart createAreaChart() { Number[][] data = new Integer[][] {{new Integer(-3), new Integer(-2)}, {new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset, PlotOrientation.HORIZONTAL, true, true, true); ",
        "label":1
    },
    {
        "ins1CurCode":" assertTrue(checkIndependence(r1, r2)); TestUtils.checkIndependence(r1, r2);",
        "ins1PreCode":" assertTrue(checkIndependence(r1, r2));",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { XYStepRenderer r1 = new XYStepRenderer(); XYStepRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":0
    },
    {
        "ins1CurCode":"void getWhenHasFactoryMethodBindsUsingMethodReturnType() throws Throwable { get(NonAnnotatedGenericBeanConfiguration.class, \"nonAnnotatedGenericBean\", (propertiesBean) -> { assertThat(propertiesBean.getType()).isEqualTo(NonAnnotatedGenericBean.class); assertThat(propertiesBean.getBindMethod()).isEqualTo(BindMethod.JAVA_BEAN); ResolvableType type = propertiesBean.asBindTarget().getType();",
        "ins1PreCode":"void getWhenHasFactoryMethodBindsUsingMethodReturnType() throws Throwable { get(NonAnnotatedGenericBeanConfiguration.class, \"nonAnnotatedGenericBean\", (propertiesBean) -> { ResolvableType type = propertiesBean.asBindTarget().getType(); assertThat(type.resolve()).isEqualTo(NonAnnotatedGenericBean.class); assertThat(type.resolveGeneric(0)).isEqualTo(String.class);",
        "ins2PreCode":"void getWhenHasFactoryMethodWithoutAnnotationBindsUsingMethodType() throws Throwable { get(AnnotatedGenericBeanConfiguration.class, \"annotatedGenericBean\", (propertiesBean) -> { ResolvableType type = propertiesBean.asBindTarget().getType(); assertThat(type.resolve()).isEqualTo(AnnotatedGenericBean.class); assertThat(type.resolveGeneric(0)).isEqualTo(String.class);",
        "label":1
    },
    {
        "ins1CurCode":"void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception { Map<String, String> KEYS = Collections.singletonMap(\"valid-key\", INVALID_KEY);",
        "ins1PreCode":"public void validateTokenWhenSignatureInvalidShouldThrowException() throws Exception { Map<String, String> KEYS = Collections.singletonMap(\"valid-key\", INVALID_KEY);",
        "ins2PreCode":"public void validateTokenWhenTokenAlgorithmIsNotRS256ShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));",
        "label":1
    },
    {
        "ins1CurCode":"minwait = Math.min(delta, minwait); nroffetch++; try { if (FairnessTest.this.sleep>0) sleep(FairnessTest.this.sleep); } catch (InterruptedException x) { interrupted(); } } finally { long cstart = System.nanoTime(); if (con!=null) try {con.close();}catch(Exception x) {x.printStackTrace();}",
        "ins1PreCode":"minwait = Math.min(delta, minwait); nroffetch++; if (query!=null) { Statement st = con.createStatement(); ResultSet rs = st.executeQuery(query); while (rs.next()) { } rs.close(); st.close(); }",
        "ins2PreCode":"minwait = Math.min(delta, minwait); nroffetch++; if (query!=null) { Statement st = con.createStatement(); ResultSet rs = st.executeQuery(query); while (rs.next()) { } rs.close(); st.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"Configuration configuration = sqlSessionFactory.getConfiguration(); configuration.setAggressiveLazyLoading(false); configuration.setLazyLoadTriggerMethods(new HashSet<>()); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"Configuration configuration = sqlSessionFactory.getConfiguration(); configuration.setAggressiveLazyLoading(false); configuration.setLazyLoadTriggerMethods(new HashSet<String>()); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"configuration.setAggressiveLazyLoading(false); configuration .setLazyLoadTriggerMethods(new HashSet<String>(Collections.singleton(\"trigger\"))); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByCitationKey(\"1\").get().getField(StandardField.YEAR));",
        "ins1PreCode":" assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "ins2PreCode":" assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "label":1
    },
    {
        "ins1CurCode":"public void testdefToCharacterExplicit() { assertEquals('s', exec(\"def d = 's'; Character b = (Character)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Character b = (Character)d;\"));",
        "ins1PreCode":"public void testdefToCharacterExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Character b = (Character)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; Character b = (Character)d;\"));",
        "ins2PreCode":"public void testdefTocharExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = (char)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; char b = (char)d;\"));",
        "label":0
    },
    {
        "ins1CurCode":"GraphModel gm = ce.getGraphModel(); if (gm instanceof SequenceDiagramGraphModel) { Object owner = ((SequenceDiagramGraphModel) gm).getOwner(); node = Model.getCollaborationsFactory().buildLifeline(owner); } else {",
        "ins1PreCode":"GraphModel gm = ce.getGraphModel(); if (gm instanceof SequenceDiagramGraphModel) { Object collaboration = ((SequenceDiagramGraphModel) gm).getCollaboration(); node = Model.getCollaborationsFactory().buildClassifierRole( collaboration);      } else {",
        "ins2PreCode":"public Object makeNode() { Object node = null; Editor ce = Globals.curEditor(); GraphModel gm = ce.getGraphModel(); if (gm instanceof CollabDiagramGraphModel) { Object collaboration = ((CollabDiagramGraphModel) gm).getHomeModel(); node = Model.getCollaborationsFactory().buildClassifierRole( collaboration); } else { throw new IllegalStateException(\"Graphmodel is not a \" + \"collaboration diagram graph model\"); } return node;",
        "label":0
    },
    {
        "ins1CurCode":"void shouldTrimWHEREInsteadOfANDForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  ID = ?\";",
        "ins1PreCode":"public void shouldTrimWHEREInsteadOfANDForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  ID = ?\";",
        "ins2PreCode":"public void shouldTrimWHEREInsteadOfORForSecondCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  NAME = ?\";",
        "label":1
    },
    {
        "ins1CurCode":"} }) .toSingle() .test()",
        "ins1PreCode":"} }) .test() .assertFailure(TestException.class);",
        "ins2PreCode":"public void singleErrors() { Maybe.just(1) .flatMapSingleElement(new Function<Integer, SingleSource<Integer>>() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"jj_consume_token(START_DEFERRED_EXPRESSION); Expression(); jj_consume_token(RBRACE); } catch (Throwable jjte000) {",
        "ins1PreCode":"jj_consume_token(START_DEFERRED_EXPRESSION); Expression(); jj_consume_token(RCURL); } catch (Throwable jjte000) {",
        "ins2PreCode":"jj_consume_token(START_DYNAMIC_EXPRESSION); Expression(); jj_consume_token(RCURL); } catch (Throwable jjte000) {",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Object> observer) { observer.onSubscribe(Disposable.empty()); ref.set(observer);",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); ref.set(observer);",
        "ins2PreCode":"public void mainAndBoundaryBothError() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<? super Object>> ref = new AtomicReference<Subscriber<? super Object>>();  TestSubscriberEx<Flowable<Object>> ts = Flowable.error(new TestException(\"main\")) .window(new Flowable<Object>() { @Override protected void subscribeActual(Subscriber<? super Object> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); ref.set(subscriber); } }) .doOnNext(new Consumer<Flowable<Object>>() { @Override public void accept(Flowable<Object> w) throws Throwable { w.subscribe(Functions.emptyConsumer(), Functions.emptyConsumer()); } }) .to(TestHelper.<Flowable<Object>>testConsumer());  ts .assertValueCount(1) .assertError(TestException.class) .assertErrorMessage(\"main\") .assertNotComplete();  ref.get().onError(new TestException(\"inner\"));  TestHelper.assertUndeliverable(errors, 0, TestException.class, \"inner\"); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"public void windowUnsubscribeNonOverlappingAsyncSource() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); final AtomicInteger count = new AtomicInteger();",
        "ins1PreCode":"public void windowUnsubscribeNonOverlappingAsyncSource() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final AtomicInteger count = new AtomicInteger();",
        "ins2PreCode":"public void windowUnsubscribeOverlappingAsyncSource() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class,",
        "ins1PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class,",
        "ins2PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { this.contextRunner.run(withWebTestClient((client) -> client.options().uri(\"/cfApplication/test\")",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Integer> observer) { Disposable bs = Disposable.empty(); observer.onSubscribe(bs);",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Integer> observer) { Disposable bs = Disposables.empty(); observer.onSubscribe(bs);",
        "ins2PreCode":"public void multiTake() { final AtomicInteger count = new AtomicInteger(); Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(Subscriber<? super Integer> s) { BooleanSubscription bs = new BooleanSubscription(); s.onSubscribe(bs); for (int i = 0; !bs.isCancelled(); i++) { System.out.println(\"Emit: \" + i); count.incrementAndGet(); s.onNext(i); } }  }).take(100).take(1).blockingForEach(new Consumer<Integer>() {  @Override public void accept(Integer t1) { System.out.println(\"Receive: \" + t1);  }  });  assertEquals(1, count.get());",
        "label":0
    },
    {
        "ins1CurCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded.get()); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded.get(), jarEntry.getName()); if (jarEntry.isDirectory()) {",
        "ins1PreCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded, jarEntry.getName()); if (jarEntry.isDirectory()) {",
        "ins2PreCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded, jarEntry.getName()); if (jarEntry.isDirectory()) { extracted.mkdirs(); } else { FileOutputStream extractedOutputStream = new FileOutputStream(extracted); StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream); extractedOutputStream.close(); } } jarFile.close();",
        "label":0
    },
    {
        "ins1CurCode":"}  queue = new SpscLinkedArrayQueue<>(prefetch); ",
        "ins1PreCode":"}  queue = new SpscLinkedArrayQueue<T>(prefetch); ",
        "ins2PreCode":"}  queue = new SpscLinkedArrayQueue<T>(bufferSize); ",
        "label":1
    },
    {
        "ins1CurCode":"void roundtripWithUserComment() throws Exception { Path testBibtexFile = Path.of(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8;",
        "ins1PreCode":"void roundtripWithUserComment() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8;",
        "ins2PreCode":"void roundtripWithUserCommentAndEntryChange() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(StandardField.AUTHOR, \"Mr. Author\");  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "label":0
    },
    {
        "ins1CurCode":"protected Map<Axis, AxisState> drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {  AxisCollection axisCollection = new AxisCollection();   for (CategoryAxis xAxis : this.domainAxes.values()) { if (xAxis != null) { int index = getDomainAxisIndex(xAxis); axisCollection.add(xAxis, getDomainAxisEdge(index)); } }   for (ValueAxis yAxis : this.rangeAxes.values()) { if (yAxis != null) { int index = findRangeAxisIndex(yAxis); axisCollection.add(yAxis, getRangeAxisEdge(index)); } }  Map<Axis, AxisState> axisStateMap = new HashMap<>(); ",
        "ins1PreCode":"protected Map drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {  AxisCollection axisCollection = new AxisCollection();   for (CategoryAxis xAxis : this.domainAxes.values()) { if (xAxis != null) { int index = getDomainAxisIndex(xAxis); axisCollection.add(xAxis, getDomainAxisEdge(index)); } }   for (ValueAxis yAxis : this.rangeAxes.values()) { if (yAxis != null) { int index = findRangeAxisIndex(yAxis); axisCollection.add(yAxis, getRangeAxisEdge(index)); } }  Map axisStateMap = new HashMap(); ",
        "ins2PreCode":"protected Map<Axis, AxisState> drawAxes(Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, PlotRenderingInfo plotState) {  AxisCollection axisCollection = new AxisCollection();   for (ValueAxis axis : this.domainAxes.values()) { if (axis != null) { int axisIndex = findDomainAxisIndex(axis); axisCollection.add(axis, getDomainAxisEdge(axisIndex)); } }   for (ValueAxis axis : this.rangeAxes.values()) { if (axis != null) { int axisIndex = findRangeAxisIndex(axis); axisCollection.add(axis, getRangeAxisEdge(axisIndex)); } }  Map<Axis, AxisState> axisStateMap = new HashMap<>();   double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset( dataArea.getHeight()); for (Axis axis : axisCollection.getAxesAtTop()) { AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.TOP, plotState); cursor = info.getCursor(); axisStateMap.put(axis, info); }   cursor = dataArea.getMaxY() + this.axisOffset.calculateBottomOutset(dataArea.getHeight()); for (Axis axis : axisCollection.getAxesAtBottom()) { AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.BOTTOM, plotState); cursor = info.getCursor(); axisStateMap.put(axis, info); }   cursor = dataArea.getMinX() - this.axisOffset.calculateLeftOutset(dataArea.getWidth()); for (Axis axis : axisCollection.getAxesAtLeft()) { AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.LEFT, plotState); cursor = info.getCursor(); axisStateMap.put(axis, info); }   cursor = dataArea.getMaxX() + this.axisOffset.calculateRightOutset(dataArea.getWidth()); for (Axis axis : axisCollection.getAxesAtRight()) { AxisState info = axis.draw(g2, cursor, plotArea, dataArea, RectangleEdge.RIGHT, plotState); cursor = info.getCursor(); axisStateMap.put(axis, info); }  return axisStateMap;",
        "label":0
    },
    {
        "ins1CurCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext, int capacityHint) { Iterator<T> it = blockingIterable(capacityHint).iterator(); while (it.hasNext()) {",
        "ins1PreCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator(); while (it.hasNext()) {",
        "ins2PreCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator(); while (it.hasNext()) {",
        "label":0
    },
    {
        "ins1CurCode":"RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.GRAY); g2.fill(shadow);",
        "ins1PreCode":"RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.gray); g2.fill(shadow);",
        "ins2PreCode":"public void paintBarShadow(Graphics2D g2, BarRenderer renderer, int row, int column, RectangularShape bar, RectangleEdge base, boolean pegShadow) {    Paint itemPaint = renderer.getItemPaint(row, column); if (itemPaint instanceof Color) { Color c = (Color) itemPaint; if (c.getAlpha() == 0) { return; } }  RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(renderer.getShadowPaint()); g2.fill(shadow); ",
        "label":0
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC); ",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue();",
        "ins1PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"info\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse();",
        "ins2PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"mappings\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.POST, \"shutdown\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"status\")).isFalse(); assertThat(isExposed(mvc, HttpMethod.GET, \"threaddump\")).isFalse();",
        "label":0
    },
    {
        "ins1CurCode":"Object fieldValue = \"foo\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = createSetProcessor(fieldName, \"bar\", null, false, false); processor.execute(ingestDocument);",
        "ins1PreCode":"Object fieldValue = \"foo\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = createSetProcessor(fieldName, \"bar\", false, false); processor.execute(ingestDocument);",
        "ins2PreCode":"Object newValue = \"bar\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = createSetProcessor(fieldName, newValue, false, false); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1CurCode":"public void sameSize() throws Exception { MergerBiFunction<Integer> merger = new MergerBiFunction<>(new Comparator<Integer>() { @Override",
        "ins1PreCode":"public void sameSize() throws Exception { MergerBiFunction<Integer> merger = new MergerBiFunction<Integer>(new Comparator<Integer>() { @Override",
        "ins2PreCode":"public void sameSizeReverse() throws Exception { MergerBiFunction<Integer> merger = new MergerBiFunction<Integer>(new Comparator<Integer>() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNames(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<>(); parms.put(\"lowestId\", 3);",
        "ins1PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNames(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 3);",
        "ins2PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2); List<Name> names = spMapper.getNames(parms); assertEquals(2, parms.get(\"totalRows\")); assertEquals(2, names.size());  parms = new HashMap<String, Object>(); parms.put(\"lowestId\", 2);",
        "label":1
    },
    {
        "ins1CurCode":"static void setUp() throws Exception { Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), PgContainer.getUnpooledDataSource()); configuration.setEnvironment(environment);",
        "ins1PreCode":"static void setUp() throws Exception {  String url = postgres.start( EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"cursor_simple\", \"postgres\", \"root\", Collections.emptyList());  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.postgresql.Driver\", url, null)); configuration.setEnvironment(environment);",
        "ins2PreCode":"static void setUp() throws Exception {  String url = postgres.start(EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"keycolumn\", \"postgres\", \"root\", Collections.emptyList());  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.postgresql.Driver\", url, null)); configuration.setEnvironment(environment);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { ValueMarker m1 = new ValueMarker(25.0); ValueMarker m2 = CloneUtils.clone(m1); assertTrue(m1 != m2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { ValueMarker m1 = new ValueMarker(25.0); ValueMarker m2 = (ValueMarker) m1.clone(); assertTrue(m1 != m2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalMarker m1 = new IntervalMarker(45.0, 50.0); IntervalMarker m2 = CloneUtils.clone(m1); assertTrue(m1 != m2); assertTrue(m1.getClass() == m2.getClass()); assertTrue(m1.equals(m2));",
        "label":0
    },
    {
        "ins1CurCode":"public void fromIterable() { ArrayList<String> items = new ArrayList<>(); items.add(\"one\");",
        "ins1PreCode":"public void fromIterable() { ArrayList<String> items = new ArrayList<String>(); items.add(\"one\");",
        "ins2PreCode":"public void fromIterable() { ArrayList<String> items = new ArrayList<String>(); items.add(\"one\");",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"boolean result = Os.isName( test );  return reverse ? !result : result;",
        "ins1PreCode":"boolean result = Os.isName( test );  if ( reverse ) { return !result; } else { return result; }",
        "ins2PreCode":"private boolean determineNameMatch( String name ) { String test = name; boolean reverse = false;  if ( test.startsWith( \"!\" ) ) { reverse = true; test = test.substring( 1 ); }  boolean result = Os.isName( test );  if ( reverse ) { return !result; } else { return result; }",
        "label":0
    },
    {
        "ins1CurCode":"public void eventOrdering() { final List<String> list = new ArrayList<>(); ",
        "ins1PreCode":"public void eventOrdering() { final List<String> list = new ArrayList<String>(); ",
        "ins2PreCode":"public void eventOrdering2() { final List<String> list = new ArrayList<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void testLangRawWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testLangRawWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testLangVelocityWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"private byte[] readRawBytesSlowPath(final int size) throws IOException {  byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return result; }",
        "ins1PreCode":"private byte[] readRawBytesSlowPath( final int size, boolean ensureNoLeakedReferences) throws IOException {  byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return ensureNoLeakedReferences ? result.clone() : result; }",
        "ins2PreCode":"  return ByteString.copyFrom(result); }  final int originalBufferPos = pos; final int bufferedBytes = bufferSize - pos;   totalBytesRetired += bufferSize; pos = 0; bufferSize = 0;   int sizeLeft = size - bufferedBytes;    List<byte[]> chunks = readRawBytesSlowPathRemainingChunks(sizeLeft);   final byte[] bytes = new byte[size];   System.arraycopy(buffer, originalBufferPos, bytes, 0, bufferedBytes);   int tempPos = bufferedBytes; for (final byte[] chunk : chunks) { System.arraycopy(chunk, 0, bytes, tempPos, chunk.length); tempPos += chunk.length; }  return ByteString.wrap(bytes);",
        "label":0
    },
    {
        "ins1CurCode":"PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<Flowable<Integer>> inner = new AtomicReference<>(); ",
        "ins1PreCode":"PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<Flowable<Integer>> inner = new AtomicReference<Flowable<Integer>>(); ",
        "ins2PreCode":"PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<Flowable<Integer>> inner = new AtomicReference<Flowable<Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"stmt += caseSensitive ?             \" TABLE_NAME LIKE ?\" : \" UPPER(TABLE_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY SCHEMA_NAME, TABLE_NAME LIMIT \" + maxResults; ",
        "ins1PreCode":"stmt += caseSensitive ?             \" TABLE_NAME LIKE ?\" : \" UPPER(TABLE_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY TABLE_NAME LIMIT \" + maxResults; ",
        "ins2PreCode":"stmt += caseSensitive ?             \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt +=    \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY VIEW_NAME LIMIT \" + maxResults; ",
        "label":1
    },
    {
        "ins1CurCode":"public void testInsertBlobThenSelectAll() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { BlobMapper blobMapper = sqlSession.getMapper(BlobMapper.class);",
        "ins1PreCode":"public void testInsertBlobThenSelectAll() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { BlobMapper blobMapper = sqlSession.getMapper(BlobMapper.class);  byte[] myblob = new byte[] {1, 2, 3, 4, 5}; BlobRecord blobRecord = new BlobRecord(1, myblob); int rows = blobMapper.insert(blobRecord); assertEquals(1, rows);   List<BlobRecord> results = blobMapper.selectAll();  assertEquals(1, results.size()); BlobRecord result = results.get(0); assertEquals (blobRecord.getId(), result.getId()); assertTrue (blobsAreEqual(blobRecord.getBlob(), result.getBlob())); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertBlobObjectsThenSelectAll() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { BlobMapper blobMapper = sqlSession.getMapper(BlobMapper.class);  Byte[] myblob = new Byte[] {1, 2, 3, 4, 5}; BlobRecord blobRecord = new BlobRecord(1, myblob); int rows = blobMapper.insert(blobRecord); assertEquals(1, rows);   List<BlobRecord> results = blobMapper.selectAllWithBlobObjects();  assertEquals(1, results.size()); BlobRecord result = results.get(0); assertEquals (blobRecord.getId(), result.getId()); assertTrue (blobsAreEqual(blobRecord.getBlob(), result.getBlob())); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"DumbSlave slave = j.createSlave(\"aNode\", \"\", null); slave.toComputer().disconnect(); while (!slave.toComputer().isOffline()) { Thread.sleep(100);",
        "ins1PreCode":"DumbSlave slave = j.createSlave(\"aNode\", \"\", null); slave.toComputer().disconnect(); while (true) { if(slave.toComputer().isOffline()) break; Thread.sleep(100);",
        "ins2PreCode":"DumbSlave slave = j.createSlave(\"aNode\", \"\", null); slave.toComputer().waitUntilOnline(); while (true) { if(slave.toComputer().isOnline()) break; Thread.sleep(100);",
        "label":1
    },
    {
        "ins1CurCode":"boolean encodeAlpha, int compression) throws IOException {  Args.nullNotPermitted(out, \"out\"); Args.nullNotPermitted(chart, \"chart\"); BufferedImage chartImage = chart.createBufferedImage(width, height,",
        "ins1PreCode":"boolean encodeAlpha, int compression) throws IOException {  ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\"); BufferedImage chartImage = chart.createBufferedImage(width, height,",
        "ins2PreCode":"throws IOException {  ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\"); BufferedImage image = chart.createBufferedImage(width, height,",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals( \"project-basic\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = getExecutions( calculateExecutionPlan( session, \"clean\" ) ); assertEquals( 1, executionPlan.size() ); MojoExecution mojoExecution = executionPlan.get( 0 ); assertNotNull( mojoExecution ); assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() ); assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );",
        "ins1PreCode":"assertEquals( \"project-basic\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean\" ).getExecutions(); assertEquals( 1, executionPlan.size() ); MojoExecution mojoExecution = executionPlan.get( 0 ); assertNotNull( mojoExecution ); assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() ); assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );",
        "ins2PreCode":"assertEquals( \"project-basic\", session.getCurrentProject().getArtifactId() ); assertEquals( \"1.0\", session.getCurrentProject().getVersion() ); List<MojoExecution> executionPlan = lifecycleExecutor.calculateExecutionPlan( session, \"clean:clean\" ).getExecutions(); assertEquals( 1, executionPlan.size() ); MojoExecution mojoExecution = executionPlan.get( 0 ); assertNotNull( mojoExecution ); assertEquals( \"org.apache.maven.plugins\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getGroupId() ); assertEquals( \"maven-clean-plugin\", mojoExecution.getMojoDescriptor().getPluginDescriptor().getArtifactId() );",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetMinStartIndex() { TimePeriodValues<String> s = new TimePeriodValues<>(\"Test\"); assertEquals(-1, s.getMinStartIndex());",
        "ins1PreCode":"public void testGetMinStartIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMinStartIndex());",
        "ins2PreCode":"public void testGetMaxStartIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMaxStartIndex());",
        "label":1
    },
    {
        "ins1CurCode":"public void merge2000AsyncStreamOf100() { TestObserver<Integer> to = new TestObserver<>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(to);",
        "ins1PreCode":"public void merge2000AsyncStreamOf100() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(to);",
        "ins2PreCode":"public void merge100AsyncStreamOf1() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(100, 1).subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"private static void exportOpenDocumentSpreadsheet(Path file, BibDatabase database, List<BibEntry> entries) throws IOException {",
        "ins1PreCode":"private static void exportOpenDocumentSpreadsheet(File file, BibDatabase database, List<BibEntry> entries) throws IOException {",
        "ins2PreCode":"private static void exportOpenOfficeCalc(File file, BibDatabase database, List<BibEntry> entries) throws Exception { ",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7) { Objects.requireNonNull(item1, \"item1 is null\");",
        "ins1PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7) { Objects.requireNonNull(item1, \"item1 is null\");",
        "ins2PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8) { Objects.requireNonNull(item1, \"item1 is null\");",
        "label":1
    },
    {
        "ins1CurCode":"case 101: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 15); break;",
        "ins1PreCode":"case 101: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 17); break;",
        "ins2PreCode":"case 101: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(3, 17, 17); break; case 76: case 108: if ((active0 & 0x80000L) != 0L) return jjStartNfaWithStates_0(3, 19, 17); break;",
        "label":0
    },
    {
        "ins1CurCode":"private Duration convert(ConversionService conversionService, Integer source, ChronoUnit defaultUnit) { TypeDescriptor targetType = mock(TypeDescriptor.class); if (defaultUnit != null) { DurationUnit unitAnnotation = AnnotationUtils .synthesizeAnnotation(Collections.singletonMap(\"value\", defaultUnit), DurationUnit.class, null); given(targetType.getAnnotation(DurationUnit.class)).willReturn(unitAnnotation); } given(targetType.getType()).willReturn((Class) Duration.class); return (Duration) conversionService.convert(source, TypeDescriptor.forObject(source), targetType);",
        "ins1PreCode":"private Duration convert(Integer source, ChronoUnit defaultUnit) { TypeDescriptor targetType = mock(TypeDescriptor.class); if (defaultUnit != null) { DurationUnit unitAnnotation = AnnotationUtils .synthesizeAnnotation(Collections.singletonMap(\"value\", defaultUnit), DurationUnit.class, null); given(targetType.getAnnotation(DurationUnit.class)).willReturn(unitAnnotation); } given(targetType.getType()).willReturn((Class) Duration.class); return (Duration) this.conversionService.convert(source, TypeDescriptor.forObject(source), targetType);",
        "ins2PreCode":"private DataSize convert(Integer source, DataUnit defaultUnit) { TypeDescriptor targetType = mock(TypeDescriptor.class); if (defaultUnit != null) { DataSizeUnit unitAnnotation = AnnotationUtils .synthesizeAnnotation(Collections.singletonMap(\"value\", defaultUnit), DataSizeUnit.class, null); given(targetType.getAnnotation(DataSizeUnit.class)).willReturn(unitAnnotation); } given(targetType.getType()).willReturn((Class) DataSize.class); return (DataSize) this.conversionService.convert(source, TypeDescriptor.forObject(source), targetType);",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerCompletableObserverError() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerCompletableObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerEmitterError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"separator\", \"\\\\.\"); String processorTag = randomAlphaOfLength(10); SplitProcessor splitProcessor = factory.create(null, processorTag, null, config); assertThat(splitProcessor.getTag(), equalTo(processorTag));",
        "ins1PreCode":"config.put(\"separator\", \"\\\\.\"); String processorTag = randomAlphaOfLength(10); SplitProcessor splitProcessor = factory.create(null, processorTag, config); assertThat(splitProcessor.getTag(), equalTo(processorTag));",
        "ins2PreCode":"config.put(\"target_field\", \"target\"); String processorTag = randomAlphaOfLength(10); SplitProcessor splitProcessor = factory.create(null, processorTag, config); assertThat(splitProcessor.getTag(), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1CurCode":"up .doFinally(this) .compose(TestHelper.conditional()) .subscribe(ts);",
        "ins1PreCode":"up .doFinally(this) .filter(Functions.alwaysTrue()) .subscribe(ts);",
        "ins2PreCode":"public void asyncFusedBoundary() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>().setInitialFusionMode(QueueFuseable.ASYNC | QueueFuseable.BOUNDARY);  UnicastProcessor<Integer> up = UnicastProcessor.create(); TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doFinally(this) .subscribe(ts);  ts.assertFusionMode(QueueFuseable.NONE) .assertResult(1, 2, 3, 4, 5);  assertEquals(1, calls);",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetEstimatedDurationIfNoSuccessfulBuildTakeDurationOfFailedBuild() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<>(); ",
        "ins1PreCode":"public void testGetEstimatedDurationIfNoSuccessfulBuildTakeDurationOfFailedBuild() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<Integer, TestBuild>(); ",
        "ins2PreCode":"public void testGetEstimatedDurationWithFailedRun() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<Integer, TestBuild>();  Job project = createMockProject(runs);  TestBuild lastBuild = new TestBuild(project, Result.FAILURE, 42, null); runs.put(1, lastBuild);  assertEquals(-1, project.getEstimatedDuration());",
        "label":0
    },
    {
        "ins1CurCode":"public void error() { BooleanSubscription bs = new BooleanSubscription(); Disposable d = Disposable.empty(); ",
        "ins1PreCode":"public void error() { BooleanSubscription bs = new BooleanSubscription(); Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void complete() { BooleanSubscription bs = new BooleanSubscription(); Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(range.getLowerBound() <= 10, \"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound()); assertTrue(range.getUpperBound() >= 30, \"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound());",
        "ins1PreCode":"ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "ins2PreCode":"ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "label":1
    },
    {
        "ins1CurCode":"try (ACLContext ignored = ACL.as2(manager.impersonate2())) { Exception e = Assert.assertThrows(AccessDeniedException.class, () -> jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Run.ARTIFACTS)); Assert.assertEquals(\"manager is missing a permission, one of Job/WipeOut, Run/Artifacts is required\", e.getMessage());",
        "ins1PreCode":"try (ACLContext ignored = ACL.as2(manager.impersonate2())) { Exception e = Assert.assertThrows(AccessDeniedException.class, () -> jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Build.ARTIFACTS)); Assert.assertEquals(\"manager is missing a permission, one of Job/WipeOut, Run/Artifacts is required\", e.getMessage());",
        "ins2PreCode":"public void checkAnyPermissionDoesNotShowDisabledPermissionsInError() { Jenkins jenkins = r.jenkins; jenkins.setSecurityRealm(r.createDummySecurityRealm()); jenkins.setAuthorizationStrategy(new MockAuthorizationStrategy() .grant(Jenkins.READ).everywhere().to(\"manager\") );  final User manager = User.getOrCreateByIdOrFullName(\"manager\");  try (ACLContext ignored = ACL.as2(manager.impersonate2())) { Exception e = Assert.assertThrows(AccessDeniedException.class, () -> jenkins.getACL().checkAnyPermission(Jenkins.MANAGE, Jenkins.SYSTEM_READ)); Assert.assertEquals(\"manager is missing the Overall/Administer permission\", e.getMessage()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"public void tryTerminateConsumerObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerMaybeObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Single<Boolean> sequenceEqual(@NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull BiPredicate<? super T, ? super T> isEqual, int bufferSize) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(isEqual, \"isEqual is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new FlowableSequenceEqualSingle<>(source1, source2, isEqual, bufferSize));",
        "ins1PreCode":"public static <T> Single<Boolean> sequenceEqual(Publisher<? extends T> source1, Publisher<? extends T> source2, BiPredicate<? super T, ? super T> isEqual, int bufferSize) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(isEqual, \"isEqual is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new FlowableSequenceEqualSingle<T>(source1, source2, isEqual, bufferSize));",
        "ins2PreCode":"public static <T> Single<Boolean> sequenceEqual(ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, BiPredicate<? super T, ? super T> isEqual, int bufferSize) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":1
    },
    {
        "ins1CurCode":"int index = -1;  final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i);",
        "ins1PreCode":"int index = -1;  for (int i = 0; i < entries.size() && index == -1; ++i) { Object element = entries.elementAt(i);",
        "ins2PreCode":"int index = -1;  for (int i = 0; i < entries.size() && index == -1; ++i) { Object element = entries.elementAt(i);",
        "label":1
    },
    {
        "ins1CurCode":"void getValueOrigin() { Map<String, Object> source = new LinkedHashMap<>();",
        "ins1PreCode":"public void getValueOrigin() { Map<String, Object> source = new LinkedHashMap<>();",
        "ins2PreCode":"public void getValueWhenOriginCapableShouldIncludeSourceOrigin() { Map<String, Object> source = new LinkedHashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":"public void testDataSendACK() throws Exception { System.err.println(\"Starting ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "ins1PreCode":"public void testDataSendACK() throws Exception { System.err.println(\"Starting ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "ins2PreCode":"public void testDataSendSYNCACK() throws Exception { System.err.println(\"Starting SYNC_ACK\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_SYNCHRONIZED_ACK|GroupChannel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250);",
        "label":0
    },
    {
        "ins1CurCode":"MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fieldType(\"_parent_join\")).thenReturn(metaJoinFieldType); return mapperService;",
        "ins1PreCode":"MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fullName(\"_parent_join\")).thenReturn(metaJoinFieldType); return mapperService;",
        "ins2PreCode":"MetaJoinFieldMapper.MetaJoinFieldType metaJoinFieldType = mock(MetaJoinFieldMapper.MetaJoinFieldType.class); when(metaJoinFieldType.getMapper()).thenReturn(joinFieldMapper); when(mapperService.fullName(\"_parent_join\")).thenReturn(metaJoinFieldType); return mapperService;",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void responseToOptionsRequestIncludesCorsHeaders() { this.contextRunner.run(withWebTestClient((client) -> client.options() .uri(\"/cfApplication/test\").accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus().isOk() .expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\")));",
        "ins1PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class, (client) -> client.options() .uri(\"/cfApplication/test\").accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus().isOk() .expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader().valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "ins2PreCode":"public void responseToOptionsRequestIncludesCorsHeaders() { load(TestEndpointConfiguration.class, (client) -> client.options().uri(\"/test\") .accept(MediaType.APPLICATION_JSON) .header(\"Access-Control-Request-Method\", \"POST\") .header(\"Origin\", \"http://example.com\").exchange().expectStatus() .isOk().expectHeader() .valueEquals(\"Access-Control-Allow-Origin\", \"http://example.com\") .expectHeader() .valueEquals(\"Access-Control-Allow-Methods\", \"GET,POST\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void multipleErrors3() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins1PreCode":"public void multipleErrors3() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins2PreCode":"public void multipleErrors4() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "label":1
    },
    {
        "ins1CurCode":"tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); connector.setThrowOnFailure(true); tomcat.getService().addConnector(connector);",
        "ins1PreCode":"tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector);",
        "ins2PreCode":"tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); tomcat.getService().addConnector(connector); customizeConnector(connector);",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Computer.CREATE, Jenkins.READ) .withStdin(Computer.class.getResourceAsStream(\"node.xml\")) .invokeWithArgs(\"CustomSlaveName\")",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.ADMINISTER) .withStdin(getClass().getResourceAsStream(\"node.xml\")) .invokeWithArgs(\"CustomSlaveName\")",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.ADMINISTER) .withStdin(getClass().getResourceAsStream(\"node.xml\")) .invokeWithArgs(\"CustomSlaveName\")",
        "label":1
    },
    {
        "ins1CurCode":"public void testDataSendNO_ACK() throws Exception { final AtomicInteger counter = new AtomicInteger(0); ReceiverBase rb1 = (ReceiverBase)channel1.getChannelReceiver(); ReceiverBase rb2 = (ReceiverBase)channel2.getChannelReceiver(); rb1.setUdpRxBufSize(1024*1024*10); rb2.setUdpRxBufSize(1024*1024*10); rb1.setUdpTxBufSize(1024*1024*10); rb2.setUdpTxBufSize(1024*1024*10); System.err.println(\"Starting NO_ACK\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) { int cnt = counter.addAndGet(1); channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024,cnt),Channel.SEND_OPTIONS_UDP); Thread.currentThread().sleep(10); } System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); System.out.println(\"Sent \"+counter.get()+ \" messages. Received \"+listener1.count+\" Highest msg received:\"+listener1.maxIdx); System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins1PreCode":"try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024),Channel.SEND_OPTIONS_UDP); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins2PreCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(3, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return info.getDomainLowerBound(true); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; value = intervalXYData.getStartXValue(series, item); } else { value = dataset.getXValue(series, item); } if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); }  } } if (minimum == Double.POSITIVE_INFINITY) { result = null; } else { result = minimum; }",
        "ins1PreCode":"if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return new Double(info.getDomainLowerBound(true)); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; value = intervalXYData.getStartXValue(series, item); } else { value = dataset.getXValue(series, item); } if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); }  } } if (minimum == Double.POSITIVE_INFINITY) { result = null; } else { result = new Double(minimum); }",
        "ins2PreCode":"if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return new Double(info.getDomainUpperBound(true)); }",
        "label":0
    },
    {
        "ins1CurCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "ins1PreCode":"public void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "ins2PreCode":"public void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "label":0
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetNamesWithArray() throws SQLException { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins1PreCode":"public void testGetNamesWithArray() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Array array = sqlSession.getConnection().createArrayOf(\"int\", new Integer[] { 1, 2, 5 });  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"ids\", array); List<Name> names = spMapper.getNamesWithArray(parms); Object[] returnedIds = (Object[]) parms.get(\"returnedIds\"); assertEquals(4, returnedIds.length); assertEquals(3, parms.get(\"requestedRows\")); assertEquals(2, names.size()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testGetNamesWithArray_a2() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Array array = sqlSession.getConnection().createArrayOf(\"int\", new Integer[] { 1, 2, 5 });  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"ids\", array); List<Name> names = spMapper.getNamesWithArrayAnnotatedWithXMLResultMap(parms); Object[] returnedIds = (Object[]) parms.get(\"returnedIds\"); assertEquals(4, returnedIds.length); assertEquals(3, parms.get(\"requestedRows\")); assertEquals(2, names.size()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public Hashtable<String, Class<?>> getDataTypeDefinitions() { synchronized (typeClassDefinitions) { synchronized (antTypeTable) { if (rebuildTypeClassDefinitions) { typeClassDefinitions.clear(); for (Map.Entry<String, AntTypeDefinition> e : antTypeTable.entrySet()) { final Class<?> clazz = e.getValue().getExposedClass(project); if (clazz == null) { continue; } if (!Task.class.isAssignableFrom(clazz)) { typeClassDefinitions.put(e.getKey(), e.getValue().getTypeClass(project)); }",
        "ins1PreCode":"public Hashtable getDataTypeDefinitions() { synchronized (typeClassDefinitions) { synchronized (antTypeTable) { if (rebuildTypeClassDefinitions) { typeClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (!(Task.class.isAssignableFrom(clazz))) { typeClassDefinitions.put(name, antTypeTable.getTypeClass(name)); }",
        "ins2PreCode":"public Hashtable getTaskDefinitions() { synchronized (taskClassDefinitions) { synchronized (antTypeTable) { if (rebuildTaskClassDefinitions) { taskClassDefinitions.clear(); for (Iterator i = antTypeTable.keySet().iterator(); i.hasNext();) { String name = (String) i.next(); Class clazz = antTypeTable.getExposedClass(name); if (clazz == null) { continue; } if (Task.class.isAssignableFrom(clazz)) { taskClassDefinitions.put(name, antTypeTable.getTypeClass(name)); }",
        "label":0
    },
    {
        "ins1CurCode":"this.parent = parent; this.client = parent.client; List<String> pathElements = SelectorUtils.tokenizePath(path); try {  if (!this.client.changeWorkingDirectory(parent.getAbsolutePath())) { return; } this.curpwd = parent.getAbsolutePath(); } catch (IOException ioe) { throw new BuildException( \"could not change working dir to %s\", parent.curpwd); } final int size = pathElements.size(); for (int fcount = 0; fcount < size - 1; fcount++) { String currentPathElement = pathElements.get(fcount); try { if (!this.client .changeWorkingDirectory(currentPathElement)) { if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } } return; } this.curpwd = getCurpwdPlusFileSep() + currentPathElement; } catch (IOException ioe) { throw new BuildException( \"could not change working dir to %s from %s\", currentPathElement, curpwd); } } String lastpathelement = pathElements.get(pathElements.size() - 1); FTPFile[] theFiles = listFiles(this.curpwd); this.ftpFile = getFile(theFiles, lastpathelement);",
        "ins1PreCode":"this.parent = parent; this.client = parent.client; Vector pathElements = SelectorUtils.tokenizePath(path); try { boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());  if (!result) { return; } this.curpwd = parent.getAbsolutePath(); } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + parent.curpwd); } final int size = pathElements.size(); for (int fcount = 0; fcount < size - 1; fcount++) { String currentPathElement = (String) pathElements.elementAt(fcount); try { boolean result = this.client.changeWorkingDirectory(currentPathElement); if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } } else if (!result) { return; } this.curpwd = getCurpwdPlusFileSep() + currentPathElement; } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + (String) pathElements.elementAt(fcount) + \" from \" + this.curpwd); }  } String lastpathelement = (String) pathElements.elementAt(size - 1); FTPFile [] theFiles = listFiles(this.curpwd); this.ftpFile = getFile(theFiles, lastpathelement);",
        "ins2PreCode":"this.parent = parent; this.client = parent.client; Vector pathElements = SelectorUtils.tokenizePath(path); try { boolean result = this.client.changeWorkingDirectory(parent.getAbsolutePath());  if (!result) { return; } this.curpwd = parent.getAbsolutePath(); } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + parent.curpwd); } final int size = pathElements.size(); for (int fcount = 0; fcount < size - 1; fcount++) { String currentPathElement = (String) pathElements.elementAt(fcount); try { boolean result = this.client.changeWorkingDirectory(currentPathElement); if (!result && !isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) { return; } } else if (!result) { return; } this.curpwd = getCurpwdPlusFileSep() + currentPathElement; } catch (IOException ioe) { throw new BuildException(\"could not change working dir to \" + (String) pathElements.elementAt(fcount) + \" from \" + this.curpwd); }  } String lastpathelement = (String) pathElements.elementAt(size - 1); FTPFile [] theFiles = listFiles(this.curpwd); this.ftpFile = getFile(theFiles, lastpathelement);",
        "label":0
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"} if (writeable) { ByteUtil.set31Bits(header, 5, stream.getIdAsInt()); int orgLimit = data.limit();",
        "ins1PreCode":"} if (writeable) { ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue()); int orgLimit = data.limit();",
        "ins2PreCode":"} if (writeable) { ByteUtil.set31Bits(header, 5, stream.getIdentifier().intValue()); synchronized (socketWrapper) {",
        "label":1
    },
    {
        "ins1CurCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex2(2l); Assertions.assertNotNull(person, \"person must not be null\"); Assertions.assertEquals(\"Christian\", person.getFirstName()); Assertions.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assertions.assertNotNull(parent, \"parent must not be null\"); Assertions.assertEquals(\"John\", parent.getFirstName()); Assertions.assertEquals(\"Smith\", parent.getLastName()); }",
        "ins1PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex2(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "ins2PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "label":1
    },
    {
        "ins1CurCode":"protected List<? extends Tick> refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) {  List<DateTick> result = new ArrayList<>();  Font tickLabelFont = getTickLabelFont(); g2.setFont(tickLabelFont);  if (isAutoTickUnitSelection()) { selectAutoTickUnit(g2, dataArea, edge); }  DateTickUnit unit = getTickUnit(); Date tickDate = calculateLowestVisibleTickValue(unit); Date upperDate = getMaximumDate();  boolean hasRolled = false; while (tickDate.before(upperDate)) {  if (!hasRolled) { tickDate = correctTickDateForPosition(tickDate, unit, this.tickMarkPosition); }  long lowestTickTime = tickDate.getTime(); long distance = unit.addToDate(tickDate, this.timeZone).getTime() - lowestTickTime; int minorTickSpaces = getMinorTickCount(); if (minorTickSpaces <= 0) { minorTickSpaces = unit.getMinorTickCount(); } for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { long minorTickTime = lowestTickTime - distance * minorTick / minorTickSpaces; if (minorTickTime > 0 && getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); } }  if (!isHiddenValue(tickDate.getTime())) {  String tickLabel; DateFormat formatter = getDateFormatOverride(); if (formatter != null) { tickLabel = formatter.format(tickDate); } else { tickLabel = this.tickUnit.dateToString(tickDate); } TextAnchor anchor, rotationAnchor; double angle = 0.0; if (isVerticalTickLabels()) { anchor = TextAnchor.CENTER_RIGHT; rotationAnchor = TextAnchor.CENTER_RIGHT; if (edge == RectangleEdge.TOP) { angle = Math.PI / 2.0; } else { angle = -Math.PI / 2.0; } } else { if (edge == RectangleEdge.TOP) { anchor = TextAnchor.BOTTOM_CENTER; rotationAnchor = TextAnchor.BOTTOM_CENTER; } else { anchor = TextAnchor.TOP_CENTER; rotationAnchor = TextAnchor.TOP_CENTER; } }  DateTick tick = new DateTick(tickDate, tickLabel, anchor, rotationAnchor, angle);",
        "ins1PreCode":"protected List refreshTicksHorizontal(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) {  List result = new java.util.ArrayList();  Font tickLabelFont = getTickLabelFont(); g2.setFont(tickLabelFont);  if (isAutoTickUnitSelection()) { selectAutoTickUnit(g2, dataArea, edge); }  DateTickUnit unit = getTickUnit(); Date tickDate = calculateLowestVisibleTickValue(unit); Date upperDate = getMaximumDate();  boolean hasRolled = false; while (tickDate.before(upperDate)) {  if (!hasRolled) { tickDate = correctTickDateForPosition(tickDate, unit, this.tickMarkPosition); }  long lowestTickTime = tickDate.getTime(); long distance = unit.addToDate(tickDate, this.timeZone).getTime() - lowestTickTime; int minorTickSpaces = getMinorTickCount(); if (minorTickSpaces <= 0) { minorTickSpaces = unit.getMinorTickCount(); } for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { long minorTickTime = lowestTickTime - distance * minorTick / minorTickSpaces; if (minorTickTime > 0 && getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); } }  if (!isHiddenValue(tickDate.getTime())) {  String tickLabel; DateFormat formatter = getDateFormatOverride(); if (formatter != null) { tickLabel = formatter.format(tickDate); } else { tickLabel = this.tickUnit.dateToString(tickDate); } TextAnchor anchor, rotationAnchor; double angle = 0.0; if (isVerticalTickLabels()) { anchor = TextAnchor.CENTER_RIGHT; rotationAnchor = TextAnchor.CENTER_RIGHT; if (edge == RectangleEdge.TOP) { angle = Math.PI / 2.0; } else { angle = -Math.PI / 2.0; } } else { if (edge == RectangleEdge.TOP) { anchor = TextAnchor.BOTTOM_CENTER; rotationAnchor = TextAnchor.BOTTOM_CENTER; } else { anchor = TextAnchor.TOP_CENTER; rotationAnchor = TextAnchor.TOP_CENTER; } }  Tick tick = new DateTick(tickDate, tickLabel, anchor, rotationAnchor, angle);",
        "ins2PreCode":"protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) {  List result = new java.util.ArrayList();  Font tickLabelFont = getTickLabelFont(); g2.setFont(tickLabelFont);  if (isAutoTickUnitSelection()) { selectAutoTickUnit(g2, dataArea, edge); } DateTickUnit unit = getTickUnit(); Date tickDate = calculateLowestVisibleTickValue(unit); Date upperDate = getMaximumDate();  boolean hasRolled = false; while (tickDate.before(upperDate)) {   if (!hasRolled) { tickDate = correctTickDateForPosition(tickDate, unit, this.tickMarkPosition); }  long lowestTickTime = tickDate.getTime(); long distance = unit.addToDate(tickDate, this.timeZone).getTime() - lowestTickTime; int minorTickSpaces = getMinorTickCount(); if (minorTickSpaces <= 0) { minorTickSpaces = unit.getMinorTickCount(); } for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { long minorTickTime = lowestTickTime - distance * minorTick / minorTickSpaces; if (minorTickTime > 0 && getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); } } if (!isHiddenValue(tickDate.getTime())) {  String tickLabel; DateFormat formatter = getDateFormatOverride(); if (formatter != null) { tickLabel = formatter.format(tickDate); } else { tickLabel = this.tickUnit.dateToString(tickDate); } TextAnchor anchor, rotationAnchor; double angle = 0.0; if (isVerticalTickLabels()) { anchor = TextAnchor.BOTTOM_CENTER; rotationAnchor = TextAnchor.BOTTOM_CENTER; if (edge == RectangleEdge.LEFT) { angle = -Math.PI / 2.0; } else { angle = Math.PI / 2.0; } } else { if (edge == RectangleEdge.LEFT) { anchor = TextAnchor.CENTER_RIGHT; rotationAnchor = TextAnchor.CENTER_RIGHT; } else { anchor = TextAnchor.CENTER_LEFT; rotationAnchor = TextAnchor.CENTER_LEFT; } }  Tick tick = new DateTick(tickDate, tickLabel, anchor, rotationAnchor, angle);",
        "label":1
    },
    {
        "ins1CurCode":"protected void updateListeners(Object oldOwner, Object newOwner) {  if (isCompartmentVisible(Model.getMetaTypes().getAttribute())) { Set<Object[]> listeners = new HashSet<Object[]>();",
        "ins1PreCode":"protected void updateListeners(Object oldOwner, Object newOwner) {  if (isAttributesVisible()) { Set<Object[]> listeners = new HashSet<Object[]>();",
        "ins2PreCode":"protected void updateListeners(Object oldOwner, Object newOwner) { Set<Object[]> listeners = new HashSet<Object[]>();   if (newOwner != null) {         listeners.add(new Object[] {newOwner, null});    for (Object stereotype : Model.getFacade().getStereotypes(newOwner)) { listeners.add(new Object[] {stereotype, null}); }   for (Object feat : Model.getFacade().getFeatures(newOwner)) { listeners.add(new Object[] {feat, null});  for (Object stereotype : Model.getFacade().getStereotypes(feat)) { listeners.add(new Object[] {stereotype, null}); }  if (Model.getFacade().isAOperation(feat)) { for (Object param : Model.getFacade().getParameters(feat)) { listeners.add(new Object[] {param, null});   } } } }    updateElementListeners(listeners);",
        "label":0
    },
    {
        "ins1CurCode":"Objects.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new ObservableZip<>(sources, null, zipper, bufferSize, delayError));",
        "ins1PreCode":"Objects.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));",
        "ins2PreCode":"Objects.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));",
        "label":1
    },
    {
        "ins1CurCode":"Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false)); ",
        "ins1PreCode":"Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(WsListener.class.getName()); ",
        "ins2PreCode":"org.apache.catalina.Context ctx = tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath()); ctx.addApplicationListener(WsListener.class.getName()); ",
        "label":1
    },
    {
        "ins1CurCode":"series.addOrUpdate(1.0, 1.0); series.addOrUpdate(1.0, 2.0); assertEquals(1.0, series.getY(0)); assertEquals(2.0, series.getY(1)); assertEquals(2, series.getItemCount());",
        "ins1PreCode":"series.addOrUpdate(1.0, 1.0); series.addOrUpdate(1.0, 2.0); assertEquals(new Double(1.0), series.getY(0)); assertEquals(new Double(2.0), series.getY(1)); assertEquals(2, series.getItemCount());",
        "ins2PreCode":"series.addOrUpdate(1.0, 2.0); series.addOrUpdate(1.0, 3.0); assertEquals(new Double(1.0), series.getY(0)); assertEquals(new Double(2.0), series.getY(1)); assertEquals(new Double(3.0), series.getY(2)); assertEquals(3, series.getItemCount());",
        "label":0
    },
    {
        "ins1CurCode":"void shouldFlushAllItemsOnDemand() { Cache cache = new SoftCache(new PerpetualCache(\"default\"));",
        "ins1PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new SoftCache(new PerpetualCache(\"default\"));",
        "ins2PreCode":"public void shouldFlushAllItemsOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\"));",
        "label":1
    },
    {
        "ins1CurCode":" List<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":"assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional());",
        "label":0
    },
    {
        "ins1CurCode":"public void nodes_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  Set<Integer> nodes = network.nodes();",
        "ins1PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2);",
        "ins2PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addNode(N1); assertThat(network.nodes()).containsExactlyElementsIn(nodes); }",
        "label":0
    },
    {
        "ins1CurCode":"public void resumeNextWithSynchronousExecution() { final AtomicReference<Throwable> receivedException = new AtomicReference<>(); Flowable<String> w = Flowable.unsafeCreate(new Publisher<String>() {",
        "ins1PreCode":"public void resumeNextWithSynchronousExecution() { final AtomicReference<Throwable> receivedException = new AtomicReference<Throwable>(); Flowable<String> w = Flowable.unsafeCreate(new Publisher<String>() {",
        "ins2PreCode":"public void resumeNextWithSynchronousExecution() { final AtomicReference<Throwable> receivedException = new AtomicReference<Throwable>(); Observable<String> w = Observable.unsafeCreate(new ObservableSource<String>() {",
        "label":1
    },
    {
        "ins1CurCode":"static String generateExpression(Object expr) { if (Model.getFacade().isAExpression(expr)) { return generateUninterpreted( (String) Model.getFacade().getBody(expr)); } else if (Model.getFacade().isAConstraint(expr)) { return generateExpression(Model.getFacade().getBody(expr));",
        "ins1PreCode":"static String generateExpression(Object expr) { if (Model.getFacade().isAExpression(expr)) return generateUninterpreted( (String) Model.getFacade().getBody(expr)); else if (Model.getFacade().isAConstraint(expr)) return generateExpression(Model.getFacade().getBody(expr));",
        "ins2PreCode":"private static String generateExpression(Object expr) { if (Model.getFacade().isAExpression(expr)) { return generateUninterpreted( (String) Model.getFacade().getBody(expr)); } else if (Model.getFacade().isAConstraint(expr)) { return generateExpression(Model.getFacade().getBody(expr)); } return \"\";",
        "label":0
    },
    {
        "ins1CurCode":"}  downstream.onComplete(); } else { downstream.onComplete(); disposeResource(); }",
        "ins1PreCode":"}  upstream.dispose(); downstream.onComplete(); } else { downstream.onComplete(); upstream.dispose(); disposeResource();",
        "ins2PreCode":"}  upstream.cancel(); downstream.onComplete(); } else { downstream.onComplete(); upstream.cancel(); disposeResource();",
        "label":1
    },
    {
        "ins1CurCode":"}; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) { transport.start();",
        "ins1PreCode":"}; try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher)) { transport.start();",
        "ins2PreCode":"}; try (Netty4HttpServerTransport transport = new Netty4HttpServerTransport(settings, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher, clusterSettings)) { transport.start();",
        "label":1
    },
    {
        "ins1CurCode":"public void testPatternSplitLookBehind() { if (!CommonPattern.isPcreLike()) { return;",
        "ins1PreCode":"public void testPatternSplitLookBehind() { if (!Platform.usingJdkPatternCompiler()) { return;",
        "ins2PreCode":"public void testPatternSplitLookBehind() { if (!Platform.usingJdkPatternCompiler()) { return;",
        "label":1
    },
    {
        "ins1CurCode":"void propertiesAsMap() { SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class) .contextFactory(ApplicationContextFactory.forContextClass(StaticApplicationContext.class)) .properties(Collections.singletonMap(\"bar\", \"foo\"));",
        "ins1PreCode":"public void propertiesAsMap() { SpringApplicationBuilder application = new SpringApplicationBuilder() .sources(ExampleConfig.class).contextClass(StaticApplicationContext.class) .properties(Collections.singletonMap(\"bar\", \"foo\"));",
        "ins2PreCode":"void propertiesAsProperties() { SpringApplicationBuilder application = new SpringApplicationBuilder().sources(ExampleConfig.class) .contextClass(StaticApplicationContext.class) .properties(StringUtils.splitArrayElementsIntoProperties(new String[] { \"bar=foo\" }, \"=\"));",
        "label":1
    },
    {
        "ins1CurCode":"void testSerialization() throws IOException { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.Article);  entry.setField(StandardField.AUTHOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins1PreCode":"void testSerialization() throws IOException { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.Article);  entry.setField(StandardField.AUTHOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins2PreCode":"void writeEntryWithOrField() throws Exception { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.InBook);  entry.setField(StandardField.EDITOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@InBook{,\" + OS.NEWLINE + \"  editor  = {Foo Bar},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1CurCode":"List<Blog> blogs = mapper.selectBlogsWithAutorAndPosts(); assertEquals(2, blogs.size()); assertTrue(blogs.get(0) instanceof Proxy); assertEquals(101, blogs.get(0).getAuthor().getId()); assertEquals(1, blogs.get(0).getPosts().size()); assertEquals(1, blogs.get(0).getPosts().get(0).getId()); assertTrue(blogs.get(1) instanceof Proxy); assertEquals(102, blogs.get(1).getAuthor().getId());",
        "ins1PreCode":"List<Blog> blogs = mapper.selectBlogsWithAutorAndPosts(); assertEquals(2, blogs.size()); assertTrue(blogs.get(0) instanceof Factory); assertEquals(101, blogs.get(0).getAuthor().getId()); assertEquals(1, blogs.get(0).getPosts().size()); assertEquals(1, blogs.get(0).getPosts().get(0).getId()); assertTrue(blogs.get(1) instanceof Factory); assertEquals(102, blogs.get(1).getAuthor().getId());",
        "ins2PreCode":"public void shouldGetBlogsWithAuthorsAndPostsEagerly() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); List<Blog> blogs = mapper.selectBlogsWithAutorAndPostsEagerly(); assertEquals(2, blogs.size()); assertFalse(blogs.get(0) instanceof Factory); assertEquals(101, blogs.get(0).getAuthor().getId()); assertEquals(1, blogs.get(0).getPosts().size()); assertEquals(1, blogs.get(0).getPosts().get(0).getId()); assertFalse(blogs.get(1) instanceof Factory); assertEquals(102, blogs.get(1).getAuthor().getId()); assertEquals(1, blogs.get(1).getPosts().size()); assertEquals(2, blogs.get(1).getPosts().get(0).getId()); } finally { session.close(); }",
        "label":0
    },
    {
        "ins1CurCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "ins1PreCode":"throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input reader missing\" ); }",
        "ins2PreCode":"throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input stream missing\" ); }",
        "label":1
    },
    {
        "ins1CurCode":"QueryStats q2 = new QueryStats(\"def\"); q2.add(0, 100); Assert.assertEquals(1, queryStatsComparator.compare(q1, q2)); Assert.assertEquals(-1, queryStatsComparator.compare(q2, q1));",
        "ins1PreCode":"QueryStats q2 = new QueryStats(\"def\"); q2.add(0, 100); Assert.assertEquals(-1, queryStatsComparator.compare(q1, q2)); Assert.assertEquals(1, queryStatsComparator.compare(q2, q1));",
        "ins2PreCode":"public void testQueryStatsBothWithSameLastInvocation() throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Comparator<QueryStats> queryStatsComparator = createComparator(); QueryStats q1 = new QueryStats(\"abc\"); QueryStats q2 = new QueryStats(\"def\"); q1.add(0, 100); q2.add(0, 100); Assert.assertEquals(0, queryStatsComparator.compare(q1, q2)); Assert.assertEquals(0, queryStatsComparator.compare(q2, q1));",
        "label":0
    },
    {
        "ins1CurCode":"public void parseLevelsNone() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins1PreCode":"public void parseLevelsNone() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins2PreCode":"public void parseLevelsMapsFalseToOff() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "label":1
    },
    {
        "ins1CurCode":"public void bindToArrayWhenNotInOrderShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToArrayWhenNotInOrderShouldReturnPopulatedArray() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToCollectionWhenNotInOrderShouldReturnPopulatedCollection() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"TermQuery termQuery1 = new TermQuery(new Term(\"_field\", \"_term\")); ConstantScoreQuery constantScoreQuery = new ConstantScoreQuery(termQuery1); Result result = analyze(constantScoreQuery); assertThat(result.verified, is(true));",
        "ins1PreCode":"TermQuery termQuery1 = new TermQuery(new Term(\"_field\", \"_term\")); ConstantScoreQuery constantScoreQuery = new ConstantScoreQuery(termQuery1); Result result = analyze(constantScoreQuery, Version.CURRENT); assertThat(result.verified, is(true));",
        "ins2PreCode":"TermQuery termQuery1 = new TermQuery(new Term(\"_field\", \"_term\")); BoostQuery constantScoreQuery = new BoostQuery(termQuery1, 1f); Result result = analyze(constantScoreQuery, Version.CURRENT); assertThat(result.verified, is(true));",
        "label":1
    },
    {
        "ins1CurCode":"headers.put(\"Content-Length\", String.valueOf(content.remaining())); session.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SUCCESS_OK, headers)); session.write(new HttpContentChunk(content)); session.write(new HttpEndOfContent());",
        "ins1PreCode":"headers.put(\"Content-Length\", String.valueOf(content.remaining())); session.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SUCCESS_OK, headers)); session.write(content); session.write(new HttpEndOfContent());",
        "ins2PreCode":"public void sendResponse(IoSession session, HttpRequest request) { Map<String, String> headers = new HashMap<String, String>(); headers.put(\"Server\", \"Apache MINA Dummy test server/0.0.\"); headers.put(\"Date\", DateUtil.getCurrentAsString()); headers.put(\"Connection\", \"Close\"); String strContent = \"Hello ! we reply to request !\"; ByteBuffer content = ByteBuffer.wrap(strContent.getBytes());   headers.put(\"Content-Length\", String.valueOf(content.remaining())); session.write(new DefaultHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SUCCESS_OK, headers)); session.write(content); session.write(new HttpEndOfContent()); ",
        "label":0
    },
    {
        "ins1CurCode":"void testSelectWithTeacher() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor();",
        "ins1PreCode":"public void testSelectWithTeacher() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor();",
        "ins2PreCode":"public void testSelectNoName() { SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryWithConstructor();",
        "label":1
    },
    {
        "ins1CurCode":" CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) CloneUtils.cloneList(this.subplots); for (XYPlot child : result.subplots) {",
        "ins1PreCode":" CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) ObjectUtils.deepClone(this.subplots); for (XYPlot child : result.subplots) {",
        "ins2PreCode":"public Object clone() throws CloneNotSupportedException { CombinedRangeCategoryPlot result = (CombinedRangeCategoryPlot) super.clone(); result.subplots = CloneUtils.cloneList(this.subplots); for (Plot child : result.subplots) { child.setParent(result); }    ValueAxis rangeAxis = result.getRangeAxis(); if (rangeAxis != null) { rangeAxis.configure(); }  return result;",
        "label":0
    },
    {
        "ins1CurCode":"runner.runScript(reader); } catch (Exception ex) { Assert.fail(ex.getMessage()); }",
        "ins1PreCode":"runner.runScript(reader); } catch (Exception ex) { ex.printStackTrace(); }",
        "ins2PreCode":"runner.runScript(reader); } catch (Exception ex) { ex.printStackTrace(); }",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Observable<String>> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void concatNonBlockingObservables() {  final CountDownLatch okToContinueW1 = new CountDownLatch(1); final CountDownLatch okToContinueW2 = new CountDownLatch(1);  final TestObservable<String> w1 = new TestObservable<String>(null, okToContinueW1, \"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(null, okToContinueW2, \"four\", \"five\", \"six\");  Subscriber<String> subscriber = TestHelper.mockSubscriber();  Flowable<Flowable<String>> observableOfObservables = Flowable.unsafeCreate(new Publisher<Flowable<String>>() {  @Override public void subscribe(Subscriber<? super Flowable<String>> subscriber) { subscriber.onSubscribe(new BooleanSubscription());  subscriber.onNext(Flowable.unsafeCreate(w1)); subscriber.onNext(Flowable.unsafeCreate(w2)); subscriber.onComplete(); }  }); Flowable<String> concat = Flowable.concat(observableOfObservables); concat.subscribe(subscriber);  verify(subscriber, times(0)).onComplete();  try {  okToContinueW1.countDown(); okToContinueW2.countDown();  w1.t.join(); w2.t.join(); } catch (InterruptedException e) { e.printStackTrace(); }  InOrder inOrder = inOrder(subscriber); inOrder.verify(subscriber, times(1)).onNext(\"one\"); inOrder.verify(subscriber, times(1)).onNext(\"two\"); inOrder.verify(subscriber, times(1)).onNext(\"three\"); inOrder.verify(subscriber, times(1)).onNext(\"four\"); inOrder.verify(subscriber, times(1)).onNext(\"five\"); inOrder.verify(subscriber, times(1)).onNext(\"six\"); verify(subscriber, times(1)).onComplete(); ",
        "label":0
    },
    {
        "ins1CurCode":"throw new TestException(); } return new ArrayList<>(); }",
        "ins1PreCode":"throw new TestException(); } return new ArrayList<Integer>(); }",
        "ins2PreCode":"throw new TestException(); } return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1CurCode":" try { value = Objects.requireNonNull(callable.call(), \"The callable returned a null value\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { value = ObjectHelper.requireNonNull(callable.call(), \"The callable returned a null value\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { value = ObjectHelper.requireNonNull(supplier.get(), \"The supplier returned a null value\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"private void assertMapValuesSet(TestMap message) { assertEquals(3, message.getInt32ToInt32FieldMap().size()); assertEquals(11, message.getInt32ToInt32FieldMap().get(1).intValue()); assertEquals(22, message.getInt32ToInt32FieldMap().get(2).intValue()); assertEquals(33, message.getInt32ToInt32FieldMap().get(3).intValue());  assertEquals(3, message.getInt32ToStringFieldMap().size()); assertEquals(\"11\", message.getInt32ToStringFieldMap().get(1)); assertEquals(\"22\", message.getInt32ToStringFieldMap().get(2)); assertEquals(\"33\", message.getInt32ToStringFieldMap().get(3));  assertEquals(3, message.getInt32ToBytesFieldMap().size()); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesFieldMap().get(1)); assertEquals(TestUtil.toBytes(\"22\"), message.getInt32ToBytesFieldMap().get(2)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesFieldMap().get(3));  assertEquals(3, message.getInt32ToEnumFieldMap().size()); assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumFieldMap().get(1)); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumFieldMap().get(2)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumFieldMap().get(3));  assertEquals(3, message.getInt32ToMessageFieldMap().size()); assertEquals(11, message.getInt32ToMessageFieldMap().get(1).getValue()); assertEquals(22, message.getInt32ToMessageFieldMap().get(2).getValue()); assertEquals(33, message.getInt32ToMessageFieldMap().get(3).getValue());  assertEquals(3, message.getStringToInt32FieldMap().size()); assertEquals(11, message.getStringToInt32FieldMap().get(\"1\").intValue()); assertEquals(22, message.getStringToInt32FieldMap().get(\"2\").intValue()); assertEquals(33, message.getStringToInt32FieldMap().get(\"3\").intValue());",
        "ins1PreCode":"private void assertMapValuesSet(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(11, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(22, message.getInt32ToInt32Field().get(2).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue());  assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"11\", message.getInt32ToStringField().get(1)); assertEquals(\"22\", message.getInt32ToStringField().get(2)); assertEquals(\"33\", message.getInt32ToStringField().get(3));  assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"22\"), message.getInt32ToBytesField().get(2)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3));  assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(2)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3));  assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(11, message.getInt32ToMessageField().get(1).getValue()); assertEquals(22, message.getInt32ToMessageField().get(2).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue());  assertEquals(3, message.getStringToInt32Field().size()); assertEquals(11, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(22, message.getStringToInt32Field().get(\"2\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue());",
        "ins2PreCode":"private void assertMapValuesUpdated(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(111, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(4).intValue());  assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"111\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"44\", message.getInt32ToStringField().get(4));  assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesField().get(4));  assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumField().get(4));  assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(111, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(44, message.getInt32ToMessageField().get(4).getValue());  assertEquals(3, message.getStringToInt32Field().size()); assertEquals(111, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32Field().get(\"4\").intValue());",
        "label":1
    },
    {
        "ins1CurCode":"existing.removeChangeListener(this); } this.datasets.put(index, dataset); if (dataset != null) {",
        "ins1PreCode":"existing.removeChangeListener(this); } this.datasets.set(index, dataset); if (dataset != null) {",
        "ins2PreCode":"public void setDataset(int index, XYDataset<S> dataset) { XYDataset<S> existing = getDataset(index); if (existing != null) { existing.removeChangeListener(this); } this.datasets.put(index, dataset); if (dataset != null) { dataset.addChangeListener(this); }   DatasetChangeEvent event = new DatasetChangeEvent(this, dataset); datasetChanged(event);",
        "label":0
    },
    {
        "ins1CurCode":"public void usingDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "ins1PreCode":"public void usingDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "ins2PreCode":"public void usingDoesNotDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<String>(); final Supplier<Resource> resourceFactory = createResourceFactory(events);",
        "label":1
    },
    {
        "ins1CurCode":"public void testPoolThreads10Connections10Validate() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "ins1PreCode":"public void testPoolThreads10Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testPoolThreads10Connections10ValidateFair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":"public void customExceptionConversionWord() { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf( containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins1PreCode":"public void customExceptionConversionWord() throws Exception { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf( containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins2PreCode":"public void customExceptionConversionWord() throws Exception { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf( containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Notification<Object>> observer) { observer.onSubscribe(Disposable.empty()); observer.onNext(Notification.createOnComplete());",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Notification<Object>> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(Notification.createOnComplete());",
        "ins2PreCode":"public void nonNotificationInstanceAfterDispose() { new Flowable<Notification<Object>>() { @Override protected void subscribeActual(Subscriber<? super Notification<Object>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(Notification.createOnComplete()); subscriber.onNext(Notification.<Object>createOnNext(1)); } } .dematerialize(Functions.<Notification<Object>>identity()) .test() .assertResult();",
        "label":0
    },
    {
        "ins1CurCode":"throws Exception { List<MavenProject> projects = new ArrayList<>(); ",
        "ins1PreCode":"throws Exception { List<MavenProject> projects = new ArrayList<MavenProject>(); ",
        "ins2PreCode":"throws Exception { List<MavenProject> projects = new ArrayList<MavenProject>(); ",
        "label":1
    },
    {
        "ins1CurCode":"try { while (loopcount.get()<iter) { Assert.assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); ds.getPool().testAllIdle(); ds.getPool().checkAbandoned(); ds.getPool().checkIdle(); } }catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } for (int i=0; i<threads.length; i++) { threads[i].join(); } System.out.println(\"Connect count:\"+Driver.connectCount.get()); System.out.println(\"DisConnect count:\"+Driver.disconnectCount.get()); Assert.assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); Assert.assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); Assert.assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); Assert.assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "ins1PreCode":"try { while (loopcount.get()<iter) { assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); ds.getPool().testAllIdle(); ds.getPool().checkAbandoned(); ds.getPool().checkIdle(); } }catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } for (int i=0; i<threads.length; i++) { threads[i].join(); } System.out.println(\"Connect count:\"+Driver.connectCount.get()); System.out.println(\"DisConnect count:\"+Driver.disconnectCount.get()); assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "ins2PreCode":"try { while (loopcount.get()<iter) { assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); ds.getPool().testAllIdle(); ds.getPool().checkAbandoned(); ds.getPool().checkIdle(); } }catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } for (int i=0; i<threads.length; i++) { threads[i].join(); } System.out.println(\"Connect count:\"+Driver.connectCount.get()); System.out.println(\"DisConnect count:\"+Driver.disconnectCount.get()); assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void run() { DisposableHelper.replace(d, Disposable.empty()); }",
        "ins1PreCode":"@Override public void run() { DisposableHelper.replace(d, Disposables.empty()); }",
        "ins2PreCode":"@Override public void run() { DisposableHelper.set(d, Disposables.empty()); }",
        "label":1
    },
    {
        "ins1CurCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  TestSubscriber<String> ts = new TestSubscriber<>(subscriber, Long.MAX_VALUE); flowable.subscribe(ts);",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  TestSubscriber<String> ts = new TestSubscriber<String>(subscriber, Long.MAX_VALUE); flowable.subscribe(ts);",
        "ins2PreCode":" Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); observable.subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"assertFalse(rco.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertFalse(rco.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertFalse(rco.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"}  List<Dependency> list = new ArrayList<>( artifacts.size() ); ",
        "ins1PreCode":"}  List<Dependency> list = new ArrayList<Dependency>( artifacts.size() ); ",
        "ins2PreCode":"}  List<Dependency> list = new ArrayList<Dependency>( artifacts.size() ); ",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals( \"select userid from account where userid = 'j2ee'\" + LINE_SEPARATOR + LINE_SEPARATOR + \"USERID\\t\" + LINE_SEPARATOR + \"j2ee\\t\" + LINE_SEPARATOR, sw.toString());",
        "ins1PreCode":" assertEquals( \"select userid from account where userid = 'j2ee'\" + System.getProperty(\"line.separator\") + System.getProperty(\"line.separator\") + \"USERID\\t\" + System.getProperty(\"line.separator\") + \"j2ee\\t\" + System.getProperty(\"line.separator\"), sw.toString());",
        "ins2PreCode":" assertEquals( \"select userid from account where userid = 'j2ee';\" + System.getProperty(\"line.separator\") + System.getProperty(\"line.separator\") + \"USERID\\t\" + System.getProperty(\"line.separator\") + \"j2ee\\t\" + System.getProperty(\"line.separator\"), sw.toString());",
        "label":1
    },
    {
        "ins1CurCode":" try { Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\");",
        "ins1PreCode":" try { Map parms = new HashMap(); parms.put(\"name\", \"Fred\");",
        "ins2PreCode":" try { Map parms = new HashMap(); parms.put(\"name\", \"Fred\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator(); BubbleXYItemLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { BubbleXYItemLabelGenerator g1 = new BubbleXYItemLabelGenerator(); BubbleXYItemLabelGenerator g2 = (BubbleXYItemLabelGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StandardCategorySeriesLabelGenerator g1 = new StandardCategorySeriesLabelGenerator(\"{1}\"); StandardCategorySeriesLabelGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(ts); ts.awaitDone(10, TimeUnit.SECONDS); ts.assertNoErrors();",
        "ins1PreCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors();",
        "ins2PreCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(100, 1).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors();",
        "label":1
    },
    {
        "ins1CurCode":"}  checkAtReturnAndSignatureMatch(\"Maybe\", m, e, \"Flowable\", \"Observable\", \"Maybe\", \"Single\", \"Completable\", \"Disposable\", \"Iterable\", \"Stream\", \"Future\", \"CompletionStage\");  aOrAn(e, m, \"Maybe\"); missingClosingDD(e, m, \"Maybe\", \"io.reactivex.rxjava3.core\"); backpressureMentionedWithoutAnnotation(e, m, \"Maybe\");",
        "ins1PreCode":"} aOrAn(e, m, \"Maybe\"); missingClosingDD(e, m, \"Maybe\"); backpressureMentionedWithoutAnnotation(e, m, \"Maybe\");",
        "ins2PreCode":" aOrAn(e, m, \"Single\"); missingClosingDD(e, m, \"Single\"); backpressureMentionedWithoutAnnotation(e, m, \"Single\");",
        "label":1
    },
    {
        "ins1CurCode":".setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"accuracy\"); double accuracy = evaluator.evaluate(predictions);",
        "ins1PreCode":".setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions);",
        "ins2PreCode":".setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions);",
        "label":1
    },
    {
        "ins1CurCode":"String name = Model.getFacade().getName(op); assertEquals(\"Operation name incorrect\", \"myOperB\", name); String notationStr = notation.toString(aCallState, NotationSettings.getDefaultSettings()); assertEquals(\"Notation not correctly generated\", \"myOperB\\n(ClassB)\",",
        "ins1PreCode":"String name = Model.getFacade().getName(op); assertEquals(\"Operation name incorrect\", \"myOperB\", name); String notationStr = notation.toString(aCallState, null); assertEquals(\"Notation not correctly generated\", \"myOperB\\n(ClassB)\",",
        "ins2PreCode":"Object op = Model.getFacade().getOperation(entry); assertNotNull(\"Operation not linked to entry action\", op); String notationStr = notation.toString(aCallState, null); assertEquals(\"Notation not correctly generated\", \"myOper\\n(ClassA)\",",
        "label":1
    },
    {
        "ins1CurCode":"final int weight_n1 = weight[n1]; final int weight_n2 = weight[n2]; weight[nNodes] = (weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00) | 1 + ((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff) ? weight_n1 & 0x000000ff : weight_n2 & 0x000000ff); ",
        "ins1PreCode":"final int weight_n1 = weight[n1]; final int weight_n2 = weight[n2]; weight[nNodes] = (((weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)) | (1 + (((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)) ? (weight_n1 & 0x000000ff) : (weight_n2 & 0x000000ff)) )); ",
        "ins2PreCode":"private static void hbMakeCodeLengths(final byte[] len, final int[] freq, final Data dat, final int alphaSize, final int maxLen) {     final int[] heap = dat.heap; final int[] weight = dat.weight; final int[] parent = dat.parent;  for (int i = alphaSize; --i >= 0;) { weight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8; }  for (boolean tooLong = true; tooLong;) { tooLong = false;  int nNodes = alphaSize; int nHeap = 0; heap[0] = 0; weight[0] = 0; parent[0] = -2;  for (int i = 1; i <= alphaSize; i++) { parent[i] = -1; nHeap++; heap[nHeap] = i;  int zz = nHeap; int tmp = heap[zz]; while (weight[tmp] < weight[heap[zz >> 1]]) { heap[zz] = heap[zz >> 1]; zz >>= 1; } heap[zz] = tmp; }  while (nHeap > 1) { int n1 = heap[1]; heap[1] = heap[nHeap]; nHeap--;  int yy = 0; int zz = 1; int tmp = heap[1];  while (true) { yy = zz << 1;  if (yy > nHeap) { break; }  if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) { yy++; }  if (weight[tmp] < weight[heap[yy]]) { break; }  heap[zz] = heap[yy]; zz = yy; }  heap[zz] = tmp;  int n2 = heap[1]; heap[1] = heap[nHeap]; nHeap--;  yy = 0; zz = 1; tmp = heap[1];  while (true) { yy = zz << 1;  if (yy > nHeap) { break; }  if ((yy < nHeap) && (weight[heap[yy + 1]] < weight[heap[yy]])) { yy++; }  if (weight[tmp] < weight[heap[yy]]) { break; }  heap[zz] = heap[yy]; zz = yy; }  heap[zz] = tmp; nNodes++; parent[n1] = parent[n2] = nNodes;  final int weight_n1 = weight[n1]; final int weight_n2 = weight[n2]; weight[nNodes] = ((weight_n1 & 0xffffff00) + (weight_n2 & 0xffffff00)) | (1 + (((weight_n1 & 0x000000ff) > (weight_n2 & 0x000000ff)) ? (weight_n1 & 0x000000ff) : (weight_n2 & 0x000000ff)));  parent[nNodes] = -1; nHeap++; heap[nHeap] = nNodes;  tmp = 0; zz = nHeap; tmp = heap[zz]; final int weight_tmp = weight[tmp]; while (weight_tmp < weight[heap[zz >> 1]]) { heap[zz] = heap[zz >> 1]; zz >>= 1; } heap[zz] = tmp;  }  for (int i = 1; i <= alphaSize; i++) { int j = 0; int k = i;  for (int parent_k; (parent_k = parent[k]) >= 0;) { k = parent_k; j++; }  len[i - 1] = (byte) j; if (j > maxLen) { tooLong = true; } }  if (tooLong) { for (int i = 1; i < alphaSize; i++) { int j = weight[i] >> 8; j = 1 + (j >> 1); weight[i] = j << 8; } } }",
        "label":0
    },
    {
        "ins1CurCode":"void getResourceAsStream() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"))) { assertThat(explodedArchive.getManifest()).isNotNull(); URLClassLoader loader = new URLClassLoader(new URL[] { explodedArchive.getUrl() }); assertThat(loader.getResourceAsStream(\"META-INF/spring/application.xml\")).isNotNull();",
        "ins1PreCode":"void getResourceAsStream() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\")); assertThat(archive.getManifest()).isNotNull(); URLClassLoader loader = new URLClassLoader(new URL[] { archive.getUrl() }); assertThat(loader.getResourceAsStream(\"META-INF/spring/application.xml\")).isNotNull();",
        "ins2PreCode":"void getResourceAsStreamNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), false); assertThat(archive.getManifest()).isNotNull(); URLClassLoader loader = new URLClassLoader(new URL[] { archive.getUrl() }); assertThat(loader.getResourceAsStream(\"META-INF/spring/application.xml\")).isNotNull();",
        "label":1
    },
    {
        "ins1CurCode":"if (netInBuffer.position() == 0) { sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler); return 1; }  TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer);  if (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler); return 1; }  String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler); return 1;",
        "ins1PreCode":"if (netInBuffer.position() == 0) { sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; }  TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer);  if (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; }  String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1;",
        "ins2PreCode":"private int processSNI() throws IOException {  int bytesRead = sc.read(netInBuffer); if (bytesRead == -1) {  return -1; } TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer);  while (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer); extractor = new TLSClientHelloExtractor(netInBuffer); }  String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: return SelectionKey.OP_READ; case UNDERFLOW:  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniDefault\")); } hostName = endpoint.getDefaultSSLHostConfigName(); clientRequestedCiphers = Collections.emptyList(); break; case NON_SECURE: netOutBuffer.clear(); netOutBuffer.put(TLSClientHelloExtractor.USE_TLS_RESPONSE); netOutBuffer.flip(); flushOutbound(); throw new IOException(sm.getString(\"channel.nio.ssl.foundHttp\")); }  if (log.isDebugEnabled()) { log.debug(sm.getString(\"channel.nio.ssl.sniHostName\", sc, hostName)); }  sslEngine = endpoint.createSSLEngine(hostName, clientRequestedCiphers, clientRequestedApplicationProtocols);    getBufHandler().expand(sslEngine.getSession().getApplicationBufferSize()); if (netOutBuffer.capacity() < sslEngine.getSession().getApplicationBufferSize()) {  log.info(sm.getString(\"channel.nio.ssl.expandNetOutBuffer\", Integer.toString(sslEngine.getSession().getApplicationBufferSize()))); } netInBuffer = ByteBufferUtils.expand(netInBuffer, sslEngine.getSession().getPacketBufferSize()); netOutBuffer = ByteBufferUtils.expand(netOutBuffer, sslEngine.getSession().getPacketBufferSize());   netOutBuffer.position(0); netOutBuffer.limit(0);   sslEngine.beginHandshake(); handshakeStatus = sslEngine.getHandshakeStatus();  return 0;",
        "label":0
    },
    {
        "ins1CurCode":"void addProfiles() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins1PreCode":"public void addProfiles() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins2PreCode":"public void addProfilesOrder() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void testZeroLengthStream() throws Throwable { try (TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort())) { StreamTask task = new StreamTask(client, \"emptyBuffer\", TimeUnit.SECONDS.toMillis(5));",
        "ins1PreCode":"public void testZeroLengthStream() throws Throwable { TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort()); try { StreamTask task = new StreamTask(client, \"emptyBuffer\", TimeUnit.SECONDS.toMillis(5)); task.run(); task.check(); } finally { client.close(); }",
        "ins2PreCode":"public void testSingleStream() throws Throwable { TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort()); try { StreamTask task = new StreamTask(client, \"largeBuffer\", TimeUnit.SECONDS.toMillis(5)); task.run(); task.check(); } finally { client.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"void testNoAstRegex() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription();  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1PreCode":"public void testNoAstRegex() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription();  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testNoAstRegexCaseSensitive() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1CurCode":"public void cancelWhileRunning() { final TestObserver<Object> to = new TestObserver<>();  FutureTask<Object> ft = new FutureTask<>(new Runnable() { @Override",
        "ins1PreCode":"public void cancelWhileRunning() { final TestObserver<Object> to = new TestObserver<Object>();  FutureTask<Object> ft = new FutureTask<Object>(new Runnable() { @Override",
        "ins2PreCode":"public void cancelAndCrashWhileRunning() { final TestObserver<Object> to = new TestObserver<Object>();  FutureTask<Object> ft = new FutureTask<Object>(new Runnable() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopping\"}, Notification.class.getName(),",
        "ins1PreCode":"), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopped\"}, Notification.class.getName(),",
        "ins2PreCode":"public MBeanNotificationInfo[] getNotificationInfo() {  if(notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[]{ new MBeanNotificationInfo(new String[] { \"j2ee.object.created\"}, Notification.class.getName(), \"servlet is created\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.starting\"}, Notification.class.getName(), \"servlet is starting\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.running\"}, Notification.class.getName(), \"servlet is running\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopped\"}, Notification.class.getName(), \"servlet start to stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.stopped\"}, Notification.class.getName(), \"servlet is stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.deleted\"}, Notification.class.getName(), \"servlet is deleted\" ) };  }  return notificationInfo;",
        "label":0
    },
    {
        "ins1CurCode":"int _la; try { setState(426); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(413); match(LBRACE); setState(414); expression(0); setState(419); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(415); match(COMMA); setState(416); expression(0); } } setState(421); _errHandler.sync(this); _la = _input.LA(1); } setState(422); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(424); match(LBRACE); setState(425); match(RBRACE);",
        "ins1PreCode":"setState(424); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,38,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(411); match(LBRACE); setState(412); expression(0); setState(417); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(413); match(COMMA); setState(414); expression(0); } } setState(419); _errHandler.sync(this); _la = _input.LA(1); } setState(420); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(422); match(LBRACE); setState(423); match(RBRACE);",
        "ins2PreCode":"setState(440); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(426); match(LBRACE); setState(427); maptoken(); setState(432); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(428); match(COMMA); setState(429); maptoken(); } } setState(434); _errHandler.sync(this); _la = _input.LA(1); } setState(435); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(437); match(LBRACE); setState(438); match(COLON);",
        "label":0
    },
    {
        "ins1CurCode":"Exception e = null; ServerSocket s = null; long pool = 0; long nativeSocket = 0; boolean isApr = tomcat.getConnector().getProtocolHandlerClassName().contains(\"Apr\"); try {  if (isApr) { pool = createAprPool(); assertTrue(pool != 0); nativeSocket = createAprSocket(port, pool); assertTrue(nativeSocket != 0); } else { s = new ServerSocket(port); } } catch (Exception e1) { e = e1; } finally { try { if (isApr) { destroyAprSocket(nativeSocket, pool); } else if (s != null) { s.close(); } } catch (Exception e2) {  } } if (e != null) { log.info(\"Exception was\", e); }",
        "ins1PreCode":"e = e1; } finally { if (s != null) { try {",
        "ins2PreCode":"e = e1; } finally { if (s != null) { try {",
        "label":1
    },
    {
        "ins1CurCode":"public void propertyFiltering() throws Exception { j.jenkins.setAuthorizationStrategy(new ProjectMatrixAuthorizationStrategy()); DumbSlave.DescriptorImpl descriptor =",
        "ins1PreCode":"public void propertyFiltering() throws Exception { DumbSlave.DescriptorImpl descriptor = j.getInstance().getDescriptorByType(DumbSlave.DescriptorImpl.class);",
        "ins2PreCode":"public void retentionFiltering() throws Exception { DumbSlave.DescriptorImpl descriptor = j.getInstance().getDescriptorByType(DumbSlave.DescriptorImpl.class); DescriptorExtensionList<RetentionStrategy<?>, Descriptor<RetentionStrategy<?>>> descriptors = RetentionStrategy.all(); assumeThat(\"we need at least two retention strategies to test this\", descriptors.size(), not(anyOf(is(0), is(1)))); assertThat(descriptor.retentionStrategyDescriptors(null), containsInAnyOrder(descriptors.toArray(new Descriptor[descriptors.size()])));  Descriptor<RetentionStrategy<?>> victim = descriptors.iterator().next(); assertThat(descriptor.retentionStrategyDescriptors(null), hasItem(victim)); DynamicFilter.descriptors().add(victim); assertThat(descriptor.retentionStrategyDescriptors(null), not(hasItem(victim))); DynamicFilter.descriptors().remove(victim); assertThat(descriptor.retentionStrategyDescriptors(null), hasItem(victim));",
        "label":0
    },
    {
        "ins1CurCode":"sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM GV$SESSION s \\n\" + \"LEFT JOIN gv$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN gv$sess_io io ON ( s.sid = io.sid)\\n\" + ",
        "ins1PreCode":"sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM V$SESSION s \\n\" + \"LEFT JOIN v$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN v$sess_io io ON ( s.sid = io.sid)\\n\" + ",
        "ins2PreCode":"public Collection<PostgreSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(\"SELECT sa.* FROM pg_catalog.pg_stat_activity sa\")) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<PostgreSession> sessions = new ArrayList<>(); while (dbResult.next()) { sessions.add(new PostgreSession(dbResult)); } return sessions; } } } catch (SQLException e) { throw new DBException(e, session.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void delayErrorIterableCancelAfterHasNext() { final TestObserver<Void> to = new TestObserver<>(); ",
        "ins1PreCode":"public void delayErrorIterableCancelAfterHasNext() { final TestObserver<Void> to = new TestObserver<Void>(); ",
        "ins2PreCode":"public void cancelAfterHasNext() { final TestObserver<Void> to = new TestObserver<Void>(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, SecurityFilterChain.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"void outcomeWhenIncludeAllWebAndExcludeMatchesShouldNotMatch() { this.contextRunner",
        "ins1PreCode":"public void outcomeWhenIncludeAllWebAndExcludeMatchesShouldNotMatch() { this.contextRunner",
        "ins2PreCode":"public void outcomeWhenIncludeMatchesAndExcludeMatchesShouldNotMatch() { this.contextRunner",
        "label":1
    },
    {
        "ins1CurCode":"throw new TestException(); } }, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts); ",
        "ins1PreCode":"throw new TestException(); } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts); ",
        "ins2PreCode":"public void innerThrows() { TestSubscriber<Integer> ts = TestSubscriber.create();  Flowable.just(1) .hide() .concatMapDelayError(new Function<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Integer v) { throw new TestException(); } }).subscribe(ts);  ts.assertNoValues(); ts.assertError(TestException.class); ts.assertNotComplete();",
        "label":0
    },
    {
        "ins1CurCode":"this.capacityHint = capacityHint; this.once = new AtomicBoolean(); Node<T> n = new Node<>(capacityHint); this.head = n; this.tail = n; this.observers = new AtomicReference<>(EMPTY);",
        "ins1PreCode":"this.capacityHint = capacityHint; this.once = new AtomicBoolean(); Node<T> n = new Node<T>(capacityHint); this.head = n; this.tail = n; this.observers = new AtomicReference<CacheDisposable<T>[]>(EMPTY);",
        "ins2PreCode":"this.capacityHint = capacityHint; this.once = new AtomicBoolean(); Node<T> n = new Node<T>(capacityHint); this.head = n; this.tail = n; this.subscribers = new AtomicReference<CacheSubscription<T>[]>(EMPTY);",
        "label":0
    },
    {
        "ins1CurCode":"public void unorderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "ins1PreCode":"public void unorderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "ins2PreCode":"public void orderedFastPathNoRequest() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "label":1
    },
    {
        "ins1CurCode":"} else if (JdbcType.CURSOR.name().equals(propertiesMap.get(\"jdbcType\"))) { propertyType = java.sql.ResultSet.class; } else if (property == null || Map.class.isAssignableFrom(parameterType)) { propertyType = Object.class;",
        "ins1PreCode":"} else if (JdbcType.CURSOR.name().equals(propertiesMap.get(\"jdbcType\"))) { propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory());",
        "ins2PreCode":"private ParameterMapping buildParameterMapping(String content) { Map<String, String> propertiesMap = parseParameterMapping(content); String property = propertiesMap.get(\"property\"); String jdbcType = propertiesMap.get(\"jdbcType\"); Class<?> propertyType; if (typeHandlerRegistry.hasTypeHandler(parameterType)) { propertyType = parameterType; } else if (JdbcType.CURSOR.name().equals(jdbcType)) { propertyType = java.sql.ResultSet.class; } else if (property != null) { MetaClass metaClass = MetaClass.forClass(parameterType, configuration.getReflectorFactory()); if (metaClass.hasGetter(property)) { propertyType = metaClass.getGetterType(property); } else { propertyType = Object.class; } } else { propertyType = Object.class; } ParameterMapping.Builder builder = new ParameterMapping.Builder(configuration, property, propertyType); if (jdbcType != null) { builder.jdbcType(resolveJdbcType(jdbcType)); } Class<?> javaType = null; String typeHandlerAlias = null; for (Map.Entry<String, String> entry : propertiesMap.entrySet()) { String name = entry.getKey(); String value = entry.getValue(); if (\"javaType\".equals(name)) { javaType = resolveClass(value); builder.javaType(javaType); } else if (\"jdbcType\".equals(name)) { builder.jdbcType(resolveJdbcType(value)); } else if (\"mode\".equals(name)) { builder.mode(resolveParameterMode(value)); } else if (\"numericScale\".equals(name)) { builder.numericScale(Integer.valueOf(value)); } else if (\"resultMap\".equals(name)) { builder.resultMapId(value); } else if (\"typeHandler\".equals(name)) { typeHandlerAlias = value; } else if (\"jdbcTypeName\".equals(name)) { builder.jdbcTypeName(value); } else if (\"property\".equals(name)) {  } else if (\"expression\".equals(name)) { builder.expression(value); } else { throw new BuilderException(\"An invalid property '\" + name + \"' was found in mapping @{\" + content + \"}.  Valid properties are \" + parameterProperties); } } if (typeHandlerAlias != null) { builder.typeHandler(resolveTypeHandler(javaType, typeHandlerAlias)); } return builder.build();",
        "label":0
    },
    {
        "ins1CurCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(\"testimport\"); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapContext, Arrays.asList(existingContributor, contributor)); contributors.withProcessedImports(this.importer, this.activationContext); verify(this.importer).resolveAndLoad(any(), this.locationResolverContext.capture(), any(), any()); ConfigDataLocationResolverContext context = this.locationResolverContext.getValue(); assertThat(context.getBootstrapContext()).isSameAs(this.bootstrapContext);",
        "ins1PreCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(\"testimport\"); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(existingContributor, contributor)); contributors.withProcessedImports(this.importer, this.activationContext); verify(this.importer).resolveAndLoad(any(), this.locationResolverContext.capture(), any(), any()); ConfigDataLocationResolverContext context = this.locationResolverContext.getValue(); assertThat(context.getBootstrapRegistry()).isSameAs(this.bootstrapRegistry);",
        "ins2PreCode":"ConfigDataEnvironmentContributor contributor = ConfigDataEnvironmentContributor.ofInitialImport(\"testimport\"); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(existingContributor, contributor)); contributors.withProcessedImports(this.importer, this.activationContext);",
        "label":0
    },
    {
        "ins1CurCode":"Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"Observable<Integer> source = Observable.range(0, 1000).replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"protected void subscribeActual(Observer<? super U> t) { if (timespan == timeskip && maxSize == Integer.MAX_VALUE) { source.subscribe(new BufferExactUnboundedObserver<>( new SerializedObserver<>(t), bufferSupplier, timespan, unit, scheduler)); return; } Scheduler.Worker w = scheduler.createWorker();  if (timespan == timeskip) { source.subscribe(new BufferExactBoundedObserver<>( new SerializedObserver<>(t), bufferSupplier, timespan, unit, maxSize, restartTimerOnMaxSize, w )); return; }   source.subscribe(new BufferSkipBoundedObserver<>( new SerializedObserver<>(t), bufferSupplier, timespan, timeskip, unit, w));",
        "ins1PreCode":"protected void subscribeActual(Observer<? super U> t) { if (timespan == timeskip && maxSize == Integer.MAX_VALUE) { source.subscribe(new BufferExactUnboundedObserver<T, U>( new SerializedObserver<U>(t), bufferSupplier, timespan, unit, scheduler)); return; } Scheduler.Worker w = scheduler.createWorker();  if (timespan == timeskip) { source.subscribe(new BufferExactBoundedObserver<T, U>( new SerializedObserver<U>(t), bufferSupplier, timespan, unit, maxSize, restartTimerOnMaxSize, w )); return; }   source.subscribe(new BufferSkipBoundedObserver<T, U>( new SerializedObserver<U>(t), bufferSupplier, timespan, timeskip, unit, w));",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super U> s) { if (timespan == timeskip && maxSize == Integer.MAX_VALUE) { source.subscribe(new BufferExactUnboundedSubscriber<T, U>( new SerializedSubscriber<U>(s), bufferSupplier, timespan, unit, scheduler)); return; } Scheduler.Worker w = scheduler.createWorker();  if (timespan == timeskip) { source.subscribe(new BufferExactBoundedSubscriber<T, U>( new SerializedSubscriber<U>(s), bufferSupplier, timespan, unit, maxSize, restartTimerOnMaxSize, w )); return; }   source.subscribe(new BufferSkipBoundedSubscriber<T, U>( new SerializedSubscriber<U>(s), bufferSupplier, timespan, timeskip, unit, w));",
        "label":1
    },
    {
        "ins1CurCode":"void testUserSpecifiedClassLoader() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\");",
        "ins1PreCode":"public void testUserSpecifiedClassLoader() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\");",
        "ins2PreCode":"public void testUserSpecifiedClassPathOrder() throws Exception { System.setProperty(\"loader.path\", \"more-jars/app.jar,jars/app.jar\");",
        "label":1
    },
    {
        "ins1CurCode":"void yamlProfiles() { this.initializer.setSearchNames(\"testprofiles\");",
        "ins1PreCode":"public void yamlProfiles() { this.initializer.setSearchNames(\"testprofiles\");",
        "ins2PreCode":"public void yamlTwoProfiles() { this.initializer.setSearchNames(\"testprofiles\");",
        "label":1
    },
    {
        "ins1CurCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot<String> plot = new XYPlot<>(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "ins1PreCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "ins2PreCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "label":1
    },
    {
        "ins1CurCode":"public void registerListener() { SpringApplication application = new SpringApplication(ExampleConfig.class,",
        "ins1PreCode":"public void registerListener() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class,",
        "ins2PreCode":"public void registerListenerWithCustomMulticaster() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class,",
        "label":1
    },
    {
        "ins1CurCode":".dispose();  Disposable bs = Disposable.empty(); ",
        "ins1PreCode":".dispose();  Disposable bs = Disposables.empty(); ",
        "ins2PreCode":".dispose();  Disposable bs = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void addProfiles() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins1PreCode":"public void addProfiles() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins2PreCode":"public void addProfilesOrder() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":1
    },
    {
        "ins1CurCode":" service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "ins1PreCode":" service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, ignored -> fieldData);",
        "ins2PreCode":" service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, ignored -> fieldData);",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribe(Subscriber<? super R>[] subscribers) { subscribers = RxJavaPlugins.onSubscribe(this, subscribers); ",
        "ins1PreCode":"public void subscribe(Subscriber<? super R>[] subscribers) { if (!validate(subscribers)) { return;",
        "ins2PreCode":"public void subscribe(Subscriber<? super R>[] subscribers) { if (!validate(subscribers)) { return; }  int n = subscribers.length;  @SuppressWarnings(\"unchecked\") final Subscriber<T>[] parents = new Subscriber[n];  for (int i = 0; i < n; i++) { parents[i] = FlowableFlatMapStream.subscribe(subscribers[i], mapper, prefetch); }  source.subscribe(parents);",
        "label":0
    },
    {
        "ins1CurCode":"void throwWhenPidFileIsReadOnly() throws Exception { withReadOnlyPidFile((file) -> { System.setProperty(\"PID_FAIL_ON_WRITE_ERROR\", \"true\"); ApplicationPidFileWriter listener = new ApplicationPidFileWriter(file); assertThatIllegalStateException().isThrownBy(() -> listener.onApplicationEvent(EVENT)) .withMessageContaining(\"Cannot create pid file\"); });",
        "ins1PreCode":"void throwWhenPidFileIsReadOnly() throws Exception { File file = new File(this.tempDir, \"pid\"); file.createNewFile(); file.setReadOnly(); System.setProperty(\"PID_FAIL_ON_WRITE_ERROR\", \"true\");",
        "ins2PreCode":"void throwWhenPidFileIsReadOnlyWithSpring() throws Exception { File file = new File(this.tempDir, \"pid\"); file.createNewFile(); file.setReadOnly(); SpringApplicationEvent event = createPreparedEvent(\"spring.pid.fail-on-write-error\", \"true\");",
        "label":1
    },
    {
        "ins1CurCode":"writer.writeAttribute(ATTR_TYPE, t.getClass().getName());  writer.writeCData(StringUtils.getStackTrace(t)); }",
        "ins1PreCode":"writer.writeAttribute(ATTR_TYPE, t.getClass().getName());  writer.writeCData(StringUtils.getStackTrace(cause.get())); }",
        "ins2PreCode":"writer.writeAttribute(ATTR_TYPE, t.getClass().getName());  writer.writeCData(StringUtils.getStackTrace(cause.get())); }",
        "label":1
    },
    {
        "ins1CurCode":"T value; try { value = ExceptionHelper.nullCheck(callable.call(), \"Callable returned a null value.\"); } catch (Throwable e) {",
        "ins1PreCode":"T value; try { value = ObjectHelper.requireNonNull(callable.call(), \"Callable returned null\"); } catch (Throwable e) {",
        "ins2PreCode":"T value; try { value = ObjectHelper.requireNonNull(supplier.get(), \"Supplier returned null\"); } catch (Throwable e) {",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Observable<T> merge( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "ins1PreCode":"public static <T> Observable<T> merge( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "ins2PreCode":"public static <T> Observable<T> mergeDelayError( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "label":1
    },
    {
        "ins1CurCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>(); ",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences)); set.add(new ACMPortalFetcher()); ",
        "ins1PreCode":"set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences));  ",
        "ins2PreCode":"public static SortedSet<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { SortedSet<IdBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); set.add(new ArXiv(importFormatPreferences)); set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new IsbnFetcher(importFormatPreferences)); set.add(new DiVA(importFormatPreferences)); set.add(new DoiFetcher(importFormatPreferences)); set.add(new MedlineFetcher()); set.add(new TitleFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences)); set.add(new CrossRef()); set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); set.add(new Medra());  return set;",
        "label":0
    },
    {
        "ins1CurCode":"Arrays.fill(a, 1);  final TestSubscriber<Integer> ts = new TestSubscriber<>(0L); ",
        "ins1PreCode":"Arrays.fill(a, 1);  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "ins2PreCode":"Arrays.fill(a, 1);  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "label":1
    },
    {
        "ins1CurCode":"public void filterCapturesSessionIdWhenSessionIsUsed() { executeFilter( MockServerWebExchange",
        "ins1PreCode":"public void filterCapturesSessionIdWhenSessionIsUsed() throws ServletException, IOException { this.filter.filter( MockServerWebExchange",
        "ins2PreCode":"public void filterDoesNotCaptureIdOfUnusedSession() throws ServletException, IOException { this.filter.filter( MockServerWebExchange",
        "label":1
    },
    {
        "ins1CurCode":"public void eventOrdering() { final List<String> list = new ArrayList<>(); ",
        "ins1PreCode":"public void eventOrdering() { final List<String> list = new ArrayList<String>(); ",
        "ins2PreCode":"public void eventOrdering2() { final List<String> list = new ArrayList<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"final Observer<Object> o = TestHelper.mockObserver();  final List<Observer<Object>> values = new ArrayList<>(); ",
        "ins1PreCode":"final Observer<Object> o = TestHelper.mockObserver();  final List<Observer<Object>> values = new ArrayList<Observer<Object>>(); ",
        "ins2PreCode":"final Observer<Object> o = TestHelper.mockObserver();  final List<Observer<Object>> values = new ArrayList<Observer<Object>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/]\"); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"app.jar\"));",
        "ins1PreCode":"PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/]\"); List<Archive> archives = CollectionUtils.iteratorToList(launcher.getClassPathArchivesIterator()); assertThat(archives).areExactly(1, endingWith(\"app.jar\"));",
        "ins2PreCode":"assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()) .isEqualTo(\"[jar:file:./src/test/resources/nested-jars/app.jar!/]\"); List<Archive> archives = CollectionUtils.iteratorToList(launcher.getClassPathArchivesIterator()); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void concatConcurrentWithInfinity() { final TestObservable<String> w1 = new TestObservable<>(\"one\", \"two\", \"three\");  final TestObservable<String> w2 = new TestObservable<>(\"hello\", Integer.MAX_VALUE);  Subscriber<String> subscriber = TestHelper.mockSubscriber();  @SuppressWarnings(\"unchecked\") TestObservable<Flowable<String>> observableOfObservables = new TestObservable<>(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2)); Flowable<String> concatF = Flowable.concat(Flowable.unsafeCreate(observableOfObservables));",
        "ins1PreCode":"public void concatConcurrentWithInfinity() { final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");  final TestObservable<String> w2 = new TestObservable<String>(\"hello\", Integer.MAX_VALUE);  Subscriber<String> subscriber = TestHelper.mockSubscriber();  @SuppressWarnings(\"unchecked\") TestObservable<Flowable<String>> observableOfObservables = new TestObservable<Flowable<String>>(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2)); Flowable<String> concatF = Flowable.concat(Flowable.unsafeCreate(observableOfObservables));",
        "ins2PreCode":"public void concatConcurrentWithInfinity() { final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\");  final TestObservable<String> w2 = new TestObservable<String>(\"hello\", Integer.MAX_VALUE);  Observer<String> observer = TestHelper.mockObserver();  @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<Observable<String>>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2)); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "label":1
    },
    {
        "ins1CurCode":"public void sizedTruncation() { SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<>(2, true); List<Integer> values = new ArrayList<>(); ",
        "ins1PreCode":"public void sizedTruncation() { SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<Integer>(2, true); List<Integer> values = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void sizedTruncation() { SizeBoundReplayBuffer<Integer> buf = new SizeBoundReplayBuffer<Integer>(2, false); List<Integer> values = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"assertEcho(result, \"01-hello 'world\"); assertEcho(result, \"02-hello \\\"world\"); assertEcho(result, \"03-hello \\\"world\"); assertEcho(result, \"04-hello world\"); assertEcho(result, \"05-hello 'world\"); assertEcho(result, \"06-hello 'world\"); assertEcho(result, \"07-hello \\\"world\"); assertEcho(result, \"08-hello world\"); assertEcho(result, \"09-hello 'world\"); assertEcho(result, \"10-hello \\\"world\"); assertEcho(result, \"11-hello \\\"world\"); assertEcho(result, \"12-hello world\"); assertEcho(result, \"13-hello 'world\"); assertEcho(result, \"14-hello 'world\"); assertEcho(result, \"15-hello \\\"world\");",
        "ins1PreCode":"assertEcho(result, \"01-hello 'world\"); assertEcho(result, \"02-hello \\\"world\"); assertEcho(result, \"03-hello world\"); assertEcho(result, \"04-hello 'world\"); assertEcho(result, \"05-hello \\\"world\"); assertEcho(result, \"06-hello world\"); assertEcho(result, \"07-hello 'world\"); assertEcho(result, \"08-hello \\\"world\"); assertEcho(result, \"09-hello world\"); assertEcho(result, \"10-hello 'world\"); assertEcho(result, \"11-hello \\\"world\"); assertEcho(result, \"12-hello world\"); assertEcho(result, \"13-hello 'world\"); assertEcho(result, \"14-hello \\\"world\"); assertEcho(result, \"15-hello world\"); assertEcho(result, \"16-hello 'world\"); assertEcho(result, \"17-hello \\\"world\");",
        "ins2PreCode":"public void testScriptingExpression() throws Exception { getTomcatInstanceTestWebapp(false, true);  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/script-expr.jsp\"); String result = res.toString(); assertEcho(result, \"00-hello world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"02-hello \\\\\\\"world\"); assertEcho(result, \"03-hello ${world\"); assertEcho(result, \"04-hello \\\\${world\"); assertEcho(result, \"05-hello world\"); assertEcho(result, \"06-hello \\\"world\"); assertEcho(result, \"07-hello \\\\\\\"world\"); assertEcho(result, \"08-hello ${world\"); assertEcho(result, \"09-hello \\\\${world\"); assertEcho(result, \"10-hello <% world\"); assertEcho(result, \"11-hello %> world\");",
        "label":0
    },
    {
        "ins1CurCode":"{ IssueManagement src = source.getIssueManagement(); if ( src != null ) {",
        "ins1PreCode":"{ IssueManagement src = source.getIssueManagement(); if ( source.getIssueManagement() != null ) {",
        "ins2PreCode":"{ Parent src = source.getParent(); if ( source.getParent() != null ) {",
        "label":0
    },
    {
        "ins1CurCode":"void shouldPickSoleTypeHandlerOnXmlResultMap() { addMapper();",
        "ins1PreCode":"public void shouldPickSoleTypeHandlerOnXmlResultMap() { addMapper();",
        "ins2PreCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, JdbcType.BIGINT, ProductIdTypeHandler.class);",
        "label":1
    },
    {
        "ins1CurCode":"TestObserverEx<Integer> to0 = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> us = UnicastSubject.create();  TestHelper.emit(us, 1, 2, 3, 4, 5);  us .doAfterNext(afterNext)",
        "ins1PreCode":"TestObserverEx<Integer> to0 = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> up = UnicastSubject.create();  TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doAfterNext(afterNext)",
        "ins2PreCode":"TestObserverEx<Integer> to0 = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> up = UnicastSubject.create();  TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doAfterNext(afterNext)",
        "label":1
    },
    {
        "ins1CurCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeTrue(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\").contains(\"bye world\")); ",
        "ins1PreCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); Assume.assumeTrue(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\").contains(\"bye world\")); ",
        "ins2PreCode":"public void testFilterContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); Assume.assumeTrue(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\").contains(\"bye world\")); ",
        "label":1
    },
    {
        "ins1CurCode":"private void testServerToClient(Message msg) { EmbeddedChannel serverChannel = new EmbeddedChannel(new FileRegionEncoder(), MessageEncoder.INSTANCE); serverChannel.writeOutbound(msg);  EmbeddedChannel clientChannel = new EmbeddedChannel( NettyUtils.createFrameDecoder(), MessageDecoder.INSTANCE); ",
        "ins1PreCode":"private void testServerToClient(Message msg) { EmbeddedChannel serverChannel = new EmbeddedChannel(new FileRegionEncoder(), new MessageEncoder()); serverChannel.writeOutbound(msg);  EmbeddedChannel clientChannel = new EmbeddedChannel( NettyUtils.createFrameDecoder(), new MessageDecoder()); ",
        "ins2PreCode":"private void testClientToServer(Message msg) { EmbeddedChannel clientChannel = new EmbeddedChannel(new FileRegionEncoder(), new MessageEncoder()); clientChannel.writeOutbound(msg);  EmbeddedChannel serverChannel = new EmbeddedChannel( NettyUtils.createFrameDecoder(), new MessageDecoder()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void insertRecord( Object recordBase, long recordOffset, int length, long prefix, boolean prefixIsNull) throws IOException {  growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required);  final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length; assert(inMemSorter != null); inMemSorter.insertRecord(recordAddress, prefix, prefixIsNull);",
        "ins1PreCode":"public void insertRecord(Object recordBase, long recordOffset, int length, long prefix) throws IOException {  growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required);  final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length; assert(inMemSorter != null); inMemSorter.insertRecord(recordAddress, prefix);",
        "ins2PreCode":"public void insertRecord(Object recordBase, long recordOffset, int length, int partitionId) throws IOException {   assert(inMemSorter != null); if (inMemSorter.numRecords() > numElementsForSpillThreshold) { spill(); }  growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required);  assert(currentPage != null); final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length; inMemSorter.insertRecord(recordAddress, partitionId);",
        "label":0
    },
    {
        "ins1CurCode":"int tempPos = pos;  if (bufferSize - tempPos < FIXED32_SIZE) { refillBuffer(FIXED32_SIZE); tempPos = pos; }  final byte[] buffer = this.buffer; pos = tempPos + FIXED32_SIZE; return (((buffer[tempPos] & 0xff))",
        "ins1PreCode":"int tempPos = pos;  if (bufferSize - tempPos < FIXED_32_SIZE) { refillBuffer(FIXED_32_SIZE); tempPos = pos; }  final byte[] buffer = this.buffer; pos = tempPos + FIXED_32_SIZE; return (((buffer[tempPos] & 0xff))",
        "ins2PreCode":"int tempPos = pos;  if (limit - tempPos < FIXED_32_SIZE) { throw InvalidProtocolBufferException.truncatedMessage(); }  final byte[] buffer = this.buffer; pos = tempPos + FIXED_32_SIZE; return (((buffer[tempPos] & 0xff))",
        "label":0
    },
    {
        "ins1CurCode":"String result = res.toString();  Assert.assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "ins1PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "ins2PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "label":1
    },
    {
        "ins1CurCode":"System.out.println(\"[testDBCPThreads20Connections10] Starting fairness - DBCP\"); this.threadcount = 20; this.transferProperties(); this.tDatasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-dbcp-\"+i); threads[i].d = this.tDatasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\");",
        "ins1PreCode":"System.out.println(\"[testDBCPThreads20Connections10] Starting fairness - DBCP\"); this.threadcount = 20; init(); this.transferProperties(); this.tDatasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-dbcp-\"+i); threads[i].d = this.tDatasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testDBCPThreads20Connections10\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "ins2PreCode":"public void testPoolThreads20Connections10() throws Exception { System.out.println(\"[testPoolThreads20Connections10] Starting fairness - Tomcat JDBC - Non Fair\"); init(); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown(); ",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(SHORT_USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void onNext(@NonNull T t) { ExceptionHelper.nullCheck(t, \"onNext called with a null value.\");",
        "ins1PreCode":"public void onNext(T t) { ExceptionHelper.nullCheck(t, \"onNext called with a null value.\");",
        "ins2PreCode":"public void onNext(T t) { ExceptionHelper.nullCheck(t, \"onNext called with a null value.\");  if (terminalEvent.get() != null) { return; } Object o = NotificationLite.next(t); setCurrent(o); for (BehaviorDisposable<T> bs : subscribers.get()) { bs.emitNext(o, index); }",
        "label":0
    },
    {
        "ins1CurCode":"responseHeaders);  Assert.assertEquals(HttpServletResponse.SC_OK, rc); Assert.assertTrue(responseHeaders.containsKey(\"Transfer-Encoding\")); List<String> encodings = responseHeaders.get(\"Transfer-Encoding\"); Assert.assertEquals(1, encodings.size()); Assert.assertEquals(\"chunked\", encodings.get(0));",
        "ins1PreCode":"responseHeaders);  assertEquals(HttpServletResponse.SC_OK, rc); assertTrue(responseHeaders.containsKey(\"Transfer-Encoding\")); List<String> encodings = responseHeaders.get(\"Transfer-Encoding\"); assertEquals(1, encodings.size()); assertEquals(\"chunked\", encodings.get(0));",
        "ins2PreCode":"responseHeaders);  assertEquals(HttpServletResponse.SC_OK, rc);  assertTrue(responseHeaders.containsKey(\"Connection\")); List<String> connections = responseHeaders.get(\"Connection\"); assertEquals(1, connections.size()); assertEquals(\"close\", connections.get(0));  assertFalse(responseHeaders.containsKey(\"Transfer-Encoding\"));  assertEquals(\"OK\", responseBody.toString());",
        "label":0
    },
    {
        "ins1CurCode":"connector.setPort(port); if (StringUtils.hasText(getServerHeader())) { connector.setProperty(\"server\", getServerHeader()); }",
        "ins1PreCode":"connector.setPort(port); if (StringUtils.hasText(getServerHeader())) { connector.setAttribute(\"server\", getServerHeader()); }",
        "ins2PreCode":"connector.setPort(port); if (StringUtils.hasText(getServerHeader())) { connector.setAttribute(\"server\", getServerHeader()); }",
        "label":1
    },
    {
        "ins1CurCode":"  Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\")); ",
        "ins1PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "ins2PreCode":"  tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\"); ",
        "label":1
    },
    {
        "ins1CurCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposable.empty(); ",
        "ins1PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "ins2PreCode":"final ListCompositeDisposable cd = new ListCompositeDisposable();  final Disposable d1 = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void transitiveClosure_directedGraph() { MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N1, N3); directedGraph.putEdge(N2, N3); directedGraph.addNode(N4);  MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1);",
        "ins1PreCode":"public void transitiveClosure_directedGraph() { MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N1, N3); directedGraph.putEdge(N2, N3); directedGraph.addNode(N4);  MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1);",
        "ins2PreCode":"public void transitiveClosure_undirectedGraph() { MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(false).build(); undirectedGraph.putEdge(N1, N2); undirectedGraph.putEdge(N1, N3); undirectedGraph.putEdge(N2, N3); undirectedGraph.addNode(N4);  MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1CurCode":"public void successDetaches() throws Exception { Disposable d = Disposable.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "ins1PreCode":"public void successDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "ins2PreCode":"public void successDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "label":1
    },
    {
        "ins1CurCode":"protected String getLocalPath() { if (localPath == null) {",
        "ins1PreCode":"public String getLocalPath() { if (localPath == null) {",
        "ins2PreCode":"protected String getLocalpath() { if (m_LocalPath == null) { return \"\"; } else {  File dir = getProject().resolveFile(m_LocalPath); if (! dir.exists()) { boolean done = dir.mkdirs(); if (! done) { String msg = \"Directory \" + m_LocalPath + \" creation was not \" + \"successful for an unknown reason\"; throw new BuildException(msg, getLocation()); } getProject().log(\"Created dir: \" + dir.getAbsolutePath()); } return FLAG_OVERRIDE_WORKING_DIR + m_LocalPath; }",
        "label":0
    },
    {
        "ins1CurCode":"assertFalse(rmo.isDisposed());  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"assertFalse(rmo.isDisposed());  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"assertFalse(rmo.isDisposed());  Disposable d = Disposables.empty(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":" BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(StandardField.AUTHOR, \"Mr. Author\"); ",
        "ins1PreCode":" BibEntry entry = result.getDatabase().getEntryByKey(\"1137631\").get(); entry.setField(\"author\", \"Mr. Author\"); ",
        "ins2PreCode":"void roundtripWithUserComment() throws Exception { Path testBibtexFile = Paths.get(\"src/test/resources/testbib/bibWithUserComments.bib\"); Charset encoding = StandardCharsets.UTF_8; ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile,encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void createDirected_expectedEdgeCount() { Graph<Integer, String> directedGraph = GraphBuilder.directed() .expectedEdgeCount(EDGE_COUNT) .build(); assertThat(directedGraph.addEdge(E12, N1, N2)).isTrue();",
        "ins1PreCode":"public void createDirected_expectedEdgeCount() { DirectedGraph<Integer, String> directedGraph = Graphs.createDirected(config().expectedEdgeCount(EDGE_COUNT)); assertThat(directedGraph.addEdge(E12, N1, N2)).isTrue();",
        "ins2PreCode":"public void createUndirected_expectedEdgeCount() { UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(config().expectedEdgeCount(EDGE_COUNT)); assertThat(undirectedGraph.addEdge(E12, N1, N2)).isTrue();",
        "label":0
    },
    {
        "ins1CurCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNotNull(results); assertEquals(\"a string\", results); assertEquals(0, context.getBuffer().position());",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\\r\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1CurCode":"final ConnectableObservable<Integer> co = ps.replay();  final TestObserver<Integer> to1 = new TestObserver<>(); ",
        "ins1PreCode":"final ConnectableObservable<Integer> co = ps.replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>(); ",
        "ins2PreCode":"final ConnectableObservable<Integer> co = ps.replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDrawWithNullMaxRegular() { try { DefaultBoxAndWhiskerCategoryDataset<String, String> dataset = new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null,",
        "ins1PreCode":"public void testDrawWithNullMaxRegular() { try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null,",
        "ins2PreCode":"boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, 4.5,",
        "label":1
    },
    {
        "ins1CurCode":"{ target.setUrl( src ); target.setLocation( \"url\", source.getLocation( \"url\" ) ); } else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) ); }",
        "ins1PreCode":"{ target.setUrl( src ); } else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); } }",
        "ins2PreCode":"{ target.setUrl( src ); } else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); } }",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception {  Executor executor = createExecutor(new JdbcTransaction(ds, null, false)); try {",
        "ins1PreCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try {",
        "ins2PreCode":"public void shouldUpdateAuthor() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try {",
        "label":1
    },
    {
        "ins1CurCode":"public static void cleanDirectory(final File directory) throws IOException { if (!directory.exists()) { final String message = directory + \" does not exist\"; throw new IllegalArgumentException(message); }  if (!directory.isDirectory()) { final String message = directory + \" is not a directory\"; throw new IllegalArgumentException(message); }  final File[] files = directory.listFiles(); if (files == null) {",
        "ins1PreCode":"public static void cleanDirectory(File directory) throws IOException { if (!directory.exists()) { String message = directory + \" does not exist\"; throw new IllegalArgumentException(message); }  if (!directory.isDirectory()) { String message = directory + \" is not a directory\"; throw new IllegalArgumentException(message); }  File[] files = directory.listFiles(); if (files == null) {",
        "ins2PreCode":"private static void cleanDirectoryOnExit(File directory) throws IOException { if (!directory.exists()) {",
        "label":0
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"final BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":"public void customEnvironment() { TestSpringApplication application = new TestSpringApplication(",
        "ins1PreCode":"public void customEnvironment() throws Exception { TestSpringApplication application = new TestSpringApplication(",
        "ins2PreCode":"public void propertiesFileEnhancesEnvironment() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":1
    },
    {
        "ins1CurCode":"Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<>(observer); ",
        "ins1PreCode":"Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<String>(observer); ",
        "ins2PreCode":"Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<String>(observer); ",
        "label":1
    },
    {
        "ins1CurCode":"return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, prefetch, ErrorMode.IMMEDIATE));",
        "ins1PreCode":"return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));",
        "ins2PreCode":"return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "label":1
    },
    {
        "ins1CurCode":" builder = message.toBuilder(); setMapValuesUsingAccessors(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingAccessors(builder); message = builder.build();",
        "ins1PreCode":" builder = message.toBuilder(); setMapValuesUsingMutableMap(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValuesUsingMutableMap(builder); message = builder.build();",
        "ins2PreCode":"public void testGettersAndSetters() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); TestMap message = builder.build(); assertMapValuesCleared(message);  builder = message.toBuilder(); setMapValues(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build(); assertMapValuesUpdated(message);  builder = message.toBuilder(); builder.clear(); assertMapValuesCleared(builder); message = builder.build(); assertMapValuesCleared(message);",
        "label":0
    },
    {
        "ins1CurCode":"if (getClass() != obj.getClass()) return false; GeoEmptyValueSource other = (GeoEmptyValueSource) obj; return fieldData.equals(other.fieldData);",
        "ins1PreCode":"if (getClass() != obj.getClass()) return false; GeoEmptyValueSource other = (GeoEmptyValueSource) obj; if (!fieldData.equals(other.fieldData)) return false; return true;",
        "ins2PreCode":"if (getClass() != obj.getClass()) return false; GeoLatitudeValueSource other = (GeoLatitudeValueSource) obj; if (!fieldData.equals(other.fieldData)) return false; return true;",
        "label":1
    },
    {
        "ins1CurCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, source.isChildInheritAppendPath(), context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins1PreCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "ins2PreCode":"else if ( target.getUrl() == null ) { target.setUrl( extrapolateChildUrl( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) );",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetStartValue3() { TaskSeriesCollection c = new TaskSeriesCollection(); TaskSeries<String> s = new TaskSeries<>(\"Series 1\"); s.add(new Task(\"Task with null duration\", null));",
        "ins1PreCode":"public void testGetStartValue3() { TaskSeriesCollection c = new TaskSeriesCollection(); TaskSeries s = new TaskSeries(\"Series 1\"); s.add(new Task(\"Task with null duration\", null));",
        "ins2PreCode":"public void testGetEndValue3() { TaskSeriesCollection c = new TaskSeriesCollection(); TaskSeries s = new TaskSeries(\"Series 1\"); s.add(new Task(\"Task with null duration\", null));",
        "label":1
    },
    {
        "ins1CurCode":"final String displayName = \"displayName\";  FreeStyleProject curProject = j.createFreeStyleProject(curJobName); curProject.setDisplayName(\"currentProjectDisplayName\");  FreeStyleProject p = j.createFreeStyleProject(jobName); p.setDisplayName(displayName);",
        "ins1PreCode":"final String displayName = \"displayName\";  FreeStyleProject curProject = createFreeStyleProject(curJobName); curProject.setDisplayName(\"currentProjectDisplayName\");  FreeStyleProject p = createFreeStyleProject(jobName); p.setDisplayName(displayName);",
        "ins2PreCode":"final String jobName = \"jobName\"; final String displayName = \"displayName\"; FreeStyleProject curProject = createFreeStyleProject(curJobName); curProject.setDisplayName(\"currentProjectDisplayName\");  FreeStyleProject p = createFreeStyleProject(jobName); p.setDisplayName(displayName);",
        "label":1
    },
    {
        "ins1CurCode":"ListSet offs = null; for (Object obj : figs) { if (!(obj instanceof FigMNode)) { continue; }",
        "ins1PreCode":"ListSet offs = null; for (Object obj : figs) { if (!(obj instanceof FigMNode)) continue; FigMNode fn = (FigMNode) obj;",
        "ins2PreCode":"public ListSet computeOffenders(UMLDeploymentDiagram dd) { Collection figs = dd.getLayer().getContents(); ListSet offs = null; for (Object obj : figs) { if (!(obj instanceof FigNodeInstance)) { continue; } FigNodeInstance fn = (FigNodeInstance) obj; if (fn.getEnclosingFig() != null) { if (offs == null) { offs = new ListSet(); offs.add(dd); } offs.add(fn); } } return offs;",
        "label":0
    },
    {
        "ins1CurCode":"Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); Assertions.assertThrows(PersistenceException.class, () -> { sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms); }); }",
        "ins1PreCode":"Map<String, String> parms = new HashMap<String, String>(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms); assertEquals(1, rows); assertNull(parms.get(\"id\")); }",
        "ins2PreCode":"parms.put(\"name\", \"Fred\"); sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertTooManyValuesInSelectKey\", parms); sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertTooManyValuesInSelectKey\", parms); }",
        "label":0
    },
    {
        "ins1CurCode":"List<PluginExecution> tgt = target.getExecutions(); Map<Object, PluginExecution> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); }  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null ) { mergePluginExecution( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setExecutions( new ArrayList<>( merged.values() ) ); }",
        "ins1PreCode":"List<PluginExecution> tgt = target.getExecutions(); Map<Object, PluginExecution> merged = new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); }  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null ) { mergePluginExecution( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) ); }",
        "ins2PreCode":"List<PluginExecution> tgt = target.getExecutions(); Map<Object, PluginExecution> merged = new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );  for ( PluginExecution element : src ) { if ( sourceDominant || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); } }  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null ) { mergePluginExecution( element, existing, sourceDominant, context ); } merged.put( key, element ); }  target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) ); }",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@article{test,author=\\\"Test {\\\" Test}\\\"}\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), entry.getField(\"author\"));",
        "ins1PreCode":".parse(new StringReader(\"@article{test,author=\\\"Test {\\\" Test}\\\"}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), e.getField(\"author\"));",
        "ins2PreCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException {  ParserResult result = BibtexParser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor);  assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1CurCode":"TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatContextCustomizer.class)); factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins1PreCode":"TomcatReactiveWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; Arrays.setAll(listeners, i -> mock(TomcatContextCustomizer.class)); factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins2PreCode":"TomcatReactiveWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4]; Arrays.setAll(listeners, i -> mock(LifecycleListener.class)); factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));",
        "label":1
    },
    {
        "ins1CurCode":"Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"), new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileNamePattern()).thenReturn(\"[citationkey] - [fulltitle]\"); cleanup.cleanup(entry);",
        "ins1PreCode":"Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", path.toAbsolutePath().toString(), \"\"), new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileNamePattern()).thenReturn(\"[bibtexkey] - [fulltitle]\"); cleanup.cleanup(entry);",
        "ins2PreCode":"void movesFileWithMulitpleLinked() throws Exception { LinkedFile fileField = new LinkedFile(\"\", fileBefore.toAbsolutePath().toString(), \"\"); entry.setField(StandardField.FILE, FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), fileField, new LinkedFile(\"\", \"\", \"\"))));  when(filePreferences.getFileDirectoryPattern()).thenReturn(\"\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation( Arrays.asList(new LinkedFile(\"\", \"\", \"\"), new LinkedFile(\"\", \"test.pdf\", \"\"), new LinkedFile(\"\", \"\", \"\")))), entry.getField(StandardField.FILE)); assertFalse(Files.exists(fileBefore)); assertTrue(Files.exists(fileAfter));",
        "label":0
    },
    {
        "ins1CurCode":"AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<>(QUEUE_LINK_SIZE); queue = q;",
        "ins1PreCode":"AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(QUEUE_LINK_SIZE); queue = q;",
        "ins2PreCode":"AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(QUEUE_LINK_SIZE); queue = q;",
        "label":1
    },
    {
        "ins1CurCode":"\"AMUL\", \"ADIV\", \"AREM\", \"AAND\", \"AXOR\", \"AOR\", \"ALSH\", \"ARSH\", \"AUSH\", \"OCTAL\", \"HEX\", \"INTEGER\", \"DECIMAL\", \"STRING\", \"REGEX\", \"TRUE\", \"FALSE\", \"NULL\", \"PRIMITIVE\", \"DEF\", \"ID\", \"DOTINTEGER\", \"DOTID\"",
        "ins1PreCode":"\"AMUL\", \"ADIV\", \"AREM\", \"AAND\", \"AXOR\", \"AOR\", \"ALSH\", \"ARSH\", \"AUSH\", \"OCTAL\", \"HEX\", \"INTEGER\", \"DECIMAL\", \"STRING\", \"REGEX\", \"TRUE\", \"FALSE\", \"NULL\", \"TYPE\", \"ID\", \"DOTINTEGER\", \"DOTID\"",
        "ins2PreCode":"\"AMUL\", \"ADIV\", \"AREM\", \"AAND\", \"AXOR\", \"AOR\", \"ALSH\", \"ARSH\", \"AUSH\", \"OCTAL\", \"HEX\", \"INTEGER\", \"DECIMAL\", \"STRING\", \"REGEX\", \"TRUE\", \"FALSE\", \"NULL\", \"TYPE\", \"ID\", \"DOTINTEGER\", \"DOTID\"",
        "label":1
    },
    {
        "ins1CurCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicateErr);  Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(1, Arrays.asList(\"aa\", \"bb\"));",
        "ins1PreCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicateErr);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\"));",
        "ins2PreCode":"Single<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicateErr);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void getSize() { this.files.addFile(\"s1\", \"n1\", mock(ClassLoaderFile.class));",
        "ins1PreCode":"public void getSize() throws Exception { this.files.addFile(\"s1\", \"n1\", mock(ClassLoaderFile.class));",
        "ins2PreCode":"public void constructFromExistingSet() throws Exception { this.files.addFile(\"s1\", \"n1\", mock(ClassLoaderFile.class));",
        "label":1
    },
    {
        "ins1CurCode":"sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM GV$SESSION s \\n\" + \"LEFT JOIN gv$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN gv$sess_io io ON ( s.sid = io.sid)\\n\" + ",
        "ins1PreCode":"sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM V$SESSION s \\n\" + \"LEFT JOIN v$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN v$sess_io io ON ( s.sid = io.sid)\\n\" + ",
        "ins2PreCode":"public Collection<SQLServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { try { boolean onlyConnections = CommonUtils.getOption(options, OPTION_SHOW_ONLY_CONNECTIONS); boolean supportsDatabaseInfo = ((SQLServerDataSource) session.getDataSource()).isServerVersionAtLeast(SQLServerConstants.SQL_SERVER_2012_VERSION_MAJOR, 0);  StringBuilder sql = new StringBuilder(); sql.append(\"SELECT s.*,\"); if (supportsDatabaseInfo) { sql.append(\"db.name as database_name,\"); } else { sql.append(\"NULL as database_name,\"); } sql.append(\"c.connection_id,(select text from sys.dm_exec_sql_text(c.most_recent_sql_handle)) as sql_text\\n\") .append(\"FROM sys.dm_exec_sessions s\\n\"); if (onlyConnections) { sql.append(\"LEFT OUTER \"); } sql.append(\"JOIN sys.dm_exec_connections c ON c.session_id=s.session_id\\n\"); if (supportsDatabaseInfo) { sql.append(\"LEFT OUTER JOIN sys.sysdatabases db on db.dbid=s.database_id\\n\"); } sql.append(\"ORDER BY s.session_id DESC\");  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement( sql.toString())) { try (JDBCResultSet dbResult = dbStat.executeQuery()) { List<SQLServerSession> sessions = new ArrayList<>(); while (dbResult.next()) { sessions.add(new SQLServerSession(dbResult)); } return sessions; } } } catch (SQLException e) { throw new DBException(e, session.getDataSource()); }",
        "label":0
    },
    {
        "ins1CurCode":".assertResult(1);  assertFalse(\"Subject still has observers!\", ps.hasObservers());",
        "ins1PreCode":".assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins2PreCode":".assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "label":1
    },
    {
        "ins1CurCode":" if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns, p.getProjectSettings().getDefaultDiagramSettings()); assert (diagram != null)",
        "ins1PreCode":" if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns); assert (diagram != null)",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) {  Project p = ProjectManager.getManager().getCurrentProject(); Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); DiagramSettings settings = p.getProjectSettings().getDefaultDiagramSettings();   ArgoDiagram diagram = createDiagram(ns, settings);  p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded(ns); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "label":0
    },
    {
        "ins1CurCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))",
        "ins1PreCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(\",\") .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))",
        "ins2PreCode":"public void testCharacterSplitWithTrim() { String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = COMMA_SPLITTER .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); ASSERT.that(family).hasContentsInOrder( \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "label":0
    },
    {
        "ins1CurCode":"expected = \"NOTEQUAL\"; } Assert.assertEquals(expected, bc.toString()); ",
        "ins1PreCode":"expected = \"NOTEQUAL\"; } assertEquals(expected, bc.toString()); ",
        "ins2PreCode":" ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/\"); assertEquals(\"org.apache.naming.resources.TesterObject\", bc.toString());",
        "label":1
    },
    {
        "ins1CurCode":"if ( tgt == null ) { tgt = new IssueManagement(); target.setIssueManagement( tgt ); }",
        "ins1PreCode":"if ( tgt == null ) { target.setIssueManagement( tgt = new IssueManagement() ); }",
        "ins2PreCode":"if ( tgt == null ) { target.setCiManagement( tgt = new CiManagement() ); }",
        "label":1
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":" if (isInternalAnchor(position.getItemLabelAnchor())) { Shape bounds = TextUtils.calculateRotatedStringBounds(label, g2, (float) anchorPoint.getX(), (float) anchorPoint.getY(), position.getTextAnchor(), position.getAngle(), position.getRotationAnchor());  if (bounds != null) { if (!bar.contains(bounds.getBounds2D())) { if (!negative) { position = getPositiveItemLabelPositionFallback(); } else { position = getNegativeItemLabelPositionFallback(); } if (position != null) { anchorPoint = calculateLabelAnchorPoint( position.getItemLabelAnchor(), bar, plot.getOrientation()); } } }  }  if (position != null) { TextUtils.drawRotatedString(label, g2, (float) anchorPoint.getX(), (float) anchorPoint.getY(),",
        "ins1PreCode":" if (isInternalAnchor(position.getItemLabelAnchor())) { Shape bounds = TextUtilities.calculateRotatedStringBounds(label, g2, (float) anchorPoint.getX(), (float) anchorPoint.getY(), position.getTextAnchor(), position.getAngle(), position.getRotationAnchor());  if (bounds != null) { if (!bar.contains(bounds.getBounds2D())) { if (!negative) { position = getPositiveItemLabelPositionFallback(); } else { position = getNegativeItemLabelPositionFallback(); } if (position != null) { anchorPoint = calculateLabelAnchorPoint( position.getItemLabelAnchor(), bar, plot.getOrientation()); } } }  }  if (position != null) { TextUtilities.drawRotatedString(label, g2, (float) anchorPoint.getX(), (float) anchorPoint.getY(),",
        "ins2PreCode":" if (isInternalAnchor(position.getItemLabelAnchor())) { Shape bounds = TextUtilities.calculateRotatedStringBounds(label, g2, (float) anchorPoint.getX(), (float) anchorPoint.getY(), position.getTextAnchor(), position.getAngle(), position.getRotationAnchor());  if (bounds != null) { if (!bar.contains(bounds.getBounds2D())) { if (!negative) { position = getPositiveItemLabelPositionFallback(); } else { position = getNegativeItemLabelPositionFallback(); } if (position != null) { anchorPoint = calculateLabelAnchorPoint( position.getItemLabelAnchor(), bar, plot.getOrientation()); } } }  }  if (position != null) { TextUtilities.drawRotatedString(label, g2, (float) anchorPoint.getX(), (float) anchorPoint.getY(),",
        "label":1
    },
    {
        "ins1CurCode":"void accessManagerVetoRequest() throws Exception { given(this.accessManager.isAllowed(any(ServerHttpRequest.class))).willReturn(false);",
        "ins1PreCode":"public void accessManagerVetoRequest() throws Exception { given(this.accessManager.isAllowed(any(ServerHttpRequest.class))).willReturn(false);",
        "ins2PreCode":"public void accessManagerAllowRequest() throws Exception { given(this.accessManager.isAllowed(any(ServerHttpRequest.class))).willReturn(true);",
        "label":1
    },
    {
        "ins1CurCode":"} this.requestFactory = requestFactory; this.executor = (executor != null ? executor : Executors.newCachedThreadPool(new TunnelThreadFactory()));",
        "ins1PreCode":"} this.requestFactory = requestFactory; this.executor = (executor == null ? Executors.newCachedThreadPool(new TunnelThreadFactory()) : executor);",
        "ins2PreCode":"public ClassPathChangeUploader(String url, ClientHttpRequestFactory requestFactory) { Assert.hasLength(url, \"URL must not be empty\"); Assert.notNull(requestFactory, \"RequestFactory must not be null\"); try { this.uri = new URL(url).toURI(); } catch (URISyntaxException | MalformedURLException ex) { throw new IllegalArgumentException(\"Malformed URL '\" + url + \"'\"); } this.requestFactory = requestFactory;",
        "label":0
    },
    {
        "ins1CurCode":"public void testAllowSymlinks() { assumeTrue(\"System does not support Symlinks\", supportsSymlinks); assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\");",
        "ins1PreCode":"public void testAllowSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\");",
        "ins2PreCode":"public void testProhibitSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testAndThen() { Converter<StringWrapper, String> first = new Converter<StringWrapper, String>() { @Override protected String doForward(StringWrapper object) { return object.value; }  @Override protected StringWrapper doBackward(String object) { return new StringWrapper(object);",
        "ins1PreCode":"public void testAndThen() { Converter<StringWrapper, String> first = new Converter<StringWrapper, String>() { @Override public String doForward(StringWrapper object) { return object.value; }  @Override public StringWrapper doBackward(String object) { return new StringWrapper(object);",
        "ins2PreCode":"public void testAndThen() { Converter<StringWrapper, String> first = new Converter<StringWrapper, String>() { @Override public String doForward(StringWrapper object) { return object.value; }  @Override public StringWrapper doBackward(String object) { return new StringWrapper(object);",
        "label":1
    },
    {
        "ins1CurCode":"set.add(new RfcFetcher(importFormatPreferences)); set.add(new Medra()); set.add(new JstorFetcher(importFormatPreferences)); return set;",
        "ins1PreCode":"set.add(new RfcFetcher(importFormatPreferences)); set.add(new Medra()); return set;",
        "ins2PreCode":"set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); return set;",
        "label":1
    },
    {
        "ins1CurCode":"protected Set<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) { return entryType.get().getSecondaryOptionalNotDeprecatedFields(); } else {  return Collections.emptySet(); }",
        "ins1PreCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) { return entryType.get().getSecondaryOptionalNotDeprecatedFields(); } else {  return Collections.emptySortedSet(); }",
        "ins2PreCode":"protected SortedSet<Field> determineFieldsToShow(BibEntry entry) { Optional<BibEntryType> entryType = entryTypesManager.enrich(entry.getType(), databaseContext.getMode()); if (entryType.isPresent()) { return entryType.get().getDeprecatedFields() .stream() .filter(entry::hasField) .collect(Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(Field::getName)))); } else {  return Collections.emptySortedSet(); }",
        "label":0
    },
    {
        "ins1CurCode":" Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(\"*\")); Assert.assertTrue(((Boolean) request.getAttribute(",
        "ins1PreCode":" Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\")); Assert.assertTrue(((Boolean) request.getAttribute(",
        "ins2PreCode":" Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\")); Assert.assertTrue(((Boolean) request.getAttribute(",
        "label":1
    },
    {
        "ins1CurCode":"MockServerWebExchange .from(MockServerHttpRequest.get(\"https://api.example.com\")), (exchange) -> { exchange.getSession().block(Duration.ofSeconds(30)).getAttributes() .put(\"a\", \"alpha\"); return Mono.empty();",
        "ins1PreCode":"MockServerWebExchange .from(MockServerHttpRequest.get(\"https://api.example.com\")), new WebFilterChain() {  @Override public Mono<Void> filter(ServerWebExchange exchange) { exchange.getSession().block(Duration.ofSeconds(30)) .getAttributes().put(\"a\", \"alpha\"); return Mono.empty(); }  }).block(Duration.ofSeconds(30));",
        "ins2PreCode":"MockServerWebExchange .from(MockServerHttpRequest.get(\"https://api.example.com\")), new WebFilterChain() {  @Override public Mono<Void> filter(ServerWebExchange exchange) { exchange.getSession().block(Duration.ofSeconds(30)); return Mono.empty(); }  }).block(Duration.ofSeconds(30));",
        "label":1
    },
    {
        "ins1CurCode":"} if (packagesToScan.isEmpty()) { packagesToScan.add(ClassUtils.getPackageName(metadata.getClassName())); }",
        "ins1PreCode":"} if (packagesToScan.isEmpty()) { return Collections .singleton(ClassUtils.getPackageName(metadata.getClassName())); }",
        "ins2PreCode":"private Set<String> getPackagesToScan(AnnotationMetadata metadata) { AnnotationAttributes attributes = AnnotationAttributes.fromMap( metadata.getAnnotationAttributes(EntityScan.class.getName())); String[] basePackages = attributes.getStringArray(\"basePackages\"); Class<?>[] basePackageClasses = attributes .getClassArray(\"basePackageClasses\"); Set<String> packagesToScan = new LinkedHashSet<>(); packagesToScan.addAll(Arrays.asList(basePackages)); for (Class<?> basePackageClass : basePackageClasses) { packagesToScan.add(ClassUtils.getPackageName(basePackageClass)); } if (packagesToScan.isEmpty()) { String packageName = ClassUtils.getPackageName(metadata.getClassName()); Assert.state(!StringUtils.isEmpty(packageName), \"@EntityScan cannot be used with the default package\"); return Collections.singleton(packageName); } return packagesToScan;",
        "label":0
    },
    {
        "ins1CurCode":"TomcatHttpHandlerAdapter servlet = new TomcatHttpHandlerAdapter(httpHandler); prepareContext(tomcat.getHost(), servlet); return getTomcatWebServer(tomcat);",
        "ins1PreCode":"TomcatHttpHandlerAdapter servlet = new TomcatHttpHandlerAdapter(httpHandler); prepareContext(tomcat.getHost(), servlet); return new TomcatWebServer(tomcat, getPort() >= 0);",
        "ins2PreCode":"public WebServer getWebServer(ServletContextInitializer... initializers) { if (this.disableMBeanRegistry) { Registry.disableRegistry(); } Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol); connector.setThrowOnFailure(true); tomcat.getService().addConnector(connector); customizeConnector(connector); tomcat.setConnector(connector); tomcat.getHost().setAutoDeploy(false); configureEngine(tomcat.getEngine()); for (Connector additionalConnector : this.additionalTomcatConnectors) { tomcat.getService().addConnector(additionalConnector); } prepareContext(tomcat.getHost(), initializers); return getTomcatWebServer(tomcat);",
        "label":0
    },
    {
        "ins1CurCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); System.out.println(\"TestMultiThreadedObservable subscribed to ...\");",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestMultiThreadedObservable subscribed to ...\");",
        "ins2PreCode":"public void subscribe(final Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); System.out.println(\"TestMultiThreadedObservable subscribed to ...\"); final NullPointerException npe = new NullPointerException(); t = new Thread(new Runnable() {  @Override public void run() { try { System.out.println(\"running TestMultiThreadedObservable thread\"); for (final String s : values) { threadPool.execute(new Runnable() {  @Override public void run() { threadsRunning.incrementAndGet(); try {  if (s == null) { System.out.println(\"TestMultiThreadedObservable onNext: null\");  throw npe; } else { try { Thread.sleep(10); } catch (InterruptedException ex) {  } System.out.println(\"TestMultiThreadedObservable onNext: \" + s); } subscriber.onNext(s);  int concurrentThreads = threadsRunning.get(); int maxThreads = maxConcurrentThreads.get(); if (concurrentThreads > maxThreads) { maxConcurrentThreads.compareAndSet(maxThreads, concurrentThreads); } } catch (Throwable e) { subscriber.onError(e); } finally { threadsRunning.decrementAndGet(); } } }); }  threadPool.shutdown(); } catch (Throwable e) { throw new RuntimeException(e); }   try {  threadPool.awaitTermination(2, TimeUnit.SECONDS); } catch (InterruptedException e) { throw new RuntimeException(e); } subscriber.onComplete(); } }); System.out.println(\"starting TestMultiThreadedObservable thread\"); t.start(); System.out.println(\"done starting TestMultiThreadedObservable thread\");",
        "label":0
    },
    {
        "ins1CurCode":"void movesFile() throws Exception { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"\"); cleanup.cleanup(entry);",
        "ins1PreCode":"void movesFile() throws Exception { when(filePreferences.getFileDirPattern()).thenReturn(\"\"); cleanup.cleanup(entry);",
        "ins2PreCode":"void doesNotMoveFileWithEmptyFileDirPattern() throws Exception { when(filePreferences.getFileDirPattern()).thenReturn(\"\"); cleanup.cleanup(entry);",
        "label":1
    },
    {
        "ins1CurCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"description\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \");",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"comment\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \");",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"comment\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \"); query.append(command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL)).append(\" \"); appendTableModifiers(monitor, command.getObject(), command, query, true); actionList.add(new SQLDatabasePersistAction(query.toString())); }",
        "label":0
    },
    {
        "ins1CurCode":"public void assertNotMatchCount() { assertThrows(AssertionError.class, () -> { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<>(); oi.subscribe(ts);  ts.assertValues(1); ts.assertValueCount(2); ts.assertComplete(); ts.assertNoErrors(); });",
        "ins1PreCode":"oi.subscribe(ts);  thrown.expect(AssertionError.class); ",
        "ins2PreCode":"public void assertTestSubscriber() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<>(); oi.subscribe(ts);  ts.assertValues(1, 2); ts.assertValueCount(2); ts.assertComplete(); ts.assertNoErrors();",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StandardXYToolTipGenerator g1 = new StandardXYToolTipGenerator(); StandardXYToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StandardXYToolTipGenerator g1 = new StandardXYToolTipGenerator(); StandardXYToolTipGenerator g2 = (StandardXYToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { BoxAndWhiskerToolTipGenerator g1 = new BoxAndWhiskerToolTipGenerator(); BoxAndWhiskerToolTipGenerator g2 = (BoxAndWhiskerToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "label":1
    },
    {
        "ins1CurCode":" BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"Peptidomics of the larval {{{D}rosophila melanogaster}} central nervous system.\"); ",
        "ins1PreCode":" BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"Peptidomics of the larval {\\\\protect{{D}rosophila melanogaster}} central nervous system.\"); ",
        "ins2PreCode":"public void testCorruptedTitleUnicode(@TempDir Path testFolder) throws Exception { Path tmpFile = testFolder.resolve(\"testBraces\");  BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"Insect neuropeptide bursicon homodimers induce innate immune and stress genes during molting by activating the {NF}-$\\\\kappa$B transcription factor Relish.\");  List<BibEntry> entries = Arrays.asList(entry);  exportFormat.export(databaseContext, tmpFile, charset, entries);  List<String> lines = Files.readAllLines(tmpFile); assertEquals(20, lines.size()); assertEquals(\"   <citetitle pubwork=\\\"article\\\">Insect neuropeptide bursicon homodimers induce innate immune and stress genes during molting by activating the NF&#45;&#954;B transcription factor Relish.</citetitle>\", lines.get(9));",
        "label":0
    },
    {
        "ins1CurCode":"public void requestCancelConditionalRace2() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final TestSubscriber<Integer> ts = new TestSubscriber<>(0L); ",
        "ins1PreCode":"public void requestCancelConditionalRace2() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "ins2PreCode":"public void requestCancelRace2() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ",
        "label":1
    },
    {
        "ins1CurCode":"observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) { return Observable.empty(); } });  observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) { return Completable.complete().toObservable(); } });  observableDedicated = source.flatMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) { return Completable.complete();",
        "ins1PreCode":"observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.empty(); } });  observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Completable.complete().toObservable(); } });  observableDedicated = source.flatMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) throws Exception { return Completable.complete();",
        "ins2PreCode":"observablePlain = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.empty(); } });  observableConvert = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Completable.complete().toObservable(); } });  observableDedicated = source.concatMapCompletable(new Function<Integer, Completable>() { @Override public Completable apply(Integer v) throws Exception { return Completable.complete();",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void dummyRangeShouldFailIfJobNameIsEmpty() { final CLICommandInvoker.Result result = command",
        "ins1PreCode":"@Test public void dummyRangeShouldFailIfJobNameIsEmpty() throws Exception { final CLICommandInvoker.Result result = command",
        "ins2PreCode":"@Test public void dummyRangeShouldFailIfJobNameIsSpace() throws Exception { final CLICommandInvoker.Result result = command",
        "label":1
    },
    {
        "ins1CurCode":"public void test2ButCaseInsensitive() { assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins1PreCode":"public void test2ButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "ins2PreCode":"public void test2bisButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp);",
        "label":1
    },
    {
        "ins1CurCode":"void deleteWhenDialogCancelledReturnsFalseAndDoesNotRemoveFile() { linkedFile = new LinkedFile(\"desc\", tempFile, \"pdf\"); when(dialogService.showCustomButtonDialogAndWait(",
        "ins1PreCode":"void deleteWhenDialogCancelledReturnsFalseAndDoesNotRemoveFile() { linkedFile = new LinkedFile(\"desc\", tempFile.toString(), \"pdf\"); when(dialogService.showCustomButtonDialogAndWait(",
        "ins2PreCode":"void deleteMissingFileReturnsTrue() { linkedFile = new LinkedFile(\"\", \"!!nonexistent file!!\", \"\"); when(dialogService.showCustomButtonDialogAndWait(",
        "label":0
    },
    {
        "ins1CurCode":"void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception { WithMockBean instance = new WithMockBean();",
        "ins1PreCode":"public void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception { WithMockBean instance = new WithMockBean();",
        "ins2PreCode":"public void prepareTestInstanceShouldInjectMockBean() throws Exception { WithMockBean instance = new WithMockBean(); this.listener.prepareTestInstance(mockTestContext(instance)); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "label":0
    },
    {
        "ins1CurCode":"public void testEquals_ObjectList() { XYPlot<String> p1 = new XYPlot<>(); p1.setDomainAxis(new NumberAxis(\"A\")); XYPlot<String> p2 = new XYPlot<>(); p2.setDomainAxis(new NumberAxis(\"A\"));",
        "ins1PreCode":"public void testEquals_ObjectList() { XYPlot p1 = new XYPlot(); p1.setDomainAxis(new NumberAxis(\"A\")); XYPlot p2 = new XYPlot(); p2.setDomainAxis(new NumberAxis(\"A\"));",
        "ins2PreCode":"public void testEquals_ObjectList3() { XYPlot p1 = new XYPlot(); p1.setRangeAxis(new NumberAxis(\"A\")); XYPlot p2 = new XYPlot(); p2.setRangeAxis(new NumberAxis(\"A\"));",
        "label":1
    },
    {
        "ins1CurCode":"Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<Row> actual = sqlContext.sql(\"SELECT * FROM people\").collectAsList();  List<Row> expected = new ArrayList<>(2); expected.add(RowFactory.create(\"Michael\", 29)); expected.add(RowFactory.create(\"Yin\", 28));  Assert.assertEquals(expected, actual);",
        "ins1PreCode":"Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collectRows();  List<Row> expected = new ArrayList<>(2); expected.add(RowFactory.create(\"Michael\", 29)); expected.add(RowFactory.create(\"Yin\", 28));  Assert.assertEquals(expected, Arrays.asList(actual));",
        "ins2PreCode":"public void dataFrameRDDOperations() { List<Person> personList = new ArrayList<>(2); Person person1 = new Person(); person1.setName(\"Michael\"); person1.setAge(29); personList.add(person1); Person person2 = new Person(); person2.setName(\"Yin\"); person2.setAge(28); personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD().map(new Function<Row, String>() { @Override public String call(Row row) { return row.getString(0) + \"_\" + row.get(1); } }).collect();  List<String> expected = new ArrayList<>(2); expected.add(\"Michael_29\"); expected.add(\"Yin_28\");  Assert.assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1CurCode":"onError.accept(ex); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); throw new CompositeException(ex, exc); } throw ExceptionHelper.<Exception>throwIfThrowable(ex); }  if (v != null) { try { try { onNext.accept(v); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); try { onError.accept(ex); } catch (Throwable exc) { Exceptions.throwIfFatal(exc); throw new CompositeException(ex, exc);",
        "ins1PreCode":"onError.accept(ex); } catch (Throwable exc) { throw new CompositeException(ex, exc); } throw ExceptionHelper.<Exception>throwIfThrowable(ex); }  if (v != null) { try { try { onNext.accept(v); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); try { onError.accept(ex); } catch (Throwable exc) { throw new CompositeException(ex, exc); } throw ExceptionHelper.<Exception>throwIfThrowable(ex);",
        "ins2PreCode":"onError.accept(ex); } catch (Throwable exc) { throw new CompositeException(ex, exc); } throw ExceptionHelper.<Exception>throwIfThrowable(ex); }  if (v != null) { try { try { onNext.accept(v); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); try { onError.accept(ex); } catch (Throwable exc) { throw new CompositeException(ex, exc); } throw ExceptionHelper.<Exception>throwIfThrowable(ex);",
        "label":1
    },
    {
        "ins1CurCode":"final ScriptsExportData exportData = mainPage.getExportData(); try { DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try {",
        "ins1PreCode":"final ScriptsExportData exportData = mainPage.getExportData(); try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try {",
        "ins2PreCode":"public boolean performFinish() { try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try {",
        "label":1
    },
    {
        "ins1CurCode":"public void testNoPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(getOutputDir(), \"test.txt\").lastModified());",
        "ins1PreCode":"public void testNoPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); String tmpdir = project.getProperty(\"tmp.dir\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(tmpdir, \"test.txt\").lastModified());",
        "ins2PreCode":"public void testPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); String tmpdir = project.getProperty(\"tmp.dir\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testPreserve\"); assertTrue(ts1 == new File(tmpdir, \"test.txt\").lastModified());",
        "label":1
    },
    {
        "ins1CurCode":"fullLogBuffer = new StringBuffer(); project = new Project(); if (Boolean.getBoolean(MagicTestNames.TEST_BASEDIR_IGNORE)) { System.clearProperty(MagicNames.PROJECT_BASEDIR); } project.init(); File antFile = new File(System.getProperty(MagicTestNames.TEST_ROOT_DIRECTORY), filename); project.setProperty(MagicTestNames.TEST_PROCESS_ID, ProcessUtil.getProcessId(\"<Process>\")); project.setProperty(MagicTestNames.TEST_THREAD_NAME, Thread.currentThread().getName()); project.setUserProperty(MagicNames.ANT_FILE, antFile.getAbsolutePath());",
        "ins1PreCode":"fullLogBuffer = new StringBuffer(); project = new Project(); if (Boolean.getBoolean(MagicNames.TEST_BASEDIR_IGNORE)) { System.clearProperty(MagicNames.PROJECT_BASEDIR); } project.init(); File antFile = new File(System.getProperty(MagicNames.TEST_ROOT_DIRECTORY), filename); project.setProperty(MagicNames.TEST_PROCESS_ID, ProcessUtil.getProcessId(\"<Process>\")); project.setProperty(MagicNames.TEST_THREAD_NAME, Thread.currentThread().getName()); project.setUserProperty(MagicNames.ANT_FILE, antFile.getAbsolutePath());",
        "ins2PreCode":"fullLogBuffer = new StringBuffer(); project = new Project(); if (Boolean.getBoolean(MagicNames.TEST_BASEDIR_IGNORE)) { System.clearProperty(MagicNames.PROJECT_BASEDIR); } project.init(); File antFile = new File(System.getProperty(MagicNames.TEST_ROOT_DIRECTORY), filename); project.setUserProperty(MagicNames.ANT_FILE, antFile.getAbsolutePath());  project.setProperty(MagicNames.TEST_PROCESS_ID, ProcessUtil.getProcessId(\"<Process>\")); project.setProperty(MagicNames.TEST_THREAD_NAME, Thread.currentThread().getName()); project.addBuildListener(new AntTestListener(logLevel));",
        "label":1
    },
    {
        "ins1CurCode":"if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); DiagramSettings settings = p.getProjectSettings().getDefaultDiagramSettings();   ArgoDiagram diagram = createDiagram(ns); diagram.setDiagramSettings(settings); ",
        "ins1PreCode":"if (ns != null && isValidNamespace(ns)) { super.actionPerformed(e); ArgoDiagram diagram = createDiagram(ns); p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded(ns); TargetManager.getInstance().setTarget(diagram); } else {",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { super.actionPerformed(e);     Project p = ProjectManager.getManager().getCurrentProject(); Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns); assert (diagram != null) : \"No diagram was returned by the concrete class\";  p.addMember(diagram);   ExplorerEventAdaptor.getInstance().modelElementAdded( diagram.getNamespace()); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "label":0
    },
    {
        "ins1CurCode":"return Observable.just(1); } }, true, 16));",
        "ins1PreCode":"return Observable.just(1); } }, 16, true));",
        "ins2PreCode":"public void switchMapDelayErrorEmptySource() { assertSame(Observable.empty(), Observable.<Object>empty() .switchMapDelayError(new Function<Object, ObservableSource<Integer>>() { @Override public ObservableSource<Integer> apply(Object v) throws Exception { return Observable.just(1); } }, 16));",
        "label":0
    },
    {
        "ins1CurCode":"public void testSetMaximumItemCount2() { YIntervalSeries<String> s1 = new YIntervalSeries<>(\"S1\"); s1.add(1.0, 1.1, 1.1, 1.1);",
        "ins1PreCode":"public void testSetMaximumItemCount2() { YIntervalSeries s1 = new YIntervalSeries(\"S1\"); s1.add(1.0, 1.1, 1.1, 1.1);",
        "ins2PreCode":"public void testSetMaximumItemCount2() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); s1.add(1.0, 1.1, 1.1, 1.1);",
        "label":1
    },
    {
        "ins1CurCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() +",
        "ins1PreCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() +",
        "ins2PreCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, Builder.create().build(), new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":1
    },
    {
        "ins1CurCode":"public void assertEmpty() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void assertEmpty() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void assertEmpty() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void readOperationWithResourceResponse() { load(ResourceEndpointConfiguration.class, (context, client) -> {",
        "ins1PreCode":"public void readOperationWithResourceResponse() { load(ResourceEndpointConfiguration.class, (context, client) -> {",
        "ins2PreCode":"public void readOperationWithResourceWebOperationResponse() { load(ResourceWebEndpointResponseEndpointConfiguration.class, (context, client) -> {",
        "label":1
    },
    {
        "ins1CurCode":"String body = bc.toString();  Assert.assertTrue(body, body.contains(\"MatchValue=[mapping]\")); Assert.assertTrue(body, body.contains(\"Pattern=[/mapping]\"));",
        "ins1PreCode":"String body = bc.toString();  Assert.assertTrue(body, body.contains(\"MatchValue=[/mapping]\")); Assert.assertTrue(body, body.contains(\"Pattern=[/mapping]\"));",
        "ins2PreCode":"String body = bc.toString();  Assert.assertTrue(body, body.contains(\"MatchValue=[/mapping]\")); Assert.assertTrue(body, body.contains(\"Pattern=[/mapping]\"));",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList<SqlNode>() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = ?\")), \"true\"",
        "ins1PreCode":"DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = ?\")), \"true\"",
        "ins2PreCode":"DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = ?\")), \"false\"",
        "label":1
    },
    {
        "ins1CurCode":"markers = this.foregroundDomainMarkers.get(index); if (markers == null) { markers = new ArrayList<>(); this.foregroundDomainMarkers.put(index, markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = this.backgroundDomainMarkers.get(index); if (markers == null) { markers = new ArrayList<>(); this.backgroundDomainMarkers.put(index, markers);",
        "ins1PreCode":"markers = this.foregroundDomainMarkers.get(index); if (markers == null) { markers = new java.util.ArrayList<Marker>(); this.foregroundDomainMarkers.put(index, markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = this.backgroundDomainMarkers.get(index); if (markers == null) { markers = new java.util.ArrayList<Marker>(); this.backgroundDomainMarkers.put(index, markers);",
        "ins2PreCode":"markers = this.foregroundRangeMarkers.get(index); if (markers == null) { markers = new java.util.ArrayList<Marker>(); this.foregroundRangeMarkers.put(index, markers); } markers.add(marker); } else if (layer == Layer.BACKGROUND) { markers = this.backgroundRangeMarkers.get(index); if (markers == null) { markers = new java.util.ArrayList<Marker>(); this.backgroundRangeMarkers.put(index, markers);",
        "label":1
    },
    {
        "ins1CurCode":"public void add(CategoryPlot subplot, int weight) { Args.nullNotPermitted(subplot, \"subplot\"); if (weight <= 0) {",
        "ins1PreCode":"public void add(CategoryPlot subplot, int weight) { ParamChecks.nullNotPermitted(subplot, \"subplot\"); if (weight <= 0) {",
        "ins2PreCode":"public void add(CategoryPlot subplot, int weight) { ParamChecks.nullNotPermitted(subplot, \"subplot\"); if (weight < 1) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetValueByKey() { KeyedObjects2D<String, String> data = new KeyedObjects2D<>(); data.addObject(\"Obj1\", \"R1\", \"C1\");",
        "ins1PreCode":"public void testGetValueByKey() { KeyedObjects2D data = new KeyedObjects2D(); data.addObject(\"Obj1\", \"R1\", \"C1\");",
        "ins2PreCode":"public void testSetObject() { KeyedObjects2D data = new KeyedObjects2D(); data.setObject(\"Obj1\", \"R1\", \"C1\");",
        "label":1
    },
    {
        "ins1CurCode":"void testReadArticleDublinCoreReadXmp() throws IOException, URISyntaxException, ParseException { Path pathPdf = Paths.get(XmpUtilShared.class.getResource(\"article_dublinCore.pdf\").toURI()); List<BibEntry> entries = XmpUtilReader.readXmp(pathPdf, xmpPreferences); BibEntry entry = entries.get(0);  String bibString = Resources.toString(XmpUtilShared.class.getResource(\"article_dublinCore.bib\"), StandardCharsets.UTF_8); Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString); entryFromBibFile.get().setFiles(Arrays.asList( new LinkedFile(\"\", \"paper.pdf\", \"PDF\"), new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\")) ); ",
        "ins1PreCode":"void testReadArticleDublinCoreReadXmp() throws IOException, URISyntaxException, ParseException { List<BibEntry> entries = XmpUtilReader.readXmp(Paths.get(XmpUtilShared.class.getResource(\"article_dublinCore.pdf\").toURI()), xmpPreferences); BibEntry entry = entries.get(0);",
        "ins2PreCode":"void testReadPDMetadata() throws IOException, URISyntaxException, ParseException { List<BibEntry> entries = XmpUtilReader.readXmp(Paths.get(XmpUtilShared.class.getResource(\"PD_metadata.pdf\").toURI()), xmpPreferences); ",
        "label":1
    },
    {
        "ins1CurCode":"void unknownJavaTypeOnTypeHandler() { final String MAPPER_CONFIG = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"",
        "ins1PreCode":"public void unknownJavaTypeOnTypeHandler() { final String MAPPER_CONFIG = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"",
        "ins2PreCode":"public void propertiesSpecifyResourceAndUrlAtSameTime() { final String MAPPER_CONFIG = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" ?>\\n\"",
        "label":1
    },
    {
        "ins1CurCode":"  TestMap m1 = TestMap.newBuilder() .putInt32ToInt32Field(1, 2) .putInt32ToInt32Field(3, 4) .putInt32ToInt32Field(5, 6) .build(); ",
        "ins1PreCode":"  TestMap.Builder b1 = TestMap.newBuilder() .putInt32ToInt32Field(1, 2) .putInt32ToInt32Field(3, 4) .putInt32ToInt32Field(5, 6); TestMap m1 = b1.build(); ",
        "ins2PreCode":"  TestMap.Builder b1 = TestMap.newBuilder() .putInt32ToInt32Field(1, 2) .putInt32ToInt32Field(3, 4) .putInt32ToInt32Field(5, 6); TestMap m1 = b1.build(); ",
        "label":1
    },
    {
        "ins1CurCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<120000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK\");",
        "ins1PreCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<30000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK\");",
        "ins2PreCode":"public void testDataSendASYNCM() throws Exception { System.err.println(\"Starting ASYNC MULTI THREAD\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "label":0
    },
    {
        "ins1CurCode":"{ List<ReportSet> tgt = target.getReportSets(); Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); merged.put( key, element ); }  for ( ReportSet element : src ) { Object key = getReportSetKey( element ); ReportSet existing = merged.get( key ); if ( existing != null ) { mergeReportSet( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setReportSets( new ArrayList<>( merged.values() ) ); }",
        "ins1PreCode":"{ List<ReportSet> tgt = target.getReportSets(); Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); merged.put( key, element ); }  for ( ReportSet element : src ) { Object key = getReportSetKey( element ); ReportSet existing = merged.get( key ); if ( existing != null ) { mergeReportSet( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setReportSets( new ArrayList<ReportSet>( merged.values() ) ); }",
        "ins2PreCode":"{ List<ReportSet> tgt = target.getReportSets(); Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet rset : src ) { if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) ) { Object key = getReportSetKey( rset ); merged.put( key, rset ); } }  for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); ReportSet existing = merged.get( key ); if ( existing != null ) { mergeReportSet( element, existing, sourceDominant, context ); } merged.put( key, element ); }  target.setReportSets( new ArrayList<ReportSet>( merged.values() ) ); }",
        "label":1
    },
    {
        "ins1CurCode":"wasJar = new JarFile(websphereJarFile);  Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); Hashtable<String, JarEntry> wasEntries = new Hashtable<>(); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();   for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration<JarEntry> e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = e.nextElement(); wasEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { String filepath = e.nextElement();  if (wasEntries.containsKey(filepath)) {   JarEntry genericEntry = genericEntries.get(filepath); JarEntry wasEntry = wasEntries.get(filepath);  if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class<?> genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; }  replaceEntries.put(filepath, genericEntry); } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; } break; } } } else {   log(\"File \" + filepath + \" not present in websphere jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newwasJarFile = new File(websphereJarFile.getAbsolutePath() + \".temp\"); if (newwasJarFile.exists()) { newwasJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newwasJarFile.toPath())); newJarStream.setLevel(0);   for (Enumeration<JarEntry> e = wasEntries.elements(); e.hasMoreElements();) { JarEntry je = e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }  InputStream is;  if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wasJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"websphere Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { throw new BuildException( \"ClassNotFoundException while processing ejb-jar file. Details: \" + cnfe.getMessage(), cnfe); } catch (IOException ioe) { throw new BuildException( \"IOException while processing ejb-jar file . Details: \" + ioe.getMessage(), ioe); } finally {  FileUtils.close(genericJar); FileUtils.close(wasJar); FileUtils.close(newJarStream);  if (newJarStream != null) { try { FILE_UTILS.rename(newwasJarFile, websphereJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true; } } if (genericLoader != null && genericLoader instanceof AntClassLoader) { @SuppressWarnings(\"resource\") AntClassLoader loader = (AntClassLoader) genericLoader;",
        "ins1PreCode":"wasJar = new JarFile(websphereJarFile);  Hashtable genericEntries = new Hashtable(); Hashtable wasEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable();   for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration e = wasJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  wasEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wasEntries.containsKey(filepath)) {   JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wasEntry = (JarEntry) wasEntries.get(filepath);  if ((genericEntry.getCrc() != wasEntry.getCrc()) || (genericEntry.getSize() != wasEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; } break; } } } else {   log(\"File \" + filepath + \" not present in websphere jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newwasJarFile = new File(websphereJarFile.getAbsolutePath() + \".temp\"); if (newwasJarFile.exists()) { newwasJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newwasJarFile.toPath())); newJarStream.setLevel(0);   for (Enumeration e = wasEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wasJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"websphere Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); } } else { rebuild = true; } } catch (ClassNotFoundException cnfe) { String cnfmsg = \"ClassNotFoundException while processing ejb-jar file\" + \". Details: \" + cnfe.getMessage();  throw new BuildException(cnfmsg, cnfe); } catch (IOException ioe) { String msg = \"IOException while processing ejb-jar file \" + \". Details: \" + ioe.getMessage();  throw new BuildException(msg, ioe); } finally {",
        "ins2PreCode":"wlJar = new JarFile(weblogicJarFile);  Hashtable genericEntries = new Hashtable(); Hashtable wlEntries = new Hashtable(); Hashtable replaceEntries = new Hashtable();   for (Enumeration e = genericJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  genericEntries.put(je.getName().replace('\\\\', '/'), je); }  for (Enumeration e = wlJar.entries(); e.hasMoreElements();) { JarEntry je = (JarEntry) e.nextElement();  wlEntries.put(je.getName(), je); }   genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);  if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName() .replace(File.separatorChar, '.') .replace('/', '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } } else {   log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(Files.newOutputStream(newWLJarFile.toPath())); newJarStream.setLevel(0);   for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[DEFAULT_BUFFER_SIZE]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(JAR_COMPRESS_LEVEL); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je);",
        "label":1
    },
    {
        "ins1CurCode":"public UnsafeArrayData getArray(int ordinal) { if (isNullAt(ordinal)) return null; final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; final UnsafeArrayData array = new UnsafeArrayData();",
        "ins1PreCode":"public UnsafeArrayData getArray(int ordinal) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeArrayData array = new UnsafeArrayData();",
        "ins2PreCode":"public UnsafeArrayData getArray(int ordinal) { if (isNullAt(ordinal)) { return null; } else { final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; final UnsafeArrayData array = new UnsafeArrayData(); array.pointTo(baseObject, baseOffset + offset, size); return array; }",
        "label":0
    },
    {
        "ins1CurCode":"void testNestedNaming() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class)",
        "ins1PreCode":"public void testNestedNaming() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class)",
        "ins2PreCode":"public void testMap() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class)",
        "label":1
    },
    {
        "ins1CurCode":"List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( p.getName() + \"/intermediateFolder/public2.key\", p.getName() + \"/public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"intermediateFolder/public2.key\")); }",
        "ins1PreCode":"List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( \"intermediateFolder/public2.key\", \"public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"public2.key\")); }",
        "ins2PreCode":"List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, containsInAnyOrder( \"intermediateFolder/public2.key\", \"public1.key\" )); } { Page zipPage = wc.goTo(p.getUrl() + \"ws/intermediateFolder/*zip*/intermediateFolder.zip\", null); assertThat(zipPage.getWebResponse().getStatusCode(), equalTo(HttpURLConnection.HTTP_OK));  List<String> entryNames = getListOfEntriesInDownloadedZip((UnexpectedPage) zipPage); assertThat(entryNames, contains(\"public2.key\")); }",
        "label":0
    },
    {
        "ins1CurCode":"buildRule.executeTarget(\"testOrder1\");  Manifest manifest = getManifest(expandedManifest); Enumeration e = manifest.getSectionNames();",
        "ins1PreCode":"buildRule.executeTarget(\"testOrder1\");  Manifest manifest = getManifest(EXPANDED_MANIFEST); Enumeration e = manifest.getSectionNames();",
        "ins2PreCode":"buildRule.executeTarget(\"testOrder2\");  Manifest manifest = getManifest(EXPANDED_MANIFEST); Enumeration e = manifest.getSectionNames();",
        "label":1
    },
    {
        "ins1CurCode":"new ApplicationContextRunner() .withUserConfiguration(ClassConfigurationProperties.class) .withParent(parent).run((child) -> { ConfigurationPropertiesReportEndpoint endpoint = child",
        "ins1PreCode":"new ApplicationContextRunner() .withUserConfiguration(ClassConfigurationProperties.class) .withParent(parent).run(child -> { ConfigurationPropertiesReportEndpoint endpoint = child",
        "ins2PreCode":".withUserConfiguration( BeanMethodConfigurationProperties.class) .withParent(parent).run(child -> { ConfigurationPropertiesReportEndpoint endpoint = child",
        "label":1
    },
    {
        "ins1CurCode":"void testDynamicSelectWithPropertyParams() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {  Parameter p = new Parameter(true, \"Fli%\"); List<Name> answer = sqlSession.selectList(\"selectNames\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); }  p = new Parameter(false, \"Fli%\"); answer = sqlSession.selectList(\"selectNames\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertNull(n.getLastName()); }  p = new Parameter(false, \"Rub%\"); answer = sqlSession.selectList(\"selectNames\", p); assertEquals(2, answer.size()); for (Name n : answer) { assertNull(n.getLastName()); }",
        "ins1PreCode":"public void testDynamicSelectWithPropertyParams() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {  Parameter p = new Parameter(true, \"Fli%\"); List<Name> answer = sqlSession.selectList(\"selectNames\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); }  p = new Parameter(false, \"Fli%\"); answer = sqlSession.selectList(\"selectNames\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertTrue(n.getLastName() == null); }  p = new Parameter(false, \"Rub%\"); answer = sqlSession.selectList(\"selectNames\", p); assertEquals(2, answer.size()); for (Name n : answer) { assertTrue(n.getLastName() == null); }",
        "ins2PreCode":"public void testDynamicSelectWithExpressionParams() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {  Parameter p = new Parameter(true, \"Fli\"); List<Name> answer = sqlSession.selectList(\"selectNamesWithExpressions\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); }  p = new Parameter(false, \"Fli\"); answer = sqlSession.selectList(\"selectNamesWithExpressions\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertTrue(n.getLastName() == null); }  p = new Parameter(false, \"Rub\"); answer = sqlSession.selectList(\"selectNamesWithExpressions\", p); assertEquals(2, answer.size()); for (Name n : answer) { assertTrue(n.getLastName() == null); }",
        "label":1
    },
    {
        "ins1CurCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1); ",
        "ins1PreCode":"series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<>(series1); ",
        "ins2PreCode":"this.chart.addChangeListener(l);  XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "label":1
    },
    {
        "ins1CurCode":"public void unorderedFastPathReject() { TestSubscriber<Integer> ts = new TestSubscriber<>(1); Disposable d = Disposable.empty();",
        "ins1PreCode":"public void unorderedFastPathReject() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "ins2PreCode":"public void orderedFastPathReject() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1CurCode":"}); } }, true, 2, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"}); } }, 2, true, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"}); } }, 2, false, ImmediateThinScheduler.INSTANCE) .test()",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(\"InputStream.skip(), no more input\", -1, input.read()); input.reset(); assertEquals(\"InputStream.reset() succeeded\", stringSize - skipped1, input.available()); assertEquals(",
        "ins1PreCode":"assertEquals(\"InputStream.skip(), no more input\", -1, input.read()); input.reset(); assertEquals(\"InputStream.reset() succeded\", stringSize - skipped1, input.available()); assertEquals(",
        "ins2PreCode":" input.reset(); assertEquals(\"InputStream.reset() succeded\", stringSize - skipped1, input.available()); assertEquals(",
        "label":1
    },
    {
        "ins1CurCode":"Supplier<AnnotationConfigServletWebApplicationContext> supplier) throws Exception { AtomicReference<AnnotationConfigServletWebApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { AnnotationConfigServletWebApplicationContext context = supplier.get(); atomicReference.getAndSet(context); }); thread.start();",
        "ins1PreCode":"Supplier<AnnotationConfigServletWebApplicationContext> supplier) throws Exception { CountDownLatch latch = new CountDownLatch(1); AtomicReference<AnnotationConfigServletWebApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { AnnotationConfigServletWebApplicationContext context = supplier.get(); latch.countDown(); atomicReference.getAndSet(context);",
        "ins2PreCode":"private ConfigurableApplicationContext getContext( Supplier<ConfigurableApplicationContext> supplier) throws Exception { CountDownLatch latch = new CountDownLatch(1); AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { ConfigurableApplicationContext context = supplier.get(); latch.countDown(); atomicReference.getAndSet(context);",
        "label":1
    },
    {
        "ins1CurCode":"void bindToClassShouldBindToList() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToClassShouldBindToList() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToClassShouldBindToSet() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"public Set<Map.Entry<K,V>> entrySet() { LinkedHashSet<Map.Entry<K,V>> set = new LinkedHashSet<>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();",
        "ins1PreCode":"public Set<Map.Entry<K,V>> entrySet() { LinkedHashSet<Map.Entry<K,V>> set = new LinkedHashSet<Map.Entry<K,V>>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();",
        "ins2PreCode":"  LinkedHashSet<K> set = new LinkedHashSet<K>(innerMap.size()); Iterator<Map.Entry<K,MapEntry<K,V>>> i = innerMap.entrySet().iterator();",
        "label":0
    },
    {
        "ins1CurCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assertThat(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\"), containsString(\"bye world\")); ",
        "ins1PreCode":"public void testContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeTrue(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\").contains(\"bye world\")); ",
        "ins2PreCode":"public void testFilterContainsRegex() throws IOException { buildRule.executeTarget(\"hasregex\"); assumeTrue(\"Regex not present\", getFileString(buildRule.getProject().getProperty(\"output\") + \"/replaceregexp\").contains(\"bye world\")); ",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetMaxMiddleIndex() { TimePeriodValues<String> s = new TimePeriodValues<>(\"Test\"); assertEquals(-1, s.getMaxMiddleIndex());",
        "ins1PreCode":"public void testGetMaxMiddleIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMaxMiddleIndex());",
        "ins2PreCode":"public void getMinEndIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMinEndIndex());",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(\"All the items should have been resolved.\", checker.resolved.containsAll(items)); assertTrue(\"There should be no unresolved items.\", resolver.unresolvedItems.isEmpty());",
        "ins1PreCode":"assertTrue(\"All the items should have been resolved.\", checker.resolved.containsAll(items));",
        "ins2PreCode":"assertTrue(\"All the items should have been resolved.\", checker.resolved.containsAll(items));",
        "label":1
    },
    {
        "ins1CurCode":"Second s = new Second(50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); Calendar cal = Calendar.getInstance(zone); assertEquals(-623289610000L, s.getFirstMillisecond(cal));   boolean pass = false; try { s.getFirstMillisecond((Calendar) null); }",
        "ins1PreCode":"Second s = new Second(50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-623289610000L, s.getFirstMillisecond(zone));   boolean pass = false; try { s.getFirstMillisecond((TimeZone) null); }",
        "ins2PreCode":"Second s = new Second(55, 1, 2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-614962684001L, s.getLastMillisecond(zone));   boolean pass = false; try { s.getLastMillisecond((TimeZone) null); }",
        "label":1
    },
    {
        "ins1CurCode":"public void groupByBackpressure() throws InterruptedException {  TestSubscriber<String> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void groupByBackpressure() throws InterruptedException {  TestSubscriber<String> ts = new TestSubscriber<String>(); ",
        "ins2PreCode":"public void groupByBackpressure2() throws InterruptedException {  TestObserver<String> to = new TestObserver<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"Assert.assertTrue(corsFilter.isAnyOriginAllowed()); Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0); Assert.assertFalse(corsFilter.isSupportsCredentials()); Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);",
        "ins1PreCode":"Assert.assertTrue(corsFilter.isAnyOriginAllowed()); Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0); Assert.assertTrue(corsFilter.isSupportsCredentials()); Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);",
        "ins2PreCode":"public void testWithStringParserEmpty() throws ServletException { CorsFilter corsFilter = new CorsFilter(); corsFilter.init(TesterFilterConfigs.getEmptyFilterConfig()); Assert.assertTrue(corsFilter.getAllowedHttpHeaders().size() == 0); Assert.assertTrue(corsFilter.getAllowedHttpMethods().size() == 0); Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0); Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0); Assert.assertFalse(corsFilter.isSupportsCredentials()); Assert.assertTrue(corsFilter.getPreflightMaxAge() == 0);",
        "label":0
    },
    {
        "ins1CurCode":"try { AbstractServletWebServerFactory factory = getFactory(); addConnector(port, factory); AbstractServletWebServerFactoryTests.this.webServer = factory",
        "ins1PreCode":"try { AbstractServletWebServerFactory factory = getFactory(); factory.setPort(SocketUtils.findAvailableTcpPort(40000)); addConnector(port, factory);",
        "ins2PreCode":"public void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> { try { AbstractServletWebServerFactory factory = getFactory(); factory.setPort(port); AbstractServletWebServerFactoryTests.this.webServer = factory .getWebServer(); AbstractServletWebServerFactoryTests.this.webServer.start(); fail(); } catch (RuntimeException ex) { handleExceptionCausedByBlockedPort(ex, port); } });",
        "label":0
    },
    {
        "ins1CurCode":"public void testSerialization() { XIntervalSeriesCollection<String> c1 = new XIntervalSeriesCollection<>(); XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); XIntervalSeriesCollection<String> c2 = TestUtils.serialised(c1); assertEquals(c1, c2);",
        "ins1PreCode":"public void testSerialization() { XIntervalSeriesCollection c1 = new XIntervalSeriesCollection(); XIntervalSeries s1 = new XIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); XIntervalSeriesCollection c2 = TestUtils.serialised(c1); assertEquals(c1, c2);",
        "ins2PreCode":"public void testSerialization() { YIntervalSeriesCollection c1 = new YIntervalSeriesCollection(); YIntervalSeries s1 = new YIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3);",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetIndex() throws IOException { Request request = new Request(\"PUT\", \"/_kibana/\" + indexName); Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  request = new Request(\"GET\", \"/_kibana/\" + indexName); response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200)); assertThat(EntityUtils.toString(response.getEntity()), containsString(indexName));",
        "ins1PreCode":"public void testGetIndex() throws IOException { Request request = new Request(\"PUT\", \"/_kibana/.kibana-1\"); Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  request = new Request(\"GET\", \"/_kibana/.kibana-1\"); response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200)); assertThat(EntityUtils.toString(response.getEntity()), containsString(\".kibana-1\"));",
        "ins2PreCode":"public void testAliases() throws IOException { Request request = new Request(\"PUT\", \"/_kibana/.kibana-1\"); Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  request = new Request(\"PUT\", \"/_kibana/.kibana-1/_alias/.kibana\"); response = client().performRequest(request);",
        "label":0
    },
    {
        "ins1CurCode":"addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(shrinkStatus(stat)); }",
        "ins1PreCode":"addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(stat); }",
        "ins2PreCode":"addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(stat); }",
        "label":0
    },
    {
        "ins1CurCode":"JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<?> plot = (XYPlot) chart.getPlot(); LogAxis axis = new LogAxis(\"Log(Y)\");",
        "ins1PreCode":"JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<String> plot = (XYPlot) chart.getPlot(); LogAxis axis = new LogAxis(\"Log(Y)\");",
        "ins2PreCode":"JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<String> plot = (XYPlot) chart.getPlot(); LogAxis axis = new LogAxis(\"Log(Y)\");",
        "label":1
    },
    {
        "ins1CurCode":"PomTestWrapper pom = buildPom( \"url-inheritance/sub\" ); assertEquals( \"http://parent.url/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) );",
        "ins1PreCode":"PomTestWrapper pom = buildPom( \"url-inheritance/sub\" ); assertEquals( \"http://parent.url/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org/\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) );",
        "ins2PreCode":"PomTestWrapper pom = buildPom( \"url-inheritance/another-parent/sub\" ); assertEquals( \"http://parent.url/ap/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org/\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) );",
        "label":1
    },
    {
        "ins1CurCode":"void basicAdd() { given(this.resolver.getGroupId(\"spring-boot-starter-logging\")).willReturn(\"org.springframework.boot\"); given(this.resolver.getArtifactId(\"spring-boot-starter-logging\")).willReturn(\"spring-boot-starter-logging\"); given(this.resolver.getVersion(\"spring-boot-starter-logging\")).willReturn(\"1.2.3\"); this.dependencyCustomizer.add(\"spring-boot-starter-logging\");",
        "ins1PreCode":"void basicAdd() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\"); List<AnnotationNode> grabAnnotations = this.classNode.getAnnotations(new ClassNode(Grab.class)); assertThat(grabAnnotations).hasSize(1); AnnotationNode annotationNode = grabAnnotations.get(0);",
        "ins2PreCode":"void nonTransitiveAdd() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\", false); List<AnnotationNode> grabAnnotations = this.classNode.getAnnotations(new ClassNode(Grab.class)); assertThat(grabAnnotations).hasSize(1); AnnotationNode annotationNode = grabAnnotations.get(0);",
        "label":1
    },
    {
        "ins1CurCode":"\"Transaction has been committed\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\", null, () -> TransactionLogDialog.showDialog(null, context, true)); }",
        "ins1PreCode":"\"Transaction has been committed\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\"); }",
        "ins2PreCode":"public static void execute(final DBCExecutionContext context) { TasksJob.runTask(\"Rollback transaction\", new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { QMTransactionState txnInfo = QMUtils.getTransactionState(context); try (DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\")) { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } DBeaverNotifications.showNotification( context.getDataSource(), \"rollback\", \"Transaction has been rolled back\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\", DBPMessageType.ERROR); ",
        "label":0
    },
    {
        "ins1CurCode":" if (context == null) return null;   if (path == null) return null; else if (path.startsWith(\"/\")) return (context.getServletContext().getRequestDispatcher(path));   String servletPath = (String) getAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR); if (servletPath == null) servletPath = getServletPath();   String pathInfo = getPathInfo(); String requestPath = null;  if (pathInfo == null) { requestPath = servletPath; } else { requestPath = servletPath + pathInfo; }  int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; }  return context.getServletContext().getRequestDispatcher(relative); ",
        "ins1PreCode":" if (context == null) return (null);   if (path == null) return (null); else if (path.startsWith(\"/\")) return (context.getServletContext().getRequestDispatcher(path));   String servletPath = (String) getAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR); if (servletPath == null) servletPath = getServletPath();   String pathInfo = getPathInfo(); String requestPath = null;  if (pathInfo == null) { requestPath = servletPath; } else { requestPath = servletPath + pathInfo; }  int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; }  return (context.getServletContext().getRequestDispatcher(relative)); ",
        "ins2PreCode":" if (context == null) return (null);   if (path == null) return (null); else if (path.startsWith(\"/\")) return (context.getServletContext().getRequestDispatcher(path));   String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); if (servletPath == null) servletPath = getServletPath();   String pathInfo = getPathInfo(); String requestPath = null;  if (pathInfo == null) { requestPath = servletPath; } else { requestPath = servletPath + pathInfo; }  int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; }  return (context.getServletContext().getRequestDispatcher(relative)); ",
        "label":1
    },
    {
        "ins1CurCode":"protected <S extends Comparable<S>> void  applyToXYPlot(XYPlot<S> plot) { plot.setAxisOffset(this.axisOffset);",
        "ins1PreCode":"protected void applyToXYPlot(XYPlot plot) { plot.setAxisOffset(this.axisOffset);",
        "ins2PreCode":"protected void applyToCategoryPlot(CategoryPlot plot) { plot.setAxisOffset(this.axisOffset); plot.setDomainGridlinePaint(this.domainGridlinePaint); plot.setRangeGridlinePaint(this.rangeGridlinePaint); plot.setRangeZeroBaselinePaint(this.baselinePaint); plot.setShadowGenerator(this.shadowGenerator);   int domainAxisCount = plot.getDomainAxisCount(); for (int i = 0; i < domainAxisCount; i++) { CategoryAxis axis = plot.getDomainAxis(i); if (axis != null) { applyToCategoryAxis(axis); } }   int rangeAxisCount = plot.getRangeAxisCount(); for (int i = 0; i < rangeAxisCount; i++) { ValueAxis axis = plot.getRangeAxis(i); if (axis != null) { applyToValueAxis(axis); } }   int rendererCount = plot.getRendererCount(); for (int i = 0; i < rendererCount; i++) { CategoryItemRenderer r = plot.getRenderer(i); if (r != null) { applyToCategoryItemRenderer(r); } }  if (plot instanceof CombinedDomainCategoryPlot) { CombinedDomainCategoryPlot cp = (CombinedDomainCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } if (plot instanceof CombinedRangeCategoryPlot) { CombinedRangeCategoryPlot cp = (CombinedRangeCategoryPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { CategoryPlot subplot = (CategoryPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } }",
        "label":0
    },
    {
        "ins1CurCode":"ParserResult result = parser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\")); ",
        "ins1PreCode":"ParserResult result = parser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor); ",
        "ins2PreCode":"public void parseRecognizesMonthFieldsWithFollowingComma() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},month={8,}},\"));  Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(3, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\")); assertEquals(Optional.of(\"8,\"), entry.getField(\"month\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CustomXYToolTipGenerator g1 = new CustomXYToolTipGenerator(); CustomXYToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CustomXYToolTipGenerator g1 = new CustomXYToolTipGenerator(); CustomXYToolTipGenerator g2 = (CustomXYToolTipGenerator) g1.clone(); assertTrue(g1 != g2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = CloneUtils.clone(g1); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));",
        "label":0
    },
    {
        "ins1CurCode":"Date end = new Date(h1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnitType.HOUR, 6); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd, TimeZone.getDefault()); assertTrue(psd.getTime() < d4.getTime());",
        "ins1PreCode":"Date end = new Date(h1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.HOUR, 6); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "ins2PreCode":"Date end = new Date(s1.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.SECOND, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime());",
        "label":1
    },
    {
        "ins1CurCode":"result.append('1'); result.append(req.isAsyncStarted()); req.startAsync().setTimeout(10000); result.append('2');",
        "ins1PreCode":"result.append('1'); result.append(req.isAsyncStarted()); req.startAsync(); result.append('2');",
        "ins2PreCode":"protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {  result = new StringBuilder(); result.append('1'); result.append(req.isAsyncStarted()); req.startAsync(); result.append('2'); result.append(req.isAsyncStarted());  req.getAsyncContext().start(new Runnable() { @Override public void run() { Thread t = new Thread(new Runnable() { @Override public void run() { try { result.append('3'); result.append(req.isAsyncStarted()); Thread.sleep(1000); result.append('4'); result.append(req.isAsyncStarted()); resp.setContentType(\"text/plain\"); resp.getWriter().print(\"OK\"); req.getAsyncContext().complete(); result.append('5'); result.append(req.isAsyncStarted()); done = true; } catch (InterruptedException e) { result.append(e); } catch (IOException e) { result.append(e); } } }); t.start(); } });   req.getMethod();",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { StatisticalLineAndShapeRenderer r1 = new StatisticalLineAndShapeRenderer(); StatisticalLineAndShapeRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); TestUtils.checkIndependence(r1, r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StatisticalLineAndShapeRenderer r1 = new StatisticalLineAndShapeRenderer(); StatisticalLineAndShapeRenderer r2 = CloneUtils.clone(r1);",
        "ins2PreCode":"assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1CurCode":"AbstractGraphTest.validateGraph(transpose);  for (Integer node : directedGraph.nodes()) { assertThat(directedGraph.inDegree(node)).isSameAs(transpose.outDegree(node)); assertThat(directedGraph.outDegree(node)).isSameAs(transpose.inDegree(node)); }",
        "ins1PreCode":"AbstractGraphTest.validateGraph(transpose);  assertThat(transpose.successors(N1)).doesNotContain(N2); directedGraph.putEdge(N2, N1);  assertThat(transpose.successors(N1)).contains(N2);",
        "ins2PreCode":"AbstractGraphTest.validateGraph(transpose);  assertThat(transpose.successors(N1)).doesNotContain(N2); directedGraph.putEdge(N2, N1);  assertThat(transpose.successors(N1)).contains(N2);",
        "label":1
    },
    {
        "ins1CurCode":"HtmlForm f = page.getFormByName(\"uploadPlugin\"); File dir = tmp.newFolder(); File plugin = new File(dir, \"htmlpublisher.jpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/htmlpublisher.jpi\"),plugin); f.getInputByName(\"name\").setValueAttribute(plugin.getAbsolutePath()); r.submit(f);  assertTrue( new File(r.jenkins.getRootDir(),\"plugins/htmlpublisher.jpi\").exists() );",
        "ins1PreCode":"HtmlForm f = page.getFormByName(\"uploadPlugin\"); File dir = tmp.newFolder(); File plugin = new File(dir, \"tasks.jpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/tasks.jpi\"),plugin); f.getInputByName(\"name\").setValueAttribute(plugin.getAbsolutePath()); r.submit(f);  assertTrue( new File(r.jenkins.getRootDir(),\"plugins/tasks.jpi\").exists() );",
        "ins2PreCode":"@Test public void uploadHpi() throws Exception { HtmlPage page = r.createWebClient().goTo(\"pluginManager/advanced\"); HtmlForm f = page.getFormByName(\"uploadPlugin\"); File dir = tmp.newFolder(); File plugin = new File(dir, \"legacy.hpi\"); FileUtils.copyURLToFile(getClass().getClassLoader().getResource(\"plugins/legacy.hpi\"),plugin); f.getInputByName(\"name\").setValueAttribute(plugin.getAbsolutePath()); r.submit(f);   assertTrue( new File(r.jenkins.getRootDir(),\"plugins/legacy.jpi\").exists() );",
        "label":0
    },
    {
        "ins1CurCode":"if ((active0 & 0x141d555401c000L) != 0L) { jjmatchedKind = 56; return 30; } return -1; case 1: if ((active0 & 0x41554000000L) != 0L) return 30; if ((active0 & 0x1419400001c000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 1; return 30; } return -1; case 2: if ((active0 & 0x14014000000000L) != 0L) return 30; if ((active0 & 0x18000001c000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 2; return 30; } return -1; case 3: if ((active0 & 0x14000L) != 0L) return 30; if ((active0 & 0x180000008000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 3; return 30; } return -1; case 4: if ((active0 & 0x80000008000L) != 0L) return 30; if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 4; return 30; } return -1; case 5: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 5; return 30; } return -1; case 6: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 6; return 30; } return -1; case 7: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 7; return 30; } return -1; case 8: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 56; jjmatchedPos = 8;",
        "ins1PreCode":"if ((active0 & 0x141d555401c000L) != 0L) { jjmatchedKind = 55; return 30; } return -1; case 1: if ((active0 & 0x41554000000L) != 0L) return 30; if ((active0 & 0x1419400001c000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 1; return 30; } return -1; case 2: if ((active0 & 0x14014000000000L) != 0L) return 30; if ((active0 & 0x18000001c000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 2; return 30; } return -1; case 3: if ((active0 & 0x14000L) != 0L) return 30; if ((active0 & 0x180000008000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 3; return 30; } return -1; case 4: if ((active0 & 0x80000008000L) != 0L) return 30; if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 4; return 30; } return -1; case 5: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 5; return 30; } return -1; case 6: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 6; return 30; } return -1; case 7: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 7; return 30; } return -1; case 8: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 8;",
        "ins2PreCode":"if ((active0 & 0x141d555401c000L) != 0L) { jjmatchedKind = 55; return 30; } return -1; case 1: if ((active0 & 0x41554000000L) != 0L) return 30; if ((active0 & 0x1419400001c000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 1; return 30; } return -1; case 2: if ((active0 & 0x14014000000000L) != 0L) return 30; if ((active0 & 0x18000001c000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 2; return 30; } return -1; case 3: if ((active0 & 0x14000L) != 0L) return 30; if ((active0 & 0x180000008000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 3; return 30; } return -1; case 4: if ((active0 & 0x80000008000L) != 0L) return 30; if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 4; return 30; } return -1; case 5: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 5; return 30; } return -1; case 6: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 6; return 30; } return -1; case 7: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 7; return 30; } return -1; case 8: if ((active0 & 0x100000000000L) != 0L) { jjmatchedKind = 55; jjmatchedPos = 8;",
        "label":1
    },
    {
        "ins1CurCode":"for (int i = 0; i < 50; i++) { final ReplayProcessor<String> processor = ReplayProcessor.create(); final AtomicReference<String> value1 = new AtomicReference<>(); ",
        "ins1PreCode":"for (int i = 0; i < 50; i++) { final ReplayProcessor<String> processor = ReplayProcessor.create(); final AtomicReference<String> value1 = new AtomicReference<String>(); ",
        "ins2PreCode":"for (int i = 0; i < 50; i++) { final ReplayProcessor<String> processor = ReplayProcessor.createUnbounded(); final AtomicReference<String> value1 = new AtomicReference<String>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void serverHeaderIsDisabledByDefaultWhenUsingSsl() throws Exception { AbstractServletWebServerFactory factory = getFactory();",
        "ins1PreCode":"public void serverHeaderIsDisabledByDefaultWhenUsingSsl() throws Exception { AbstractServletWebServerFactory factory = getFactory();",
        "ins2PreCode":"public void serverHeaderCanBeCustomizedWhenUsingSsl() throws Exception { AbstractServletWebServerFactory factory = getFactory();",
        "label":1
    },
    {
        "ins1CurCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtils.createCategoryDataset( \"S\", \"C\", data);",
        "ins1PreCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset( \"S\", \"C\", data);",
        "ins2PreCode":"{new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1CurCode":" AppId appExecId = (AppId) o; return Objects.equals(appId, appExecId.appId);",
        "ins1PreCode":" AppId appExecId = (AppId) o; return Objects.equal(appId, appExecId.appId);",
        "ins2PreCode":" AppExecId appExecId = (AppExecId) o; return Objects.equal(appId, appExecId.appId) && Objects.equal(execId, appExecId.execId);",
        "label":0
    },
    {
        "ins1CurCode":"cleanup.cleanup(entry);  assertEquals(fieldMap.get(\"title\").toUpperCase(), entry.getField(\"title\").get()); assertEquals(fieldMap.get(\"booktitle\").toUpperCase(), entry.getField(\"booktitle\").get()); assertEquals(fieldMap.get(\"year\").toUpperCase(), entry.getField(\"year\").get()); assertEquals(fieldMap.get(\"month\").toUpperCase(), entry.getField(\"month\").get()); assertEquals(fieldMap.get(\"abstract\").toUpperCase(), entry.getField(\"abstract\").get()); assertEquals(fieldMap.get(\"doi\").toUpperCase(), entry.getField(\"doi\").get()); assertEquals(fieldMap.get(\"issn\").toUpperCase(), entry.getField(\"issn\").get());",
        "ins1PreCode":"cleanup.cleanup(entry);  Assert.assertEquals(fieldMap.get(\"title\").toUpperCase(), entry.getField(\"title\").get()); Assert.assertEquals(fieldMap.get(\"booktitle\").toUpperCase(), entry.getField(\"booktitle\").get()); Assert.assertEquals(fieldMap.get(\"year\").toUpperCase(), entry.getField(\"year\").get()); Assert.assertEquals(fieldMap.get(\"month\").toUpperCase(), entry.getField(\"month\").get()); Assert.assertEquals(fieldMap.get(\"abstract\").toUpperCase(), entry.getField(\"abstract\").get()); Assert.assertEquals(fieldMap.get(\"doi\").toUpperCase(), entry.getField(\"doi\").get()); Assert.assertEquals(fieldMap.get(\"issn\").toUpperCase(), entry.getField(\"issn\").get());",
        "ins2PreCode":"cleanup.cleanup(entry);  Assert.assertEquals(fieldMap.get(\"title\").toUpperCase(), entry.getField(\"title\").get()); Assert.assertEquals(fieldMap.get(\"booktitle\").toUpperCase(), entry.getField(\"booktitle\").get()); Assert.assertEquals(fieldMap.get(\"year\"), entry.getField(\"year\").get()); Assert.assertEquals(fieldMap.get(\"month\"), entry.getField(\"month\").get()); Assert.assertEquals(fieldMap.get(\"abstract\").toUpperCase(), entry.getField(\"abstract\").get()); Assert.assertEquals(fieldMap.get(\"doi\"), entry.getField(\"doi\").get()); Assert.assertEquals(fieldMap.get(\"issn\"), entry.getField(\"issn\").get());",
        "label":1
    },
    {
        "ins1CurCode":"URI.create(\"http://example.com/projects/spring-boot\")).build(); given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\")",
        "ins1PreCode":"URI.create(\"http://example.com/projects/spring-boot\")).build(); given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(); assertThat(this.registry.get(\"http.client.requests\")",
        "ins2PreCode":".attribute(URI_TEMPLATE_ATTRIBUTE, \"/projects/{project}\").build(); given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(); assertThat(this.registry.get(\"http.client.requests\")",
        "label":1
    },
    {
        "ins1CurCode":"Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet rset : src ) { if ( sourceDominant || ( rset.getInherited() != null ? rset.isInherited() : source.isInherited() ) ) { Object key = getReportSetKey( rset ); merged.put( key, rset ); }",
        "ins1PreCode":"Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet element : src ) { if ( sourceDominant || ( element.getInherited() != null ? element.isInherited() : source.isInherited() ) ) {",
        "ins2PreCode":"protected void mergeReportPlugin_ReportSets( ReportPlugin target, ReportPlugin source, boolean sourceDominant, Map<Object, Object> context ) { List<ReportSet> src = source.getReportSets(); if ( !src.isEmpty() ) { List<ReportSet> tgt = target.getReportSets(); Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); merged.put( key, element ); }  for ( ReportSet element : src ) { Object key = getReportSetKey( element ); ReportSet existing = merged.get( key ); if ( existing != null ) { mergeReportSet( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setReportSets( new ArrayList<ReportSet>( merged.values() ) ); }",
        "label":0
    },
    {
        "ins1CurCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<Integer>(false) { private static final long serialVersionUID = -9081211580719235896L;  @Override void truncate() { } }; ",
        "ins1PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(false); buf.addLast(new Node(1, 0));",
        "ins2PreCode":"public void boundedReplayBuffer() { BoundedReplayBuffer<Integer> buf = new BoundedReplayBuffer<>(true); buf.addLast(new Node(1, 0));",
        "label":0
    },
    {
        "ins1CurCode":"void configurationPropertiesClass() { new ApplicationContextRunner().withUserConfiguration(Parent.class).run((parent) -> {",
        "ins1PreCode":"public void configurationPropertiesClass() { new ApplicationContextRunner().withUserConfiguration(Parent.class).run((parent) -> {",
        "ins2PreCode":"public void configurationPropertiesBeanMethod() { new ApplicationContextRunner().withUserConfiguration(Parent.class).run((parent) -> {",
        "label":1
    },
    {
        "ins1CurCode":"IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"127.0.0.1\"); Processor processor = new SplitProcessor(randomAlphaOfLength(10), null, fieldName, \"\\\\.\", false, false, fieldName); processor.execute(ingestDocument);",
        "ins1PreCode":"IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"127.0.0.1\"); Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, false, fieldName); processor.execute(ingestDocument);",
        "ins2PreCode":"String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"127.0.0.1\"); String targetFieldName = fieldName + randomAlphaOfLength(5); Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, false, targetFieldName); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()) .willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"HS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier .create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .consumeErrorWith((ex) -> { assertThat(ex).isExactlyInstanceOf( CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) ex).getReason()) .isEqualTo(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM); }).verify();",
        "ins1PreCode":"throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"HS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier.create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))).consumeErrorWith(throwable -> { assertThat(throwable).isExactlyInstanceOf(CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) throwable) .getReason()).isEqualTo(Reason.UNSUPPORTED_TOKEN_SIGNING_ALGORITHM); }).verify();",
        "ins2PreCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\")); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; StepVerifier.create(this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))).consumeErrorWith(throwable -> { assertThat(throwable).isExactlyInstanceOf(CloudFoundryAuthorizationException.class); assertThat(((CloudFoundryAuthorizationException) throwable) .getReason()).isEqualTo(Reason.TOKEN_EXPIRED); }).verify();",
        "label":1
    },
    {
        "ins1CurCode":"private String testSingleWrite(String bibtexEntry) throws IOException {  ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries();",
        "ins1PreCode":"private String testSingleWrite(String bibtexEntry) throws IOException {  ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries();",
        "ins2PreCode":"  ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries();",
        "label":1
    },
    {
        "ins1CurCode":".to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(ExceptionHelper.nullWarning(\"The collectionSupplier returned a null Collection.\"));",
        "ins1PreCode":".to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins2PreCode":".to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "label":1
    },
    {
        "ins1CurCode":"Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap( Comparator<? super K> comparator,",
        "ins1PreCode":"static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap( Comparator<? super K> comparator,",
        "ins2PreCode":"public static <T, K, V> Collector<T, ?, ImmutableSortedMap<K, V>> toImmutableSortedMap( Comparator<? super K> comparator, Function<? super T, ? extends K> keyFunction, Function<? super T, ? extends V> valueFunction, BinaryOperator<V> mergeFunction) { checkNotNull(comparator); checkNotNull(keyFunction); checkNotNull(valueFunction); checkNotNull(mergeFunction); return Collectors.collectingAndThen( Collectors.toMap( keyFunction, valueFunction, mergeFunction, () -> new TreeMap<K, V>(comparator)), ImmutableSortedMap::copyOfSorted);",
        "label":0
    },
    {
        "ins1CurCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset);",
        "ins2PreCode":"public void testReplaceDataset() {   XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset<String> dataset = new XYSeriesCollection<>(series1);  LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around 10: \" + range.getLowerBound(), range.getLowerBound() <= 10); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "label":0
    },
    {
        "ins1CurCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<>(); ",
        "ins1PreCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<Thread>(); ",
        "ins2PreCode":"public void onErrorCalledOnScheduler() throws Exception { final CountDownLatch latch = new CountDownLatch(1); final AtomicReference<Thread> thread = new AtomicReference<Thread>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testSerialization() { List<String> u1 = new ArrayList<>(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\");  List<String> u2 = new ArrayList<>(); u2.add(\"URL B1\");",
        "ins1PreCode":"public void testSerialization() { List u1 = new java.util.ArrayList(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\");  List u2 = new java.util.ArrayList(); u2.add(\"URL B1\");",
        "ins2PreCode":"public void testSerialization() {  List u1 = new java.util.ArrayList(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\");  List u2 = new java.util.ArrayList(); u2.add(\"URL B1\");",
        "label":1
    },
    {
        "ins1CurCode":"private ServerTransport<CloseableChannel> createWebSocketTransport() { HttpServer httpServer = HttpServer.create(); if (this.resourceFactory != null) { httpServer = httpServer.runOn(this.resourceFactory.getLoopResources()); } if (this.ssl != null && this.ssl.isEnabled()) { SslServerCustomizer sslServerCustomizer = new SslServerCustomizer(this.ssl, null, this.sslStoreProvider); httpServer = sslServerCustomizer.apply(httpServer); } return WebsocketServerTransport.create(httpServer.bindAddress(this::getListenAddress));",
        "ins1PreCode":"private ServerTransport<CloseableChannel> createWebSocketTransport() { if (this.resourceFactory != null) { HttpServer httpServer = HttpServer.create().runOn(this.resourceFactory.getLoopResources()) .bindAddress(this::getListenAddress); return WebsocketServerTransport.create(httpServer); } return WebsocketServerTransport.create(getListenAddress());",
        "ins2PreCode":"private ServerTransport<CloseableChannel> createTcpTransport() { if (this.resourceFactory != null) { TcpServer tcpServer = TcpServer.create().runOn(this.resourceFactory.getLoopResources()) .bindAddress(this::getListenAddress); return TcpServerTransport.create(tcpServer); } return TcpServerTransport.create(getListenAddress());",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); push(observer, \"one\", 97);",
        "ins1PreCode":"@Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); push(observer, \"one\", 97);",
        "ins2PreCode":"public void timed() { Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); push(subscriber, \"one\", 97); push(subscriber, \"two\", 98);     push(subscriber, \"three\", 99); push(subscriber, \"four\", 101); push(subscriber, \"five\", 102); complete(subscriber, 150); } });  Flowable<List<String>> buffered = source.buffer(100, TimeUnit.MILLISECONDS, scheduler); buffered.subscribe(subscriber);  InOrder inOrder = Mockito.inOrder(subscriber); scheduler.advanceTimeTo(101, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, Mockito.times(1)).onNext(list(\"one\", \"two\", \"three\"));  scheduler.advanceTimeTo(201, TimeUnit.MILLISECONDS); inOrder.verify(subscriber, Mockito.times(1)).onNext(list(\"four\", \"five\")); inOrder.verify(subscriber, Mockito.never()).onNext(Mockito.<String>anyList()); inOrder.verify(subscriber, Mockito.never()).onError(Mockito.any(Throwable.class)); inOrder.verify(subscriber, Mockito.times(1)).onComplete();",
        "label":0
    },
    {
        "ins1CurCode":" int len = end - start; if (len != len2 || b1 == null || b2 == null) { return false;",
        "ins1PreCode":" int len = end - start; if (len2 != len || b1 == null || b2 == null) { return false;",
        "ins2PreCode":"}  if (b1 == null || b2 == null || end - start != len2) { return false;",
        "label":0
    },
    {
        "ins1CurCode":"this.contextRunner.withPropertyValues(\"spring.main.cloud-platform=kubernetes\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class).hasBean(\"livenessStateHealthIndicator\") .hasSingleBean(ReadinessStateHealthIndicator.class).hasBean(\"readinessStateHealthIndicator\") .hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class));",
        "ins1PreCode":"this.contextRunner.withPropertyValues(\"spring.main.cloud-platform=kubernetes\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class) .hasSingleBean(ReadinessStateHealthIndicator.class) .hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class));",
        "ins2PreCode":"this.contextRunner.withPropertyValues(\"management.endpoint.health.probes.enabled=true\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class) .hasSingleBean(ReadinessStateHealthIndicator.class) .hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class));",
        "label":1
    },
    {
        "ins1CurCode":"assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals( 2, result.getRepeatedFieldCount( result.getDescriptorForType().findFieldByName(\"repeated_foreign_message\")));",
        "ins1PreCode":"assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals(result.getRepeatedFieldCount(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")), 2);",
        "ins2PreCode":"public void testDynamicRepeatedMessageNotNull() throws Exception {  TestAllTypes REPEATED_NESTED = TestAllTypes.newBuilder() .setOptionalInt32(1) .setOptionalString(\"foo\") .setOptionalForeignMessage(ForeignMessage.getDefaultInstance()) .addRepeatedString(\"bar\") .addRepeatedForeignMessage(ForeignMessage.getDefaultInstance()) .addRepeatedForeignMessage(ForeignMessage.getDefaultInstance()) .build(); Descriptors.Descriptor descriptor = TestRequired.getDescriptor(); DynamicMessage result = DynamicMessage.newBuilder(TestAllTypes.getDescriptor()) .mergeFrom(DynamicMessage.newBuilder(REPEATED_NESTED).build()) .build();  assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals(result.getRepeatedFieldCount(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")), 2);",
        "label":0
    },
    {
        "ins1CurCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.ENGLISH); if (granularityU.isEmpty()) { if (action == SEND_FILES) {",
        "ins1PreCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.ENGLISH); if (\"\".equals(granularityU)) { if (action == SEND_FILES) {",
        "ins2PreCode":"public long getMilliseconds(int action) { String granularityU = getValue().toUpperCase(Locale.ENGLISH); if (\"\".equals(granularityU)) { if (action == SEND_FILES) {",
        "label":1
    },
    {
        "ins1CurCode":"}  Tick tick = new NumberTick(currentTickValue, tickLabel, anchor, rotationAnchor, angle);",
        "ins1PreCode":"}  Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle);",
        "ins2PreCode":"}  Tick tick = new NumberTick(new Double(currentTickValue), tickLabel, anchor, rotationAnchor, angle); result.add(tick);",
        "label":1
    },
    {
        "ins1CurCode":"void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception { File testJar = new File(tempDir, \"t+e+s+t.jar\"); TestJarCreator.createTestJar(testJar);",
        "ins1PreCode":"public void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile() throws Exception { File testJar = this.temporaryFolder.newFile(\"t+e+s+t.jar\"); TestJarCreator.createTestJar(testJar);",
        "ins2PreCode":"public void whenJarHasASpaceInItsPathConnectionJarFileMatchesOriginalJarFile() throws Exception { File testJar = this.temporaryFolder.newFile(\"t e s t.jar\"); TestJarCreator.createTestJar(testJar);",
        "label":1
    },
    {
        "ins1CurCode":"void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\"));",
        "ins1PreCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\"));",
        "ins2PreCode":"public void parsePreservesNewlineInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups \\nsala}}\"));",
        "label":1
    },
    {
        "ins1CurCode":" return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2],",
        "ins1PreCode":" return new DiskBlockObjectWriter( (BlockId) args[0], (File) args[1],",
        "ins2PreCode":"public void setup() { shuffleMemoryManager = ShuffleMemoryManager.create(Long.MAX_VALUE, PAGE_SIZE_BYTES); taskMemoryManager = new TaskMemoryManager(new ExecutorMemoryManager(getMemoryAllocator()));   sizeLimitedTaskMemoryManager = mock(TaskMemoryManager.class); when(sizeLimitedTaskMemoryManager.allocate(geq(1L << 20))).thenAnswer( new Answer<MemoryBlock>() { @Override public MemoryBlock answer(InvocationOnMock invocation) throws Throwable { if (((Long) invocation.getArguments()[0] / 8) > Integer.MAX_VALUE) { throw new OutOfMemoryError(\"Requested array size exceeds VM limit\"); } return new MemoryBlock(null, 0, (Long) invocation.getArguments()[0]); } } );",
        "label":0
    },
    {
        "ins1CurCode":"PluginVersionResolutionException { List<TaskSegment> taskSegments = new ArrayList<>( tasks.size() ); ",
        "ins1PreCode":"PluginVersionResolutionException { List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() ); ",
        "ins2PreCode":"PluginVersionResolutionException { List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() ); ",
        "label":1
    },
    {
        "ins1CurCode":"= new DefaultCategoryDataset<>(); dataset.addValue(1.0, \"S1\", \"C1\"); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins1PreCode":"= new DefaultCategoryDataset<>(); dataset.addValue(1.0, \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>(); dataset.addValue(1.0, \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "label":1
    },
    {
        "ins1CurCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; }",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders();",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; } ListSet offs = i.getOffenders(); UMLDeploymentDiagram dd = (UMLDeploymentDiagram) offs.get(0);  ListSet newOffs = computeOffenders(dd); boolean res = offs.equals(newOffs); return res;",
        "label":0
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Item.READ, Item.DELETE, Jenkins.READ) .invokeWithArgs(\"never_created\", \"aProject1\", \"aProject2\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.DELETE, Jenkins.READ) .invokeWithArgs(\"never_created\", \"aProject1\", \"aProject2\");",
        "ins2PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.DELETE, Jenkins.READ) .invokeWithArgs(\"aProject1\",\"never_created\", \"aProject2\");",
        "label":1
    },
    {
        "ins1CurCode":"public final <@NonNull K, @NonNull V> Flowable<GroupedFlowable<K, V>> groupBy(@NonNull Function<? super T, ? extends K> keySelector, @NonNull Function<? super T, ? extends V> valueSelector,",
        "ins1PreCode":"public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(@NonNull Function<? super T, ? extends K> keySelector, @NonNull Function<? super T, ? extends V> valueSelector,",
        "ins2PreCode":"public final <K, V> Flowable<GroupedFlowable<K, V>> groupBy(@NonNull Function<? super T, ? extends K> keySelector, @NonNull Function<? super T, ? extends V> valueSelector,",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindLiveItemsLowerBound_Unordered() { DefaultXYDataset<String> d = new DefaultXYDataset<>(); ",
        "ins1PreCode":"public void testFindLiveItemsLowerBound_Unordered() { DefaultXYDataset d = new DefaultXYDataset(); ",
        "ins2PreCode":"public void testFindLiveItemsLowerBound_Ascending() { DefaultXYDataset d = new DefaultXYDataset() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"int _la; try { setState(424); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,38,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(411); match(LBRACE); setState(412); expression(0); setState(417); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(413); match(COMMA); setState(414); expression(0); } } setState(419); _errHandler.sync(this);",
        "ins1PreCode":"int _la; try { setState(427); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(414); match(LBRACE); setState(415); expression(0); setState(420); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(416); match(COMMA); setState(417); expression(0); } } setState(422); _errHandler.sync(this); _la = _input.LA(1); } setState(423); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(425); match(LBRACE); setState(426); match(RBRACE);",
        "ins2PreCode":"setState(440); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(426); match(LBRACE); setState(427); maptoken(); setState(432); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(428); match(COMMA); setState(429); maptoken(); } } setState(434); _errHandler.sync(this); _la = _input.LA(1); } setState(435); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(437); match(LBRACE); setState(438); match(COLON);",
        "label":1
    },
    {
        "ins1CurCode":"void specifyQueryTimeoutZeroAndTransactionTimeout() throws SQLException { doReturn(0).when(configuration).getDefaultStatementTimeout();",
        "ins1PreCode":"public void specifyQueryTimeoutZeroAndTransactionTimeout() throws SQLException { doReturn(0).when(configuration).getDefaultStatementTimeout();",
        "ins2PreCode":"public void specifyQueryTimeoutAndTransactionTimeoutMinIsQueryTimeout() throws SQLException { doReturn(10).when(configuration).getDefaultStatementTimeout();",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValuePredicateEmpty() { TestObserver<Object> to = new TestObserver<>(); ",
        "ins1PreCode":"public void assertValuePredicateEmpty() { TestObserver<Object> to = new TestObserver<Object>(); ",
        "ins2PreCode":"public void assertValueAtPredicateEmpty() { TestObserver<Object> to = new TestObserver<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"view.description = \"one\"; WebClient wc = j.createWebClient(); String xml = wc.goToXml(\"view/v/config.xml\").getWebResponse().getContentAsString(); assertTrue(xml, xml.contains(\"<description>one</description>\"));",
        "ins1PreCode":"view.description = \"one\"; WebClient wc = j.createWebClient(); String xml = wc.goToXml(\"view/v/config.xml\").getContent(); assertTrue(xml, xml.contains(\"<description>one</description>\"));",
        "ins2PreCode":"@Test public void doConfigDotXmlReset() throws Exception { ListView view = listView(\"v\"); view.description = \"one\"; WebClient wc = j.createWebClient(); String xml = wc.goToXml(\"view/v/config.xml\").getWebResponse().getContentAsString(); assertThat(xml, containsString(\"<description>one</description>\")); xml = xml.replace(\"<description>one</description>\", \"\"); WebRequest req = new WebRequest(wc.createCrumbedUrl(\"view/v/config.xml\"), HttpMethod.POST); req.setRequestBody(xml); req.setEncodingType(null); wc.getPage(req); assertEquals(null, view.getDescription()); xml = new XmlFile(Jenkins.XSTREAM, new File(j.jenkins.getRootDir(), \"config.xml\")).asString(); assertThat(xml, not(containsString(\"<description>\"))); assertEquals(j.jenkins, view.getOwner());",
        "label":0
    },
    {
        "ins1CurCode":"public void testNotIndexed() throws Exception { DocumentMapper mapper = createDocumentMapper( fieldMapping(b -> b.field(\"type\", \"scaled_float\").field(\"index\", false).field(\"scaling_factor\", 10.0)) ); ",
        "ins1PreCode":"public void testNotIndexed() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"index\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject());  DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));  assertEquals(mapping, mapper.mappingSource().toString()); ",
        "ins2PreCode":"public void testNoDocValues() throws Exception { String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject(\"type\") .startObject(\"properties\").startObject(\"field\").field(\"type\", \"scaled_float\") .field(\"doc_values\", false).field(\"scaling_factor\", 10.0).endObject().endObject() .endObject().endObject());  DocumentMapper mapper = parser.parse(\"type\", new CompressedXContent(mapping));  assertEquals(mapping, mapper.mappingSource().toString()); ",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(splitProcessor.getSeparator(), equalTo(\"\\\\.\")); assertFalse(splitProcessor.isIgnoreMissing()); assertFalse(splitProcessor.isPreserveTrailing()); assertThat(splitProcessor.getTargetField(), equalTo(\"target\"));",
        "ins1PreCode":"assertThat(splitProcessor.getSeparator(), equalTo(\"\\\\.\")); assertFalse(splitProcessor.isIgnoreMissing()); assertThat(splitProcessor.getTargetField(), equalTo(\"target\"));",
        "ins2PreCode":"public void testCreate() throws Exception { SplitProcessor.Factory factory = new SplitProcessor.Factory(); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); config.put(\"separator\", \"\\\\.\"); String processorTag = randomAlphaOfLength(10); SplitProcessor splitProcessor = factory.create(null, processorTag, config); assertThat(splitProcessor.getTag(), equalTo(processorTag)); assertThat(splitProcessor.getField(), equalTo(\"field1\")); assertThat(splitProcessor.getSeparator(), equalTo(\"\\\\.\")); assertFalse(splitProcessor.isIgnoreMissing()); assertThat(splitProcessor.getTargetField(), equalTo(\"field1\"));",
        "label":0
    },
    {
        "ins1CurCode":"entry2.setField(StandardField.AUTHOR, \"John Doe\"); entry2.setField(StandardField.YEAR, \"2016\"); entry2.setCitationKey(entry.getCitationKey().get()); database.insertEntry(entry2); BibEntry entry3 = new BibEntry(); entry3.setField(StandardField.AUTHOR, \"John Doe\"); entry3.setField(StandardField.YEAR, \"2016\"); entry3.setCitationKey(entry.getCitationKey().get()); database.insertEntry(entry3); keyGenerator.generateAndSetKey(entry3); assertEquals(Optional.of(\"Doe2016a\"), entry3.getCitationKey());",
        "ins1PreCode":"entry2.setField(StandardField.AUTHOR, \"John Doe\"); entry2.setField(StandardField.YEAR, \"2016\"); entry2.setCiteKey(entry.getCiteKeyOptional().get()); database.insertEntry(entry2); BibEntry entry3 = new BibEntry(); entry3.setField(StandardField.AUTHOR, \"John Doe\"); entry3.setField(StandardField.YEAR, \"2016\"); entry3.setCiteKey(entry.getCiteKeyOptional().get()); database.insertEntry(entry3); keyGenerator.generateAndSetKey(entry3); assertEquals(Optional.of(\"Doe2016a\"), entry3.getCiteKeyOptional());",
        "ins2PreCode":"entry3.setField(StandardField.AUTHOR, \"John Doe\"); entry3.setField(StandardField.YEAR, \"2016\"); entry3.setCiteKey(entry.getCiteKeyOptional().get()); database.insertEntry(entry3); keyGenerator.generateAndSetKey(entry3); assertEquals(Optional.of(\"Doe2016b\"), entry3.getCiteKeyOptional());",
        "label":0
    },
    {
        "ins1CurCode":"public void subClassExceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new IllegalStateException(\"BAD\"); }); this.filter.doFilter(this.request, this.response, this.chain);",
        "ins1PreCode":"public void subClassExceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new IllegalStateException(\"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "ins2PreCode":"public void nestedServletExceptionIsUnwrapped() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new NestedServletException(\"Wrapper\", new RuntimeException(\"BAD\")); } }; this.filter.doFilter(this.request, this.response, this.chain);",
        "label":1
    },
    {
        "ins1CurCode":"public void tryTerminateConsumerObserverError() { TestObserver<Object> to = new TestObserver<>(); to.onSubscribe(Disposable.empty());",
        "ins1PreCode":"public void tryTerminateConsumerObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "ins2PreCode":"public void tryTerminateConsumerMaybeObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1CurCode":"void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception { given(this.applicationContext.getBean(MockitoPostProcessor.class)).willReturn(this.postProcessor); WithMockBean instance = new WithMockBean(); TestContext mockTestContext = mockTestContext(instance); given(mockTestContext.getApplicationContext()).willReturn(this.applicationContext); given(mockTestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE))",
        "ins1PreCode":"void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception { WithMockBean instance = new WithMockBean(); TestContext mockTestContext = mockTestContext(instance); given(mockTestContext.getAttribute(DependencyInjectionTestExecutionListener.REINJECT_DEPENDENCIES_ATTRIBUTE)) .willReturn(Boolean.TRUE); this.listener.beforeTestMethod(mockTestContext);",
        "ins2PreCode":"public void prepareTestInstanceShouldInjectMockBean() throws Exception { WithMockBean instance = new WithMockBean(); this.listener.prepareTestInstance(mockTestContext(instance)); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "label":0
    },
    {
        "ins1CurCode":"}  Collection<CategoryMarker> markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { for (CategoryMarker marker : markers) { r.drawDomainMarker(g2, this, axis, marker, dataArea);",
        "ins1PreCode":"}  Collection<Marker> markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { for (Marker value : markers) { CategoryMarker marker = (CategoryMarker) value; r.drawDomainMarker(g2, this, axis, marker, dataArea);",
        "ins2PreCode":"protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {  XYItemRenderer r = getRenderer(index); if (r == null) { return; }   if (index >= getDatasetCount()) { return; } Collection<Marker> markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { for (Marker marker : markers) { r.drawRangeMarker(g2, this, axis, marker, dataArea); } }",
        "label":0
    },
    {
        "ins1CurCode":"private void testMaxFileSizeProperty(String sizeValue, String expectedFileSize) { this.environment.setProperty(\"logging.file.max-size\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\");",
        "ins1PreCode":"private void testMaxFileSizeProperty(String sizeValue, String expectedFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-size\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\");",
        "ins2PreCode":"void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testXYAutoRange1() { XYSeries<String> series = new XYSeries<>(\"Series 1\"); series.add(1.0, 1.0); series.add(2.0, 2.0); series.add(3.0, 3.0); XYSeriesCollection<String> dataset = new XYSeriesCollection<>(); dataset.addSeries(series);",
        "ins1PreCode":"public void testXYAutoRange1() { XYSeries series = new XYSeries(\"Series 1\"); series.add(1.0, 1.0); series.add(2.0, 2.0); series.add(3.0, 3.0); XYSeriesCollection dataset = new XYSeriesCollection(); dataset.addSeries(series);",
        "ins2PreCode":"public void testXYAutoRange2() { XYSeries series = new XYSeries(\"Series 1\"); series.add(1.0, 1.0); series.add(2.0, 2.0); series.add(3.0, 3.0); XYSeriesCollection dataset = new XYSeriesCollection(); dataset.addSeries(series);",
        "label":1
    },
    {
        "ins1CurCode":"public boolean tryOnError(Throwable t) { if (t == null) { t = ExceptionHelper.createNullPointerException(\"onError called with a null Throwable.\"); }",
        "ins1PreCode":"public boolean tryOnError(Throwable t) { if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); }",
        "ins2PreCode":"public boolean tryOnError(Throwable t) { if (t == null) { t = new NullPointerException(\"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetRangeAxisForDataset() { XYDataset dataset = new XYSeriesCollection<String>(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins1PreCode":"public void testGetRangeAxisForDataset() { XYDataset dataset = new XYSeriesCollection(); NumberAxis xAxis = new NumberAxis(\"X\");",
        "ins2PreCode":"public void testGetDomainAxisForDataset() { CategoryDataset<String, String> dataset = new DefaultCategoryDataset<>(); CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); assertEquals(xAxis, plot.getDomainAxisForDataset(0));   boolean pass = false; try { plot.getDomainAxisForDataset(-1); } catch (IllegalArgumentException e) { pass = true; } assertTrue(pass);    CategoryAxis xAxis2 = new CategoryAxis(\"X2\"); plot.setDomainAxis(1, xAxis2); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  plot.mapDatasetToDomainAxis(0, 1); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));  List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {1, 2}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));",
        "label":0
    },
    {
        "ins1CurCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "ins2PreCode":"{new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1CurCode":"protected void handleOutput(String line) { line = line.trim(); if (!line.isEmpty() && !line.equals(randomOutValue)) { String message = \"Received = [\" + line + \"], expected = [\"",
        "ins1PreCode":"protected void handleOutput(String line) { line = line.trim(); if (line.length() != 0 && !line.equals(randomOutValue)) { String message = \"Received = [\" + line + \"], expected = [\"",
        "ins2PreCode":"protected void handleErrorOutput(String line) { line = line.trim(); if (line.length() != 0 && !line.equals(randomErrValue)) { String message = \"Received = [\" + line + \"], expected = [\"",
        "label":1
    },
    {
        "ins1CurCode":"try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) { assertThat(input).hasBinaryContent(new byte[] { 3 }); }",
        "ins1PreCode":"try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "ins2PreCode":"try (JarFile nested = this.jarFile.getNestedJarFile(this.jarFile.getEntry(\"nested.jar\"))) { try (InputStream input = JarURLConnection.get(url, nested).getInputStream()) { assertThat(input).hasSameContentAs(new ByteArrayInputStream(new byte[] { 3 })); }",
        "label":1
    },
    {
        "ins1CurCode":"personList.add(person2);  JavaRDD<Row> rowRDD = jsc.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = spark.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<Row> actual = spark.sql(\"SELECT * FROM people\").collectAsList(); ",
        "ins1PreCode":"personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<Row> actual = sqlContext.sql(\"SELECT * FROM people\").collectAsList(); ",
        "ins2PreCode":"personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { @Override public Row call(Person person) { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<>(2); fields.add(DataTypes.createStructField(\"\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false)); StructType schema = DataTypes.createStructType(fields);  Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD() .map(new Function<Row, String>() {",
        "label":1
    },
    {
        "ins1CurCode":"public void eagerDisposedOnComplete() { final TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void eagerDisposedOnComplete() { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void eagerDisposedOnError() { final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":".parse(new StringReader(\"@string {bourdieu = {Bourdieu, Pierre}}\"));  BibtexString parsedString = result.getDatabase().getStringValues().iterator().next();  assertEquals(1, result.getDatabase().getStringCount()); assertEquals(\"bourdieu\", parsedString.getName()); assertEquals(\"Bourdieu, Pierre\", parsedString.getContent());",
        "ins1PreCode":"assertEquals(1, result.getDatabase().getStringCount());  BibtexString s = result.getDatabase().getStringValues().iterator().next(); assertEquals(\"bourdieu\", s.getName()); assertEquals(\"Bourdieu, Pierre\", s.getContent());",
        "ins2PreCode":"assertEquals(1, result.getDatabase().getStringCount());  BibtexString s = result.getDatabase().getStringValues().iterator().next(); assertEquals(\"bourdieu\", s.getName()); assertEquals(\"Bourdieu, Pierre\", s.getContent());",
        "label":1
    },
    {
        "ins1CurCode":"public void testRemoveSeries() { XIntervalSeriesCollection<String> c = new XIntervalSeriesCollection<>(); XIntervalSeries<String> s1 = new XIntervalSeries<>(\"s1\"); c.addSeries(s1);",
        "ins1PreCode":"public void testRemoveSeries() { XIntervalSeriesCollection c = new XIntervalSeriesCollection(); XIntervalSeries s1 = new XIntervalSeries(\"s1\"); c.addSeries(s1);",
        "ins2PreCode":"public void testRemoveSeries() { YIntervalSeriesCollection c = new YIntervalSeriesCollection(); YIntervalSeries s1 = new YIntervalSeries(\"s1\"); c.addSeries(s1);",
        "label":1
    },
    {
        "ins1CurCode":"public void iterate() { MimeMappings mappings = new MimeMappings();",
        "ins1PreCode":"public void iterate() throws Exception { MimeMappings mappings = new MimeMappings();",
        "ins2PreCode":"public void getAll() throws Exception { MimeMappings mappings = new MimeMappings();",
        "label":1
    },
    {
        "ins1CurCode":"q.offer(1);  Disposable d = Disposable.empty(); ",
        "ins1PreCode":"q.offer(1);  Disposable d = Disposables.empty(); ",
        "ins2PreCode":"public void drainMaxLoopMissingBackpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1);  QueueDrainHelper.drainMaxLoop(q, ts, false, null, qd);  ts.assertFailure(MissingBackpressureException.class);",
        "label":0
    },
    {
        "ins1CurCode":" StringBuilder target = new StringBuilder(\"testNested4x\"); for (char ch : Arrays.asList('a', 'b', 'c')) { target.setCharAt(target.length() - 1, ch); try {",
        "ins1PreCode":"+ \"not permitted in conjunction with if/unless attributes\";  char[] c = {'a', 'b', 'c'}; StringBuilder target = new StringBuilder(\"testNested4x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try {",
        "ins2PreCode":"String specificMessage = \"A single nested condition is required.\";  char[] c = {'a', 'b'}; StringBuilder target = new StringBuilder(\"testNested7x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try {",
        "label":1
    },
    {
        "ins1CurCode":"void javaBeanNestedPropertyWithAnnotation() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanNestedPropertyWithAnnotation() throws IOException { process(InnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokNestedPropertyWithAnnotation() throws IOException { process(LombokInnerClassProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void testEnumWithOgnlDirectorWithInterface() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "ins1PreCode":"public void testEnumWithOgnlDirectorWithInterface() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); sqlSession.close();",
        "ins2PreCode":"public void testEnumWithOgnlDirectorNameAttributeWithInterface() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeNameAttributeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); sqlSession.close();",
        "label":1
    },
    {
        "ins1CurCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication()); if(!Lifecycle.get().canRewriteHudsonWar()) {",
        "ins1PreCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication());",
        "ins2PreCode":"public void doRestart(StaplerResponse rsp) throws IOException, ServletException { Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Jenkins.getAuthentication()); LOGGER.info(\"Scheduling the core downgrade\");  addJob(job); rsp.sendRedirect2(\".\");",
        "label":0
    },
    {
        "ins1CurCode":"public void testNullWithoutIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), null, \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false,",
        "ins1PreCode":"public void testNullWithoutIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false,",
        "ins2PreCode":"public void testNonExistentWithoutIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false,",
        "label":1
    },
    {
        "ins1CurCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');",
        "ins1PreCode":" assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');",
        "ins2PreCode":"public void forGraph_breadthFirst_iterableIsLazy() { RequestSavingGraph graph = new RequestSavingGraph(DIAMOND_GRAPH); Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('a');  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');",
        "label":0
    },
    {
        "ins1CurCode":"void getPoolSizeNoConnection() { ",
        "ins1PreCode":"public void getPoolSizeNoConnection() { ",
        "ins2PreCode":"public void getPoolSizeOneConnection() { JdbcTemplate jdbcTemplate = new JdbcTemplate(getDataSourceMetadata().getDataSource());",
        "label":1
    },
    {
        "ins1CurCode":"if (childType == MySQLTableColumn.class) { return object.getAttributes(monitor); } else if (childType == MySQLTableUniqueKey.class) { return object.getConstraints(monitor); } else if (childType == MySQLTableCheckConstraint.class) { return object.getConstraints(monitor);",
        "ins1PreCode":"if (childType == MySQLTableColumn.class) { return object.getAttributes(monitor); } else if (childType == MySQLTableConstraint.class) { return object.getConstraints(monitor);",
        "ins2PreCode":"public Collection<? extends DBSObject> getChildObjects(DBRProgressMonitor monitor, PostgreTableBase object, Class<? extends DBSObject> childType) throws DBException { if (childType == PostgreTableColumn.class) { return object.getAttributes(monitor); } else if (childType == PostgreTableConstraint.class) { return object.getConstraints(monitor); } else if (childType == PostgreTableForeign.class) { return object.getAssociations(monitor); } else if (childType == PostgreIndex.class) { return object.getIndexes(monitor); } return null;",
        "label":0
    },
    {
        "ins1CurCode":"public void disposeOnNextAfterFirst() { final TestObserver<Integer> to = new TestObserver<>(); ",
        "ins1PreCode":"public void disposeOnNextAfterFirst() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "ins2PreCode":"public void disposeOnNextAfterFirst() { final TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"}).take(2).subscribe(ts);  assertEquals(2, requested.get());",
        "ins1PreCode":"  assertEquals(Long.MAX_VALUE, requested.get());",
        "ins2PreCode":"public void requestThroughTakeWhereRequestIsSmallerThanTake() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); ts.request(3); final AtomicLong requested = new AtomicLong(); Flowable.<Integer>unsafeCreate(new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> s) { s.onSubscribe(new Subscription() {  @Override public void request(long n) { requested.set(n); }  @Override public void cancel() {  }  }); } }).take(10).subscribe(ts); assertEquals(3, requested.get());",
        "label":0
    },
    {
        "ins1CurCode":"void shouldFindPostsWithAuthorIdUsingDynamicSql() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1PreCode":"public void shouldFindPostsWithAuthorIdUsingDynamicSql() throws Exception { try (SqlSession session = sqlMapper.openSession()) {",
        "ins2PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() { try (SqlSession session = sqlMapper.openSession()) {",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { LayeredBarRenderer r1 = new LayeredBarRenderer(); LayeredBarRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { LayeredBarRenderer r1 = new LayeredBarRenderer(); LayeredBarRenderer r2 = (LayeredBarRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedAreaRenderer r1 = new StackedAreaRenderer(); StackedAreaRenderer r2 = (StackedAreaRenderer) r1.clone(); assertTrue(r1 != r2);",
        "label":1
    },
    {
        "ins1CurCode":"new PushBlock(0, 3, 0, ByteBuffer.wrap(new byte[3])) }; pushBlockHelper(TEST_APP, NO_ATTEMPT_ID, pushBlocks); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); validateMergeStatuses(statuses, new int[] {0}, new long[] {13});",
        "ins1PreCode":"new PushBlock(0, 3, 0, ByteBuffer.wrap(new byte[3])) }; pushBlockHelper(TEST_APP, pushBlocks); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, 0)); validateMergeStatuses(statuses, new int[] {0}, new long[] {13});",
        "ins2PreCode":"new PushBlock(0, 1, 1, ByteBuffer.wrap(new byte[3])) }; pushBlockHelper(TEST_APP, pushBlocks); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, 0)); validateMergeStatuses(statuses, new int[] {0, 1}, new long[] {5, 8});",
        "label":1
    },
    {
        "ins1CurCode":"} final RecursionInterceptor recursionInterceptor = createRecursionInterceptor(); return value -> {",
        "ins1PreCode":"} final RecursionInterceptor recursionInterceptor = createRecursionInterceptor(); return new InnerInterpolator() { @Override public String interpolate( String value ) {",
        "ins2PreCode":"} final RecursionInterceptor recursionInterceptor = createRecursionInterceptor(); return new InnerInterpolator() { @Override public String interpolate( String value ) {",
        "label":1
    },
    {
        "ins1CurCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData()); ",
        "ins1PreCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); ",
        "ins2PreCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); ",
        "label":1
    },
    {
        "ins1CurCode":"   setFilled(true);",
        "ins1PreCode":"  addFig(getBorderFig()); ",
        "ins2PreCode":"} addFig(getOperationsFig()); addFig(getBorderFig()); ",
        "label":1
    },
    {
        "ins1CurCode":"for (N predecessor : sanityCheckSet(graph.predecessors(node))) { assertThat(graph.successors(predecessor)).contains(node); }  for (N successor : sanityCheckSet(graph.successors(node))) { allEndpointPairs.add(EndpointPair.of(graph, node, successor)); assertThat(graph.predecessors(successor)).contains(node); } } ",
        "ins1PreCode":"for (N predecessor : sanityCheckSet(graph.predecessors(node))) { assertThat(graph.successors(predecessor)).contains(node); assertThat(graph.hasEdge(predecessor, node)).isTrue(); }  for (N successor : sanityCheckSet(graph.successors(node))) { allEndpointPairs.add(EndpointPair.of(graph, node, successor)); assertThat(graph.predecessors(successor)).contains(node); assertThat(graph.hasEdge(node, successor)).isTrue(); }",
        "ins2PreCode":"for (N predecessor : sanityCheckSet(graph.predecessors(node))) { assertThat(graph.successors(predecessor)).contains(node); assertThat(graph.hasEdge(predecessor, node)).isTrue(); }  for (N successor : sanityCheckSet(graph.successors(node))) { allEndpointPairs.add(EndpointPair.of(graph, node, successor)); assertThat(graph.predecessors(successor)).contains(node); assertThat(graph.hasEdge(node, successor)).isTrue(); }",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"public void fusedOnErrorCrash() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fusedOnErrorCrash() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void fusedOnErrorCrashConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testDrawWithNullInfo() { try { DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>(); dataset.addValue(1.0, \"S1\", \"C1\");",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(1.0, \"S1\", \"C1\");",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultCategoryDataset dataset = new DefaultCategoryDataset(); dataset.addValue(1.0, \"S1\", \"C1\");",
        "label":1
    },
    {
        "ins1CurCode":"MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class, HazelcastAutoConfiguration.class, ElasticsearchDataAutoConfiguration.class, SolrRepositoriesAutoConfiguration.class, SolrAutoConfiguration.class, RedisAutoConfiguration.class, RedisRepositoriesAutoConfiguration.class,",
        "ins1PreCode":"MongoReactiveAutoConfiguration.class, MongoReactiveDataAutoConfiguration.class, RepositoryRestMvcAutoConfiguration.class, HazelcastAutoConfiguration.class, ElasticsearchDataAutoConfiguration.class, org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration.class, SolrRepositoriesAutoConfiguration.class, SolrAutoConfiguration.class, RedisAutoConfiguration.class,",
        "ins2PreCode":"@Configuration(proxyBeanMethods = false) @ImportAutoConfiguration({ MetricsAutoConfiguration.class, JvmMetricsAutoConfiguration.class, LogbackMetricsAutoConfiguration.class, SystemMetricsAutoConfiguration.class, RabbitMetricsAutoConfiguration.class, CacheMetricsAutoConfiguration.class, DataSourcePoolMetricsAutoConfiguration.class, HibernateMetricsAutoConfiguration.class, HttpClientMetricsAutoConfiguration.class, WebFluxMetricsAutoConfiguration.class, WebMvcMetricsAutoConfiguration.class, JacksonAutoConfiguration.class, HttpMessageConvertersAutoConfiguration.class, RestTemplateAutoConfiguration.class, WebMvcAutoConfiguration.class, DispatcherServletAutoConfiguration.class,",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(final Observer<? super Observable<String>> observer) { final Disposable d = Disposable.empty(); observer.onSubscribe(d);",
        "ins1PreCode":"@Override public void subscribe(final Observer<? super Observable<String>> observer) { final Disposable d = Disposables.empty(); observer.onSubscribe(d);",
        "ins2PreCode":"@Override public void subscribe(final Subscriber<? super Flowable<String>> subscriber) { final Disposable d = Disposables.empty(); subscriber.onSubscribe(new Subscription() {",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"public void predicateThrows() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription());  subscriber.onNext(1); subscriber.onNext(2); subscriber.onError(new TestException()); subscriber.onComplete(); } } .all(new Predicate<Integer>() { @Override public boolean test(Integer v) throws Exception { throw new TestException(); } }) .toFlowable() .test() .assertFailure(TestException.class);  TestHelper.assertUndeliverable(errors, 0, TestException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"void constructorParameterPropertyWithDescription() throws IOException { process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void constructorParameterPropertyWithDescription() throws IOException { process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void constructorParameterPropertyWithDefaultValue() throws IOException { process(ImmutableSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void delayErrorIterableCancelAfterNext() { final TestObserver<Void> to = new TestObserver<>(); ",
        "ins1PreCode":"public void delayErrorIterableCancelAfterNext() { final TestObserver<Void> to = new TestObserver<Void>(); ",
        "ins2PreCode":"public void cancelAfterNext() { final TestObserver<Void> to = new TestObserver<Void>(); ",
        "label":1
    },
    {
        "ins1CurCode":"  UpdateByQueryRequest internal = new UpdateByQueryRequest(); ",
        "ins1PreCode":"  UpdateByQueryRequest internal = new UpdateByQueryRequest(new SearchRequest()); ",
        "ins2PreCode":"  DeleteByQueryRequest internal = new DeleteByQueryRequest(new SearchRequest()); ",
        "label":1
    },
    {
        "ins1CurCode":"private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { Objects.requireNonNull(onNext, \"onNext is null\"); Objects.requireNonNull(onError, \"onError is null\"); Objects.requireNonNull(onComplete, \"onComplete is null\"); Objects.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins1PreCode":"private Observable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new ObservableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "ins2PreCode":"private Flowable<T> doOnEach(Consumer<? super T> onNext, Consumer<? super Throwable> onError, Action onComplete, Action onAfterTerminate) { ObjectHelper.requireNonNull(onNext, \"onNext is null\"); ObjectHelper.requireNonNull(onError, \"onError is null\"); ObjectHelper.requireNonNull(onComplete, \"onComplete is null\"); ObjectHelper.requireNonNull(onAfterTerminate, \"onAfterTerminate is null\"); return RxJavaPlugins.onAssembly(new FlowableDoOnEach<T>(this, onNext, onError, onComplete, onAfterTerminate));",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { MatrixSeries<String> s1 = new MatrixSeries<>(\"Series\", 2, 3); s1.update(0, 0, 1.1); MatrixSeriesCollection<String> c1 = new MatrixSeriesCollection<>(); c1.addSeries(s1); MatrixSeriesCollection<String> c2 = CloneUtils.clone(c1); ",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { MatrixSeries s1 = new MatrixSeries(\"Series\", 2, 3); s1.update(0, 0, 1.1); MatrixSeriesCollection c1 = new MatrixSeriesCollection(); c1.addSeries(s1); MatrixSeriesCollection c2 = CloneUtils.clone(c1); ",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { VectorSeries s1 = new VectorSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); VectorSeriesCollection c1 = new VectorSeriesCollection(); c1.addSeries(s1); VectorSeriesCollection c2 = CloneUtils.clone(c1); assertTrue(c1 != c2); assertTrue(c1.getClass() == c2.getClass()); assertTrue(c1.equals(c2));   s1.setDescription(\"XYZ\"); assertFalse(c1.equals(c2));",
        "label":0
    },
    {
        "ins1CurCode":"}  Deque<String> relativePath = new ArrayDeque<>(); FilePath current = this.f;",
        "ins1PreCode":"}  LinkedList<String> relativePath = new LinkedList<>(); FilePath current = this.f;",
        "ins2PreCode":"}  Deque<String> relativePath = new LinkedList<>(); File current = this.f;",
        "label":0
    },
    {
        "ins1CurCode":"} String systemid = JAXPUtils.getSystemId(file); assertThat(\"SystemIDs should start by file:/\", systemid, startsWith(\"file:/\")); assertThat(\"SystemIDs should not start with file:////\", systemid, not(startsWith(\"file:////\")));",
        "ins1PreCode":"} String systemid = JAXPUtils.getSystemId(file); assertTrue(\"SystemIDs should start by file:/\", systemid.startsWith(\"file:/\")); assertFalse(\"SystemIDs should not start with file:////\", systemid.startsWith(\"file:////\"));",
        "ins2PreCode":"} String systemid = JAXPUtils.getSystemId(file); assertTrue(\"SystemIDs should start by file:/\", systemid.startsWith(\"file:/\")); assertFalse(\"SystemIDs should not start with file:////\", systemid.startsWith(\"file:////\"));",
        "label":1
    },
    {
        "ins1CurCode":" try { v = Objects.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper function returned a null value.\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testDynamicMessage() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValuesUsingMutableMap(builder); TestMap message = builder.build();",
        "ins1PreCode":"public void testDynamicMessage() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();",
        "ins2PreCode":"public void testDynamicMessage() throws Exception { TestMap.Builder builder = TestMap.newBuilder(); setMapValues(builder); TestMap message = builder.build();",
        "label":1
    },
    {
        "ins1CurCode":"return visitBraceaccess(ctx.braceaccess(), prefix); } else { throw location(ctx).createError(new IllegalStateException(\"illegal tree structure\")); }",
        "ins1PreCode":"return visitBraceaccess(ctx.braceaccess(), prefix); } else { throw location(ctx).createError(new IllegalStateException(\"Illegal tree structure.\")); }",
        "ins2PreCode":"return visitFieldaccess(ctx.fieldaccess(), prefix); } else { throw location(ctx).createError(new IllegalStateException(\"Illegal tree structure.\")); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "label":1
    },
    {
        "ins1CurCode":"void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); database.insertEntry(entry);  Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"testvalue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testvalue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"public void completeBeginnigOfSecondWordReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"val\"))); assertEquals(Collections.singletonList(\"test value\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"Single<Object> fromSupplierSingle = Single.fromSupplier(func);  verifyNoInteractions(func); ",
        "ins1PreCode":"Single<Object> fromSupplierSingle = Single.fromSupplier(func);  verifyZeroInteractions(func); ",
        "ins2PreCode":"Observable<Object> fromSupplierObservable = Observable.fromSupplier(func);  verifyZeroInteractions(func); ",
        "label":1
    },
    {
        "ins1CurCode":"final int j = i; t[j] = new Thread() { @Override public void run() {",
        "ins1PreCode":"final int j = i; t[j] = new Thread() { public void run() { status[j].stop();",
        "ins2PreCode":"final int j = i; t[j] = new Thread() { public void run() { status[j].start();",
        "label":1
    },
    {
        "ins1CurCode":"(SerializerInstance) args[2], (Integer) args[3], new WrapStream(), false,",
        "ins1PreCode":"(SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false,",
        "ins2PreCode":"(SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false,",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 50; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(WsContextListener.class.getName()); ",
        "ins1PreCode":"Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false)); ",
        "ins2PreCode":"org.apache.catalina.Context ctx = tomcat.addWebapp(null, \"/examples\", appDir.getAbsolutePath()); ctx.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false)); ",
        "label":1
    },
    {
        "ins1CurCode":"} } if (wakeUpTransferInterval > 0) { if (wakeUpTransferIntervalExpired()) { getProject().log(\"wakeUpTransferInterval is reached,\" + \" trigger a data connection \", Project.MSG_DEBUG); ",
        "ins1PreCode":"} } if(wakeUpTransferInterval > 0) { if(wakeUpTransferIntervalExpired()) { getProject().log(\"wakeUpTransferInterval is reached, trigger a data connection \" , Project.MSG_DEBUG); ",
        "ins2PreCode":"protected void scandir(String dir, String vpath, boolean fast) {  if (fast && hasBeenScanned(vpath)) { return; } try { if (!ftp.changeWorkingDirectory(dir)) { return; } String completePath; if (vpath.isEmpty()) { completePath = rootPath; } else { completePath = rootPath + task.getSeparator() + vpath.replace(File.separatorChar, task.getSeparator().charAt(0)); } FTPFile[] newfiles = listFiles(completePath, false);  if (newfiles == null) { ftp.changeToParentDirectory(); return; } for (FTPFile file : newfiles) { if (file != null && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file)); if (isFunctioningAsDirectory(ftp, dir, file)) { boolean slowScanAllowed = true; if (!isFollowSymlinks() && file.isSymbolicLink()) { dirsExcluded.addElement(name); slowScanAllowed = false; } else if (isIncluded(name)) { accountForIncludedDir(name, new AntFTPFile(ftp, file, completePath), fast); } else { dirsNotIncluded.addElement(name); if (fast && couldHoldIncluded(name)) { scandir(file.getName(), name + File.separator, fast); } } if (!fast && slowScanAllowed) { scandir(file.getName(), name + File.separator, fast); } } else { if (!isFollowSymlinks() && file.isSymbolicLink()) { filesExcluded.addElement(name); } else if (isFunctioningAsFile(ftp, dir, file)) { accountForIncludedFile(name); } } } } ftp.changeToParentDirectory(); } catch (IOException e) { throw new BuildException(\"Error while communicating with FTP \" + \"server: \", e); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins1PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2WithSelectKeyWithKeyMap(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"barney_fred\", name.getGeneratedName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testAnnotatedInsertTable3() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable3(name); assertEquals(1, rows); assertEquals(33, name.getNameId()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncDispatch()\", state)); }",
        "ins1PreCode":"throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"dispatchAsync()\", state)); }",
        "ins2PreCode":"public synchronized boolean asyncComplete() { boolean doComplete = false;  if (state == AsyncState.STARTING) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.STARTED) { state = AsyncState.COMPLETING; doComplete = true; } else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncComplete()\", state));  } return doComplete;",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"custommvc\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isTrue();",
        "ins1PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isTrue();",
        "ins2PreCode":"assertThat(isExposed(mvc, HttpMethod.GET, \"conditions\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"configprops\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"env\")).isTrue(); assertThat(isExposed(mvc, HttpMethod.GET, \"health\")).isTrue();",
        "label":1
    },
    {
        "ins1CurCode":"public void testRefresh() throws IOException { Request request = new Request(\"POST\", \"/_kibana/_bulk\"); request.setJsonEntity(\"{ \\\"index\\\" : { \\\"_index\\\" : \\\"\" + indexName + \"\\\", \\\"_id\\\" : \\\"1\\\" } }\\n{ \\\"foo\\\" : \\\"bar\\\" }\\n\"); Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  request = new Request(\"GET\", \"/_kibana/\" + indexName + \"/_refresh\"); response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  Request getRequest = new Request(\"GET\", \"/_kibana/\" + indexName + \"/_doc/1\"); Response getResponse = client().performRequest(getRequest);",
        "ins1PreCode":"public void testRefresh() throws IOException { Request request = new Request(\"POST\", \"/_kibana/_bulk\"); request.setJsonEntity(\"{ \\\"index\\\" : { \\\"_index\\\" : \\\".kibana\\\", \\\"_id\\\" : \\\"1\\\" } }\\n{ \\\"foo\\\" : \\\"bar\\\" }\\n\"); Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  request = new Request(\"GET\", \"/_kibana/.kibana/_refresh\"); response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  Request getRequest = new Request(\"GET\", \"/_kibana/.kibana/_doc/1\"); Response getResponse = client().performRequest(getRequest);",
        "ins2PreCode":"public void testGetFromKibanaIndex() throws IOException { Request request = new Request(\"POST\", \"/_kibana/_bulk\"); request.setJsonEntity(\"{ \\\"index\\\" : { \\\"_index\\\" : \\\".kibana\\\", \\\"_id\\\" : \\\"1\\\" } }\\n{ \\\"foo\\\" : \\\"bar\\\" }\\n\"); request.addParameter(\"refresh\", \"true\");  Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  Request getRequest = new Request(\"GET\", \"/_kibana/.kibana/_doc/1\"); Response getResponse = client().performRequest(getRequest);",
        "label":0
    },
    {
        "ins1CurCode":"case IDENTIFIER: Expression(); label_14: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_14; }",
        "ins1PreCode":"case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_15; }",
        "ins2PreCode":"case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_16; }",
        "label":1
    },
    {
        "ins1CurCode":" expected.remove(ACMPortalFetcher.class); expected.remove(JstorFetcher.class); expected.remove(GoogleScholar.class); ",
        "ins1PreCode":" expected.remove(ACMPortalFetcher.class);  assertEquals(expected, getClasses(idFetchers)); }",
        "ins2PreCode":" expected.remove(ACMPortalFetcher.class);  expected.remove(PagedSearchBasedParserFetcher.class); expected.remove(PagedSearchBasedFetcher.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset<String, String> dataset0 = new DefaultCategoryDataset<>(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>(); dataset1.addValue(23.0, \"R3\", \"C1\");",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\");",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\");",
        "label":1
    },
    {
        "ins1CurCode":"public Collection<Feature> allAvailableFeatures(Object arole) { LOG.info(\"allAvailableFeatures start\");  if (arole instanceof ClassifierRole) { try { List<Feature> returnList = new ArrayList<Feature>(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableFeatures(genElem)); } } for (Classifier classifier : role.getBase()) { returnList.addAll(classifier.getFeature()); } LOG.info(\"allAvailableFeatures \" + returnList.size()); return returnList;",
        "ins1PreCode":"public Collection<Feature> allAvailableFeatures(Object arole) {  if (arole instanceof ClassifierRole) { try { List<Feature> returnList = new ArrayList<Feature>(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableFeatures(genElem)); } } for (Classifier classifier : role.getBase()) { returnList.addAll(classifier.getFeature()); } return returnList; } catch (InvalidObjectException e) { throw new InvalidElementException(e);",
        "ins2PreCode":"public Collection allAvailableContents(Object arole) { try { if (arole instanceof ClassifierRole) { List returnList = new ArrayList(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableContents(genElem)); } } for (Classifier baseClassifier : role.getBase()) { returnList.addAll(baseClassifier.getOwnedElement()); } return returnList; } } catch (InvalidObjectException e) {",
        "label":1
    },
    {
        "ins1CurCode":"List<BibEntry> entries = Arrays.asList(entry);  exportFormat.export(databaseContext, tmpFile.toPath(), charset, entries); ",
        "ins1PreCode":"public void testPerformExportForSingleAuthor() throws Exception { File tmpFile = testFolder.newFile(); String filename = tmpFile.getCanonicalPath(); BibEntry entry = new BibEntry(); entry.setField(\"author\", \"Someone, Van Something\"); List<BibEntry> entries = Arrays.asList(entry);  exportFormat.performExport(databaseContext, filename, charset, entries); ",
        "ins2PreCode":"public void testPerformExportForMultipleAuthors() throws Exception { File tmpFile = testFolder.newFile(); String filename = tmpFile.getCanonicalPath(); BibEntry entry = new BibEntry(); entry.setField(\"author\", \"von Neumann, John and Smith, John and Black Brown, Peter\"); List<BibEntry> entries = Arrays.asList(entry);  exportFormat.performExport(databaseContext, filename, charset, entries); ",
        "label":1
    },
    {
        "ins1CurCode":"buffer.append( \" (scope managed from \" ).append( premanagedScope ); appendManagementSource( buffer, art, \"scope\" ); buffer.append( ')' ); }  String premanagedVersion = DependencyManagerUtils.getPremanagedVersion( node ); if ( premanagedVersion != null && !premanagedVersion.equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( premanagedVersion ); appendManagementSource( buffer, art, \"version\" ); buffer.append( ')' ); }",
        "ins1PreCode":"buffer.append( \" (scope managed from \" ).append( premanagedScope ); appendManagementSource( buffer, art, \"scope\" ); buffer.append( \")\" ); }  String premanagedVersion = DependencyManagerUtils.getPremanagedVersion( node ); if ( premanagedVersion != null && !premanagedVersion.equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( premanagedVersion ); appendManagementSource( buffer, art, \"version\" ); buffer.append( \")\" ); }",
        "ins2PreCode":"public boolean visitEnter( DependencyNode node ) { StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() ); }  logger.debug( buffer.toString() ); indent += \"   \"; return true;",
        "label":0
    },
    {
        "ins1CurCode":"this.server .expect(requestTo( \"https://repo.spring.io/api/build/distribute/example-build/example-build-1\")) .andExpect(method(HttpMethod.POST))",
        "ins1PreCode":"this.server .expect(requestTo( \"https://repo.spring.io/api/build/distribute/\" + \"example-build\" + \"/\" + \"example-build-1\")) .andExpect(method(HttpMethod.POST))",
        "ins2PreCode":"this.server .expect(requestTo( \"https://repo.spring.io/api/build/distribute/\" + \"example-build\" + \"/\" + \"example-build-1\")) .andExpect(method(HttpMethod.POST))",
        "label":1
    },
    {
        "ins1CurCode":"public void testBuildTargetField() throws Exception { GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000)); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"target_field\", \"_field\");",
        "ins1PreCode":"public void testBuildTargetField() throws Exception {   assumeFalse(\"windows deletion behavior is asinine\", Constants.WINDOWS); GeoIpProcessor.Factory factory = new GeoIpProcessor.Factory(databaseReaders, new GeoIpCache(1000));",
        "ins2PreCode":"public void testBuildTargetField() throws Exception { UserAgentProcessor.Factory factory = new UserAgentProcessor.Factory(userAgentParsers);  Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"target_field\", \"_target_field\");  UserAgentProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\")); assertThat(processor.getTargetField(), equalTo(\"_target_field\"));",
        "label":0
    },
    {
        "ins1CurCode":"} catch (CriticalXStreamException e) { throw e; } catch (XStreamException | LinkageError e) { RobustReflectionConverter.addErrorInContext(context, e);",
        "ins1PreCode":"} catch (CriticalXStreamException e) { throw e; } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { RobustReflectionConverter.addErrorInContext(context, e);",
        "ins2PreCode":"} catch (CriticalXStreamException e) { throw e; } catch (XStreamException e) { RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { RobustReflectionConverter.addErrorInContext(context, e);",
        "label":1
    },
    {
        "ins1CurCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Arrays.asList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Arrays.asList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Arrays.asList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Arrays.asList(testBatch, testBatch), 2)); StreamingLogisticRegressionWithSGD slr = new StreamingLogisticRegressionWithSGD()",
        "ins1PreCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Lists.newArrayList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2)); StreamingLogisticRegressionWithSGD slr = new StreamingLogisticRegressionWithSGD()",
        "ins2PreCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Lists.newArrayList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2)); StreamingLinearRegressionWithSGD slr = new StreamingLinearRegressionWithSGD()",
        "label":1
    },
    {
        "ins1CurCode":"void javaBeanCollectionProperty() throws IOException { process(SimpleCollectionProperties.class, (roundEnv, metadataEnv) -> {",
        "ins1PreCode":"public void javaBeanCollectionProperty() throws IOException { process(SimpleCollectionProperties.class, (roundEnv, metadataEnv) -> {",
        "ins2PreCode":"public void lombokCollectionProperty() throws IOException { process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> {",
        "label":1
    },
    {
        "ins1CurCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins1PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "ins2PreCode":"BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername());",
        "label":1
    },
    {
        "ins1CurCode":".test();  assertFalse(\"Subject still has observers!\", ps.hasObservers()); ",
        "ins1PreCode":".test();  assertFalse(\"Subject still has subscribers!\", ps.hasObservers()); ",
        "ins2PreCode":".test();  assertFalse(\"Subject still has subscribers!\", ps.hasObservers()); ",
        "label":1
    },
    {
        "ins1CurCode":"void getEndpointsShouldDiscoverProxyServletEndpoints() { this.contextRunner.withUserConfiguration(TestProxyServletEndpoint.class)",
        "ins1PreCode":"public void getEndpointsShouldDiscoverProxyServletEndpoints() { this.contextRunner.withUserConfiguration(TestProxyServletEndpoint.class)",
        "ins2PreCode":"public void getEndpointsShouldIncludeControllerEndpoints() { this.contextRunner.withUserConfiguration(TestControllerEndpoint.class).run(assertDiscoverer((discoverer) -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void testAlternateIncludeExclude() { ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/**\", \"alpha/beta/gamma/**\"});",
        "ins1PreCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\")));",
        "ins2PreCode":"public void testAlternateExcludeInclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\")));",
        "label":1
    },
    {
        "ins1CurCode":"Object a = me; int count = 1; if (Model.getFacade().getOwner(a) != null) { count = Model.getFacade().getFeatures(",
        "ins1PreCode":"Object a = me; int count = 1; if (Model.getFacade().getOwner(a) != null) count = Model.getFacade().getFeatures(",
        "ins2PreCode":"Object a = me; int count = 1; if (Model.getFacade().getOwner(a) != null) count = Model.getFacade().getFeatures(",
        "label":1
    },
    {
        "ins1CurCode":" d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); assertFalse(d1.equals(d2)); d2.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList<>())); assertTrue(d1.equals(d2));",
        "ins1PreCode":" d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertFalse(d1.equals(d2)); d2.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertTrue(d1.equals(d2));",
        "ins2PreCode":"\"Series\"); d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   d1.add(new Date(2L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); assertFalse(d1.equals(d2));",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtPredicateNoMatch() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void assertValueAtPredicateNoMatch() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void assertValueAtPredicateNoMatch() { TestObserver<Integer> to = new TestObserver<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(Script.parse(o))); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));",
        "ins1PreCode":"Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(parseScript(o))); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));",
        "ins2PreCode":"protected DeleteByQueryRequest buildRequest(RestRequest request) throws IOException {      DeleteByQueryRequest internal = new DeleteByQueryRequest();  Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));  parseInternalRequest(internal, request, consumers);  return internal;",
        "label":0
    },
    {
        "ins1CurCode":"}  setControl(composite);",
        "ins1PreCode":"}  loadSettings(); updateState();",
        "ins2PreCode":"public void createControl(Composite parent) { Composite composite = UIUtils.createPlaceholder(parent, 1);  Group objectsGroup = UIUtils.createControlGroup(composite, MySQLUIMessages.tools_db_export_wizard_page_settings_group_objects, 1, GridData.FILL_HORIZONTAL, 0); objectsGroup.setLayoutData(new GridData(GridData.FILL_BOTH));  SashForm sash = new CustomSashForm(objectsGroup, SWT.VERTICAL); sash.setLayoutData(new GridData(GridData.FILL_BOTH));  { Composite catPanel = UIUtils.createComposite(sash, 1); catPanel.setLayoutData(new GridData(GridData.FILL_BOTH)); catalogTable = new Table(catPanel, SWT.BORDER | SWT.CHECK); catalogTable.addListener(SWT.Selection, event -> { TableItem item = (TableItem) event.item; if (item != null) { MySQLCatalog catalog = (MySQLCatalog) item.getData(); if (event.detail == SWT.CHECK) { catalogTable.select(catalogTable.indexOf(item)); checkedObjects.remove(catalog); } loadTables(catalog); updateState(); } }); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; catalogTable.setLayoutData(gd);  Composite buttonsPanel = UIUtils.createComposite(catPanel, 3); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); new Label(buttonsPanel, SWT.NONE).setLayoutData(new GridData(GridData.GRAB_HORIZONTAL)); createCheckButtons(buttonsPanel, catalogTable); }  { Composite tablesPanel = UIUtils.createComposite(sash, 1); tablesPanel.setLayoutData(new GridData(GridData.FILL_BOTH));  tablesTable = new Table(tablesPanel, SWT.BORDER | SWT.CHECK); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; tablesTable.setLayoutData(gd); tablesTable.addListener(SWT.Selection, event -> { if (event.detail == SWT.CHECK) { updateCheckedTables(); updateState(); } }); Composite buttonsPanel = UIUtils.createComposite(tablesPanel, 3); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));  exportViewsCheck = UIUtils.createCheckbox(buttonsPanel, \"Show views\", false); exportViewsCheck.addSelectionListener(new SelectionAdapter() { @Override public void widgetSelected(SelectionEvent e) { wizard.getSettings().setShowViews(exportViewsCheck.getSelection()); loadTables(null); } }); exportViewsCheck.setLayoutData(new GridData(GridData.GRAB_HORIZONTAL)); createCheckButtons(buttonsPanel, tablesTable); }  loadSettings(); setControl(composite);",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32FieldMap().keySet()));",
        "ins1PreCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "label":1
    },
    {
        "ins1CurCode":"public void fromPropertySourceShouldFlattenPropertySources() { StandardEnvironment environment = new StandardEnvironment();",
        "ins1PreCode":"public void fromPropertySourceShouldFlattenPropertySources() throws Exception { StandardEnvironment environment = new StandardEnvironment();",
        "ins2PreCode":"public void shouldFlattenEnvironment() throws Exception { StandardEnvironment environment = new StandardEnvironment();",
        "label":1
    },
    {
        "ins1CurCode":"LatexBibEntriesResolverResult expectedCrossingResult2 = new LatexBibEntriesResolverResult(expectedParserResult);  expectedCrossingResult2.addEntry(database.getEntryByCitationKey(EINSTEIN).get()); expectedCrossingResult2.addEntry(database.getEntryByCitationKey(DARWIN).get()); ",
        "ins1PreCode":"LatexBibEntriesResolverResult expectedCrossingResult2 = new LatexBibEntriesResolverResult(expectedParserResult);  expectedCrossingResult2.addEntry(database.getEntryByKey(EINSTEIN).get()); expectedCrossingResult2.addEntry(database.getEntryByKey(DARWIN).get()); ",
        "ins2PreCode":"public void testTwoFiles() throws URISyntaxException { Path texFile = Path.of(DefaultTexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Path.of(DefaultTexParserTest.class.getResource(\"paper2.tex\").toURI());  LatexParserResult parserResult = new DefaultLatexParser().parse(Arrays.asList(texFile, texFile2)); LatexParserResult expectedParserResult = new LatexParserResult();  expectedParserResult.getFileList().addAll(Arrays.asList(texFile, texFile2)); expectedParserResult.addBibFile(texFile, texFile.getParent().resolve(\"origin.bib\")); expectedParserResult.addBibFile(texFile2, texFile2.getParent().resolve(\"origin.bib\")); expectedParserResult.addKey(EINSTEIN, texFile, 4, 0, 19, \"\\\\cite{Einstein1920}\"); expectedParserResult.addKey(DARWIN, texFile, 5, 0, 17, \"\\\\cite{Darwin1888}.\"); expectedParserResult.addKey(EINSTEIN, texFile, 6, 14, 33, \"Einstein said \\\\cite{Einstein1920} that lorem impsum, consectetur adipiscing elit.\"); expectedParserResult.addKey(DARWIN, texFile, 7, 67, 84, \"Nunc ultricies leo nec libero rhoncus, eu vehicula enim efficitur. \\\\cite{Darwin1888}\"); expectedParserResult.addKey(DARWIN, texFile2, 4, 48, 65, \"This is some content trying to cite a bib file: \\\\cite{Darwin1888}\"); expectedParserResult.addKey(EINSTEIN, texFile2, 5, 48, 67, \"This is some content trying to cite a bib file: \\\\cite{Einstein1920}\"); expectedParserResult.addKey(NEWTON, texFile2, 6, 48, 65, \"This is some content trying to cite a bib file: \\\\cite{Newton1999}\");  assertEquals(expectedParserResult, parserResult);",
        "label":0
    },
    {
        "ins1CurCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { requirePOST(); Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication()); if(!Lifecycle.get().canRewriteHudsonWar()) {",
        "ins1PreCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { requirePOST(); Hudson.getInstance().checkPermission(Hudson.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Hudson.getAuthentication()); if(!Lifecycle.get().canRewriteHudsonWar()) {",
        "ins2PreCode":"public void doRestart(StaplerResponse rsp) throws IOException, ServletException { Hudson.getInstance().checkPermission(Hudson.ADMINISTER); HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Hudson.getAuthentication()); LOGGER.info(\"Scheduling the core downgrade\");",
        "label":1
    },
    {
        "ins1CurCode":"void addAndRemoveEntry() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getNumberOfKeyOccurrences(\"AAA\")); database.removeEntry(entry); assertEquals(0, database.getNumberOfKeyOccurrences(\"AAA\"));",
        "ins1PreCode":"public void addAndRemoveEntry() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\")); database.removeEntry(entry); assertEquals(0, database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"));",
        "ins2PreCode":"public void removeEmptyCiteKey() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"));  entry.setCiteKey(\"\"); database.removeEntry(entry); assertEquals(0, database.getDuplicationChecker().getNumberOfKeyOccurrences(\"AAA\"));",
        "label":1
    },
    {
        "ins1CurCode":"{ DistributionManagement src = source.getDistributionManagement(); if ( src != null ) {",
        "ins1PreCode":"{ DistributionManagement src = source.getDistributionManagement(); if ( source.getDistributionManagement() != null ) {",
        "ins2PreCode":"{ DependencyManagement src = source.getDependencyManagement(); if ( source.getDependencyManagement() != null ) {",
        "label":1
    },
    {
        "ins1CurCode":"}  newJarStream = new JarOutputStream(Files.newOutputStream(newwasJarFile.toPath())); newJarStream.setLevel(0);",
        "ins1PreCode":"}  newJarStream = new JarOutputStream(new FileOutputStream(newwasJarFile)); newJarStream.setLevel(0);",
        "ins2PreCode":"}  newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile)); newJarStream.setLevel(0);",
        "label":1
    },
    {
        "ins1CurCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toFlowable();  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"a\");",
        "ins1PreCode":"Flowable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toFlowable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "ins2PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\");",
        "label":1
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"public void testJavaKeyWordSuffix() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl(factory); ",
        "ins1PreCode":"public void testJavaKeyWordSuffix() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl(); ",
        "ins2PreCode":"public void testJavaKeyWordIdentifier() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl(); ",
        "label":1
    },
    {
        "ins1CurCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> { availableParameters.add(Log.class, logFactory::getLog); availableParameters.add(ConfigurableBootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapRegistry.class, bootstrapContext); }); this.loaders = instantiator.instantiate(names);",
        "ins1PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> availableParameters.add(Log.class, logFactory::getLog)); this.loaders = instantiator.instantiate(names);",
        "ins2PreCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass());",
        "label":0
    },
    {
        "ins1CurCode":"boolean success; try { DefaultBoxAndWhiskerCategoryDataset<String, String> dataset = new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5,",
        "ins1PreCode":"boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5,",
        "ins2PreCode":"boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5,",
        "label":1
    },
    {
        "ins1CurCode":"return false; } if (!Objects.equals(this.y, that.y)) { return false;",
        "ins1PreCode":"return false; } if (!ObjectUtils.equal(this.y, that.y)) { return false;",
        "ins2PreCode":"return false; } if (!ObjectUtils.equal(this.obj, that.obj)) { return false;",
        "label":1
    },
    {
        "ins1CurCode":"void errorResponseAlwaysDetails() { this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ALWAYS); this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ALWAYS); this.request.addParameter(\"trace\", \"false\"); this.request.addParameter(\"message\", \"false\"); ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);",
        "ins1PreCode":"void errorResponseAlwaysDetails() { this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ALWAYS); this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ALWAYS); this.request.addParameter(\"trace\", \"false\"); this.request.addParameter(\"details\", \"false\"); ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);",
        "ins2PreCode":"void errorResponseParamsTrue() { this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM); this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ON_DETAILS_PARAM); this.request.addParameter(\"trace\", \"true\"); this.request.addParameter(\"details\", \"true\"); ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties);",
        "label":0
    },
    {
        "ins1CurCode":"String actual = webResource.getURL().toString();  if (JrePlatform.IS_WINDOWS){ expected = expected.toLowerCase();",
        "ins1PreCode":"String actual = webResource.getURL().toString();  if (isWindows()){ expected = expected.toLowerCase();",
        "ins2PreCode":"String actual = webResource.getURL().toString();  if (isWindows()){ expected = expected.toLowerCase();",
        "label":1
    },
    {
        "ins1CurCode":"if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = (FigNode) ((UMLDiagram) diag).drop(node, null); } else {",
        "ins1PreCode":"if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else {",
        "ins2PreCode":"if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else {",
        "label":1
    },
    {
        "ins1CurCode":"final Jenkins jenkins = Jenkins.getActiveInstance();  final HashSet<String> hs = new HashSet<>(); hs.addAll(nodes);",
        "ins1PreCode":"final Jenkins jenkins = Jenkins.getActiveInstance();  final HashSet<String> hs = new HashSet<String>(); hs.addAll(nodes);",
        "ins2PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.getInstance(); final HashSet<String> hs = new HashSet<String>(nodes); List<String> names = null;",
        "label":0
    },
    {
        "ins1CurCode":"{ CiManagement src = source.getCiManagement(); if ( src != null ) {",
        "ins1PreCode":"{ CiManagement src = source.getCiManagement(); if ( source.getCiManagement() != null ) {",
        "ins2PreCode":"{ DistributionManagement src = source.getDistributionManagement(); if ( source.getDistributionManagement() != null ) {",
        "label":1
    },
    {
        "ins1CurCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(\",\") .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace()))",
        "ins1PreCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace()))",
        "ins2PreCode":"public void testCharacterSplitWithTrim() { String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = COMMA_SPLITTER .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace())) .split(jacksons); assertThat(family) .containsExactly(\"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\") .inOrder();",
        "label":0
    },
    {
        "ins1CurCode":"void profilesAddedToEnvironmentAndViaProperty(CapturedOutput output) {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=other\"); this.environment.addActiveProfile(\"dev\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).contains(\"dev\", \"other\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromotherpropertiesfile\"); validateProfilePreference(output, null, \"dev\", \"other\");",
        "ins1PreCode":"void profilesAddedToEnvironmentAndViaProperty(CapturedOutput capturedOutput) {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=other\"); this.environment.addActiveProfile(\"dev\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).contains(\"dev\", \"other\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromotherpropertiesfile\"); validateProfilePreference(capturedOutput, null, \"dev\", \"other\");",
        "ins2PreCode":"void profilesAddedToEnvironmentViaActiveAndIncludeProperty(CapturedOutput capturedOutput) {  TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.profiles.active=dev\", \"spring.profiles.include=other\"); this.initializer.postProcessEnvironment(this.environment, this.application); assertThat(this.environment.getActiveProfiles()).containsExactly(\"other\", \"dev\"); assertThat(this.environment.getProperty(\"my.property\")).isEqualTo(\"fromdevpropertiesfile\"); validateProfilePreference(capturedOutput, null, \"other\", \"dev\");",
        "label":1
    },
    {
        "ins1CurCode":"}  queue = new SpscArrayQueue<>(bufferSize); ",
        "ins1PreCode":"}  queue = new SpscArrayQueue<T>(bufferSize); ",
        "ins2PreCode":"public void onSubscribe(Subscription s) { if (SubscriptionHelper.setOnce(this, s)) { if (s instanceof QueueSubscription) { @SuppressWarnings(\"unchecked\") QueueSubscription<T> qs = (QueueSubscription<T>) s;  int m = qs.requestFusion(QueueSubscription.ANY); if (m == QueueSubscription.SYNC) { fusionMode = m; queue = qs; done = true; parent.innerComplete(this); return; } if (m == QueueSubscription.ASYNC) { fusionMode = m; queue = qs; QueueDrainHelper.request(s, prefetch); return; } }  queue = QueueDrainHelper.createQueue(prefetch);  QueueDrainHelper.request(s, prefetch); }",
        "label":0
    },
    {
        "ins1CurCode":"this.webServer.start(); CountDownLatch responseLatch = new CountDownLatch(1); getWebClient().build().get().retrieve().toBodilessEntity().subscribe((response) -> responseLatch.countDown()); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown();   Mono<ResponseEntity<Void>> unconnectableRequest1 = getWebClient().build().get().retrieve().toBodilessEntity(); Mono<ResponseEntity<Void>> unconnectableRequest2 = getWebClient().build().get().retrieve().toBodilessEntity(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); responseLatch.await(5, TimeUnit.SECONDS); this.webServer.stop(); List<Object> results = new ArrayList<>(); try { results.add(unconnectableRequest1.block()); } catch (Exception ex) { results.add(ex); } try { results.add(unconnectableRequest2.block()); } catch (Exception ex) { results.add(ex); } assertThat(results).anySatisfy((result) -> assertThat(result).isInstanceOf(Exception.class));",
        "ins1PreCode":"this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); getWebClient().build().get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown();   CountDownLatch responseLatch = new CountDownLatch(1); AtomicReference<Throwable> errorReference = new AtomicReference<>(); getWebClient().build().get().retrieve().toBodilessEntity().doOnSuccess((response) -> responseLatch.countDown()) .doOnError(errorReference::set).subscribe(); getWebClient().build().get().retrieve().toBodilessEntity().doOnSuccess((response) -> responseLatch.countDown()) .doOnError(errorReference::set).subscribe(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); blockingHandler.completeOne(); responseLatch.await(5, TimeUnit.SECONDS); this.webServer.stop(); Throwable error = await().atMost(Duration.ofSeconds(30)).until(errorReference::get, (ex) -> ex != null); assertThat(error).isInstanceOf(IOException.class);",
        "ins2PreCode":"void whenServerIsShuttingDownGracefullyThenNewConnectionsCannotBeMade() throws Exception { NettyReactiveWebServerFactory factory = getFactory(); Shutdown shutdown = new Shutdown(); shutdown.setGracePeriod(Duration.ofSeconds(5)); factory.setShutdown(shutdown); BlockingHandler blockingHandler = new BlockingHandler(); this.webServer = factory.getWebServer(blockingHandler); this.webServer.start(); WebClient webClient = getWebClient().build(); webClient.get().retrieve().toBodilessEntity().subscribe(); blockingHandler.awaitQueue(); Future<Boolean> shutdownResult = initiateGracefulShutdown(); AtomicReference<Throwable> errorReference = new AtomicReference<>(); webClient.get().retrieve().toBodilessEntity().doOnError(errorReference::set).subscribe(); assertThat(shutdownResult.get()).isEqualTo(false); blockingHandler.completeOne(); this.webServer.stop(); assertThat(errorReference.get()).hasCauseInstanceOf(ConnectException.class);",
        "label":0
    },
    {
        "ins1CurCode":" databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins1PreCode":"databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());  try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins2PreCode":" databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "label":0
    },
    {
        "ins1CurCode":"if ((0x3ff001000000000L & l) != 0L) { if (kind > 57) kind = 57; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 57) kind = 57; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 57) kind = 57; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 57) kind = 57; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 56) kind = 56; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 56) kind = 56; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 57) kind = 57; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 56) kind = 56; jjCheckNAdd(28); break; case 29: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 57) kind = 57; jjCheckNAdd(29);",
        "ins1PreCode":"else if ((0x1800000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 56) kind = 56; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(28);",
        "ins2PreCode":"else if ((0x1800000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 56) kind = 56; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(28);",
        "label":1
    },
    {
        "ins1CurCode":"void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() { ",
        "ins1PreCode":"public void originTrackedMapPropertySourceKeyAdditionInvalidatesCache() { ",
        "ins2PreCode":"public void readOnlyOriginTrackedMapPropertySourceKeyAdditionDoesNotInvalidateCache() { ",
        "label":1
    },
    {
        "ins1CurCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockGraphManager.keyType);  switch (otype) {  case LockGraphManager.typeWait: dbStat.setInt(1, (int) options.get(sidWait)); break;  case LockGraphManager.typeHold: dbStat.setInt(1, (int) options.get(sidHold));",
        "ins1PreCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockManagerViewer.keyType);  switch (otype) {  case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(sidWait)); break;  case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(sidHold));",
        "ins2PreCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockManagerViewer.keyType);  switch(otype) { case LockManagerViewer.typeWait: dbStat.setBigDecimal(1, new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidWait))); break; case LockManagerViewer.typeHold: dbStat.setBigDecimal(1,  new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidHold)));",
        "label":1
    },
    {
        "ins1CurCode":"};  TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"};  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"};  TestSubscriber<Integer> ts = new TestSubscriber<Integer>(5); ",
        "label":1
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_predecessors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_successors_returnsInConnectingEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":"void testcrossrefUniversity() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry() .withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoeping\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"[auth]\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins1PreCode":"void testcrossrefUniversity() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoeping\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins2PreCode":"void testcrossrefDepartment() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, Department of Electrical Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingEE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "label":1
    },
    {
        "ins1CurCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); ",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); ",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\"); ",
        "label":1
    },
    {
        "ins1CurCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "ins1PreCode":"throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input stream missing\" ); }",
        "ins2PreCode":"throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input reader missing\" ); }",
        "label":1
    },
    {
        "ins1CurCode":"if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 4L * rowId, count * 4L); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 4L * rowId; for (int i = 0; i < count; ++i, offset += 4, srcOffset += 4) {",
        "ins1PreCode":"if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 4 * rowId, count * 4); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 4 * rowId; for (int i = 0; i < count; ++i, offset += 4, srcOffset += 4) {",
        "ins2PreCode":"if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 8 * rowId, count * 8); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 8 * rowId; for (int i = 0; i < count; ++i, offset += 8, srcOffset += 8) {",
        "label":1
    },
    {
        "ins1CurCode":"void completeBeginningOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); database.insertEntry(entry);  Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"test\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1PreCode":"public void completeBeginningOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"test\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"public void completeLowercaseValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testvalue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"synchronized boolean asyncDispatch() { if (!ContainerThreadMarker.isContainerThread() && state == AsyncState.STARTING) { state = AsyncState.DISPATCH_PENDING; return false; }  clearNonBlockingListeners(); boolean triggerDispatch = false; if (state == AsyncState.STARTING || state == AsyncState.MUST_ERROR) {   state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state == AsyncState.DISPATCH_PENDING) { state = AsyncState.DISPATCHING;       triggerDispatch = true; } else if (state == AsyncState.READ_WRITE_OP || state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) {           state = AsyncState.DISPATCHING; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncDispatch()\", state)); } return triggerDispatch;",
        "ins1PreCode":"public synchronized boolean asyncDispatch() { pauseNonContainerThread(); boolean doDispatch = false; if (state == AsyncState.STARTING || state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) {   state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED) { state = AsyncState.DISPATCHING;       doDispatch = true; } else if (state == AsyncState.READ_WRITE_OP) { state = AsyncState.DISPATCHING;     if (!ContainerThreadMarker.isContainerThread()) { doDispatch = true; } } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncDispatch()\", state)); } return doDispatch;",
        "ins2PreCode":"public synchronized boolean asyncComplete() { pauseNonContainerThread(); clearNonBlockingListeners(); boolean doComplete = false; if (state == AsyncState.STARTING || state == AsyncState.TIMING_OUT || state == AsyncState.ERROR || state == AsyncState.READ_WRITE_OP) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.STARTED) { state = AsyncState.COMPLETING; doComplete = true; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncComplete()\", state)); } return doComplete;",
        "label":0
    },
    {
        "ins1CurCode":"}  return (sb.length() > content.length()) ? sb.toString(): content;",
        "ins1PreCode":"}  return sb.toString();",
        "ins2PreCode":"sb.append(\"&gt;\"); } else if (c == '\\'') { sb.append(\"&#x27;\"); } else if (c == '&') { sb.append(\"&amp;\"); } else if (c == '\"') { sb.append(\"&quot;\"); } else if (c == '/') { sb.append(\"&#x2F;\"); } else { sb.append(c); } }  return sb.toString();",
        "label":0
    },
    {
        "ins1CurCode":"void javaBeanDeprecatedPropertyOnClass() throws IOException { process(org.springframework.boot.configurationsample.simple.DeprecatedProperties.class,",
        "ins1PreCode":"public void javaBeanDeprecatedPropertyOnClass() throws IOException { process(org.springframework.boot.configurationsample.simple.DeprecatedProperties.class,",
        "ins2PreCode":"public void lombokDeprecatedPropertyOnClass() throws IOException { process(org.springframework.boot.configurationsample.lombok.LombokDeprecatedProperties.class,",
        "label":1
    },
    {
        "ins1CurCode":"try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assertions.assertTrue(blog instanceof Proxy); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins1PreCode":"try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assert.assertTrue(blog instanceof Proxy); assertEquals(\"Jim Business\", blog.getTitle());",
        "ins2PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingSubSelects() { try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelect\", 1); assertEquals(\"Jim Business\", blog.getTitle()); assertEquals(2, blog.getPosts().size()); assertEquals(\"Corn nuts\", blog.getPosts().get(0).getSubject()); assertEquals(101, blog.getAuthor().getId()); assertEquals(\"jim\", blog.getAuthor().getUsername()); }",
        "label":0
    },
    {
        "ins1CurCode":"AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<>(4); queue = q;",
        "ins1PreCode":"AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(4); queue = q;",
        "ins2PreCode":"AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(4); queue = q;",
        "label":1
    },
    {
        "ins1CurCode":"public void testBoolean() throws Exception { JsonProcessor jsonProcessor = new JsonProcessor(\"tag\", null, \"field\", \"target_field\", false); Map<String, Object> document = new HashMap<>();",
        "ins1PreCode":"public void testBoolean() throws Exception { JsonProcessor jsonProcessor = new JsonProcessor(\"tag\", \"field\", \"target_field\", false); Map<String, Object> document = new HashMap<>();",
        "ins2PreCode":"public void testArray() throws Exception { JsonProcessor jsonProcessor = new JsonProcessor(\"tag\", \"field\", \"target_field\", false); Map<String, Object> document = new HashMap<>();",
        "label":1
    },
    {
        "ins1CurCode":".observeOn(Schedulers.computation()) .test() .awaitDone(20, TimeUnit.SECONDS) .assertNoErrors()",
        "ins1PreCode":".observeOn(Schedulers.computation()) .test() .awaitDone(5, TimeUnit.SECONDS) .assertNoErrors()",
        "ins2PreCode":".observeOn(Schedulers.computation()) .test() .awaitDone(5, TimeUnit.SECONDS) .assertNoErrors()",
        "label":1
    },
    {
        "ins1CurCode":"}  System.arraycopy(buff, 0, tmp, 0, end); buff = tmp;",
        "ins1PreCode":"}  System.arraycopy(buff, start, tmp, start, end-start); buff = tmp;",
        "ins2PreCode":"private void makeSpace(int count) { byte[] tmp = null;  int newSize; int desiredSize=end + count;   if( limit > 0 && desiredSize > limit) { desiredSize=limit; }  if( buff==null ) { if( desiredSize < 256 ) desiredSize=256; buff=new byte[desiredSize]; }    if( desiredSize <= buff.length ) { return; }  if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit >0 && newSize > limit ) newSize=limit; tmp=new byte[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) newSize=limit; tmp=new byte[newSize]; }  System.arraycopy(buff, start, tmp, 0, end-start); buff = tmp; tmp = null; end=end-start; start=0;",
        "label":0
    },
    {
        "ins1CurCode":"throws ELException { Object obj = this.children[0].getValue(ctx); Boolean b = coerceToBoolean(obj, true); if (b.booleanValue()) { return b; } obj = this.children[1].getValue(ctx); b = coerceToBoolean(obj, true); return b;",
        "ins1PreCode":"throws ELException { Object obj = this.children[0].getValue(ctx); Boolean b = coerceToBoolean(obj); if (b.booleanValue()) { return b; } obj = this.children[1].getValue(ctx); b = coerceToBoolean(obj); return b;",
        "ins2PreCode":"throws ELException { Object obj = children[0].getValue(ctx); Boolean b = coerceToBoolean(obj); if (!b.booleanValue()) { return b; } obj = children[1].getValue(ctx); b = coerceToBoolean(obj); return b;",
        "label":1
    },
    {
        "ins1CurCode":"public void testUpgradeInternal() throws Exception { Assume.assumeTrue( \"Only supported on NIO X\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Nio\")); ",
        "ins1PreCode":"public void testUpgradeInternal() throws Exception { Assume.assumeTrue( \"Only supported on NIO 2\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Nio2\")); ",
        "ins2PreCode":"private void doTestMessages ( Class<? extends HttpUpgradeHandler> upgradeHandlerClass) throws Exception { UpgradeConnection uc = doUpgrade(upgradeHandlerClass); PrintWriter pw = new PrintWriter(uc.getWriter()); BufferedReader reader = uc.getReader();  pw.println(MESSAGE); pw.flush();  Thread.sleep(500);  pw.println(MESSAGE); pw.flush();  uc.shutdownOutput();    String response = reader.readLine(); Assert.assertEquals(MESSAGE, response); response = reader.readLine(); Assert.assertEquals(MESSAGE, response);  uc.shutdownInput(); pw.close();",
        "label":0
    },
    {
        "ins1CurCode":"ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/test/'singlequote.jsp\"); Assert.assertEquals(\"<p>'singlequote.jsp in resources.jar</p>\", bc.toString());   bc = getUrl(\"http://localhost:\" + getPort() + \"/test/'singlequote2.jsp\"); Assert.assertEquals(\"<p>'singlequote2.jsp in file system</p>\", bc.toString());",
        "ins1PreCode":"ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/test/'singlequote.jsp\"); assertEquals(\"<p>'singlequote.jsp in resources.jar</p>\", bc.toString());   bc = getUrl(\"http://localhost:\" + getPort() + \"/test/'singlequote2.jsp\"); assertEquals(\"<p>'singlequote2.jsp in file system</p>\", bc.toString());",
        "ins2PreCode":"ByteChunk bc = getUrl(\"http://localhost:\" + getPort() + \"/test/'singlequote.jsp\"); assertEquals(\"<p>'singlequote.jsp in resources.jar</p>\", bc.toString());   bc = getUrl(\"http://localhost:\" + getPort() + \"/test/'singlequote2.jsp\"); assertEquals(\"<p>'singlequote2.jsp in file system</p>\", bc.toString());",
        "label":1
    },
    {
        "ins1CurCode":" final CLICommandInvoker.Result result = command .authorizedTo(Item.READ, Item.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "ins1PreCode":" final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"never_created\");",
        "ins2PreCode":"public void disconnectNodeShouldFailIfNodeDoesNotExist() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Computer.DISCONNECT, Jenkins.READ) .invokeWithArgs(\"never_created\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No such agent \\\"never_created\\\" exists.\")); assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "label":0
    },
    {
        "ins1CurCode":"DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(String.format(\"<root>%n  <emptyElement />%n</root>%n\"), sw.toString());",
        "ins1PreCode":"DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(\"<root>\" + StringUtils.LINE_SEP  + \"  <emptyElement />\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "ins2PreCode":"DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(\"<root>\" + StringUtils.LINE_SEP + \"  <cdataElement><![CDATA[content]]></cdataElement>\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "label":0
    },
    {
        "ins1CurCode":"public void zipIterable2IteratorNull() { Observable.zip(new Iterable<Observable<Object>>() { @Override",
        "ins1PreCode":"public void zipIterable2IteratorNull() { Observable.zipIterable(new Iterable<Observable<Object>>() { @Override",
        "ins2PreCode":"public void zipIterableIteratorNull() { Observable.zip(new Iterable<Observable<Object>>() { @Override public Iterator<Observable<Object>> iterator() { return null; } }, new Function<Object[], Object>() { @Override public Object apply(Object[] v) { return 1; } }).blockingLast();",
        "label":0
    },
    {
        "ins1CurCode":"}; } for (Thread value : threads) { value.start(); } for (Thread thread : threads) { thread.join(); }",
        "ins1PreCode":"}; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} ",
        "ins2PreCode":"}; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} ",
        "label":1
    },
    {
        "ins1CurCode":"this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).toIterable() .hasOnlyElementsOfType(TestServlet.class);",
        "ins1PreCode":"this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).hasOnlyElementsOfType(TestServlet.class);",
        "ins2PreCode":"this.context.getBeanFactory()); assertThat(initializerBeans.size()).isEqualTo(1); assertThat(initializerBeans.iterator()).hasOnlyElementsOfType(TestFilter.class);",
        "label":1
    },
    {
        "ins1CurCode":" Map<Object, PluginExecution> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 );  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); merged.put( key, element.clone() ); }  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null ) { mergePluginExecution( element, existing, sourceDominant, context ); } merged.put( key, element ); }  target.setExecutions( new ArrayList<>( merged.values() ) ); }",
        "ins1PreCode":" Map<Object, PluginExecution> merged = new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); merged.put( key, element.clone() ); }  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null ) { mergePluginExecution( element, existing, sourceDominant, context ); } merged.put( key, element ); }  target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) ); }",
        "ins2PreCode":"List<PluginExecution> tgt = target.getExecutions(); Map<Object, PluginExecution> merged = new LinkedHashMap<Object, PluginExecution>( ( src.size() + tgt.size() ) * 2 );  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); }  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null ) { mergePluginExecution( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setExecutions( new ArrayList<PluginExecution>( merged.values() ) ); }",
        "label":1
    },
    {
        "ins1CurCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return Flowable.fromArray(source1, source2, source3, source4).concatMapSingleDelayError(Functions.identity(), false);",
        "ins1PreCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return concat(Flowable.fromArray(source1, source2, source3, source4));",
        "ins2PreCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return merge(Flowable.fromArray(source1, source2, source3, source4));",
        "label":0
    },
    {
        "ins1CurCode":"List<Dependency> list = new ArrayList<>( artifacts.size() );  for ( Artifact a : getArtifacts() ) {  if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ) { Dependency dependency = new Dependency();  dependency.setArtifactId( a.getArtifactId() ); dependency.setGroupId( a.getGroupId() ); dependency.setVersion( a.getVersion() ); dependency.setScope( a.getScope() ); dependency.setType( a.getType() ); dependency.setClassifier( a.getClassifier() );  list.add( dependency ); } } return Collections.unmodifiableList( list );",
        "ins1PreCode":"List<Dependency> list = new ArrayList<>( artifacts.size() );  for ( Artifact a : getArtifacts()  ) {  if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ) { Dependency dependency = new Dependency();  dependency.setArtifactId( a.getArtifactId() ); dependency.setGroupId( a.getGroupId() ); dependency.setVersion( a.getVersion() ); dependency.setScope( a.getScope() ); dependency.setType( a.getType() ); dependency.setClassifier( a.getClassifier() );  list.add( dependency ); } } return list;",
        "ins2PreCode":"} } return list;",
        "label":1
    },
    {
        "ins1CurCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtils.writePaint(this.paint, stream); SerialUtils.writePaint(this.backgroundPaint, stream); SerialUtils.writePaint(this.outlinePaint, stream); SerialUtils.writeStroke(this.outlineStroke, stream);",
        "ins1PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.paint, stream); SerialUtilities.writePaint(this.backgroundPaint, stream); SerialUtilities.writePaint(this.outlinePaint, stream); SerialUtilities.writeStroke(this.outlineStroke, stream);",
        "ins2PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.dialBackgroundPaint, stream); SerialUtilities.writePaint(this.dialOutlinePaint, stream); SerialUtilities.writePaint(this.needlePaint, stream); SerialUtilities.writePaint(this.valuePaint, stream); SerialUtilities.writePaint(this.tickPaint, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "label":0
    },
    {
        "ins1CurCode":"ssl.setKeyStoreProvider(\"com.example.KeyStoreProvider\"); SslServerCustomizer customizer = new SslServerCustomizer(ssl, null, null); assertThatIllegalStateException() .isThrownBy(() -> customizer.getKeyManagerFactory(ssl, null)) .withCauseInstanceOf(NoSuchProviderException.class) .withMessageContaining(\"com.example.KeyStoreProvider\");",
        "ins1PreCode":"ssl.setKeyStoreProvider(\"com.example.KeyStoreProvider\"); SslServerCustomizer customizer = new SslServerCustomizer(ssl, null, null); try { customizer.getKeyManagerFactory(ssl, null); fail(); } catch (IllegalStateException ex) { Throwable cause = ex.getCause(); assertThat(cause).isInstanceOf(NoSuchProviderException.class); assertThat(cause).hasMessageContaining(\"com.example.KeyStoreProvider\"); }",
        "ins2PreCode":"ssl.setTrustStoreProvider(\"com.example.TrustStoreProvider\"); SslServerCustomizer customizer = new SslServerCustomizer(ssl, null, null); try { customizer.getTrustManagerFactory(ssl, null); fail(); } catch (IllegalStateException ex) { Throwable cause = ex.getCause(); assertThat(cause).isInstanceOf(NoSuchProviderException.class); assertThat(cause).hasMessageContaining(\"com.example.TrustStoreProvider\"); }",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> concatArray(@NonNull Publisher<? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static <T> Flowable<T> concatArray(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "ins2PreCode":"public static <T> Flowable<T> concatArrayDelayError(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\");",
        "label":1
    },
    {
        "ins1CurCode":"void testMaxFileSizePropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment();",
        "ins1PreCode":"public void testMaxFileSizePropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment();",
        "ins2PreCode":"public void testTotalSizeCapPropertyWithXmlConfiguration() { String expectedSize = \"101 MB\";",
        "label":1
    },
    {
        "ins1CurCode":"ArrayList toBeRemoved = new ArrayList(); for (Object o : objects) { if (!elements.contains(o) && !(isClearable     && (\"\".equals(o) || CLEARED.equals(o)))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements);  if (isClearable && !elements.contains(CLEARED)) { addElement(CLEARED); }",
        "ins1PreCode":"ArrayList toBeRemoved = new ArrayList(); for (Object o : objects) { if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements);  if (!objects.contains(selectedObject)) { selectedObject = null; } if (isClearable && !elements.contains(\"\")) { addElement(\"\"); }",
        "ins2PreCode":"protected void setElements(Collection elements) { if (elements != null) { ArrayList toBeRemoved = new ArrayList(); for (int i = 0; i < objects.size(); i++) { Object o = objects.get(i); if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements);  if (!objects.contains(selectedObject)) { selectedObject = null; } if (isClearable && !elements.contains(\"\")) { addElement(\"\"); } } else { throw new IllegalArgumentException(\"In setElements: may not set \" + \"elements to null collection\"); }",
        "label":0
    },
    {
        "ins1CurCode":"public static Method getWriteMethod(Class<?> beanClass, String prop) throws JasperException { Method method = null; Class<?> type = null; try {",
        "ins1PreCode":"public static Method getWriteMethod(Class beanClass, String prop) throws JasperException { Method method = null; Class type = null; try {",
        "ins2PreCode":"public static Method getReadMethod(Class beanClass, String prop) throws JasperException {  Method method = null; Class type = null; try {",
        "label":1
    },
    {
        "ins1CurCode":"public void ofNameWhenDotOnAssociative() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.bar\");",
        "ins1PreCode":"public void ofNameWhenDotOnAssociative() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.bar\");",
        "ins2PreCode":"public void ofNameWhenDotAndAssociative() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.[bar]\");",
        "label":1
    },
    {
        "ins1CurCode":"public void filterWhenIoExceptionThrownShouldRecordTimer() { ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")).build(); ExchangeFunction errorExchange = (r) -> Mono.error(new IOException()); this.filterFunction.filter(request, errorExchange) .onErrorResume(IOException.class, (t) -> Mono.empty()).block(); assertThat( this.registry .get(\"http.client.requests\").tags(\"method\", \"GET\", \"uri\", \"/projects/spring-boot\", \"status\", \"IO_ERROR\") .timer().count()).isEqualTo(1);",
        "ins1PreCode":"public void filterWhenIoExceptionThrownShouldRecordTimer() { ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")) .build(); ExchangeFunction errorExchange = r -> Mono.error(new IOException()); this.filterFunction.filter(request, errorExchange) .onErrorResume(IOException.class, t -> Mono.empty()).block(); assertThat(this.registry.get(\"http.client.requests\") .tags(\"method\", \"GET\", \"uri\", \"/projects/spring-boot\", \"status\", \"IO_ERROR\").timer() .count()).isEqualTo(1);",
        "ins2PreCode":"public void filterWhenExceptionThrownShouldRecordTimer() { ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")) .build(); ExchangeFunction exchange = r -> Mono.error(new IllegalArgumentException()); this.filterFunction.filter(request, exchange) .onErrorResume(IllegalArgumentException.class, t -> Mono.empty()).block(); assertThat(this.registry.get(\"http.client.requests\") .tags(\"method\", \"GET\", \"uri\", \"/projects/spring-boot\", \"status\", \"CLIENT_ERROR\").timer() .count()).isEqualTo(1);",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void run() { cd.add(Disposable.empty()); }",
        "ins1PreCode":"@Override public void run() { cd.add(Disposables.empty()); }",
        "ins2PreCode":"@Override public void run() { cd.addAll(Disposables.empty()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testdefTocharImplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 's'; char b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = d;\"));",
        "ins1PreCode":"public void testdefTocharImplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; char b = d;\"));",
        "ins2PreCode":"public void testdefTobooleanExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; boolean b = (boolean)d;\")); assertEquals(true, exec(\"def d = true; boolean b = (boolean)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (short)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (char)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (int)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (long)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (float)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (double)0; boolean b = (boolean)d;\")); assertEquals(false, exec(\"def d = Boolean.valueOf(false); boolean b = (boolean)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Byte.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Short.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Character.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Integer.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Long.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Float.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = Double.valueOf(0); boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); boolean b = (boolean)d;\"));",
        "label":0
    },
    {
        "ins1CurCode":"public void shouldGetOrderDetailsEachHavingAnOrderHeader() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins1PreCode":"public void shouldGetOrderDetailsEachHavingAnOrderHeader() throws IOException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<OrderDetail> orderDetails = mapper.getOrderDetailsWithHeaders();    Assert.assertEquals(6, orderDetails.size());    for(OrderDetail orderDetail : orderDetails){ Assert.assertNotNull(orderDetail.getOrderHeader()); }  } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldGetOrderDetailsEachHavingAnOrderHeaderAnnotationBased() throws IOException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<OrderDetail> orderDetails = mapper.getOrderDetailsWithHeadersAnnotationBased();    Assert.assertEquals(6, orderDetails.size());    for(OrderDetail orderDetail : orderDetails){ Assert.assertNotNull(orderDetail.getOrderHeader()); }  } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.log(Level.FINE, \"toDoItemsChanged\"); List<ToDoItem> items = tde.getToDoItemList();",
        "ins1PreCode":"public void toDoItemsChanged(ToDoListEvent tde) { LOG.debug(\"toDoItemsChanged\"); List<ToDoItem> items = tde.getToDoItemList();",
        "ins2PreCode":"public void toDoItemsAdded(ToDoListEvent tde) { LOG.debug(\"toDoItemAdded\"); List<ToDoItem> items = tde.getToDoItemList();",
        "label":1
    },
    {
        "ins1CurCode":"UnicastSubject(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<>(capacityHint); this.onTerminate = new AtomicReference<>(onTerminate); this.delayError = delayError;",
        "ins1PreCode":"UnicastSubject(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<>(Objects.requireNonNull(onTerminate, \"onTerminate\")); this.delayError = delayError;",
        "ins2PreCode":"UnicastProcessor(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<>(Objects.requireNonNull(onTerminate, \"onTerminate\")); this.delayError = delayError;",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals( TestMap.EnumValue.BAR.getNumber(), testMapOrBuilder.getInt32ToEnumFieldValueOrDefault(2, -1)); assertEquals(-1, testMapOrBuilder.getInt32ToEnumFieldValueOrDefault(-1000, -1));  assertEquals( MessageValue.newBuilder().setValue(11).build(), testMapOrBuilder.getInt32ToMessageFieldOrDefault(1, null));",
        "ins1PreCode":"assertEquals( TestMap.EnumValue.BAR.getNumber(), (int) testMapOrBuilder.getInt32ToEnumFieldValueOrDefault(2, -1)); assertEquals(-1, testMapOrBuilder.getInt32ToEnumFieldValueOrDefault(-1000, -1));  assertEquals(MessageValue.newBuilder().setValue(11).build(), testMapOrBuilder.getInt32ToMessageFieldOrDefault(1, null));",
        "ins2PreCode":"public void doTestGetOrDefault(TestMapOrBuilder testMapOrBuilder) { assertEquals(11, testMapOrBuilder.getInt32ToInt32FieldOrDefault(1, -11)); assertEquals(-11, testMapOrBuilder.getInt32ToInt32FieldOrDefault(-1, -11));  assertEquals(\"11\", testMapOrBuilder.getInt32ToStringFieldOrDefault(1, \"-11\")); assertNull(\"-11\", testMapOrBuilder.getInt32ToStringFieldOrDefault(-1, null));  assertEquals(TestUtil.toBytes(\"11\"), testMapOrBuilder.getInt32ToBytesFieldOrDefault(1, null)); assertNull(testMapOrBuilder.getInt32ToBytesFieldOrDefault(-1, null));  assertEquals(TestMap.EnumValue.FOO, testMapOrBuilder.getInt32ToEnumFieldOrDefault(1, null)); assertNull(testMapOrBuilder.getInt32ToEnumFieldOrDefault(-1, null));  assertEquals(MessageValue.newBuilder().setValue(11).build(), testMapOrBuilder.getInt32ToMessageFieldOrDefault(1, null)); assertNull(testMapOrBuilder.getInt32ToMessageFieldOrDefault(-1, null));  assertEquals(11, testMapOrBuilder.getStringToInt32FieldOrDefault(\"1\", -11)); assertEquals(-11, testMapOrBuilder.getStringToInt32FieldOrDefault(\"-1\", -11));  try { testMapOrBuilder.getStringToInt32FieldOrDefault(null, -11); fail(); } catch (NullPointerException e) {  }",
        "label":0
    },
    {
        "ins1CurCode":"vehicleBuilder.getWheelBuilder(i).setRadius(5).setWidth(i + 10); } Engine.Builder engineBuilder = vehicleBuilder.getEngineBuilder().setLiters(20);  vehicle = vehicleBuilder.build(); for (int i = 0; i < 4; i++) { Wheel wheel = vehicle.getWheel(i); assertEquals(5, wheel.getRadius()); assertEquals(i + 10, wheel.getWidth()); } assertEquals(20, vehicle.getEngine().getLiters()); assertTrue(vehicle.hasEngine());  engineBuilder.setLiters(50); assertEquals(50, vehicleBuilder.getEngine().getLiters());",
        "ins1PreCode":"vehicleBuilder.getWheelBuilder(i).setRadius(5).setWidth(i + 10); } vehicleBuilder.getEngineBuilder().setLiters(20); ",
        "ins2PreCode":"public void testMessagesAndBuilders() { Vehicle.Builder vehicleBuilder = Vehicle.newBuilder(); vehicleBuilder.addWheelBuilder() .setRadius(4) .setWidth(1); vehicleBuilder.addWheelBuilder() .setRadius(4) .setWidth(2); vehicleBuilder.addWheelBuilder() .setRadius(4) .setWidth(3); vehicleBuilder.addWheelBuilder() .setRadius(4) .setWidth(4); vehicleBuilder.getEngineBuilder() .setLiters(10);  Vehicle vehicle = vehicleBuilder.build(); assertEquals(4, vehicle.getWheelCount()); for (int i = 0; i < 4; i++) { Wheel wheel = vehicle.getWheel(i); assertEquals(4, wheel.getRadius()); assertEquals(i + 1, wheel.getWidth()); } assertEquals(10, vehicle.getEngine().getLiters());  for (int i = 0; i < 4; i++) { vehicleBuilder.getWheelBuilder(i) .setRadius(5) .setWidth(i + 10); } vehicleBuilder.getEngineBuilder().setLiters(20);  vehicle = vehicleBuilder.build(); for (int i = 0; i < 4; i++) { Wheel wheel = vehicle.getWheel(i); assertEquals(5, wheel.getRadius()); assertEquals(i + 10, wheel.getWidth()); } assertEquals(20, vehicle.getEngine().getLiters()); assertTrue(vehicle.hasEngine());",
        "label":0
    },
    {
        "ins1CurCode":"public void testNoPreserveLastModified() throws Exception { buildRule.executeTarget(\"lastModifiedSetup\"); File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5))); long ts1 = testFile.lastModified(); buildRule.executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(buildRule.getOutputDir(), \"test.txt\").lastModified());",
        "ins1PreCode":"public void testNoPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(getOutputDir(), \"test.txt\").lastModified());",
        "ins2PreCode":"public void testPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testPreserve\"); assertTrue(ts1 == new File(getOutputDir(), \"test.txt\").lastModified());",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { CustomXYURLGenerator g1 = new CustomXYURLGenerator(); List<String> u1 = new ArrayList<>(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\"); g1.addURLSeries(u1); CustomXYURLGenerator g2 = (CustomXYURLGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));   List<String> u2 = new ArrayList<>(); u2.add(\"URL XXX\");",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CustomXYURLGenerator g1 = new CustomXYURLGenerator(); List u1 = new java.util.ArrayList(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\"); g1.addURLSeries(u1); CustomXYURLGenerator g2 = (CustomXYURLGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));   List u2 = new java.util.ArrayList(); u2.add(\"URL XXX\");",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CustomCategoryURLGenerator g1 = new CustomCategoryURLGenerator(); List u1 = new java.util.ArrayList(); u1.add(\"URL A1\"); u1.add(\"URL A2\"); u1.add(\"URL A3\"); g1.addURLSeries(u1); CustomCategoryURLGenerator g2 = (CustomCategoryURLGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass()); assertTrue(g1.equals(g2));   List u2 = new java.util.ArrayList(); u2.add(\"URL XXX\");",
        "label":1
    },
    {
        "ins1CurCode":";  assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: No view named never_created inside view Jenkins\"));",
        "ins1PreCode":";  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"No view named never_created inside view Jenkins\"));",
        "ins2PreCode":";  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"No view named never_created inside view Jenkins\"));",
        "label":1
    },
    {
        "ins1CurCode":"new CompressStream(), false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] );",
        "ins1PreCode":"new CompressStream(), false, (ShuffleWriteMetrics) args[4] );",
        "ins2PreCode":"new CompressStream(), false, (ShuffleWriteMetrics) args[4] );",
        "label":1
    },
    {
        "ins1CurCode":"public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) { Objects.requireNonNull(unit, \"unit is null\"); Objects.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins1PreCode":"public final Observable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"public final Flowable<T> skipLast(long time, TimeUnit unit, Scheduler scheduler, boolean delayError, int bufferSize) { ObjectHelper.requireNonNull(unit, \"unit is null\"); ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":1
    },
    {
        "ins1CurCode":"deleteContentTypeHeader(request);  Page p = rule.createWebClient() .withThrowExceptionOnFailingStatusCode(false) .getPage(request); assertEquals(\"Creating job from copy should succeed.\", HttpURLConnection.HTTP_OK, p.getWebResponse().getStatusCode());",
        "ins1PreCode":"WebRequest request = new WebRequest(apiURL, HttpMethod.POST); deleteContentTypeHeader(request); int result = ERROR_PRESET; try { result = rule.createWebClient() .getPage(request).getWebResponse().getStatusCode(); } catch (FailingHttpStatusCodeException e) { result = e.getResponse().getStatusCode(); }  assertEquals(\"Creating job from copy should succeed.\", 200, result);",
        "ins2PreCode":"WebRequest request = new WebRequest(apiURL, HttpMethod.POST); deleteContentTypeHeader(request); int result = ERROR_PRESET; try { result = rule.createWebClient() .getPage(request).getWebResponse().getStatusCode(); } catch (FailingHttpStatusCodeException e) { result = e.getResponse().getStatusCode(); }  assertEquals(\"Creating job from copy should fail.\", 400, result); assertThat(rule.jenkins.getItem(\"newJob\"), nullValue());",
        "label":1
    },
    {
        "ins1CurCode":"public void assertResult() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void assertResult() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void assertResult() { TestObserver<Integer> to = TestObserver.create();  to.onSubscribe(Disposable.empty());  to.onComplete();  to.assertResult();  try { to.assertResult(1); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError ex) {  }  to.onNext(1);  to.assertResult(1);  try { to.assertResult(2); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError ex) {  }  try { to.assertResult(); throw new RuntimeException(\"Should have thrown\"); } catch (AssertionError ex) {  } ",
        "label":0
    },
    {
        "ins1CurCode":"public void assertNeverAtMatchingPredicate() { assertThrows(AssertionError.class, () -> { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1PreCode":"ts.assertValues(1, 2);  thrown.expect(AssertionError.class); ",
        "ins2PreCode":"public void assertNeverAtNotMatchingPredicate() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();  Flowable.just(2, 3).subscribe(ts);  ts.assertNever(new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; } });",
        "label":0
    },
    {
        "ins1CurCode":"  Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers);",
        "ins1PreCode":"  Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers);",
        "ins2PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "label":0
    },
    {
        "ins1CurCode":"File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - FileUtils.getFileUtils().getFileTimestampGranularity() * 5)); long ts1 = testFile.lastModified();",
        "ins1PreCode":"File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5))); long ts1 = testFile.lastModified();",
        "ins2PreCode":"File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5))); long ts1 = testFile.lastModified();buildRule.executeTarget(\"testPreserve\"); assertTrue(ts1 == new File(buildRule.getOutputDir(), \"test.txt\").lastModified());",
        "label":1
    },
    {
        "ins1CurCode":" try { FileUtils.newFileUtils().rename(newwasJarFile, websphereJarFile); } catch (IOException renameException) { log(renameException.getMessage(), Project.MSG_WARN); rebuild = true;",
        "ins1PreCode":"}  websphereJarFile.delete(); newwasJarFile.renameTo(websphereJarFile); if (!websphereJarFile.exists()) { rebuild = true;",
        "ins2PreCode":"}  weblogicJarFile.delete(); newWLJarFile.renameTo(weblogicJarFile); if (!weblogicJarFile.exists()) { rebuild = true;",
        "label":1
    },
    {
        "ins1CurCode":"endLine = input_stream.getEndLine(); endColumn = input_stream.getEndColumn(); t = Token.newToken(jjmatchedKind, curTokenImage); ",
        "ins1PreCode":"endLine = input_stream.getEndLine(); endColumn = input_stream.getEndColumn(); t = Token.newToken(jjmatchedKind); t.kind = jjmatchedKind; t.image = curTokenImage; ",
        "ins2PreCode":"protected Token jjFillToken() { final Token t; final String curTokenImage; final int beginLine; final int endLine; final int beginColumn; final int endColumn; String im = jjstrLiteralImages[jjmatchedKind]; curTokenImage = (im == null) ? input_stream.GetImage() : im; beginLine = input_stream.getBeginLine(); beginColumn = input_stream.getBeginColumn(); endLine = input_stream.getEndLine(); endColumn = input_stream.getEndColumn(); t = Token.newToken(jjmatchedKind, curTokenImage);  t.beginLine = beginLine; t.endLine = endLine; t.beginColumn = beginColumn; t.endColumn = endColumn;  return t;",
        "label":0
    },
    {
        "ins1CurCode":"public void testAPIExample() throws InterruptedException { final DummyMailServer testMailServer = DummyMailServer.startMailServer(this.local); final ClientThread testMailClient; try { testMailClient = new ClientThread(testMailServer.getPort());  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.cc(\"cc1@you.com\"); testMailClient.cc(\"cc2@you.com\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start(); client.join(30 * 1000);  } finally { testMailServer.disconnect(); }",
        "ins1PreCode":"public void testAPIExample() throws InterruptedException { final int port = TEST_PORT + 1; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread(port);  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.cc(\"cc1@you.com\"); testMailClient.cc(\"cc2@you.com\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);",
        "ins2PreCode":"public void testToOnly() throws InterruptedException { final int port = TEST_PORT + 2; ServerThread testMailServer = new ServerThread(port); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread(port);  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage(\"test line 1\\n\" + \"test line 2\");  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);",
        "label":1
    },
    {
        "ins1CurCode":"List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); }",
        "ins1PreCode":"List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { if (cookieHeader.contains(\"name=\")) { assertTrue(cookieHeader.contains(\"name=val?ue\")); }",
        "ins2PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "label":0
    },
    {
        "ins1CurCode":"public void getLoggingConfiguration() { this.loggingSystem.beforeInitialize();",
        "ins1PreCode":"public void getLoggingConfiguration() throws Exception { this.loggingSystem.beforeInitialize();",
        "ins2PreCode":"public void getLoggingConfiguration() throws Exception { this.loggingSystem.beforeInitialize();",
        "label":1
    },
    {
        "ins1CurCode":"} if (rc <= 0) { log.error(sm.getString(\"opensslconf.failedCommand\", name, value, Integer.toString(rc))); result = false; } else if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, Integer.toString(rc))); }",
        "ins1PreCode":"} if (rc <= 0) { log.error(sm.getString(\"opensslconf.failedCommand\", name, value, rc)); result = false; } else if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, rc)); }",
        "ins2PreCode":"} if (rc <= 0) { log.error(sm.getString(\"opensslconf.failedCommand\", name, value, rc)); result = false; } else if (log.isDebugEnabled()) { log.debug(sm.getString(\"opensslconf.resultCommand\", name, value, rc)); } } try { rc = SSLConf.finish(cctx); } catch (UnsatisfiedLinkError e) { log.warn(sm.getString(\"opensslconf.missingOpenSSLConfSupport\"), e); log.error(sm.getString(\"opensslconf.applyFailed\")); return false; } if (rc <= 0) { log.error(sm.getString(\"opensslconf.finishFailed\", rc)); result = false;",
        "label":0
    },
    {
        "ins1CurCode":"public void yamlProfiles() { this.initializer.setSearchNames(\"testprofiles\");",
        "ins1PreCode":"public void yamlProfiles() throws Exception { this.initializer.setSearchNames(\"testprofiles\");",
        "ins2PreCode":"public void yamlTwoProfiles() throws Exception { this.initializer.setSearchNames(\"testprofiles\");",
        "label":1
    },
    {
        "ins1CurCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<>(); map.put(\"name\", \"User1\");",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<String, String>(); map.put(\"name\", \"User1\");",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<String, String>(); map.put(\"name\", \"User1\");",
        "label":1
    },
    {
        "ins1CurCode":"CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { for (Marker value : markers) { CategoryMarker marker = (CategoryMarker) value; r.drawDomainMarker(g2, this, axis, marker, dataArea);",
        "ins1PreCode":"CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { Iterator<Marker> iterator = markers.iterator(); while (iterator.hasNext()) { CategoryMarker marker = (CategoryMarker) iterator.next(); r.drawDomainMarker(g2, this, axis, marker, dataArea);",
        "ins2PreCode":"protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, int index, Layer layer) {  XYItemRenderer r = getRenderer(index); if (r == null) { return; }   if (index >= getDatasetCount()) { return; } Collection<Marker> markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { for (Marker marker : markers) { r.drawRangeMarker(g2, this, axis, marker, dataArea); } }",
        "label":0
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { ScatterRenderer r1 = new ScatterRenderer(); ScatterRenderer r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { ScatterRenderer r1 = new ScatterRenderer(); ScatterRenderer r2 = (ScatterRenderer) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { LineAndShapeRenderer r1 = new LineAndShapeRenderer(); LineAndShapeRenderer r2 = (LineAndShapeRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2)); assertTrue(checkIndependence(r1, r2));",
        "label":0
    },
    {
        "ins1CurCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.NONE); ",
        "ins1PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.NONE); ",
        "ins2PreCode":"List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "label":1
    },
    {
        "ins1CurCode":" assert(inMemSorter != null); if (inMemSorter.numRecords() >= numElementsForSpillThreshold) { logger.info(\"Spilling data because number of spilledRecords crossed the threshold \" + numElementsForSpillThreshold); spill(); }",
        "ins1PreCode":" growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required); ",
        "ins2PreCode":" assert(inMemSorter != null); if (inMemSorter.numRecords() > numElementsForSpillThreshold) { spill();",
        "label":0
    },
    {
        "ins1CurCode":"} else { extracted.getParentFile().mkdirs(); FileOutputStream extractedOutputStream = new FileOutputStream(extracted);",
        "ins1PreCode":"} else { FileOutputStream extractedOutputStream = new FileOutputStream(extracted); StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream);",
        "ins2PreCode":"private void explodeArchive(File archive, File destination) throws IOException { FileSystemUtils.deleteRecursively(destination); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(destination, jarEntry.getName()); if (jarEntry.isDirectory()) { extracted.mkdirs(); } else { FileOutputStream extractedOutputStream = new FileOutputStream(extracted); StreamUtils.copy(jarFile.getInputStream(jarEntry), extractedOutputStream); extractedOutputStream.close(); } } jarFile.close();",
        "label":0
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<?> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "label":1
    },
    {
        "ins1CurCode":"MapperB mapper = sqlSession.getMapper(MapperB.class); User user = mapper.getUser(1); Assertions.assertEquals(Integer.valueOf(1), user.getId()); Assertions.assertEquals(\"User1\", user.getName()); }",
        "ins1PreCode":"MapperB mapper = sqlSession.getMapper(MapperB.class); User user = mapper.getUser(1); Assert.assertEquals(Integer.valueOf(1), user.getId()); Assert.assertEquals(\"User1\", user.getName()); }",
        "ins2PreCode":"MapperB mapper = sqlSession.getMapper(MapperB.class); User user = mapper.getUser(1); Assert.assertEquals(Integer.valueOf(1), user.getId()); Assert.assertEquals(\"User1\", user.getName()); }",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); push(observer, \"one\", 98);",
        "ins1PreCode":"@Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); push(observer, \"one\", 98);",
        "ins2PreCode":"public void timed() { final List<String> list = new ArrayList<String>(); final List<List<String>> lists = new ArrayList<List<String>>();  Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); push(subscriber, \"one\", 98); push(subscriber, \"two\", 99); push(subscriber, \"three\", 99); push(subscriber, \"four\", 101); push(subscriber, \"five\", 102); complete(subscriber, 150); } });  Flowable<Flowable<String>> windowed = source.window(100, TimeUnit.MILLISECONDS, scheduler); windowed.subscribe(observeWindow(list, lists));  scheduler.advanceTimeTo(101, TimeUnit.MILLISECONDS); assertEquals(1, lists.size()); assertEquals(lists.get(0), list(\"one\", \"two\", \"three\"));  scheduler.advanceTimeTo(201, TimeUnit.MILLISECONDS); assertEquals(2, lists.size()); assertEquals(lists.get(1), list(\"four\", \"five\"));",
        "label":0
    },
    {
        "ins1CurCode":"}  Boolean premanagedOptional = DependencyManagerUtils.getPremanagedOptional( node ); if ( premanagedOptional != null && !premanagedOptional.equals( dep.getOptional() ) ) { buffer.append( \" (optionality managed from \" ).append( premanagedOptional ); appendManagementSource( buffer, art, \"optional\" ); buffer.append( ')' );",
        "ins1PreCode":"} } else { buffer.append( project.getGroupId() ); buffer.append( ':' ).append( project.getArtifactId() ); buffer.append( ':' ).append( project.getPackaging() ); buffer.append( ':' ).append( project.getVersion() );",
        "ins2PreCode":"public boolean visitEnter( DependencyNode node ) { StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() ); }  logger.debug( buffer.toString() ); indent += \"   \"; return true;",
        "label":0
    },
    {
        "ins1CurCode":"public void simplePropertyWithOldStyleJdbcTypeAndAttributes() { Map<String, String> result = new ParameterExpression(\"id:VARCHAR, attr1=val1, attr2=val2\"); Assertions.assertEquals(4, result.size()); Assertions.assertEquals(\"id\", result.get(\"property\")); Assertions.assertEquals(\"VARCHAR\", result.get(\"jdbcType\")); Assertions.assertEquals(\"val1\", result.get(\"attr1\")); Assertions.assertEquals(\"val2\", result.get(\"attr2\"));",
        "ins1PreCode":"public void simplePropertyWithOldStyleJdbcTypeAndAttributes() { Map<String, String> result = new ParameterExpression(\"id:VARCHAR, attr1=val1, attr2=val2\"); Assert.assertEquals(4, result.size()); Assert.assertEquals(\"id\", result.get(\"property\")); Assert.assertEquals(\"VARCHAR\", result.get(\"jdbcType\")); Assert.assertEquals(\"val1\", result.get(\"attr1\")); Assert.assertEquals(\"val2\", result.get(\"attr2\"));",
        "ins2PreCode":"public void shouldIgnoreLeadingAndTrailingSpaces() { Map<String, String> result = new ParameterExpression(\" id , jdbcType =  VARCHAR,  attr1 = val1 ,  attr2 = val2 \"); Assert.assertEquals(4, result.size()); Assert.assertEquals(\"id\", result.get(\"property\")); Assert.assertEquals(\"VARCHAR\", result.get(\"jdbcType\")); Assert.assertEquals(\"val1\", result.get(\"attr1\")); Assert.assertEquals(\"val2\", result.get(\"attr2\"));",
        "label":1
    },
    {
        "ins1CurCode":"log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (int i = 0; i < sessions.length; i++) { if (sessions[i]!=null && !sessions[i].isValid()) { expireHere++;",
        "ins1PreCode":"log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (int i = 0; i < sessions.length; i++) { if (!sessions[i].isValid()) { expireHere++;",
        "ins2PreCode":"public void processExpires() {  long timeNow = System.currentTimeMillis(); Session sessions[] = findSessions(); int expireHere = 0 ; if(log.isDebugEnabled()) log.debug(\"Start expire sessions \" + getName() + \" at \" + timeNow + \" sessioncount \" + sessions.length); for (int i = 0; i < sessions.length; i++) { if (!sessions[i].isValid()) { expiredSessions++; expireHere++; } } processPersistenceChecks(); if ((getStore() != null) && (getStore() instanceof StoreBase)) { ((StoreBase) getStore()).processExpires(); }  long timeEnd = System.currentTimeMillis(); if(log.isDebugEnabled()) log.debug(\"End expire sessions \" + getName() + \" processingTime \" + (timeEnd - timeNow) + \" expired sessions: \" + expireHere); processingTime += (timeEnd - timeNow); ",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposable.empty()); observer.onComplete();",
        "ins1PreCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "ins2PreCode":"@Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete();",
        "label":1
    },
    {
        "ins1CurCode":"public static void execute(final DBCExecutionContext context) { TasksJob.runTask(\"Rollback transaction\", monitor -> { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { QMTransactionState txnInfo = QMUtils.getTransactionState(context); try (DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\")) { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } DBeaverNotifications.showNotification( context.getDataSource(), \"rollback\", \"Transaction has been rolled back\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\", DBPMessageType.ERROR, () -> TransactionLogDialog.showDialog(null, context, true)); ",
        "ins1PreCode":"public static void execute(final DBCExecutionContext context) { TasksJob.runTask(\"Rollback transaction\", new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { QMTransactionState txnInfo = QMUtils.getTransactionState(context); try (DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\")) { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } DBeaverNotifications.showNotification( context.getDataSource(), \"rollback\", \"Transaction has been rolled back\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\", DBPMessageType.ERROR); ",
        "ins2PreCode":"\"Transaction has been committed\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\"); }",
        "label":0
    },
    {
        "ins1CurCode":"int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); StringBuilder escapedBuffer = null;  for (int i = 0; i < length; i++) { char c = arrayBuffer[i]; if (c <= HIGHEST_SPECIAL) { char[] escaped = specialCharactersRepresentation[c]; if (escaped != null) {  if (start == 0) { escapedBuffer = new StringBuilder(length + 5); }",
        "ins1PreCode":"int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); StringBuffer escapedBuffer = null;  for (int i = 0; i < length; i++) { char c = arrayBuffer[i]; if (c <= HIGHEST_SPECIAL) { char[] escaped = specialCharactersRepresentation[c]; if (escaped != null) {  if (start == 0) { escapedBuffer = new StringBuffer(length + 5); }",
        "ins2PreCode":"int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); StringBuffer escapedBuffer = null;  for (int i = 0; i < length; i++) { char c = arrayBuffer[i]; if (c <= HIGHEST_SPECIAL) { char[] escaped = specialCharactersRepresentation[c]; if (escaped != null) {  if (start == 0) { escapedBuffer = new StringBuffer(length + 5); }",
        "label":1
    },
    {
        "ins1CurCode":"dataset.add(new BoxAndWhiskerItem(null, 2.0, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins1PreCode":"dataset.add(new BoxAndWhiskerItem(null, 2.0, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"dataset.add(new BoxAndWhiskerItem(1.0, null, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(\"source\" + (j + 1) + \" is null\", ex.getCause().getMessage()); } else { assertEquals(\"combiner is null\", ex.getCause().getMessage()); }",
        "ins1PreCode":"assertEquals(\"source\" + (j + 1) + \" is null\", ex.getCause().getMessage()); } else { assertEquals(\"f is null\", ex.getCause().getMessage()); }",
        "ins2PreCode":"assertEquals(\"source\" + (j + 1) + \" is null\", ex.getCause().getMessage()); } else { assertEquals(\"f is null\", ex.getCause().getMessage()); }",
        "label":0
    },
    {
        "ins1CurCode":"WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); assertThatExceptionOfType(RuntimeException.class) .isThrownBy( webClient.get().uri(\"https://self-signed.badssl.com/\") .exchange()::block) .withCauseInstanceOf(SSLException.class); });",
        "ins1PreCode":"WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); this.thrown.expectCause(instanceOf(SSLException.class)); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange() .block(); });",
        "ins2PreCode":"public void skipSslValidation() { this.contextRunner .withConfiguration( AutoConfigurations.of(HealthEndpointAutoConfiguration.class)) .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\", \"management.cloudfoundry.skip-ssl-validation:true\") .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping( context); Object interceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(interceptor, \"cloudFoundrySecurityService\"); WebClient webClient = (WebClient) ReflectionTestUtils .getField(interceptorSecurityService, \"webClient\"); webClient.get().uri(\"https://self-signed.badssl.com/\").exchange() .block(); });",
        "label":0
    },
    {
        "ins1CurCode":"when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_BIBTEX_LIBRARY_LOCATION); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.of(file)); doReturn(true).when(saveDatabaseAction).saveAs(any()); ",
        "ins1PreCode":"when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_BIBTEX_LIBRARY_LOCATION); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.of(file)); doNothing().when(saveDatabaseAction).saveAs(any()); ",
        "ins2PreCode":"when(preferences.get(JabRefPreferences.WORKING_DIRECTORY)).thenReturn(TEST_BIBTEX_LIBRARY_LOCATION); when(dialogService.showFileSaveDialog(any(FileDialogConfiguration.class))).thenReturn(Optional.empty()); doNothing().when(saveDatabaseAction).saveAs(any()); ",
        "label":1
    },
    {
        "ins1CurCode":"public void test_olderThan_leaving_part_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L); List<ModelObject> itemList = newRuns(1, 10); ",
        "ins1PreCode":"public void test_olderThan_leaving_part_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "ins2PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1CurCode":"public void testCheckoutTimeout() throws Exception { Set<Connection> cons = new HashSet<>(); try { this.datasource.getPoolProperties().setTestWhileIdle(true); this.datasource.getPoolProperties().setTestOnBorrow(false); this.datasource.getPoolProperties().setTestOnReturn(false); this.datasource.getPoolProperties().setValidationInterval(30000); this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(1000); this.datasource.getPoolProperties().setMaxActive(20); this.datasource.getPoolProperties().setMaxWait(3000); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(5); this.datasource.getPoolProperties().setMinEvictableIdleTimeMillis(5000); this.datasource.getPoolProperties().setMinIdle(5); this.datasource.getPoolProperties().setLogAbandoned(true); System.out.println(\"About to test connection pool:\"+datasource); for (int i = 0; i < 21; i++) { long now = System.currentTimeMillis(); cons.add(this.datasource.getConnection()); long delta = System.currentTimeMillis()-now; System.out.println(\"Got connection #\"+i+\" in \"+delta+\" ms.\"); } Assert.fail(); } catch ( Exception x ) {  }finally { Thread.sleep(2000); } for (Connection c : cons) { c.close(); }",
        "ins1PreCode":"for (int i = 0; i < 21; i++) { long now = System.currentTimeMillis(); this.datasource.getConnection(); long delta = System.currentTimeMillis()-now; System.out.println(\"Got connection #\"+i+\" in \"+delta+\" ms.\"); } Assert.assertTrue(false); } catch ( Exception x ) { Assert.assertTrue(true); }finally {",
        "ins2PreCode":"for (int i = 0; i < 21; i++) { long now = System.currentTimeMillis(); this.datasource.getConnection(); long delta = System.currentTimeMillis()-now; System.out.println(\"Got connection #\"+i+\" in \"+delta+\" ms.\"); } Assert.assertTrue(false); } catch ( Exception x ) { Assert.assertTrue(true); }finally {",
        "label":1
    },
    {
        "ins1CurCode":"String result = res.toString();  Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "ins1PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1CurCode":"public void requestZero() { final List<Object> list = new ArrayList<>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "ins1PreCode":"public void requestZero() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "ins2PreCode":"public void requestNegative() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "label":1
    },
    {
        "ins1CurCode":" List<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":"assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional());",
        "label":0
    },
    {
        "ins1CurCode":"0, end - start);  entry.charset = bc.getCharset(); ",
        "ins1PreCode":"0, end - start);  entry.enc = bc.getEncoding(); ",
        "ins2PreCode":"public static String toString(CharChunk cc) {    if (ccCache == null) { String value = cc.toStringInternal(); if (charEnabled && (value.length() < maxStringSize)) {  synchronized (ccStats) {    if (ccCache != null) { return value; }    if (ccCount > trainThreshold) { long t1 = System.currentTimeMillis();  TreeMap<Integer,ArrayList<CharEntry>> tempMap = new TreeMap<Integer,ArrayList<CharEntry>>(); for (Entry<CharEntry,int[]> item : ccStats.entrySet()) { CharEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]);  ArrayList<CharEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<CharEntry>(); tempMap.put(count, list); } list.add(entry); }  int size = ccStats.size(); if (size > cacheSize) { size = cacheSize; } CharEntry[] tempccCache = new CharEntry[size];   CharChunk tempChunk = new CharChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList<CharEntry> list = tempMap.get(key); for (int i = 0; i < list.size() && n < size; i++) { CharEntry entry = list.get(i); tempChunk.setChars(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempccCache, n); if (insertPos == n) { tempccCache[n + 1] = entry; } else { System.arraycopy(tempccCache, insertPos + 1, tempccCache, insertPos + 2, n - insertPos - 1); tempccCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } ccCount = 0; ccStats.clear(); ccCache = tempccCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug(\"CharCache generation time: \" + (t2 - t1) + \"ms\"); } } else { ccCount++;  CharEntry entry = new CharEntry(); entry.value = value; int[] count = ccStats.get(entry); if (count == null) { int end = cc.getEnd(); int start = cc.getStart();  entry.name = new char[cc.getLength()]; System.arraycopy(cc.getBuffer(), start, entry.name, 0, end - start);  count = new int[1]; count[0] = 1;  ccStats.put(entry, count); } else { count[0] = count[0] + 1; } } } } return value; } else { accessCount++;  String result = find(cc); if (result == null) { return cc.toStringInternal(); }  hitCount++; return result; } ",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposable.empty()); new Thread(new Runnable() {",
        "ins1PreCode":"@Override public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); new Thread(new Runnable() {",
        "ins2PreCode":"@Override public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); new Thread(new Runnable() {",
        "label":1
    },
    {
        "ins1CurCode":"public void run(ApplicationArguments args) throws Exception { logger.debug(\"Running 'promote' command\"); List<String> nonOptionArgs = args.getNonOptionArgs();",
        "ins1PreCode":"public void run(ApplicationArguments args) throws Exception { List<String> nonOptionArgs = args.getNonOptionArgs(); Assert.state(!nonOptionArgs.isEmpty(), \"No command argument specified\");",
        "ins2PreCode":"public void run(ApplicationArguments args) throws Exception { List<String> nonOptionArgs = args.getNonOptionArgs(); Assert.state(!nonOptionArgs.isEmpty(), \"No command argument specified\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testPassFileDuplicateEntry() throws Exception { buildRule.executeTarget(\"test4\"); File f = new File(buildRule.getProject().getBaseDir(), \"testpassfile.tmp\");  assertTrue( \"Passfile \"+f+\" not created\", f.exists());  assertEquals( JAKARTA_URL+ EOL+ TIGRIS_URL+ EOL, FileUtilities.getFileContents(f));",
        "ins1PreCode":"public void testPassFileDuplicateEntry() throws Exception { executeTarget(\"test4\"); File f = new File(getProjectDir(), \"testpassfile.tmp\");  assertTrue( \"Passfile \"+f+\" not created\", f.exists());  assertEquals( JAKARTA_URL+ EOL+ TIGRIS_URL+ EOL, readFile(f));",
        "ins2PreCode":"public void testPassFileMultipleEntry() throws Exception { executeTarget(\"test5\"); File f = new File(getProjectDir(), \"testpassfile.tmp\");  assertTrue( \"Passfile \"+f+\" not created\", f.exists());  assertEquals( JAKARTA_URL+ EOL+ XML_URL+ EOL+ TIGRIS_URL+ EOL, readFile(f));",
        "label":1
    },
    {
        "ins1CurCode":"  OHLCSeries<String> s1 = new OHLCSeries<>(\"Series\"); s1.add(new Year(2006), 1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); assertFalse(c1.equals(c2)); OHLCSeries<String> s2 = new OHLCSeries<>(\"Series\"); s2.add(new Year(2006), 1.0, 1.1, 1.2, 1.3); c2.addSeries(s2); assertTrue(c1.equals(c2));   c1.addSeries(new OHLCSeries<>(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new OHLCSeries<>(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "ins1PreCode":"  OHLCSeries s1 = new OHLCSeries(\"Series\"); s1.add(new Year(2006), 1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); assertFalse(c1.equals(c2)); OHLCSeries s2 = new OHLCSeries(\"Series\"); s2.add(new Year(2006), 1.0, 1.1, 1.2, 1.3); c2.addSeries(s2); assertTrue(c1.equals(c2));   c1.addSeries(new OHLCSeries(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new OHLCSeries(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "ins2PreCode":"public void testEquals() { XYIntervalSeriesCollection<String> c1 = new XYIntervalSeriesCollection<>(); XYIntervalSeriesCollection<String> c2 = new XYIntervalSeriesCollection<>(); assertEquals(c1, c2);   XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); c1.addSeries(s1); assertFalse(c1.equals(c2)); XYIntervalSeries<String> s2 = new XYIntervalSeries<>(\"Series\"); s2.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); c2.addSeries(s2); assertTrue(c1.equals(c2));   c1.addSeries(new XYIntervalSeries<>(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries<>(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "label":0
    },
    {
        "ins1CurCode":"LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(1.0, 100, 0.0, 1.0); linSGDImpl.setIntercept(true);",
        "ins1PreCode":"LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(); linSGDImpl.setIntercept(true);",
        "ins2PreCode":"LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LassoModel model = LassoWithSGD.train(testRDD.rdd(), 100, 1.0, 0.01, 1.0); ",
        "label":0
    },
    {
        "ins1CurCode":" assertEquals(Collections.singletonList(expected), importer.importAnnotations(Path.of(\"src/test/resources/pdfs/minimal-popup.pdf\")));",
        "ins1PreCode":" assertEquals(Collections.singletonList(expected), importer.importAnnotations(Paths.get(\"src/test/resources/pdfs/minimal-popup.pdf\")));",
        "ins2PreCode":" assertEquals(Collections.singletonList(expected), importer.importAnnotations(Paths.get(\"src/test/resources/pdfs/minimal-polygon.pdf\")));",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6) { Objects.requireNonNull(item1, \"item1 is null\");",
        "ins1PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6) { Objects.requireNonNull(item1, \"item1 is null\");",
        "ins2PreCode":"public static <@NonNull T> Flowable<T> just(T item1, T item2, T item3, T item4, T item5, T item6) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\"); Objects.requireNonNull(item3, \"item3 is null\"); Objects.requireNonNull(item4, \"item4 is null\"); Objects.requireNonNull(item5, \"item5 is null\"); Objects.requireNonNull(item6, \"item6 is null\");  return fromArray(item1, item2, item3, item4, item5, item6);",
        "label":0
    },
    {
        "ins1CurCode":"this.parent.registerSingleton(\"foo\", Foo.class); this.context.registerSingleton(\"bar\", Foo.class); assertThatExceptionOfType(AssertionError.class).isThrownBy( () -> assertThat(getAssert(this.context)).hasSingleBean(Foo.class)) .withMessageContaining(\"but found:\");",
        "ins1PreCode":"this.parent.registerSingleton(\"foo\", Foo.class); this.context.registerSingleton(\"bar\", Foo.class); this.thrown.expect(AssertionError.class); this.thrown.expectMessage(\"but found:\"); assertThat(getAssert(this.context)).hasSingleBean(Foo.class);",
        "ins2PreCode":"this.context.registerSingleton(\"foo\", Foo.class); this.context.registerSingleton(\"bar\", Foo.class); this.thrown.expect(AssertionError.class); this.thrown.expectMessage(\"but found\"); assertThat(getAssert(this.context)).getBean(Foo.class);",
        "label":1
    },
    {
        "ins1CurCode":"doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false, ThreadWatchdog.noop()); Exception e = expectThrows(Exception.class, () -> processor.execute(doc));",
        "ins1PreCode":"doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false); Exception e = expectThrows(Exception.class, () -> processor.execute(doc));",
        "ins2PreCode":"doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, true); Exception e = expectThrows(Exception.class, () -> processor.execute(doc));",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator(); renderer.setSeriesToolTipGenerator(0, tt); XYToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0); assertTrue(tt2 == tt);",
        "label":0
    },
    {
        "ins1CurCode":"return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"float [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + byte.class.getCanonicalName()); }",
        "ins1PreCode":"return ((Number)value).floatValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to float\"); }",
        "ins2PreCode":"return ((Number)value).doubleValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testBasics() throws Exception { indexRandom(true, client().prepareIndex(\"test\").setId(\"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\").setId(\"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\").setId(\"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\").setId(\"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4);",
        "ins1PreCode":"public void testBasics() throws Exception { indexRandom(true, client().prepareIndex(\"test\", \"test\", \"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4);",
        "ins2PreCode":"public void testSlices() throws Exception { indexRandom(true, client().prepareIndex(\"test\", \"test\", \"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4);",
        "label":1
    },
    {
        "ins1CurCode":"void whenHealthIsDown503ResponseIsReturned(ApplicationContext context, WebTestClient client) throws Exception { withHealthIndicator(context, \"charlie\", () -> Health.down().build(), () -> Mono.just(Health.down().build()), () -> { client.get().uri(\"/actuator/health\").exchange().expectStatus() .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\") .jsonPath(\"details.alpha.status\").isEqualTo(\"UP\").jsonPath(\"details.bravo.status\") .isEqualTo(\"UP\").jsonPath(\"details.charlie.status\").isEqualTo(\"DOWN\"); return null;",
        "ins1PreCode":"public void whenHealthIsDown503ResponseIsReturned() throws Exception { withHealthIndicator(\"charlie\", () -> Health.down().build(), () -> Mono.just(Health.down().build()), () -> { client.get().uri(\"/actuator/health\").exchange().expectStatus().isEqualTo(HttpStatus.SERVICE_UNAVAILABLE) .expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\").jsonPath(\"details.alpha.status\").isEqualTo(\"UP\") .jsonPath(\"details.bravo.status\").isEqualTo(\"UP\").jsonPath(\"details.charlie.status\") .isEqualTo(\"DOWN\"); return null;",
        "ins2PreCode":"public void whenComponentHealthIsDown503ResponseIsReturned() throws Exception { withHealthIndicator(\"charlie\", () -> Health.down().build(), () -> Mono.just(Health.down().build()), () -> { client.get().uri(\"/actuator/health/charlie\").exchange().expectStatus() .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\"); return null;",
        "label":1
    },
    {
        "ins1CurCode":"} else { active = true; inner.setSubscription(new WeakScalarSubscription<>(vr, inner)); }",
        "ins1PreCode":"} else { active = true; inner.setSubscription(new WeakScalarSubscription<R>(vr, inner)); }",
        "ins2PreCode":"} else { active = true; inner.setSubscription(new WeakScalarSubscription<R>(vr, inner)); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testFindFileInSubdirectory() throws Exception {  BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\"); ",
        "ins1PreCode":"public void testFindFileInSubdirectory() throws Exception {  BibEntry localEntry = new BibEntry(BibtexEntryTypes.ARTICLE); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(\"year\", \"2017\"); ",
        "ins2PreCode":"public void testFindFileNonRecursive() throws Exception {  BibEntry localEntry = new BibEntry(BibtexEntryTypes.ARTICLE); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(\"year\", \"2017\"); ",
        "label":1
    },
    {
        "ins1CurCode":"public static <S extends Comparable<S>> Number findMinimumDomainValue( XYDataset<S> dataset) { Args.nullNotPermitted(dataset, \"dataset\"); Number result;  if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return info.getDomainLowerBound(true); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { @SuppressWarnings(\"unchecked\") IntervalXYDataset<S> intervalXYData = (IntervalXYDataset) dataset;",
        "ins1PreCode":"public static Number findMinimumDomainValue(XYDataset dataset) { Args.nullNotPermitted(dataset, \"dataset\"); Number result;  if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return info.getDomainLowerBound(true); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;",
        "ins2PreCode":"public static Number findMaximumDomainValue(XYDataset dataset) { Args.nullNotPermitted(dataset, \"dataset\"); Number result;  if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return info.getDomainUpperBound(true); }   else { double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset;",
        "label":1
    },
    {
        "ins1CurCode":"(new InitCollaborationDiagram()).init(); (new InitDeploymentDiagram()).init(); (new InitStateDiagram()).init(); (new InitClassDiagram()).init();",
        "ins1PreCode":"(new InitCollaborationDiagram()).init(); (new InitDeploymentDiagram()).init(); (new InitSequenceDiagram()).init(); (new InitStateDiagram()).init();",
        "ins2PreCode":"(new InitCollaborationDiagram()).init(); (new InitDeploymentDiagram()).init(); (new InitSequenceDiagram()).init(); (new InitStateDiagram()).init();",
        "label":1
    },
    {
        "ins1CurCode":"DNSKEYRecord dnskey = (DNSKEYRecord) Record.fromString(Name.root, Type.DNSKEY, DClass.IN, 3600, \"256 3 3 AJYu3cw2nLqOuyYO5rahJtk0bjjF/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuF2eEcbJ6nPRO6RpJxRR9samq8kTwWkNNZIaTHS0UJxueNQMLcf1z2heQabMuKTVjDhwgYjVNDaIKbEFuUL55TKRAt3Xr7t5zCMLaujMvqNHOzCFEusXN5mXjJqAj8J0l4B4tbL7M4iIFZeXJDXGCEcsBbNrVAfFnlOO06B6dkB8L\", Name.root); RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600L, \"TXT 3 0 3600 19700101000003 19700101000000 36714 . AAAycZeIdBGB7vjlFzd5+ZgV8IxGRLpLierdV1KO4SGIy707hKUXJRc=\", Name.root);",
        "ins1PreCode":"DNSKEYRecord dnskey = (DNSKEYRecord) Record.fromString(Name.root, Type.DNSKEY, DClass.IN, 3600, \"256 3 3 AJYu3cw2nLqOuyYO5rahJtk0bjjF/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuF2eEcbJ6nPRO6RpJxRR9samq8kTwWkNNZIaTHS0UJxueNQMLcf1z2heQabMuKTVjDhwgYjVNDaIKbEFuUL55TKRAt3Xr7t5zCMLaujMvqNHOzCFEusXN5mXjJqAj8J0l4B4tbL7M4iIFZeXJDXGCEcsBbNrVAfFnlOO06B6dkB8L\", Name.root); RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600l, \"TXT 3 0 3600 19700101000003 19700101000000 36714 . AAAycZeIdBGB7vjlFzd5+ZgV8IxGRLpLierdV1KO4SGIy707hKUXJRc=\", Name.root);",
        "ins2PreCode":"DNSKEYRecord dnskey = (DNSKEYRecord) Record.fromString(Name.root, Type.DNSKEY, DClass.IN, 3600, \"256 3 3 AJYu3cw2nLqOuyYO5rahJtk0bjjF/KaCzo4Syrom78z3EQ5SbbB4sF7ey80etKII864WF64B81uRpH5t9jQTxeEu0ImbzRMqzVDZkVG9xD7nN1kuF2eEcbJ6nPRO6RpJxRR9samq8kTwWkNNZIaTHS0UJxueNQMLcf1z2heQabMuKTVjDhwgYjVNDaIKbEFuUL55TKQflphJYUXcb2M3wKNGoXP7NufzhfVaDtiS44waWjC8IN98Ab+SPPfM4+xgTsgzWt8KvzL8hhqSW+4+5zjiQ6UG\", Name.root); RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600l, \"TXT 3 0 3600 19700101000003 19700101000000 57407 . AIh8Bp0EFNszs3cB0gNatjWy8tBrgUAUe1gTHkVsm1pva1GYWOW/FbA=\", Name.root);",
        "label":1
    },
    {
        "ins1CurCode":"public void singleWebEndpointCanBeExcluded() { WebApplicationContextRunner contextRunner = this.contextRunner.withPropertyValues( \"management.endpoints.web.exposure.include=*\", \"management.endpoints.web.exposure.exclude=shutdown\"); contextRunner.run((context) -> {",
        "ins1PreCode":"public void singleWebEndpointCanBeExcluded() { WebApplicationContextRunner contextRunner = this.contextRunner.withPropertyValues( \"management.endpoints.web.expose=*\", \"management.endpoints.web.exclude=shutdown\"); contextRunner.run((context) -> {",
        "ins2PreCode":"public void webEndpointsCanBeExposed() { WebApplicationContextRunner contextRunner = this.contextRunner .withPropertyValues(\"management.endpoints.web.expose=*\"); contextRunner.run((context) -> {",
        "label":0
    },
    {
        "ins1CurCode":"});  Dataset<Row> sentenceData = spark.createDataFrame(data, schema); Tokenizer tokenizer = new Tokenizer()",
        "ins1PreCode":"});  Dataset<Row> sentenceData = jsql.createDataFrame(data, schema); Tokenizer tokenizer = new Tokenizer()",
        "ins2PreCode":"public static void main(String[] args) { SparkSession spark = SparkSession.builder().appName(\"JavaTfIdfExample\").getOrCreate();   List<Row> data = Arrays.asList( RowFactory.create(0, \"Hi I heard about Spark\"), RowFactory.create(0, \"I wish Java could use case classes\"), RowFactory.create(1, \"Logistic regression models are neat\") ); StructType schema = new StructType(new StructField[]{ new StructField(\"label\", DataTypes.DoubleType, false, Metadata.empty()), new StructField(\"sentence\", DataTypes.StringType, false, Metadata.empty()) }); Dataset<Row> sentenceData = spark.createDataFrame(data, schema); Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\"); Dataset<Row> wordsData = tokenizer.transform(sentenceData); int numFeatures = 20; HashingTF hashingTF = new HashingTF() .setInputCol(\"words\") .setOutputCol(\"rawFeatures\") .setNumFeatures(numFeatures); Dataset<Row> featurizedData = hashingTF.transform(wordsData);   IDF idf = new IDF().setInputCol(\"rawFeatures\").setOutputCol(\"features\"); IDFModel idfModel = idf.fit(featurizedData); Dataset<Row> rescaledData = idfModel.transform(featurizedData); for (Row r : rescaledData.select(\"features\", \"label\").takeAsList(3)) { Vector features = r.getAs(0); Double label = r.getDouble(1); System.out.println(features); System.out.println(label); }   spark.stop();",
        "label":0
    },
    {
        "ins1CurCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); Object fieldValue = RandomDocumentPicks.randomFieldValue(random()); Processor processor = createSetProcessor(fieldName, fieldValue, null, false, false); processor.execute(ingestDocument);",
        "ins1PreCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); Object fieldValue = RandomDocumentPicks.randomFieldValue(random()); Processor processor = createSetProcessor(fieldName, fieldValue, false, false); processor.execute(ingestDocument);",
        "ins2PreCode":"Object fieldValue = \"foo\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = createSetProcessor(fieldName, \"bar\", false, false); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1CurCode":"throws Exception { ProjectBuildingRequest configuration = newBuildingRequest(); configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) );",
        "ins1PreCode":"throws Exception { ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest(); configuration.setLocalRepository( getLocalRepository() ); configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) ); configuration.setProcessPlugins( false ); configuration.setResolveDependencies( true ); initRepoSession( configuration );  try { return projectBuilder.build( pom, configuration ).getProject(); } catch ( Exception e ) { Throwable cause = e.getCause(); if ( cause instanceof ModelBuildingException ) { String message = \"In: \" + pom + \"\\n\\n\"; for ( ModelProblem problem : ( (ModelBuildingException) cause ).getProblems() ) { message += problem + \"\\n\"; } System.out.println( message ); fail( message ); }",
        "ins2PreCode":"protected MavenProject getProjectWithDependencies( File pom ) throws Exception { ProjectBuildingRequest configuration = new DefaultProjectBuildingRequest(); configuration.setLocalRepository( getLocalRepository() ); configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) ); configuration.setProcessPlugins( false ); configuration.setResolveDependencies( true ); initRepoSession( configuration );  try { return projectBuilder.build( pom, configuration ).getProject(); } catch ( Exception e ) { Throwable cause = e.getCause(); if ( cause instanceof ModelBuildingException ) { String message = \"In: \" + pom + \"\\n\\n\"; for ( ModelProblem problem : ( (ModelBuildingException) cause ).getProblems() ) { message += problem + \"\\n\"; } System.out.println( message ); fail( message ); }  throw e; }",
        "label":0
    },
    {
        "ins1CurCode":"Observer<String> observer = TestHelper.mockObserver();  TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2)); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "ins1PreCode":"Observer<String> observer = TestHelper.mockObserver();  @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2));",
        "ins2PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  @SuppressWarnings(\"unchecked\") TestObservable<Flowable<String>> observableOfObservables = new TestObservable<>(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2));",
        "label":1
    },
    {
        "ins1CurCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFuncErr);  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"a\");",
        "ins1PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFuncErr);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "ins2PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFuncErr);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "label":1
    },
    {
        "ins1CurCode":"InputStream is = this.getInputStream(); try { StringBuilder sb = new StringBuilder(); int windowStart = -s.length();",
        "ins1PreCode":"InputStream is = this.getInputStream(); try { StringBuffer sb = new StringBuffer(); int windowStart = -s.length();",
        "ins2PreCode":"InputStream is = this.getInputStream(); try { StringBuffer sb = new StringBuffer(); int windowStart = -s.length();",
        "label":1
    },
    {
        "ins1CurCode":"Widget widget = SWTElementHelpers.getWidget(element); if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { return super.applyCSSProperty(element, property, value, pseudo, engine); }",
        "ins1PreCode":"Widget widget = SWTElementHelpers.getWidget(element); if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { return false; }",
        "ins2PreCode":"Widget widget = SWTElementHelpers.getWidget(element); if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { return false; }",
        "label":1
    },
    {
        "ins1CurCode":" List<Repository> pluginRepositories = rawProfile.getPluginRepositories(); for ( Repository pluginRepo : pluginRepositories ) { try { request.addPluginArtifactRepository( repositorySystem.buildArtifactRepository( pluginRepo ) ); }",
        "ins1PreCode":" List<Repository> pluginRepositories = rawProfile.getPluginRepositories(); for ( Repository pluginRepository : pluginRepositories ) { try { request.addPluginArtifactRepository( repositorySystem.buildArtifactRepository( pluginRepository ) ); }",
        "ins2PreCode":"public MavenExecutionRequest populateFromSettings( MavenExecutionRequest request, Settings settings ) throws MavenExecutionRequestPopulationException { if ( settings == null ) { return request; }  request.setOffline( settings.isOffline() );  request.setInteractiveMode( settings.isInteractiveMode() );  request.setPluginGroups( settings.getPluginGroups() );  request.setLocalRepositoryPath( settings.getLocalRepository() );  for ( Server server : settings.getServers() ) { server = server.clone();  request.addServer( server ); }              for ( Proxy proxy : settings.getProxies() ) { if ( !proxy.isActive() ) { continue; }  proxy = proxy.clone();  request.addProxy( proxy ); }          for ( Mirror mirror : settings.getMirrors() ) { mirror = mirror.clone();  request.addMirror( mirror ); }  request.setActiveProfiles( settings.getActiveProfiles() );  for ( org.apache.maven.settings.Profile rawProfile : settings.getProfiles() ) { request.addProfile( SettingsUtils.convertFromSettingsProfile( rawProfile ) );  if ( settings.getActiveProfiles().contains( rawProfile.getId() ) ) { List<Repository> remoteRepositories = rawProfile.getRepositories(); for ( Repository remoteRepository : remoteRepositories ) { try { request.addRemoteRepository( MavenRepositorySystem.buildArtifactRepository( remoteRepository ) ); } catch ( InvalidRepositoryException e ) {  } }  List<Repository> pluginRepositories = rawProfile.getPluginRepositories(); for ( Repository pluginRepository : pluginRepositories ) { try { request.addPluginArtifactRepository( MavenRepositorySystem.buildArtifactRepository( pluginRepository ) ); } catch ( InvalidRepositoryException e ) {  } } } } return request;",
        "label":0
    },
    {
        "ins1CurCode":"private static void revokeToken(JenkinsRule j, WebClient wc, String login, String tokenUuid) throws Exception { WebRequest request = new WebRequest( new URL(j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid), HttpMethod.POST",
        "ins1PreCode":"private void revokeToken(WebClient wc, String login, String tokenUuid) throws Exception { WebRequest request = new WebRequest( new URL(rr.j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid), HttpMethod.POST",
        "ins2PreCode":"private void revokeToken(WebClient wc, String login, String tokenUuid) throws Exception { WebRequest request = new WebRequest( new URL(j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid), HttpMethod.POST ); Page p = wc.getPage(request); assertEquals(200, p.getWebResponse().getStatusCode());",
        "label":0
    },
    {
        "ins1CurCode":"URL txtFile = new File( \"target/test-classes/source.txt\" ).toURI().toURL(); UrlSource source = new UrlSource( txtFile ); try ( InputStream is = source.getInputStream(); Scanner scanner = new Scanner( is ) ) {",
        "ins1PreCode":"URL txtFile = new File( \"target/test-classes/source.txt\" ).toURI().toURL(); UrlSource source = new UrlSource( txtFile );  Scanner scanner = null; InputStream is = null; try { is = source.getInputStream();  scanner = new Scanner( is ); assertEquals( \"Hello World!\", scanner.nextLine() ); } finally { if ( scanner != null ) { scanner.close(); } if ( is != null ) { is.close(); }",
        "ins2PreCode":"FileSource source = new FileSource( txtFile );  Scanner scanner = null; InputStream is = null; try { is = source.getInputStream();  scanner = new Scanner( is ); assertEquals( \"Hello World!\", scanner.nextLine() ); } finally { if ( scanner != null ) { scanner.close(); } if ( is != null ) { is.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"});  final ArrayList<String> list = new ArrayList<>(); f.subscribe(new Consumer<String>() {",
        "ins1PreCode":"});  final ArrayList<String> list = new ArrayList<String>(); f.subscribe(new Consumer<String>() {",
        "ins2PreCode":"});  final ArrayList<String> list = new ArrayList<String>(); o.subscribe(new Consumer<String>() {",
        "label":1
    },
    {
        "ins1CurCode":"void canMockPrimaryBean() { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();",
        "ins1PreCode":"public void canMockPrimaryBean() { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();",
        "ins2PreCode":"public void canMockQualifiedBeanWithPrimaryBeanPresent() { AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext();",
        "label":1
    },
    {
        "ins1CurCode":"void writeEntry() throws Exception { BibEntry entry = new BibEntry(); entry.setType(StandardEntryType.Article); database.insertEntry(entry);",
        "ins1PreCode":"void writeEntry() throws Exception { BibEntry entry = new BibEntry(); entry.setType(BibtexEntryTypes.ARTICLE); database.insertEntry(entry);",
        "ins2PreCode":"when(preferences.getEncoding()).thenReturn(StandardCharsets.US_ASCII); BibEntry entry = new BibEntry(); entry.setType(BibtexEntryTypes.ARTICLE); database.insertEntry(entry);",
        "label":1
    },
    {
        "ins1CurCode":"effectiveRepository.setMirroredRepositories( mirroredRepos );  effectiveRepository.setBlocked( aliasedRepo.isBlocked() ); ",
        "ins1PreCode":"effectiveRepository.setMirroredRepositories( mirroredRepos );  effectiveRepositories.add( effectiveRepository ); }",
        "ins2PreCode":"effectiveRepository.setMirroredRepositories( mirroredRepos );  effectiveRepositories.add( effectiveRepository ); }",
        "label":1
    },
    {
        "ins1CurCode":"void loadTwoPropertiesFile() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.location=classpath:application.properties,classpath:testproperties.properties\"); this.initializer.postProcessEnvironment(this.environment, this.application);",
        "ins1PreCode":"void loadTwoPropertiesFile() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment, \"spring.config.location=\" + \"classpath:application.properties,classpath:testproperties.properties\"); this.initializer.postProcessEnvironment(this.environment, this.application);",
        "ins2PreCode":"void loadDefaultPropertiesFile() { this.environment.setDefaultProfiles(\"thedefault\"); this.initializer.setSearchNames(\"testprofiles\"); this.initializer.postProcessEnvironment(this.environment, this.application); String property = this.environment.getProperty(\"the.property\"); assertThat(property).isEqualTo(\"fromdefaultpropertiesfile\");",
        "label":0
    },
    {
        "ins1CurCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins1PreCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "ins2PreCode":"protected void addObjectDeleteActions(List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) {",
        "label":1
    },
    {
        "ins1CurCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<>(); List<Flowable<Integer>> sourceList = new ArrayList<>(i); Set<Integer> expected = new HashSet<>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<>(ts.values()); ",
        "ins1PreCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(ts.values()); ",
        "ins2PreCode":"break; } TestObserver<Integer> to = new TestObserver<Integer>(); List<Observable<Integer>> sourceList = new ArrayList<Observable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Observable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Observable.merge(sourceList, i - 1).subscribe(to);  to.awaitDone(1, TimeUnit.SECONDS); to.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(to.values()); ",
        "label":1
    },
    {
        "ins1CurCode":"runJsonDatasetExample(spark); runCsvDatasetExample(spark); runTextDatasetExample(spark); runJdbcDatasetExample(spark);",
        "ins1PreCode":"runJsonDatasetExample(spark); runCsvDatasetExample(spark); runJdbcDatasetExample(spark); ",
        "ins2PreCode":"public static void main(String[] args) throws AnalysisException {  SparkSession spark = SparkSession .builder() .appName(\"Java Spark SQL basic example\") .config(\"spark.some.config.option\", \"some-value\") .getOrCreate();   runBasicDataFrameExample(spark); runDatasetCreationExample(spark); runInferSchemaExample(spark); runProgrammaticSchemaExample(spark);  spark.stop();",
        "label":0
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); observer.onNext(1); observer.onError(new TestException(\"outer\")); } } .switchMapMaybe(new Function<Integer, MaybeSource<Integer>>() { @Override public MaybeSource<Integer> apply(Integer v) throws Exception { return new Maybe<Integer>() { @Override protected void subscribeActual( MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); moRef.set(observer);",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1); observer.onError(new TestException(\"outer\")); } } .switchMapMaybe(new Function<Integer, MaybeSource<Integer>>() { @Override public MaybeSource<Integer> apply(Integer v) throws Exception { return new Maybe<Integer>() { @Override protected void subscribeActual( MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); moRef.set(observer);",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1); observer.onError(new TestException(\"outer\")); } } .switchMapSingle(new Function<Integer, SingleSource<Integer>>() { @Override public SingleSource<Integer> apply(Integer v) throws Exception { return new Single<Integer>() { @Override protected void subscribeActual( SingleObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); moRef.set(observer);",
        "label":1
    },
    {
        "ins1CurCode":"void testSeleckKeyReturnsNoData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<>(); parms.put(\"name\", \"Fred\"); Assertions.assertThrows(PersistenceException.class, () -> sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms)); }",
        "ins1PreCode":"public void testSeleckKeyReturnsNoData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<>(); parms.put(\"name\", \"Fred\"); Assertions.assertThrows(PersistenceException.class, () -> { sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms); }); }",
        "ins2PreCode":"public void testSeleckKeyReturnsTooManyData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<>(); parms.put(\"name\", \"Fred\"); sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertTooManyValuesInSelectKey\", parms); Assertions.assertThrows(PersistenceException.class, () -> { sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertTooManyValuesInSelectKey\", parms); }); }",
        "label":1
    },
    {
        "ins1CurCode":"public RequestDispatcher getRequestDispatcher(String path) {  Context context = getContext(); if (context == null) {",
        "ins1PreCode":"public RequestDispatcher getRequestDispatcher(String path) {  if (context == null) { return null;",
        "ins2PreCode":"public RequestDispatcher getRequestDispatcher(String path) {  if (context == null) return (null);   if (path == null) return (null); else if (path.startsWith(\"/\")) return (context.getServletContext().getRequestDispatcher(path));   String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH); if (servletPath == null) servletPath = getServletPath();   String pathInfo = getPathInfo(); String requestPath = null;  if (pathInfo == null) { requestPath = servletPath; } else { requestPath = servletPath + pathInfo; }  int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; }  return (context.getServletContext().getRequestDispatcher(relative)); ",
        "label":0
    },
    {
        "ins1CurCode":"private void addGetMethods(Class<?> cls) { Map<String, List<Method>> conflictingGetters = new HashMap<String, List<Method>>(); Method[] methods = getClassMethods(cls); for (Method method : methods) { String name = method.getName(); if (name.startsWith(\"get\") && name.length() > 3) { if (method.getParameterTypes().length == 0) { name = PropertyNamer.methodToProperty(name); addMethodConflict(conflictingGetters, name, method); } } else if (name.startsWith(\"is\") && name.length() > 2) { if (method.getParameterTypes().length == 0) { name = PropertyNamer.methodToProperty(name); addMethodConflict(conflictingGetters, name, method); } } } resolveGetterConflicts(conflictingGetters);",
        "ins1PreCode":"if (method.getParameterTypes().length == 0) { name = PropertyNamer.methodToProperty(name); addGetMethod(name, method); } } else if (name.startsWith(\"is\") && name.length() > 2) { if (method.getParameterTypes().length == 0) { name = PropertyNamer.methodToProperty(name); addGetMethod(name, method); }",
        "ins2PreCode":"if (method.getParameterTypes().length == 1) { name = PropertyNamer.methodToProperty(name); addSetterConflict(conflictingSetters, name, method); }",
        "label":0
    },
    {
        "ins1CurCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();",
        "ins1PreCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "ins2PreCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "label":1
    },
    {
        "ins1CurCode":"public void collectIntoFlowable() { Flowable.just(1, 1, 1, 1, 2) .collectInto(new HashSet<>(), new BiConsumer<HashSet<Integer>, Integer>() { @Override public void accept(HashSet<Integer> s, Integer v) throws Exception { s.add(v); } }) .toFlowable() .test() .assertResult(new HashSet<>(Arrays.asList(1, 2)));",
        "ins1PreCode":"public void collectIntoFlowable() { Flowable.just(1, 1, 1, 1, 2) .collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() { @Override public void accept(HashSet<Integer> s, Integer v) throws Exception { s.add(v); } }) .toFlowable() .test() .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));",
        "ins2PreCode":"public void collectInto() { Flowable.just(1, 1, 1, 1, 2) .collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() { @Override public void accept(HashSet<Integer> s, Integer v) throws Exception { s.add(v); } }) .test() .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));",
        "label":1
    },
    {
        "ins1CurCode":"DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings, mapperService.documentMapperParser(), documentMapper, null, null);",
        "ins1PreCode":"DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(), documentMapper, null, null);",
        "ins2PreCode":"DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(), documentMapper, null, null);",
        "label":1
    },
    {
        "ins1CurCode":" Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(false)); ctx.addServletMappingDecoded(\"/\", \"bug54220\"); ",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(false)); ctx.addServletMapping(\"/\", \"bug54220\"); ",
        "ins2PreCode":" Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(true)); ctx.addServletMapping(\"/\", \"bug54220\"); ",
        "label":1
    },
    {
        "ins1CurCode":"ensureIsMutable();  checkNotNull(collection); ",
        "ins1PreCode":"ensureIsMutable();  if (collection == null) { throw new NullPointerException(); }",
        "ins2PreCode":"ensureIsMutable();  if (collection == null) { throw new NullPointerException(); }",
        "label":1
    },
    {
        "ins1CurCode":"void propertiesFileEnhancesEnvironment() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins1PreCode":"public void propertiesFileEnhancesEnvironment() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "ins2PreCode":"public void emptyCommandLinePropertySourceNotAdded() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":1
    },
    {
        "ins1CurCode":"public void testClone() throws CloneNotSupportedException { TimePeriodValues<String> series = new TimePeriodValues<>(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42); TimePeriodValues<String> clone = CloneUtils.clone(series); clone.setKey(\"Clone Series\");",
        "ins1PreCode":"public void testClone() throws CloneNotSupportedException { TimePeriodValues series = new TimePeriodValues(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42); TimePeriodValues clone = (TimePeriodValues) series.clone(); clone.setKey(\"Clone Series\");",
        "ins2PreCode":"public void testClone() throws CloneNotSupportedException { TimeSeries series = new TimeSeries(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42);  TimeSeries clone = CloneUtils.clone(series); clone.setKey(\"Clone Series\");",
        "label":0
    },
    {
        "ins1CurCode":"private void testCompleteDirectoryMove(String target) throws IOException { buildRule.executeTarget(target); String output = buildRule.getProject().getProperty(\"output\"); assertTrue(new File(output,\"E\").exists()); assertTrue(new File(output,\"E/1\").exists()); assertTrue(!new File(output,\"A/1\").exists()); ",
        "ins1PreCode":"private void testCompleteDirectoryMove(String target) throws IOException { executeTarget(target); assertTrue(new File(getOutputDir(),\"E\").exists()); assertTrue(new File(getOutputDir(),\"E/1\").exists()); assertTrue(!new File(getOutputDir(),\"A/1\").exists()); ",
        "ins2PreCode":"public void testPathElementMove() throws IOException { executeTarget(\"testPathElementMove\"); assertTrue(new File(getOutputDir(),\"E\").exists()); assertTrue(new File(getOutputDir(),\"E/1\").exists()); assertTrue(!new File(getOutputDir(),\"A/1\").exists()); assertTrue(new File(getOutputDir(),\"A\").exists());",
        "label":1
    },
    {
        "ins1CurCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for group \" + group); iae.initCause(e); throw iae;",
        "ins1PreCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for group \" + group); jdkCompat.chainException(iae, e); throw iae;",
        "ins2PreCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying group \" + group + \" MBean\"); jdkCompat.chainException(iae, e); throw iae;",
        "label":1
    },
    {
        "ins1CurCode":"public void testCloning() throws CloneNotSupportedException { DefaultDrawingSupplier r1 = new DefaultDrawingSupplier(); DefaultDrawingSupplier r2 = CloneUtils.clone(r1); assertTrue(r1 != r2);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultDrawingSupplier r1 = new DefaultDrawingSupplier(); DefaultDrawingSupplier r2 = (DefaultDrawingSupplier) r1.clone(); assertTrue(r1 != r2);",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { LevelRenderer r1 = new LevelRenderer(); r1.setItemMargin(0.123); r1.setMaximumItemWidth(0.234); LevelRenderer r2 = (LevelRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));  assertTrue(checkIndependence(r1, r2)); ",
        "label":0
    },
    {
        "ins1CurCode":"  assertEquals(\"\", a.format(\"\"));   assertEquals(\"Someone, Van Something\", a.format(\"Van Something Someone\"));   assertEquals(\"von Neumann, John and Black Brown, Peter\", a .format(\"John von Neumann and Black Brown, Peter\"));   assertEquals(\"von Neumann, John, Smith, John and Black Brown, Peter\", a .format(\"von Neumann, John and Smith, John and Black Brown, Peter\"));  assertEquals(\"von Neumann, John, Smith, John and Black Brown, Peter\", a .format(\"John von Neumann and John Smith and Black Brown, Peter\"));",
        "ins1PreCode":"  Assert.assertEquals(\"\", a.format(\"\"));   Assert.assertEquals(\"Someone, Van Something\", a.format(\"Van Something Someone\"));   Assert.assertEquals(\"von Neumann, John and Black Brown, Peter\", a .format(\"John von Neumann and Black Brown, Peter\"));   Assert.assertEquals(\"von Neumann, John, Smith, John and Black Brown, Peter\", a .format(\"von Neumann, John and Smith, John and Black Brown, Peter\"));  Assert.assertEquals(\"von Neumann, John, Smith, John and Black Brown, Peter\", a .format(\"John von Neumann and John Smith and Black Brown, Peter\"));",
        "ins2PreCode":"  Assert.assertEquals(\"\", a.format(\"\"));   Assert.assertEquals(\"Someone, Van Something\", a.format(\"Van Something Someone\"));   Assert.assertEquals(\"von Neumann, John and Black Brown, Peter\", a .format(\"John von Neumann and Black Brown, Peter\"));   Assert.assertEquals(\"von Neumann, John, Smith, John, and Black Brown, Peter\", a .format(\"von Neumann, John and Smith, John and Black Brown, Peter\"));  Assert.assertEquals(\"von Neumann, John, Smith, John, and Black Brown, Peter\", a .format(\"John von Neumann and John Smith and Black Brown, Peter\"));",
        "label":1
    },
    {
        "ins1CurCode":"public void hasCycle_threeAcyclicEdges() { for (MutableBasicGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "ins1PreCode":"public void hasCycle_threeAcyclicEdges() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "ins2PreCode":"public void hasCycle_threeCyclicEdges() { for (MutableGraph<Integer> graph : graphsToTest) { graph.putEdge(1, 2);",
        "label":1
    },
    {
        "ins1CurCode":"}); } }, false, 2, ImmediateThinScheduler.INSTANCE) .test()",
        "ins1PreCode":"}); } }, 2, false, ImmediateThinScheduler.INSTANCE) .test()",
        "ins2PreCode":"public void delayErrorCallableTillTheEnd() { Flowable.just(1, 2, 3, 101, 102, 23, 890, 120, 32) .concatMapDelayError(new Function<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(final Integer integer) throws Exception { return Flowable.fromCallable(new Callable<Integer>() { @Override public Integer call() throws Exception { if (integer >= 100) { throw new NullPointerException(\"test null exp\"); } return integer; } }); } }) .test() .assertFailure(CompositeException.class, 1, 2, 3, 23, 32);",
        "label":0
    },
    {
        "ins1CurCode":"Exception e = new Exception();  log.debug(\"Cookies: Parsing cookie as String. Expected bytes.\", e); cookieValue.toBytes();",
        "ins1PreCode":"if (cookieValue.getType() != MessageBytes.T_BYTES ) { Exception e = new Exception(); log.warn(\"Cookies: Parsing cookie as String. Expected bytes.\", e); cookieValue.toBytes();",
        "ins2PreCode":"if (cookieValue.getType() != MessageBytes.T_BYTES ) { Exception e = new Exception(); log.warn(\"Cookies: Parsing cookie as String. Expected bytes.\", e); cookieValue.toBytes();",
        "label":1
    },
    {
        "ins1CurCode":"final CountDownLatch latch = new CountDownLatch(1); final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<>(); ",
        "ins1PreCode":"final CountDownLatch latch = new CountDownLatch(1); final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); ",
        "ins2PreCode":"final CountDownLatch latch = new CountDownLatch(1); final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); ",
        "label":1
    },
    {
        "ins1CurCode":"rb2.setUdpPort(50000); channel2.addChannelListener(listener1); channel1.start(Channel.DEFAULT); channel2.start(Channel.DEFAULT);",
        "ins1PreCode":"rb2.setUdpPort(50000); channel2.addChannelListener(listener1); channel1.start(GroupChannel.DEFAULT); channel2.start(GroupChannel.DEFAULT);",
        "ins2PreCode":"rb2.setUdpPort(50000); channel2.addChannelListener(listener1); channel1.start(GroupChannel.DEFAULT); channel2.start(GroupChannel.DEFAULT);",
        "label":1
    },
    {
        "ins1CurCode":"SomeChainingException thrown = new SomeChainingException(cause);  assertThat(thrown).hasCauseThat().isSameInstanceAs(cause); assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameInstanceAs(cause); assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameInstanceAs(cause);  try { Throwables.getCauseAs(thrown, IllegalStateException.class); fail(\"Should have thrown CCE\"); } catch (ClassCastException expected) { assertThat(expected).hasCauseThat().isSameInstanceAs(thrown); }",
        "ins1PreCode":"SomeChainingException thrown = new SomeChainingException(cause);  assertThat(thrown).hasCauseThat().isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);  try { Throwables.getCauseAs(thrown, IllegalStateException.class); fail(\"Should have thrown CCE\"); } catch (ClassCastException expected) { assertThat(expected).hasCauseThat().isSameAs(thrown); }",
        "ins2PreCode":"SomeChainingException thrown = new SomeChainingException(cause);  assertThat(thrown).hasCauseThat().isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, SomeCheckedException.class)).isSameAs(cause); assertThat(Throwables.getCauseAs(thrown, Exception.class)).isSameAs(cause);  try { Throwables.getCauseAs(thrown, IllegalStateException.class); fail(\"Should have thrown CCE\"); } catch (ClassCastException expected) { assertThat(expected).hasCauseThat().isSameAs(thrown); }",
        "label":1
    },
    {
        "ins1CurCode":"IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"first=hello&second=world&second=universe\"); Processor processor = createKvProcessor(fieldName, \"&\", \"=\", null, null, \"target\", false); processor.execute(ingestDocument);",
        "ins1PreCode":"IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"first=hello&second=world&second=universe\"); Processor processor = new KeyValueProcessor(randomAlphaOfLength(10), fieldName, \"&\", \"=\", null, null, \"target\", false); processor.execute(ingestDocument);",
        "ins2PreCode":"IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"first=hello|second=world|second=universe\"); Processor processor = new KeyValueProcessor(randomAlphaOfLength(10), fieldName, \"&\", \"=\", null, null, \"target\", false); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1CurCode":"public void producerRequestThroughBufferWithSize1() { TestSubscriber<List<Integer>> ts = new TestSubscriber<>(3L); ",
        "ins1PreCode":"public void producerRequestThroughBufferWithSize1() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(3L); ",
        "ins2PreCode":"public void producerRequestThroughBufferWithSize3() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(3L); final AtomicLong requested = new AtomicLong();",
        "label":1
    },
    {
        "ins1CurCode":" List<FieldComparator> comparators = new ArrayList<>(); comparators.add(new FieldComparator(StandardField.AUTHOR)); comparators.add(new FieldComparator(StandardField.YEAR)); comparators.add(new FieldComparator(InternalField.KEY_FIELD)); ",
        "ins1PreCode":" List<FieldComparator> comparators = new ArrayList<>(); comparators.add(new FieldComparator(FieldName.AUTHOR)); comparators.add(new FieldComparator(FieldName.YEAR)); comparators.add(new FieldComparator(BibEntry.KEY_FIELD)); ",
        "ins2PreCode":" List<FieldComparator> comparators = new ArrayList<>(); comparators.add(new FieldComparator(FieldName.AUTHOR)); comparators.add(new FieldComparator(FieldName.YEAR)); comparators.add(new FieldComparator(BibEntry.KEY_FIELD)); ",
        "label":1
    },
    {
        "ins1CurCode":"nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins1PreCode":"nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins2PreCode":"nMatchingItems++; } fireNodesInserted(path, childIndices, children); }",
        "label":1
    },
    {
        "ins1CurCode":"fail(ERROR_ADDED_SELF_LOOP); } catch (IllegalArgumentException e) { assertThat(e).hasMessageThat().contains(ERROR_SELF_LOOP); }",
        "ins1PreCode":"fail(ERROR_ADDED_SELF_LOOP); } catch (IllegalArgumentException e) { assertThat(e.getMessage()).contains(ERROR_SELF_LOOP); }",
        "ins2PreCode":"fail(ERROR_ADDED_SELF_LOOP); } catch (IllegalArgumentException e) { assertThat(e.getMessage()).contains(ERROR_SELF_LOOP); }",
        "label":1
    },
    {
        "ins1CurCode":"entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"Simon Holland\");",
        "ins1PreCode":"entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"Simon Holland\");",
        "ins2PreCode":"entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"Mari D. Herland and Mona-Iren Hauge and Ingeborg M. Helgeland\");",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldFailCallingAnUnloadedProperty() throws Exception {  HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<> (); unloadedProperties.put(\"ID\", null); Author author2 = (Author) ((JavassistProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Assertions.assertThrows(ExecutorException.class, () -> {",
        "ins1PreCode":"public void shouldFailCallingAnUnloadedProperty() throws Exception {  HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<String, ResultLoaderMap.LoadPair> (); unloadedProperties.put(\"ID\", null); Author author2 = (Author) ((JavassistProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Assertions.assertThrows(ExecutorException.class, () -> {",
        "ins2PreCode":"public void shouldFailCallingAnUnloadedProperty() throws Exception {  HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<String, ResultLoaderMap.LoadPair>(); unloadedProperties.put(\"ID\", null); Author author2 = (Author) ((CglibProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Assertions.assertThrows(ExecutorException.class, () -> {",
        "label":1
    },
    {
        "ins1CurCode":"public void degree_selfLoop() { assume().that(graph.allowsSelfLoops()).isTrue(); ",
        "ins1PreCode":"public void degree_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "ins2PreCode":"public void inDegree_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); ",
        "label":1
    },
    {
        "ins1CurCode":"void movesFileWithFileDirPattern() throws Exception { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"[entrytype]\"); cleanup.cleanup(entry);",
        "ins1PreCode":"void movesFileWithFileDirPattern() throws Exception { when(filePreferences.getFileDirPattern()).thenReturn(\"[entrytype]\"); cleanup.cleanup(entry);",
        "ins2PreCode":"void movesFileWithSubdirectoryPattern() throws Exception { when(filePreferences.getFileDirPattern()).thenReturn(\"[entrytype]/[year]/[auth]\"); cleanup.cleanup(entry);",
        "label":1
    },
    {
        "ins1CurCode":"configuration.addMapper(PetMapper.class);  SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);  initDb(sqlSessionFactory);  return sqlSessionFactory;",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(PersonMapper.class); configuration.addMapper(PetMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(MultipleCrossIncludePersonMapper.class); configuration.addMapper(MultipleCrossIncludePetMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"public void testJarWithManifestInDirWithSpace() { String mainjarstring = buildRule.getProject().getProperty(\"main.jar\"); String extjarstring = buildRule.getProject().getProperty(\"ext.jar\"); Path myPath = new Path(buildRule.getProject()); myPath.setLocation(new File(mainjarstring)); buildRule.getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = buildRule.getProject().createClassLoader(myPath); String path = loader.getClasspath();",
        "ins1PreCode":"public void testJarWithManifestInDirWithSpace() { String mainjarstring = getProject().getProperty(\"main.jar\"); String extjarstring = getProject().getProperty(\"ext.jar\"); Path myPath = new Path(getProject()); myPath.setLocation(new File(mainjarstring)); getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = getProject().createClassLoader(myPath); String path = loader.getClasspath();",
        "ins2PreCode":"public void testJarWithManifestInNonAsciiDir() { String mainjarstring = getProject().getProperty(\"main.jar.nonascii\"); String extjarstring = getProject().getProperty(\"ext.jar.nonascii\"); Path myPath = new Path(getProject()); myPath.setLocation(new File(mainjarstring)); getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = getProject().createClassLoader(myPath); String path = loader.getClasspath();",
        "label":1
    },
    {
        "ins1CurCode":"public void testListAllValid() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), null, \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false,",
        "ins1PreCode":"public void testListAllValid() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false,",
        "ins2PreCode":"public void testListPartiallyValid() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false,",
        "label":1
    },
    {
        "ins1CurCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableNetwork = NetworkBuilder.directed().build(); mutableNetwork.addEdge(\"A\", \"A\", \"AA\"); mutableNetwork.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> network = ImmutableNetwork.copyOf(mutableNetwork);  assertThat(network.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(network.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(network.edgesConnecting(\"B\", \"A\")).isEmpty();",
        "ins1PreCode":"public void edgesConnecting_directed() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.directed().build(); mutableGraph.addEdge(\"A\", \"A\", \"AA\"); mutableGraph.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);  assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(graph.edgesConnecting(\"B\", \"A\")).isEmpty();",
        "ins2PreCode":"public void edgesConnecting_undirected() { MutableNetwork<String, String> mutableGraph = NetworkBuilder.undirected().build(); mutableGraph.addEdge(\"A\", \"A\", \"AA\"); mutableGraph.addEdge(\"A\", \"B\", \"AB\"); Network<String, String> graph = ImmutableNetwork.copyOf(mutableGraph);  assertThat(graph.edgesConnecting(\"A\", \"A\")).containsExactly(\"AA\"); assertThat(graph.edgesConnecting(\"A\", \"B\")).containsExactly(\"AB\"); assertThat(graph.edgesConnecting(\"B\", \"A\")).containsExactly(\"AB\");",
        "label":1
    },
    {
        "ins1CurCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 44; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"throws IOException {  Args.nullNotPermitted(out, \"out\"); Args.nullNotPermitted(chart, \"chart\"); BufferedImage image = chart.createBufferedImage(width, height,",
        "ins1PreCode":"throws IOException {  ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\"); BufferedImage image = chart.createBufferedImage(width, height,",
        "ins2PreCode":"throws IOException {  ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\"); BufferedImage image = chart.createBufferedImage(width, height,",
        "label":1
    },
    {
        "ins1CurCode":" JavaPairDStream<String, Integer> combined = pairStream.combineByKey( i -> i, new IntegerSum(), new IntegerSum(), new HashPartitioner(2)); ",
        "ins1PreCode":" JavaPairDStream<String, Integer> combined = pairStream.combineByKey( new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i; } }, new IntegerSum(), new IntegerSum(), new HashPartitioner(2)); ",
        "ins2PreCode":"JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream);  JavaPairDStream<String, Integer> combined = pairStream.<Integer>combineByKey(i -> i, (x, y) -> x + y, (x, y) -> x + y, new HashPartitioner(2));",
        "label":0
    },
    {
        "ins1CurCode":"public void testSetKey() { XYSeries<String> s1 = new XYSeries<>(\"S\"); s1.setKey(\"S1\"); assertEquals(\"S1\", s1.getKey());  XYSeriesCollection<String> c = new XYSeriesCollection<>(); c.addSeries(s1); XYSeries<String> s2 = new XYSeries<>(\"S2\"); c.addSeries(s2);",
        "ins1PreCode":"public void testSetKey() { XYSeries s1 = new XYSeries(\"S\"); s1.setKey(\"S1\"); assertEquals(\"S1\", s1.getKey());  XYSeriesCollection c = new XYSeriesCollection(); c.addSeries(s1); XYSeries s2 = new XYSeries(\"S2\"); c.addSeries(s2);",
        "ins2PreCode":"public void testSetKey() { TimeSeries s1 = new TimeSeries(\"S\"); s1.setKey(\"S1\"); assertEquals(\"S1\", s1.getKey());  TimeSeriesCollection c = new TimeSeriesCollection(); c.addSeries(s1); TimeSeries s2 = new TimeSeries(\"S2\"); c.addSeries(s2);",
        "label":1
    },
    {
        "ins1CurCode":"public void requestClearRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<>(0L);  final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<>(ts); ts.onSubscribe(ds);",
        "ins1PreCode":"public void requestClearRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);  final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(ts); ts.onSubscribe(ds);",
        "ins2PreCode":"public void requestCancelRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);  final DeferredScalarSubscription<Integer> ds = new DeferredScalarSubscription<Integer>(ts); ts.onSubscribe(ds);",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void decoratedByEnvMaintainsIsUnix() { ByteArrayOutputStream output = new ByteArrayOutputStream();",
        "ins1PreCode":"@Test public void decoratedByEnvMaintainsIsUnix() throws Exception { ByteArrayOutputStream output = new ByteArrayOutputStream();",
        "ins2PreCode":"@Test public void decoratedByPrefixMaintainsIsUnix() throws Exception { ByteArrayOutputStream output = new ByteArrayOutputStream();",
        "label":1
    },
    {
        "ins1CurCode":"fail(); } catch (RuntimeException ex) { assertThat(ex).hasCauseThat().isInstanceOf(java.io.NotSerializableException.class); }",
        "ins1PreCode":"fail(); } catch (RuntimeException ex) { assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass()); }",
        "ins2PreCode":"fail(); } catch (RuntimeException ex) { assertEquals(java.io.NotSerializableException.class, ex.getCause().getClass()); }",
        "label":1
    },
    {
        "ins1CurCode":"public void producerRequestThroughBufferWithSize2() { TestSubscriber<List<Integer>> ts = new TestSubscriber<>(); final AtomicLong requested = new AtomicLong();",
        "ins1PreCode":"public void producerRequestThroughBufferWithSize2() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); final AtomicLong requested = new AtomicLong();",
        "ins2PreCode":"public void producerRequestThroughBufferWithSize4() { TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); final AtomicLong requested = new AtomicLong();",
        "label":1
    },
    {
        "ins1CurCode":"public void testDBCPThreads20Connections10Validate() throws Exception { this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "ins1PreCode":"public void testDBCPThreads20Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "ins2PreCode":"public void testPoolThreads10Connections20Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10);",
        "label":1
    },
    {
        "ins1CurCode":"public void addMappingForServletNames( EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... servletNames) {  FilterMap filterMap = new FilterMap();  filterMap.setFilterName(filterDef.getFilterName());  if (dispatcherTypes != null) { for (DispatcherType dispatcherType : dispatcherTypes) { filterMap.setDispatcher(dispatcherType.name()); } }  if (servletNames != null) { for (String servletName : servletNames) { filterMap.addServletName(servletName); }  if (isMatchAfter) { context.addFilterMap(filterMap); } else { context.addFilterMapBefore(filterMap); } } ",
        "ins1PreCode":"public void addMappingForServletNames( EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... servletNames) {  FilterMap filterMap = new FilterMap();  filterMap.setFilterName(filterDef.getFilterName());  if (dispatcherTypes != null) { for (DispatcherType dispatcherType : dispatcherTypes) { filterMap.setDispatcher(dispatcherType.name()); } }  if (servletNames != null) { for (String servletName : servletNames) { filterMap.addServletName(servletName); }  if (isMatchAfter) { context.addFilterMapBefore(filterMap); } else { context.addFilterMap(filterMap); } } ",
        "ins2PreCode":"public void addMappingForUrlPatterns( EnumSet<DispatcherType> dispatcherTypes, boolean isMatchAfter, String... urlPatterns) {  FilterMap filterMap = new FilterMap();  filterMap.setFilterName(filterDef.getFilterName());  if (dispatcherTypes != null) { for (DispatcherType dispatcherType : dispatcherTypes) { filterMap.setDispatcher(dispatcherType.name()); } }  if (urlPatterns != null) { for (String urlPattern : urlPatterns) { filterMap.addURLPattern(urlPattern); }  if (isMatchAfter) { context.addFilterMapBefore(filterMap); } else { context.addFilterMap(filterMap); } }  ",
        "label":1
    },
    {
        "ins1CurCode":"Collections.emptyList()); return new WebFluxEndpointHandlerMapping(new EndpointMapping(\"/actuator\"), discoverer.getEndpoints(), endpointMediaTypes, new CorsConfiguration(), new EndpointLinksResolver(discoverer.getEndpoints()), true);",
        "ins1PreCode":"Collections.emptyList()); return new WebFluxEndpointHandlerMapping(new EndpointMapping(\"/actuator\"), discoverer.getEndpoints(), endpointMediaTypes, new CorsConfiguration(), new EndpointLinksResolver(discoverer.getEndpoints()));",
        "ins2PreCode":"Collections.emptyList()); return new WebMvcEndpointHandlerMapping(new EndpointMapping(\"/actuator\"), discoverer.getEndpoints(), endpointMediaTypes, new CorsConfiguration(), new EndpointLinksResolver(discoverer.getEndpoints()));",
        "label":1
    },
    {
        "ins1CurCode":"public static <T> Flowable<T> concat( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Flowable<T> concat( MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> merge( MaybeSource<? extends T> source1, MaybeSource<? extends T> source2, MaybeSource<? extends T> source3, MaybeSource<? extends T> source4 ) {",
        "label":1
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"@Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"@Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"  Thread.sleep(20000); acceptor.unbindAll();",
        "ins1PreCode":"  Thread.sleep(2000000); acceptor.unbindAll();",
        "ins2PreCode":"public static void main(String[] args) throws Exception {  OneThreadSelectorStrategy strategy = new OneThreadSelectorStrategy(new SelectorFactory( NioSelectorProcessor.class)); NioTcpServer acceptor = new NioTcpServer(strategy); acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"), new DummyHttpSever());  acceptor.getSessionConfig().setTcpNoDelay(true);  acceptor.bind(new InetSocketAddress(8080));   Thread.sleep(20000); acceptor.unbindAll(); ",
        "label":0
    },
    {
        "ins1CurCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposable.empty()); ",
        "ins1PreCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposables.empty()); ",
        "ins2PreCode":"TestObserver<Integer> to = TestObserver.create();  to.onSubscribe(Disposables.empty()); ",
        "label":1
    },
    {
        "ins1CurCode":"void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));",
        "ins1PreCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));",
        "ins2PreCode":"public void validateTokenWhenAudienceIsNotValidShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS));",
        "label":1
    },
    {
        "ins1CurCode":"void testAdderAsSelectDoubleCallAnnotated1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1PreCode":"public void testAdderAsSelectDoubleCallAnnotated1() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void testAdderAsSelectDoubleCallAnnotated2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1CurCode":"private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, org.eclipse.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception ) { RepositoryListener listener = session.getRepositoryListener(); if ( listener != null ) { RepositoryEvent.Builder event = new RepositoryEvent.Builder( session, EventType.METADATA_INVALID ); event.setTrace( trace ); event.setMetadata( metadata ); event.setException( exception ); event.setRepository( repository ); listener.metadataInvalid( event.build() ); }",
        "ins1PreCode":"private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception ) { RepositoryListener listener = session.getRepositoryListener(); if ( listener != null ) { DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace ); event.setMetadata( metadata ); event.setException( exception ); event.setRepository( repository ); listener.metadataInvalid( event ); }",
        "ins2PreCode":"private void invalidMetadata( RepositorySystemSession session, RequestTrace trace, org.sonatype.aether.metadata.Metadata metadata, ArtifactRepository repository, Exception exception ) { RepositoryListener listener = session.getRepositoryListener(); if ( listener != null ) { DefaultRepositoryEvent event = new DefaultRepositoryEvent( EventType.METADATA_INVALID, session, trace ); event.setMetadata( metadata ); event.setException( exception ); event.setRepository( repository ); listener.metadataInvalid( event ); }",
        "label":1
    },
    {
        "ins1CurCode":"commandLine.createArgument().setValue(getRecursive());  commandLine.createArgument().setValue(getVersionDateLabel());  commandLine.createArgument().setValue(getLogin());  commandLine.createArgument().setValue(getFileTimeStamp());  commandLine.createArgument().setValue(getWritableFiles());  commandLine.createArgument().setValue(getGetLocalCopy()); ",
        "ins1PreCode":"commandLine.createArgument().setValue(getRecursive());  commandLine.createArgument().setValue(getVersion()); ",
        "ins2PreCode":"protected Commandline buildCmdLine() { Commandline commandLine = new Commandline();   if (getVsspath() == null) { String msg = \"vsspath attribute must be set!\"; throw new BuildException(msg, getLocation()); }     commandLine.setExecutable(getSSCommand()); commandLine.createArgument().setValue(COMMAND_CHECKIN);   commandLine.createArgument().setValue(getVsspath());  commandLine.createArgument().setValue(getLocalpath());  commandLine.createArgument().setValue(getAutoresponse());  commandLine.createArgument().setValue(getRecursive());  commandLine.createArgument().setValue(getWritable());  commandLine.createArgument().setValue(getLogin());  commandLine.createArgument().setValue(getComment());  return commandLine;",
        "label":0
    },
    {
        "ins1CurCode":"String randomString = Long.toString(randomLong); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), null, \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument);",
        "ins1PreCode":"String randomString = Long.toString(randomLong); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument);",
        "ins2PreCode":"String randomString = Float.toString(randomFloat); IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), Collections.singletonMap(\"field\", randomString)); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), \"field\", \"field\", Type.AUTO, false); processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1CurCode":"void defaultPropertyAsFallback() { this.environment.getPropertySources() .addLast(new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"my.fallback\", \"foo\"))); this.initializer.postProcessEnvironment(this.environment, this.application);",
        "ins1PreCode":"void defaultPropertyAsFallback() { this.environment.getPropertySources().addLast( new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"my.fallback\", (Object) \"foo\"))); this.initializer.postProcessEnvironment(this.environment, this.application);",
        "ins2PreCode":"void defaultPropertyAsFallbackDuringFileParsing() { this.environment.getPropertySources().addLast(new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"spring.config.name\", (Object) \"testproperties\"))); this.initializer.postProcessEnvironment(this.environment, this.application);",
        "label":1
    },
    {
        "ins1CurCode":" int nRead = fillReadBuffer(block); updateLastRead(); ",
        "ins1PreCode":" int nRead = fillReadBuffer(block); lastRead = System.currentTimeMillis(); ",
        "ins2PreCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {  socketBufferHandler.configureReadBufferForRead(); ByteBuffer readBuffer = socketBufferHandler.getReadBuffer(); int remaining = readBuffer.remaining();   if (remaining >= len) { readBuffer.get(b, off, len); return len; }   if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining;        }   int nRead = fillReadBuffer(block);    if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead; }",
        "label":0
    },
    {
        "ins1CurCode":"protected void doIt(Collection selected) { Object stereo = getTarget(); Set<Object> oldSet = new HashSet<Object>(getSelected()); Set toBeRemoved = new HashSet<Object>(oldSet);  for (Object o : selected) { if (oldSet.contains(o)) { toBeRemoved.remove(o); } else { Model.getExtensionMechanismsHelper() .addBaseClass(stereo, o); } } for (Object o : toBeRemoved) { Model.getExtensionMechanismsHelper().removeBaseClass(stereo, o); }",
        "ins1PreCode":"protected void doIt(Collection selected) { Object state = getTarget(); assert (Model.getFacade().isAState(state));  Collection oldOnes = new ArrayList(Model.getFacade() .getDeferrableEvents(state)); Collection toBeRemoved = new ArrayList(oldOnes); for (Object o : selected) { if (oldOnes.contains(o)) { toBeRemoved.remove(o); } else { Model.getStateMachinesHelper().addDeferrableEvent(state, o); } } for (Object o : toBeRemoved) { Model.getStateMachinesHelper().removeDeferrableEvent(state, o); }",
        "ins2PreCode":"protected void doIt(Collection selected) { Object stereo = getTarget(); Set<Object> oldSet = new HashSet<Object>(getSelected()); Set toBeRemoved = new HashSet<Object>(oldSet);  for (Object o : selected) { if (oldSet.contains(o)) { toBeRemoved.remove(o); } else { Model.getExtensionMechanismsHelper() .addBaseClass(stereo, o); } } for (Object o : toBeRemoved) { Model.getExtensionMechanismsHelper().removeBaseClass(stereo, o); }",
        "label":0
    },
    {
        "ins1CurCode":"Launcher remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, false); Launcher decorated = remoteLauncher.decorateByEnv(new EnvVars()); assertFalse(decorated.isUnix()); remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, true); decorated = remoteLauncher.decorateByEnv(new EnvVars()); assertTrue(decorated.isUnix());",
        "ins1PreCode":"Launcher remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, false); Launcher decorated = remoteLauncher.decorateByEnv(new EnvVars()); assertEquals(false, decorated.isUnix()); remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, true); decorated = remoteLauncher.decorateByEnv(new EnvVars()); assertEquals(true, decorated.isUnix());",
        "ins2PreCode":"Launcher remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, false); Launcher decorated = remoteLauncher.decorateByPrefix(\"test\"); assertEquals(false, decorated.isUnix()); remoteLauncher = new Launcher.RemoteLauncher(listener, FilePath.localChannel, true); decorated = remoteLauncher.decorateByPrefix(\"test\"); assertEquals(true, decorated.isUnix());",
        "label":1
    },
    {
        "ins1CurCode":"PublishSubject<Integer> ps = PublishSubject.create();  final AtomicReference<Observable<Integer>> inner = new AtomicReference<>(); ",
        "ins1PreCode":"PublishSubject<Integer> ps = PublishSubject.create();  final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>(); ",
        "ins2PreCode":"PublishSubject<Integer> ps = PublishSubject.create();  final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void removeObject(R rowKey, C columnKey) { int rowIndex = getRowIndex(rowKey);",
        "ins1PreCode":"public void removeObject(Comparable rowKey, Comparable columnKey) { int rowIndex = getRowIndex(rowKey);",
        "ins2PreCode":"public void removeValue(R rowKey, C columnKey) { setValue(null, rowKey, columnKey);   boolean allNull = true; int rowIndex = getRowIndex(rowKey); DefaultKeyedValues row = this.rows.get(rowIndex);  for (int item = 0, itemCount = row.getItemCount(); item < itemCount; item++) { if (row.getValue(item) != null) { allNull = false; break; } }  if (allNull) { this.rowKeys.remove(rowIndex); this.rows.remove(rowIndex); }   allNull = true;   for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0 && row.getValue(columnIndex) != null) { allNull = false; break; } }  if (allNull) { for (int item = 0, itemCount = this.rows.size(); item < itemCount; item++) { row = this.rows.get(item); int columnIndex = row.getIndex(columnKey); if (columnIndex >= 0) { row.removeValue(columnIndex); } } this.columnKeys.remove(columnKey); }",
        "label":0
    },
    {
        "ins1CurCode":"assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );  updateCheckManager.touch( a, remoteRepository, null ); ",
        "ins1PreCode":"assertTrue( updateCheckManager.isUpdateRequired( a, remoteRepository ) );  updateCheckManager.touch( a, remoteRepository ); ",
        "ins2PreCode":"file.getParentFile().mkdirs(); file.createNewFile(); updateCheckManager.touch( a, remoteRepository ); ",
        "label":1
    },
    {
        "ins1CurCode":"return v == 2 ? Observable.<Integer>empty() : Observable.range(1, 2); } }, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(to); ",
        "ins1PreCode":"return v == 2 ? Observable.<Integer>empty() : Observable.range(1, 2); } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(to); ",
        "ins2PreCode":"return v == 2 ? Observable.just(3) : Observable.range(1, 2); } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(to); ",
        "label":1
    },
    {
        "ins1CurCode":"void noFile(CapturedOutput output) { this.loggingSystem.beforeInitialize();",
        "ins1PreCode":"public void noFile() { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, null); this.logger.info(\"Hello world\"); String output = this.output.toString().trim(); assertThat(output).contains(\"Hello world\").doesNotContain(\"Hidden\");",
        "ins2PreCode":"public void noFile() { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, null); this.logger.info(\"Hello world\"); String output = this.output.toString().trim(); Configuration configuration = this.loggingSystem.getConfiguration();",
        "label":1
    },
    {
        "ins1CurCode":"if (field.isRepeated()) { if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) { if (field.isMapField()) { fields[i] = new MapFieldAccessor(",
        "ins1PreCode":"if (field.isRepeated()) { if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) { if (field.isMapField() && isMapFieldEnabled(field)) { fields[i] = new MapFieldAccessor(",
        "ins2PreCode":"public FieldAccessorTable ensureFieldAccessorsInitialized( Class<? extends GeneratedMessage> messageClass, Class<? extends Builder> builderClass) { if (initialized) { return this; } synchronized (this) { if (initialized) { return this; } int fieldsSize = fields.length; for (int i = 0; i < fieldsSize; i++) { FieldDescriptor field = descriptor.getFields().get(i); String containingOneofCamelCaseName = null; if (field.getContainingOneof() != null) { containingOneofCamelCaseName = camelCaseNames[fieldsSize + field.getContainingOneof().getIndex()]; } if (field.isRepeated()) { if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) { if (field.isMapField() && isMapFieldEnabled(field)) { fields[i] = new MapFieldAccessor( field, camelCaseNames[i], messageClass, builderClass); } else { fields[i] = new RepeatedMessageFieldAccessor( field, camelCaseNames[i], messageClass, builderClass); } } else if (field.getJavaType() == FieldDescriptor.JavaType.ENUM) { fields[i] = new RepeatedEnumFieldAccessor( field, camelCaseNames[i], messageClass, builderClass); } else { fields[i] = new RepeatedFieldAccessor( field, camelCaseNames[i], messageClass, builderClass); } } else { if (field.getJavaType() == FieldDescriptor.JavaType.MESSAGE) { fields[i] = new SingularMessageFieldAccessor( field, camelCaseNames[i], messageClass, builderClass, containingOneofCamelCaseName); } else if (field.getJavaType() == FieldDescriptor.JavaType.ENUM) { fields[i] = new SingularEnumFieldAccessor( field, camelCaseNames[i], messageClass, builderClass, containingOneofCamelCaseName); } else if (field.getJavaType() == FieldDescriptor.JavaType.STRING) { fields[i] = new SingularStringFieldAccessor( field, camelCaseNames[i], messageClass, builderClass, containingOneofCamelCaseName); } else { fields[i] = new SingularFieldAccessor( field, camelCaseNames[i], messageClass, builderClass, containingOneofCamelCaseName); } } }  int oneofsSize = oneofs.length; for (int i = 0; i < oneofsSize; i++) { oneofs[i] = new OneofAccessor( descriptor, camelCaseNames[i + fieldsSize], messageClass, builderClass); } initialized = true; camelCaseNames = null; return this; }",
        "label":0
    },
    {
        "ins1CurCode":"void loadMetadataInvalidJson() throws Exception { CloseableHttpResponse response = mock(CloseableHttpResponse.class);",
        "ins1PreCode":"public void loadMetadataInvalidJson() throws Exception { CloseableHttpResponse response = mock(CloseableHttpResponse.class);",
        "ins2PreCode":"public void loadMetadataNoContent() throws Exception { CloseableHttpResponse response = mock(CloseableHttpResponse.class);",
        "label":1
    },
    {
        "ins1CurCode":"public static <@NonNull T> Flowable<T> concat( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins1PreCode":"public static <T> Flowable<T> concat( @NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Observable<T> mergeDelayError( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "label":0
    },
    {
        "ins1CurCode":"+ dest.getAbsolutePath());  try (XZInputStream zIn = new XZInputStream(srcResource.getInputStream()); OutputStream out = Files.newOutputStream(dest.toPath())) { byte[] buffer = new byte[BUFFER_SIZE];",
        "ins1PreCode":"+ dest.getAbsolutePath());  OutputStream out = null; XZInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new XZInputStream(fis); byte[] buffer = new byte[BUFFER_SIZE]; int count = 0; do { out.write(buffer, 0, count); count = zIn.read(buffer, 0, buffer.length); } while (count != -1); } catch (IOException ioe) { String msg = \"Problem expanding xz \" + ioe.getMessage(); throw new BuildException(msg, ioe, getLocation()); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn); }",
        "ins2PreCode":"log(\"Expanding \" + srcResource.getName() + \" to \" + dest.getAbsolutePath());  OutputStream out = null; GZIPInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new GZIPInputStream(fis); byte[] buffer = new byte[BUFFER_SIZE]; int count = 0; do { out.write(buffer, 0, count); count = zIn.read(buffer, 0, buffer.length); } while (count != -1); } catch (IOException ioe) { String msg = \"Problem expanding gzip \" + ioe.getMessage(); throw new BuildException(msg, ioe, getLocation()); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn); }",
        "label":0
    },
    {
        "ins1CurCode":"void errorEndpointIsUsedWithEndpoint() { this.runner.run(withWebTestClient((client) -> { Map<String, ?> body = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON) .exchangeToMono(toResponseBody()).block(); assertThat(body).hasEntrySatisfying(\"exception\",",
        "ins1PreCode":"void errorEndpointIsUsedWithEndpoint() { this.runner.run(withWebTestClient((client) -> { ClientResponse response = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON).exchange() .block(); Map<String, ?> body = getResponseBody(response); assertThat(body).hasEntrySatisfying(\"exception\",",
        "ins2PreCode":"this.runner.withPropertyValues(\"server.error.include-stacktrace=always\", \"server.error.include-message=always\") .run(withWebTestClient((client) -> { ClientResponse response = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON) .exchange().block(); Map<String, ?> body = getResponseBody(response); assertThat(body).hasEntrySatisfying(\"message\",",
        "label":1
    },
    {
        "ins1CurCode":"public LibraryPropertiesDialogView(BasePanel panel) { this.panel = panel;  ViewLoader.view(this) .load() .setAsDialogPane(this);  setResultConverter(btn -> { if (btn == ButtonType.OK) { viewModel.storeSettings(); }",
        "ins1PreCode":"public LibraryPropertiesDialogView(BasePanel panel, DialogService dialogService) { this.dialogService = dialogService; this.panel = panel; ViewLoader.view(this) .load() .setAsDialogPane(this);  setResultConverter(btn -> { if (btn == ButtonType.OK) { storeSettings(); }",
        "ins2PreCode":"public ManageCitationsDialogView(OOBibBase ooBase) { this.ooBase = ooBase;   ViewLoader.view(this) .load() .setAsDialogPane(this);  setResultConverter(btn -> { if (btn == ButtonType.OK) { viewModel.storeSettings(); } return null; });  setTitle(Localization.lang(\"Manage citations\"));",
        "label":0
    },
    {
        "ins1CurCode":"assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals( 0, result.getRepeatedFieldCount( result.getDescriptorForType().findFieldByName(\"repeated_foreign_message\")));",
        "ins1PreCode":"assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals(result.getRepeatedFieldCount(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")), 0);",
        "ins2PreCode":"public void testDynamicRepeatedMessageNull() throws Exception { Descriptors.Descriptor descriptor = TestRequired.getDescriptor(); DynamicMessage result = DynamicMessage.newBuilder(TestAllTypes.getDescriptor()) .mergeFrom(DynamicMessage.newBuilder(MERGE_SOURCE).build()) .build();  assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals(result.getRepeatedFieldCount(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")), 0);",
        "label":0
    },
    {
        "ins1CurCode":"break; default: jj_la1[38] = jj_gen; ;",
        "ins1PreCode":"break; default: jj_la1[36] = jj_gen; break label_15;",
        "ins2PreCode":"break; default: jj_la1[41] = jj_gen; break label_16;",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32FieldMap().keySet()));",
        "ins1PreCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "label":1
    },
    {
        "ins1CurCode":"public void testFileEncodingUtf8() throws URISyntaxException { Path texFile = Path.of(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI()); ",
        "ins1PreCode":"public void testFileEncodingUtf8() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI()); ",
        "ins2PreCode":"public void testFileEncodingIso88591() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI()); ",
        "label":1
    },
    {
        "ins1CurCode":"public CategoryDataset<String, String> createDataset2() {  DefaultCategoryDataset<String, String> result = new DefaultCategoryDataset<>(); ",
        "ins1PreCode":"public CategoryDataset createDataset2() {  DefaultCategoryDataset result = new DefaultCategoryDataset(); ",
        "ins2PreCode":"public CategoryDataset createDataset1() {  DefaultCategoryDataset result = new DefaultCategoryDataset(); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testPseudoTahoeRefid() { assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject())); ",
        "ins1PreCode":"public void testPseudoTahoeRefid() { Assume.assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject())); ",
        "ins2PreCode":"public void testPseudoTahoeNested() { Assume.assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject())); ",
        "label":1
    },
    {
        "ins1CurCode":"WebXml desc = (WebXml) digester.parse( new File(\"test/webapp/WEB-INF/web.xml\")); Assert.assertEquals(\"5.0\", desc.getVersion()); Assert.assertEquals(0, handler.getErrors().size());",
        "ins1PreCode":"WebXml desc = (WebXml) digester.parse( new File(\"test/webapp/WEB-INF/web.xml\")); Assert.assertEquals(\"4.0\", desc.getVersion()); Assert.assertEquals(0, handler.getErrors().size());",
        "ins2PreCode":"public void testWebapp_2_5() throws Exception { XmlErrorHandler handler = new XmlErrorHandler(); Digester digester = DigesterFactory.newDigester( true, true, new WebRuleSet(false), true); digester.setErrorHandler(handler); digester.push(new WebXml()); WebXml desc = (WebXml) digester.parse( new File(\"test/webapp-2.5/WEB-INF/web.xml\")); Assert.assertEquals(\"2.5\", desc.getVersion()); Assert.assertEquals(0, handler.getErrors().size()); Assert.assertEquals(0, handler.getWarnings().size());",
        "label":0
    },
    {
        "ins1CurCode":"void testHtmlFormat() { String expectedCitation = \"  <div class=\\\"csl-entry\\\">\\n\" +",
        "ins1PreCode":"public void testHtmlFormat() { String expectedCitation = \"  <div class=\\\"csl-entry\\\">\\n\" +",
        "ins2PreCode":"public void testTextFormat() { String expectedCitation = \"[1]B. Smith, B. Jones, and J. Williams, \u201cTitle of the test entry,\u201d BibTeX Journal, vol. 34, no. 3, pp. 45\u201367, Jul. 2016.\\n\";",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(v); } }, true, 2, ImmediateThinScheduler.INSTANCE) .observeOn(Schedulers.computation())",
        "ins1PreCode":"return Flowable.just(v); } }, 2, true, ImmediateThinScheduler.INSTANCE) .observeOn(Schedulers.computation())",
        "ins2PreCode":"public void boundaryFusionDelayError() { Flowable.range(1, 10000) .observeOn(Schedulers.single()) .map(new Function<Integer, String>() { @Override public String apply(Integer t) throws Exception { String name = Thread.currentThread().getName(); if (name.contains(\"RxSingleScheduler\")) { return \"RxSingleScheduler\"; } return name; } }) .concatMapDelayError(new Function<String, Publisher<? extends Object>>() { @Override public Publisher<? extends Object> apply(String v) throws Exception { return Flowable.just(v); } }) .observeOn(Schedulers.computation()) .distinct() .test() .awaitDone(5, TimeUnit.SECONDS) .assertResult(\"RxSingleScheduler\");",
        "label":0
    },
    {
        "ins1CurCode":"public void collectorFailureDoesNotResultInTwoErrorEmissions() { try { final List<Throwable> list = new CopyOnWriteArrayList<>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "ins1PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissions() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "ins2PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsFlowable() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list));",
        "label":1
    },
    {
        "ins1CurCode":"  bindings.add(variable, getDocValueSource(variable, lookup)); }",
        "ins1PreCode":"  final ValueSource valueSource = getDocValueSource(variable, lookup); bindings.add(variable, valueSource.asDoubleValuesSource()); }",
        "ins2PreCode":"bindFromParams(vars, bindings, variable); } else { final ValueSource valueSource = getDocValueSource(variable, lookup); bindings.add(variable, valueSource.asDoubleValuesSource()); }",
        "label":1
    },
    {
        "ins1CurCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Test, Second Keyword, Third Keyword\"), entry.getField(StandardField.KEYWORDS));",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Test, Second Keyword, Third Keyword\"), entry.getField(\"keywords\"));",
        "ins2PreCode":" assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1CurCode":"  if (ACTIVITY_CHECK) { accessCount = new AtomicInteger(); }",
        "ins1PreCode":"  fireSessionEvent(Session.SESSION_ACTIVATED_EVENT, null);  ",
        "ins2PreCode":"public void passivate() {   fireSessionEvent(Session.SESSION_PASSIVATED_EVENT, null);   HttpSessionEvent event = null; String keys[] = keys(); for (int i = 0; i < keys.length; i++) { Object attribute = attributes.get(keys[i]); if (attribute instanceof HttpSessionActivationListener) { if (event == null) event = new HttpSessionEvent(getSession()); try { ((HttpSessionActivationListener)attribute) .sessionWillPassivate(event); } catch (Throwable t) { manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t); } } } ",
        "label":0
    },
    {
        "ins1CurCode":"public static <@NonNull T> Single<Boolean> sequenceEqual( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "ins1PreCode":"public static <T> Single<Boolean> sequenceEqual( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2,",
        "ins2PreCode":"public static <T> Single<Boolean> sequenceEqual(@NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull BiPredicate<? super T, ? super T> isEqual, int bufferSize) {",
        "label":0
    },
    {
        "ins1CurCode":"byte[] bigBytes = getTestBytes(2048 * 1024, 113344L); int start = 512 * 1024 - 3333; int end = 512 * 1024 + 7777; ByteString concreteSubstring = ByteString.copyFrom(bigBytes).substring(start, end); boolean ok = true; for (int i = start; ok && i < end; ++i) { ok = (bigBytes[i] == concreteSubstring.byteAt(i - start)); } assertTrue(\"Concrete substring didn't capture the right bytes\", ok);  ByteString literalString = ByteString.copyFrom(bigBytes, start, end - start); assertEquals(\"Substring must be equal to literal string\", literalString, concreteSubstring); assertEquals( \"Substring must have same hashcode as literal string\", literalString.hashCode(), concreteSubstring.hashCode());",
        "ins1PreCode":"byte[] bigBytes = getTestBytes(2048 * 1024, 113344L); int start = 512 * 1024 - 3333; int end   = 512 * 1024 + 7777; ByteString concreteSubstring = ByteString.copyFrom(bigBytes).substring(start, end); boolean ok = true; for (int i = start; ok && i < end; ++i) { ok = (bigBytes[i] == concreteSubstring.byteAt(i - start)); } assertTrue(\"Concrete substring didn't capture the right bytes\", ok);  ByteString literalString = ByteString.copyFrom(bigBytes, start, end - start); assertTrue(\"Substring must be equal to literal string\", concreteSubstring.equals(literalString)); assertEquals(\"Substring must have same hashcode as literal string\", literalString.hashCode(), concreteSubstring.hashCode());",
        "ins2PreCode":"public void testSubstringParity() { byte[] bigBytes = getTestBytes(2048 * 1024, 113344L); int start = 512 * 1024 - 3333; int end   = 512 * 1024 + 7777; ByteString concreteSubstring = ByteString.copyFrom(bigBytes).substring(start, end); boolean ok = true; for (int i = start; ok && i < end; ++i) { ok = (bigBytes[i] == concreteSubstring.byteAt(i - start)); } assertTrue(\"Concrete substring didn't capture the right bytes\", ok);  ByteString literalString = ByteString.copyFrom(bigBytes, start, end - start); assertTrue(\"Substring must be equal to literal string\", concreteSubstring.equals(literalString)); assertEquals(\"Substring must have same hashcode as literal string\", literalString.hashCode(), concreteSubstring.hashCode());",
        "label":0
    },
    {
        "ins1CurCode":"void adaptShouldSupportUnderscore() { ConfigurationPropertyName name = ConfigurationPropertyName.adapt(\"f-_o.b_r\", '.');",
        "ins1PreCode":"public void adaptShouldSupportUnderscore() { ConfigurationPropertyName name = ConfigurationPropertyName.adapt(\"f-_o.b_r\", '.');",
        "ins2PreCode":"public void adaptShouldSupportMixedCase() { ConfigurationPropertyName name = ConfigurationPropertyName.adapt(\"fOo.bAr\", '.');",
        "label":1
    },
    {
        "ins1CurCode":"@Test public void hashSerialization() { HashData td = new HashData();",
        "ins1PreCode":"@Test public void hashSerialization() throws Exception { HashData td = new HashData();",
        "ins2PreCode":"@Test public void treeSerialization() throws Exception { TreeData td = new TreeData();",
        "label":1
    },
    {
        "ins1CurCode":"public void testDateConstructor1() { TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Locale locale = Locale.UK; Day d1 = new Day(new Date(1078099199999L), zone, locale); Day d2 = new Day(new Date(1078099200000L), zone, locale);  assertEquals(MonthConstants.FEBRUARY, d1.getMonth()); assertEquals(1078099199999L, d1.getLastMillisecond(cal));  assertEquals(MonthConstants.MARCH, d2.getMonth()); assertEquals(1078099200000L, d2.getFirstMillisecond(cal));",
        "ins1PreCode":" assertEquals(MonthConstants.FEBRUARY, d1.getMonth()); assertEquals(1078099199999L, d1.getLastMillisecond(zone));  assertEquals(MonthConstants.MARCH, d2.getMonth()); assertEquals(1078099200000L, d2.getFirstMillisecond(zone));",
        "ins2PreCode":" assertEquals(MonthConstants.FEBRUARY, d1.getMonth()); assertEquals(1078091999999L, d1.getLastMillisecond(zone));  assertEquals(MonthConstants.MARCH, d2.getMonth()); assertEquals(1078092000000L, d2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1CurCode":"} for (int i = 0; i < includePatterns.length; i++) { if (includePatterns[i].matchPath(name, isCaseSensitive())) { return true;",
        "ins1PreCode":"} for (int i = 0; i < includePatterns.length; i++) { if (matchPath(includePatterns[i], name, isCaseSensitive())) { return true;",
        "ins2PreCode":"} for (int i = 0; i < excludePatterns.length; i++) { if (matchPath(excludePatterns[i], name, isCaseSensitive())) { return true;",
        "label":1
    },
    {
        "ins1CurCode":"  if (Model.getUmlFactory().isContainmentValid( Model.getMetaTypes().getAttribute(), getOwner())) { addFig(new FigAttributesCompartment( getOwner(), DEFAULT_COMPARTMENT_BOUNDS, getSettings())); }",
        "ins1PreCode":" addFig(getOperationsFig()); addFig(getBorderFig());   setFilled(true); setFillColor(FILL_COLOR); setLineColor(LINE_COLOR); setLineWidth(LINE_WIDTH); ",
        "ins2PreCode":"private void constructFigs(Rectangle bounds) {   enableSizeChecking(false); setSuppressCalcBounds(true);  getStereotypeFig().setKeyword(\"stereotype\"); getStereotypeFig().setVisible(true);    getNameFig().setTopMargin( getStereotypeFig().getMinimumSize().height);  addFig(getBigPort()); addFig(getNameFig());  addFig(getStereotypeFig());      addFig(getBorderFig());   setFilled(true); setFillColor(FILL_COLOR); setLineColor(LINE_COLOR); setLineWidth(LINE_WIDTH);   if (bounds != null) { setLocation(bounds.x, bounds.y); }  setSuppressCalcBounds(false); setBounds(getBounds());",
        "label":0
    },
    {
        "ins1CurCode":"Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for (int i = 0; i < 100; ++i) { sb.append(\"a string\"); } String results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertNotNull(results); assertEquals(sb.toString(), results); assertEquals(0, context.getBuffer().position());",
        "ins1PreCode":"Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1CurCode":"fail(); } catch (RuntimeException expected) { assertThat(expected).hasCauseThat().isInstanceOf(SomeOtherCheckedException.class); }",
        "ins1PreCode":"fail(); } catch (RuntimeException expected) { assertThat(expected.getCause()).isInstanceOf(SomeOtherCheckedException.class); }",
        "ins2PreCode":"public void testPropagateIfInstanceOf_UncheckedThrown() throws SomeCheckedException { Sample sample = new Sample() { @Override public void oneDeclared() throws SomeCheckedException { try { methodThatThrowsUnchecked(); } catch (Throwable t) { Throwables.propagateIfInstanceOf(t, SomeCheckedException.class); throw Throwables.propagate(t); } } };   try { sample.oneDeclared(); fail(); } catch (SomeUncheckedException expected) { }",
        "label":0
    },
    {
        "ins1CurCode":"+ \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"state_timestamp\\\":1369795079}\"); this.initializer.postProcessEnvironment(this.context.getEnvironment(), null); assertThat(getProperty(\"vcap.application.instance_id\")).isEqualTo(\"bb7935245adf3e650dfb7c58a06e9ece\");",
        "ins1PreCode":"+ \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"state_timestamp\\\":1369795079}\"); this.initializer.postProcessEnvironment(this.context.getEnvironment(), null); assertThat(this.context.getEnvironment().getProperty(\"vcap.application.instance_id\")) .isEqualTo(\"bb7935245adf3e650dfb7c58a06e9ece\");",
        "ins2PreCode":"void testNullApplicationProperties() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"VCAP_APPLICATION={\\\"application_users\\\":null,\" + \"\\\"instance_id\\\":\\\"bb7935245adf3e650dfb7c58a06e9ece\\\",\" + \"\\\"instance_index\\\":0,\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"foo\\\",\\\"uris\\\":[\\\"foo.cfapps.io\\\"],\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"host\\\":\\\"0.0.0.0\\\",\\\"port\\\":61034,\" + \"\\\"limits\\\":{\\\"mem\\\":128,\\\"disk\\\":1024,\\\"fds\\\":16384},\" + \"\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"dsyerenv\\\",\\\"uris\\\":[\\\"dsyerenv.cfapps.io\\\"],\" + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"state_timestamp\\\":1369795079}\"); this.initializer.postProcessEnvironment(this.context.getEnvironment(), null); assertThat(getProperty(\"vcap\")).isNull();",
        "label":0
    },
    {
        "ins1CurCode":"Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toObservable();  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"aa\");",
        "ins1PreCode":"Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toObservable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\");",
        "ins2PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc);  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "label":1
    },
    {
        "ins1CurCode":"}  DebounceEmitter<T> de = new DebounceEmitter<>(t, idx, this); timer = de;",
        "ins1PreCode":"}  DebounceEmitter<T> de = new DebounceEmitter<T>(t, idx, this); timer = de;",
        "ins2PreCode":"}  DebounceEmitter<T> de = new DebounceEmitter<T>(t, idx, this); timer = de;",
        "label":1
    },
    {
        "ins1CurCode":"final BytesToBytesMap.Location loc = map.lookup( key, Platform.BYTE_ARRAY_OFFSET, key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, Platform.BYTE_ARRAY_OFFSET, key.length, value, Platform.BYTE_ARRAY_OFFSET, value.length ));   Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } }  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined());",
        "ins1PreCode":"final BytesToBytesMap.Location loc = map.lookup( key, BYTE_ARRAY_OFFSET, key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, BYTE_ARRAY_OFFSET, key.length, value, BYTE_ARRAY_OFFSET, value.length ));   Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } }  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined());",
        "ins2PreCode":"final BytesToBytesMap.Location loc = map.lookup( key, BYTE_ARRAY_OFFSET, key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, BYTE_ARRAY_OFFSET, key.length, value, BYTE_ARRAY_OFFSET, value.length ));   Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } } for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined());",
        "label":1
    },
    {
        "ins1CurCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views); result.sort(new Comparator<View>() { @Override",
        "ins1PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<>(views); Collections.sort(result, new Comparator<View>() { @Override",
        "ins2PreCode":"public List<View> sort(@Nonnull List<? extends View> views) { List<View> result = new ArrayList<View>(views); Collections.sort(result, new Comparator<View>() { @Override",
        "label":0
    },
    {
        "ins1CurCode":"public void onNextOnCompleteRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<>();  final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts); ",
        "ins1PreCode":"public void onNextOnCompleteRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts); ",
        "ins2PreCode":"public void onNextOnErrorRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts); ",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(1); } }, false, 16) .test()",
        "ins1PreCode":"return Flowable.just(1); } }, 16, false) .test()",
        "ins2PreCode":"return Flowable.just(1); } }, 16, false, ImmediateThinScheduler.INSTANCE) .test()",
        "label":0
    },
    {
        "ins1CurCode":" final Subscriber<Integer> subscriber = TestHelper.mockSubscriber(); TestSubscriber<Integer> ts = new TestSubscriber<>(subscriber); ",
        "ins1PreCode":" final Subscriber<Integer> subscriber = TestHelper.mockSubscriber(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber); ",
        "ins2PreCode":" final Observer<Integer> observer = TestHelper.mockObserver(); TestObserver<Integer> to = new TestObserver<Integer>(observer); ",
        "label":1
    },
    {
        "ins1CurCode":"String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit)); } long offset = getArrayBaseOffset() + index; final long offsetLimit = getArrayBaseOffset() + limit; if (state != COMPLETE) {        if (offset >= offsetLimit) { return state; } int byte1 = (byte) state;  if (byte1 < (byte) 0xE0) {     if (byte1 < (byte) 0xC2  || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) { return MALFORMED; } } else if (byte1 < (byte) 0xF0) {    int byte2 = (byte) ~(state >> 8); if (byte2 == 0) { byte2 = UnsafeUtil.getByte(bytes, offset++); if (offset >= offsetLimit) { return incompleteStateFor(byte1, byte2); } } if (byte2 > (byte) 0xBF  || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)  || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)  || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) { return MALFORMED; } } else {    int byte2 = (byte) ~(state >> 8); int byte3 = 0; if (byte2 == 0) { byte2 = UnsafeUtil.getByte(bytes, offset++); if (offset >= offsetLimit) { return incompleteStateFor(byte1, byte2); } } else { byte3 = (byte) (state >> 16); } if (byte3 == 0) { byte3 = UnsafeUtil.getByte(bytes, offset++); if (offset >= offsetLimit) { return incompleteStateFor(byte1, byte2, byte3); } }      if (byte2 > (byte) 0xBF     || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0  || byte3 > (byte) 0xBF  || UnsafeUtil.getByte(bytes, offset++) > (byte) 0xBF) { return MALFORMED;",
        "ins1PreCode":"String.format(\"Array length=%d, index=%d, limit=%d\", bytes.length, index, limit)); } long offset = ARRAY_BASE_OFFSET + index; final long offsetLimit = ARRAY_BASE_OFFSET + limit; if (state != COMPLETE) {        if (offset >= offsetLimit) { return state; } int byte1 = (byte) state;  if (byte1 < (byte) 0xE0) {     if (byte1 < (byte) 0xC2  || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) { return MALFORMED; } } else if (byte1 < (byte) 0xF0) {    int byte2 = (byte) ~(state >> 8); if (byte2 == 0) { byte2 = UNSAFE.getByte(bytes, offset++); if (offset >= offsetLimit) { return incompleteStateFor(byte1, byte2); } } if (byte2 > (byte) 0xBF  || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)  || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)  || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) { return MALFORMED; } } else {    int byte2 = (byte) ~(state >> 8); int byte3 = 0; if (byte2 == 0) { byte2 = UNSAFE.getByte(bytes, offset++); if (offset >= offsetLimit) { return incompleteStateFor(byte1, byte2); } } else { byte3 = (byte) (state >> 16); } if (byte3 == 0) { byte3 = UNSAFE.getByte(bytes, offset++); if (offset >= offsetLimit) { return incompleteStateFor(byte1, byte2, byte3); } }      if (byte2 > (byte) 0xBF     || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0  || byte3 > (byte) 0xBF  || UNSAFE.getByte(bytes, offset++) > (byte) 0xBF) { return MALFORMED;",
        "ins2PreCode":"if (byte1 < (byte) 0xC2  || UNSAFE.getByte(address++) > (byte) 0xBF) { return MALFORMED; } } else if (byte1 < (byte) 0xF0) {    int byte2 = (byte) ~(state >> 8); if (byte2 == 0) { byte2 = UNSAFE.getByte(address++); if (address >= addressLimit) { return incompleteStateFor(byte1, byte2); } } if (byte2 > (byte) 0xBF  || (byte1 == (byte) 0xE0 && byte2 < (byte) 0xA0)  || (byte1 == (byte) 0xED && byte2 >= (byte) 0xA0)  || UNSAFE.getByte(address++) > (byte) 0xBF) { return MALFORMED; } } else {    int byte2 = (byte) ~(state >> 8); int byte3 = 0; if (byte2 == 0) { byte2 = UNSAFE.getByte(address++); if (address >= addressLimit) { return incompleteStateFor(byte1, byte2); } } else { byte3 = (byte) (state >> 16); } if (byte3 == 0) { byte3 = UNSAFE.getByte(address++); if (address >= addressLimit) { return incompleteStateFor(byte1, byte2, byte3); } }      if (byte2 > (byte) 0xBF     || (((byte1 << 28) + (byte2 - (byte) 0x90)) >> 30) != 0  || byte3 > (byte) 0xBF  || UNSAFE.getByte(address++) > (byte) 0xBF) { return MALFORMED;",
        "label":1
    },
    {
        "ins1CurCode":"public void testExceedMaxActiveStreams02() throws Exception {  LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.ALL); try {     enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendRst(3, Http2Error.NO_ERROR.getCode());   parser.readFrame(true); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace();   sendWindowUpdate(0, (1 << 31) - 2);   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace()); } finally { LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.INFO); }",
        "ins1PreCode":"public void testExceedMaxActiveStreams02() throws Exception {   enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendRst(3, Http2Error.NO_ERROR.getCode());   parser.readFrame(true); Assert.assertEquals(\"3-RST-[8]\\n\", output.getTrace()); output.clearTrace();   sendWindowUpdate(0, (1 << 31) - 2);   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "ins2PreCode":"public void testExceedMaxActiveStreams01() throws Exception {  enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendWindowUpdate(0, (1 << 31) - 2);  sendWindowUpdate(3, (1 << 31) - 8193);   while (!output.getTrace().contains(\"3-EndOfStream\")) { parser.readFrame(true); } output.clearTrace();   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "label":0
    },
    {
        "ins1CurCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Short.class.getCanonicalName()); }",
        "ins1PreCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Short.class.getCanonicalName()); }",
        "ins2PreCode":"} else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Integer.class.getCanonicalName()); }",
        "label":1
    },
    {
        "ins1CurCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { return false; }",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders();",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders();",
        "label":1
    },
    {
        "ins1CurCode":"System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = CollectionUtils.iteratorToList(launcher.getClassPathArchivesIterator()); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins1PreCode":"System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins2PreCode":"void testUserSpecifiedJarPathWithDot() throws Exception { System.setProperty(\"loader.path\", \"./jars/app.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); launcher.launch(new String[0]); waitFor(\"Hello World\");",
        "label":0
    },
    {
        "ins1CurCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins1PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jjtree.reset(); jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1CurCode":"return Observable.just(Thread.currentThread().getName()); } }, false, 2, Schedulers.single()) .test()",
        "ins1PreCode":"return Observable.just(Thread.currentThread().getName()); } }, 2, false, Schedulers.single()) .test()",
        "ins2PreCode":"return Observable.just(Thread.currentThread().getName()); } }, 2, true, Schedulers.single()) .test()",
        "label":1
    },
    {
        "ins1CurCode":"void parseAddsEscapedClosingBracketToFieldValue() throws IOException { ParserResult result = parser",
        "ins1PreCode":"public void parseAddsEscapedClosingBracketToFieldValue() throws IOException { ParserResult result = parser",
        "ins2PreCode":"public void parseRecognizesEntryWithAtSymbolInQuotationMarks() throws IOException { ParserResult result = parser",
        "label":1
    },
    {
        "ins1CurCode":"public void drainMaxLoopMissingBackpressureWithResource() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32); q.offer(1);",
        "ins1PreCode":"public void drainMaxLoopMissingBackpressureWithResource() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 0; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1);",
        "ins2PreCode":"public void drainMaxLoopDontAccept() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 1; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1);",
        "label":1
    },
    {
        "ins1CurCode":"ZipFileSet fs = new ZipFileSet(); fs.setFile(deploymentDescriptor); fs.setFullpath(XML_DESCRIPTOR_PATH); super.addFileset(fs);",
        "ins1PreCode":"ZipFileSet fs = new ZipFileSet(); fs.setFile(deploymentDescriptor); fs.setFullpath(\"WEB-INF/web.xml\"); super.addFileset(fs);",
        "ins2PreCode":"ZipFileSet fs = new ZipFileSet(); fs.setFile(deploymentDescriptor); fs.setFullpath(\"META-INF/application.xml\"); super.addFileset(fs);",
        "label":1
    },
    {
        "ins1CurCode":"public void emptyXMap() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ",
        "ins1PreCode":"public void emptyXMap() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "ins2PreCode":"public void mapperCrashes() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"void testWithNbibFile() throws IOException, URISyntaxException { Path file = Paths.get(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI());",
        "ins1PreCode":"public void testWithNbibFile() throws IOException, URISyntaxException { Path file = Paths.get(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI());",
        "ins2PreCode":"public void testWithMultipleEntries() throws IOException, URISyntaxException { Path file = Paths",
        "label":1
    },
    {
        "ins1CurCode":"public void backpressureWithSelectorDelay() { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.range(1, Flowable.bufferSize() * 2)",
        "ins1PreCode":"public void backpressureWithSelectorDelay() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(1, Flowable.bufferSize() * 2)",
        "ins2PreCode":"public void backpressureWithSelectorDelayAndSubscriptionDelay() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(1, Flowable.bufferSize() * 2)",
        "label":1
    },
    {
        "ins1CurCode":"throws IOException { Validate.notNull( input, \"input cannot be null\" ); ",
        "ins1PreCode":"throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input stream missing\" ); }",
        "ins2PreCode":"throws IOException { if ( input == null ) { throw new IllegalArgumentException( \"input reader missing\" ); }",
        "label":1
    },
    {
        "ins1CurCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot<String> plot = new XYPlot<>(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "ins1PreCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "ins2PreCode":"s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"),",
        "label":1
    },
    {
        "ins1CurCode":"public void take() { TestObserverEx<Integer> to = new TestObserverEx<>(); ",
        "ins1PreCode":"public void take() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "ins2PreCode":"public void take() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(1, client().prepareGet(\"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").refresh(true).get(), matcher().updated(4)); assertEquals(2, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").filter(termQuery(\"foo\", \"no_match\")).refresh(true).get(), matcher().updated(0)); assertEquals(2, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").filter(termQuery(\"foo\", \"a\")).refresh(true).get(), matcher().updated(2)); assertEquals(3, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"2\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());   UpdateByQueryRequestBuilder request = updateByQuery().source(\"test\").size(3).refresh(true); request.source().addSort(\"foo.keyword\", SortOrder.ASC); assertThat(request.get(), matcher().updated(3));  assertEquals(4, client().prepareGet(\"test\", \"1\").get().getVersion()); assertEquals(4, client().prepareGet(\"test\", \"2\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"4\").get().getVersion());",
        "ins1PreCode":"client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(1, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").refresh(true).get(), matcher().updated(4)); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").filter(termQuery(\"foo\", \"no_match\")).refresh(true).get(), matcher().updated(0)); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat(updateByQuery().source(\"test\").filter(termQuery(\"foo\", \"a\")).refresh(true).get(), matcher().updated(2)); assertEquals(3, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"test\", \"2\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   UpdateByQueryRequestBuilder request = updateByQuery().source(\"test\").size(3).refresh(true); request.source().addSort(\"foo.keyword\", SortOrder.ASC); assertThat(request.get(), matcher().updated(3));  assertEquals(4, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(4, client().prepareGet(\"test\", \"test\", \"2\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());",
        "ins2PreCode":"client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(1, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());  int slices = randomSlices(2, 10); int expectedSlices = expectedSliceStatuses(slices, \"test\");   assertThat( updateByQuery() .source(\"test\") .refresh(true) .setSlices(slices).get(), matcher() .updated(4) .slices(hasSize(expectedSlices))); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat( updateByQuery() .source(\"test\") .filter(termQuery(\"foo\", \"no_match\")) .setSlices(slices) .refresh(true).get(), matcher() .updated(0) .slices(hasSize(expectedSlices))); assertEquals(2, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());   assertThat( updateByQuery() .source(\"test\") .filter(termQuery(\"foo\", \"a\")) .refresh(true) .setSlices(slices).get(), matcher() .updated(2) .slices(hasSize(expectedSlices))); assertEquals(3, client().prepareGet(\"test\", \"test\", \"1\").get().getVersion()); assertEquals(3, client().prepareGet(\"test\", \"test\", \"2\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"3\").get().getVersion()); assertEquals(2, client().prepareGet(\"test\", \"test\", \"4\").get().getVersion());",
        "label":0
    },
    {
        "ins1CurCode":"blocks, blockIds, new FetchShuffleBlocks( \"app-id\", \"exec-id\", 0, new long[] { 0 }, new int[][] {{ 0, 1, 2 }}, false), conf);",
        "ins1PreCode":"blocks, blockIds, new FetchShuffleBlocks(\"app-id\", \"exec-id\", 0, new long[] { 0 }, new int[][] {{ 0, 1, 2 }}), conf);",
        "ins2PreCode":"public void testFetchThree() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"b0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"b1\", new NioManagedBuffer(ByteBuffer.wrap(new byte[23]))); blocks.put(\"b2\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new OpenBlocks(\"app-id\", \"exec-id\", blockIds), conf);  for (int i = 0; i < 3; i ++) { verify(listener, times(1)).onBlockFetchSuccess(\"b\" + i, blocks.get(\"b\" + i)); }",
        "label":0
    },
    {
        "ins1CurCode":"public List<BibEntry> parseEntries(InputStream inputStream) { try {",
        "ins1PreCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException { try {",
        "ins2PreCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException { try { return importDatabase( new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8))).getDatabase().getEntries();  } catch (IOException e) { LOGGER.error(e.getLocalizedMessage(), e); } return Collections.emptyList();",
        "label":0
    },
    {
        "ins1CurCode":"series.add(jan1st2002, 42);  TimeSeries clone = CloneUtils.clone(series); clone.setKey(\"Clone Series\");",
        "ins1PreCode":"series.add(jan1st2002, 42);  TimeSeries clone; clone = (TimeSeries) series.clone(); clone.setKey(\"Clone Series\");",
        "ins2PreCode":"public void testClone() throws CloneNotSupportedException { TimePeriodValues series = new TimePeriodValues(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42); TimePeriodValues clone = (TimePeriodValues) series.clone(); clone.setKey(\"Clone Series\"); clone.update(0, 10);  int seriesValue = series.getValue(0).intValue(); int cloneValue = clone.getValue(0).intValue();  assertEquals(42, seriesValue); assertEquals(10, cloneValue); assertEquals(\"Test Series\", series.getKey()); assertEquals(\"Clone Series\", clone.getKey());",
        "label":0
    },
    {
        "ins1CurCode":" boolean create; long waitTime = 0;  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { waitTime = System.currentTimeMillis(); p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); waitTime = System.currentTimeMillis() - waitTime; } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } }  updateStatsBorrow(p, waitTime); ",
        "ins1PreCode":" boolean create; long waitTime = System.currentTimeMillis();  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } }  updateStatsBorrow(p, System.currentTimeMillis() - waitTime); ",
        "ins2PreCode":" boolean create; long waitTime = System.currentTimeMillis(); ObjectDeque<T> objectDeque = register(key);  try { while (p == null) { create = false; if (blockWhenExhausted) { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = objectDeque.getIdleObjects().takeFirst(); } else { p = objectDeque.getIdleObjects().pollFirst( borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(key, p); } catch (Exception e) { try { destroy(key, p, true); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(key, p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(key, p, true); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } } } finally { deregister(key); }  updateStatsBorrow(p, System.currentTimeMillis() - waitTime); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testToOnly() throws InterruptedException { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  server.join(60 * 1000); client.join(30 * 1000);  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); assertFalse(testMailClient.getFailMessage(), testMailClient.isFailed());",
        "ins1PreCode":"public void testToOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail(\"InterruptedException: \" + ie); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins2PreCode":"public void testAPIExample() {  ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.cc(\"cc1@you.com\"); testMailClient.cc(\"cc2@you.com\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc1@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc2@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"Cc: cc1@you.com, cc2@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; for (int icounter = 0; icounter<expectedResult.length(); icounter++) { if (icounter < result.length()) { if (expectedResult.charAt(icounter) != result.charAt(icounter)) { System.out.println(\"posit \" + icounter + \" expected \" + expectedResult.charAt(icounter) + \" result \" + result.charAt(icounter)); } } } if (expectedResult.length()>result.length()) { System.out.println(\"excedent of expected result \" + expectedResult.substring(result.length())); } if (expectedResult.length()<result.length()) { System.out.println(\"excedent of result \" + result.substring(expectedResult.length())); } assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "label":0
    },
    {
        "ins1CurCode":"public void updateTimestampDisabled() { final String timestampField = \"timestamp\"; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = false;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.includeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\");  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(\"test\", \"some value\");  assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"New timestamp set after entry changed even though updates were disabled\");",
        "ins1PreCode":"public void updateTimestampDisabled(){ final String timestampField = \"timestamp\"; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = false;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.includeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(\"Initial timestamp not set correctly\", Optional.of(baseDate), bibEntry.getField(timestampField));  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(\"test\", \"some value\");  assertEquals(\"New timestamp set after entry changed even though updates were disabled\", Optional.of(baseDate), bibEntry.getField(timestampField));",
        "ins2PreCode":"public void updateTimestampEnabled(){ final String timestampField = \"timestamp\"; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = true;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.includeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(\"Initial timestamp not set correctly\", Optional.of(baseDate), bibEntry.getField(timestampField));  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(\"test\", \"some value\");  assertEquals(\"Timestamp not set correctly after entry changed\", Optional.of(newDate), bibEntry.getField(timestampField));",
        "label":0
    },
    {
        "ins1CurCode":"public void multipleErrors2() { TestSubscriber<Integer> ts = new TestSubscriber<>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins1PreCode":"public void multipleErrors2() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "ins2PreCode":"public void multipleErrors3() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE);",
        "label":1
    },
    {
        "ins1CurCode":"getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getProperty(\"output\").replace( File.separatorChar, '/'); ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "ins1PreCode":"getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getBaseDir().getAbsolutePath().replace( File.separatorChar, '/') + \"/tmp\"; ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "ins2PreCode":"getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getBaseDir().getAbsolutePath().replace( File.separatorChar, '/') + \"/tmp\"; ds.setIncludes(new String[] {tmpdir + \"/alpha/beta/**/*\",",
        "label":1
    },
    {
        "ins1CurCode":"Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length)); Assert.assertTrue( arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length)); } }  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue( arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength())); Assert.assertTrue( arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength())); }",
        "ins1PreCode":"Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } }  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength())); }",
        "ins2PreCode":"Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } } for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength())); }",
        "label":1
    },
    {
        "ins1CurCode":"} target.setProperties( merged ); target.setLocation( \"properties\", InputLocation.merge( target.getLocation( \"properties\" ), source.getLocation( \"properties\" ), sourceDominant ) );",
        "ins1PreCode":"} target.setProperties( merged );",
        "ins2PreCode":"} target.setProperties( merged );",
        "label":1
    },
    {
        "ins1CurCode":"Page p = wc.getPage(request); assertEquals(HttpURLConnection.HTTP_NOT_FOUND, p.getWebResponse().getStatusCode()); assertEquals(\"text/html\", p.getWebResponse().getContentType());",
        "ins1PreCode":"Page p = wc.getPage(request); assertEquals(HttpURLConnection.HTTP_NOT_FOUND, p.getWebResponse().getStatusCode()); assertEquals(p.getWebResponse().getContentType(), \"text/html\");",
        "ins2PreCode":"public void cannotUseInvalidLocale_toTraverseFolder() throws Exception { Assume.assumeTrue(Functions.isWindows());  if (j.jenkins.pluginManager.getPlugin(\"credentials\") == null) { ((TestPluginManager) j.jenkins.pluginManager).installDetachedPlugin(\"credentials\"); } j.createWebClient().goTo(\"plugin/credentials/images/24x24/credentials.png\", \"image/png\");  JenkinsRule.WebClient wc = j.createWebClient() .withThrowExceptionOnFailingStatusCode(false); WebRequest request = new WebRequest(new URL(j.getURL() + \"plugin/credentials/.xml\"));    request.setAdditionalHeader(\"Accept-Language\", \"../../../../jenkinsTests.tmp/\" + j.jenkins.getRootDir().getName() + \"/config\");  Page p = wc.getPage(request); assertEquals(HttpURLConnection.HTTP_NOT_FOUND, p.getWebResponse().getStatusCode()); assertNotEquals(p.getWebResponse().getContentType(), \"application/xml\");",
        "label":0
    },
    {
        "ins1CurCode":"public void specificResourceAsFile() { String location = \"file:src/test/resources/specificlocation.properties\";",
        "ins1PreCode":"public void specificResourceAsFile() throws Exception { String location = \"file:src/test/resources/specificlocation.properties\";",
        "ins2PreCode":"public void specificResourceDefaultsToFile() throws Exception { String location = \"src/test/resources/specificlocation.properties\";",
        "label":1
    },
    {
        "ins1CurCode":"public void orderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<>(1); Disposable d = Disposable.empty();",
        "ins1PreCode":"public void orderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "ins2PreCode":"public void unorderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty();",
        "label":1
    },
    {
        "ins1CurCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<>(); ",
        "ins1PreCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<Integer>(); ",
        "ins2PreCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<Integer>(); ",
        "label":1
    },
    {
        "ins1CurCode":"while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); Assert.assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins1PreCode":"while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins2PreCode":"while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "label":1
    },
    {
        "ins1CurCode":"this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); initialize(this.initializationContext, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\")));",
        "ins1PreCode":"this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\")));",
        "ins2PreCode":"void customExceptionConversionWord(CapturedOutput output) { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, getRelativeClasspathLocation(\"log4j2-file.xml\"), getLogFile(null, tmpDir())); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); assertThat(output).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); } finally { System.clearProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD); }",
        "label":0
    },
    {
        "ins1CurCode":"remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new MockRequest(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "ins1PreCode":"remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "ins2PreCode":"remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "label":1
    },
    {
        "ins1CurCode":"});  final List<Object> received = new ArrayList<>();  BoundedSubscriber<Object> subscriber = new BoundedSubscriber<>(new Consumer<Object>() { @Override",
        "ins1PreCode":"});  final List<Object> received = new ArrayList<Object>();  BoundedSubscriber<Object> subscriber = new BoundedSubscriber<Object>(new Consumer<Object>() { @Override",
        "ins2PreCode":"});  final List<Object> received = new ArrayList<Object>();  LambdaSubscriber<Object> subscriber = new LambdaSubscriber<Object>(new Consumer<Object>() { @Override",
        "label":1
    },
    {
        "ins1CurCode":"public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, boolean tillTheEnd, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch, boolean tillTheEnd) { ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins2PreCode":"public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return FlowableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new FlowableConcatMap<T, R>(this, mapper, prefetch, ErrorMode.IMMEDIATE));",
        "label":0
    },
    {
        "ins1CurCode":"Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue(); ItemList<Queue.Item> unblockedItems = queue.getUnblockedItems(); for (AbstractProject tup : tups) { if(tup.isBuilding() || unblockedItems.containsKey(tup)) return tup;",
        "ins1PreCode":"Set<AbstractProject> tups = graph.getTransitiveDownstream(this); Queue queue = Hudson.getInstance().getQueue();  for (AbstractProject tup : tups) { if(tup.isBuilding() || queue.getUnblockedItems().containsKey(tup)) return tup;",
        "ins2PreCode":"DependencyGraph graph = Hudson.getInstance().getDependencyGraph(); Set<AbstractProject> tups = graph.getTransitiveUpstream(this); tups.add(this); for (AbstractProject tup : tups) { if(tup!=this && (tup.isBuilding() || tup.isInQueue())) return tup;",
        "label":0
    },
    {
        "ins1CurCode":"BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, null, random()); try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { XContentParseException exception = expectThrows(XContentParseException.class, () -> RatedDocument.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[rated_document] unknown field\")); }",
        "ins1PreCode":"BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, null, random()); try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { Exception exception = expectThrows(IllegalArgumentException.class, () -> RatedDocument.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[rated_document] unknown field\")); }",
        "ins2PreCode":"parser.nextToken(); parser.nextToken(); IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> MeanReciprocalRank.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[reciprocal_rank] unknown field\")); }",
        "label":1
    },
    {
        "ins1CurCode":"public void assertValueAtPredicateNoMatch() { assertThrows(\"Value not present\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1PreCode":"Flowable.just(1, 2, 3).subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Value not present\"); ts.assertValueAt(2, new Predicate<Integer>() {",
        "ins2PreCode":"Flowable.just(1, 2, 3).subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Value not present\"); ts.assertValueAt(2, new Predicate<Integer>() {",
        "label":1
    },
    {
        "ins1CurCode":"void usesUserProvidedTracer() { this.contextRunner.withUserConfiguration(HttpTraceRepositoryConfiguration.class)",
        "ins1PreCode":"public void usesUserProvidedTracer() { this.contextRunner.withUserConfiguration(HttpTraceRepositoryConfiguration.class)",
        "ins2PreCode":"public void usesUserProvidedWebFilterWhenReactiveContext() { new ReactiveWebApplicationContextRunner()",
        "label":1
    },
    {
        "ins1CurCode":"private static List<Field> createParentDocument(String id, String kwd) { return Arrays.asList( new StringField(IdFieldMapper.NAME, Uid.encodeId(id), Field.Store.NO), new SortedSetDocValuesField(\"kwd\", new BytesRef(kwd)), new StringField(\"join_field\", PARENT_TYPE, Field.Store.NO),",
        "ins1PreCode":"private static List<Field> createParentDocument(String id) { return Arrays.asList(",
        "ins2PreCode":"private static List<Field> createChildDocument(String childId, String parentId, int value) { return Arrays.asList( new StringField(IdFieldMapper.NAME, Uid.encodeId(childId), Field.Store.NO), new StringField(\"join_field\", CHILD_TYPE, Field.Store.NO), createJoinField(PARENT_TYPE, parentId), new SortedNumericDocValuesField(\"number\", value) );",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON));  IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0];  ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder()",
        "ins1PreCode":"assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON));  IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0];  ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder()",
        "ins2PreCode":"assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc1 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject() .field(\"field\", 10) .endObject()), XContentType.JSON));  IndexableField[] fields = doc1.rootDoc().getFields(\"_feature\"); assertEquals(1, fields.length); assertThat(fields[0], Matchers.instanceOf(FeatureField.class)); FeatureField featureField1 = (FeatureField) fields[0];  ParsedDocument doc2 = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder()",
        "label":1
    },
    {
        "ins1CurCode":"Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toObservable();  Map<Integer, String> expected = new HashMap<>(); expected.put(1, \"a\");",
        "ins1PreCode":"Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc).toObservable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\");",
        "ins2PreCode":"Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toObservable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\");",
        "label":1
    },
    {
        "ins1CurCode":"public void testFilterSet() throws IOException { executeTarget(\"testFilterSet\"); File tmp  = new File(getOutputDir(), \"copy.filterset.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\");",
        "ins1PreCode":"public void testFilterSet() throws IOException { executeTarget(\"testFilterSet\"); File tmp  = new File(getProjectDir(), \"copy.filterset.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\");",
        "ins2PreCode":"public void testFilterChain() throws IOException { executeTarget(\"testFilterChain\"); File tmp  = new File(getProjectDir(), \"copy.filterchain.tmp\"); File check  = new File(getProjectDir(), \"expected/copy.filterset.filtered\");",
        "label":1
    },
    {
        "ins1CurCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, xmpPreferences, filePreferences, externalFileType); boolean removed = viewModel.delete();",
        "ins1PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete();",
        "ins2PreCode":"any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1CurCode":"void toAnyEndpointWhenServletPathSetShouldMatch() { getContextRunner()",
        "ins1PreCode":"public void toAnyEndpointWhenServletPathSetShouldMatch() { getContextRunner()",
        "ins2PreCode":"public void toAllEndpointsShouldMatch() { getContextRunner().withInitializer(new ConditionEvaluationReportLoggingListener(LogLevel.INFO))",
        "label":1
    },
    {
        "ins1CurCode":"void testNaming() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class)",
        "ins1PreCode":"public void testNaming() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class)",
        "ins2PreCode":"public void testEmptyMapIsNotAdded() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class);",
        "label":1
    },
    {
        "ins1CurCode":"byte[] tmp = null;  int limit = getLimitInternal();  long newSize; long desiredSize = end + count;   if (desiredSize > limit) { desiredSize = limit; }  if (buff == null) { if (desiredSize < 256) { desiredSize = 256; } buff = new byte[(int) desiredSize]; }    if (desiredSize <= buff.length) { return; }  if (desiredSize < 2L * buff.length) { newSize = buff.length * 2L; } else { newSize = buff.length * 2L + count; }  if (newSize > limit) { newSize = limit; } tmp = new byte[(int) newSize]; ",
        "ins1PreCode":"byte[] tmp = null;  int newSize; int desiredSize = end + count;   if (limit > 0 && desiredSize > limit) { desiredSize = limit; }  if (buff == null) { if (desiredSize < 256) { desiredSize = 256; } buff = new byte[desiredSize]; }    if (desiredSize <= buff.length) { return; }  if (desiredSize < 2 * buff.length) { newSize = buff.length * 2; } else { newSize = buff.length * 2 + count; }  if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new byte[newSize]; ",
        "ins2PreCode":"char[] tmp = null;  int newSize; int desiredSize = end + count;   if (limit > 0 && desiredSize > limit) { desiredSize = limit; }  if (buff == null) { if (desiredSize < 256) { desiredSize = 256; } buff = new char[desiredSize]; }    if (desiredSize <= buff.length) { return; }  if (desiredSize < 2 * buff.length) { newSize = buff.length * 2; } else { newSize = buff.length * 2 + count; }  if (limit > 0 && newSize > limit) { newSize = limit; } tmp = new char[newSize]; ",
        "label":1
    },
    {
        "ins1CurCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY); ",
        "ins1PreCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "ins2PreCode":"public void fusedAsyncConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); ",
        "label":1
    },
    {
        "ins1CurCode":"throw new FatalBeanException(\"test failure\"); })); EndpointMBean bean = new EndpointMBean(this.responseMapper, null, endpoint); this.thrown.expect(MBeanException.class);",
        "ins1PreCode":"throw new FatalBeanException(\"test failure\"); })); EndpointMBean bean = new EndpointMBean(this.responseMapper, endpoint); this.thrown.expect(MBeanException.class);",
        "ins2PreCode":"throw new UnsupportedOperationException(\"test failure\"); })); EndpointMBean bean = new EndpointMBean(this.responseMapper, endpoint); this.thrown.expect(MBeanException.class);",
        "label":1
    },
    {
        "ins1CurCode":" final FutureTask exec_task = new FutureTask(new Callable() { @Override public Object call() {",
        "ins1PreCode":" final FutureTask exec_task = new FutureTask(new Callable() { public Object call() { assertJenkinsNotInQuietMode();",
        "ins2PreCode":" final FutureTask exec_task = new FutureTask(new Callable() { public Object call() { assertJenkinsNotInQuietMode();",
        "label":1
    },
    {
        "ins1CurCode":"  for (CategoryPlot categoryPlot : getSubplots()) { subplot = categoryPlot; subplot.zoomRangeAxes(lowerPercent, upperPercent, info, source);",
        "ins1PreCode":"  Iterator iterator = getSubplots().iterator(); while (iterator.hasNext()) { subplot = (CategoryPlot) iterator.next(); subplot.zoomRangeAxes(lowerPercent, upperPercent, info, source);",
        "ins2PreCode":"public void zoomDomainAxes(double lowerPercent, double upperPercent, PlotRenderingInfo info, Point2D source) {  XYPlot subplot = findSubplot(info, source); if (subplot != null) { subplot.zoomDomainAxes(lowerPercent, upperPercent, info, source); } else {   for (XYPlot plot : getSubplots()) { plot.zoomDomainAxes(lowerPercent, upperPercent, info, source); } }",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCitationKey()); assertEquals(2, entry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"public void adjacentNodes_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  addNode(N1);",
        "ins1PreCode":"public void adjacentNodes_checkReturnedSetMutability() { addNode(N1); Set<Integer> adjacentNodes = network.adjacentNodes(N1); try {",
        "ins2PreCode":"public void adjacentNodes_checkReturnedSetMutability() { addNode(N1); Set<Integer> adjacentNodes = network.adjacentNodes(N1); try { adjacentNodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.adjacentNodes(N1)).containsExactlyElementsIn(adjacentNodes); }",
        "label":0
    },
    {
        "ins1CurCode":"void parseIgnoresCommentsAfterEntry() throws IOException { ParserResult result = parser",
        "ins1PreCode":"public void parseIgnoresCommentsAfterEntry() throws IOException { ParserResult result = parser",
        "ins2PreCode":"public void parseIgnoresTextBeforeEntry() throws IOException { ParserResult result = parser",
        "label":1
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "label":0
    },
    {
        "ins1CurCode":"StringBuilder out = new StringBuilder(); while (in.hasNext()) { out.append(in.next().toUpperCase(Locale.ROOT)); }",
        "ins1PreCode":"StringBuilder out = new StringBuilder(); while (in.hasNext()) { out.append(in.next().toUpperCase(Locale.ENGLISH)); }",
        "ins2PreCode":"String out = \"\"; while (in.hasNext()) { out = out + in.next().toUpperCase(); }",
        "label":0
    },
    {
        "ins1CurCode":"void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap();",
        "ins1PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap();",
        "ins2PreCode":"public void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "label":0
    },
    {
        "ins1CurCode":"public void testAdd() { XIntervalSeries<String> series = new XIntervalSeries<>(\"Series\", false, true); series.add(5.0, 5.50, 5.50, 5.50);",
        "ins1PreCode":"public void testAdd() { XIntervalSeries series = new XIntervalSeries(\"Series\", false, true); series.add(5.0, 5.50, 5.50, 5.50);",
        "ins2PreCode":"public void testAdd() { VectorSeries series = new VectorSeries(\"Series\", false, true); series.add(5.0, 5.50, 5.50, 5.50);",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCitationKey()); assertEquals(2, parsedEntry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); skipTokens(st, 2); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins1PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "ins2PreCode":"if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) {",
        "label":1
    },
    {
        "ins1CurCode":"public void shouldNotOverwriteCollectionOnNestedResultMap() { try (SqlSession session = factory.openSession()) { List<Author> authors = session.selectList(\"getAllAuthors\");",
        "ins1PreCode":"public void shouldNotOverwriteCollectionOnNestedResultMap() { SqlSession session = factory.openSession(); try { List<Author> authors = session.selectList(\"getAllAuthors\"); assertEquals(1, authors.size()); assertEquals(4, authors.get(0).getPosts().size()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldNotOverwriteCollectionOnNestedQuery() { SqlSession session = factory.openSession(); try { List<Author> authors = session.selectList(\"getAllAuthorsNestedQuery\"); assertEquals(1, authors.size()); assertEquals(4, authors.get(0).getPosts().size()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"for (FilterMap filterMap : filterMaps) { if (filterMap.getFilterName().equals(filterDef.getFilterName())) { result.addAll(Arrays.asList(filterMap.getServletNames())); }",
        "ins1PreCode":"for (FilterMap filterMap : filterMaps) { if (filterMap.getFilterName().equals(filterDef.getFilterName())) { for (String servletName : filterMap.getServletNames()) { result.add(servletName); }",
        "ins2PreCode":"for (FilterMap filterMap : filterMaps) { if (filterMap.getFilterName().equals(filterDef.getFilterName())) { for (String urlPattern : filterMap.getURLPatterns()) { result.add(urlPattern); }",
        "label":1
    },
    {
        "ins1CurCode":"public void testBug2817504() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); LineAndShapeRenderer r1 = new LineAndShapeRenderer(); p1.setRenderer(r1); CategoryPlot<String, String> p2; try {",
        "ins1PreCode":"public void testBug2817504() { CategoryPlot p1 = new CategoryPlot(); LineAndShapeRenderer r1 = new LineAndShapeRenderer(); p1.setRenderer(r1); CategoryPlot p2; try {",
        "ins2PreCode":"public void testBug2817504() throws CloneNotSupportedException { XYPlot p1 = new XYPlot(); XYLineAndShapeRenderer r1 = new XYLineAndShapeRenderer(); p1.setRenderer(r1); XYPlot p2 = (XYPlot) p1.clone(); assertTrue(p1 != p2); assertTrue(p1.getClass() == p2.getClass()); assertTrue(p1.equals(p2));   XYLineAndShapeRenderer r2 = (XYLineAndShapeRenderer) p2.getRenderer(); assertTrue(r2.getPlot() == p2);",
        "label":0
    },
    {
        "ins1CurCode":"@Override public void subscribe(Observer<? super String> o) { o.onSubscribe(Disposable.empty()); for (int i = 0; i < NUM_MSG; i++) {",
        "ins1PreCode":"@Override public void subscribe(Observer<? super String> o) { o.onSubscribe(Disposables.empty()); for (int i = 0; i < NUM_MSG; i++) {",
        "ins2PreCode":"public void issue1900() throws InterruptedException { Observer<String> observer = TestHelper.mockObserver(); final int NUM_MSG = 1034; final AtomicInteger count = new AtomicInteger();  Observable<String> origin = Observable.range(0, NUM_MSG) .map(new Function<Integer, String>() { @Override public String apply(Integer t1) { return \"msg: \" + count.incrementAndGet(); } });  origin.retry() .groupBy(new Function<String, String>() { @Override public String apply(String t1) { return t1; } }) .flatMap(new Function<GroupedObservable<String, String>, Observable<String>>() { @Override public Observable<String> apply(GroupedObservable<String, String> t1) { return t1.take(1); } }) .subscribe(new TestObserver<String>(observer));  InOrder inOrder = inOrder(observer);  inOrder.verify(observer, times(NUM_MSG)).onNext(any(java.lang.String.class));  inOrder.verify(observer, never()).onError(any(Throwable.class));    inOrder.verify(observer, times(1)).onComplete(); inOrder.verifyNoMoreInteractions();",
        "label":0
    },
    {
        "ins1CurCode":"while (line == null || line.length() == 0) { line = lineTokenizer.getToken(in); if (line == null) { return -1; } line = headFilter(line); linePos = 0; }  int ch = line.charAt(linePos); linePos++; if (linePos == line.length()) { line = null;",
        "ins1PreCode":"while (line == null || line.length() == 0) { line = lineTokenizer.getToken(in); if (line == null) return -1; line = headFilter(line); linePos = 0; }  int ch = line.charAt(linePos); linePos++; if (linePos == line.length()) line = null;",
        "ins2PreCode":"line = lineTokenizer.getToken(in); line = tailFilter(line); if (line == null) return -1; linePos = 0; }  int ch = line.charAt(linePos); linePos++; if (linePos == line.length()) line = null;",
        "label":1
    },
    {
        "ins1CurCode":"static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {  MethodHandle getter = painlessLookup.lookupRuntimeGetterMethodHandle(receiverClass, name);  if (getter != null) { return getter; }   if (receiverClass.isArray() && \"length\".equals(name)) {  return arrayLengthGetter(receiverClass); } else if (Map.class.isAssignableFrom(receiverClass)) {   return MethodHandles.insertArguments(MAP_GET, 1, name); } else if (List.class.isAssignableFrom(receiverClass)) {    try { int index = Integer.parseInt(name); return MethodHandles.insertArguments(LIST_GET, 1, index); } catch (NumberFormatException exception) { throw new IllegalArgumentException(\"Illegal list shortcut value [\" + name + \"].\"); } }  throw new IllegalArgumentException( \"dynamic getter [\" + typeToCanonicalTypeName(receiverClass) + \", \" + name + \"] not found\");",
        "ins1PreCode":"static MethodHandle lookupGetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {  for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);  if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.lookupPainlessClass(iface);  if (struct != null) { MethodHandle handle = struct.getterMethodHandles.get(name); if (handle != null) { return handle; } } } }  if (receiverClass.isArray() && \"length\".equals(name)) {  return arrayLengthGetter(receiverClass); } else if (Map.class.isAssignableFrom(receiverClass)) {   return MethodHandles.insertArguments(MAP_GET, 1, name); } else if (List.class.isAssignableFrom(receiverClass)) {    try { int index = Integer.parseInt(name); return MethodHandles.insertArguments(LIST_GET, 1, index); } catch (NumberFormatException exception) { throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\"); } }  throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" + \"for class [\" + receiverClass.getCanonicalName() + \"].\");",
        "ins2PreCode":"static MethodHandle lookupSetter(PainlessLookup painlessLookup, Class<?> receiverClass, String name) {  for (Class<?> clazz = receiverClass; clazz != null; clazz = clazz.getSuperclass()) { PainlessClass struct = painlessLookup.lookupPainlessClass(clazz);  if (struct != null) { MethodHandle handle = struct.setterMethodHandles.get(name); if (handle != null) { return handle; } }  for (final Class<?> iface : clazz.getInterfaces()) { struct = painlessLookup.lookupPainlessClass(iface);  if (struct != null) { MethodHandle handle = struct.setterMethodHandles.get(name); if (handle != null) { return handle; } } } }  if (Map.class.isAssignableFrom(receiverClass)) {   return MethodHandles.insertArguments(MAP_PUT, 1, name); } else if (List.class.isAssignableFrom(receiverClass)) {    try { int index = Integer.parseInt(name); return MethodHandles.insertArguments(LIST_SET, 1, index); } catch (final NumberFormatException exception) { throw new IllegalArgumentException( \"Illegal list shortcut value [\" + name + \"].\"); } }  throw new IllegalArgumentException(\"Unable to find dynamic field [\" + name + \"] \" + \"for class [\" + receiverClass.getCanonicalName() + \"].\");",
        "label":1
    },
    {
        "ins1CurCode":"  alv.validateAccessLog(1, 200, Bug49528Servlet.THREAD_SLEEP_TIME, Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins1PreCode":"  validateAccessLog(alv, 1, 200, Bug49528Servlet.THREAD_SLEEP_TIME, Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins2PreCode":"  validateAccessLog(alv, 1, 200, Bug49567Servlet.THREAD_SLEEP_TIME, Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "label":1
    },
    {
        "ins1CurCode":"d.addValue(4.0, \"R2\", \"C2\"); CategoryItemEntity e1 = new CategoryItemEntity(new Rectangle2D.Double( 1.0, 2.0, 3.0, 4.0), \"ToolTip\", \"URL\", d, \"R2\", \"C2\"); CategoryItemEntity e2 = (CategoryItemEntity) e1.clone();",
        "ins1PreCode":"d.addValue(4.0, \"R2\", \"C2\"); CategoryItemEntity e1 = new CategoryItemEntity(new Rectangle2D.Double( 1.0, 2.0, 3.0, 4.0), \"ToolTip\", \"URL\", d, 1, \"C2\", 1); CategoryItemEntity e2 = (CategoryItemEntity) e1.clone();",
        "ins2PreCode":"d.addValue(4.0, \"R2\", \"C2\"); CategoryItemEntity e1 = new CategoryItemEntity(new Rectangle2D.Double( 1.0, 2.0, 3.0, 4.0), \"ToolTip\", \"URL\", d, 1, \"C2\", 1); CategoryItemEntity e2 = (CategoryItemEntity) TestUtilities.serialised(e1);",
        "label":1
    },
    {
        "ins1CurCode":"void getBeanOfTypeWhenHasMultipleBeansShouldFail() { this.context.registerSingleton(\"foo\", Foo.class);",
        "ins1PreCode":"public void getBeanOfTypeWhenHasMultipleBeansShouldFail() { this.context.registerSingleton(\"foo\", Foo.class);",
        "ins2PreCode":"public void getBeanOfTypeWhenHasMultipleBeansIncludingParentShouldFail() { this.parent.registerSingleton(\"foo\", Foo.class);",
        "label":1
    },
    {
        "ins1CurCode":" databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins1PreCode":"databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());  try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins2PreCode":" databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "label":0
    },
    {
        "ins1CurCode":"public Decimal getDecimal(int ordinal, int precision, int scale) { if (isNullAt(ordinal)) return null; if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.apply(getLong(ordinal), precision, scale); } else {",
        "ins1PreCode":"public Decimal getDecimal(int ordinal, int precision, int scale) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null;  if (precision <= Decimal.MAX_LONG_DIGITS()) { final long value = Platform.getLong(baseObject, baseOffset + offset); return Decimal.apply(value, precision, scale); } else {",
        "ins2PreCode":"public Decimal getDecimal(int ordinal, int precision, int scale) { if (isNullAt(ordinal)) { return null; } if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.createUnsafe(getLong(ordinal), precision, scale); } else { byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(javaDecimal, precision, scale); }",
        "label":0
    },
    {
        "ins1CurCode":"long timespan, TimeUnit unit, int maxSize, boolean restartOnMaxSize, Worker w) { super(actual, new MpscLinkedQueue<>()); this.bufferSupplier = bufferSupplier;",
        "ins1PreCode":"long timespan, TimeUnit unit, int maxSize, boolean restartOnMaxSize, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier;",
        "ins2PreCode":"long timespan, TimeUnit unit, int maxSize, boolean restartOnMaxSize, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier;",
        "label":1
    },
    {
        "ins1CurCode":"{ BlobContent blobContent = mapper.findOne(1); assertThat(new BufferedReader(new InputStreamReader(blobContent.getContent())).readLine()).isEqualTo(\"Hello\"); }",
        "ins1PreCode":"{ BlobContent blobContent = mapper.findOne(1); assertThat(new BufferedReader(new InputStreamReader(blobContent.getContent())).readLine(), is(\"Hello\")); }",
        "ins2PreCode":"{ ClobContent clobContent = mapper.findOne(1); assertThat(new BufferedReader(clobContent.getContent()).readLine(), is(\"Hello\")); }",
        "label":1
    },
    {
        "ins1CurCode":"long timeout = getReadTimeout(); try { readBlock = new CountDownLatch(1); registerReadInterest(); if (timeout > 0) { if (!readBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { readBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { readBlock = null; }",
        "ins1PreCode":"long timeout = getReadTimeout(); try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; }",
        "ins2PreCode":"} if (n == 0) { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) {  } if (writeBlocking) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { writeBlocking = false; }",
        "label":0
    },
    {
        "ins1CurCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); @SuppressWarnings(\"unchecked\") CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData);",
        "label":1
    },
    {
        "ins1CurCode":"public void testIterateToFindDomainBounds_IntervalXYDataset() { DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>(); double[] x1 = new double[] {0.8, 3.2, 3.0};",
        "ins1PreCode":"public void testIterateToFindDomainBounds_IntervalXYDataset() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {0.8, 3.2, 3.0};",
        "ins2PreCode":"public void testIterateToFindRangeBounds_IntervalXYDataset() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {0.8, 3.2, 3.0};",
        "label":1
    },
    {
        "ins1CurCode":"public void retentionFiltering() { DumbSlave.DescriptorImpl descriptor =",
        "ins1PreCode":"public void retentionFiltering() throws Exception { DumbSlave.DescriptorImpl descriptor =",
        "ins2PreCode":"public void propertyFiltering() throws Exception { j.jenkins.setAuthorizationStrategy(new ProjectMatrixAuthorizationStrategy());",
        "label":1
    },
    {
        "ins1CurCode":"{ IssueManagement src = source.getIssueManagement(); if ( src != null ) { IssueManagement tgt = target.getIssueManagement(); if ( tgt == null ) { tgt = new IssueManagement(); tgt.setLocation( \"\", src.getLocation( \"\" ) ); target.setIssueManagement( tgt );",
        "ins1PreCode":"{ IssueManagement src = source.getIssueManagement(); if ( source.getIssueManagement() != null ) {",
        "ins2PreCode":"{ CiManagement src = source.getCiManagement(); if ( source.getCiManagement() != null ) {",
        "label":1
    },
    {
        "ins1CurCode":"@Override public Object apply(Observable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Observable.just(1).hide()), true, 2, ImmediateThinScheduler.INSTANCE); }",
        "ins1PreCode":"@Override public Object apply(Observable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Observable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE); }",
        "ins2PreCode":"@Override public Object apply(Flowable<Integer> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(1).hide()), 2, true, ImmediateThinScheduler.INSTANCE); }",
        "label":1
    },
    {
        "ins1CurCode":".startWith(Flowable.error(new TestException()));  TestSubscriber<Object> ts = new TestSubscriber<>(); ",
        "ins1PreCode":".startWith(Flowable.error(new TestException()));  TestSubscriber<Object> ts = new TestSubscriber<Object>(); ",
        "ins2PreCode":".andThen(Flowable.error(new TestException()));  TestSubscriber<Object> ts = new TestSubscriber<Object>(); ",
        "label":1
    },
    {
        "ins1CurCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { nRead = pool.read(to, socket, selector, getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = socket.read(to); if (nRead == -1) {",
        "ins1PreCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel channel = getSocket(); if (block) { Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { nRead = pool.read(to, channel, selector, getReadTimeout()); } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(to); if (nRead == -1) {",
        "ins2PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } if (block) { long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) {  } try { pool.write(from, socket, selector, writeTimeout); if (block) {  do { if (socket.flush(true, selector, writeTimeout)) { break; } } while (true); } } finally { if (selector != null) { pool.put(selector); } }     } else { if (socket.write(from) == -1) { throw new EOFException(); } } updateLastWrite();",
        "label":0
    },
    {
        "ins1CurCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); int updates = session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1PreCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins2PreCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "label":1
    },
    {
        "ins1CurCode":"FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); Hashtable<String, String> files = new Hashtable<>(); for (String scannedFile : scanner.getIncludedFiles()) { files.put(scannedFile, scannedFile);",
        "ins1PreCode":"FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile);",
        "ins2PreCode":"DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) {",
        "label":0
    },
    {
        "ins1CurCode":"{ if (image == null) { return getImage(DBIcon.TYPE_UNKNOWN); } if (image instanceof DBIconBinary) { return ((DBIconBinary) image).getImage(); } else { IconDescriptor icon = getIconByLocation(image.getLocation()); if (icon == null) { log.error(\"Image '\" + image.getLocation() + \"' not found\"); return getImage(DBIcon.TYPE_UNKNOWN); } else if (image instanceof DBIconComposite) {",
        "ins1PreCode":"{ if (image == null) { return null; } if (image instanceof DBIconBinary) { return ((DBIconBinary) image).getImage(); } else { IconDescriptor icon = getIconByLocation(image.getLocation()); if (icon == null) { throw new IllegalArgumentException(\"Image '\" + image.getLocation() + \"' not found\"); } else if (image instanceof DBIconComposite) {",
        "ins2PreCode":"{ if (image == null) { return null; } if (image instanceof DBIconBinary) { return ((DBIconBinary) image).getImageDescriptor(); } else { IconDescriptor icon = getIconByLocation(image.getLocation()); if (icon == null) { throw new IllegalArgumentException(\"Image '\" + image.getLocation() + \"' not found\"); } else if (image instanceof DBIconComposite) {",
        "label":1
    },
    {
        "ins1CurCode":" DefaultKeyedValues<String> data = new DefaultKeyedValues<>(); data.addValue(\"C\", 1.0); data.addValue(\"B\", null); data.addValue(\"D\", 3.0); data.addValue(\"A\", 2.0); ",
        "ins1PreCode":" DefaultKeyedValues<String> data = new DefaultKeyedValues<>(); data.addValue(\"C\", new Double(1.0)); data.addValue(\"B\", null); data.addValue(\"D\", new Double(3.0)); data.addValue(\"A\", new Double(2.0)); ",
        "ins2PreCode":" DefaultKeyedValues<String> data = new DefaultKeyedValues<>(); data.addValue(\"C\", new Double(1.0)); data.addValue(\"B\", null); data.addValue(\"D\", new Double(3.0)); data.addValue(\"A\", new Double(2.0)); ",
        "label":1
    },
    {
        "ins1CurCode":"return Observable.just(v).hide(); } }, true, 2); }",
        "ins1PreCode":"return Observable.just(v).hide(); } }, 2, true); }",
        "ins2PreCode":"public void undeliverableUponCancelDelayError() { TestHelper.checkUndeliverableUponCancel(new FlowableConverter<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Flowable<Integer> upstream) { return upstream.concatMapEagerDelayError(new Function<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, false); } });",
        "label":0
    },
    {
        "ins1CurCode":" try { cs = Objects.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) {",
        "ins1PreCode":" try { cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) {",
        "ins2PreCode":" try { cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) {",
        "label":1
    },
    {
        "ins1CurCode":"public void testConstructor1() { XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(1.0, item1.getX()); assertEquals(2.0, item1.getXLowValue(), EPSILON);",
        "ins1PreCode":"public void testConstructor1() { XIntervalDataItem item1 = new XIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(new Double(1.0), item1.getX()); assertEquals(2.0, item1.getXLowValue(), EPSILON);",
        "ins2PreCode":"public void testConstructor1() { YIntervalDataItem item1 = new YIntervalDataItem(1.0, 2.0, 3.0, 4.0); assertEquals(Double.valueOf(1.0), item1.getX()); assertEquals(2.0, item1.getYValue(), EPSILON); assertEquals(3.0, item1.getYLowValue(), EPSILON); assertEquals(4.0, item1.getYHighValue(), EPSILON);",
        "label":0
    },
    {
        "ins1CurCode":"assertThat(events).hasAtLeastOneElementOfType(ApplicationPreparedEvent.class); assertThat(events).hasAtLeastOneElementOfType(ContextRefreshedEvent.class); verifyRegisteredListenerSuccessEvents();",
        "ins1PreCode":"assertThat(events).hasAtLeastOneElementOfType(ApplicationPreparedEvent.class); assertThat(events).hasAtLeastOneElementOfType(ContextRefreshedEvent.class); verifyTestListenerEvents();",
        "ins2PreCode":"assertThat(events).hasAtLeastOneElementOfType(ApplicationPreparedEvent.class); assertThat(events).hasAtLeastOneElementOfType(ContextRefreshedEvent.class); verifyTestListenerEvents();",
        "label":1
    },
    {
        "ins1CurCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent, StandardCharsets.UTF_8); ",
        "ins1PreCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent); ",
        "ins2PreCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent); ",
        "label":1
    },
    {
        "ins1CurCode":"protected void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "ins1PreCode":"public void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "ins2PreCode":"public void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> {",
        "label":0
    },
    {
        "ins1CurCode":"public void onNext(@NonNull T t) { if (done) {",
        "ins1PreCode":"public void onNext(T t) { if (done) {",
        "ins2PreCode":"public void onNext(@NonNull T t) { if (done) { return; } if (upstream == null) { onNextNoSubscription(); return; }  if (t == null) { Throwable ex = ExceptionHelper.createNullPointerException(\"onNext called with a null value.\"); try { upstream.dispose(); } catch (Throwable e1) { Exceptions.throwIfFatal(e1); onError(new CompositeException(ex, e1)); return; } onError(ex); return; }  try { downstream.onNext(t); } catch (Throwable e) { Exceptions.throwIfFatal(e); try { upstream.dispose(); } catch (Throwable e1) { Exceptions.throwIfFatal(e1); onError(new CompositeException(e, e1)); return; } onError(e); }",
        "label":0
    },
    {
        "ins1CurCode":"throws MavenExecutionRequestPopulationException { Set<String> definedRepositories = repositorySystem.getRepoIds( request.getRemoteRepositories() );  if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) ) { try { request.addRemoteRepository( repositorySystem.createDefaultRemoteRepository( request ) ); }",
        "ins1PreCode":"throws MavenExecutionRequestPopulationException { Set<String> definedRepositories = getRepoIds( request.getRemoteRepositories() );  if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) ) { try { request.addRemoteRepository( createDefaultRemoteRepository( request ) ); }",
        "ins2PreCode":"throws MavenExecutionRequestPopulationException { Set<String> definedRepositories = getRepoIds( request.getPluginArtifactRepositories() );  if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) ) { try { request.addPluginArtifactRepository( createDefaultRemoteRepository( request ) ); }",
        "label":1
    },
    {
        "ins1CurCode":"Class<?> type = null; try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { method = pd[i].getWriteMethod(); type = pd[i].getPropertyType(); break; } } } catch (Exception ex) { throw new JasperException (ex); } if (method == null) { if (type == null) { throw new JasperException(Localizer.getMessage( \"jsp.error.beans.noproperty\", prop, beanClass.getName())); } else { throw new JasperException(Localizer.getMessage( \"jsp.error.beans.nomethod.setproperty\", prop, type.getName(), beanClass.getName())); }",
        "ins1PreCode":"Class<?> type = null; try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); if ( info != null ) { java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { method = pd[i].getWriteMethod(); type   = pd[i].getPropertyType(); break; } } } else {  throw new JasperException( Localizer.getMessage(\"jsp.error.beans.nobeaninfo\", beanClass.getName())); } } catch (Exception ex) { throw new JasperException (ex); } if (method == null) { if (type == null) { throw new JasperException( Localizer.getMessage(\"jsp.error.beans.noproperty\", prop, beanClass.getName())); } else { throw new JasperException( Localizer.getMessage(\"jsp.error.beans.nomethod.setproperty\", prop, type.getName(), beanClass.getName())); }",
        "ins2PreCode":"Class<?> type = null; try { java.beans.BeanInfo info = java.beans.Introspector.getBeanInfo(beanClass); if ( info != null ) { java.beans.PropertyDescriptor pd[] = info.getPropertyDescriptors(); for (int i = 0 ; i < pd.length ; i++) { if ( pd[i].getName().equals(prop) ) { method = pd[i].getReadMethod(); type   = pd[i].getPropertyType(); break; } } } else {  throw new JasperException( Localizer.getMessage(\"jsp.error.beans.nobeaninfo\", beanClass.getName())); } } catch (Exception ex) { throw new JasperException (ex); } if (method == null) { if (type == null) { throw new JasperException( Localizer.getMessage(\"jsp.error.beans.noproperty\", prop, beanClass.getName())); } else { throw new JasperException( Localizer.getMessage(\"jsp.error.beans.nomethod\", prop, beanClass.getName())); }",
        "label":1
    },
    {
        "ins1CurCode":"remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new MockRequest(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "ins1PreCode":"remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "ins2PreCode":"remoteIpValve.setNext(remoteAddrAndHostTrackerValve);  Request request = new Request(); request.setCoyoteRequest(new org.apache.coyote.Request());",
        "label":1
    },
    {
        "ins1CurCode":"void bufferRequestBodyCanBeConfiguredOnHttpComponentsRequestFactory() { ClientHttpRequestFactory requestFactory = this.builder",
        "ins1PreCode":"public void bufferRequestBodyCanBeConfiguredOnHttpComponentsRequestFactory() { ClientHttpRequestFactory requestFactory = this.builder",
        "ins2PreCode":"public void bufferRequestBodyCanBeConfiguredOnSimpleRequestFactory() { ClientHttpRequestFactory requestFactory = this.builder.requestFactory(SimpleClientHttpRequestFactory.class)",
        "label":1
    },
    {
        "ins1CurCode":"for ( PluginExecution element : src ) { Object key = getPluginExecutionKey().apply( element ); merged.put( key, element.clone() ); }  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey().apply( element ); PluginExecution existing = merged.get( key );",
        "ins1PreCode":"for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); merged.put( key, element.clone() ); }  for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key );",
        "ins2PreCode":"for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); }  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key );",
        "label":1
    },
    {
        "ins1CurCode":"StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.eclipse.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  String premanagedScope = DependencyManagerUtils.getPremanagedScope( node ); if ( premanagedScope != null && !premanagedScope.equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( premanagedScope ); appendManagementSource( buffer, art, \"scope\" ); buffer.append( \")\" ); }  String premanagedVersion = DependencyManagerUtils.getPremanagedVersion( node ); if ( premanagedVersion != null && !premanagedVersion.equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( premanagedVersion ); appendManagementSource( buffer, art, \"version\" );",
        "ins1PreCode":"StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.sonatype.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.sonatype.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ); appendManagementSource( buffer, art, \"scope\" ); buffer.append( \")\" ); }  if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ); appendManagementSource( buffer, art, \"version\" );",
        "ins2PreCode":"StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.sonatype.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.sonatype.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ).append( \")\" ); }  if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ).append( \")\" ); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testSetSeriesToolTipGenerator() { XYPlot<?> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer();",
        "label":0
    },
    {
        "ins1CurCode":"void disableIgnoreBeanInfoProperty() { System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, \"false\");",
        "ins1PreCode":"public void disableIgnoreBeanInfoProperty() { System.setProperty(CachedIntrospectionResults.IGNORE_BEANINFO_PROPERTY_NAME, \"false\");",
        "ins2PreCode":"public void setIgnoreBeanInfoPropertyByDefault() { SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":0
    },
    {
        "ins1CurCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposable.empty()); observer.onError(new TestException());",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException());",
        "ins2PreCode":"public void badInnerSource() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { Flowable.just(1).hide() .switchMap(Functions.justFunction(new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onError(new TestException()); subscriber.onComplete(); subscriber.onError(new TestException()); subscriber.onComplete(); } })) .test() .assertFailure(TestException.class);  TestHelper.assertUndeliverable(errors, 0, TestException.class); } finally { RxJavaPlugins.reset(); }",
        "label":0
    },
    {
        "ins1CurCode":"List<DBDAttributeBinding> attrs = model.getVisibleAttributes();  grid.append(\"> \").append(controller.getDataContainer().getName()).append(\"\\n\"); ",
        "ins1PreCode":"List<DBDAttributeBinding> attrs = model.getVisibleAttributes();  grid.append(\"> \"+controller.getDataContainer().getName()+\"\\n\"); ",
        "ins2PreCode":"private void printGrid(boolean append) { DBPPreferenceStore prefs = getController().getPreferenceStore(); int maxColumnSize = prefs.getInt(ResultSetPreferences.RESULT_TEXT_MAX_COLUMN_SIZE); boolean delimLeading = prefs.getBoolean(ResultSetPreferences.RESULT_TEXT_DELIMITER_LEADING); boolean delimTrailing = prefs.getBoolean(ResultSetPreferences.RESULT_TEXT_DELIMITER_TRAILING); boolean extraSpaces = prefs.getBoolean(ResultSetPreferences.RESULT_TEXT_EXTRA_SPACES); this.showNulls = getController().getPreferenceStore().getBoolean(ResultSetPreferences.RESULT_TEXT_SHOW_NULLS);  DBDDisplayFormat displayFormat = DBDDisplayFormat.safeValueOf(prefs.getString(ResultSetPreferences.RESULT_TEXT_VALUE_FORMAT));  StringBuilder grid = new StringBuilder(512); ResultSetModel model = controller.getModel(); List<DBDAttributeBinding> attrs = model.getVisibleAttributes();  List<ResultSetRow> allRows = model.getAllRows(); int extraSpacesNum = extraSpaces ? 2 : 0; if (colWidths == null) {  colWidths = new int[attrs.size()];  for (int i = 0; i < attrs.size(); i++) { DBDAttributeBinding attr = attrs.get(i); colWidths[i] = getAttributeName(attr).length() + extraSpacesNum; if (showNulls && !attr.isRequired()) { colWidths[i] = Math.max(colWidths[i], DBConstants.NULL_VALUE_LABEL.length()); } for (ResultSetRow row : allRows) { String displayString = getCellString(model, attr, row, displayFormat); colWidths[i] = Math.max(colWidths[i], getStringWidth(displayString) + extraSpacesNum); } } for (int i = 0; i < colWidths.length; i++) { if (colWidths[i] > maxColumnSize) { colWidths[i] = maxColumnSize; } } }  if (!append) {  if (delimLeading) grid.append(\"|\"); for (int i = 0; i < attrs.size(); i++) { if (i > 0) grid.append(\"|\"); if (extraSpaces) grid.append(\" \"); DBDAttributeBinding attr = attrs.get(i); String attrName = getAttributeName(attr); grid.append(attrName); for (int k = colWidths[i] - attrName.length() - extraSpacesNum; k > 0; k--) { grid.append(\" \"); } if (extraSpaces) grid.append(\" \"); } if (delimTrailing) grid.append(\"|\"); grid.append(\"\\n\");    if (delimLeading) grid.append(\"|\"); for (int i = 0; i < attrs.size(); i++) { if (i > 0) grid.append(\"|\"); for (int k = colWidths[i]; k > 0; k--) { grid.append(\"-\"); } } if (delimTrailing) grid.append(\"|\"); grid.append(\"\\n\"); }   int firstRow = append ? totalRows : 0; if (append) { grid.append(\"\\n\"); } for (int i = firstRow; i < allRows.size(); i++) { ResultSetRow row = allRows.get(i); if (delimLeading) grid.append(\"|\"); for (int k = 0; k < attrs.size(); k++) { if (k > 0) grid.append(\"|\"); DBDAttributeBinding attr = attrs.get(k); String displayString = getCellString(model, attr, row, displayFormat); if (displayString.length() >= colWidths[k]) { displayString = CommonUtils.truncateString(displayString, colWidths[k]); }  int stringWidth = getStringWidth(displayString);  if (extraSpaces) grid.append(\" \"); DBPDataKind dataKind = attr.getDataKind(); if ((dataKind == DBPDataKind.NUMERIC && rightJustifyNumbers) || (dataKind == DBPDataKind.DATETIME && rightJustifyDateTime)) {  for (int j = colWidths[k] - stringWidth - extraSpacesNum; j > 0; j--) { grid.append(\" \"); } grid.append(displayString); } else { grid.append(displayString); for (int j = colWidths[k] - stringWidth - extraSpacesNum; j > 0; j--) { grid.append(\" \"); } } if (extraSpaces) grid.append(\" \"); } if (delimTrailing) grid.append(\"|\"); grid.append(\"\\n\"); } grid.setLength(grid.length() - 1);  if (append) { text.append(grid.toString()); } else { text.setText(grid.toString()); }  totalRows = allRows.size();",
        "label":0
    },
    {
        "ins1CurCode":"CronTab x = new CronTab(\"0,30 * * * *\"); Calendar c = new GregorianCalendar(2000,2,1,1,10); compare(new GregorianCalendar(2000,2,1,1,30),x.ceil(c));   c =     new GregorianCalendar(2000,2,1,1,40); compare(new GregorianCalendar(2000,2,1,2, 0),x.ceil(c));",
        "ins1PreCode":"CronTab x = new CronTab(\"0,30 * * * *\"); Calendar c = new GregorianCalendar(2000,2,1,1,10); assertEquals(new GregorianCalendar(2000,2,1,1,30),x.ceil(c));   c =          new GregorianCalendar(2000,2,1,1,40); assertEquals(new GregorianCalendar(2000,2,1,2, 0),x.ceil(c));",
        "ins2PreCode":"Calendar c = new GregorianCalendar(2010,0,1,15,55);  assertEquals(new GregorianCalendar(2010,7,1,0,0),x.ceil(c));",
        "label":0
    },
    {
        "ins1CurCode":" configuration.addMapper(MultipleIncludePersonMapper.class); c.close(); ",
        "ins1PreCode":" configuration.addMapper(MultipleIncludePersonMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":" configuration.addMapper(MultipleReverseIncludePersonMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1CurCode":"config.put(\"separator\", \"\\\\.\"); try { factory.create(null, null, null, config); fail(\"factory create should have failed\");",
        "ins1PreCode":"config.put(\"separator\", \"\\\\.\"); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "ins2PreCode":"config.put(\"separator\", \"-\"); try { factory.create(null, null, config); fail(\"factory create should have failed\");",
        "label":1
    },
    {
        "ins1CurCode":"org.apache.catalina.Context ctxt  = tomcat.addWebapp( null, \"/examples\", appDir.getAbsolutePath()); ctxt.addApplicationListener(WsContextListener.class.getName()); ",
        "ins1PreCode":"org.apache.catalina.Context ctxt  = tomcat.addWebapp( null, \"/examples\", appDir.getAbsolutePath()); ctxt.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false)); ",
        "ins2PreCode":"org.apache.catalina.Context ctxt  = tomcat.addWebapp( null, \"/examples\", appDir.getAbsolutePath()); ctxt.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false)); ",
        "label":1
    },
    {
        "ins1CurCode":"Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "ins1PreCode":"Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\"));",
        "ins2PreCode":"Observable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicate).toObservable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\"));",
        "label":1
    },
    {
        "ins1CurCode":"private void validateLifetime(final PooledObject<PoolableConnection> p) throws Exception { if (maxConnLifetimeMillis > 0) { final long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) {",
        "ins1PreCode":"private void validateLifetime(PooledObject<PoolableConnection> p) throws Exception { if (maxConnLifetimeMillis > 0) { long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) {",
        "ins2PreCode":"private void validateLifetime(PooledObject<PooledConnectionAndInfo> p) throws Exception { if (maxConnLifetimeMillis > 0) { long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) {",
        "label":1
    },
    {
        "ins1CurCode":"if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", RequestUtil.filter(displayPath))); return;",
        "ins1PreCode":"if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", HttpMessages.filter(displayPath))); return;",
        "ins2PreCode":"if (context == null) { writer.println(smClient.getString(\"managerServlet.noContext\", HttpMessages.filter(displayPath))); return;",
        "label":1
    },
    {
        "ins1CurCode":"Completable c = c1.ambWith(c2);  final AtomicReference<Throwable> complete = new AtomicReference<>(); ",
        "ins1PreCode":"Completable c = c1.ambWith(c2);  final AtomicReference<Throwable> complete = new AtomicReference<Throwable>(); ",
        "ins2PreCode":"Completable c = c1.ambWith(c2);  final AtomicReference<Throwable> complete = new AtomicReference<Throwable>(); ",
        "label":1
    },
    {
        "ins1CurCode":"tickDate = unit.rollDate(tickDate, this.timeZone); hasRolled = true; } }",
        "ins1PreCode":"tickDate = unit.rollDate(tickDate, this.timeZone); hasRolled = true; continue; }",
        "ins2PreCode":"protected List refreshTicksVertical(Graphics2D g2, Rectangle2D dataArea, RectangleEdge edge) {  List result = new java.util.ArrayList();  Font tickLabelFont = getTickLabelFont(); g2.setFont(tickLabelFont);  if (isAutoTickUnitSelection()) { selectAutoTickUnit(g2, dataArea, edge); } DateTickUnit unit = getTickUnit(); Date tickDate = calculateLowestVisibleTickValue(unit); Date upperDate = getMaximumDate();  boolean hasRolled = false; while (tickDate.before(upperDate)) {   if (!hasRolled) { tickDate = correctTickDateForPosition(tickDate, unit, this.tickMarkPosition); }  long lowestTickTime = tickDate.getTime(); long distance = unit.addToDate(tickDate, this.timeZone).getTime() - lowestTickTime; int minorTickSpaces = getMinorTickCount(); if (minorTickSpaces <= 0) { minorTickSpaces = unit.getMinorTickCount(); } for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { long minorTickTime = lowestTickTime - distance * minorTick / minorTickSpaces; if (minorTickTime > 0 && getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); } } if (!isHiddenValue(tickDate.getTime())) {  String tickLabel; DateFormat formatter = getDateFormatOverride(); if (formatter != null) { tickLabel = formatter.format(tickDate); } else { tickLabel = this.tickUnit.dateToString(tickDate); } TextAnchor anchor, rotationAnchor; double angle = 0.0; if (isVerticalTickLabels()) { anchor = TextAnchor.BOTTOM_CENTER; rotationAnchor = TextAnchor.BOTTOM_CENTER; if (edge == RectangleEdge.LEFT) { angle = -Math.PI / 2.0; } else { angle = Math.PI / 2.0; } } else { if (edge == RectangleEdge.LEFT) { anchor = TextAnchor.CENTER_RIGHT; rotationAnchor = TextAnchor.CENTER_RIGHT; } else { anchor = TextAnchor.CENTER_LEFT; rotationAnchor = TextAnchor.CENTER_LEFT; } }  Tick tick = new DateTick(tickDate, tickLabel, anchor, rotationAnchor, angle); result.add(tick); hasRolled = false;  long currentTickTime = tickDate.getTime(); tickDate = unit.addToDate(tickDate, this.timeZone); long nextTickTime = tickDate.getTime(); for (int minorTick = 1; minorTick < minorTickSpaces; minorTick++) { long minorTickTime = currentTickTime + (nextTickTime - currentTickTime) * minorTick / minorTickSpaces; if (getRange().contains(minorTickTime) && (!isHiddenValue(minorTickTime))) { result.add(new DateTick(TickType.MINOR, new Date(minorTickTime), \"\", TextAnchor.TOP_CENTER, TextAnchor.CENTER, 0.0)); } } } else { tickDate = unit.rollDate(tickDate, this.timeZone); hasRolled = true; } } return result;",
        "label":0
    },
    {
        "ins1CurCode":"public void transitiveClosure_directedPathGraph() { MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N2, N3); directedGraph.putEdge(N3, N4);  MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1);",
        "ins1PreCode":"public void transitiveClosure_directedPathGraph() { MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N2, N3); directedGraph.putEdge(N3, N4);  MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1);",
        "ins2PreCode":"public void transitiveClosure_undirectedPathGraph() { MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(false).build(); undirectedGraph.putEdge(N1, N2); undirectedGraph.putEdge(N2, N3); undirectedGraph.putEdge(N3, N4);  MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1CurCode":"assertEquals(Arrays.asList(a1, a2), thing.getActions()); assertThat(thing.removeAction(a1), is(true)); assertEquals(Collections.singletonList(a2), thing.getActions()); assertThat(thing.removeAction(a1), is(false)); assertEquals(Collections.singletonList(a2), thing.getActions()); assertThat(thing.removeAction(null), is(false)); assertEquals(Collections.singletonList(a2), thing.getActions());",
        "ins1PreCode":"assertEquals(Arrays.asList(a1, a2), thing.getActions()); assertThat(thing.removeAction(a1), is(true)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeAction(a1), is(false)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeAction(null), is(false)); assertEquals(Arrays.asList(a2), thing.getActions());",
        "ins2PreCode":"assertEquals(Arrays.asList(a1, a2), thing.getActions()); assertThat(thing.removeActions(CauseAction.class), is(true)); assertEquals(Arrays.asList(a2), thing.getActions()); assertThat(thing.removeActions(CauseAction.class), is(false)); assertEquals(Arrays.asList(a2), thing.getActions());",
        "label":0
    },
    {
        "ins1CurCode":"public void orderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposable.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "ins1PreCode":"public void orderedFastPathRequest1() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createOrdered(ts, d);",
        "ins2PreCode":"public void unorderedSlowPath() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(1); Disposable d = Disposables.empty(); QueueDrainSubscriber<Integer, Integer, Integer> qd = createUnordered(ts, d);",
        "label":1
    },
    {
        "ins1CurCode":"void bindToArrayWhenMultipleSourceShouldOnlyUseFirst() { MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();",
        "ins1PreCode":"public void bindToArrayWhenMultipleSourceShouldOnlyUseFirst() { MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToCollectionWhenMultipleSourceShouldOnlyUseFirst() { MockConfigurationPropertySource source1 = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1CurCode":"@Override public void subscribe(SingleObserver<? super String> observer) { observer.onSubscribe(Disposable.empty()); try {",
        "ins1PreCode":"@Override public void subscribe(SingleObserver<? super String> observer) { observer.onSubscribe(Disposables.empty()); try {",
        "ins2PreCode":"@Override public void subscribe(SingleObserver<? super String> observer) { observer.onSubscribe(Disposables.empty()); try {",
        "label":1
    },
    {
        "ins1CurCode":" postWelcomeFiles(); if(this.getState().equals(LifecycleState.STARTED)) fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);",
        "ins1PreCode":" postWelcomeFiles(); fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name); ",
        "ins2PreCode":"public void removeWatchedResource(String name) {  synchronized (watchedResourcesLock) {   int n = -1; for (int i = 0; i < watchedResources.length; i++) { if (watchedResources[i].equals(name)) { n = i; break; } } if (n < 0) return;   int j = 0; String results[] = new String[watchedResources.length - 1]; for (int i = 0; i < watchedResources.length; i++) { if (i != n) results[j++] = watchedResources[i]; } watchedResources = results;  }  fireContainerEvent(\"removeWatchedResource\", name); ",
        "label":0
    },
    {
        "ins1CurCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins1PreCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"void addFieldWithLongerLength() throws IOException {  String bibtexEntry = OS.NEWLINE + OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author =  {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number =  {1},\" + OS.NEWLINE + \"  note =    {some note},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.HOWPUBLISHED, \"asdf\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1CurCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":" long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins2PreCode":"public void testDataSendASYNC() throws Exception { System.err.println(\"Starting ASYNC\"); for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS);  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "label":0
    },
    {
        "ins1CurCode":"try { buildModelList();  if ( LOG.isLoggable( Level.FINE ) ) { long endTime = System.currentTimeMillis(); LOG.log(Level.FINE, \"buildModelList took \" + (endTime - startTime) + \" msec. for \" + this.getClass().getName()); } } catch (InvalidElementException e) { LOG.log(Level.WARNING, \"buildModelList attempted to operate on \" + \"deleted element\");",
        "ins1PreCode":"buildModelList(); long endTime = System.currentTimeMillis(); LOG.debug(\"buildModelList took \" + (endTime - startTime) + \" msec. for \" + this.getClass().getName()); } catch (InvalidElementException e) { LOG.warn(\"buildModelList attempted to operate on \" + \"deleted element\");",
        "ins2PreCode":"buildModelList(); long endTime = System.currentTimeMillis(); LOG.debug(\"buildModelList took \" + (endTime - startTime) + \" msec. for \" + this.getClass().getName()); } catch (InvalidElementException e) { LOG.warn(\"buildModelList attempted to operate on \" + \"deleted element\");",
        "label":1
    },
    {
        "ins1CurCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins1PreCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"void roundTripWithModification() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author  = {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1CurCode":"public void test_latest_longer_list() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null); List<ModelObject> runs = newRuns(1, 10); List<Queue.Item> queueItems = newQueueItems(11, 12);  historyPageFilter.add(runs, queueItems); ",
        "ins1PreCode":"public void test_latest_longer_list() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); itemList.addAll(newQueueItems(11, 12));  historyPageFilter.add(itemList); ",
        "ins2PreCode":"public void test_latest_partial_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 2)); itemList.addAll(newQueueItems(3, 4));   Assert.assertEquals(HistoryPageEntry.getEntryId(1), HistoryPageEntry.getEntryId(itemList.get(0))); historyPageFilter.add(itemList); Assert.assertEquals(4, HistoryPageEntry.getEntryId(itemList.get(0))); ",
        "label":0
    },
    {
        "ins1CurCode":"} catch (IndexOutOfBoundsException e) { throw new OutOfSpaceException( String.format(\"Pos: %d, limit: %d, len: %d\", position, limit, 1), e); }",
        "ins1PreCode":"} catch (IndexOutOfBoundsException e) { throw new OutOfSpaceException( new IndexOutOfBoundsException( String.format(\"Pos: %d, limit: %d, len: %d\", position, limit, 1))); }",
        "ins2PreCode":"final void bufferFixed32NoTag(int value) { buffer[position++] = (byte) (value & 0xFF); buffer[position++] = (byte) ((value >> 8) & 0xFF); buffer[position++] = (byte) ((value >> 16) & 0xFF); buffer[position++] = (byte) ((value >> 24) & 0xFF); totalBytesWritten += FIXED_32_SIZE;",
        "label":0
    },
    {
        "ins1CurCode":"nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins1PreCode":"nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins2PreCode":"nMatchingItems++; } fireTreeNodesInserted(this, path, childIndices, children); }",
        "label":1
    },
    {
        "ins1CurCode":"public void merge1SyncStreamOf1000000() { TestObserver<Integer> to = new TestObserver<>(); mergeNSyncStreamsOfN(1, 1000000).subscribe(to);",
        "ins1PreCode":"public void merge1SyncStreamOf1000000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(1, 1000000).subscribe(to);",
        "ins2PreCode":"public void merge1000SyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(1000, 1000).subscribe(to);",
        "label":1
    },
    {
        "ins1CurCode":"try {  final AtomicReference<CompletableObserver> ref = new AtomicReference<>(); ",
        "ins1PreCode":"try {  final AtomicReference<CompletableObserver> ref = new AtomicReference<CompletableObserver>(); ",
        "ins2PreCode":"try {  final AtomicReference<CompletableObserver> ref = new AtomicReference<CompletableObserver>(); ",
        "label":1
    },
    {
        "ins1CurCode":"public Principal authenticate(String username, String credentials) {  JNDIConnection connection = null; Principal principal = null;  try {   connection = get();    try {   principal = authenticate(connection, username, credentials);  } catch (NullPointerException | NamingException e) {                 containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   close(connection);   connection = get();   principal = authenticate(connection, username, credentials); }    release(connection);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   close(connection); ",
        "ins1PreCode":"public Principal authenticate(String username, String credentials) {  DirContext context = null; Principal principal = null;  try {   context = open();    try {   principal = authenticate(context, username, credentials);  } catch (NullPointerException | NamingException e) {                 containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials); }    release(context);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   if (context != null) close(context); ",
        "ins2PreCode":"GSSCredential gssCredential) {  DirContext context = null; Principal principal = null;  try {   context = open();    try {   principal = getPrincipal(context, username, gssCredential);  } catch (CommunicationException | ServiceUnavailableException e) {   containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = getPrincipal(context, username, gssCredential);  }    release(context);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   if (context != null) close(context); ",
        "label":1
    },
    {
        "ins1CurCode":"public void testLangRawWithInclude() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins1PreCode":"public void testLangRawWithInclude() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); List<Name> answer = sqlSession.selectList(\"selectRawWithInclude\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testLangRawWithIncludeAndCData() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Parameter p = new Parameter(true, \"Fli%\"); List<Name> answer = sqlSession.selectList(\"selectRawWithIncludeAndCData\", p); assertEquals(3, answer.size()); for (Name n : answer) { assertEquals(\"Flintstone\", n.getLastName()); } } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1CurCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return Flowable.fromArray(source1, source2, source3, source4).flatMapSingle(Functions.identity(), false, Integer.MAX_VALUE);",
        "ins1PreCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return merge(Flowable.fromArray(source1, source2, source3, source4));",
        "ins2PreCode":"Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return mergeDelayError(Flowable.fromArray(source1, source2, source3, source4));",
        "label":0
    },
    {
        "ins1CurCode":" cmdl.createArgument().setValue(\"-OUTPUT_DIRECTORY:\" + getDefaultOutputDirectory()); ",
        "ins1PreCode":"File javaFile = null;   if (outputDirectory == null) {",
        "ins2PreCode":"public void execute() throws BuildException {   Enumeration iter = optionalAttrs.keys(); while (iter.hasMoreElements()) { String name  = (String) iter.nextElement(); Object value = optionalAttrs.get(name); cmdl.createArgument() .setValue(\"-\" + name + \":\" + value.toString()); }  if (target == null || !target.isFile()) { throw new BuildException(\"Invalid target: \" + target); }  if (outputFile != null) { cmdl.createArgument() .setValue(\"-\" + OUTPUT_FILE + \":\" + outputFile.replace('\\\\', '/')); }   File javaFile = new File(createOutputFileName(target, outputFile, plainText));  if (javaFile.exists() && target.lastModified() < javaFile.lastModified()) { log(\"Target is already built - skipping (\" + target + \")\", Project.MSG_VERBOSE); return; }  cmdl.createArgument().setValue(target.getAbsolutePath());  cmdl.setClassname(JavaCC.getMainClass(javaccHome, JavaCC.TASKDEF_TYPE_JJDOC));  final Path classpath = cmdl.createClasspath(getProject()); final File javaccJar = JavaCC.getArchiveFile(javaccHome); classpath.createPathElement().setPath(javaccJar.getAbsolutePath()); classpath.addJavaRuntime();  final Commandline.Argument arg = cmdl.createVmArgument(); arg.setValue(\"-mx140M\"); arg.setValue(\"-Dinstall.root=\" + javaccHome.getAbsolutePath());  final Execute process = new Execute(new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_INFO), null); log(cmdl.describeCommand(), Project.MSG_VERBOSE); process.setCommandline(cmdl.getCommandline());  try { if (process.execute() != 0) { throw new BuildException(\"JJDoc failed.\"); } } catch (IOException e) { throw new BuildException(\"Failed to launch JJDoc\", e); }",
        "label":0
    },
    {
        "ins1CurCode":" Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); Assert.assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":" Collection<String> result = autoCompleter.call(getRequest((\"test\"))); Assert.assertEquals(Arrays.asList(\"testValue\"), result);",
        "label":1
    },
    {
        "ins1CurCode":"public void testExceedMaxActiveStreams02() throws Exception {  enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendRst(3, Http2Error.NO_ERROR.getCode());   parser.readFrame(true); Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace()); output.clearTrace();   sendWindowUpdate(0, (1 << 31) - 2);   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "ins1PreCode":"public void testExceedMaxActiveStreams02() throws Exception {  LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.ALL); try {     enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendRst(3, Http2Error.NO_ERROR.getCode());   parser.readFrame(true); Assert.assertEquals(\"3-RST-[5]\\n\", output.getTrace()); output.clearTrace();   sendWindowUpdate(0, (1 << 31) - 2);   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace()); } finally { LogManager.getLogManager().getLogger(\"org.apache.coyote\").setLevel(Level.INFO); }",
        "ins2PreCode":"public void testExceedMaxActiveStreams01() throws Exception {  enableHttp2(1); configureAndStartWebApplication(); openClientConnection(); doHttpUpgrade(); sendClientPreface();   parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true); parser.readFrame(true);  Assert.assertEquals(\"0-Settings-[3]-[1]\\n\" + \"0-Settings-End\\n\" + \"0-Settings-Ack\\n\" + \"0-Ping-[0,0,0,0,0,0,0,1]\\n\" + getSimpleResponseTrace(1) , output.getTrace()); output.clearTrace();  sendLargeGetRequest(3);  sendSimpleGetRequest(5);          for (int i = 0; i < 9; i++) { parser.readFrame(true); }  Assert.assertTrue(output.getTrace(), output.getTrace().contains(\"5-RST-[\" + Http2Error.REFUSED_STREAM.getCode() + \"]\")); output.clearTrace();      sendWindowUpdate(0, (1 << 31) - 2);  sendWindowUpdate(3, (1 << 31) - 8193);   while (!output.getTrace().contains(\"3-EndOfStream\")) { parser.readFrame(true); } output.clearTrace();   sendSimpleGetRequest(7); parser.readFrame(true); parser.readFrame(true); Assert.assertEquals(getSimpleResponseTrace(7), output.getTrace());",
        "label":0
    },
    {
        "ins1CurCode":"assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCitationKey()); assertEquals(2, parsedEntry.getFields().size());",
        "ins1PreCode":"assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size());",
        "ins2PreCode":"assertEquals(1, parsedEntries.size()); assertEquals(StandardEntryType.Article, parsedEntry.getType()); assertEquals(Optional.of(\"test\"), parsedEntry.getCiteKeyOptional()); assertEquals(2, parsedEntry.getFields().size());",
        "label":1
    },
    {
        "ins1CurCode":"public void testSingle10() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb; q =\\t1\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q1_000, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testSingle10() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testSingle11() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.50\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "label":1
    },
    {
        "ins1CurCode":"public void edgesConnecting_checkReturnedSetMutability() { assume().that(graphIsMutable()).isTrue();  assume().that(graphIsMutable()).isTrue();  addNode(N1);",
        "ins1PreCode":"public void edgesConnecting_checkReturnedSetMutability() { addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23);",
        "ins2PreCode":"public void edgesConnecting_checkReturnedSetMutability() { addNode(N1); addNode(N2); Set<String> edgesConnecting = network.edgesConnecting(N1, N2); try { edgesConnecting.add(E23); fail(ERROR_MODIFIABLE_COLLECTION); } catch (UnsupportedOperationException e) { addEdge(N1, N2, E12); assertThat(network.edgesConnecting(N1, N2)).containsExactlyElementsIn(edgesConnecting); }",
        "label":0
    },
    {
        "ins1CurCode":"public void testGetStartValue3() { TaskSeriesCollection<String, String> c = new TaskSeriesCollection<>(); TaskSeries<String> s = new TaskSeries<>(\"Series 1\");",
        "ins1PreCode":"public void testGetStartValue3() { TaskSeriesCollection c = new TaskSeriesCollection(); TaskSeries<String> s = new TaskSeries<>(\"Series 1\");",
        "ins2PreCode":"public void testGetEndValue3() { TaskSeriesCollection c = new TaskSeriesCollection(); TaskSeries<String> s = new TaskSeries<>(\"Series 1\");",
        "label":1
    },
    {
        "ins1CurCode":"map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandler(map); Assertions.assertNotNull(user); }",
        "ins1PreCode":"map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandler(map); Assert.assertNotNull(user); }",
        "ins2PreCode":"map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandlerXml(map); Assert.assertNotNull(user); }",
        "label":1
    },
    {
        "ins1CurCode":"this.messageConverters, this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, copiedSetOf(requestCustomizers));",
        "ins1PreCode":"this.messageConverters, this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, setOf(requestCustomizers));",
        "ins2PreCode":"public RestTemplateBuilder additionalRequestCustomizers( Collection<? extends RestTemplateRequestCustomizer<?>> requestCustomizers) { Assert.notNull(requestCustomizers, \"RequestCustomizers must not be null\"); return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, this.messageConverters, this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, append(this.requestCustomizers, requestCustomizers));",
        "label":0
    },
    {
        "ins1CurCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins1PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "ins2PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); ",
        "label":1
    },
    {
        "ins1CurCode":"public XYPlot findSubplot(PlotRenderingInfo info, Point2D source) { Args.nullNotPermitted(info, \"info\"); Args.nullNotPermitted(source, \"source\"); XYPlot result = null;",
        "ins1PreCode":"public XYPlot findSubplot(PlotRenderingInfo info, Point2D source) { ParamChecks.nullNotPermitted(info, \"info\"); ParamChecks.nullNotPermitted(source, \"source\"); XYPlot result = null;",
        "ins2PreCode":"public CategoryPlot findSubplot(PlotRenderingInfo info, Point2D source) { ParamChecks.nullNotPermitted(info, \"info\"); ParamChecks.nullNotPermitted(source, \"source\"); CategoryPlot result = null;",
        "label":1
    },
    {
        "ins1CurCode":"return Flowable.just(Thread.currentThread().getName()); } }, false, 2, Schedulers.single()) .test()",
        "ins1PreCode":"return Flowable.just(Thread.currentThread().getName()); } }, 2, false, Schedulers.single()) .test()",
        "ins2PreCode":"return Flowable.just(Thread.currentThread().getName()); } }, 2, true, Schedulers.single()) .test()",
        "label":1
    },
    {
        "ins1CurCode":"  DefaultCategoryDataset<String, String> dataset = new DefaultCategoryDataset<>(); assertNull(r.findRangeBounds(dataset));",
        "ins1PreCode":"  DefaultCategoryDataset dataset = new DefaultCategoryDataset(); assertNull(r.findRangeBounds(dataset));",
        "ins2PreCode":"  DefaultCategoryDataset dataset = new DefaultCategoryDataset(); assertNull(r.findRangeBounds(dataset));",
        "label":1
    },
    {
        "ins1CurCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Disconnect permission\")); assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "ins1PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Disconnect permission\")); assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins2PreCode":"assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Connect permission\")); assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "label":1
    },
    {
        "ins1CurCode":"public void merge1SyncStreamOf1000000() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNSyncStreamsOfN(1, 1000000).subscribe(ts);",
        "ins1PreCode":"public void merge1SyncStreamOf1000000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(1, 1000000).subscribe(ts);",
        "ins2PreCode":"public void merge1000SyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(1000, 1000).subscribe(ts);",
        "label":1
    }
]
