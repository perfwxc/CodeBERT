[
    {
        "ins1AddCode":"void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception {",
        "ins1DelCode":"public void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception {",
        "ins1PreCode":"public void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception { WithMockBean instance = new WithMockBean(); TestContext mockTestContext = mockTestContext(instance);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ExceptionUtils.handleThrowable(t);",
        "ins1DelCode":"",
        "ins1PreCode":"((HttpSessionActivationListener)attribute) .sessionWillPassivate(event); } catch (Throwable t) { manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t); }",
        "ins2PreCode":"((HttpSessionActivationListener)attribute) .sessionDidActivate(event); } catch (Throwable t) { manager.getContainer().getLogger().error (sm.getString(\"standardSession.attributeEvent\"), t); }",
        "label":1
    },
    {
        "ins1AddCode":"String resource = \"org/apache/ibatis/jdbc/ScriptMissingEOLTerminator.sql\"; try (Connection conn = ds.getConnection(); Reader reader = Resources.getResourceAsReader(resource)) { ScriptRunner runner = new ScriptRunner(conn); runner.setAutoCommit(true); runner.setStopOnError(false); runner.setErrorLogWriter(null); runner.setLogWriter(null); try { runner.runScript(reader); fail(\"Expected script runner to fail due to missing end of line terminator.\"); } catch (Exception e) { assertTrue(e.getMessage().contains(\"end-of-line terminator\")); }",
        "ins1DelCode":"Connection conn = ds.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setAutoCommit(true); runner.setStopOnError(false); runner.setErrorLogWriter(null); runner.setLogWriter(null); String resource = \"org/apache/ibatis/jdbc/ScriptMissingEOLTerminator.sql\"; Reader reader = Resources.getResourceAsReader(resource); try { runner.runScript(reader); fail(\"Expected script runner to fail due to missing end of line terminator.\"); } catch (Exception e) { assertTrue(e.getMessage().contains(\"end-of-line terminator\")); reader.close(); conn.close();",
        "ins1PreCode":"public void shouldReturnWarningIfEndOfLineTerminatorNotFound() throws Exception { DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES); Connection conn = ds.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setAutoCommit(true); runner.setStopOnError(false); runner.setErrorLogWriter(null); runner.setLogWriter(null);  String resource = \"org/apache/ibatis/jdbc/ScriptMissingEOLTerminator.sql\"; Reader reader = Resources.getResourceAsReader(resource);  try { runner.runScript(reader); fail(\"Expected script runner to fail due to missing end of line terminator.\"); } catch (Exception e) { assertTrue(e.getMessage().contains(\"end-of-line terminator\")); } reader.close(); conn.close();",
        "ins2PreCode":"public void shouldReturnWarningIfNotTheCurrentDelimiterUsed() throws Exception { DataSource ds = createUnpooledDataSource(JPETSTORE_PROPERTIES); Connection conn = ds.getConnection(); ScriptRunner runner = new ScriptRunner(conn); runner.setAutoCommit(false); runner.setStopOnError(true); runner.setErrorLogWriter(null); runner.setLogWriter(null); String resource = \"org/apache/ibatis/jdbc/ScriptChangingDelimiterMissingDelimiter.sql\"; Reader reader = Resources.getResourceAsReader(resource); try { runner.runScript(reader); fail(\"Expected script runner to fail due to the usage of invalid delimiter.\"); } catch (Exception e) { assertTrue(e.getMessage().contains(\"end-of-line terminator\")); } reader.close(); conn.close();",
        "label":1
    },
    {
        "ins1AddCode":"final boolean layoutEnabled = isLayoutEnabled(); if (layoutEnabled) {",
        "ins1DelCode":"final boolean editEnabled = isEditEnabled(); if (editEnabled) {",
        "ins1PreCode":"{ getDiagram().getModelAdapter().installPartEditPolicies(this);  final boolean editEnabled = isEditEnabled(); if (editEnabled) { installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new EntityConnectionEditPolicy()); ",
        "ins2PreCode":"if (editEnabled) { getDiagram().getModelAdapter().installPartEditPolicies(this); final boolean editEnabled = isEditEnabled(); if (editEnabled) { installEditPolicy(EditPolicy.GRAPHICAL_NODE_ROLE, new EntityConnectionEditPolicy());",
        "label":1
    },
    {
        "ins1AddCode":"public void setUp() throws Exception {",
        "ins1DelCode":"protected void setUp() throws Exception { super.setUp();",
        "ins1PreCode":"protected void setUp() throws Exception { super.setUp(); channel1 = new GroupChannel(); channel1.addInterceptor(new MessageDispatch15Interceptor());",
        "ins2PreCode":"protected void setUp() throws Exception { super.setUp(); channel1 = new GroupChannel(); channel1.addInterceptor(new MessageDispatch15Interceptor());",
        "label":1
    },
    {
        "ins1AddCode":"Container container = null; container = (Container) getManagedResource();",
        "ins1DelCode":"ContainerBase container = null; container = (ContainerBase) getManagedResource();",
        "ins1PreCode":"public String[] findLifecycleListenerNames() throws MBeanException { ContainerBase container = null; List<String> result = new ArrayList<String>();  try { container = (ContainerBase) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e);",
        "ins2PreCode":"public String[] findContainerListenerNames() throws MBeanException { ContainerBase container = null; List<String> result = new ArrayList<String>(); try { container = (ContainerBase) getManagedResource(); } catch (InstanceNotFoundException e) { throw new MBeanException(e);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<String> subscriber = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<String> subscriber = new TestSubscriberEx<String>();",
        "ins1PreCode":"public void shouldTimeoutIfOnNextNotWithinTimeout() { TestSubscriberEx<String> subscriber = new TestSubscriberEx<String>();  withTimeout.subscribe(subscriber);",
        "ins2PreCode":"public void shouldTimeoutIfOnNextNotWithinTimeout() { TestObserverEx<String> observer = new TestObserverEx<String>(); withTimeout.subscribe(observer);",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void blockingSubscribeObserver() { final List<Object> list = new ArrayList<Object>();  Flowable.range(1, 5)",
        "ins2PreCode":"public void blockingSubscribeObserver() { final List<Object> list = new ArrayList<Object>(); Observable.range(1, 5)",
        "label":1
    },
    {
        "ins1AddCode":"ObjectName sname = new ObjectName(getDomain() + \":type=StoreConfig\"); if (mserver.isRegistered(sname)) { mserver.invoke(sname, \"storeConfig\", null, null); } else { log.error(sm.getString(\"standardServer.storeConfig.notAvailable\", sname)); }",
        "ins1DelCode":"ObjectName sname = null; sname = new ObjectName(\"Catalina:type=StoreConfig\"); if(mserver.isRegistered(sname)) { mserver.invoke(sname, \"storeConfig\", null, null); } else log.error(\"StoreConfig mbean not registered\" + sname);",
        "ins1PreCode":"public synchronized void storeConfig() throws Exception {  ObjectName sname = null; try { sname = new ObjectName(\"Catalina:type=StoreConfig\"); if(mserver.isRegistered(sname)) { mserver.invoke(sname, \"storeConfig\", null, null); } else log.error(\"StoreConfig mbean not registered\" + sname); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); } ",
        "ins2PreCode":"public synchronized void storeContext(Context context) throws Exception { ObjectName sname = null; try { sname = new ObjectName(getDomain() + \":type=StoreConfig\"); if(mserver.isRegistered(sname)) { mserver.invoke(sname, \"store\", } else log.error(\"StoreConfig mbean not registered\" + sname); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); }",
        "label":0
    },
    {
        "ins1AddCode":"String cnonce, String qop) {",
        "ins1DelCode":"String cnonce, String qop) throws NoSuchAlgorithmException {",
        "ins1PreCode":"private static String buildDigestResponse(String user, String pwd, String uri, String realm, String nonce, String opaque, String nc, String cnonce, String qop) throws NoSuchAlgorithmException {  String a1 = user + \":\" + realm + \":\" + pwd;",
        "ins2PreCode":"private static String buildDigestResponse(String user, String pwd, String uri, String realm, String nonce, String opaque, String nc, String cnonce, String qop) throws NoSuchAlgorithmException { String a1 = user + \":\" + realm + \":\" + pwd;",
        "label":1
    },
    {
        "ins1AddCode":"protected Aggregator doCreateInternal(SearchContext searchContext, Aggregator parent, ValuesSource rawValuesSource = config.getValuesSource();",
        "ins1DelCode":"protected Aggregator doCreateInternal(ValuesSource rawValuesSource, SearchContext searchContext, Aggregator parent,",
        "ins1PreCode":"protected Aggregator doCreateInternal(ValuesSource rawValuesSource, SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket, Map<String, Object> metadata) throws IOException {",
        "ins2PreCode":"protected Aggregator doCreateInternal(ValuesSource rawValuesSource, SearchContext searchContext, Aggregator children, boolean collectsFromSingleBucket, Map<String, Object> metadata) throws IOException {",
        "label":1
    },
    {
        "ins1AddCode":"if (notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[] { new MBeanNotificationInfo( new String[] { \"j2ee.object.created\" }, Notification.class.getName(), \"web application is created\"), new MBeanNotificationInfo( new String[] { \"j2ee.state.starting\" }, Notification.class.getName(), \"change web application is starting\"), new MBeanNotificationInfo( new String[] { \"j2ee.state.running\" }, Notification.class.getName(), \"web application is running\"), new MBeanNotificationInfo( new String[] { \"j2ee.state.stopping\" }, Notification.class.getName(), \"web application start to stopped\"), new MBeanNotificationInfo( new String[] { \"j2ee.object.stopped\" }, Notification.class.getName(), \"web application is stopped\"), new MBeanNotificationInfo( new String[] { \"j2ee.object.deleted\" }, Notification.class.getName(), \"web application is deleted\"), new MBeanNotificationInfo( new String[] { \"j2ee.object.failed\" }, Notification.class.getName(), \"web application failed\") };",
        "ins1DelCode":"if(notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[]{ new MBeanNotificationInfo(new String[] { \"j2ee.object.created\"}, Notification.class.getName(), \"web application is created\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.starting\"}, Notification.class.getName(), \"change web application is starting\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.running\"}, Notification.class.getName(), \"web application is running\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopping\"}, Notification.class.getName(), \"web application start to stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.stopped\"}, Notification.class.getName(), \"web application is stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.deleted\"}, Notification.class.getName(), \"web application is deleted\" ) };",
        "ins1PreCode":"public MBeanNotificationInfo[] getNotificationInfo() {  if(notificationInfo == null) { notificationInfo = new MBeanNotificationInfo[]{ new MBeanNotificationInfo(new String[] { \"j2ee.object.created\"}, Notification.class.getName(), \"web application is created\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.starting\"}, Notification.class.getName(), \"change web application is starting\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.running\"}, Notification.class.getName(), \"web application is running\" ), new MBeanNotificationInfo(new String[] { \"j2ee.state.stopping\"}, Notification.class.getName(), \"web application start to stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.stopped\"}, Notification.class.getName(), \"web application is stopped\" ), new MBeanNotificationInfo(new String[] { \"j2ee.object.deleted\"}, Notification.class.getName(), \"web application is deleted\" ) };  }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public synchronized String get() { ConfidentialStore cs = ConfidentialStore.get(); if (secret == null || cs != lastCS) { lastCS = cs; try { byte[] payload = load(); if (payload == null) { payload = cs.randomBytes(length / 2); store(payload); secret = Util.toHexString(payload).substring(0, length); } catch (IOException e) { throw new Error(\"Failed to load the key: \" + getId(), e); return secret;",
        "ins1DelCode":"public String get() { try { if (secret==null) { synchronized (this) { if (secret==null) { byte[] payload = load(); if (payload==null) { payload = ConfidentialStore.get().randomBytes(length/2); store(payload); } secret = Util.toHexString(payload).substring(0,length); } return secret; } catch (IOException e) { throw new Error(\"Failed to load the key: \"+getId(),e);",
        "ins1PreCode":"public String get() { try { if (secret==null) { synchronized (this) { if (secret==null) { byte[] payload = load(); if (payload==null) { payload = ConfidentialStore.get().randomBytes(length/2); store(payload); } secret = Util.toHexString(payload).substring(0,length); } } } return secret; } catch (IOException e) { throw new Error(\"Failed to load the key: \"+getId(),e); }",
        "ins2PreCode":"private SecretKey getKey() { try { if (secret==null) { synchronized (this) { if (secret==null) { byte[] payload = load(); if (payload==null) { payload = ConfidentialStore.get().randomBytes(256); store(payload); } secret = new SecretKeySpec(payload,0,128/8, KEY_ALGORITHM); } } } return secret; } catch (IOException e) { throw new Error(\"Failed to load the key: \"+getId(),e); }",
        "label":1
    },
    {
        "ins1AddCode":"SQLServerTableBase object = command.getObject();",
        "ins1DelCode":"SQLServerTable object = command.getObject();",
        "ins1PreCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) { SQLServerTable object = command.getObject(); actions.add( new SQLDatabasePersistAction(",
        "ins2PreCode":"protected void addObjectDeleteActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actions, ObjectDeleteCommand command, Map<String, Object> options) { OracleTable object = command.getObject(); actions.add( new SQLDatabasePersistAction(",
        "label":0
    },
    {
        "ins1AddCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<@NonNull ? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) {",
        "ins1DelCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) {",
        "ins1PreCode":"public static <T, R> Flowable<R> combineLatestArray(@NonNull Publisher<? extends T>[] sources, @NonNull Function<? super Object[], ? extends R> combiner, int bufferSize) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins2PreCode":"public static <T, R> Flowable<R> zipArray(@NonNull Function<? super Object[], ? extends R> zipper, Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "label":1
    },
    {
        "ins1AddCode":"for ( Artifact a : getArtifacts() ) return Collections.unmodifiableList( list );",
        "ins1DelCode":"for ( Artifact a : getArtifacts()  ) return list;",
        "ins1PreCode":" List<Dependency> list = new ArrayList<>( artifacts.size() );  for ( Artifact a : getArtifacts()  ) {  if ( Artifact.SCOPE_COMPILE.equals( a.getScope() ) || Artifact.SCOPE_RUNTIME.equals( a.getScope() ) ) { Dependency dependency = new Dependency();  dependency.setArtifactId( a.getArtifactId() ); dependency.setGroupId( a.getGroupId() ); dependency.setVersion( a.getVersion() ); dependency.setScope( a.getScope() ); dependency.setType( a.getType() ); dependency.setClassifier( a.getClassifier() );  list.add( dependency ); } } return list;",
        "ins2PreCode":"List<Dependency> list = new ArrayList<>( artifacts.size() ); for ( Artifact a : getArtifacts() ) { if ( Artifact.SCOPE_SYSTEM.equals( a.getScope() ) ) { Dependency dependency = new Dependency(); dependency.setArtifactId( a.getArtifactId() ); dependency.setGroupId( a.getGroupId() ); dependency.setVersion( a.getVersion() ); dependency.setScope( a.getScope() ); dependency.setType( a.getType() ); dependency.setClassifier( a.getClassifier() ); list.add( dependency ); } } return list;",
        "label":1
    },
    {
        "ins1AddCode":"auth.add(Item.READ, user.getId()); auth.add(Item.CONFIGURE, user.getId());",
        "ins1DelCode":"auth.add(Job.READ, user.getId()); auth.add(Job.CONFIGURE, user.getId());",
        "ins1PreCode":"fail(\"AccessDeniedException should be thrown.\"); } } auth.add(Job.READ, user.getId()); auth.add(Job.CONFIGURE, user.getId()); auth.add(Jenkins.READ, user.getId()); ",
        "ins2PreCode":"fail(\"AccessDeniedException should be thrown.\"); } } auth.add(Job.READ, user.getId()); auth.add(Job.CONFIGURE, user.getId()); auth.add(Jenkins.READ, user.getId());",
        "label":1
    },
    {
        "ins1AddCode":"FileUtils.write(uploadedFile, uploadedContent, StandardCharsets.UTF_8);",
        "ins1DelCode":"FileUtils.write(uploadedFile, uploadedContent);",
        "ins1PreCode":" String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent);  FreeStyleBuild build = p.scheduleBuild2(0, new Cause.UserIdCause(), new ParametersAction(",
        "ins2PreCode":"String uploadedContent = \"test-content\"; File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, uploadedContent); FreeStyleBuild build = p.scheduleBuild2(0, new Cause.UserIdCause(), new ParametersAction(",
        "label":1
    },
    {
        "ins1AddCode":"}, NUM_MSG)",
        "ins1DelCode":"})",
        "ins1PreCode":"public Flowable<String> apply(GroupedFlowable<String, String> t1) { return t1.take(1); } }) .subscribe(new TestSubscriber<String>(subscriber)); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"boolean atLeastV11 = dataSource.isAtLeastV11(); if (atLeastV11) { if (atLeastV11) {",
        "ins1DelCode":"boolean atLeastV9 = dataSource.isAtLeastV9(); if (atLeastV9) { if(atLeastV9) {",
        "ins1PreCode":"public Collection<OracleServerSession> getSessions(DBCSession session, Map<String, Object> options) throws DBException { boolean atLeastV9 = dataSource.isAtLeastV9(); try { StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, \"); if (atLeastV9) { sql.append(\"sq.SQL_FULLTEXT, \"); } else { sql.append(\"sq.SQL_TEXT AS SQL_FULLTEXT, \"); } sql.append(\"io.*\\n\" + \"FROM GV$SESSION s, gv$sql sq, gv$sess_io io\\n\" + \"WHERE s.sql_address = sq.address(+)\\n\" + \" AND s.sql_hash_value = sq.hash_value(+)\" + \" AND s.sid = io.sid(+)\" + \" AND s.inst_id = io.inst_id(+)\");    if(atLeastV9) { sql.append(\" AND s.sql_child_number = sq.child_number (+)\"); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY));",
        "ins1DelCode":"List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY));",
        "ins1PreCode":" List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[bibtexkey].*\\\\\\\\.[extension]\", ','); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DefaultTableXYDataset<String> dataset = new DefaultTableXYDataset<>();",
        "ins1DelCode":"DefaultTableXYDataset dataset = new DefaultTableXYDataset();",
        "ins1PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset();  XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false);",
        "ins2PreCode":"public void testDrawWithNullInfo() { try { DefaultTableXYDataset dataset = new DefaultTableXYDataset(); XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(error);",
        "ins1DelCode":"assertTrue(error);",
        "ins1PreCode":"}catch ( ChannelException x ) { if (x.getMessage().contains(\"option flag conflict\")) error = true; } assertTrue(error);",
        "ins2PreCode":"}catch ( ChannelException x ) { if (x.getMessage().contains(\"option flag conflict\")) error = true; } assertFalse(error);",
        "label":1
    },
    {
        "ins1AddCode":"PushGatewayTaskScheduler ownedScheduler = givenScheduleAtFixedRateWillReturnFuture( mock(PushGatewayTaskScheduler.class));",
        "ins1DelCode":"PushGatewayTaskScheduler ownedScheduler = mockScheduler(PushGatewayTaskScheduler.class);",
        "ins1PreCode":"void shutdownWhenOwnsSchedulerDoesShutdownScheduler() { PushGatewayTaskScheduler ownedScheduler = mockScheduler(PushGatewayTaskScheduler.class); PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry, ownedScheduler, this.pushRate, \"job\", this.groupingKey, null);",
        "ins2PreCode":"void shutdownWhenDoesNotOwnSchedulerDoesNotShutdownScheduler() { ThreadPoolTaskScheduler otherScheduler = mockScheduler(ThreadPoolTaskScheduler.class); PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry, otherScheduler, this.pushRate, \"job\", this.groupingKey, null);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset<String, String> newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1DelCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}}; CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);  LocalListener l = new LocalListener();",
        "ins2PreCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}}; = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener();",
        "label":1
    },
    {
        "ins1AddCode":"TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\"), TooltipTextUtil.createText(\" author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED));",
        "ins1DelCode":"TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED));",
        "ins1PreCode":"String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription(); ",
        "ins2PreCode":"String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void assertTestSubscriber() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); oi.subscribe(ts); ",
        "ins2PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"validatePrediction(model, users, products, testData._2(), 0.4, true, testData._3());",
        "ins1DelCode":"validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins1PreCode":" JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.trainImplicit(data.rdd(), features, iterations); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins2PreCode":"JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features) validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "label":1
    },
    {
        "ins1AddCode":"\"  note         = {some note},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  note         = {some note},\" + OS.NEWLINE +",
        "ins1PreCode":"void addFieldWithLongerLength() throws IOException {  String bibtexEntry = OS.NEWLINE + OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author =  {BlaBla},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  number =  {1},\" + OS.NEWLINE + \"  note =    {some note},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.HOWPUBLISHED, \"asdf\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertWarnings(RestMultiSearchTemplateAction.TYPES_DEPRECATION_MESSAGE);",
        "ins1DelCode":"assertWarnings(RestMultiSearchAction.TYPES_DEPRECATION_MESSAGE);",
        "ins1PreCode":"assertEquals(1, request.requests().get(1).getScriptParams().size()); assertEquals(1, request.requests().get(2).getScriptParams().size());  assertWarnings(RestMultiSearchAction.TYPES_DEPRECATION_MESSAGE);",
        "ins2PreCode":"assertEquals(1, request.requests().get(0).getScriptParams().size()); assertEquals(1, request.requests().get(0).getScriptParams().size()); MultiSearchTemplateRequest request = RestMultiSearchTemplateAction.parseRequest(restRequest, true);",
        "label":0
    },
    {
        "ins1AddCode":"public Collection<Marker> getRangeMarkers(int index, Layer layer) { Collection<Marker> result = null; Integer key = index; result = this.foregroundRangeMarkers.get(key); result = this.backgroundRangeMarkers.get(key);",
        "ins1DelCode":"public Collection getRangeMarkers(int index, Layer layer) { Collection result = null; Integer key = new Integer(index); result = (Collection) this.foregroundRangeMarkers.get(key); result = (Collection) this.backgroundRangeMarkers.get(key);",
        "ins1PreCode":"public Collection getRangeMarkers(int index, Layer layer) { Collection result = null; Integer key = new Integer(index); if (layer == Layer.FOREGROUND) { result = (Collection) this.foregroundRangeMarkers.get(key); } else if (layer == Layer.BACKGROUND) { result = (Collection) this.backgroundRangeMarkers.get(key); } if (result != null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public final <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull R> Observable<R> withLatestFrom(",
        "ins1DelCode":"public final <T1, T2, T3, T4, R> Observable<R> withLatestFrom(",
        "ins1PreCode":"public final <T1, T2, T3, T4, R> Observable<R> withLatestFrom( @NonNull ObservableSource<T1> source1, @NonNull ObservableSource<T2> source2, @NonNull ObservableSource<T3> source3, @NonNull ObservableSource<T4> source4,",
        "ins2PreCode":"public final <T1, T2, T3, T4, @NonNull R> Flowable<R> withLatestFrom( @NonNull Publisher<T1> source1, @NonNull Publisher<T2> source2, @NonNull Publisher<T3> source3, @NonNull Publisher<T4> source4,",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Flowable<R> concatMap(Function<? super T, ? extends Publisher<? extends R>> mapper, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) {",
        "ins2PreCode":"public final <R> Flowable<R> concatMapDelayError(Function<? super T, ? extends Publisher<? extends R>> mapper, ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) {",
        "label":1
    },
    {
        "ins1AddCode":"public void getValueShouldUseDirectMapping() {",
        "ins1DelCode":"public void getValueShouldUseDirectMapping() throws Exception {",
        "ins1PreCode":"public void getValueShouldUseDirectMapping() throws Exception { Map<String, Object> source = new LinkedHashMap<>(); source.put(\"key1\", \"value1\");",
        "ins2PreCode":"public void getValueShouldUseDirectMapping() throws Exception { Map<String, Object> source = new LinkedHashMap<>(); source.put(\"key1\", \"value1\");",
        "label":1
    },
    {
        "ins1AddCode":"LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); LatexParserResult expectedParserResult = new LatexParserResult();",
        "ins1DelCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexParserResult expectedParserResult = new TexParserResult();",
        "ins1PreCode":"public void testFileEncodingUtf8() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"utf-8.tex\").toURI());  TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexParserResult expectedParserResult = new TexParserResult();  expectedParserResult.getFileList().add(texFile);",
        "ins2PreCode":"public void testFileEncodingIso88591() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"iso-8859-1.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexParserResult expectedParserResult = new TexParserResult(); expectedParserResult.getFileList().add(texFile);",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Item.READ, Item.CONFIGURE, Jenkins.READ)",
        "ins1DelCode":".authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ)",
        "ins1PreCode":"changeProjectOnTheDisc(project2, \"echo 1\", \"echo 2\");  final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"aProject1\", \"never_created\", \"aProject2\"); ",
        "ins2PreCode":"changeProjectOnTheDisc(project2, \"echo 1\", \"echo 2\"); final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.CONFIGURE, Jenkins.READ) .invokeWithArgs(\"aProject1\", \"never_created1\", \"never_created2\", \"aProject2\");",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 35; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 34; i++) jj_la1[i] = -1;",
        "ins1PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 34; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\"));",
        "ins1PreCode":"assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\"));  assertThat(j.jenkins.getItem(\"aProject1\"), nullValue());",
        "ins2PreCode":"assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job 'never_created'\")); assertThat(result.stderr(), containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")); assertThat(j.jenkins.getItem(\"aProject1\"), nullValue());",
        "label":1
    },
    {
        "ins1AddCode":"Platform.copyMemory( baseObject, baseOffset, arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, numElements, sizeInBytes);",
        "ins1DelCode":"PlatformDependent.copyMemory( baseObject, baseOffset, arrayDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, sizeInBytes ); arrayCopy.pointTo(arrayDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, numElements, sizeInBytes);",
        "ins1PreCode":"public UnsafeArrayData copy() { UnsafeArrayData arrayCopy = new UnsafeArrayData(); final byte[] arrayDataCopy = new byte[sizeInBytes]; PlatformDependent.copyMemory( baseObject, baseOffset, arrayDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, sizeInBytes ); arrayCopy.pointTo(arrayDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, numElements, sizeInBytes); return arrayCopy;",
        "ins2PreCode":"public UnsafeRow copy() { UnsafeRow rowCopy = new UnsafeRow(); final byte[] rowDataCopy = new byte[sizeInBytes]; PlatformDependent.copyMemory( baseObject, baseOffset, rowDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, sizeInBytes ); rowCopy.pointTo(rowDataCopy, PlatformDependent.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); return rowCopy;",
        "label":1
    },
    {
        "ins1AddCode":"void testMaxFileSizePropertyWithXmlConfiguration() {",
        "ins1DelCode":"public void testMaxFileSizePropertyWithXmlConfiguration() {",
        "ins1PreCode":"public void testMaxFileSizePropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-size\", \"100MB\");",
        "ins2PreCode":"public void testTotalSizeCapPropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", expectedSize);",
        "label":1
    },
    {
        "ins1AddCode":"append(this.messageConverters, messageConverters), this.requestFactorySupplier,",
        "ins1DelCode":"append(this.messageConverters, messageConverters), this.requestFactory,",
        "ins1PreCode":"Collection<? extends HttpMessageConverter<?>> messageConverters) { Assert.notNull(messageConverters, \"MessageConverters must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, append(this.messageConverters, messageConverters), this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers,",
        "ins2PreCode":"Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers,",
        "label":1
    },
    {
        "ins1AddCode":"if ( entry != null && entry.isPrimary() ) set.add(entry.getValue()); else if ( entry != null && entry.getPrimary() == null && entry.isBackup() ) set.add(entry.getValue());",
        "ins1DelCode":"if ( entry.isPrimary() ) set.add(entry.getValue());",
        "ins1PreCode":"Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry.isPrimary() ) set.add(entry.getValue()); } return Collections.unmodifiableSet(set);",
        "ins2PreCode":"Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry.isPrimary() ) set.add(key); } return Collections.unmodifiableSet(set);",
        "label":1
    },
    {
        "ins1AddCode":"inOrder.verify( logger ).info( \"--------------------------------[ jar ]---------------------------------\" );",
        "ins1DelCode":"inOrder.verify( logger ).info( \"------------------------------------------------------------------------\" );",
        "ins1PreCode":"inOrder.verify( logger ).info( \"\" ); inOrder.verify( logger ).info( \"------------------< org.apache.maven:maven-embedder >-------------------\" ); inOrder.verify( logger ).info( \"Building Apache Maven Embedder 3.5.4-SNAPSHOT\" ); inOrder.verify( logger ).info( \"------------------------------------------------------------------------\" );",
        "ins2PreCode":"inOrder.verify( logger ).info( \"\" ); inOrder.verify( logger ).info( \"------------------------------------------------------------------------\" ); inOrder.verify( logger ).info( \"Building Apache Maven Project Info Reports Plugin 3.0.0-SNAPSHOT\" ); inOrder.verify( logger ).info( \"------------------------------------------------------------------------\" );",
        "label":0
    },
    {
        "ins1AddCode":"DBeaverNotifications.showNotification(",
        "ins1DelCode":"NotificationUtils.sendNotification(",
        "ins1PreCode":"throw new InvocationTargetException(e); }  NotificationUtils.sendNotification( context.getDataSource(), \"commit\",",
        "ins2PreCode":"throw new InvocationTargetException(e); } throw new InvocationTargetException(e); throw new InvocationTargetException(e); public void run(DBRProgressMonitor monitor)",
        "label":0
    },
    {
        "ins1AddCode":"() -> jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Run.ARTIFACTS));",
        "ins1DelCode":"() -> jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Build.ARTIFACTS));",
        "ins1PreCode":" try (ACLContext ignored = ACL.as2(manager.impersonate2())) { Exception e = Assert.assertThrows(AccessDeniedException.class, () -> jenkins.getACL().checkAnyPermission(Item.WIPEOUT, Build.ARTIFACTS)); Assert.assertEquals(\"manager is missing a permission, one of Job/WipeOut, Run/Artifacts is required\", e.getMessage()); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "ins1DelCode":"Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins1PreCode":"TestMap message = builder.build();  assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.just(1, 2).subscribe(ts); ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; } });",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.just(1, 2).subscribe(ts); thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; }",
        "ins1PreCode":" Flowable.just(1, 2).subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to);  Disposable d = Disposables.empty();  so.onSubscribe(d);",
        "ins2PreCode":"final SerializedObserver<Integer> so = new SerializedObserver<Integer>(to); Disposable d = Disposables.empty(); so.onSubscribe(d);",
        "label":1
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa6_1(active0, 0x40000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa6_1(active0, 0x80000000000L);",
        "ins1PreCode":"switch(curChar) { case 110: return jjMoveStringLiteralDfa6_1(active0, 0x80000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 99: return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"ctxt.addServletMappingDecoded(URI_PROTECTED, \"TesterServlet1\"); collection1.addPatternDecoded(URI_PROTECTED); ctxt.addServletMappingDecoded(URI_PUBLIC, \"TesterServlet2\"); collection2.addPatternDecoded(URI_PUBLIC);",
        "ins1DelCode":"ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); collection1.addPattern(URI_PROTECTED); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); collection2.addPattern(URI_PUBLIC);",
        "ins1PreCode":"  Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint(); ",
        "ins2PreCode":"Tomcat.addServlet(nonloginContext, \"TesterServlet1\", new TesterServlet()); nonloginContext.addServletMapping(URI_PROTECTED, \"TesterServlet1\"); SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); nonloginContext.addConstraint(sc1); Tomcat.addServlet(nonloginContext, \"TesterServlet2\", new TesterServlet()); nonloginContext.addServletMapping(URI_PUBLIC, \"TesterServlet2\"); SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final BehaviorSubject<Object> p = BehaviorSubject.create();  final TestObserver<Object> to = new TestObserver<Object>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final BehaviorSubject<Object> p = BehaviorSubject.create(); final TestObserver<Object> to = new TestObserver<Object>(); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"public void loadGroovyResource() {",
        "ins1DelCode":"public void loadGroovyResource() throws Exception {",
        "ins1PreCode":"public void loadGroovyResource() throws Exception { ClassPathResource resource = new ClassPathResource(\"sample-beans.groovy\", getClass());",
        "ins2PreCode":"public void loadGroovyResourceWithNamespace() throws Exception { ClassPathResource resource = new ClassPathResource(\"sample-namespace.groovy\", getClass());",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\" + LS + LS + \"[0] Inside the definition for plugin 'artifactId', specify the following:\" + LS + LS + \"<configuration>\" + LS + \"  ...\" + LS + \"  <toAddresses>\" + LS + \"    <item>VALUE</item>\" + LS + \"  </toAddresses>\" + LS + \"</configuration>.\" + LS, exception.buildDiagnosticMessage() );",
        "ins1DelCode":"assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\\n\" + \"\\n\" + \"[0] Inside the definition for plugin 'artifactId', specify the following:\\n\" + \"\\n\" + \"<configuration>\\n\" + \"  ...\\n\" + \"  <toAddresses>\\n\" + \"    <item>VALUE</item>\\n\" + \"  </toAddresses>\\n\" + \"</configuration>.\\n\", exception.buildDiagnosticMessage() );",
        "ins1PreCode":"PluginParameterException exception = new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) );  assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\\n\" + \"\\n\" + \"[0] Inside the definition for plugin 'artifactId', specify the following:\\n\" + \"\\n\" + \"<configuration>\\n\" + \"  ...\\n\" + \"  <toAddresses>\\n\" + \"    <item>VALUE</item>\\n\" + \"  </toAddresses>\\n\" + \"</configuration>.\\n\", exception.buildDiagnosticMessage() );",
        "ins2PreCode":"PluginParameterException exception = new PluginParameterException( mojoDescriptor, Collections.singletonList( parameter ) ); assertEquals( \"One or more required plugin parameters are invalid/missing for 'goalPrefix:goal'\\n\" + \"\\n\" + \"[0] Inside the definition for plugin 'artifactId', specify the following:\\n\" + \"\\n\" + \"<configuration>\\n\" + \"  ...\\n\" + \"  <toAddresses>\\n\" + \"    <item>VALUE</item>\\n\" + \"  </toAddresses>\\n\" + \"</configuration>.\\n\", exception.buildDiagnosticMessage() );",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.SYNC | QueueFuseable.BOUNDARY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC | QueueFuseable.BOUNDARY);",
        "ins1PreCode":"public void syncFusedBoundary() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC | QueueFuseable.BOUNDARY);  Observable.range(1, 5)",
        "ins2PreCode":"public void syncFusedBoundaryConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC | QueueFuseable.BOUNDARY); Observable.range(1, 5)",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldHashCodeTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); user.hashCode(); assertEquals(3, user.setterCounter); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldEqualsTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); user.equals(null); assertEquals(3, user.setterCounter); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset<String> data1 = createDataset1(); XYDataset<String> data2 = createDataset2();",
        "ins1DelCode":"XYDataset data1 = createDataset1(); XYDataset data2 = createDataset2();",
        "ins1PreCode":"private CombinedRangeXYPlot createPlot() {  XYDataset data1 = createDataset1(); XYItemRenderer renderer1 = new StandardXYItemRenderer(); NumberAxis xAxis1 = new NumberAxis(\"X1\"); XYPlot subplot1 = new XYPlot(data1, xAxis1, null, renderer1); subplot1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT);  XYTextAnnotation annotation = new XYTextAnnotation(\"Hello!\", 50.0, 10000.0); annotation.setFont(new Font(\"SansSerif\", Font.PLAIN, 9)); annotation.setRotationAngle(Math.PI / 4.0); subplot1.addAnnotation(annotation);   XYDataset data2 = createDataset2(); XYItemRenderer renderer2 = new StandardXYItemRenderer(); NumberAxis xAxis2 = new NumberAxis(\"X2\");",
        "ins2PreCode":"private CombinedDomainXYPlot createPlot() { XYDataset data1 = createDataset1(); XYItemRenderer renderer1 = new StandardXYItemRenderer(); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); XYPlot subplot1 = new XYPlot(data1, null, rangeAxis1, renderer1); subplot1.setRangeAxisLocation(AxisLocation.BOTTOM_OR_LEFT); subplot1.addAnnotation(annotation); XYTextAnnotation annotation = new XYTextAnnotation(\"Hello!\", 50.0, annotation.setFont(new Font(\"SansSerif\", Font.PLAIN, 9)); annotation.setRotationAngle(Math.PI / 4.0); subplot1.addAnnotation(annotation); XYDataset data2 = createDataset2(); XYItemRenderer renderer2 = new StandardXYItemRenderer(); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\");",
        "label":1
    },
    {
        "ins1AddCode":"public void inMemoryH2IsShutdown() throws Exception { ConfigurableApplicationContext context = getContext(() -> createContext( \"org.h2.Driver\", \"jdbc:h2:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class));",
        "ins1DelCode":"public void inMemoryH2IsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class);",
        "ins1PreCode":"public void inMemoryH2IsShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "ins2PreCode":"public void hsqlServerIsNotShutdown() throws SQLException { ConfigurableApplicationContext context = createContext(\"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehavior( context.getBean(DataSource.class));",
        "label":1
    },
    {
        "ins1AddCode":"g2.setPaint(Color.GRAY);",
        "ins1DelCode":"g2.setPaint(Color.gray);",
        "ins1PreCode":" RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.gray); g2.fill(shadow); ",
        "ins2PreCode":"RectangularShape shadow = createShadow(bar, renderer.getShadowXOffset(), renderer.getShadowYOffset(), base, pegShadow); g2.setPaint(Color.gray); g2.fill(shadow);",
        "label":1
    },
    {
        "ins1AddCode":"lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "ins1DelCode":"MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "ins1PreCode":"super.setUp();  NumberFieldType fieldType = new NumberFieldType(\"field\", NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType);  SortedNumericDoubleValues doubleValues = mock(SortedNumericDoubleValues.class); when(doubleValues.advanceExact(anyInt())).thenReturn(true); when(doubleValues.nextValue()).thenReturn(2.718);  LeafNumericFieldData atomicFieldData = mock(LeafNumericFieldData.class); when(atomicFieldData.getDoubleValues()).thenReturn(doubleValues);  IndexNumericFieldData fieldData = mock(IndexNumericFieldData.class); when(fieldData.getFieldName()).thenReturn(\"field\"); when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "ins2PreCode":"super.setUp(); NumberFieldType fieldType = new NumberFieldType(\"field\", NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType); SortedNumericDoubleValues doubleValues = mock(SortedNumericDoubleValues.class); when(doubleValues.advanceExact(anyInt())).thenReturn(true); when(doubleValues.nextValue()).thenReturn(2.718); LeafNumericFieldData atomicFieldData = mock(LeafNumericFieldData.class); when(atomicFieldData.getDoubleValues()).thenReturn(doubleValues); IndexNumericFieldData fieldData = mock(IndexNumericFieldData.class); when(fieldData.getFieldName()).thenReturn(\"field\"); when(fieldData.load(anyObject())).thenReturn(atomicFieldData); service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fusedAsync() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  final int[] call = { 0, 0 };",
        "ins2PreCode":"public void fusedAsyncConditional() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY); final int[] call = { 0, 0 };",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"DirectoryScanner ds = new DirectoryScanner();",
        "ins1PreCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/**\", \"alpha/beta/gamma/**\"});",
        "ins2PreCode":"public void testAlternateExcludeInclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\"))); ds.setExcludes(new String[] {\"alpha/**\", \"alpha/beta/gamma/**\"});",
        "label":1
    },
    {
        "ins1AddCode":"new FetchShuffleBlocks(\"app-id\", \"exec-id\", 0, new long[] { 0 }, new int[][] {{ 0, 1, 2 }}),",
        "ins1DelCode":"new FetchShuffleBlocks(\"app-id\", \"exec-id\", 0, new int[] { 0 }, new int[][] {{ 0, 1, 2 }}),",
        "ins1PreCode":"BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new FetchShuffleBlocks(\"app-id\", \"exec-id\", 0, new int[] { 0 }, new int[][] {{ 0, 1, 2 }}), conf); ",
        "ins2PreCode":"BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new OpenBlocks(\"app-id\", \"exec-id\", blockIds), conf);",
        "label":0
    },
    {
        "ins1AddCode":"DefaultBoxAndWhiskerCategoryDataset<String, String> dataset = new DefaultBoxAndWhiskerCategoryDataset<>();",
        "ins1DelCode":"DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset();",
        "ins1PreCode":"public void testDrawWithNullMedian() { boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, null, 0.0, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\");",
        "ins2PreCode":"public void testDrawWithNullQ1() { boolean success; try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, null, 4.0, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\");",
        "label":1
    },
    {
        "ins1AddCode":"void loadDefaultYamlDocument() {",
        "ins1DelCode":"public void loadDefaultYamlDocument() {",
        "ins1PreCode":"public void loadDefaultYamlDocument() { this.environment.setDefaultProfiles(\"thedefault\"); this.initializer.setSearchNames(\"testprofilesdocument\");",
        "ins2PreCode":"public void loadDefaultYamlDocumentNotActivated() { this.environment.setDefaultProfiles(\"thedefault\"); this.initializer.setSearchNames(\"testprofilesdocument\");",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Flowable<Integer>> inner = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Flowable<Integer>> inner = new AtomicReference<Flowable<Integer>>();",
        "ins1PreCode":"public void windowAbandonmentCancelsUpstream() { PublishProcessor<Integer> pp = PublishProcessor.create();  final AtomicReference<Flowable<Integer>> inner = new AtomicReference<Flowable<Integer>>();  TestSubscriber<Flowable<Integer>> ts = pp.window(Flowable.<Integer>never())",
        "ins2PreCode":"public void windowAbandonmentCancelsUpstream() { PublishProcessor<Integer> pp = PublishProcessor.create(); final AtomicReference<Flowable<Integer>> inner = new AtomicReference<Flowable<Integer>>(); TestSubscriber<Flowable<Integer>> ts = pp.window(Flowable.<Integer>just(1).concatWith(Flowable.<Integer>never()),",
        "label":1
    },
    {
        "ins1AddCode":"public void shouldExtendedAdaptSystemEnvironmentPropertySource() {",
        "ins1DelCode":"public void shouldExtendedAdaptSystemEnvironmentPropertySource() throws Exception {",
        "ins1PreCode":"public void shouldExtendedAdaptSystemEnvironmentPropertySource() throws Exception { MutablePropertySources sources = new MutablePropertySources(); sources.addLast(new SystemEnvironmentPropertySource(",
        "ins2PreCode":"public void shouldNotAdaptSystemEnvironmentPropertyOverrideSource() throws Exception { MutablePropertySources sources = new MutablePropertySources(); sources.addLast(new SystemEnvironmentPropertySource(\"override\",",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":" LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsEmptyNumber() {",
        "ins1DelCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsEmptyNumber() throws Exception {",
        "ins1PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsEmptyNumber() throws Exception { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "ins2PreCode":"@Test public void dummyRangeRangeSingleShouldFailIfBuildRangeContainsHyphen() throws Exception { CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "label":1
    },
    {
        "ins1AddCode":"UnicastProcessor<Integer> up = UnicastProcessor.create(Observable.bufferSize(), new Runnable() { final Disposable subscribe = up.subscribe();",
        "ins1DelCode":"UnicastProcessor<Integer> us = UnicastProcessor.create(Observable.bufferSize(), new Runnable() { final Disposable subscribe = us.subscribe();",
        "ins1PreCode":"public void onTerminateCalledWhenCanceled() { final AtomicBoolean didRunOnTerminate = new AtomicBoolean();  UnicastProcessor<Integer> us = UnicastProcessor.create(Observable.bufferSize(), new Runnable() { @Override public void run() { didRunOnTerminate.set(true); } });  final Disposable subscribe = us.subscribe();  assertFalse(didRunOnTerminate.get());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(graph.edgeValueOrDefault(node, otherNode, null) != null).isEqualTo(hasEdge);",
        "ins1DelCode":"assertThat(graph.edgeValueOrNull(node, otherNode) != null).isEqualTo(hasEdge);",
        "ins1PreCode":"for (Integer otherNode : graph.nodes()) { boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrNull(node, otherNode) != null).isEqualTo(hasEdge); } }",
        "ins2PreCode":"for (Integer otherNode : graph.nodes()) { boolean hasEdge = graph.hasEdgeConnecting(node, otherNode); assertThat(hasEdge).isEqualTo(asGraph.hasEdgeConnecting(node, otherNode)); assertThat(graph.edgeValueOrNull(node, otherNode) != null).isEqualTo(hasEdge); } }",
        "label":1
    },
    {
        "ins1AddCode":"void setIgnoreBeanInfoPropertyByDefault(CapturedOutput output) {",
        "ins1DelCode":"void setIgnoreBeanInfoPropertyByDefault(CapturedOutput capturedOutput) {",
        "ins1PreCode":"void setIgnoreBeanInfoPropertyByDefault(CapturedOutput capturedOutput) { SpringApplication application = new SpringApplication(ExampleConfig.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "ins2PreCode":"void disableIgnoreBeanInfoProperty() { SpringApplication application = new SpringApplication(ExampleConfig.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "label":0
    },
    {
        "ins1AddCode":"assertThrows(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\", AssertionError.class, () -> { TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.just(1, 2).subscribe(ts); ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; } });",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); Flowable.just(1, 2).subscribe(ts); thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception { return o == 1; }",
        "ins1PreCode":" Flowable.just(1, 2).subscribe(ts);  thrown.expect(AssertionError.class); thrown.expectMessage(\"Invalid index: 2 (latch = 0, values = 2, errors = 0, completions = 1)\"); ts.assertValueAt(2, new Predicate<Integer>() { @Override public boolean test(final Integer o) throws Exception {",
        "ins2PreCode":"Flowable.just(1, 2).subscribe(ts); thrown.expect(AssertionError.class); thrown.expect(AssertionError.class); ts.assertNever(new Predicate<Integer>() { public boolean test(final Integer o) throws Exception {",
        "label":0
    },
    {
        "ins1AddCode":"this.restTemplateCustomizers, this.requestFactoryCustomizer,",
        "ins1DelCode":"this.restTemplateCustomizers, this.requestFactoryCustomizers,",
        "ins1PreCode":"return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, Collections.unmodifiableSet(new LinkedHashSet<>(interceptors)));",
        "ins2PreCode":"return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, append(this.interceptors, interceptors));",
        "label":1
    },
    {
        "ins1AddCode":"pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );",
        "ins1DelCode":"pluginManager.setupPluginRealm( pluginDescriptor, session, null, null );",
        "ins1PreCode":" pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest );  pluginManager.setupPluginRealm( pluginDescriptor, session, null, null ); } catch ( Exception e )",
        "ins2PreCode":"pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest ); pluginManager.setupPluginRealm( pluginDescriptor, session, null, null ); } catch ( Exception e )",
        "label":1
    },
    {
        "ins1AddCode":"public void customResourceLoaderIsUsedInNonWebApplication() {",
        "ins1DelCode":"public void customResourceLoaderIsUsedInNonWebApplication() throws Exception {",
        "ins1PreCode":"public void customResourceLoaderIsUsedInNonWebApplication() throws Exception { GenericApplicationContext context = new GenericApplicationContext(); ResourceLoader resourceLoader = mock(ResourceLoader.class);",
        "ins2PreCode":"public void customResourceLoaderIsUsedInWebApplication() throws Exception { GenericWebApplicationContext context = new GenericWebApplicationContext( ResourceLoader resourceLoader = mock(ResourceLoader.class);",
        "label":1
    },
    {
        "ins1AddCode":"final int[] primaryIdAndSecondaryIds = new int[2 * blockIds.length]; if (blockIdParts.length != 4 || (!requestForMergedBlockChunks && !blockIdParts[0].equals(SHUFFLE_BLOCK_ID)) || (requestForMergedBlockChunks && !blockIdParts[0].equals(SHUFFLE_CHUNK_ID))) { primaryIdAndSecondaryIds[2 * i] = Integer.parseInt(blockIdParts[2]); primaryIdAndSecondaryIds[2 * i + 1] = Integer.parseInt(blockIdParts[3]); return primaryIdAndSecondaryIds;",
        "ins1DelCode":"final int[] mapIdAndReduceIds = new int[2 * blockIds.length]; if (blockIdParts.length != 4 || !blockIdParts[0].equals(\"shuffle\")) { mapIdAndReduceIds[2 * i] = Integer.parseInt(blockIdParts[2]); mapIdAndReduceIds[2 * i + 1] = Integer.parseInt(blockIdParts[3]); return mapIdAndReduceIds;",
        "ins1PreCode":"private int[] shuffleMapIdAndReduceIds(String[] blockIds, int shuffleId) { final int[] mapIdAndReduceIds = new int[2 * blockIds.length]; for (int i = 0; i < blockIds.length; i++) { String[] blockIdParts = blockIds[i].split(\"_\"); if (blockIdParts.length != 4 || !blockIdParts[0].equals(\"shuffle\")) { throw new IllegalArgumentException(\"Unexpected shuffle block id format: \" + blockIds[i]); } if (Integer.parseInt(blockIdParts[1]) != shuffleId) { throw new IllegalArgumentException(\"Expected shuffleId=\" + shuffleId + \", got:\" + blockIds[i]); } mapIdAndReduceIds[2 * i] = Integer.parseInt(blockIdParts[2]); mapIdAndReduceIds[2 * i + 1] = Integer.parseInt(blockIdParts[3]); } return mapIdAndReduceIds;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final FullHttpResponse response = client.send(remoteAddress.address(), request); final FullHttpResponse continuationResponse = client.send(remoteAddress.address(), continuationRequest);",
        "ins1DelCode":"final FullHttpResponse response = client.post(remoteAddress.address(), request); final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest);",
        "ins1PreCode":"request.headers().set(HttpHeaderNames.EXPECT, expectation); HttpUtil.setContentLength(request, contentLength);  final FullHttpResponse response = client.post(remoteAddress.address(), request); try { assertThat(response.status(), equalTo(expectedStatus)); if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) { final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.EMPTY_BUFFER); final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest); try { assertThat(continuationResponse.status(), is(HttpResponseStatus.OK));",
        "ins2PreCode":"request.headers().set(HttpHeaderNames.EXPECT, expectation); HttpUtil.setContentLength(request, contentLength); final FullHttpResponse response = client.post(remoteAddress.address(), request); try { assertThat(response.status(), equalTo(expectedStatus)); if (expectedStatus.equals(HttpResponseStatus.CONTINUE)) { final FullHttpRequest continuationRequest = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.POST, \"/\", Unpooled.EMPTY_BUFFER); final FullHttpResponse continuationResponse = client.post(remoteAddress.address(), continuationRequest); try { assertThat(continuationResponse.status(), is(HttpResponseStatus.OK));",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerCompletableObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\"));",
        "ins1DelCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "ins1PreCode":"   tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");  ",
        "ins2PreCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"Single.zip(new CrashingMappedIterable<>(1, 100, 100, new Function<Integer, Single<Integer>>() {",
        "ins1DelCode":"Single.zip(new CrashingMappedIterable<Single<Integer>>(1, 100, 100, new Function<Integer, Single<Integer>>() {",
        "ins1PreCode":"public void iteratorThrows() { Single.zip(new CrashingMappedIterable<Single<Integer>>(1, 100, 100, new Function<Integer, Single<Integer>>() { @Override public Single<Integer> apply(Integer v) throws Exception {",
        "ins2PreCode":"public void hasNextThrows() { Single.zip(new CrashingMappedIterable<Single<Integer>>(100, 20, 100, new Function<Integer, Single<Integer>>() { @Override public Single<Integer> apply(Integer v) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"j.createSlave(\"ExistingAgent\", null, null); .invokeWithArgs(\"ExistingAgent\") assertThat(result.stderr(), containsString(\"ERROR: Node 'ExistingAgent' already exists\"));",
        "ins1DelCode":"j.createSlave(\"ExistingSlave\", null, null); .invokeWithArgs(\"ExistingSlave\") assertThat(result.stderr(), containsString(\"ERROR: Node 'ExistingSlave' already exists\"));",
        "ins1PreCode":"@Test public void createNodeShouldFailIfNodeAlreadyExistWhenNameSpecifiedExplicitly() throws Exception {  j.createSlave(\"ExistingSlave\", null, null);  final CLICommandInvoker.Result result = command .authorizedTo(Computer.CREATE, Jenkins.READ) .withStdin(Computer.class.getResourceAsStream(\"node.xml\")) .invokeWithArgs(\"ExistingSlave\") ;  assertThat(result.stderr(), containsString(\"ERROR: Node 'ExistingSlave' already exists\")); assertThat(result, hasNoStandardOutput()); assertThat(result, failedWith(4));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectRenameActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final OracleTableColumn column = command.getObject();",
        "ins2PreCode":"protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { protected void addObjectRenameActions(List<DBEPersistAction> actions, ObjectRenameCommand command, Map<String, Object> options) { final ExasolTableColumn column = command.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"void propertySourceAnnotationWithName() {",
        "ins1DelCode":"public void propertySourceAnnotationWithName() {",
        "ins1PreCode":"public void propertySourceAnnotationWithName() { SpringApplication application = new SpringApplication(WithPropertySourceAndName.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "ins2PreCode":"public void propertySourceAnnotationMultipleLocations() { SpringApplication application = new SpringApplication(WithPropertySourceMultipleLocations.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "label":1
    },
    {
        "ins1AddCode":"sub.onSubscribe(Disposable.empty());",
        "ins1DelCode":"sub.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Integer> sub) { sub.onSubscribe(Disposables.empty()); sub.onNext(1); sub.onNext(2);",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super Integer> sub) { sub.onSubscribe(new BooleanSubscription()); sub.onNext(1); sub.onNext(2);",
        "label":0
    },
    {
        "ins1AddCode":"}, false, 2);",
        "ins1DelCode":"}, 2, false);",
        "ins1PreCode":"public Observable<Integer> apply(Integer v) throws Throwable { return Observable.just(v).hide(); } }, 2, false); } });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYDataItem item = this.data.get(i);",
        "ins1DelCode":"XYDataItem item = (XYDataItem) this.data.get(i);",
        "ins1PreCode":"} else { for (int i = 0; i < this.data.size(); i++) { XYDataItem item = (XYDataItem) this.data.get(i); if (item.getX().equals(x)) { return i;",
        "ins2PreCode":"} else { for (int i = 0; i < this.data.size(); i++) { this.data.get(i); if (item.getComparable().equals(x)) { return i;",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(this.output.toString()).contains(\"testatdebug\"); assertThat(this.output.toString()).contains(\"testattrace\");",
        "ins1DelCode":"assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "ins1PreCode":"this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "ins2PreCode":"this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.debug(\"testatdebug\"); this.logger.trace(\"testattrace\"); assertThat(this.outputCapture.toString()).contains(\"testatdebug\"); assertThat(this.outputCapture.toString()).contains(\"testattrace\");",
        "label":1
    },
    {
        "ins1AddCode":"LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, xmpPreferences, filePreferences, externalFileType);",
        "ins1DelCode":"LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType);",
        "ins1PreCode":"any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete(); ",
        "ins2PreCode":"any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1AddCode":"public void shouldSelectOneAuthor() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1DelCode":"public void shouldSelectOneAuthor() throws Exception { SqlSession session = sqlMapper.openSession(); try { } finally { session.close();",
        "ins1PreCode":"public void shouldSelectOneAuthor() throws Exception { SqlSession session = sqlMapper.openSession(); try { Author author = session.selectOne( \"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAuthor\", new Author(101)); assertEquals(101, author.getId()); assertEquals(Section.NEWS, author.getFavouriteSection()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldSelectOneImmutableAuthor() throws Exception { SqlSession session = sqlMapper.openSession(); try { ImmutableAuthor author = session.selectOne( \"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectImmutableAuthor\", new Author(101)); assertEquals(101, author.getId()); assertEquals(Section.NEWS, author.getFavouriteSection()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 's'; char b = d;\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testdefTocharImplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; char b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; char b = d;\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaRDD<List<List<Integer>>> sequences = jsc.parallelize(Arrays.asList( model.save(spark.sparkContext(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(spark.sparkContext(), outputPath); for (PrefixSpan.FreqSequence<Integer> freqSeq : localFreqSeqs) {",
        "ins1DelCode":"JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( model.save(sc.sc(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(sc.sc(), outputPath); for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) {",
        "ins1PreCode":"public void runPrefixSpanSaveLoad() { JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences);  File tempDir = Utils.createTempDir( System.getProperty(\"java.io.tmpdir\"), \"JavaPrefixSpanSuite\"); String outputPath = tempDir.getPath();  try { model.save(sc.sc(), outputPath); PrefixSpanModel newModel = PrefixSpanModel.load(sc.sc(), outputPath); JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size());  for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence(); long freq = freqSeq.freq();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fused() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  TakeFirst source = new TakeFirst(to);",
        "ins2PreCode":"public void fusedReject() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.SYNC); TakeFirst source = new TakeFirst(to);",
        "label":1
    },
    {
        "ins1AddCode":"int uaoSize = UnsafeAlignedOffset.getUaoSize(); final int required = length + uaoSize; UnsafeAlignedOffset.putSize(base, pageCursor, length); pageCursor += uaoSize;",
        "ins1DelCode":"final int required = length + 4; Platform.putInt(base, pageCursor, length); pageCursor += 4;",
        "ins1PreCode":" growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required);  final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length;",
        "ins2PreCode":"growPointerArrayIfNecessary(); final int required = length + 4; acquireNewPageIfNecessary(required); final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length;",
        "label":1
    },
    {
        "ins1AddCode":"this.firstBarPaint = SerialUtils.readPaint(stream); this.lastBarPaint = SerialUtils.readPaint(stream); this.positiveBarPaint = SerialUtils.readPaint(stream); this.negativeBarPaint = SerialUtils.readPaint(stream);",
        "ins1DelCode":"this.firstBarPaint = SerialUtilities.readPaint(stream); this.lastBarPaint = SerialUtilities.readPaint(stream); this.positiveBarPaint = SerialUtilities.readPaint(stream); this.negativeBarPaint = SerialUtilities.readPaint(stream);",
        "ins1PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.firstBarPaint = SerialUtilities.readPaint(stream); this.lastBarPaint = SerialUtilities.readPaint(stream); this.positiveBarPaint = SerialUtilities.readPaint(stream); this.negativeBarPaint = SerialUtilities.readPaint(stream);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1DelCode":"assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST); Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins2PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST); Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1AddCode":"byte[] capturedArray = eis.capturedArray; assertTrue( \"copyFrom byteBuffer must not grant access to underlying array\",",
        "ins1DelCode":"byte[] capturedArray = null; capturedArray = eis.capturedArray; assertTrue(\"copyFrom byteBuffer must not grant access to underlying array\",",
        "ins1PreCode":"public void testReadFrom_mutating() throws IOException { byte[] capturedArray = null; EvilInputStream eis = new EvilInputStream(); ByteString byteString = ByteString.readFrom(eis);  capturedArray = eis.capturedArray; byte[] originalValue = byteString.toByteArray(); for (int x = 0; x < capturedArray.length; ++x) { capturedArray[x] = (byte) 0; }  byte[] newValue = byteString.toByteArray(); assertTrue(\"copyFrom byteBuffer must not grant access to underlying array\", Arrays.equals(originalValue, newValue));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"FieldFormatterCleanup cleanup = new FieldFormatterCleanup(InternalField.KEY_FIELD, new UnicodeToLatexFormatter()); entry.setField(InternalField.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); assertEquals(\"Fran{\\\\c{c}}ois-Marie Arouet\", entry.getField(InternalField.KEY_FIELD).get());",
        "ins1DelCode":"FieldFormatterCleanup cleanup = new FieldFormatterCleanup(BibEntry.KEY_FIELD, new UnicodeToLatexFormatter()); entry.setField(BibEntry.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); assertEquals(\"Fran{\\\\c{c}}ois-Marie Arouet\", entry.getField(BibEntry.KEY_FIELD).get());",
        "ins1PreCode":"public void testCleanupKeyFieldCleansUpKeyField() throws Exception { FieldFormatterCleanup cleanup = new FieldFormatterCleanup(BibEntry.KEY_FIELD, new UnicodeToLatexFormatter()); entry.setField(BibEntry.KEY_FIELD, \"Fran\u00e7ois-Marie Arouet\"); cleanup.cleanup(entry);  assertEquals(\"Fran{\\\\c{c}}ois-Marie Arouet\", entry.getField(BibEntry.KEY_FIELD).get());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public static long produced(@NonNull AtomicLong requested, long n) {",
        "ins1DelCode":"public static long produced(AtomicLong requested, long n) {",
        "ins1PreCode":"public static long produced(AtomicLong requested, long n) { for (;;) { long current = requested.get();",
        "ins2PreCode":"public static long producedCancel(AtomicLong requested, long n) { for (;;) { long current = requested.get();",
        "label":1
    },
    {
        "ins1AddCode":"final UnsafeRow row = new UnsafeRow(numFields); row.pointTo(baseObject, baseOffset + offset, size);",
        "ins1DelCode":"final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size);",
        "ins1PreCode":"final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size); return row;",
        "ins2PreCode":"final long offsetAndSize = getLong(ordinal); return null; final int size = (int) offsetAndSize; final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size); return row;",
        "label":1
    },
    {
        "ins1AddCode":"set.add(new Medra());",
        "ins1DelCode":"",
        "ins1PreCode":"set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); return set;",
        "ins2PreCode":"set.add(new DoiFetcher(importFormatPreferences)); set.add(new IsbnFetcher(importFormatPreferences)); set.add(new DoiFetcher(importFormatPreferences)); return set;",
        "label":0
    },
    {
        "ins1AddCode":"enterRule(_localctx, 62, RULE_listinitializer); setState(493); switch ( getInterpreter().adaptivePredict(_input,48,_ctx) ) { setState(480); setState(481); setState(486); setState(482); setState(483); setState(488); setState(489); setState(491); setState(492);",
        "ins1DelCode":"enterRule(_localctx, 52, RULE_listinitializer); setState(432); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { setState(419); setState(420); setState(425); setState(421); setState(422); setState(427); setState(428); setState(430); setState(431);",
        "ins1PreCode":"public final ListinitializerContext listinitializer() throws RecognitionException { ListinitializerContext _localctx = new ListinitializerContext(_ctx, getState()); enterRule(_localctx, 52, RULE_listinitializer); int _la; try { setState(432); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(419); match(LBRACE); setState(420); expression(); setState(425); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(421); match(COMMA); setState(422); expression(); } } setState(427); _errHandler.sync(this); _la = _input.LA(1); } setState(428); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(430); match(LBRACE); setState(431); match(RBRACE); }",
        "ins2PreCode":"public final MapinitializerContext mapinitializer() throws RecognitionException { MapinitializerContext _localctx = new MapinitializerContext(_ctx, getState()); enterRule(_localctx, 54, RULE_mapinitializer); int _la; try { setState(434); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,42,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(448); match(LBRACE); setState(440); exitRule(); setState(435); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(442); match(COMMA); setState(442); exitRule(); } } setState(437); _errHandler.sync(this); _la = _input.LA(1); } setState(448); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(434); match(LBRACE); setState(434); match(RBRACE); }",
        "label":0
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(marker, \"marker\"); ParamChecks.nullNotPermitted(layer, \"layer\");",
        "ins1PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { ParamChecks.nullNotPermitted(marker, \"marker\"); ParamChecks.nullNotPermitted(layer, \"layer\"); List markers; if (layer == Layer.FOREGROUND) {",
        "ins2PreCode":"public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { boolean removed = markers.remove(marker); if (layer == Layer.FOREGROUND) { ArrayList markers; if (layer == Layer.FOREGROUND) {",
        "label":0
    },
    {
        "ins1AddCode":"verifyOpenBlockLatencyMetrics(2, 2);",
        "ins1DelCode":"verifyOpenBlockLatencyMetrics();",
        "ins1PreCode":" verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 0); verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 1); verifyOpenBlockLatencyMetrics();",
        "ins2PreCode":"verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 0); verify(blockResolver, times(1)).getBlockData(\"app0\", \"exec1\", 0, 0, 1); verifyOpenBlockLatencyMetrics();",
        "label":1
    },
    {
        "ins1AddCode":"for (Entry<ByteEntry, int[]> item : bcStats.entrySet()) { ByteEntry entry = item.getKey(); int[] countA = item.getValue();",
        "ins1DelCode":"Iterator<ByteEntry> entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = entries.next(); int[] countA = bcStats.get(entry);",
        "ins1PreCode":" TreeMap<Integer,ArrayList<ByteEntry>> tempMap = new TreeMap<Integer,ArrayList<ByteEntry>>(); Iterator<ByteEntry> entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = entries.next(); int[] countA = bcStats.get(entry); Integer count = new Integer(countA[0]); ",
        "ins2PreCode":"TreeMap<Integer,ArrayList<CharEntry>> tempMap = new TreeMap<Integer,ArrayList<CharEntry>>(); Iterator<CharEntry> entries = ccStats.keySet().iterator(); Iterator<CharEntry> entries = ccStats.keySet().iterator(); while (entries.hasNext()) { CharEntry entry = entries.next(); int[] countA = ccStats.get(entry); Integer count = new Integer(countA[0]);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":".sequential() ;  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  result.subscribe(ts);",
        "ins2PreCode":".sequential() ; TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); result.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"Single.zip(new CrashingMappedIterable<>(100, 20, 100, new Function<Integer, Single<Integer>>() {",
        "ins1DelCode":"Single.zip(new CrashingMappedIterable<Single<Integer>>(100, 20, 100, new Function<Integer, Single<Integer>>() {",
        "ins1PreCode":"public void hasNextThrows() { Single.zip(new CrashingMappedIterable<Single<Integer>>(100, 20, 100, new Function<Integer, Single<Integer>>() { @Override public Single<Integer> apply(Integer v) throws Exception {",
        "ins2PreCode":"public void nextThrows() { Single.zip(new CrashingMappedIterable<Single<Integer>>(100, 100, 5, new Function<Integer, Single<Integer>>() { @Override public Single<Integer> apply(Integer v) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1AddCode":"ArrayList<String> results = new ArrayList<>();",
        "ins1DelCode":"ArrayList<String> results = new ArrayList<String>();",
        "ins1PreCode":"public String[] getRoles() {  User user = (User) this.resource; ArrayList<String> results = new ArrayList<String>(); Iterator<Role> roles = user.getRoles(); while (roles.hasNext()) {",
        "ins2PreCode":"public String[] getRoles() { Group group = (Group) this.resource; ArrayList<String> results = new ArrayList<String>(); Iterator<Role> roles = group.getRoles(); while (roles.hasNext()) {",
        "label":1
    },
    {
        "ins1AddCode":"HttpURLConnection conn = getConnection(\"http://localhost:\" + getPort() + \"/\");",
        "ins1DelCode":"HttpURLConnection conn = getConnection();",
        "ins1PreCode":"root.addServletMapping(\"/\", \"Bug37794\"); tomcat.start();  HttpURLConnection conn = getConnection(); InputStream is = conn.getInputStream(); assertNotNull(is);",
        "ins2PreCode":"root.addServletMapping(\"/\", \"Bug37794\"); tomcat.start(); HttpURLConnection conn = getConnection(); InputStream is = conn.getInputStream(); assertNotNull(is);",
        "label":1
    },
    {
        "ins1AddCode":"int updates = session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); assertEquals(1, updates);",
        "ins1DelCode":"session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);",
        "ins1PreCode":"try { original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "ins2PreCode":"try { original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail());",
        "label":1
    },
    {
        "ins1AddCode":"TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); Arrays.asList(customizers[0], customizers[1])); factory.addProtocolHandlerCustomizers(customizers[2], customizers[3]); InOrder ordered = inOrder((Object[]) customizers); for (TomcatProtocolHandlerCustomizer customizer : customizers) { ordered.verify(customizer).customize(any(ProtocolHandler.class));",
        "ins1DelCode":"TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] listeners = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); Arrays.asList(listeners[0], listeners[1])); factory.addProtocolHandlerCustomizers(listeners[2], listeners[3]); InOrder ordered = inOrder((Object[]) listeners); for (TomcatProtocolHandlerCustomizer listener : listeners) { ordered.verify(listener).customize(any(ProtocolHandler.class));",
        "ins1PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatServletWebServerFactory factory = getFactory(); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] listeners = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(listeners, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); factory.setTomcatProtocolHandlerCustomizers( Arrays.asList(listeners[0], listeners[1])); factory.addProtocolHandlerCustomizers(listeners[2], listeners[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) listeners); for (TomcatProtocolHandlerCustomizer listener : listeners) { ordered.verify(listener).customize(any(ProtocolHandler.class)); }",
        "ins2PreCode":"public void builderCustomizers() { UndertowServletWebServerFactory factory = getFactory(); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class)); public void builderCustomizers() { factory.setBuilderCustomizers(Arrays.asList(customizers[0], customizers[1])); factory.addBuilderCustomizers(customizers[2], customizers[3]); this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) customizers); for (UndertowBuilderCustomizer customizer : customizers) { ordered.verify(customizer).customize(any(Builder.class)); }",
        "label":0
    },
    {
        "ins1AddCode":"}).satisfies((ex) -> handleExceptionCausedByBlockedPortOnPrimaryConnector(ex, port));",
        "ins1DelCode":"}).satisfies((ex) -> handleExceptionCausedByBlockedPort(ex, port));",
        "ins1PreCode":"factory.setPort(port); AbstractServletWebServerFactoryTests.this.webServer = factory.getWebServer(); AbstractServletWebServerFactoryTests.this.webServer.start(); }).satisfies((ex) -> handleExceptionCausedByBlockedPort(ex, port)); });",
        "ins2PreCode":"doWithBlockedPort((port) -> { AbstractServletWebServerFactoryTests.this.webServer = factory.getWebServer(); AbstractServletWebServerFactoryTests.this.webServer.start(); }).satisfies((ex) -> handleExceptionCausedByBlockedPort(ex, port)); });",
        "label":1
    },
    {
        "ins1AddCode":"public synchronized DBSObject refreshObject(@NotNull DBRProgressMonitor monitor) return this;",
        "ins1DelCode":"public synchronized boolean refreshObject(@NotNull DBRProgressMonitor monitor) return true;",
        "ins1PreCode":"public synchronized boolean refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { tableCache.clearCache(); foreignKeyCache.clearCache(); constraintCache.clearCache(); indexCache.clearCache(); packageCache.clearCache(); proceduresCache.clearCache(); triggerCache.clearCache(); dataTypeCache.clearCache(); sequenceCache.clearCache(); synonymCache.clearCache(); javaCache.clearCache(); recycleBin.clearCache(); return true;",
        "ins2PreCode":"public boolean refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { public boolean refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { public boolean refreshObject(@NotNull DBRProgressMonitor monitor) throws DBException { tablespaceCache.clearCache(); encodingCache.clearCache(); encodingCache.clearCache(); dataTypeCache.clearCache(); languageCache.clearCache(); schemaCache.clearCache(); languageCache.clearCache(); dataTypeCache.clearCache(); encodingCache.clearCache(); encodingCache.clearCache(); dataTypeCache.clearCache(); encodingCache.clearCache(); return true;",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void merge1000SyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(1000, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge10000SyncStreamOf10() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNSyncStreamsOfN(10000, 10).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"void testAbbreviationsWithSemicolons() { Abbreviation abbreviation = new Abbreviation(\"Long Name\", \"L. N.;LN;M\");",
        "ins1DelCode":"public void testAbbreviationsWithSemicolons() { Abbreviation abbreviation = new Abbreviation(\" Long Name \", \" L. N.;LN;M\");",
        "ins1PreCode":"public void testAbbreviationsWithSemicolons() { Abbreviation abbreviation = new Abbreviation(\" Long Name \", \" L. N.;LN;M\");  assertEquals(\"Long Name\", abbreviation.getName());",
        "ins2PreCode":"public void testAbbreviationsWithSemicolonsWithShortestUniqueAbbreviation() { Abbreviation abbreviation = new Abbreviation(\" Long Name \", \" L. N.;LN;M\", \"LNLNM\"); assertEquals(\"Long Name\", abbreviation.getName());",
        "label":1
    },
    {
        "ins1AddCode":"cs = Objects.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\");",
        "ins1DelCode":"cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\");",
        "ins1PreCode":"CompletableSource cs;  try { cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"CompletableSource cs; try { cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts(), \"Check artifact list\" ); assertEquals( \"3.8.1\", getArtifact( \"junit\", res.getArtifacts() ).getVersion(), \"Check version\" ); assertEquals( Artifact.SCOPE_TEST, getArtifact( \"junit\", res.getArtifacts() ).getScope(), \"Check artifactScope\" );",
        "ins1DelCode":"assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() ); assertEquals( \"Check version\", \"3.8.1\", getArtifact( \"junit\", res.getArtifacts() ).getVersion() ); assertEquals( \"Check artifactScope\", Artifact.SCOPE_TEST, getArtifact( \"junit\", res.getArtifacts() ).getScope() );",
        "ins1PreCode":"ArtifactSpec b = createArtifactSpec( \"junit\", \"3.8.1\", Artifact.SCOPE_TEST );  ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() ); assertEquals( \"Check version\", \"3.8.1\", getArtifact( \"junit\", res.getArtifacts() ).getVersion() ); assertEquals( \"Check artifactScope\", Artifact.SCOPE_TEST, getArtifact( \"junit\", res.getArtifacts() ).getScope() );",
        "ins2PreCode":"ArtifactSpec b = createArtifactSpec( \"junit\", \"3.8.1\", Artifact.SCOPE_TEST ); ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() ); assertEquals( \"Check version\", \"3.8.1\", getArtifact( \"junit\", res.getArtifacts() ).getVersion() ); assertEquals( \"Check artifactScope\", Artifact.SCOPE_TEST, getArtifact( \"junit\", res.getArtifacts() ).getScope() );",
        "label":1
    },
    {
        "ins1AddCode":"TestEmptyMessage.newBuilder() .setUnknownFields( UnknownFieldSet.newBuilder() .addField(2, UnknownFieldSet.Field.newBuilder().addVarint(2).build()) .addField(3, UnknownFieldSet.Field.newBuilder().addVarint(4).build()) .build()) .build(); TestEmptyMessage.newBuilder() .setUnknownFields( UnknownFieldSet.newBuilder() .addField(1, UnknownFieldSet.Field.newBuilder().addVarint(1).build()) .addField(3, UnknownFieldSet.Field.newBuilder().addVarint(3).build()) .build()) .mergeFrom(source) .build(); assertEquals(\"1: 1\\n2: 2\\n3: 3\\n3: 4\\n\", destination.toString());",
        "ins1DelCode":"TestEmptyMessage.newBuilder() .setUnknownFields( UnknownFieldSet.newBuilder() .addField(2, UnknownFieldSet.Field.newBuilder() .addVarint(2).build()) .addField(3, UnknownFieldSet.Field.newBuilder() .addVarint(4).build()) .build()) .build(); TestEmptyMessage.newBuilder() .setUnknownFields( UnknownFieldSet.newBuilder() .addField(1, UnknownFieldSet.Field.newBuilder() .addVarint(1).build()) .addField(3, UnknownFieldSet.Field.newBuilder() .addVarint(3).build()) .build()) .mergeFrom(source) .build(); assertEquals( \"1: 1\\n\" + \"2: 2\\n\" + \"3: 3\\n\" + \"3: 4\\n\", destination.toString());",
        "ins1PreCode":"TestEmptyMessage.newBuilder() .setUnknownFields( UnknownFieldSet.newBuilder() .addField(2, UnknownFieldSet.Field.newBuilder() .addVarint(2).build()) .addField(3, UnknownFieldSet.Field.newBuilder() .addVarint(4).build()) .build()) .build(); TestEmptyMessage destination = TestEmptyMessage.newBuilder() .setUnknownFields( UnknownFieldSet.newBuilder() .addField(1, UnknownFieldSet.Field.newBuilder() .addVarint(1).build()) .addField(3, UnknownFieldSet.Field.newBuilder() .addVarint(3).build()) .build()) .mergeFrom(source) .build();  assertEquals( \"1: 1\\n\" + \"2: 2\\n\" + \"3: 3\\n\" + \"3: 4\\n\", destination.toString());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"MetaObject meta = SystemMetaObject.forObject(rich);",
        "ins1DelCode":"MetaObject meta = MetaObject.forObject(rich);",
        "ins1PreCode":"public void shouldGetReadablePropertyNames() { RichType rich = new RichType(); MetaObject meta = MetaObject.forObject(rich); String[] readables = meta.getGetterNames(); assertEquals(5, readables.length);",
        "ins2PreCode":"public void shouldGetWriteablePropertyNames() { RichType rich = new RichType(); MetaObject meta = MetaObject.forObject(rich); String[] writeables = meta.getSetterNames(); assertEquals(5, writeables.length);",
        "label":1
    },
    {
        "ins1AddCode":"void azureDefaultLoggingConfigDoesNotCauseAFailure() { assertThat(this.output).contains(\"Hello world\").doesNotContain(\"???\"); assertThat(new File(this.tempDir.toFile(), \"/spring.log\").exists()).isFalse();",
        "ins1DelCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() { String output = this.output.toString().trim(); assertThat(output).contains(\"Hello world\").doesNotContain(\"???\"); assertThat(new File(tmpDir() + \"/spring.log\").exists()).isFalse();",
        "ins1PreCode":"public void azureDefaultLoggingConfigDoesNotCauseAFailure() { addPropertiesToEnvironment(this.context, \"logging.config=-Djava.util.logging.config.file=\\\"d:\\\\home\\\\site\\\\wwwroot\\\\bin\\\\apache-tomcat-7.0.52\\\\conf\\\\logging.properties\\\"\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.info(\"Hello world\"); String output = this.output.toString().trim(); assertThat(output).contains(\"Hello world\").doesNotContain(\"???\"); assertThat(new File(tmpDir() + \"/spring.log\").exists()).isFalse();",
        "ins2PreCode":"public void tomcatNopLoggingConfigDoesNotCauseAFailure() { addPropertiesToEnvironment(this.context, \"LOGGING_CONFIG=-Dnop\"); public void tomcatNopLoggingConfigDoesNotCauseAFailure() { this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); this.logger.info(\"Hello world\"); String output = this.output.toString().trim(); assertThat(output).contains(\"Hello world\").doesNotContain(\"???\"); assertThat(new File(tmpDir() + \"/spring.log\").exists()).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"Object key = getRepositoryKey().apply( element ); Object key = getRepositoryKey().apply( element );",
        "ins1DelCode":"Object key = getRepositoryKey( element ); Object key = getRepositoryKey( element );",
        "ins1PreCode":" for ( Repository element : dominant ) { Object key = getRepositoryKey( element ); merged.put( key, element ); }  for ( Repository element : recessive ) { Object key = getRepositoryKey( element ); if ( !merged.containsKey( key ) ) {",
        "ins2PreCode":"for ( Repository element : dominant ) { Object key = getRepositoryKey( element ); merged.put( key, element ); } for ( Repository element : recessive ) { Object key = getRepositoryKey( element ); if ( !merged.containsKey( key ) ) {",
        "label":1
    },
    {
        "ins1AddCode":"for (Parameter param : params) { if (LINES_KEY.equals(param.getName())) { lines = Long.parseLong(param.getValue()); if (SKIP_KEY.equals(param.getName())) { skip = Long.parseLong(param.getValue());",
        "ins1DelCode":"for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { lines = Long.parseLong(params[i].getValue()); if (SKIP_KEY.equals(params[i].getName())) { skip = Long.parseLong(params[i].getValue());",
        "ins1PreCode":"private void initialize() { Parameter[] params = getParameters(); if (params != null) { for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { lines = Long.parseLong(params[i].getValue()); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = Long.parseLong(params[i].getValue()); continue; }",
        "ins2PreCode":"private void initialize() { Parameter[] params = getParameters(); if (params != null) { for (int i = 0; i < params.length; i++) { if (LINES_KEY.equals(params[i].getName())) { skip = Long.parseLong(params[i].getValue()); continue; } if (SKIP_KEY.equals(params[i].getName())) { skip = Long.parseLong(params[i].getValue()); continue; }",
        "label":1
    },
    {
        "ins1AddCode":"Path tempDir = Files.createTempDirectory(\"jabref-journal\"); Path tempJournalList = tempDir.resolve(\"journalList.mv\"); tempDir.toFile().deleteOnExit(); tempJournalList.toFile().deleteOnExit();",
        "ins1DelCode":"Path tempJournalList = Files.createTempDirectory(\"journal\").resolve(\"journalList.mv\");",
        "ins1PreCode":"JournalAbbreviationRepository repository;  try { Path tempJournalList = Files.createTempDirectory(\"journal\").resolve(\"journalList.mv\"); Files.copy(JournalAbbreviationRepository.class.getResourceAsStream(\"/journals/journalList.mv\"), tempJournalList); repository = new JournalAbbreviationRepository(tempJournalList);",
        "ins2PreCode":"JournalAbbreviationRepository repository; try { Path tempJournalList = Files.createTempDirectory(\"journal\").resolve(\"journalList.mv\"); Files.copy(JournalAbbreviationRepository.class.getResourceAsStream(\"/journals/journalList.mv\"), tempJournalList); repository = new JournalAbbreviationRepository(tempJournalList);",
        "label":1
    },
    {
        "ins1AddCode":"log.error(sm.getString(\"standardServer.storeConfig.contextError\", context.getName()), t);",
        "ins1DelCode":"log.error(t);",
        "ins1PreCode":"} } catch (Throwable t) { ExceptionUtils.handleThrowable(t); log.error(t); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertFalse(\"^starttest in default mode\", reg.matches(text)); assertFalse(\"^starttest in single line mode\", reg.matches(text, RegexpMatcher.MATCH_SINGLELINE));",
        "ins1DelCode":"assertTrue(\"^starttest in default mode\", !reg.matches(text)); assertTrue(\"^starttest in single line mode\", !reg.matches(text, RegexpMatcher.MATCH_SINGLELINE));",
        "ins1PreCode":"protected void doStartTest1(String text) { reg.setPattern(\"^starttest\"); assertTrue(\"^starttest in default mode\", !reg.matches(text)); assertTrue(\"^starttest in single line mode\", !reg.matches(text, RegexpMatcher.MATCH_SINGLELINE)); assertTrue(\"^starttest in multi line mode\", reg.matches(text, RegexpMatcher.MATCH_MULTILINE));",
        "ins2PreCode":"protected void doEndTest1(String text) { reg.setPattern(\"endtest$\"); assertTrue(\"endtest$ in default mode\", !reg.matches(text)); assertTrue(\"endtest$ in single line mode\", !reg.matches(text, RegexpMatcher.MATCH_SINGLELINE)); assertTrue(\"endtest$ in multi line mode\", reg.matches(text, RegexpMatcher.MATCH_MULTILINE));",
        "label":1
    },
    {
        "ins1AddCode":"void testNoAstRegexCaseSensitive() { TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins1DelCode":"public void testNoAstRegexCaseSensitive() { assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins1PreCode":"public void testNoAstRegexCaseSensitive() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the regular expression \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();  assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "ins2PreCode":"public void testNoAstCaseSensitive() { String query = \"a b\"; List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which any field contains the term \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \"), TooltipTextUtil.createText(\"\\n\\nHint: To search specific fields only, enter for example:\\n\"), TooltipTextUtil.createText(\"author=smith and title=electrical\", TooltipTextUtil.TextType.MONOSPACED)); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, false, query).getDescription(); assertTrue(TextFlowEqualityHelper.checkIfDescriptionEqualsExpectedTexts(description, expectedTexts));",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void merge100AsyncStreamOf1() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(100, 1).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1SyncStreamOf1() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(1, 1).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"for (ValueTick tick : ticks) { boolean paintLine = false;",
        "ins1DelCode":"Iterator iterator = ticks.iterator(); boolean paintLine; while (iterator.hasNext()) { paintLine = false; ValueTick tick = (ValueTick) iterator.next();",
        "ins1PreCode":"if (isDomainGridlinesVisible() || isDomainMinorGridlinesVisible()) { Stroke gridStroke = null; Paint gridPaint = null; Iterator iterator = ticks.iterator(); boolean paintLine; while (iterator.hasNext()) { paintLine = false; ValueTick tick = (ValueTick) iterator.next(); if ((tick.getTickType() == TickType.MINOR) && isDomainMinorGridlinesVisible()) {",
        "ins2PreCode":"if (isRangeGridlinesVisible() || isRangeMinorGridlinesVisible()) { Stroke gridStroke = null; Paint gridPaint = null; Iterator iterator = ticks.iterator(); boolean paintLine; while (iterator.hasNext()) { paintLine = false; ValueTick tick = (ValueTick) iterator.next(); if ((tick.getTickType() == TickType.MINOR) && isRangeMinorGridlinesVisible()) {",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>();",
        "ins1DelCode":"XYPlot plot = new XYPlot();",
        "ins1PreCode":"public void testListenersWithXYPlot() { XYPlot plot = new XYPlot(); ValueMarker marker1 = new ValueMarker(1.0); ValueMarker marker2 = new ValueMarker(2.0);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins1PreCode":"); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"disposable.set(Disposable.fromSubscription(ts));",
        "ins1DelCode":"disposable.set(Disposables.fromSubscription(ts));",
        "ins1PreCode":"to.assertEmpty(); } else if (result instanceof Publisher) { TestSubscriberEx<Object> ts = new TestSubscriberEx<>(); disposable.set(Disposables.fromSubscription(ts));  ((Publisher<?>)result)",
        "ins2PreCode":"to.assertEmpty(); } else if (result instanceof Publisher) { TestSubscriberEx<Object> ts = new TestSubscriberEx<>(); disposable.set(Disposables.fromSubscription(ts)); ((Publisher<?>)result)",
        "label":1
    },
    {
        "ins1AddCode":"DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.commit(); } catch (DBCException e) { throw new InvocationTargetException(e); }",
        "ins1DelCode":"final DBPDataSource dataSource = dataSourceContainer.getDataSource(); DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit '\" + dataSourceContainer.getName() + \"' transaction\"); try { session.getTransactionManager().commit(); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close();",
        "ins1PreCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { final DBPDataSource dataSource = dataSourceContainer.getDataSource(); try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit '\" + dataSourceContainer.getName() + \"' transaction\"); try { session.getTransactionManager().commit(); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } }",
        "ins2PreCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { final DBPDataSource dataSource = dataSourceContainer.getDataSource(); try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback '\" + dataSourceContainer.getName() + \"' transaction\"); try { session.getTransactionManager().rollback(null); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } }",
        "label":1
    },
    {
        "ins1AddCode":"label_14: break label_14;",
        "ins1DelCode":"label_15: break label_15;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_15; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_16; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void tryTerminateConsumerObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void tryTerminateConsumerMaybeObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1DelCode":"HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1PreCode":"rand.nextBytes(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));  hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); } ",
        "ins2PreCode":"rand.nextBytes(bytes); Assert.assertEquals( hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), hasher.hashUnsafeWords(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(hasher.hashUnsafeWords( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); }",
        "label":1
    },
    {
        "ins1AddCode":"BiConsumer<A, ? super T> accumulator;",
        "ins1DelCode":"BiConsumer<A, T> accumulator;",
        "ins1PreCode":"protected void subscribeActual(@NonNull Observer<? super R> observer) { A container; BiConsumer<A, T> accumulator; Function<A, R> finisher; ",
        "ins2PreCode":"protected void subscribeActual(@NonNull SingleObserver<? super R> observer) { A container; BiConsumer<A, T> accumulator; Function<A, R> finisher;",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void blockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>();  Flowable.range(1, 5)",
        "ins2PreCode":"public void boundedBlockingSubscribeConsumerConsumer() { final List<Object> list = new ArrayList<Object>(); Flowable.range(1, 5)",
        "label":1
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa8_1(active0, 0x100000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L);",
        "ins1PreCode":"switch(curChar) { case 101: return jjMoveStringLiteralDfa8_1(active0, 0x80000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 111: return jjMoveStringLiteralDfa9_1(active0, 0x80000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testGetPerson() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class);  List<Person> persons = mapper.getPersons();  Person person = persons.get(0); Assert.assertEquals(\"grandma\", person.getName()); Assert.assertTrue(person.owns(\"book\")); Assert.assertTrue(person.owns(\"tv\")); Assert.assertEquals(2, person.getItems().size());  person = persons.get(1); Assert.assertEquals(\"sister\", person.getName()); Assert.assertTrue(person.owns(\"phone\")); Assert.assertTrue(person.owns(\"shoes\")); Assert.assertEquals(2, person.getItems().size());  person = persons.get(2); Assert.assertEquals(\"brother\", person.getName()); Assert.assertTrue(person.owns(\"car\")); Assert.assertEquals(1, person.getItems().size()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testGetPersonOrderedByItem() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); List<Person> persons = mapper.getPersonsWithItemsOrdered(); Person person = persons.get(0); Assert.assertEquals(\"grandma\", person.getName()); Assert.assertTrue(person.owns(\"book\")); Assert.assertTrue(person.owns(\"tv\")); Assert.assertEquals(2, person.getItems().size()); person = persons.get(1); Assert.assertEquals(\"sister\", person.getName()); Assert.assertTrue(person.owns(\"phone\")); Assert.assertTrue(person.owns(\"shoes\")); Assert.assertEquals(2, person.getItems().size()); person = persons.get(2); Assert.assertEquals(\"brother\", person.getName()); Assert.assertTrue(person.owns(\"car\")); Assert.assertEquals(1, person.getItems().size()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"errors.tryAddThrowableOrReport(ex);",
        "ins1DelCode":"errors.addThrowable(ex);",
        "ins1PreCode":"Exceptions.throwIfFatal(ex); upstream.cancel(); queue.clear(); errors.addThrowable(ex); errors.tryTerminateConsumer(downstream); return;",
        "ins2PreCode":"Exceptions.throwIfFatal(ex); upstream.cancel(); queue.clear(); errors.addThrowable(ex); errors.tryTerminateConsumer(downstream); return;",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(String.format(\"<root>%n  <textElement>content</textElement>%n</root>%n\"), \"  <textElement>content</textElement>\" StringUtils.LINE_SEP \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "ins1DelCode":"assertEquals(\"<root>\" + StringUtils.LINE_SEP + \"  <textElement>content</textElement>\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "ins1PreCode":"StringWriter sw = new StringWriter(); DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(\"<root>\" + StringUtils.LINE_SEP + \"  <textElement>content</textElement>\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "ins2PreCode":"StringWriter sw = new StringWriter(); DOMElementWriter w = new DOMElementWriter(); w.write(root, sw, 0, \"  \"); assertEquals(\"<root>\" + StringUtils.LINE_SEP + \"  <cdataElement><![CDATA[content]]></cdataElement>\" + StringUtils.LINE_SEP + \"</root>\" + StringUtils.LINE_SEP, sw.toString());",
        "label":1
    },
    {
        "ins1AddCode":"realRowCount = countData(new AbstractExecutionSource(this, session.getExecutionContext(), this), session, null, DBSDataContainer.FLAG_NONE);",
        "ins1DelCode":"realRowCount = countData(new AbstractExecutionSource(this, session.getExecutionContext(), this), session, null);",
        "ins1PreCode":"  try (DBCSession session = DBUtils.openMetaSession(monitor, this, \"Read row count\")) { realRowCount = countData(new AbstractExecutionSource(this, session.getExecutionContext(), this), session, null); } catch (DBException e) { log.debug(\"Can't fetch row count\", e);",
        "ins2PreCode":"try (DBCSession session = DBUtils.openMetaSession(monitor, this, \"Read row count\")) { rowCount = countData(new AbstractExecutionSource(this, session.getExecutionContext(), this), session, null); } catch (DBException e) { log.debug(\"Can't fetch row count\", e);",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset dataset = new XYSeriesCollection<String>();",
        "ins1DelCode":"XYDataset dataset = new XYSeriesCollection();",
        "ins1PreCode":"public void testGetDomainAxisForDataset() { XYDataset dataset = new XYSeriesCollection(); NumberAxis xAxis = new NumberAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\");",
        "ins2PreCode":"public void testGetRangeAxisForDataset() { XYDataset dataset = new XYSeriesCollection(); NumberAxis xAxis = new NumberAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\");",
        "label":1
    },
    {
        "ins1AddCode":"File f = folder.newFile(\"ant.tar\");",
        "ins1DelCode":"File f = File.createTempFile(\"ant\", \".zip\"); f.deleteOnExit();",
        "ins1PreCode":"public void getSetPermissionsWorksForTarResources() throws IOException { File f = File.createTempFile(\"ant\", \".zip\"); f.deleteOnExit(); try (TarOutputStream os = new TarOutputStream(new FileOutputStream(f))) { TarEntry e = new TarEntry(\"foo\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<String> name = new AtomicReference<>(); final AtomicReference<Throwable> err = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<String> name = new AtomicReference<String>(); final AtomicReference<Throwable> err = new AtomicReference<Throwable>();",
        "ins1PreCode":"public void observeOnNormal() throws InterruptedException { final AtomicReference<String> name = new AtomicReference<String>(); final AtomicReference<Throwable> err = new AtomicReference<Throwable>(); final CountDownLatch cdl = new CountDownLatch(1); ",
        "ins2PreCode":"public void observeOnError() throws InterruptedException { final AtomicReference<String> name = new AtomicReference<String>(); final AtomicReference<Throwable> err = new AtomicReference<Throwable>(); final CountDownLatch cdl = new CountDownLatch(1);",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, String> parms = new HashMap<String, String>();",
        "ins1DelCode":"Map parms = new HashMap();",
        "ins1PreCode":"SqlSession sqlSession = sqlSessionFactory.openSession();  try { Map parms = new HashMap(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table1.insert\", parms);",
        "ins2PreCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { Map parms = new HashMap(); parms.put(\"name\", \"Fred\"); int rows = sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insert\", parms);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"InputStream.reset() succeeded\", stringSize - skipped1, input.available());",
        "ins1DelCode":"assertEquals(\"InputStream.reset() succeded\", stringSize - skipped1, input.available());",
        "ins1PreCode":"assertEquals(\"InputStream.skip(), no more input\", 0, input.available()); assertEquals(\"InputStream.skip(), no more input\", -1, input.read()); input.reset(); assertEquals(\"InputStream.reset() succeded\", stringSize - skipped1, input.available()); assertEquals( \"InputStream.reset(), read()\", testString.byteAt(nearEndIndex) & 0xFF, input.read());",
        "ins2PreCode":"assertEquals(\"InputStream.skip(), no more input\", 0, input.available()); assertEquals(\"InputStream.skip(), no more input\", -1, input.read()); input.reset(); assertEquals(\"InputStream.reset() succeded\", stringSize - skipped1, input.available()); assertEquals( \"InputStream.reset(), read()\", stringUnderTest.byteAt(nearEndIndex) & 0xFF, input.read());",
        "label":1
    },
    {
        "ins1AddCode":"RRset<TXTRecord> rrset = new RRset<>();",
        "ins1DelCode":"RRset rrset = new RRset();",
        "ins1PreCode":"RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600, \"TXT 13 0 3600 19700101000003 19700101000000 46271 . dRwMEthIeGiucMcEcDmwixM8/LZcZ+W6lMM0KDSY5rwAGrm1j7tS/VU6xs+rpD5dSRmBYosinkWD6Jk3zRmyBQ==\", Name.root);  RRset rrset = new RRset(); rrset.addRR(txt); rrset.addRR(rrsig);",
        "ins2PreCode":"RRSIGRecord rrsig = (RRSIGRecord) Record.fromString(Name.root, Type.RRSIG, DClass.IN, 3600, \"TXT 13 0 3600 19700101000003 19700101000000 25719 . m6sD/b0ZbfBXsQruhq5dYTnHGaA+PRTL5Y1W36rMdnGBb7eOJRRzDS5Wk5hZlrS4RUKQ/tKMCn7lsl9fn4U2lw==\", Name.root); RRset rrset = new RRset(); rrset.addRR(txt); rrset.addRR(rrsig);",
        "label":1
    },
    {
        "ins1AddCode":"new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 1, 0, 0)); new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0, 0); validateChunks(TEST_APP, 0, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "ins1DelCode":"new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "ins1PreCode":"useTestFiles(true, false); RemoteBlockPushResolver.PushBlockStreamCallback callback1 = (RemoteBlockPushResolver.PushBlockStreamCallback) pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); RemoteBlockPushResolver.AppShufflePartitionInfo partitionInfo = callback1.getPartitionInfo();  TestMergeShuffleFile testIndexFile = (TestMergeShuffleFile) partitionInfo.getIndexFile(); testIndexFile.close(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); callback2.onData(callback2.getID(), ByteBuffer.wrap(new byte[5]));   callback2.onComplete(callback2.getID()); assertEquals(\"index position\", 16, testIndexFile.getPos());   testIndexFile.restore(); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); assertEquals(\"index position\", 24, testIndexFile.getPos()); validateMergeStatuses(statuses, new int[] {0}, new long[] {9}); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "ins2PreCode":"useTestFiles(false, true); RemoteBlockPushResolver.PushBlockStreamCallback callback1 = (RemoteBlockPushResolver.PushBlockStreamCallback) pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); RemoteBlockPushResolver.AppShufflePartitionInfo partitionInfo = callback1.getPartitionInfo(); TestMergeShuffleFile testMetaFile = (TestMergeShuffleFile) partitionInfo.getMetaFile(); testMetaFile.close(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); callback2.onData(callback2.getID(), ByteBuffer.wrap(new byte[5])); callback2.onComplete(callback2.getID()); assertEquals(\"index position\", 16, partitionInfo.getIndexFile().getPos()); testMetaFile.restore(); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); assertEquals(\"index position\", 24, partitionInfo.getIndexFile().getPos()); validateMergeStatuses(statuses, new int[] {0}, new long[] {11}); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 7}, new int[][] {{0}, {1, 2}});",
        "label":1
    },
    {
        "ins1AddCode":"void setCookieHeaderCanBeIncluded() {",
        "ins1DelCode":"public void setCookieHeaderCanBeIncluded() {",
        "ins1PreCode":"public void setCookieHeaderCanBeIncluded() { HttpTrace trace = new HttpTrace(createRequest()); new HttpExchangeTracer(EnumSet.of(Include.RESPONSE_HEADERS, Include.COOKIE_HEADERS)).sendingResponse(trace,",
        "ins2PreCode":"public void mixedCaseSetCookieHeaderCanBeIncluded() { HttpTrace trace = new HttpTrace(createRequest()); new HttpExchangeTracer(EnumSet.of(Include.RESPONSE_HEADERS, Include.COOKIE_HEADERS)).sendingResponse(trace,",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" assertTrue(tc.isDisposed());  Disposable d = Disposables.empty();  tc.onSubscribe(d);",
        "ins2PreCode":"assertTrue(tc.isDisposed()); Disposable d = Disposables.empty(); tc.onSubscribe(d);",
        "label":1
    },
    {
        "ins1AddCode":"clone.foregroundDomainMarkers = (Map) ObjectUtils.clone( clone.backgroundDomainMarkers = (Map) ObjectUtils.clone( clone.foregroundRangeMarkers = (Map) ObjectUtils.clone( clone.backgroundRangeMarkers = (Map) ObjectUtils.clone( clone.annotations = (List) ObjectUtils.deepClone(this.annotations); clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtils.clone( clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtils.clone( clone.quadrantOrigin = (Point2D) ObjectUtils.clone(",
        "ins1DelCode":"clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone( clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone( clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone( clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone( clone.annotations = (List) ObjectUtilities.deepClone(this.annotations); clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone( clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone( clone.quadrantOrigin = (Point2D) ObjectUtilities.clone(",
        "ins1PreCode":"renderer.addChangeListener(clone); } } clone.foregroundDomainMarkers = (Map) ObjectUtilities.clone( this.foregroundDomainMarkers); clone.backgroundDomainMarkers = (Map) ObjectUtilities.clone( this.backgroundDomainMarkers); clone.foregroundRangeMarkers = (Map) ObjectUtilities.clone( this.foregroundRangeMarkers); clone.backgroundRangeMarkers = (Map) ObjectUtilities.clone( this.backgroundRangeMarkers); clone.annotations = (List) ObjectUtilities.deepClone(this.annotations); if (this.fixedDomainAxisSpace != null) { clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone( this.fixedDomainAxisSpace); } if (this.fixedRangeAxisSpace != null) { clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone( this.fixedRangeAxisSpace); } if (this.fixedLegendItems != null) { clone.fixedLegendItems = (LegendItemCollection) this.fixedLegendItems.clone(); } clone.quadrantOrigin = (Point2D) ObjectUtilities.clone( this.quadrantOrigin); clone.quadrantPaint = this.quadrantPaint.clone();",
        "ins2PreCode":"renderer.addChangeListener(clone); } } clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone( this.foregroundDomainMarkers); clone.backgroundDomainMarkers = cloneMarkerMap( this.backgroundDomainMarkers); clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone( this.foregroundRangeMarkers); clone.backgroundRangeMarkers = cloneMarkerMap( this.backgroundRangeMarkers); clone.annotations = (List) ObjectUtilities.deepClone(this.annotations); if (this.fixedDomainAxisSpace != null) { clone.fixedDomainAxisSpace = (AxisSpace) ObjectUtilities.clone( this.fixedDomainAxisSpace); } if (this.fixedRangeAxisSpace != null) { clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone( this.fixedRangeAxisSpace); } if (this.fixedLegendItems != null) { clone.fixedLegendItems = (LegendItemCollection) this.fixedLegendItems.clone(); } clone.fixedRangeAxisSpace = (AxisSpace) ObjectUtilities.clone( this.rangeAxisLocations); clone.datasetToDomainAxesMap.putAll(this.datasetToDomainAxesMap);",
        "label":0
    },
    {
        "ins1AddCode":"exportFormat.export(databaseContext, tmpFile.toPath(), charset, entries);",
        "ins1DelCode":"String filename = tmpFile.getCanonicalPath(); exportFormat.performExport(databaseContext, filename, charset, entries);",
        "ins1PreCode":"public void testPerformExportForSingleAuthor() throws Exception { File tmpFile = testFolder.newFile(); String filename = tmpFile.getCanonicalPath(); BibEntry entry = new BibEntry(); entry.setField(\"author\", \"Someone, Van Something\"); List<BibEntry> entries = Arrays.asList(entry);  exportFormat.performExport(databaseContext, filename, charset, entries);  List<String> lines = Files.readAllLines(tmpFile.toPath());",
        "ins2PreCode":"public void testPerformExportForMultipleAuthors() throws Exception { File tmpFile = testFolder.newFile(); String filename = tmpFile.getCanonicalPath(); BibEntry entry = new BibEntry(); entry.setField(\"author\", \"von Neumann, John and Smith, John and Black Brown, Peter\"); List<BibEntry> entries = Arrays.asList(entry); exportFormat.performExport(databaseContext, filename, charset, entries); List<String> lines = Files.readAllLines(tmpFile.toPath());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void windowUnsubscribeNonOverlappingAsyncSource() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final AtomicInteger count = new AtomicInteger(); Flowable.merge(Flowable.range(1, 100000)",
        "ins2PreCode":"public void windowUnsubscribeOverlappingAsyncSource() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final AtomicInteger count = new AtomicInteger(); Flowable.merge(Flowable.range(1, 100000)",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(Integer.valueOf(2), user.getId()); Assertions.assertEquals(\"User2\", user.getName()); Assertions.assertNull(user.getPets().get(0).getPetName(), \"should not inherit auto-mapping\"); Assertions.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName());",
        "ins1DelCode":"Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_Inline(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_External(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertNeverAtNotMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>(); oi.subscribe(subscriber); ",
        "ins2PreCode":"public void assertNeverAtMatchingValue() { Observable<Integer> oi = Observable.fromIterable(Arrays.asList(1, 2)); TestObserverEx<Integer> subscriber = new TestObserverEx<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1AddCode":"}, false, 2, Schedulers.single())",
        "ins1DelCode":"}, 2, false, Schedulers.single())",
        "ins1PreCode":".repeat(1000) .observeOn(Schedulers.io()); } }, 2, false, Schedulers.single()) .distinct() .test()",
        "ins2PreCode":".repeat(1000) .observeOn(Schedulers.io()); } }, 2, true, Schedulers.single()) .distinct() .test()",
        "label":1
    },
    {
        "ins1AddCode":"spMapper.adderAsSelect(parameter); spMapper.adderAsSelect(parameter);",
        "ins1DelCode":"spMapper.adder(parameter); spMapper.adder(parameter);",
        "ins1PreCode":" SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum());  parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum()); ",
        "ins2PreCode":"SPMapper spMapper = sqlSession.getMapper(SPMapper.class); spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum()); parameter = new Parameter(); parameter.setAddend1(2); parameter.setAddend2(3); spMapper.adder(parameter); assertEquals((Integer) 5, parameter.getSum());",
        "label":1
    },
    {
        "ins1AddCode":"System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); System.clearProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD);",
        "ins1DelCode":"System.setProperty(\"LOG_EXCEPTION_CONVERSION_WORD\", \"%ex\"); System.clearProperty(\"LOG_EXCEPTION_CONVERSION_WORD\");",
        "ins1PreCode":"public void customExceptionConversionWord() throws Exception { System.setProperty(\"LOG_EXCEPTION_CONVERSION_WORD\", \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf( containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput)); } finally { System.clearProperty(\"LOG_EXCEPTION_CONVERSION_WORD\"); }",
        "ins2PreCode":"public void customExceptionConversionWord() throws Exception { System.setProperty(\"LOG_EXCEPTION_CONVERSION_WORD\", \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf( containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = FileCopyUtils .copyToString(new FileReader(new File(tmpDir() + \"/spring.log\"))); assertThat(fileContents).is(Matched.by(expectedOutput)); } finally { System.clearProperty(\"LOG_EXCEPTION_CONVERSION_WORD\"); }",
        "label":1
    },
    {
        "ins1AddCode":".addLengthDelimited(UnknownFieldSet.newBuilder() .addField(12, UnknownFieldSet.Field.newBuilder() .addVarint(6) .build()) .build().toByteString())",
        "ins1DelCode":"",
        "ins1PreCode":"private UnknownFieldSet makeUnknownFieldSet() { return UnknownFieldSet.newBuilder() .addField(5, UnknownFieldSet.Field.newBuilder() .addVarint(1) .addFixed32(2) .addFixed64(3) .addLengthDelimited(ByteString.copyFromUtf8(\"4\")) .addGroup( UnknownFieldSet.newBuilder() .addField(10, UnknownFieldSet.Field.newBuilder() .addVarint(5) .build()) .build()) .build()) .addField(8,",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"TIMEOUT = 10;",
        "ins1PreCode":"this.datasource.setValidationQuery(\"SELECT 1\"); this.datasource.setValidationQueryTimeout(TIMEOUT);  TIMEOUT = 10; isTimeoutSet = false;",
        "ins2PreCode":"this.datasource.setValidationQuery(\"SELECT 1\"); this.datasource.setValidationQuery(\"SELECT 1\"); this.datasource.setMaxActive(1); this.datasource.setInitialSize(1);",
        "label":0
    },
    {
        "ins1AddCode":"Class<?> messageClass = resolveMessageClass();",
        "ins1DelCode":"Class<?> messageClass = Class.forName(messageClassName);",
        "ins1PreCode":"protected Object readResolve() throws ObjectStreamException { try { Class<?> messageClass = Class.forName(messageClassName); java.lang.reflect.Field defaultInstanceField = messageClass.getDeclaredField(\"DEFAULT_INSTANCE\");",
        "ins2PreCode":"private Object readResolveFallback() throws ObjectStreamException { try { Class<?> messageClass = Class.forName(messageClassName); java.lang.reflect.Field defaultInstanceField = messageClass.getDeclaredField(\"defaultInstance\");",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Integer> to1 = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Integer> to1 = new TestObserver<Integer>();",
        "ins1PreCode":" final ConnectableObservable<Integer> co = ps.replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>();  co.subscribe(to1);",
        "ins2PreCode":"final ConnectableObservable<Integer> co = ps.replay(); final TestObserver<Integer> to1 = new TestObserver<Integer>(); co.subscribe(to1);",
        "label":1
    },
    {
        "ins1AddCode":"as[0] = new EqualObserver<>(this, 0, bufferSize); as[1] = new EqualObserver<>(this, 1, bufferSize);",
        "ins1DelCode":"as[0] = new EqualObserver<T>(this, 0, bufferSize); as[1] = new EqualObserver<T>(this, 1, bufferSize);",
        "ins1PreCode":"@SuppressWarnings(\"unchecked\") EqualObserver<T>[] as = new EqualObserver[2]; this.observers = as; as[0] = new EqualObserver<T>(this, 0, bufferSize); as[1] = new EqualObserver<T>(this, 1, bufferSize); this.resources = new ArrayCompositeDisposable(2);",
        "ins2PreCode":"@SuppressWarnings(\"unchecked\") EqualObserver<T>[] as = new EqualObserver[2]; this.observers = as; as[0] = new EqualObserver<T>(this, 0, bufferSize); as[1] = new EqualObserver<T>(this, 1, bufferSize); this.resources = new ArrayCompositeDisposable(2);",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(dataset,",
        "ins1DelCode":"XYPlot plot = new XYPlot(dataset,",
        "ins1PreCode":"s2.add(15.0, 9.5); s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new XYStepRenderer());",
        "ins2PreCode":"s2.add(15.0, 9.5); s2.add(20.0, 3.5); dataset.addSeries(s2); XYPlot plot = new XYPlot(dataset, new NumberAxis(\"X\"), new NumberAxis(\"Y\"), new XYAreaRenderer2());",
        "label":1
    },
    {
        "ins1AddCode":"clearNonBlockingListeners();",
        "ins1DelCode":"",
        "ins1PreCode":"state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.READ_WRITE_OP) { state = AsyncState.MUST_COMPLETE; } else { throw new IllegalStateException(",
        "ins2PreCode":"state == AsyncState.ERROR) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state = AsyncState.MUST_DISPATCH; } else { throw new IllegalStateException(",
        "label":0
    },
    {
        "ins1AddCode":"dbContext.setDatabasePath(file);",
        "ins1DelCode":"dbContext.setDatabaseFile(file.toFile());",
        "ins1PreCode":"Path file = Paths.get(\"./relative/subdir\").resolve(\"biblio.bib\");  BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabaseFile(file.toFile()); List<String> fileDirectories = dbContext.getFileDirectories(StandardField.FILE, fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()),",
        "ins2PreCode":"Path file = Paths.get(\"/absolute/subdir\").resolve(\"biblio.bib\"); BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabaseFile(file.toFile()); List<String> fileDirectories = dbContext.getFileDirectories(StandardField.FILE, fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()),",
        "label":1
    },
    {
        "ins1AddCode":"void shouldSelectBlogWithPostsAndAuthorUsingSubSelects() {",
        "ins1DelCode":"public void shouldSelectBlogWithPostsAndAuthorUsingSubSelects() {",
        "ins1PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingSubSelects() { try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelect\", 1);",
        "ins2PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingSubSelectsLazily() { try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1);",
        "label":1
    },
    {
        "ins1AddCode":"data.addValue(\"C\", 1.0); data.addValue(\"D\", 3.0); data.addValue(\"A\", 2.0); assertEquals(data.getValue(\"A\"), 2.0); assertEquals(data.getValue(\"C\"), 1.0); assertEquals(data.getValue(\"D\"), 3.0); assertEquals(data.getValue(0), 2.0); assertEquals(data.getValue(2), 1.0); assertEquals(data.getValue(3), 3.0);",
        "ins1DelCode":"data.addValue(\"C\", new Double(1.0)); data.addValue(\"D\", new Double(3.0)); data.addValue(\"A\", new Double(2.0)); assertEquals(data.getValue(\"A\"), new Double(2.0)); assertEquals(data.getValue(\"C\"), new Double(1.0)); assertEquals(data.getValue(\"D\"), new Double(3.0)); assertEquals(data.getValue(0), new Double(2.0)); assertEquals(data.getValue(2), new Double(1.0)); assertEquals(data.getValue(3), new Double(3.0));",
        "ins1PreCode":"public void testSortByKeyAscending() {  DefaultKeyedValues<String> data = new DefaultKeyedValues<>(); data.addValue(\"C\", new Double(1.0)); data.addValue(\"B\", null); data.addValue(\"D\", new Double(3.0)); data.addValue(\"A\", new Double(2.0));  data.sortByKeys(SortOrder.ASCENDING);   assertEquals(data.getKey(0), \"A\"); assertEquals(data.getKey(1), \"B\"); assertEquals(data.getKey(2), \"C\"); assertEquals(data.getKey(3), \"D\");   assertEquals(data.getValue(\"A\"), new Double(2.0)); assertEquals(data.getValue(\"B\"), null); assertEquals(data.getValue(\"C\"), new Double(1.0)); assertEquals(data.getValue(\"D\"), new Double(3.0));   assertEquals(data.getValue(0), new Double(2.0)); assertEquals(data.getValue(1), null); assertEquals(data.getValue(2), new Double(1.0)); assertEquals(data.getValue(3), new Double(3.0)); ",
        "ins2PreCode":"public void testSortByKeyDescending() { DefaultKeyedValues<String> data = new DefaultKeyedValues<>(); data.addValue(\"C\", new Double(1.0)); data.addValue(\"B\", null); data.addValue(\"D\", new Double(3.0)); data.addValue(\"A\", new Double(2.0)); data.sortByKeys(SortOrder.DESCENDING); assertEquals(data.getKey(0), \"D\"); assertEquals(data.getKey(1), \"C\"); assertEquals(data.getKey(1), \"C\"); assertEquals(data.getKey(0), \"D\"); assertEquals(data.getValue(\"A\"), new Double(2.0)); assertEquals(data.getValue(\"B\"), null); assertEquals(data.getValue(\"C\"), new Double(1.0)); assertEquals(data.getValue(\"D\"), new Double(3.0)); assertEquals(data.getValue(0), new Double(3.0)); assertEquals(data.getValue(2), null); assertEquals(data.getValue(1), new Double(1.0)); assertEquals(data.getValue(0), new Double(3.0));",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1DelCode":"assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1PreCode":" String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString(); assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"if (!elements.contains(o) && !(isClearable && (\"\".equals(o) || CLEARED.equals(o)))) { if (isClearable && !elements.contains(CLEARED)) { addElement(CLEARED); }",
        "ins1DelCode":"if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { } if (isClearable && !elements.contains(\"\")) { addElement(\"\");",
        "ins1PreCode":"if (elements != null) { ArrayList toBeRemoved = new ArrayList(); for (Object o : objects) { if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements);  if (!objects.contains(selectedObject)) { selectedObject = null; } if (isClearable && !elements.contains(\"\")) { addElement(\"\"); } } else {",
        "ins2PreCode":"if (elements != null) { ArrayList toBeRemoved = new ArrayList(); Object o = objects.get(i); if (!elements.contains(o) && !(isClearable && \"\".equals(o))) { toBeRemoved.add(o); } } removeAll(toBeRemoved); addAll(elements); if (!objects.contains(selectedObject)) { selectedObject = null; } if (isClearable && !elements.contains(\"\")) { addElement(\"\"); } } else {",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(expected.getCause()).isInstanceOf(SomeOtherCheckedException.class);",
        "ins1DelCode":"assertTrue(expected.getCause() instanceof SomeOtherCheckedException);",
        "ins1PreCode":"sample.oneDeclared(); fail(); } catch (RuntimeException expected) { assertTrue(expected.getCause() instanceof SomeOtherCheckedException); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":".collect(new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }, new BiConsumer<List<Integer>, Integer>() {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void testQueryStatsOneWithLastInvocation() throws Exception {",
        "ins1DelCode":"public void testQueryStatsOneWithLastInvocation() throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {",
        "ins1PreCode":"public void testQueryStatsOneWithLastInvocation() throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Comparator<QueryStats> queryStatsComparator = createComparator(); QueryStats q1 = new QueryStats(\"abc\");",
        "ins2PreCode":"public void testQueryStatsBothWithSameLastInvocation() throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Comparator<QueryStats> queryStatsComparator = createComparator(); QueryStats q1 = new QueryStats(\"abc\");",
        "label":1
    },
    {
        "ins1AddCode":"void testplan3() {",
        "ins1DelCode":"public void testplan3() {",
        "ins1PreCode":"public void testplan3() { try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);",
        "ins2PreCode":"public void shouldInsertWithOptionsFlushesCache() { try (SqlSession sqlSession1 = sqlSessionFactory.openSession(true)) { PersonMapper pm = sqlSession1.getMapper(PersonMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"SingleDisposable<T> md = new SingleDisposable<>(observer, this);",
        "ins1DelCode":"SingleDisposable<T> md = new SingleDisposable<T>(observer, this);",
        "ins1PreCode":"protected void subscribeActual(@NonNull SingleObserver<? super T> observer) { SingleDisposable<T> md = new SingleDisposable<T>(observer, this); observer.onSubscribe(md); if (add(md)) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"label_14: jj_la1[36] = jj_gen; break label_14; jj_la1[37] = jj_gen;",
        "ins1DelCode":"label_12: jj_la1[35] = jj_gen; break label_12; jj_la1[36] = jj_gen;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_12: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[35] = jj_gen; break label_12; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: MapEntry(); label_13: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[37] = jj_gen; break label_13; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"SavePreferences preferences = new SavePreferences().withEncoding(StandardCharsets.US_ASCII);",
        "ins1DelCode":"SavePreferences preferences = new SavePreferences().withEncoding(Charsets.US_ASCII);",
        "ins1PreCode":"public void writeEncodingAndEntry() throws Exception { SavePreferences preferences = new SavePreferences().withEncoding(Charsets.US_ASCII); BibEntry entry = new BibEntry(); entry.setType(BibtexEntryTypes.ARTICLE);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if( desiredSize < 256 ) { desiredSize=256; } newSize > limit ) { newSize=limit; } newSize > limit ) { newSize=limit; }",
        "ins1DelCode":"if( desiredSize < 256 ) desiredSize=256; newSize > limit ) newSize=limit; newSize > limit ) newSize=limit;",
        "ins1PreCode":"}  if( buff==null ) { if( desiredSize < 256 ) desiredSize=256; buff=new byte[desiredSize]; }    if( desiredSize <= buff.length ) { return; }  if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit >0 && newSize > limit ) newSize=limit; tmp=new byte[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) newSize=limit; tmp=new byte[newSize]; }",
        "ins2PreCode":"} if( buff==null ) { if( desiredSize < 256 ) desiredSize=256; buff=new char[desiredSize]; } if( desiredSize <= buff.length) { return; } if( desiredSize < 2 * buff.length ) { newSize= buff.length * 2; if( limit > 0 && newSize > limit ) newSize=limit; tmp=new char[newSize]; } else { newSize= buff.length * 2 + count ; if( limit > 0 && newSize > limit ) newSize=limit; tmp=new char[newSize]; }",
        "label":1
    },
    {
        "ins1AddCode":"String mainjarstring = buildRule.getProject().getProperty(\"main.jar\"); String extjarstring = buildRule.getProject().getProperty(\"ext.jar\"); Path myPath = new Path(buildRule.getProject()); buildRule.getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = buildRule.getProject().createClassLoader(myPath);",
        "ins1DelCode":"String mainjarstring = getProject().getProperty(\"main.jar\"); String extjarstring = getProject().getProperty(\"ext.jar\"); Path myPath = new Path(getProject()); getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = getProject().createClassLoader(myPath);",
        "ins1PreCode":"public void testJarWithManifestInDirWithSpace() { String mainjarstring = getProject().getProperty(\"main.jar\"); String extjarstring = getProject().getProperty(\"ext.jar\"); Path myPath = new Path(getProject()); myPath.setLocation(new File(mainjarstring)); getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = getProject().createClassLoader(myPath); String path = loader.getClasspath(); assertEquals(mainjarstring + File.pathSeparator + extjarstring, path);",
        "ins2PreCode":"public void testJarWithManifestInNonAsciiDir() { String mainjarstring = getProject().getProperty(\"main.jar.nonascii\"); String extjarstring = getProject().getProperty(\"ext.jar.nonascii\"); Path myPath = new Path(getProject()); myPath.setLocation(new File(mainjarstring)); getProject().setUserProperty(\"build.sysclasspath\",\"ignore\"); loader = getProject().createClassLoader(myPath); String path = loader.getClasspath(); assertEquals(mainjarstring + File.pathSeparator + extjarstring, path);",
        "label":1
    },
    {
        "ins1AddCode":"File oldFile = new File(Jenkins.get().getRootDir(), f.getName());",
        "ins1DelCode":"File oldFile = new File(Jenkins.getActiveInstance().getRootDir(), f.getName());",
        "ins1PreCode":"} else { lastRotateMillis = System.currentTimeMillis();  File oldFile = new File(Jenkins.getActiveInstance().getRootDir(), f.getName()); if (oldFile.isFile()) { File newFile = new File(f.getParentFile(), f.getName() + \".1\");",
        "ins2PreCode":"} else { lastRotateMillis = System.currentTimeMillis(); File oldFile = new File(Jenkins.getActiveInstance().getRootDir(), f.getName()); if (oldFile.isFile()) { File newFile = new File(f.getParentFile(), f.getName() + \".1\");",
        "label":1
    },
    {
        "ins1AddCode":"result.add(shrinkStatus(stat));",
        "ins1DelCode":"result.add(stat);",
        "ins1PreCode":"addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(stat); } }",
        "ins2PreCode":"addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(stat); } }",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<String> outer = new TestObserver<>(observer);",
        "ins1DelCode":"TestObserver<String> outer = new TestObserver<String>(observer);",
        "ins1PreCode":" Observer<Object> observer = TestHelper.mockObserver();  TestObserver<String> outer = new TestObserver<String>(observer);  fromCallableObservable",
        "ins2PreCode":"Observer<Object> observer = TestHelper.mockObserver(); TestObserver<String> outer = new TestObserver<String>(observer); fromCallableObservable",
        "label":1
    },
    {
        "ins1AddCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBindIfPrefixDifferent() {",
        "ins1DelCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBindIfPrefixDifferent() throws Exception {",
        "ins1PreCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBindIfPrefixDifferent() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.foo\", \"bar\");",
        "ins2PreCode":"public void bindWhenUsingNoUnboundElementsHandlerShouldBindIfUnboundSystemProperties() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"example.foo\", \"bar\");",
        "label":1
    },
    {
        "ins1AddCode":"final ArrayList<String> results = new ArrayList<>();",
        "ins1DelCode":"final ArrayList<String> results = new ArrayList<String>();",
        "ins1PreCode":"public void groupsWithNestedSubscribeOn() throws InterruptedException { final ArrayList<String> results = new ArrayList<String>(); Flowable.unsafeCreate(new Publisher<Integer>() { ",
        "ins2PreCode":"public void groupsWithNestedSubscribeOn() throws InterruptedException { final ArrayList<String> results = new ArrayList<String>(); Observable.unsafeCreate(new ObservableSource<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to1 = new TestObserverEx<>(); TestObserverEx<Integer> to2 = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to1 = new TestObserverEx<Integer>(); TestObserverEx<Integer> to2 = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void async() { Observable<Integer> source = Observable.range(1, 10000); for (int i = 0; i < 100; i++) { TestObserverEx<Integer> to1 = new TestObserverEx<Integer>();  Observable<Integer> cached = source.replay().autoConnect();  cached.observeOn(Schedulers.computation()).subscribe(to1);  to1.awaitDone(2, TimeUnit.SECONDS); to1.assertNoErrors(); to1.assertTerminated(); assertEquals(10000, to1.values().size());  TestObserverEx<Integer> to2 = new TestObserverEx<Integer>(); cached.observeOn(Schedulers.computation()).subscribe(to2); ",
        "ins2PreCode":"public void async() { Observable<Integer> source = Observable.range(1, 10000); for (int i = 0; i < 100; i++) { TestObserverEx<Integer> to1 = new TestObserverEx<Integer>(); Observable<Integer> cached = source.replay().autoConnect(); cached.observeOn(Schedulers.computation()).subscribe(to1); to1.awaitDone(2, TimeUnit.SECONDS); to1.assertNoErrors(); to1.assertTerminated(); assertEquals(10000, to1.values().size()); TestObserverEx<Integer> to2 = new TestObserverEx<Integer>(); cached.observeOn(Schedulers.computation()).subscribe(to2);",
        "label":1
    },
    {
        "ins1AddCode":"SetProcessor setProcessor = factory.create(null, processorTag, null, config);",
        "ins1DelCode":"SetProcessor setProcessor = factory.create(null, processorTag, config);",
        "ins1PreCode":"config.put(\"field\", \"field1\"); config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); SetProcessor setProcessor = factory.create(null, processorTag, config); assertThat(setProcessor.getTag(), equalTo(processorTag)); assertThat(setProcessor.getField().newInstance(Collections.emptyMap()).execute(), equalTo(\"field1\"));",
        "ins2PreCode":"config.put(\"field\", \"field1\"); config.put(\"value\", \"value1\"); String processorTag = randomAlphaOfLength(10); SetProcessor setProcessor = factory.create(null, processorTag, config); assertThat(setProcessor.getTag(), equalTo(processorTag)); assertThat(setProcessor.getField().newInstance(Collections.emptyMap()).execute(), equalTo(\"field1\"));",
        "label":1
    },
    {
        "ins1AddCode":"final List<Throwable> list = new CopyOnWriteArrayList<>();",
        "ins1DelCode":"final List<Throwable> list = new CopyOnWriteArrayList<Throwable>();",
        "ins1PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissions() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list)); final RuntimeException e1 = new RuntimeException();",
        "ins2PreCode":"public void collectorFailureDoesNotResultInTwoErrorEmissionsFlowable() { try { final List<Throwable> list = new CopyOnWriteArrayList<Throwable>(); RxJavaPlugins.setErrorHandler(addToList(list)); final RuntimeException e1 = new RuntimeException();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(new UnknownEntryType(\"unknown\"), entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1DelCode":"assertEquals(\"unknown\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"unknown\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);",
        "ins1DelCode":"XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer);",
        "ins1PreCode":"NumberAxis xAxis = new NumberAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer);  NumberAxis xAxis2 = new NumberAxis(\"X2\");",
        "ins2PreCode":"NumberAxis xAxis = new NumberAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer); NumberAxis xAxis = new NumberAxis(\"X\");",
        "label":1
    },
    {
        "ins1AddCode":"buildRule.getProject().executeTarget(\"extended-setup\"); String tmpdir = buildRule.getProject().getProperty(\"output\").replace(",
        "ins1DelCode":"getProject().executeTarget(\"extended-setup\"); String tmpdir = getProject().getProperty(\"output\").replace(",
        "ins1PreCode":"public void testAbsolute3() { getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getProperty(\"output\").replace( File.separatorChar, '/'); ds.setIncludes(new String[] {tmpdir + \"/**/*\"});",
        "ins2PreCode":"public void testAbsolute4() { getProject().executeTarget(\"extended-setup\"); DirectoryScanner ds = new DirectoryScanner(); String tmpdir = getProject().getProperty(\"output\").replace( File.separatorChar, '/') ; ds.setIncludes(new String[] {tmpdir + \"/alpha/beta/**/*\",",
        "label":1
    },
    {
        "ins1AddCode":".publish(v -> Flowable.mergeArray( v.filter(w -> w % 2 == 0), v.filter(w -> w % 2 != 0)))",
        "ins1DelCode":".publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Integer> v) throws Exception { return Flowable.mergeArray( v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 == 0; } }), v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 != 0; } })); } })",
        "ins1PreCode":"public void longFlow() { Flowable.range(1, 1000000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Integer> v) throws Exception { return Flowable.mergeArray( v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 == 0; } }), v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 != 0; } })); } }) .takeLast(1) .test()",
        "ins2PreCode":"public void longFlow2() { Flowable.range(1, 100000) .publish(new Function<Flowable<Integer>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Integer> v) throws Exception { return Flowable.mergeArray( v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 == 0; } }), v.filter(new Predicate<Integer>() { @Override public boolean test(Integer w) throws Exception { return w % 2 != 0; } })); } }) .test() .test()",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(directedGraph.addEdge(N1, N2, E12)).isTrue();",
        "ins1DelCode":"assertThat(directedGraph.addEdgeV2(N1, N2, E12)).isTrue();",
        "ins1PreCode":"MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed() .expectedNodeCount(NODE_COUNT) .build(); assertThat(directedGraph.addEdgeV2(N1, N2, E12)).isTrue(); assertThat(directedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12)); assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();",
        "ins2PreCode":"MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected() .expectedNodeCount(NODE_COUNT) .build(); assertThat(undirectedGraph.addEdgeV2(N1, N2, E12)).isTrue(); assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12)); assertThat(undirectedGraph.edgesConnecting(N2, N1)).isEqualTo(ImmutableSet.of(E12));",
        "label":1
    },
    {
        "ins1AddCode":"XYSeriesCollection<String> d1 = new XYSeriesCollection<>(); XYSeries<String> s1 = new XYSeries<>(\"S1\"); XYSeries<String> s2 = new XYSeries<>(\"S2\"); XYSeriesCollection<String> d2 = new XYSeriesCollection<>(); XYSeries<String> s3 = new XYSeries<>(\"S3\"); XYSeries<String> s4 = new XYSeries<>(\"S4\"); XYSeries<String> s5 = new XYSeries<>(\"S5\");",
        "ins1DelCode":"XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); XYSeries s2 = new XYSeries(\"S2\"); XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); XYSeries s4 = new XYSeries(\"S4\"); XYSeries s5 = new XYSeries(\"S5\");",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); XYSeries s2 = new XYSeries(\"S2\"); s2.add(1.0, 1.1); d1.addSeries(s1); d1.addSeries(s2);  XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); s3.add(1.0, 1.1); XYSeries s4 = new XYSeries(\"S4\"); s4.add(1.0, 1.1); XYSeries s5 = new XYSeries(\"S5\"); s5.add(1.0, 1.1); d2.addSeries(s3);",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); XYSeries s2 = new XYSeries(\"S2\"); s2.add(1.0, 1.1); d1.addSeries(s1); d1.addSeries(s2); XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); s3.add(1.0, 1.1); XYSeries s4 = new XYSeries(\"S4\"); s4.add(1.0, 1.1); XYSeries s5 = new XYSeries(\"S5\"); s5.add(1.0, 1.1); d2.addSeries(s3);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(urls).hasSize(1);",
        "ins1DelCode":"assertThat(urls.length).isEqualTo(1);",
        "ins1PreCode":"dependency.put(\"ext\", \"pom\"); createGrapeEngine().grab(args, dependency); URL[] urls = this.groovyClassLoader.getURLs(); assertThat(urls.length).isEqualTo(1); assertThat(urls[0].toExternalForm().endsWith(\".pom\")).isTrue();",
        "ins2PreCode":"dependency.put(\"classifier\", \"sources\"); createGrapeEngine().grab(args, dependency); URL[] urls = this.groovyClassLoader.getURLs(); assertThat(urls.length).isEqualTo(1); assertThat(urls[0].toExternalForm().endsWith(\"-sources.jar\")).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); new ConcatMapSingleSubscriber<>(",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); new ConcatMapSingleSubscriber<Integer, Integer>(",
        "ins1PreCode":"public void cancelNoConcurrentClean() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ConcatMapSingleSubscriber<Integer, Integer> operator = new ConcatMapSingleSubscriber<Integer, Integer>( ts, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE); ",
        "ins2PreCode":"public void cancelNoConcurrentClean() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ConcatMapMaybeSubscriber<Integer, Integer> operator = new ConcatMapMaybeSubscriber<Integer, Integer>( ts, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue(); assertThat(graphAsMutableGraph.removeNode(N1)).isTrue(); assertThat(graphAsMutableGraph.removeNode(N1)).isFalse();",
        "ins1DelCode":"assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.removeNode(N1)).isFalse();",
        "ins1PreCode":"public void removeNode_existingNode() { putEdge(N1, N2); putEdge(N4, N1); assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.removeNode(N1)).isFalse(); assertThat(graph.nodes()).containsExactly(N2, N4); assertThat(graph.adjacentNodes(N2)).isEmpty();",
        "ins2PreCode":"public void removeNode_existingNode() { putEdge(N1, N2); putEdge(N4, N1); assertThat(graph.removeNode(N1)).isTrue(); assertThat(graph.removeNode(N1)).isFalse(); assertThat(graph.nodes()).containsExactly(N2, N4); assertThat(graph.adjacentNodes(N2)).isEmpty();",
        "label":1
    },
    {
        "ins1AddCode":"Map<String,String> result = HttpParser.parseAuthorizationDigest(input);",
        "ins1DelCode":"Map<String,String> result = HttpParser2.parseAuthorizationDigest(input);",
        "ins1PreCode":" StringReader input = new StringReader(header);  Map<String,String> result = HttpParser2.parseAuthorizationDigest(input);  Assert.assertEquals(\"mthornton\", result.get(\"username\"));",
        "ins2PreCode":"StringReader input = new StringReader(header); Map<String,String> result = HttpParser2.parseAuthorizationDigest(input); Assert.assertEquals(\"mthornton\", result.get(\"username\"));",
        "label":1
    },
    {
        "ins1AddCode":"public void shouldFindPostByIDWithDynamicSql() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1DelCode":"public void shouldFindPostByIDWithDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { } finally { session.close();",
        "ins1PreCode":"public void shouldFindPostByIDWithDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"id\", 1); }}); assertEquals(1, posts.size()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"blog_id\", 1); }}); assertEquals(2, posts.size()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"\"Serializing to a byte array threw an IOException (should never happen).\", e);",
        "ins1DelCode":"\"Serializing to a byte array threw an IOException \" + \"(should never happen).\", e);",
        "ins1PreCode":"return result; } catch (final IOException e) { throw new RuntimeException( \"Serializing to a byte array threw an IOException \" + \"(should never happen).\", e); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void addActiveFilter(InputFilter filter) {",
        "ins1DelCode":"public void addActiveFilter(InputFilter filter) {",
        "ins1PreCode":"public void addActiveFilter(InputFilter filter) {  if (lastActiveFilter == -1) {",
        "ins2PreCode":"public void addActiveFilter(OutputFilter filter) { if (lastActiveFilter == -1) {",
        "label":0
    },
    {
        "ins1AddCode":"Arrays.setAll(configurations, (i) -> mock(JettyServerCustomizer.class));",
        "ins1DelCode":"Arrays.setAll(configurations, i -> mock(JettyServerCustomizer.class));",
        "ins1PreCode":"public void jettyCustomizations() { JettyServletWebServerFactory factory = getFactory(); JettyServerCustomizer[] configurations = new JettyServerCustomizer[4]; Arrays.setAll(configurations, i -> mock(JettyServerCustomizer.class)); factory.setServerCustomizers(Arrays.asList(configurations[0], configurations[1])); factory.addServerCustomizers(configurations[2], configurations[3]);",
        "ins2PreCode":"public void jettyCustomizersShouldBeInvoked() { JettyReactiveWebServerFactory factory = getFactory(); JettyServerCustomizer[] configurations = new JettyServerCustomizer[4]; Arrays.setAll(configurations, i -> mock(JettyServerCustomizer.class)); factory.setServerCustomizers(Arrays.asList(configurations[0], configurations[1])); factory.addServerCustomizers(configurations[2], configurations[3]);",
        "label":1
    },
    {
        "ins1AddCode":"void annotatedResponseStatusCode() {",
        "ins1DelCode":"public void annotatedResponseStatusCode() {",
        "ins1PreCode":"public void annotatedResponseStatusCode() { Exception error = new CustomException(); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build();",
        "ins2PreCode":"public void annotatedResponseStatusCodeWithCustomReasonPhrase() { Exception error = new Custom2Exception(); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build();",
        "label":1
    },
    {
        "ins1AddCode":"void shouldExtendedAdaptSystemEnvironmentPropertySource() {",
        "ins1DelCode":"public void shouldExtendedAdaptSystemEnvironmentPropertySource() {",
        "ins1PreCode":"public void shouldExtendedAdaptSystemEnvironmentPropertySource() { MutablePropertySources sources = new MutablePropertySources(); sources.addLast(new SystemEnvironmentPropertySource(",
        "ins2PreCode":"public void shouldNotAdaptSystemEnvironmentPropertyOverrideSource() { MutablePropertySources sources = new MutablePropertySources(); public void shouldNotAdaptSystemEnvironmentPropertyOverrideSource() {",
        "label":1
    },
    {
        "ins1AddCode":"Arrays.setAll(listeners, i -> mock(TomcatContextCustomizer.class));",
        "ins1DelCode":"for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatContextCustomizer.class); }",
        "ins1PreCode":"public void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatContextCustomizer.class); } factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "ins2PreCode":"public void tomcatConnectorCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatConnectorCustomizer[] listeners = new TomcatConnectorCustomizer[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatConnectorCustomizer.class); } factory.setTomcatConnectorCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "label":1
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(-623289610000L, s.getFirstMillisecond(cal)); s.getFirstMillisecond((Calendar) null);",
        "ins1DelCode":"assertEquals(-623289610000L, s.getFirstMillisecond(zone)); s.getFirstMillisecond((TimeZone) null);",
        "ins1PreCode":"public void testGetFirstMillisecondWithTimeZone() { Second s = new Second(50, 59, 15, 1, 4, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-623289610000L, s.getFirstMillisecond(zone));   boolean pass = false; try { s.getFirstMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "ins2PreCode":"public void testGetLastMillisecondWithTimeZone() { Second s = new Second(55, 1, 2, 7, 7, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-614962684001L, s.getLastMillisecond(zone)); boolean pass = false; try { s.getLastMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void debounceWithTimeBackpressure() throws InterruptedException { TestScheduler scheduler = new TestScheduler(); TestSubscriberEx<Integer> subscriber = new TestSubscriberEx<Integer>(); Flowable.merge( Flowable.just(1),",
        "ins2PreCode":"public void debounceWithTimeBackpressure() throws InterruptedException { TestScheduler scheduler = new TestScheduler(); TestObserverEx<Integer> observer = new TestObserverEx<Integer>(); Observable.merge( Observable.just(1),",
        "label":1
    },
    {
        "ins1AddCode":"LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(1.0, 100, 0.0, 1.0);",
        "ins1DelCode":"LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD();",
        "ins1PreCode":"List<LabeledPoint> validationData = LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LinearRegressionWithSGD linSGDImpl = new LinearRegressionWithSGD(); linSGDImpl.setIntercept(true); LinearRegressionModel model = linSGDImpl.run(testRDD.rdd());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ArgoDiagram diag = ProjectManager.getManager().getCurrentProject() .getActiveDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else {",
        "ins1DelCode":"if (Model.getFacade().isAClassifierRole(node)) { figNode = new FigClassifierRole(gm, lay, node); } else if (Model.getFacade().isAMessage(node)) { figNode = new FigMessage(gm, lay, node); } else if (Model.getFacade().isAComment(node)) { figNode = new FigComment(gm, node); } else {",
        "ins1PreCode":" FigNode figNode = null;  if (Model.getFacade().isAClassifierRole(node)) { figNode = new FigClassifierRole(gm, lay, node); } else if (Model.getFacade().isAMessage(node)) { figNode = new FigMessage(gm, lay, node); } else if (Model.getFacade().isAComment(node)) { figNode = new FigComment(gm, node); } else { LOG.debug(\"TODO: CollabDiagramRenderer getFigNodeFor\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>();",
        "ins1PreCode":"Flowable<Integer> f1 = createInfiniteFlowable(generatedA).take(Flowable.bufferSize() * 2); Flowable<Integer> f2 = createInfiniteFlowable(generatedB).take(Flowable.bufferSize() * 2);  TestSubscriber<String> ts = new TestSubscriber<String>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() { ",
        "ins2PreCode":"Flowable<Integer> f1 = createInfiniteFlowable(generatedA).subscribeOn(Schedulers.computation()); Flowable<Integer> f2 = createInfiniteFlowable(generatedB).subscribeOn(Schedulers.computation()); TestSubscriber<String> ts = new TestSubscriber<String>(); Flowable.zip(f1, f2, new BiFunction<Integer, Integer, String>() {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Integer.valueOf(7), answer.get(0).get(\"ID\"));",
        "ins1DelCode":"assertEquals(new Integer(7), answer.get(0).get(\"ID\"));",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { List<Map<String, Object>> answer = sqlSession.selectList(\"org.apache.ibatis.submitted.dynsql.ognlStaticMethodCall\", \"Rock 'n Roll\"); assertTrue(answer.size() == 1); assertEquals(new Integer(7), answer.get(0).get(\"ID\")); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ON_PARAM); this.errorProperties.setIncludeMessage(ErrorProperties.IncludeAttribute.ON_PARAM); this.request.addParameter(\"message\", \"true\");",
        "ins1DelCode":"this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM); this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ON_DETAILS_PARAM); this.request.addParameter(\"details\", \"true\");",
        "ins1PreCode":"void errorResponseParamsTrue() { this.errorProperties.setIncludeStacktrace(ErrorProperties.IncludeStacktrace.ON_TRACE_PARAM); this.errorProperties.setIncludeDetails(ErrorProperties.IncludeDetails.ON_DETAILS_PARAM); this.request.addParameter(\"trace\", \"true\"); this.request.addParameter(\"details\", \"true\"); ManagementErrorEndpoint endpoint = new ManagementErrorEndpoint(this.errorAttributes, this.errorProperties); Map<String, Object> response = endpoint.invoke(new ServletWebRequest(this.request));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Color.WHITE, r.getBaseFillPaint()); assertEquals(Color.WHITE, r.lookupSeriesFillPaint(0));",
        "ins1DelCode":"assertEquals(Color.white, r.getBaseFillPaint()); assertEquals(Color.white, r.lookupSeriesFillPaint(0));",
        "ins1PreCode":"public void testFillPaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.white, r.getBaseFillPaint());   r.setAutoPopulateSeriesFillPaint(false); assertEquals(Color.white, r.lookupSeriesFillPaint(0)); assertNull(r.getSeriesFillPaint(0)); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE, true) {",
        "ins1DelCode":"AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE) {",
        "ins1PreCode":"public void setFutureCancel() { AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE) { private static final long serialVersionUID = 208585707945686116L; };",
        "ins2PreCode":"public void setFutureCancelSameThread() { AbstractDirectTask task = new AbstractDirectTask(Functions.EMPTY_RUNNABLE) { private static final long serialVersionUID = 208585707945686116L; };",
        "label":1
    },
    {
        "ins1AddCode":"initRepoSession( configuration );",
        "ins1DelCode":"",
        "ins1PreCode":"configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) ); configuration.setProcessPlugins( false ); configuration.setResolveDependencies( true );  try {",
        "ins2PreCode":"configuration.setRemoteRepositories( Arrays.asList( new ArtifactRepository[] {} ) ); configuration.setProcessPlugins( false ); configuration.setResolveDependencies( true ); try {",
        "label":1
    },
    {
        "ins1AddCode":"public static void cleanDirectory(final File directory) throws IOException { final String message = directory + \" does not exist\"; final String message = directory + \" is not a directory\"; final File[] files = directory.listFiles();",
        "ins1DelCode":"public static void cleanDirectory(File directory) throws IOException { String message = directory + \" does not exist\"; String message = directory + \" is not a directory\"; File[] files = directory.listFiles();",
        "ins1PreCode":"public static void cleanDirectory(File directory) throws IOException { if (!directory.exists()) { String message = directory + \" does not exist\"; throw new IllegalArgumentException(message); }  if (!directory.isDirectory()) { String message = directory + \" is not a directory\"; throw new IllegalArgumentException(message); }  File[] files = directory.listFiles(); if (files == null) { throw new IOException(\"Failed to list contents of \" + directory);",
        "ins2PreCode":"private static void cleanDirectoryOnExit(File directory) throws IOException { if (!directory.exists()) { String message = directory + \" does not exist\"; throw new IllegalArgumentException(message); } if (!directory.isDirectory()) { String message = directory + \" is not a directory\"; throw new IllegalArgumentException(message); } File[] files = directory.listFiles(); if (files == null) { throw new IOException(\"Failed to list contents of \" + directory);",
        "label":0
    },
    {
        "ins1AddCode":"long waitTime = 0; waitTime = System.currentTimeMillis(); waitTime = System.currentTimeMillis() - waitTime; updateStatsBorrow(p, waitTime);",
        "ins1DelCode":"long waitTime = System.currentTimeMillis(); updateStatsBorrow(p, System.currentTimeMillis() - waitTime);",
        "ins1PreCode":"boolean blockWhenExhausted = getBlockWhenExhausted();  boolean create; long waitTime = System.currentTimeMillis();  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } }  updateStatsBorrow(p, System.currentTimeMillis() - waitTime);  return p.getObject();",
        "ins2PreCode":"boolean blockWhenExhausted = getBlockWhenExhausted(); boolean create; long waitTime = System.currentTimeMillis(); while (p == null) { create = false; if (blockWhenExhausted) { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = objectDeque.getIdleObjects().takeFirst(); } else { if (borrowMaxWaitMillis < 0) { borrowMaxWaitMillis, TimeUnit.MILLISECONDS); } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } } if (p != null) { try { factory.activateObject(key, p); } catch (Exception e) { try { destroy(key, p, true); } catch (Exception e1) { } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(key, p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(key, p, true); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) { } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } } updateStatsBorrow(p, System.currentTimeMillis() - waitTime); return p.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"SecurityFilterChain configure(HttpSecurity http) throws Exception { return http.build();",
        "ins1DelCode":"protected void configure(HttpSecurity http) throws Exception {",
        "ins1PreCode":"protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests((requests) -> { requests.requestMatchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();",
        "ins2PreCode":"protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests((requests) -> { requests.antMatchers(\"/css/**\").permitAll();",
        "label":1
    },
    {
        "ins1AddCode":"final String toDir = buildRule.getProject().getProperty(\"to.dir\"); assertTrue(new File(toDir + \"/file1.txt\").exists()); assertTrue(new File(toDir + \"/file2.txt\").exists()); assertTrue(new File(toDir + \"/file3.txt\").exists());",
        "ins1DelCode":"File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "ins1PreCode":"public void testFileResourcePlain() { buildRule.executeTarget(\"testFileResourcePlain\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "ins2PreCode":"public void testPathAsResource() { buildRule.executeTarget(\"testPathAsResource\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "label":1
    },
    {
        "ins1AddCode":"new ChooseSqlNode(new ArrayList<SqlNode>() {{",
        "ins1DelCode":"new ChooseSqlNode(new ArrayList() {{",
        "ins1PreCode":"final String expected = \"SELECT * FROM BLOG WHERE CATEGORY = 'DEFAULT'\"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = ?\")), \"false\" ));",
        "ins2PreCode":"final String expected = \"SELECT * FROM BLOG WHERE CATEGORY = ?\"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = 'NONE'\")), \"false\" ));",
        "label":1
    },
    {
        "ins1AddCode":"fireTreeNodesInserted(this, path, childIndices, children);",
        "ins1DelCode":"fireNodesInserted(path, childIndices, children);",
        "ins1PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesInserted(path, childIndices, children); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION));",
        "ins1DelCode":"TextFlow description = createDescription(query, true, true);",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, true);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false); TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "label":0
    },
    {
        "ins1AddCode":"final MemoryConsumer c = new TestMemoryConsumer(memoryManager, MemoryMode.ON_HEAP); final MemoryBlock page0 = memoryManager.allocatePage(128, c); final MemoryBlock page1 = memoryManager.allocatePage(128, c);",
        "ins1DelCode":"final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null);",
        "ins1PreCode":"final SparkConf conf = new SparkConf().set(\"spark.memory.offHeap.enabled\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1, page1.getBaseOffset() + 42);",
        "ins2PreCode":".set(\"spark.memory.offHeap.enabled\", \"true\") final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1, page1.getBaseOffset() + 42);",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<Tuple2<Integer, Integer>> sortedRDD = rdd.sortBy(Tuple2::_1, true, 2); sortedRDD = rdd.sortBy(Tuple2::_2, true, 2);",
        "ins1DelCode":"JavaRDD<Tuple2<Integer, Integer>> sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._1(); } }, true, 2); sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._2(); } }, true, 2);",
        "ins1PreCode":"JavaRDD<Tuple2<Integer, Integer>> rdd = sc.parallelize(pairs);   JavaRDD<Tuple2<Integer, Integer>> sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._1(); } }, true, 2);  assertEquals(new Tuple2<>(-1, 1), sortedRDD.first()); List<Tuple2<Integer, Integer>> sortedPairs = sortedRDD.collect(); assertEquals(new Tuple2<>(0, 4), sortedPairs.get(1)); assertEquals(new Tuple2<>(3, 2), sortedPairs.get(2));   sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { @Override public Integer call(Tuple2<Integer, Integer> t) { return t._2(); } }, true, 2); assertEquals(new Tuple2<>(-1, 1), sortedRDD.first()); sortedPairs = sortedRDD.collect();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(dataset, \"dataset\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(dataset, \"dataset\");",
        "ins1PreCode":"public static Number findMinimumStackedRangeValue(CategoryDataset dataset) { ParamChecks.nullNotPermitted(dataset, \"dataset\"); Number result = null; boolean hasValidData = false;",
        "ins2PreCode":"public static Number findMaximumStackedRangeValue(CategoryDataset dataset) { ParamChecks.nullNotPermitted(dataset, \"dataset\"); Number result = null; boolean hasValidData = false;",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty()); a.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty()); a.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void ambRace() { TestObserver<Void> to = new TestObserver<Void>(); to.onSubscribe(Disposables.empty());  CompositeDisposable cd = new CompositeDisposable(); AtomicBoolean once = new AtomicBoolean(); Amb a = new Amb(once, cd, to); a.onSubscribe(Disposables.empty());  a.onComplete();",
        "ins2PreCode":"public void ambRace() { TestObserver<Void> to = new TestObserver<Void>(); to.onSubscribe(Disposables.empty()); CompositeDisposable cd = new CompositeDisposable(); AtomicBoolean once = new AtomicBoolean(); TimeOutObserver a = new TimeOutObserver(cd, once, to); to.onSubscribe(Disposables.empty()); a.onComplete();",
        "label":0
    },
    {
        "ins1AddCode":"if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { Color newColor = getCurrentEditorConnectionColor();",
        "ins1DelCode":"if (widget == null) { Color newColor = getCurrentConnectionColor();",
        "ins1PreCode":"throws Exception {  Widget widget = SWTElementHelpers.getWidget(element); if (widget == null) { return false; }  Color newColor = getCurrentConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) { CTabFolder nativeWidget = (CTabFolder) ((CTabFolderElement) element).getNativeWidget();",
        "ins2PreCode":"return false; Widget widget = SWTElementHelpers.getWidget(element); if (widget == null) { return false; } Color newColor = CustomSelectedTabFillHandler.getCurrentConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) { CTabFolder nativeWidget = (CTabFolder) ((CTabFolderElement) element).getNativeWidget();",
        "label":1
    },
    {
        "ins1AddCode":".take(3)",
        "ins1DelCode":".limit(3)",
        "ins1PreCode":"return Maybe.just(v); } }) .limit(3) .test() .assertResult(1, 2, 3);",
        "ins2PreCode":"return Maybe.just(v); } }) .take(3) .test() .assertResult(1, 2, 3);",
        "label":0
    },
    {
        "ins1AddCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop());",
        "ins1DelCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap());",
        "ins1PreCode":"public void testCreateWithInvalidPattern() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap()); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\");",
        "ins2PreCode":"public void testCreateWithInvalidPatternDefinition() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap()); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\");",
        "label":1
    },
    {
        "ins1AddCode":"XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"S1\"); XYIntervalSeries<String> s2 = new XYIntervalSeries(\"S2\"); XYIntervalSeriesCollection<String> dataset = new XYIntervalSeriesCollection<>();",
        "ins1DelCode":"XYIntervalSeries s1 = new XYIntervalSeries(\"S1\"); XYIntervalSeries s2 = new XYIntervalSeries(\"S2\"); XYIntervalSeriesCollection dataset = new XYIntervalSeriesCollection();",
        "ins1PreCode":"public void testFindDomainBounds2() { XYIntervalSeries s1 = new XYIntervalSeries(\"S1\"); s1.add(1.0, 0.5, 1.5, 10.0, 9.5, 10.5); s1.add(2.0, 1.9, 2.1, 20.0, 19.8, 20.3); XYIntervalSeries s2 = new XYIntervalSeries(\"S2\"); s2.add(3.0, 2.5, 3.5, 30.0, 29.5, 30.5); s2.add(4.0, 3.9, 4.1, 9.0, 9.0, 9.0); XYIntervalSeriesCollection dataset = new XYIntervalSeriesCollection(); dataset.addSeries(s1); dataset.addSeries(s2);",
        "ins2PreCode":"public void testFindRangeBounds2() { XYIntervalSeries s1 = new XYIntervalSeries(\"S1\"); s1.add(1.0, 0.5, 1.5, 10.0, 9.5, 10.5); s1.add(2.0, 1.9, 2.1, 20.0, 19.8, 20.3); XYIntervalSeries s2 = new XYIntervalSeries(\"S2\"); s2.add(3.0, 2.5, 3.5, 30.0, 29.5, 30.5); s2.add(4.0, 3.9, 4.1, 9.0, 9.0, 9.0); XYIntervalSeriesCollection dataset = new XYIntervalSeriesCollection(); dataset.addSeries(s1); dataset.addSeries(s2);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(match()).isTrue();",
        "ins1DelCode":"assertThat(match(EndpointId.of(\"baz\"))).isTrue();",
        "ins1PreCode":"environment.setProperty(\"foo.include\", \"bar\"); environment.setProperty(\"foo.exclude\", \"\"); this.filter = new IncludeExcludeEndpointFilter<>(DifferentTestExposableWebEndpoint.class, environment, \"foo\"); assertThat(match(EndpointId.of(\"baz\"))).isTrue();",
        "ins2PreCode":"environment.setProperty(\"foo.include\", \"bar\"); environment.setProperty(\"foo.exclude\", \"\"); this.filter = new ExposeExcludePropertyEndpointFilter<>(DifferentTestExposableWebEndpoint.class, environment, assertThat(match(EndpointId.of(\"baz\"))).isTrue();",
        "label":0
    },
    {
        "ins1AddCode":"}, false, 2)",
        "ins1DelCode":"}, 2, false)",
        "ins1PreCode":"} }); } }, 2, false) .test() .assertFailure(NullPointerException.class, 1, 2, 3);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"new WrapStream(),",
        "ins1DelCode":"new CompressStream(),",
        "ins1PreCode":"(File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4],",
        "ins2PreCode":"(File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4],",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicInteger counter = new AtomicInteger(0); ReceiverBase rb1 = (ReceiverBase)channel1.getChannelReceiver(); ReceiverBase rb2 = (ReceiverBase)channel2.getChannelReceiver(); rb1.setUdpRxBufSize(1024*1024*10); rb2.setUdpRxBufSize(1024*1024*10); rb1.setUdpTxBufSize(1024*1024*10); rb2.setUdpTxBufSize(1024*1024*10); System.err.println(\"Starting NO_ACK\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) { int cnt = counter.getAndAdd(1); channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024,cnt),Channel.SEND_OPTIONS_UDP|Channel.SEND_OPTIONS_ASYNCHRONOUS); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished NO_ACK [\"+listener1.count+\"]\"); System.out.println(\"Sent \"+counter.get()+ \" messages. Received \"+listener1.count+\" Highest msg received:\"+listener1.maxIdx); System.out.print(\"Missing messages:\"); printMissingMsgs(listener1.nrs,counter.get()); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins1DelCode":"System.err.println(\"Starting ASYNC MULTI THREAD\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_UDP); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();} long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins1PreCode":"public void testDataSendASYNCM() throws Exception { System.err.println(\"Starting ASYNC MULTI THREAD\"); Thread[] threads = new Thread[threadCount]; for (int x=0; x<threads.length; x++ ) { threads[x] = new Thread() { public void run() { try { long start = System.currentTimeMillis(); for (int i = 0; i < msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)}, Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_UDP); System.out.println(\"Thread[\"+this.getName()+\"] sent \"+msgCount+\" messages in \"+(System.currentTimeMillis()-start)+\" ms.\"); }catch ( Exception x ) { x.printStackTrace(); return; } finally { threadCounter++; } } }; } for (int x=0; x<threads.length; x++ ) { threads[x].start();} for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count.get()) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count.get());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(\"Cookie name fail\", res.toString());",
        "ins1DelCode":"assertEquals(\"Cookie name ok\", res.toString());",
        "ins1PreCode":"public void testCookiesInstance() throws Exception {  System.setProperty(\"org.apache.catalina.STRICT_SERVLET_COMPLIANCE\", \"true\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.FWD_SLASH_IS_SEPARATOR\", \"false\");  Tomcat tomcat = getTomcatInstance();  addServlets(tomcat);  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); ",
        "ins2PreCode":"public void testCookiesInstance() throws Exception { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); tomcat.start(); assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); addServlets(tomcat); Tomcat tomcat = getTomcatInstance(); addServlets(tomcat); tomcat.start(); ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name ok\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());",
        "label":1
    },
    {
        "ins1AddCode":".hasSingleBean(LivenessStateHealthIndicator.class).hasBean(\"livenessStateHealthIndicator\") .hasSingleBean(ReadinessStateHealthIndicator.class).hasBean(\"readinessStateHealthIndicator\")",
        "ins1DelCode":".hasSingleBean(LivenessStateHealthIndicator.class) .hasSingleBean(ReadinessStateHealthIndicator.class)",
        "ins1PreCode":"void probesWhenKubernetesAddsBeans() { this.contextRunner.withPropertyValues(\"spring.main.cloud-platform=kubernetes\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class) .hasSingleBean(ReadinessStateHealthIndicator.class) .hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class));",
        "ins2PreCode":"void probesWhenPropertyEnabledAddsBeans() { this.contextRunner.withPropertyValues(\"management.endpoint.health.probes.enabled=true\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class) .hasSingleBean(ReadinessStateHealthIndicator.class) .hasSingleBean(AvailabilityProbesHealthEndpointGroupsPostProcessor.class));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Files.readString(testBibtexFile, encoding), stringWriter.toString());",
        "ins1DelCode":"try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins1PreCode":"new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins2PreCode":"new Defaults(BibDatabaseMode.BIBTEX)); databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "label":1
    },
    {
        "ins1AddCode":"HighLowRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"HighLowRenderer r2 = (HighLowRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { HighLowRenderer r1 = new HighLowRenderer(); r1.setCloseTickPaint(Color.green); HighLowRenderer r2 = (HighLowRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return anchor.getAnchorPoint(anchorRect);",
        "ins1DelCode":"return RectangleAnchor.coordinates(anchorRect, anchor);",
        "ins1PreCode":"anchorRect = markerOffset.createAdjustedRectangle(markerArea, LengthAdjustmentType.CONTRACT, labelOffsetType); } return RectangleAnchor.coordinates(anchorRect, anchor); ",
        "ins2PreCode":"anchorRect = markerOffset.createAdjustedRectangle(markerArea, LengthAdjustmentType.CONTRACT, labelOffsetForRange); } return RectangleAnchor.coordinates(anchorRect, anchor);",
        "label":1
    },
    {
        "ins1AddCode":"writer.write(\"  - \\\"BOOT-INF/lib/c.jar\\\"\\n\");",
        "ins1DelCode":"writer.write(\"  - \\\"0002 BOOT-INF/lib/c.jar\\\"\\n\");",
        "ins1PreCode":"writer.write(\"  - \\\"BOOT-INF/lib/a.jar\\\"\\n\"); writer.write(\"  - \\\"BOOT-INF/lib/b.jar\\\"\\n\"); writer.write(\"- \\\"0002\\\":\\n\"); writer.write(\"  - \\\"0002 BOOT-INF/lib/c.jar\\\"\\n\"); writer.write(\"- \\\"0003\\\":\\n\"); writer.write(\"  - \\\"BOOT-INF/lib/d.jar\\\"\\n\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"separator\", \"\\\\.\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"separator\", \"-\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch (ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"if (isInvalidName()) { throw new IOException(\"Invalid label\"); }",
        "ins1DelCode":"",
        "ins1PreCode":"public void save() throws IOException { if(BulkChange.contains(this))   return; try { getConfigFile().write(this); SaveableListener.fireOnChange(this, getConfigFile());",
        "ins2PreCode":"} catch (IOException e) { if(BulkChange.contains(this))   return; try { getConfigFile().write(this); SaveableListener.fireOnChange(this, getConfigFile());",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 43; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 36; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> receivedException = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> receivedException = new AtomicReference<Throwable>();",
        "ins1PreCode":"public void resumeNextWithAsyncExecution() { final AtomicReference<Throwable> receivedException = new AtomicReference<Throwable>(); Subscription s = mock(Subscription.class); TestFlowable w = new TestFlowable(s, \"one\");",
        "ins2PreCode":"public void resumeNextWithAsyncExecution() { final AtomicReference<Throwable> receivedException = new AtomicReference<Throwable>(); Subscription s = mock(Subscription.class); TestObservable w = new TestObservable(s, \"one\");",
        "label":1
    },
    {
        "ins1AddCode":"super(actual, new MpscLinkedQueue<>()); this.buffers = new LinkedList<>();",
        "ins1DelCode":"super(actual, new MpscLinkedQueue<U>()); this.buffers = new LinkedList<U>();",
        "ins1PreCode":"BufferSkipBoundedObserver(Observer<? super U> actual, Supplier<U> bufferSupplier, long timespan, long timeskip, TimeUnit unit, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan; this.timeskip = timeskip; this.unit = unit; this.w = w; this.buffers = new LinkedList<U>();",
        "ins2PreCode":"BufferSkipBoundedSubscriber(Subscriber<? super U> actual, Supplier<U> bufferSupplier, long timespan, long timeskip, TimeUnit unit, Worker w) { super(actual, new MpscLinkedQueue<U>()); this.bufferSupplier = bufferSupplier; this.timespan = timespan; this.timeskip = timeskip; this.unit = unit; this.w = w; this.buffers = new LinkedList<U>();",
        "label":1
    },
    {
        "ins1AddCode":"currentPathElement = findPathElementCaseInsensitive(this.curpwd,",
        "ins1DelCode":"currentPathElement = findPathElementCaseUnsensitive(this.curpwd,",
        "ins1PreCode":"if (!this.client.changeWorkingDirectory(currentPathElement)) { if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { currentPathElement = findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) {",
        "ins2PreCode":".changeWorkingDirectory(currentPathElement)) { if (!isCaseSensitive() && (remoteSystemCaseSensitive || !remoteSensitivityChecked)) { findPathElementCaseUnsensitive(this.curpwd, currentPathElement); if (currentPathElement == null) {",
        "label":1
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> dataset0 = new DefaultCategoryDataset<>(); DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>();",
        "ins1DelCode":"DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset();",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "label":1
    },
    {
        "ins1AddCode":"}",
        "ins1DelCode":"}}",
        "ins1PreCode":"Assert.fail(\"Bounded Replay Leak check: Memory leak detected: \" + (initial / 1024.0 / 1024.0) + \" -> \" + after.get() / 1024.0 / 1024.0); }",
        "ins2PreCode":"Assert.fail(\"Bounded Replay Leak check: Memory leak detected: \" + (initial / 1024.0 / 1024.0) + \" -> \" + after.get() / 1024.0 / 1024.0); }",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<?> plot = (XYPlot) chart.getPlot();",
        "ins1DelCode":"XYPlot<String> plot = (XYPlot) chart.getPlot();",
        "ins1PreCode":"dataset.addSeries(series); JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<String> plot = (XYPlot) chart.getPlot(); LogAxis axis = new LogAxis(\"Log(Y)\"); plot.setRangeAxis(axis);",
        "ins2PreCode":"dataset.addSeries(series); JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\", dataset); XYPlot<String> plot = (XYPlot) chart.getPlot(); LogAxis axis = new LogAxis(\"Log(Y)\"); plot.setRangeAxis(axis);",
        "label":1
    },
    {
        "ins1AddCode":"checkNotNull(message);",
        "ins1DelCode":"if (message == null) { throw new NullPointerException(); }",
        "ins1PreCode":"public RepeatedFieldBuilderV3<MType, BType, IType> setMessage( int index, MType message) { if (message == null) { throw new NullPointerException(); } ensureMutableMessageList();",
        "ins2PreCode":"public RepeatedFieldBuilder<MType, BType, IType> setMessage( int index, MType message) { if (message == null) { throw new NullPointerException(); } ensureMutableMessageList();",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, View.READ, Item.READ, View.CONFIGURE)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE)",
        "ins1PreCode":"assertThat(j.jenkins.getView(\"aView\").contains(project), equalTo(true));  final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\"); ",
        "ins2PreCode":"assertThat(j.jenkins.getView(\"aView\").contains(project), equalTo(true)); final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, View.READ, Job.READ, View.CONFIGURE) .invokeWithArgs(\"aView\", \"aProject\");",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateTShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateTShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"val\");",
        "ins1DelCode":"entry.setField(\"field\", \"val\");",
        "ins1PreCode":"public void completeShortStringReturnsFieldValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"val\"); autoCompleter.indexEntry(entry); ",
        "ins2PreCode":"public void completeShortStringReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"val\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable bs = Disposable.empty();",
        "ins1DelCode":"final Disposable bs = Disposables.empty();",
        "ins1PreCode":" TestObserver<Integer> to = s.test();  final Disposable bs = Disposables.empty();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"TestObserver<Integer> to = s.test(); final Disposable bs = Disposables.empty(); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"TimeSeries<String> ts = new TimeSeries<>(\"Time Series\");",
        "ins1DelCode":"TimeSeries ts = new TimeSeries(\"Time Series\");",
        "ins1PreCode":"public void testGetMinY2() { TimeSeries ts = new TimeSeries(\"Time Series\"); assertTrue(Double.isNaN(ts.getMinY())); ",
        "ins2PreCode":"public void testGetMaxY2() { TimeSeries ts = new TimeSeries(\"Time Series\"); assertTrue(Double.isNaN(ts.getMaxY()));",
        "label":1
    },
    {
        "ins1AddCode":"DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<>(s);",
        "ins1DelCode":"DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s);",
        "ins1PreCode":"public void subscribeActual(Subscriber<? super T> s) { DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s); s.onSubscribe(deferred); ",
        "ins2PreCode":"public void subscribeActual(Subscriber<? super T> s) { DeferredScalarSubscription<T> deferred = new DeferredScalarSubscription<T>(s); s.onSubscribe(deferred);",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(comparator, \"comparator is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(comparator, \"comparator is null\");",
        "ins1PreCode":"public final Flowable<T> sorted(@NonNull Comparator<? super T> comparator, int capacityHint) { ObjectHelper.requireNonNull(comparator, \"comparator is null\"); ObjectHelper.verifyPositive(capacityHint, \"capacityHint\"); int ch = capacityHint / parallelism() + 1;",
        "ins2PreCode":"public final Flowable<List<T>> toSortedList(@NonNull Comparator<? super T> comparator, int capacityHint) { ObjectHelper.requireNonNull(comparator, \"comparator is null\"); ObjectHelper.verifyPositive(capacityHint, \"capacityHint\"); int ch = capacityHint / parallelism() + 1;",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldApplyHashMapTypeHandler() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<String, String>(); map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandler(map); Assert.assertNotNull(user); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldApplyHashMapTypeHandlerXml() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); HashMap<String, String> map = new HashMap<String, String>(); map.put(\"name\", \"User1\"); User user = mapper.getUserWithTypeHandlerXml(map); Assert.assertNotNull(user); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"httpServer.setFilters(new LoggingFilter(\"INCOMING\"), new ProtocolCodecFilter<HttpPdu, ByteBuffer, Void, HttpDecoderState>(new HttpServerEncoder(), new HttpServerDecoder()), new LoggingFilter(\"DECODED\"), new DummyHttpSever());",
        "ins1DelCode":"httpServer.setFilters(new LoggingFilter(\"INCOMING\"), new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new LoggingFilter(\"DECODED\"), new DummyHttpSever());",
        "ins1PreCode":" NioTcpServer httpServer = new NioTcpServer();  httpServer.setFilters(new LoggingFilter(\"INCOMING\"), new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new LoggingFilter(\"DECODED\"), new DummyHttpSever());  httpServer.getSessionConfig().setTcpNoDelay(true);",
        "ins2PreCode":"NioTcpServer httpServer = new NioTcpServer(); httpServer.setFilters(new LoggingFilter(\"INCOMING\"), new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new LoggingFilter(\"DECODED\"), new DummyHttpSever()); httpServer.getSessionConfig().setTcpNoDelay(true);",
        "label":1
    },
    {
        "ins1AddCode":"XYDataItem removed = this.data.remove(0);",
        "ins1DelCode":"XYDataItem removed = (XYDataItem) this.data.remove(0);",
        "ins1PreCode":"} updateBoundsForAddedItem(item); if (getItemCount() > this.maximumItemCount) { XYDataItem removed = (XYDataItem) this.data.remove(0); updateBoundsForRemovedItem(removed); }",
        "ins2PreCode":"} this.data.add(item); if (getItemCount() > this.maximumItemCount) { this.data.remove(0); this.data.remove(0); }",
        "label":0
    },
    {
        "ins1AddCode":"TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol<?>>[] customizers = new TomcatProtocolHandlerCustomizer[4];",
        "ins1DelCode":"TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4];",
        "ins1PreCode":"public void tomcatProtocolHandlerCustomizersShouldBeInvoked() { TomcatReactiveWebServerFactory factory = getFactory(); HttpHandler handler = mock(HttpHandler.class); TomcatProtocolHandlerCustomizer<AbstractHttp11Protocol>[] customizers = new TomcatProtocolHandlerCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(TomcatProtocolHandlerCustomizer.class)); factory.setTomcatProtocolHandlerCustomizers(",
        "ins2PreCode":"public void builderCustomizersShouldBeInvoked() { UndertowReactiveWebServerFactory factory = getFactory(); HttpHandler handler = mock(HttpHandler.class); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4]; Arrays.setAll(customizers, (i) -> mock(UndertowBuilderCustomizer.class)); factory.addBuilderCustomizers(customizers[2], customizers[3]);",
        "label":0
    },
    {
        "ins1AddCode":"ListSet<Poster> allPosters = Designer.theDesigner().getToDoList().getPosters(); synchronized (allPosters) { for (Poster p : allPosters) { path[1] = p; int nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) { continue; } nMatchingItems++; } if (nMatchingItems == 0) { continue; } int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) { continue; } childIndices[nMatchingItems] = getIndexOfChild(p, item); children[nMatchingItems] = item; nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); } }",
        "ins1DelCode":"for (Poster p : Designer.theDesigner().getToDoList().getPosters()) { path[1] = p; int nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) continue; nMatchingItems++; } if (nMatchingItems == 0) continue; int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) continue; childIndices[nMatchingItems] = getIndexOfChild(p, item); children[nMatchingItems] = item; nMatchingItems++; } fireTreeNodesChanged(this, path, childIndices, children); }",
        "ins1PreCode":"Object[] path = new Object[2]; path[0] = Designer.theDesigner().getToDoList();  for (Poster p : Designer.theDesigner().getToDoList().getPosters()) { path[1] = p; int nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) continue; nMatchingItems++; } if (nMatchingItems == 0) continue; int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) continue; childIndices[nMatchingItems] = getIndexOfChild(p, item); children[nMatchingItems] = item;",
        "ins2PreCode":"Object[] path = new Object[2]; path[0] = Designer.theDesigner().getToDoList(); for (Poster p : Designer.theDesigner().getToDoList().getPosters()) { path[1] = p; int nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) continue; nMatchingItems++; } if (nMatchingItems == 0) continue; int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : items) { Poster post = item.getPoster(); if (post != p) continue; childIndices[nMatchingItems] = getIndexOfChild(p, item); children[nMatchingItems] = item;",
        "label":1
    },
    {
        "ins1AddCode":"UnittestNoGenericServices.TestMessage.newBuilder() .setA(123) .setExtension(UnittestNoGenericServices.testExtension, 456) .build(); String outerName = \"google.protobuf.no_generic_services_test.UnittestNoGenericServices\"; if (!Service.class.isAssignableFrom(innerClass) && !Message.class.isAssignableFrom(innerClass) && !ProtocolMessageEnum.class.isAssignableFrom(innerClass)) { assertEquals(\"Foo\", file.getServices().get(0).getMethods().get(0).getName());",
        "ins1DelCode":"UnittestNoGenericServices.TestMessage.newBuilder() .setA(123) .setExtension(UnittestNoGenericServices.testExtension, 456) .build(); String outerName = \"google.protobuf.no_generic_services_test.\" + \"UnittestNoGenericServices\"; if (!Service.class.isAssignableFrom(innerClass) && !Message.class.isAssignableFrom(innerClass) && !ProtocolMessageEnum.class.isAssignableFrom(innerClass)) { assertEquals(\"Foo\", file.getServices().get(0).getMethods().get(0).getName());",
        "ins1PreCode":"assertEquals(1, UnittestNoGenericServices.TestEnum.FOO.getNumber());   String outerName = \"google.protobuf.no_generic_services_test.\" + \"UnittestNoGenericServices\"; Class<?> outerClass = Class.forName(outerName);  Set<String> innerClassNames = new HashSet<String>(); for (Class<?> innerClass : outerClass.getClasses()) { String fullName = innerClass.getName();       assertTrue(fullName.startsWith(outerName));  if (!Service.class.isAssignableFrom(innerClass) && !Message.class.isAssignableFrom(innerClass) && !ProtocolMessageEnum.class.isAssignableFrom(innerClass)) {  continue; }  innerClassNames.add(fullName.substring(outerName.length() + 1)); }   assertTrue(innerClassNames.contains(\"TestMessage\")); assertTrue(innerClassNames.contains(\"TestEnum\")); assertFalse(innerClassNames.contains(\"TestService\"));   FileDescriptor file = UnittestNoGenericServices.getDescriptor(); assertEquals(1, file.getServices().size()); assertEquals(\"TestService\", file.getServices().get(0).getName()); assertEquals(1, file.getServices().get(0).getMethods().size()); assertEquals(\"Foo\", file.getServices().get(0).getMethods().get(0).getName());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void movesFile() { Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", Path.of(\"test.pdf\"), \"\"))),",
        "ins1DelCode":"void movesFile() throws Exception { Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"test.pdf\", \"\"))),",
        "ins1PreCode":"void movesFile() throws Exception { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"\"); cleanup.cleanup(entry);  Path fileAfter = defaultFileFolder.resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"test.pdf\", \"\"))), entry.getField(StandardField.FILE)); assertFalse(Files.exists(fileBefore));",
        "ins2PreCode":"void doesNotMoveFileWithEmptyFileDirPattern() throws Exception { when(filePreferences.getFileDirectoryPattern()).thenReturn(\"\"); cleanup.cleanup(entry); Path fileAfter = defaultFileFolder.resolve(\"test.pdf\"); assertEquals( Optional.of(FileFieldWriter.getStringRepresentation(new LinkedFile(\"\", \"test.pdf\", \"\"))), entry.getField(StandardField.FILE)); assertFalse(Files.exists(fileBefore));",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Item.READ, Item.DELETE, Jenkins.READ)",
        "ins1DelCode":".authorizedTo(Job.READ, Job.DELETE, Jenkins.READ)",
        "ins1PreCode":"j.createFreeStyleProject(\"aProject2\");  final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.DELETE, Jenkins.READ) .invokeWithArgs(\"never_created\", \"aProject1\", \"aProject2\"); ",
        "ins2PreCode":"j.createFreeStyleProject(\"aProject2\"); final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Job.DELETE, Jenkins.READ) .invokeWithArgs(\"aProject1\",\"never_created\", \"aProject2\");",
        "label":1
    },
    {
        "ins1AddCode":"void shouldTrimWHEREANDWithTABForFirstCondition() throws Exception {",
        "ins1DelCode":"public void shouldTrimWHEREANDWithTABForFirstCondition() throws Exception {",
        "ins1PreCode":"public void shouldTrimWHEREANDWithTABForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\t ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimWHEREORWithLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\n ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"ClientEndpointConfigurationBuilder.create().build(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins1DelCode":"new DefaultClientConfiguration(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins1PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, new DefaultClientConfiguration(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins2PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, new DefaultClientConfiguration(), new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);",
        "ins1DelCode":"final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);",
        "ins1PreCode":"final Integer[] a = new Integer[1000]; Arrays.fill(a, 1);  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);  Single.just(1)",
        "ins2PreCode":"final Integer[] a = new Integer[1000]; Arrays.fill(a, 1); final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); Maybe.just(1)",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":" @Override public List<Integer> get() { return new ArrayList<Integer>(); } ",
        "ins2PreCode":"@Override public List<Integer> get() { return new ArrayList<Integer>(); }",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.SEVERE, \"No namespace as argument {0}\",namespace);",
        "ins1DelCode":"LOG.error(\"No namespace as argument\"); LOG.error(namespace);",
        "ins1PreCode":"public ArgoDiagram createDiagram(Object namespace) { if (!Model.getFacade().isANamespace(namespace)) { LOG.error(\"No namespace as argument\"); LOG.error(namespace); throw new IllegalArgumentException( \"The argument \" + namespace + \"is not a namespace.\");",
        "ins2PreCode":"public ArgoDiagram createDiagram(Object namespace, if (!Model.getFacade().isANamespace(namespace)) { LOG.error(\"No namespace as argument\"); LOG.error(namespace); throw new IllegalArgumentException( \"The argument \" + namespace + \"is not a namespace.\");",
        "label":1
    },
    {
        "ins1AddCode":"Range r = DatasetUtils.findDomainBounds(dataset, false);",
        "ins1DelCode":"Range r = DatasetUtilities.findDomainBounds(dataset, false);",
        "ins1PreCode":"if (dataset == null) { return null; } Range r = DatasetUtilities.findDomainBounds(dataset, false); if (r == null) { return null;",
        "ins2PreCode":"if (dataset == null) { return null; } Range r = DatasetUtilities.findRangeBounds(dataset, false); if (r == null) { return null;",
        "label":1
    },
    {
        "ins1AddCode":"public void disabled() {",
        "ins1DelCode":"public void disabled() throws Exception {",
        "ins1PreCode":"public void disabled() throws Exception { SpringApplication application = new SpringApplication(Config.class); application.setWebApplicationType(WebApplicationType.NONE);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".take(3)",
        "ins1DelCode":".limit(3)",
        "ins1PreCode":"return Single.just(v); } }) .limit(3) .test() .assertResult(1, 2, 3);",
        "ins2PreCode":"return Single.just(v); } }) .take(3) .test() .assertResult(1, 2, 3);",
        "label":0
    },
    {
        "ins1AddCode":"itemTimeoutObservableSource = Objects.requireNonNull(",
        "ins1DelCode":"itemTimeoutObservableSource = ObjectHelper.requireNonNull(",
        "ins1PreCode":"ObservableSource<?> itemTimeoutObservableSource;  try { itemTimeoutObservableSource = ObjectHelper.requireNonNull( itemTimeoutIndicator.apply(t), \"The itemTimeoutIndicator returned a null ObservableSource.\");",
        "ins2PreCode":"ObservableSource<?> itemTimeoutObservableSource; try { itemTimeoutObservableSource = ObjectHelper.requireNonNull( itemTimeoutIndicator.apply(t), \"The itemTimeoutIndicator returned a null ObservableSource.\");",
        "label":1
    },
    {
        "ins1AddCode":"Disposable sub1 = Disposable.empty(); Disposable sub2 = Disposable.empty();",
        "ins1DelCode":"Disposable sub1 = Disposables.empty(); Disposable sub2 = Disposables.empty();",
        "ins1PreCode":"} };  Disposable sub1 = Disposables.empty();  consumer.onSubscribe(sub1);  assertFalse(sub1.isDisposed());  Disposable sub2 = Disposables.empty();  consumer.onSubscribe(sub2);",
        "ins2PreCode":"} }; Disposable sub1 = Disposables.empty(); consumer.onSubscribe(sub1); assertFalse(sub1.isDisposed()); Disposable sub2 = Disposables.empty(); consumer.onSubscribe(sub2);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(200, sc);",
        "ins1DelCode":"assertEquals(200, sc);",
        "ins1PreCode":"new HashMap<String,List<String>>());   assertEquals(200, sc); assertEcho(res.toString(), \"Hello World\");",
        "ins2PreCode":"new HashMap<String,List<String>>()); assertEquals(200, sc); assertEcho(res.toString(), \"OK\");",
        "label":1
    },
    {
        "ins1AddCode":"private void setUpNonLogin() throws Exception { ctxt.setSessionTimeout(LONG_TIMEOUT_MINS); nonloginAuthenticator = new NonLoginAuthenticator(); ctxt.getPipeline().addValve(nonloginAuthenticator);",
        "ins1DelCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception { ctxt.setSessionTimeout(LONG_TIMEOUT_SECS); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "ins1PreCode":"private void setUpNonLogin(Tomcat tomcat) throws Exception {   Context ctxt = tomcat.addContext(CONTEXT_PATH_NOLOGIN, System.getProperty(\"java.io.tmpdir\")); ctxt.setSessionTimeout(LONG_TIMEOUT_SECS);   Tomcat.addServlet(ctxt, \"TesterServlet1\", new TesterServlet()); ctxt.addServletMapping(URI_PROTECTED, \"TesterServlet1\");  SecurityCollection collection1 = new SecurityCollection(); collection1.addPattern(URI_PROTECTED); SecurityConstraint sc1 = new SecurityConstraint(); sc1.addAuthRole(ROLE); sc1.addCollection(collection1); ctxt.addConstraint(sc1);   Tomcat.addServlet(ctxt, \"TesterServlet2\", new TesterServlet()); ctxt.addServletMapping(URI_PUBLIC, \"TesterServlet2\");  SecurityCollection collection2 = new SecurityCollection(); collection2.addPattern(URI_PUBLIC); SecurityConstraint sc2 = new SecurityConstraint();  sc2.addCollection(collection2); ctxt.addConstraint(sc2);   LoginConfig lc = new LoginConfig(); lc.setAuthMethod(\"NONE\"); ctxt.setLoginConfig(lc); ctxt.getPipeline().addValve(new NonLoginAuthenticator());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Request request = new Request(\"PUT\", \"/_kibana/\" + indexName); request = new Request(\"GET\", \"/_kibana/\" + indexName); assertThat(EntityUtils.toString(response.getEntity()), containsString(indexName));",
        "ins1DelCode":"Request request = new Request(\"PUT\", \"/_kibana/.kibana-1\"); request = new Request(\"GET\", \"/_kibana/.kibana-1\"); assertThat(EntityUtils.toString(response.getEntity()), containsString(\".kibana-1\"));",
        "ins1PreCode":"public void testGetIndex() throws IOException { Request request = new Request(\"PUT\", \"/_kibana/.kibana-1\"); Response response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200));  request = new Request(\"GET\", \"/_kibana/.kibana-1\"); response = client().performRequest(request); assertThat(response.getStatusLine().getStatusCode(), is(200)); assertThat(EntityUtils.toString(response.getEntity()), containsString(\".kibana-1\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> merge(",
        "ins1DelCode":"public static <T> Flowable<T> merge(",
        "ins1PreCode":"public static <T> Flowable<T> merge( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4",
        "ins2PreCode":"public static <T> Flowable<T> mergeDelayError( @NonNull MaybeSource<? extends T> source1, @NonNull MaybeSource<? extends T> source2, @NonNull MaybeSource<? extends T> source3, @NonNull MaybeSource<? extends T> source4) {",
        "label":1
    },
    {
        "ins1AddCode":"writer.writeCData(StringUtils.getStackTrace(cause.get()));",
        "ins1DelCode":"",
        "ins1PreCode":"writer.writeAttribute(ATTR_MESSAGE, message); } writer.writeAttribute(ATTR_TYPE, t.getClass().getName()); } writer.writeEndElement();",
        "ins2PreCode":"writer.writeAttribute(ATTR_MESSAGE, message); } writer.writeAttribute(ATTR_TYPE, t.getClass().getName()); } writer.writeEndElement();",
        "label":1
    },
    {
        "ins1AddCode":"if (\"TestAllTypes\".equals(baseDescriptor.getName())) {",
        "ins1DelCode":"if (baseDescriptor.getName() == \"TestAllTypes\") {",
        "ins1PreCode":"this.publicImportFile = importFile.getDependencies().get(0);  Descriptors.Descriptor testAllTypes; if (baseDescriptor.getName() == \"TestAllTypes\") { testAllTypes = baseDescriptor; } else {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void ignoresUnmappedUrl() throws Exception {",
        "ins1DelCode":"public void ignoresUnmappedUrl() throws Exception {",
        "ins1PreCode":"public void ignoresUnmappedUrl() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "ins2PreCode":"public void ignoresIfMissingSecretFromRequest() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class);",
        "label":1
    },
    {
        "ins1AddCode":"protected void insertIntoEntryTable(List<BibEntry> bibEntries) { StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\"); for (int i = 0; i < bibEntries.size() - 1; i++) { insertIntoEntryQuery.append(\", (?)\"); } Statement.RETURN_GENERATED_KEYS)) { for (int i = 0; i < bibEntries.size(); i++) { preparedEntryStatement.setString(i + 1, bibEntries.get(i).getType().getName()); } for (BibEntry bibEntry : bibEntries) { generatedKeys.next(); bibEntry.getSharedBibEntryData().setSharedID(generatedKeys.getInt(1)); } LOGGER.error(\"Error: Some shared IDs left unassigned\");",
        "ins1DelCode":"protected void insertIntoEntryTable(BibEntry bibEntry) { StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\"); Statement.RETURN_GENERATED_KEYS)) { preparedEntryStatement.setString(1, bibEntry.getType().getName()); bibEntry.getSharedBibEntryData().setSharedID(generatedKeys.getInt(1));",
        "ins1PreCode":"protected void insertIntoEntryTable(BibEntry bibEntry) {  StringBuilder insertIntoEntryQuery = new StringBuilder() .append(\"INSERT INTO \") .append(escape(\"ENTRY\")) .append(\"(\") .append(escape(\"TYPE\")) .append(\") VALUES(?)\");   try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery.toString(), Statement.RETURN_GENERATED_KEYS)) {  preparedEntryStatement.setString(1, bibEntry.getType().getName()); preparedEntryStatement.executeUpdate(); ",
        "ins2PreCode":"protected void insertIntoEntryTable(BibEntry bibEntry) { String insertIntoEntryQuery = \"INSERT INTO \" + escape(\"ENTRY\") + escape(\"TYPE\") + escape(\"TYPE\") + \") VALUES(?)\"; try (PreparedStatement preparedEntryStatement = connection.prepareStatement(insertIntoEntryQuery, preparedEntryStatement.executeUpdate(); preparedEntryStatement.setString(1, bibEntry.getType().getName()); preparedEntryStatement.executeUpdate();",
        "label":0
    },
    {
        "ins1AddCode":"CategoryDataset<String, String> newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1DelCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":" Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}};  CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);  LocalListener l = new LocalListener();",
        "ins2PreCode":"Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}}; CategoryDataset newData = DatasetUtils.createCategoryDataset( \"S\", \"C\", data); LocalListener l = new LocalListener();",
        "label":1
    },
    {
        "ins1AddCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { StringBuilder query = new StringBuilder(\"ALTER TABLE \");",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { StringBuilder query = new StringBuilder(\"ALTER TABLE \");",
        "label":1
    },
    {
        "ins1AddCode":"when(rs.getInt(1)).thenReturn(INSTANT.getValue(), 0);",
        "ins1DelCode":"when(rs.getInt(1)).thenReturn(INSTANT.getValue()); when(rs.getInt(1)).thenReturn(0);",
        "ins1PreCode":"public void shouldGetResultFromResultSetByPosition() throws Exception { when(rs.getInt(1)).thenReturn(INSTANT.getValue()); assertEquals(INSTANT, TYPE_HANDLER.getResult(rs, 1));  when(rs.getInt(1)).thenReturn(0); try { TYPE_HANDLER.getResult(rs, 1);",
        "ins2PreCode":"public void shouldGetResultFromCallableStatement() throws Exception { when(cs.getInt(1)).thenReturn(INSTANT.getValue()); assertEquals(INSTANT, TYPE_HANDLER.getResult(cs, 1)); when(cs.getInt(1)).thenReturn(0); try { TYPE_HANDLER.getResult(cs, 1);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd'); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a'); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('h');  assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd', 'a');   assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd', 'a', 'a');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('h'); assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'd'); assertEqualCharNodes(Iterables.limit(result, 2), \"hd\"); assertThat(graph.requestedNodes).containsExactly('h', 'h', 'h', 'd', 'd');",
        "label":0
    },
    {
        "ins1AddCode":"JavaDStream<String> mapped = stream.mapPartitions(in -> { StringBuilder out = new StringBuilder(); while (in.hasNext()) { out.append(in.next().toUpperCase(Locale.ENGLISH)); } return Arrays.asList(out.toString()).iterator(); });",
        "ins1DelCode":"JavaDStream<String> mapped = stream.mapPartitions( new FlatMapFunction<Iterator<String>, String>() { @Override public Iterator<String> call(Iterator<String> in) { StringBuilder out = new StringBuilder(); while (in.hasNext()) { out.append(in.next().toUpperCase(Locale.ENGLISH)); } return Arrays.asList(out.toString()).iterator(); } });",
        "ins1PreCode":"Arrays.asList(\"YANKEESRED SOX\"));  JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> mapped = stream.mapPartitions( new FlatMapFunction<Iterator<String>, String>() { @Override public Iterator<String> call(Iterator<String> in) { StringBuilder out = new StringBuilder(); while (in.hasNext()) {",
        "ins2PreCode":"Arrays.asList(\"YANKEESRED SOX\")); JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> mapped = stream.mapPartitions(in -> { return Lists.newArrayList(out).iterator(); Assert.assertEquals(expected, result); public void testMapPartitions() { String out = \"\"; while (in.hasNext()) {",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1DelCode":"Assert.assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins1PreCode":"autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); Assert.assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"test\"))); Assert.assertEquals(Arrays.asList(\"testValue\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"assertEcho(result, \"03-hello \\\"world\"); assertEcho(result, \"04-hello world\"); assertEcho(result, \"05-hello 'world\"); assertEcho(result, \"06-hello 'world\"); assertEcho(result, \"07-hello \\\"world\"); assertEcho(result, \"08-hello world\"); assertEcho(result, \"09-hello 'world\"); assertEcho(result, \"10-hello \\\"world\"); assertEcho(result, \"14-hello 'world\"); assertEcho(result, \"15-hello \\\"world\");",
        "ins1DelCode":"assertEcho(result, \"03-hello world\"); assertEcho(result, \"04-hello 'world\"); assertEcho(result, \"05-hello \\\"world\"); assertEcho(result, \"06-hello world\"); assertEcho(result, \"07-hello 'world\"); assertEcho(result, \"08-hello \\\"world\"); assertEcho(result, \"09-hello world\"); assertEcho(result, \"10-hello 'world\"); assertEcho(result, \"14-hello \\\"world\"); assertEcho(result, \"15-hello world\"); assertEcho(result, \"16-hello 'world\"); assertEcho(result, \"17-hello \\\"world\");",
        "ins1PreCode":"assertEcho(result, \"00-hello world\"); assertEcho(result, \"01-hello 'world\"); assertEcho(result, \"02-hello \\\"world\"); assertEcho(result, \"03-hello world\"); assertEcho(result, \"04-hello 'world\"); assertEcho(result, \"05-hello \\\"world\"); assertEcho(result, \"06-hello world\"); assertEcho(result, \"07-hello 'world\"); assertEcho(result, \"08-hello \\\"world\"); assertEcho(result, \"09-hello world\"); assertEcho(result, \"10-hello 'world\"); assertEcho(result, \"11-hello \\\"world\"); assertEcho(result, \"12-hello world\"); assertEcho(result, \"13-hello 'world\"); assertEcho(result, \"14-hello \\\"world\"); assertEcho(result, \"15-hello world\"); assertEcho(result, \"16-hello 'world\"); assertEcho(result, \"17-hello \\\"world\");",
        "ins2PreCode":"assertEcho(result, \"00-hello world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"02-hello \\\\\\\"world\"); assertEcho(result, \"03-hello ${world\"); assertEcho(result, \"00-hello world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"06-hello \\\"world\"); assertEcho(result, \"00-hello world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"00-hello world\"); assertEcho(result, \"10-hello <% world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"05-hello world\"); assertEcho(result, \"01-hello \\\"world\"); assertEcho(result, \"01-hello \\\"world\");",
        "label":0
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"dependency-order/w-plugin-mgmt\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"dependency-order/w-plugin-mngt\" );",
        "ins1PreCode":"public void testDependencyOrderWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"dependency-order/w-plugin-mngt\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() ); assertEquals( \"a\", pom.getValue( \"dependencies[1]/artifactId\" ) );",
        "ins2PreCode":"public void testProfileInjectedDependencies() throws Exception { PomTestWrapper pom = buildPom( \"profile-injected-dependencies\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() ); assertEquals( \"a\", pom.getValue( \"dependencies[1]/artifactId\" ) );",
        "label":0
    },
    {
        "ins1AddCode":"AbstractStringProcessor<?> processor = factory.create(null, processorTag, null, modifyConfig(config));",
        "ins1DelCode":"AbstractStringProcessor<?> processor = factory.create(null, processorTag, modifyConfig(config));",
        "ins1PreCode":"config.put(\"field\", fieldName); config.put(\"ignore_missing\", true);  AbstractStringProcessor<?> processor = factory.create(null, processorTag, modifyConfig(config)); assertThat(processor.getTag(), equalTo(processorTag)); assertThat(processor.getField(), equalTo(fieldName));",
        "ins2PreCode":"config.put(\"field\", fieldName); config.put(\"field\", fieldName); AbstractStringProcessor<?> processor = factory.create(null, processorTag, modifyConfig(config)); assertThat(processor.getTag(), equalTo(processorTag)); assertThat(processor.getField(), equalTo(fieldName));",
        "label":1
    },
    {
        "ins1AddCode":"for (InputStream inputStream: inputStreams) { for (int i = 0; i < 1024; i++) { assertEquals(randomBytes[i], (byte) inputStream.read()); } assertEquals(0, inputStream.skip(-1)); assertEquals(0, inputStream.skip(-1024)); assertEquals(0, inputStream.skip(Long.MIN_VALUE)); assertEquals(1024, inputStream.skip(1024)); for (int i = 2048; i < randomBytes.length; i++) { assertEquals(randomBytes[i], (byte) inputStream.read()); }",
        "ins1DelCode":"for (int i = 0; i < 1024; i++) { assertEquals(randomBytes[i], (byte) inputStream.read()); } assertEquals(0, inputStream.skip(-1)); assertEquals(0, inputStream.skip(-1024)); assertEquals(0, inputStream.skip(Long.MIN_VALUE)); assertEquals(1024, inputStream.skip(1024)); for (int i = 2048; i < randomBytes.length; i++) { assertEquals(randomBytes[i], (byte) inputStream.read());",
        "ins1PreCode":"public void testNegativeBytesSkippedAfterRead() throws IOException { for (int i = 0; i < 1024; i++) { assertEquals(randomBytes[i], (byte) inputStream.read()); }",
        "ins2PreCode":"public void testSkipFromFileChannel() throws IOException { for (int i = 1024; i < 2048; i++) { assertEquals(randomBytes[i], (byte) inputStream.read()); }",
        "label":1
    },
    {
        "ins1AddCode":"Path texFile = Path.of(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI());",
        "ins1DelCode":"Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI());",
        "ins1PreCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); ",
        "ins2PreCode":"public void testUnknownKey() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"final TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":" cache.test();  final TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"cache.test(); final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"return -1;",
        "ins1DelCode":"throw new EOFException();",
        "ins1PreCode":"} } else if (nRead == -1) {  throw new EOFException(); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"factory.setRegisterDefaultServlet(true);",
        "ins1DelCode":"",
        "ins1PreCode":"void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); factory.setSsl(getSsl(ClientAuth.NEED, \"password\", \"classpath:test.jks\", \"classpath:test.jks\", null, null)); this.webServer = factory.getWebServer();",
        "ins2PreCode":"void sslWantsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory); getSsl(ClientAuth.WANT, \"password\", \"classpath:test.jks\", null, new String[] { \"TLSv1.2\" }, null)); this.webServer = factory.getWebServer();",
        "label":0
    },
    {
        "ins1AddCode":"parentFilter, valuesSource, maxOrd, metadata);",
        "ins1DelCode":"List<PipelineAggregator> pipelineAggregators, parentFilter, valuesSource, maxOrd, pipelineAggregators, metadata);",
        "ins1PreCode":"protected Aggregator doCreateInternal(ValuesSource rawValuesSource, SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metadata) throws IOException {  if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metadata); } else { return asMultiBucketAggregator(this, searchContext, parent);",
        "ins2PreCode":"protected Aggregator doCreateInternal(ValuesSource rawValuesSource, SearchContext searchContext, Aggregator children, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metadata) throws IOException { if (rawValuesSource instanceof WithOrdinals == false) { throw new AggregationExecutionException(\"ValuesSource type \" + rawValuesSource.toString() + \"is not supported for aggregation \" + this.name()); } WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ChildrenToParentAggregator(name, factories, searchContext, children, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metadata); } else { return asMultiBucketAggregator(this, searchContext, children);",
        "label":1
    },
    {
        "ins1AddCode":"Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);",
        "ins1DelCode":"Blog blog = (Blog) session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1);",
        "ins1PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingJoin() throws Exception { SqlSession session = sqlMapper.openSession(); try { Blog blog = (Blog) session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle()); ",
        "ins2PreCode":"public void shouldSelectNestedBlogWithPostsAndAuthorUsingJoin() throws Exception { SqlSession session = sqlMapper.openSession(); try { Blog blog = (Blog) session.selectOne(\"domain.blog.mappers.NestedBlogMapper.selectBlogJoinedWithPostsAndAuthor\", 1); assertEquals(\"Jim Business\", blog.getTitle());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>(subscriber, Long.MAX_VALUE);",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>(subscriber, Long.MAX_VALUE);",
        "ins1PreCode":" Subscriber<String> subscriber = TestHelper.mockSubscriber();  TestSubscriber<String> ts = new TestSubscriber<String>(subscriber, Long.MAX_VALUE); flowable.subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); observable.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try { adjacentEdges.add(E23);",
        "ins2PreCode":"public void adjacentEdges_checkReturnedSetMutability() { addEdge(N1, N2, E12); Set<String> adjacentEdges = network.adjacentEdges(E12); try { adjacentEdges.add(E23);",
        "label":0
    },
    {
        "ins1AddCode":"\"  Number                   = {1},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  Number                   = {1},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE +",
        "ins1PreCode":"void roundTripWithCamelCasingInTheOriginalEntryAndResultInLowerCase() throws IOException {  String bibtexEntry = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  Author                   = {Foo Bar},\" + OS.NEWLINE + \"  Journal                  = {International Journal of Something},\" + OS.NEWLINE + \"  Note                     = {some note},\" + OS.NEWLINE + \"  Number                   = {1},\" + OS.NEWLINE + \"  HowPublished             = {asdf},\" + OS.NEWLINE + \"}\";    ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();   entry.setField(StandardField.AUTHOR, \"BlaBla\");   StringWriter stringWriter = new StringWriter(); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{test,\" + OS.NEWLINE + \"  author       = {BlaBla},\" + OS.NEWLINE + \"  journal      = {International Journal of Something},\" + OS.NEWLINE + \"  note         = {some note},\" + OS.NEWLINE + \"  number       = {1},\" + OS.NEWLINE + \"  howpublished = {asdf},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;  assertEquals(expected, actual);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"BstPreviewLayout bstPreviewLayout = new BstPreviewLayout(Path.of(BstPreviewLayoutTest.class.getResource(\"abbrv.bst\").toURI()));",
        "ins1DelCode":"BstPreviewLayout bstPreviewLayout = new BstPreviewLayout(Paths.get(BstPreviewLayoutTest.class.getResource(\"abbrv.bst\").toURI()));",
        "ins1PreCode":"public void generatePreviewForSimpleEntryUsingAbbr() throws Exception { BstPreviewLayout bstPreviewLayout = new BstPreviewLayout(Paths.get(BstPreviewLayoutTest.class.getResource(\"abbrv.bst\").toURI())); BibEntry entry = new BibEntry().withField(StandardField.AUTHOR, \"Oliver Kopp\") .withField(StandardField.TITLE, \"Thoughts on Development\");",
        "ins2PreCode":"public void monthMayIsCorrectlyRendered() throws Exception { BstPreviewLayout bstPreviewLayout = new BstPreviewLayout(Paths.get(BstPreviewLayoutTest.class.getResource(\"abbrv.bst\").toURI())); BibEntry entry = new BibEntry().withField(StandardField.AUTHOR, \"Oliver Kopp\") .withField(StandardField.TITLE, \"Thoughts on Development\")",
        "label":1
    },
    {
        "ins1AddCode":"public void printBannerShouldPrintMargin() {",
        "ins1DelCode":"public void printBannerShouldPrintMargin() throws Exception {",
        "ins1PreCode":"public void printBannerShouldPrintMargin() throws Exception { AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\");",
        "ins2PreCode":"public void printBannerWhenHasMarginPropertyShouldPrintSizedMargin() AnsiOutput.setEnabled(AnsiOutput.Enabled.NEVER); String banner = printBanner(\"large.gif\", \"banner.image.margin=4\");",
        "label":1
    },
    {
        "ins1AddCode":"createCompartments();",
        "ins1DelCode":"if (Model.getUmlFactory().isContainmentValid( Model.getMetaTypes().getAttribute(), getOwner())) { addFig(new FigAttributesCompartment( getOwner(), DEFAULT_COMPARTMENT_BOUNDS, getSettings())); } addFig(getOperationsFig());",
        "ins1PreCode":"addFig(getStereotypeFig());   if (Model.getUmlFactory().isContainmentValid( Model.getMetaTypes().getAttribute(), getOwner())) { addFig(new FigAttributesCompartment( getOwner(), DEFAULT_COMPARTMENT_BOUNDS, getSettings())); } addFig(getOperationsFig());  ",
        "ins2PreCode":"addFig(getStereotypeFig()); getNameFig().setTopMargin( getStereotypeFig().setVisible(true); addFig(getOperationsFig()); addExtraCompartments(); addFig(getOperationsFig()); setFillColor(FILL_COLOR); addFig(getStereotypeFig()); } addFig(getOperationsFig());",
        "label":0
    },
    {
        "ins1AddCode":"WhileLoopNode irWhileLoopNode = new WhileLoopNode(userWhileNode.getLocation());",
        "ins1DelCode":"WhileLoopNode irWhileLoopNode = new WhileLoopNode(); irWhileLoopNode.setLocation(userWhileNode.getLocation());",
        "ins1PreCode":"public void visitWhile(SWhile userWhileNode, ScriptScope scriptScope) { WhileLoopNode irWhileLoopNode = new WhileLoopNode(); irWhileLoopNode.setConditionNode(injectCast(userWhileNode.getConditionNode(), scriptScope)); irWhileLoopNode.setBlockNode((BlockNode)visit(userWhileNode.getBlockNode(), scriptScope)); irWhileLoopNode.setLocation(userWhileNode.getLocation()); irWhileLoopNode.setContinuous(scriptScope.getCondition(userWhileNode, ContinuousLoop.class)); ",
        "ins2PreCode":"public void visitDo(SDo userDoNode, ScriptScope scriptScope) { DoWhileLoopNode irDoWhileLoopNode = new DoWhileLoopNode(); irDoWhileLoopNode.setConditionNode(injectCast(userDoNode.getConditionNode(), scriptScope)); irDoWhileLoopNode.setBlockNode((BlockNode)visit(userDoNode.getBlockNode(), scriptScope)); irDoWhileLoopNode.setLocation(userDoNode.getLocation()); irDoWhileLoopNode.setContinuous(scriptScope.getCondition(userDoNode, ContinuousLoop.class));",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull( input, \"input cannot be null\" );",
        "ins1DelCode":"Validate.notNull( input, \"input cannot be null\" );",
        "ins1PreCode":"public Settings read( InputStream input, Map<String, ?> options ) throws IOException { Validate.notNull( input, \"input cannot be null\" );  try ( final InputStream in = input )",
        "ins2PreCode":"public PersistedToolchains read( Reader input, Map<String, ?> options ) throws IOException { Validate.notNull( input, \"input cannot be null\" ); try ( final Reader in = input )",
        "label":1
    },
    {
        "ins1AddCode":"String servletPath = (String) getAttribute( RequestDispatcher.INCLUDE_SERVLET_PATH);",
        "ins1DelCode":"String servletPath = (String) getAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR);",
        "ins1PreCode":"return (context.getServletContext().getRequestDispatcher(path));   String servletPath = (String) getAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR); if (servletPath == null) servletPath = getServletPath();",
        "ins2PreCode":"return (context.getServletContext().getRequestDispatcher(path)); (String) getAttribute(Globals.INCLUDE_SERVLET_PATH_ATTR); if (servletPath == null) servletPath = getServletPath();",
        "label":1
    },
    {
        "ins1AddCode":"conn.close();",
        "ins1DelCode":"",
        "ins1PreCode":"ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.runScript(reader); reader.close(); session.close();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void mergeExistingPropertyDeprecationOverride() throws Exception {",
        "ins1DelCode":"public void mergeExistingPropertyDeprecationOverride() throws Exception {",
        "ins1PreCode":"public void mergeExistingPropertyDeprecationOverride() throws Exception { ItemMetadata property = ItemMetadata.newProperty(\"singledeprecated\", \"name\", null, null, null, null, null, new ItemDeprecation(\"Don't use this.\", \"single.name\"));",
        "ins2PreCode":"public void mergeExistingPropertyDeprecationOverrideLevel() throws Exception { ItemMetadata property = ItemMetadata.newProperty(\"singledeprecated\", \"name\", null, null, null, null, null, new ItemDeprecation(null, null, \"error\"));",
        "label":1
    },
    {
        "ins1AddCode":"public void testDetailsAreIncludedInAuditEvent() {",
        "ins1DelCode":"public void testDetailsAreIncludedInAuditEvent() throws Exception {",
        "ins1PreCode":"public void testDetailsAreIncludedInAuditEvent() throws Exception { Object details = new Object(); UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(",
        "ins2PreCode":"public void testDetailsAreIncludedInAuditEvent() throws Exception { Object details = new Object(); UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> concatArray(@NonNull Publisher<? extends T>... sources) {",
        "ins1DelCode":"public static <T> Flowable<T> concatArray(@NonNull Publisher<@NonNull ? extends T>... sources) {",
        "ins1PreCode":"public static <T> Flowable<T> concatArray(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "ins2PreCode":"public static <T> Flowable<T> concatArrayDelayError(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) {",
        "label":1
    },
    {
        "ins1AddCode":"udpServer.setIoHandler(new AbstractIoHandler() {",
        "ins1DelCode":"udpServer.setIoHandler(new IoHandler() {",
        "ins1PreCode":"UdpSessionConfig config = new DefaultUdpSessionConfig(); config.setReadBufferSize(65536); udpServer = new NioUdpServer(config); udpServer.setIoHandler(new IoHandler() { @Override public void sessionOpened(IoSession session) {",
        "ins2PreCode":"UdpSessionConfig config = new DefaultUdpSessionConfig(); config.setReadBufferSize(65536); udpServer = new BioUdpServer(config, null); udpServer.setIoHandler(new IoHandler() { @Override public void sessionOpened(IoSession session) {",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to0 = new TestObserverEx<>(QueueFuseable.ASYNC);",
        "ins1DelCode":"TestObserverEx<Integer> to0 = new TestObserverEx<Integer>(QueueFuseable.ASYNC);",
        "ins1PreCode":"public void asyncFusedRejected() { TestObserverEx<Integer> to0 = new TestObserverEx<Integer>(QueueFuseable.ASYNC);  Observable.range(1, 5)",
        "ins2PreCode":"public void syncFusedConditional() { TestObserverEx<Integer> to0 = new TestObserverEx<Integer>(QueueFuseable.SYNC); Observable.range(1, 5)",
        "label":1
    },
    {
        "ins1AddCode":"void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception {",
        "ins1DelCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception {",
        "ins1PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null);",
        "ins2PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestObservable subscribed to ...\"); t = new Thread(new Runnable() {",
        "ins2PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestSingleThreadedObservable subscribed to ...\"); t = new Thread(new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"return super.applyCSSProperty(element, property, value, pseudo, engine);",
        "ins1DelCode":"return false;",
        "ins1PreCode":" Widget widget = SWTElementHelpers.getWidget(element); if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { return false; } ",
        "ins2PreCode":"Widget widget = SWTElementHelpers.getWidget(element); if (widget == null || (widget instanceof Control && UIUtils.isInDialog((Control)widget))) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Observable<Integer>> inner = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>();",
        "ins1PreCode":"public void windowAbandonmentCancelsUpstreamSkip() { PublishSubject<Integer> ps = PublishSubject.create();  final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>();  TestObserver<Observable<Integer>> to = ps.window(5, 10)",
        "ins2PreCode":"public void windowAbandonmentCancelsUpstreamOverlap() { PublishSubject<Integer> ps = PublishSubject.create(); final AtomicReference<Observable<Integer>> inner = new AtomicReference<Observable<Integer>>(); TestObserver<Observable<Integer>> to = ps.window(5, 3)",
        "label":1
    },
    {
        "ins1AddCode":"String notationStr = notation.toString(aCallState, NotationSettings.getDefaultSettings());",
        "ins1DelCode":"String notationStr = notation.toString(aCallState, null);",
        "ins1PreCode":"assertNotNull(\"No entry action generated\", entry); Object op = Model.getFacade().getOperation(entry); assertNotNull(\"Operation not linked to entry action\", op); String notationStr = notation.toString(aCallState, null); assertEquals(\"Notation not correctly generated\", \"myOper\\n(ClassA)\", notationStr);",
        "ins2PreCode":"assertNotNull(\"No entry action generated\", entry); Object op = Model.getFacade().getOperation(entry); assertNotNull(\"Operation not linked to entry action\", op); String notationStr = notation.toString(aCallState, null); assertEquals(\"Notation not correctly generated\", \"myOper2\\n(ClassA)\", notationStr);",
        "label":1
    },
    {
        "ins1AddCode":"MutableNetwork<Integer, String> network = NetworkBuilder addEdges(network); assertThat(network.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(network.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(network.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "ins1DelCode":"MutableNetwork<Integer, String> graph = NetworkBuilder addEdges(graph); assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "ins1PreCode":"public void edgeOrder_insertion() { MutableNetwork<Integer, String> graph = NetworkBuilder .directed() .edgeOrder(insertion()) .build();  addEdges(graph);  assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "ins2PreCode":"public void edgeOrder_default() { MutableNetwork<Integer, String> graph = NetworkBuilder .directed() assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion()); .build(); addEdges(graph); assertThat(graph.edgeOrder()).isEqualTo(ElementOrder.insertion()); assertThat(graph.edges()).containsExactly(\"i\", \"e\", \"p\").inOrder(); assertThat(graph.nodeOrder()).isEqualTo(ElementOrder.insertion());",
        "label":1
    },
    {
        "ins1AddCode":"Processor processor = new RemoveProcessor.Factory(TestTemplateService.instance()).create(null, processorTag, null, config);",
        "ins1DelCode":"Processor processor = new RemoveProcessor.Factory(TestTemplateService.instance()).create(null, processorTag, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", fieldName); String processorTag = randomAlphaOfLength(10); Processor processor = new RemoveProcessor.Factory(TestTemplateService.instance()).create(null, processorTag, config); try { processor.execute(ingestDocument);",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", fieldName); String processorTag = randomAlphaOfLength(10); Processor processor = new RemoveProcessor.Factory(TestTemplateService.instance()).create(null, processorTag, config); public void testIgnoreMissing() throws Exception { processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1AddCode":"return (sb.length() > content.length()) ? sb.toString(): content;",
        "ins1DelCode":"return sb.toString();",
        "ins1PreCode":"} }  return sb.toString();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort())) {",
        "ins1DelCode":"TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort()); try { } finally { client.close();",
        "ins1PreCode":"public void testZeroLengthStream() throws Throwable { TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort()); try { StreamTask task = new StreamTask(client, \"emptyBuffer\", TimeUnit.SECONDS.toMillis(5)); task.run(); task.check(); } finally { client.close(); }",
        "ins2PreCode":"public void testSingleStream() throws Throwable { TransportClient client = clientFactory.createClient(TestUtils.getLocalHost(), server.getPort()); try { StreamTask task = new StreamTask(client, \"largeBuffer\", TimeUnit.SECONDS.toMillis(5)); task.run(); task.check(); } finally { client.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"for (FTPFile f : theFiles) { if (f != null && f.getName().equalsIgnoreCase(soughtPathElement)) { return f.getName();",
        "ins1DelCode":"for (int icounter = 0; icounter < theFiles.length; icounter++) { if (theFiles[icounter] != null && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) { return theFiles[icounter].getName();",
        "ins1PreCode":"if (theFiles == null) { return null; } for (int icounter = 0; icounter < theFiles.length; icounter++) { if (theFiles[icounter] != null && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) { return theFiles[icounter].getName(); } }",
        "ins2PreCode":"if (theFiles == null) { return null; } for (int icounter = 0; icounter < theFiles.length; icounter++) { if (theFiles[icounter] != null && theFiles[icounter].getName().equalsIgnoreCase(soughtPathElement)) { return theFiles[icounter].getName(); } }",
        "label":1
    },
    {
        "ins1AddCode":"DeterministicFactoryTestScript.Factory factory = DeterministicFactoryTestScript.CONTEXT, Collections.emptyMap());",
        "ins1DelCode":"FactoryTestScript.Factory factory = FactoryTestScript.CONTEXT, Collections.emptyMap());",
        "ins1PreCode":"public void testNotDeterministic() { FactoryTestScript.Factory factory = scriptEngine.compile(\"not_deterministic_test\", \"Math.random()\", FactoryTestScript.CONTEXT, Collections.emptyMap()); assertFalse(factory.isResultDeterministic()); Double d = (Double)factory.newInstance(Collections.emptyMap()).execute(0);",
        "ins2PreCode":"public void testMixedDeterministicIsNotDeterministic() { FactoryTestScript.Factory factory = scriptEngine.compile(\"not_deterministic_test\", \"Integer.parseInt('123') + Math.random()\", FactoryTestScript.CONTEXT, Collections.emptyMap()); assertFalse(factory.isResultDeterministic()); Double d = (Double)factory.newInstance(Collections.emptyMap()).execute(0);",
        "label":1
    },
    {
        "ins1AddCode":"if (command.getProperties().size() > 1 || command.getProperty(\"description\") == null) {",
        "ins1DelCode":"if (command.getProperties().size() > 1 || command.getProperty(\"comment\") == null) {",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { if (command.getProperties().size() > 1 || command.getProperty(\"comment\") == null) { StringBuilder query = new StringBuilder(\"ALTER TABLE \"); query.append(command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL)).append(\" \");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"= new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new BoxAndWhiskerRenderer());",
        "ins2PreCode":"= new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, 4.5, null, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new BoxAndWhiskerRenderer());",
        "label":1
    },
    {
        "ins1AddCode":"Observable.combineLatestArrayDelayError(",
        "ins1DelCode":"Observable.combineLatestDelayError(",
        "ins1PreCode":"public void errorDelayed() { Observable.combineLatestDelayError( new ObservableSource[] { Observable.error(new TestException()), Observable.just(1) }, new Function<Object[], Object>() {",
        "ins2PreCode":"public void errorDelayed() { Flowable.combineLatestDelayError( new Publisher[] { Flowable.error(new TestException()), Flowable.just(1) }, new Function<Object[], Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"public void bindToArrayWhenNonSequentialShouldThrowException() {",
        "ins1DelCode":"public void bindToArrayWhenNonSequentialShouldThrowException() throws Exception {",
        "ins1PreCode":"public void bindToArrayWhenNonSequentialShouldThrowException() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0]\", \"2\");",
        "ins2PreCode":"public void bindToCollectionWhenNonSequentialShouldThrowException() throws Exception { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0]\", \"2\");",
        "label":1
    },
    {
        "ins1AddCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() throws Exception { addMapper(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); Product product = mapper.getProductByName(\"iPad\"); assertEquals(Integer.valueOf(2), product.getId().getValue()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldApplyTypeHandlerUsingConstructor() throws Exception { addMapper(); SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); Product product = mapper.getProductByName(\"iPad\"); assertEquals(Integer.valueOf(2), product.getId().getValue()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0); ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);",
        "ins1DelCode":"ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext);",
        "ins1PreCode":"MockPropertySource secondPropertySource = new MockPropertySource(); secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor));",
        "ins2PreCode":"MockPropertySource secondPropertySource = new MockPropertySource(); secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor));",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(other, \"other is null\"); Objects.requireNonNull(leftEnd, \"leftEnd is null\"); Objects.requireNonNull(rightEnd, \"rightEnd is null\"); Objects.requireNonNull(resultSelector, \"resultSelector is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\");",
        "ins1PreCode":"Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd, BiFunction<? super T, ? super TRight, ? extends R> resultSelector ) { ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new ObservableJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "ins2PreCode":"Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, BiFunction<? super T, ? super TRight, ? extends R> resultSelector) { BiFunction<? super T, ? super TRight, ? extends R> resultSelector) { ObjectHelper.requireNonNull(other, \"other is null\"); ObjectHelper.requireNonNull(leftEnd, \"leftEnd is null\"); ObjectHelper.requireNonNull(rightEnd, \"rightEnd is null\"); ObjectHelper.requireNonNull(resultSelector, \"resultSelector is null\"); return RxJavaPlugins.onAssembly(new FlowableJoin<T, TRight, TLeftEnd, TRightEnd, R>( this, other, leftEnd, rightEnd, resultSelector));",
        "label":1
    },
    {
        "ins1AddCode":"ConstantNode irConstantNode = new ConstantNode(userDecimalNode.getLocation());",
        "ins1DelCode":"ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userDecimalNode.getLocation());",
        "ins1PreCode":"public void visitDecimal(EDecimal userDecimalNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userDecimalNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userDecimalNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userDecimalNode, StandardConstant.class).getStandardConstant());",
        "ins2PreCode":"public void visitString(EString userStringNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userStringNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userStringNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userStringNode, StandardConstant.class).getStandardConstant());",
        "label":1
    },
    {
        "ins1AddCode":"void testEmptyMapIsNotAdded() {",
        "ins1DelCode":"public void testEmptyMapIsNotAdded() {",
        "ins1PreCode":"public void testEmptyMapIsNotAdded() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class); contextRunner.run((context) -> {",
        "ins2PreCode":"public void testList() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(ListConfig.class) contextRunner.run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"innerObserver.onSubscribe(Disposable.empty());",
        "ins1DelCode":"innerObserver.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 100, \"one\"); publishNext(innerObserver, 300, \"two\");",
        "ins2PreCode":"Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 100, \"one\"); publishNext(subscriber, 300, \"two\");",
        "label":0
    },
    {
        "ins1AddCode":"public RestTemplateBuilder additionalCustomizers(Collection<? extends RestTemplateCustomizer> customizers) { return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, this.messageConverters, this.interceptors, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, append(this.customizers, customizers), this.requestCustomizers);",
        "ins1DelCode":"public RestTemplateBuilder additionalCustomizers( Collection<? extends RestTemplateCustomizer> customizers) { return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, append(this.restTemplateCustomizers, customizers), this.requestFactoryCustomizer, this.interceptors);",
        "ins1PreCode":"public RestTemplateBuilder additionalCustomizers( Collection<? extends RestTemplateCustomizer> customizers) { Assert.notNull(customizers, \"RestTemplateCustomizers must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, append(this.restTemplateCustomizers, customizers), this.requestFactoryCustomizer, this.interceptors);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public static <@NonNull T> Observable<T> mergeDelayError(",
        "ins1DelCode":"public static <T> Observable<T> mergeDelayError(",
        "ins1PreCode":"public static <T> Observable<T> mergeDelayError( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4) {",
        "ins2PreCode":"public static <T> Flowable<T> concat( @NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) {",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1DelCode":"assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1PreCode":" String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString(); assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result, failedWith(6)); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Slave/Delete permission\"));",
        "ins1DelCode":"assertThat(result, failedWith(-1)); assertThat(result.stderr(), containsString(\"user is missing the Slave/Delete permission\"));",
        "ins1PreCode":".invokeWithArgs(\"aNode\") ;  assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"user is missing the Slave/Delete permission\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Subscriber<Integer>> serial = new AtomicReference<>(); SerializedSubscriber<Integer> sobs = new SerializedSubscriber<>(ts);",
        "ins1DelCode":"final AtomicReference<Subscriber<Integer>> serial = new AtomicReference<Subscriber<Integer>>(); SerializedSubscriber<Integer> sobs = new SerializedSubscriber<Integer>(ts);",
        "ins1PreCode":"public void errorReentry() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Subscriber<Integer>> serial = new AtomicReference<Subscriber<Integer>>();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>() { @Override public void onNext(Integer v) { serial.get().onError(new TestException()); serial.get().onError(new TestException()); super.onNext(v); } }; SerializedSubscriber<Integer> sobs = new SerializedSubscriber<Integer>(ts); sobs.onSubscribe(new BooleanSubscription()); serial.set(sobs);",
        "ins2PreCode":"public void errorReentry() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final AtomicReference<Observer<Integer>> serial = new AtomicReference<Observer<Integer>>(); TestObserver<Integer> to = new TestObserver<Integer>() { @Override public void onNext(Integer v) { serial.get().onError(new TestException()); serial.get().onError(new TestException()); super.onNext(v); } }; SerializedObserver<Integer> sobs = new SerializedObserver<Integer>(to); sobs.onSubscribe(Disposable.empty()); serial.set(sobs);",
        "label":1
    },
    {
        "ins1AddCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException { socketBufferHandler.configureReadBufferForRead(); ByteBuffer readBuffer = socketBufferHandler.getReadBuffer(); int remaining = readBuffer.remaining(); if (remaining >= len) { readBuffer.get(b, off, len); return len; } if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining; } int nRead = fillReadBuffer(block); if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; return nRead;",
        "ins1DelCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException { if (closed) { throw new IOException(sm.getString(\"socket.apr.closed\", getSocket())); } if (returnedInput != null) { if (returnedInput.remaining() < len) { len = returnedInput.remaining(); returnedInput.get(b, off, len); if (returnedInput.remaining() == 0) { returnedInput = null; } return len; } Lock readLock = getBlockingStatusReadLock(); WriteLock writeLock = getBlockingStatusWriteLock(); boolean readDone = false; int result = 0; readLock.lock(); try { if (getBlockingStatus() == block) { if (block) { Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000); } result = Socket.recv(getSocket().longValue(), b, off, len); readDone = true; } } finally { readLock.unlock(); } if (!readDone) { writeLock.lock(); try { setBlockingStatus(block); if (block) { Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000); } else { Socket.timeoutSet(getSocket().longValue(), 0); } readLock.lock(); try { writeLock.unlock(); result = Socket.recv(getSocket().longValue(), b, off, len); } finally { readLock.unlock(); } } finally { if (writeLock.isHeldByCurrentThread()) { writeLock.unlock(); } } } if (result > 0) { eagain = false; return result; } else if (-result == Status.EAGAIN) { eagain = true; return 0; } else if (-result == Status.APR_EGENERAL && isSecure()) { if (log.isDebugEnabled()) { log.debug(sm.getString(\"socket.apr.read.sslGeneralError\", getSocket(), this)); } eagain = true; return 0; } else if ((-result) == Status.ETIMEDOUT || (-result) == Status.TIMEUP) { if (block) { throw new SocketTimeoutException( sm.getString(\"iib.readtimeout\")); } else { return 0; } } else if (-result == Status.APR_EOF) { return -1; } else if ((OS.IS_WIN32 || OS.IS_WIN64) && (-result == Status.APR_OS_START_SYSERR + 10053)) { throw new EOFException(sm.getString(\"socket.apr.clientAbort\")); throw new IOException(sm.getString(\"socket.apr.read.error\", Integer.valueOf(-result), getSocket(), this));",
        "ins1PreCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {    if (closed) { throw new IOException(sm.getString(\"socket.apr.closed\", getSocket())); }  if (returnedInput != null) { if (returnedInput.remaining() < len) { len = returnedInput.remaining(); } returnedInput.get(b, off, len); if (returnedInput.remaining() == 0) { returnedInput = null; } return len; }  Lock readLock = getBlockingStatusReadLock(); WriteLock writeLock = getBlockingStatusWriteLock();  boolean readDone = false; int result = 0; readLock.lock(); try { if (getBlockingStatus() == block) { if (block) { Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000); } result = Socket.recv(getSocket().longValue(), b, off, len); readDone = true; } } finally { readLock.unlock(); }  if (!readDone) { writeLock.lock(); try {  setBlockingStatus(block); if (block) { Socket.timeoutSet(getSocket().longValue(), getReadTimeout() * 1000); } else { Socket.timeoutSet(getSocket().longValue(), 0); }  readLock.lock(); try { writeLock.unlock(); result = Socket.recv(getSocket().longValue(), b, off, len); } finally { readLock.unlock(); } } finally {   if (writeLock.isHeldByCurrentThread()) { writeLock.unlock(); } } }  if (result > 0) { eagain = false; return result; } else if (-result == Status.EAGAIN) { eagain = true; return 0; } else if (-result == Status.APR_EGENERAL && isSecure()) {    if (log.isDebugEnabled()) { log.debug(sm.getString(\"socket.apr.read.sslGeneralError\", getSocket(), this)); } eagain = true; return 0; } else if ((-result) == Status.ETIMEDOUT || (-result) == Status.TIMEUP) { if (block) { throw new SocketTimeoutException( sm.getString(\"iib.readtimeout\")); } else {       return 0; } } else if (-result == Status.APR_EOF) { return -1; } else if ((OS.IS_WIN32 || OS.IS_WIN64) && (-result == Status.APR_OS_START_SYSERR + 10053)) {  throw new EOFException(sm.getString(\"socket.apr.clientAbort\")); } else { throw new IOException(sm.getString(\"socket.apr.read.error\", Integer.valueOf(-result), getSocket(), this)); }",
        "ins2PreCode":"public int read(boolean block, byte[] b, int off, int len) if (nRead > 0) { throws IOException { } return len; if (remaining >= len) { return remaining; } readBuffer.get(b, off, len); if (remaining > 0) { return len; } return len; } readBuffer.get(b, off, nRead); socketBufferHandler.configureReadBufferForRead(); return remaining; return len; int nRead = fillReadBuffer(block); return len; if (remaining >= len) { if (nRead > len) { socketBufferHandler.configureReadBufferForRead(); } readBuffer.get(b, off, len); return len; } if (nRead > len) { return len; } if (nRead > len) { return len; return len; int nRead = fillReadBuffer(block); if (nRead > len) { socketBufferHandler.configureReadBufferForRead(); } else { socketBufferHandler.configureReadBufferForRead(); } int nRead = fillReadBuffer(block); return len; return len; readBuffer.get(b, off, len); if (nRead > len) { return len; } if (nRead > len) { socketBufferHandler.configureReadBufferForRead(); return len; } } } if (nRead > 0) { if (remaining >= len) { return len; if (remaining > 0) { if (remaining >= len) { return len; if (remaining > 0) { if (nRead > len) { socketBufferHandler.configureReadBufferForRead(); } if (remaining >= len) { return len; if (remaining >= len) { if (nRead > len) { throws IOException { return nRead; } else { return len; } if (remaining > 0) { return len; } else { if (remaining > 0) { throws IOException { } else { throws IOException { int remaining = readBuffer.remaining(); }",
        "label":0
    },
    {
        "ins1AddCode":"writer.writeCData(StringUtils.getStackTrace(t));",
        "ins1DelCode":"writer.writeCData(StringUtils.getStackTrace(cause.get()));",
        "ins1PreCode":"} writer.writeAttribute(ATTR_TYPE, t.getClass().getName());  writer.writeCData(StringUtils.getStackTrace(cause.get())); } writer.writeEndElement();",
        "ins2PreCode":"} writer.writeAttribute(ATTR_TYPE, t.getClass().getName()); writer.writeCData(StringUtils.getStackTrace(cause.get())); } writer.writeEndElement();",
        "label":1
    },
    {
        "ins1AddCode":"HttpClient httpClient = this.httpClientBuilder.get().setSSLSocketFactory(socketFactory).build();",
        "ins1DelCode":"HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build();",
        "ins1PreCode":"this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); assertThat(getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory)).isEqualTo(\"test\");",
        "ins2PreCode":"this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); assertThatIOException().isThrownBy(() -> getResponse(localUrl, requestFactory));",
        "label":1
    },
    {
        "ins1AddCode":"} catch (Exception e) { (sm.getString(\"hostManagerServlet.startFailed\", name), e); e.toString()));",
        "ins1DelCode":"} catch (Throwable t) { (sm.getString(\"hostManagerServlet.startFailed\", name), t); t.toString()));",
        "ins1PreCode":"host.start(); writer.println (sm.getString(\"hostManagerServlet.started\", name)); } catch (Throwable t) { getServletContext().log (sm.getString(\"hostManagerServlet.startFailed\", name), t); writer.println (sm.getString(\"hostManagerServlet.startFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", t.toString())); return; }",
        "ins2PreCode":"host.stop(); writer.println (sm.getString(\"hostManagerServlet.stopped\", name)); } catch (Throwable t) { getServletContext().log (sm.getString(\"hostManagerServlet.stopFailed\", name), t); writer.println (sm.getString(\"hostManagerServlet.stopFailed\", name)); writer.println(sm.getString(\"hostManagerServlet.exception\", t.toString())); return; }",
        "label":1
    },
    {
        "ins1AddCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1DelCode":"h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"ParallelFailureHandling h; try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":1
    },
    {
        "ins1AddCode":"ApplicationConfigurationProperties applicationProperties = endpoint ConfigurationPropertiesBeanDescriptor foo = applicationProperties .getContexts().get(context.getId()).getBeans().get(\"foo\");",
        "ins1DelCode":"ConfigurationPropertiesDescriptor properties = endpoint ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\");",
        "ins1PreCode":"contextRunner.run((context) -> { ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull(); assertThat(foo.getPrefix()).isEqualTo(\"foo\");",
        "ins2PreCode":"contextRunner.run((context) -> { ConfigurationPropertiesReportEndpoint endpoint = context .getBean(ConfigurationPropertiesReportEndpoint.class); ConfigurationPropertiesDescriptor properties = endpoint .configurationProperties(); ConfigurationPropertiesBeanDescriptor foo = properties.getBeans().get(\"foo\"); assertThat(foo).isNotNull(); assertThat(foo.getPrefix()).isEqualTo(\"foo\");",
        "label":1
    },
    {
        "ins1AddCode":"result.subplots = (List) CloneUtils.cloneList(this.subplots);",
        "ins1DelCode":"result.subplots = (List) ObjectUtils.deepClone(this.subplots);",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException {  CombinedRangeXYPlot result = (CombinedRangeXYPlot) super.clone(); result.subplots = (List) ObjectUtils.deepClone(this.subplots); for (XYPlot child : result.subplots) { child.setParent(result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.errorIndicatorStroke, that.errorIndicatorStroke)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.errorIndicatorStroke, that.errorIndicatorStroke)) {",
        "ins1PreCode":"that.errorIndicatorPaint)) { return false; } if (!ObjectUtils.equal(this.errorIndicatorStroke, that.errorIndicatorStroke)) { return false; }",
        "ins2PreCode":"that.errorIndicatorPaint)) { return false; } if (!ObjectUtils.equal(this.errorIndicatorStroke, that.errorIndicatorStroke)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "ins1PreCode":"} return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<T, R>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "ins2PreCode":"} return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableFlatMap<T, R>(this, mapper, delayErrors, maxConcurrency, bufferSize));",
        "label":1
    },
    {
        "ins1AddCode":"protected synchronized void dieOnCircularReference(Stack stk, Project p)",
        "ins1DelCode":"protected void dieOnCircularReference(Stack stk, Project p)",
        "ins1PreCode":"protected void dieOnCircularReference(Stack stk, Project p) throws BuildException { if (isChecked()) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CacheDisposable<T> consumer = new CacheDisposable<>(t, this);",
        "ins1DelCode":"CacheDisposable<T> consumer = new CacheDisposable<T>(t, this);",
        "ins1PreCode":"protected void subscribeActual(Observer<? super T> t) { CacheDisposable<T> consumer = new CacheDisposable<T>(t, this); t.onSubscribe(consumer); add(consumer);",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super T> t) { CacheSubscription<T> consumer = new CacheSubscription<T>(t, this); t.onSubscribe(consumer); add(consumer);",
        "label":1
    },
    {
        "ins1AddCode":"final boolean lastIsUnparseableHolder = data.length > 0 && data[data.length - 1] instanceof UnparseableExtraFieldData; int regularExtraFieldCount = lastIsUnparseableHolder ? data.length - 1 : data.length; int sum = WORD * regularExtraFieldCount; for (int i = 0; i < regularExtraFieldCount; i++) { if (lastIsUnparseableHolder) { byte[] local = data[data.length - 1].getLocalFileDataData(); System.arraycopy(local, 0, result, start, local.length); }",
        "ins1DelCode":"int sum = WORD * data.length; for (int i = 0; i < data.length; i++) {",
        "ins1PreCode":"public static byte[] mergeLocalFileDataData(ZipExtraField[] data) { int sum = WORD * data.length; for (int i = 0; i < data.length; i++) { sum += data[i].getLocalFileDataLength().getValue();",
        "ins2PreCode":"public static byte[] mergeCentralDirectoryData(ZipExtraField[] data) { int sum = WORD * data.length; for (int i = 0; i < data.length; i++) { sum += data[i].getCentralDirectoryLength().getValue();",
        "label":1
    },
    {
        "ins1AddCode":"Set<String> definedRepositories = repositorySystem.getRepoIds( request.getRemoteRepositories() ); request.addRemoteRepository( repositorySystem.createDefaultRemoteRepository( request ) );",
        "ins1DelCode":"Set<String> definedRepositories = getRepoIds( request.getRemoteRepositories() ); request.addRemoteRepository( createDefaultRemoteRepository( request ) );",
        "ins1PreCode":"private void injectDefaultRepositories( MavenExecutionRequest request ) throws MavenExecutionRequestPopulationException { Set<String> definedRepositories = getRepoIds( request.getRemoteRepositories() );  if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) ) { try { request.addRemoteRepository( createDefaultRemoteRepository( request ) ); } catch ( Exception e )",
        "ins2PreCode":"private void injectDefaultPluginRepositories( MavenExecutionRequest request ) throws MavenExecutionRequestPopulationException { Set<String> definedRepositories = getRepoIds( request.getPluginArtifactRepositories() ); if ( !definedRepositories.contains( RepositorySystem.DEFAULT_REMOTE_REPO_ID ) ) { try { request.addPluginArtifactRepository( createDefaultRemoteRepository( request ) ); } catch ( Exception e )",
        "label":1
    },
    {
        "ins1AddCode":"LOG.info(\"allAvailableFeatures start\"); LOG.info(\"allAvailableFeatures \" + returnList.size());",
        "ins1DelCode":"",
        "ins1PreCode":"public Collection<Feature> allAvailableFeatures(Object arole) {  if (arole instanceof ClassifierRole) { try { List<Feature> returnList = new ArrayList<Feature>(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableFeatures(genElem)); } } for (Classifier classifier : role.getBase()) { returnList.addAll(classifier.getFeature()); } return returnList; } catch (InvalidObjectException e) { throw new InvalidElementException(e); }",
        "ins2PreCode":"public Collection allAvailableContents(Object arole) { if (arole instanceof ClassifierRole) { try { List returnList = new ArrayList(); ClassifierRole role = (ClassifierRole) arole; for (ModelElement genElem : CoreHelperMDRImpl.getAllParents(role)) { if (genElem instanceof ClassifierRole) { returnList.addAll(allAvailableContents(genElem)); } } for (Classifier baseClassifier : role.getBase()) { returnList.addAll(baseClassifier.getOwnedElement()); } return returnList; } catch (InvalidObjectException e) { throw new InvalidElementException(e); }",
        "label":1
    },
    {
        "ins1AddCode":"source.subscribe(new ReduceSeedObserver<>(observer, reducer, seed));",
        "ins1DelCode":"source.subscribe(new ReduceSeedObserver<T, R>(observer, reducer, seed));",
        "ins1PreCode":"EmptyDisposable.error(ex, observer); return; } source.subscribe(new ReduceSeedObserver<T, R>(observer, reducer, seed));",
        "ins2PreCode":"EmptyDisposable.error(ex, observer); return; } source.subscribe(new ReduceSeedObserver<T, R>(observer, reducer, seed));",
        "label":1
    },
    {
        "ins1AddCode":"void testLangRawWithInclude() {",
        "ins1DelCode":"public void testLangRawWithInclude() {",
        "ins1PreCode":"public void testLangRawWithInclude() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins2PreCode":"public void testLangRawWithIncludeAndCData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "label":1
    },
    {
        "ins1AddCode":"ProjectHelper ph = StreamUtils.iteratorAsStream(getHelpers()) .filter(helper -> helper.canParseBuildFile(buildFile)) .findFirst().orElse(null); if (ph == null) { throw new BuildException(\"BUG: at least the ProjectHelper2 should \" + \"have supported the file \" + buildFile); helper.getClass().getName() \" selected for the build file \" buildFile); \"have supported the file \" + buildFile); if (DEBUG) { System.out.println(\"ProjectHelper \" + ph.getClass().getName() + \" selected for the build file \" + buildFile); } return ph;",
        "ins1DelCode":"for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) { ProjectHelper helper = it.next(); if (helper.canParseBuildFile(buildFile)) { if (DEBUG) { System.out.println(\"ProjectHelper \" + helper.getClass().getName() + \" selected for the build file \" + buildFile); } return helper; } throw new BuildException(\"BUG: at least the ProjectHelper2 should \" + \"have supported the file \" + buildFile);",
        "ins1PreCode":"public ProjectHelper getProjectHelperForBuildFile(Resource buildFile) throws BuildException { for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) { ProjectHelper helper = it.next(); if (helper.canParseBuildFile(buildFile)) { if (DEBUG) { System.out.println(\"ProjectHelper \" + helper.getClass().getName() + \" selected for the build file \" + buildFile); } return helper; } }",
        "ins2PreCode":"public ProjectHelper getProjectHelperForAntlib(Resource antlib) throws BuildException { for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) { ProjectHelper helper = it.next(); if (helper.canParseAntlibDescriptor(antlib)) { if (DEBUG) { System.out.println(\"ProjectHelper \" + helper.getClass().getName() + \" selected for the antlib \" + antlib); } return helper; } }",
        "label":0
    },
    {
        "ins1AddCode":"BibEntry entry1 = new BibEntry().withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"Simon Holland\"); CitationKeyGenerator.cleanKey(generateKey(entry1, \"[auth]\",",
        "ins1DelCode":"BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"Simon Holland\"); CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\",",
        "ins1PreCode":"void testCrossrefAndInAuthorNames() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"Simon Holland\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"Holland\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins2PreCode":"void testCrossrefAndAuthorNames() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry1.setField(StandardField.CROSSREF, \"entry2\"); database.insertEntry(entry1); database.insertEntry(entry2); assertEquals(\"HerlandHaugeHelgeland\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"authors3\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Long>> aggregated = grouped.agg( aggregated.collectAsList());",
        "ins1DelCode":"Dataset<Tuple2<String, Long>> agged = grouped.agg( agged.collectAsList());",
        "ins1PreCode":"public void testTypedAggregationCount() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.count(value -> value)); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 2L), new Tuple2<>(\"b\", 1L)), agged.collectAsList());",
        "ins2PreCode":"public void testTypedAggregationCount() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.count(v -> v)); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 2L), new Tuple2<>(\"b\", 1L)), agged.collectAsList());",
        "label":1
    },
    {
        "ins1AddCode":"if (e == null) { }",
        "ins1DelCode":"if (e == null)",
        "ins1PreCode":"for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == TreeModelListener.class) {  if (e == null) e = new TreeModelEvent(",
        "ins2PreCode":"for (int i = listeners.length - 2; i >= 0; i -= 2) { if (listeners[i] == TreeModelListener.class) { if (e == null) e = new TreeModelEvent(",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length)); Assert.assertTrue( arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length)); Assert.assertTrue( arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength())); Assert.assertTrue( arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));",
        "ins1DelCode":"Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength()));",
        "ins1PreCode":"Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } }  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength())); } } finally {",
        "ins2PreCode":"Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } } for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength())); } } finally {",
        "label":1
    },
    {
        "ins1AddCode":"String localUrl = getLocalUrl(\"https\", \"/test.txt\"); assertThatIOException().isThrownBy(() -> getResponse(localUrl, requestFactory));",
        "ins1DelCode":"getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory);",
        "ins1PreCode":".build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory);",
        "ins2PreCode":".build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory( httpClient); assertThat(getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory))",
        "label":0
    },
    {
        "ins1AddCode":"if (!Model.getFacade().isATransition(target)) { return; }",
        "ins1DelCode":"if (!Model.getFacade().isATransition(target)) return;",
        "ins1PreCode":" public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target); super.actionPerformed(e);",
        "ins2PreCode":"public void actionPerformed(ActionEvent e) { Object target = TargetManager.getInstance().getModelTarget(); if (!Model.getFacade().isATransition(target)) return; setTarget(target); super.actionPerformed(e);",
        "label":1
    },
    {
        "ins1AddCode":"public void preHandleSuccessfulWithFullAccess() {",
        "ins1DelCode":"public void preHandleSuccessfulWithFullAccess() throws Exception {",
        "ins1PreCode":"public void preHandleSuccessfulWithFullAccess() throws Exception { String accessToken = mockAccessToken(); given(this.securityService.getAccessLevel(accessToken, \"my-app-id\"))",
        "ins2PreCode":"public void preHandleSuccessfulWithRestrictedAccess() throws Exception { String accessToken = mockAccessToken(); given(this.securityService.getAccessLevel(accessToken, \"my-app-id\"))",
        "label":1
    },
    {
        "ins1AddCode":"if (sel instanceof SelectionButtons) { ((SelectionButtons) sel).hideButtons();",
        "ins1DelCode":"if (sel instanceof SelectionClass) { ((SelectionClass) sel).hideButtons();",
        "ins1PreCode":"Editor ce = Globals.curEditor(); if (ce != null) { Selection sel = ce.getSelectionManager().findSelectionFor(this); if (sel instanceof SelectionClass) { ((SelectionClass) sel).hideButtons(); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + short.class.getCanonicalName());",
        "ins1DelCode":"throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to short\");",
        "ins1PreCode":") { return ((Number)value).shortValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to short\"); }",
        "ins2PreCode":") { return ((Number)value).intValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to int\"); }",
        "label":1
    },
    {
        "ins1AddCode":"throw new IllegalArgumentException(\"Invalid role name [\" + rolename + \"]\");",
        "ins1DelCode":"throw new IllegalArgumentException (\"Invalid role name '\" + rolename + \"'\");",
        "ins1PreCode":"} Role role = group.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException (\"Invalid role name '\" + rolename + \"'\"); } group.removeRole(role);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void testIgnoreNewLine() {",
        "ins1DelCode":"public void testIgnoreNewLine() {",
        "ins1PreCode":"public void testIgnoreNewLine() { BibEntry entry = new BibEntry(); entry.setField(StandardField.AUTHOR, \"Last, First and\\nDoe, Jane\");",
        "ins2PreCode":"public void testIgnoreCarriageReturnNewLine() { BibEntry entry = new BibEntry(); entry.setField(StandardField.AUTHOR, \"Last, First and\\r\\nDoe, Jane\");",
        "label":1
    },
    {
        "ins1AddCode":"j.jenkins.setAuthorizationStrategy(new ProjectMatrixAuthorizationStrategy());",
        "ins1DelCode":"",
        "ins1PreCode":"public void propertyFiltering() throws Exception { DumbSlave.DescriptorImpl descriptor = j.getInstance().getDescriptorByType(DumbSlave.DescriptorImpl.class); DescriptorExtensionList<NodeProperty<?>, NodePropertyDescriptor> descriptors = NodeProperty.all();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult);",
        "ins1DelCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);",
        "ins1PreCode":"public void testNestedFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"nested.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  assertEquals(expectedCrossingResult, crossingResult);",
        "ins2PreCode":"public void testCrossRef() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"crossref.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); assertEquals(expectedCrossingResult, crossingResult);",
        "label":1
    },
    {
        "ins1AddCode":"NotificationUtils.sendNotification( \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\");",
        "ins1DelCode":"AbstractNotification notification = new DatabaseNotification( \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\", DBPMessageType.WARNING, null); NotificationsUi.getService().notify( Collections.singletonList(notification));",
        "ins1PreCode":"throw new InvocationTargetException(e); }  AbstractNotification notification = new DatabaseNotification( context.getDataSource(), \"commit\", \"Transaction has been committed\\n\\n\" + \"Query count: \" + txnInfo.getUpdateCount() + \"\\n\" + \"Duration: \" + RuntimeUtils.formatExecutionTime(System.currentTimeMillis() - txnInfo.getTransactionStartTime()) + \"\\n\", DBPMessageType.WARNING, null); NotificationsUi.getService().notify( Collections.singletonList(notification));  ",
        "ins2PreCode":"throw new InvocationTargetException(e); } throws InvocationTargetException, InterruptedException { throw new InvocationTargetException(e); public void run(DBRProgressMonitor monitor) DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); txnManager.rollback(session, null); try (DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\")) { if (txnManager != null) { throw new InvocationTargetException(e); DBCTransactionManager txnManager = DBUtils.getTransactionManager(context);",
        "label":0
    },
    {
        "ins1AddCode":"public void testPropertyContext() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"public void testPropertyContext() throws Exception { final SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testPropertyContext() throws Exception { final SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyContext\"); Map<String, String> map = results.get(0); assertEquals(2, map.size()); assertEquals(\"col_a value\", map.get(\"COL_A\")); assertEquals(\"col_b value\", map.get(\"COL_B\")); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testParametersInAttribute() throws Exception { final SqlSession sqlSession = sqlSessionFactory.openSession(); try { List<Map<String, String>> results = sqlSession.selectList(\"org.apache.ibatis.submitted.include_property.Mapper.selectPropertyInAttribute\"); Map<String, String> map = results.get(0); assertEquals(2, map.size()); assertEquals(\"col_a value\", map.get(\"COL_1\")); assertEquals(\"col_b value\", map.get(\"COL_2\")); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"consumers.put(\"script\", o -> internal.setScript(Script.parse(o)));",
        "ins1DelCode":"consumers.put(\"script\", o -> internal.setScript(parseScript(o)));",
        "ins1PreCode":" Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"script\", o -> internal.setScript(parseScript(o))); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue())); ",
        "ins2PreCode":"Map<String, Consumer<Object>> consumers = new HashMap<>(); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"conflicts\", o -> internal.setConflicts((String) o)); consumers.put(\"max_docs\", s -> setMaxDocsValidateIdentical(internal, ((Number) s).intValue()));",
        "label":0
    },
    {
        "ins1AddCode":"\" expected a single matching bean to replace \" + \"but found [example1, example2]\"); + \" expected a single matching bean to replace but found [example1, example2]\");",
        "ins1DelCode":"+ \" expected a single matching bean to replace \" + \"but found [example1, example2]\");",
        "ins1PreCode":"context.register(MultipleBeans.class); assertThatIllegalStateException().isThrownBy(context::refresh) .withMessageContaining(\"Unable to register mock bean \" + ExampleService.class.getName() + \" expected a single matching bean to replace \" + \"but found [example1, example2]\");",
        "ins2PreCode":"context.register(MultipleQualifiedBeans.class); assertThatIllegalStateException().isThrownBy(context::refresh) .withMessageContaining(\"Unable to register mock bean \" + ExampleService.class.getName() + \" expected a single matching bean to replace \" + \"but found [example1, example3]\");",
        "label":1
    },
    {
        "ins1AddCode":"assert node != null; throw new IllegalArgumentException( \"Node is not a recognised type. Received \" + node.getClass().getName());",
        "ins1DelCode":"return null;",
        "ins1PreCode":"figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.debug(\"TODO: StateDiagramRenderer getFigNodeFor\"); return null; } ",
        "ins2PreCode":"figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.error(\"TODO: CollabDiagramRenderer getFigNodeFor\"); return figNode; }",
        "label":0
    },
    {
        "ins1AddCode":"getTomcatInstanceTestWebapp(false, true);",
        "ins1DelCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start();",
        "ins1PreCode":"public void testDoForward() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = new ByteChunk();",
        "ins2PreCode":"public void testBug54011() throws Exception { int rc = getUrl(\"http://localhost:\" + getPort() + ByteChunk res = new ByteChunk(); \"/test/bug5nnnn/bug54012.jsp\", res, null); int rc = getUrl(\"http://localhost:\" + getPort() + ByteChunk res = new ByteChunk();",
        "label":0
    },
    {
        "ins1AddCode":"setState(424); switch ( getInterpreter().adaptivePredict(_input,38,_ctx) ) { setState(411); setState(412); setState(417); setState(413); setState(414); setState(419); setState(420); setState(422); setState(423);",
        "ins1DelCode":"setState(427); switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) { setState(414); setState(415); setState(420); setState(416); setState(417); setState(422); setState(423); setState(425); setState(426);",
        "ins1PreCode":"enterRule(_localctx, 50, RULE_listinitializer); int _la; try { setState(427); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,39,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(414); match(LBRACE); setState(415); expression(0); setState(420); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(416); match(COMMA); setState(417); expression(0); } } setState(422); _errHandler.sync(this); _la = _input.LA(1); } setState(423); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(425); match(LBRACE); setState(426); match(RBRACE); }",
        "ins2PreCode":"enterRule(_localctx, 52, RULE_mapinitializer); int _la; try { setState(427); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(440); match(LBRACE); setState(435); exitRule(); setState(440); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(426); match(COMMA); setState(427); exitRule(); } } setState(426); _errHandler.sync(this); _la = _input.LA(1); } setState(426); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(426); match(LBRACE); setState(426); match(RBRACE); }",
        "label":1
    },
    {
        "ins1AddCode":"Object unused1 = new Object() {}; Object unused2 = new Object() {}; Object unused3 = new Object() {}; Object unused4 = new Object() {}; Object unused5 = new Object() {}; Object unused6 = new Object() {}; Object unused7 = new Object() {}; Object unused8 = new Object() {}; Object unused9 = new Object() {};",
        "ins1DelCode":"Object o1 = new Object() {}; Object o2 = new Object() {}; Object o3 = new Object() {}; Object o4 = new Object() {}; Object o5 = new Object() {}; Object o6 = new Object() {}; Object o7 = new Object() {}; Object o8 = new Object() {}; Object o9 = new Object() {};",
        "ins1PreCode":"public void testToStringHelper_moreThanNineAnonymousClasses() {  Object o1 = new Object() {}; Object o2 = new Object() {}; Object o3 = new Object() {}; Object o4 = new Object() {}; Object o5 = new Object() {}; Object o6 = new Object() {}; Object o7 = new Object() {}; Object o8 = new Object() {}; Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = MoreObjects.toStringHelper(o10).toString();",
        "ins2PreCode":"public void testToStringHelperLenient_moreThanNineAnonymousClasses() { Object o1 = new Object() {}; Object o2 = new Object() {}; Object o3 = new Object() {}; Object o4 = new Object() {}; Object o5 = new Object() {}; Object o6 = new Object() {}; Object o7 = new Object() {}; Object o8 = new Object() {}; Object o9 = new Object() {}; Object o10 = new Object() {}; String toTest = MoreObjects.toStringHelper(o10).toString();",
        "label":1
    },
    {
        "ins1AddCode":"void completeValueReturnsValue() { database.insertEntry(entry); Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"testValue\")));",
        "ins1DelCode":"public void completeValueReturnsValue() { autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"testValue\")));",
        "ins1PreCode":"public void completeValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "ins2PreCode":"public void completeBeginningOfValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"test\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"protected void rdataFromString(Tokenizer st, Name origin) throws IOException {",
        "ins1DelCode":"void rdataFromString(Tokenizer st, Name origin) throws IOException {",
        "ins1PreCode":"void rdataFromString(Tokenizer st, Name origin) throws IOException { hashAlg = st.getUInt8(); flags = st.getUInt8();",
        "ins2PreCode":"void rdataFromString(Tokenizer st, Name origin) throws IOException { hashAlg = st.getUInt8(); flags = st.getUInt8();",
        "label":1
    },
    {
        "ins1AddCode":"NestedObjectCommand<ExasolScript, PropertyHandler> command, Map<String, Object> options)",
        "ins1DelCode":"org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolScript, SQLObjectEditor<ExasolScript, ExasolSchema>.PropertyHandler> command)",
        "ins1PreCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolScript, SQLObjectEditor<ExasolScript, ExasolSchema>.PropertyHandler> command) { if (command.getProperty(\"description\") != null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception {",
        "ins1DelCode":"public void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception {",
        "ins1PreCode":"public void validateTokenWhenKidValidationFailsTwiceShouldThrowException() throws Exception { ReflectionTestUtils.setField(this.tokenValidator, \"tokenKeys\", INVALID_KEYS); given(this.securityService.fetchTokenKeys()).willReturn(INVALID_KEYS);",
        "ins2PreCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS); given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);",
        "label":1
    },
    {
        "ins1AddCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) {",
        "ins1DelCode":"public final void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) {",
        "ins1PreCode":"public final void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) {",
        "ins2PreCode":"public final void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) {",
        "label":1
    },
    {
        "ins1AddCode":"(\"Exception destroying user [\" + username + \"] MBean\");",
        "ins1DelCode":"(\"Exception destroying user \" + user + \" MBean\");",
        "ins1PreCode":"database.removeUser(user); } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying user \" + user + \" MBean\"); iae.initCause(e); throw iae;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (isNullAt(ordinal)) return null; final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize;",
        "ins1DelCode":"assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal);",
        "ins1PreCode":"public UnsafeRow getStruct(int ordinal, int numFields) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeRow row = new UnsafeRow(numFields); row.pointTo(baseObject, baseOffset + offset, size);",
        "ins2PreCode":"public UnsafeRow getStruct(int ordinal, int numFields) { final long offsetAndSize = getLong(ordinal); final long offsetAndSize = getLong(ordinal); return null; final int size = (int) offsetAndSize; final UnsafeRow row = new UnsafeRow(numFields); row.pointTo(baseObject, baseOffset + offset, size);",
        "label":0
    },
    {
        "ins1AddCode":"c.close();",
        "ins1DelCode":"",
        "ins1PreCode":"configuration.setEnvironment(environment);  configuration.addMapper(MultipleReverseIncludePersonMapper.class);  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"configuration.setEnvironment(environment); configuration.addMapper(ReverseIncludePersonMapper.class); return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1AddCode":"FreeStyleProject curProject = j.createFreeStyleProject(curJobName); FreeStyleProject p = j.createFreeStyleProject(jobName);",
        "ins1DelCode":"FreeStyleProject curProject = createFreeStyleProject(curJobName); FreeStyleProject p = createFreeStyleProject(jobName);",
        "ins1PreCode":"final String curJobName = \"curJobName\"; final String jobName = \"jobName\"; final String displayName = \"displayName\"; FreeStyleProject curProject = createFreeStyleProject(curJobName); curProject.setDisplayName(\"currentProjectDisplayName\");  FreeStyleProject p = createFreeStyleProject(jobName); p.setDisplayName(displayName); ",
        "ins2PreCode":"final String curJobName = \"curJobName\"; final String jobName = \"jobName\"; final String displayName = \"displayName\"; FreeStyleProject curProject = createFreeStyleProject(curJobName); curProject.setDisplayName(\"currentProjectDisplayName\"); FreeStyleProject p = createFreeStyleProject(jobName); p.setDisplayName(displayName);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(res.toString().contains(\"<p><b>message</b> <u>\" + ErrorServlet.ERROR_TEXT + \"</u></p>\"));",
        "ins1DelCode":"Assert.assertTrue(res.toString().contains(ErrorServlet.ERROR_TEXT));",
        "ins1PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort());  Assert.assertTrue(res.toString().contains(ErrorServlet.ERROR_TEXT));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"set.add(new ZbMATH(importFormatPreferences));",
        "ins1DelCode":"",
        "ins1PreCode":"set.add(new MedlineFetcher()); set.add(new TitleFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins2PreCode":"set.add(new CrossRef()); set.add(new DoiFetcher(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); set.add(new DoiFetcher(importFormatPreferences)); set.add(new IsbnFetcher(importFormatPreferences));",
        "label":0
    },
    {
        "ins1AddCode":"void socketChannelClosedTriggersTunnelClose() throws Exception {",
        "ins1DelCode":"public void socketChannelClosedTriggersTunnelClose() throws Exception {",
        "ins1PreCode":"public void socketChannelClosedTriggersTunnelClose() throws Exception { TunnelClient client = new TunnelClient(0, this.tunnelConnection); int port = client.start();",
        "ins2PreCode":"public void stopTriggersTunnelClose() throws Exception { TunnelClient client = new TunnelClient(0, this.tunnelConnection); int port = client.start();",
        "label":1
    },
    {
        "ins1AddCode":"private void testParseMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder().setI(123).build().toByteString()) .build()) .build(); TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension(TestMessageSetExtension1.messageSetExtension).getI());",
        "ins1DelCode":"private void testParseMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { int TYPE_ID_1 = TestMessageSetExtension1 .getDescriptor().getExtensions().get(0).getNumber(); RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder() .setI(123) .build().toByteString()) .build()) .build(); TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension( TestMessageSetExtension1.messageSetExtension).getI());",
        "ins1PreCode":"private void testParseMessageSetExtensionWithFlag(boolean eagerParsing) throws Exception { ExtensionRegistryLite.setEagerlyParseMessageSets(eagerParsing); ExtensionRegistry extensionRegistry = ExtensionRegistry.newInstance(); extensionRegistry.add(TestMessageSetExtension1.messageSetExtension);   int TYPE_ID_1 = TestMessageSetExtension1 .getDescriptor().getExtensions().get(0).getNumber(); RawMessageSet raw = RawMessageSet.newBuilder() .addItem( RawMessageSet.Item.newBuilder() .setTypeId(TYPE_ID_1) .setMessage( TestMessageSetExtension1.newBuilder() .setI(123) .build().toByteString()) .build()) .build();  ByteString data = raw.toByteString();   TestMessageSet messageSet = TestMessageSet.parseFrom(data, extensionRegistry); assertEquals(123, messageSet.getExtension( TestMessageSetExtension1.messageSetExtension).getI());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriberEx<String> ts = new TestSubscriberEx<>(subscriber);",
        "ins1DelCode":"TestSubscriberEx<String> ts = new TestSubscriberEx<String>(subscriber);",
        "ins1PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber();  InOrder inOrder = inOrder(subscriber); TestSubscriberEx<String> ts = new TestSubscriberEx<String>(subscriber);  obs.observeOn(Schedulers.computation()).subscribe(ts);",
        "ins2PreCode":"Observer<String> observer = TestHelper.mockObserver(); InOrder inOrder = inOrder(observer); TestObserverEx<String> to = new TestObserverEx<String>(observer); obs.observeOn(Schedulers.computation()).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void customFusion() { final TestObserver<Integer> to = new TestObserver<Integer>();  TakeLast source = new TakeLast(new Observer<Integer>() {",
        "ins2PreCode":"public void customFusionClear() { final TestObserver<Integer> to = new TestObserver<Integer>(); TakeLast source = new TakeLast(new Observer<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"result.append(\", Digests: \"); result.append(mgr.digests.size());",
        "ins1PreCode":"result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Digests: \"); result.append(mgr.digests.size()); result.append(\", Randoms: \"); result.append(mgr.randoms.size());",
        "ins2PreCode":"result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Digests: \"); result.append(mgr.digests.size()); result.append(\", Randoms: \"); result.append(mgr.randoms.size());",
        "label":1
    },
    {
        "ins1AddCode":"SQLObjectEditor.NestedObjectCommand<ExasolFunction, SQLObjectEditor<ExasolFunction, ExasolSchema>.PropertyHandler> command) SQLUtils.quoteString(command.getObject(), command.getObject().getDescription())));",
        "ins1DelCode":"org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolFunction, SQLObjectEditor<ExasolFunction, ExasolSchema>.PropertyHandler> command) SQLUtils.quoteString(command.getObject().getDescription())));",
        "ins1PreCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolFunction, SQLObjectEditor<ExasolFunction, ExasolSchema>.PropertyHandler> command) { if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON FUNCTION \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS \" + SQLUtils.quoteString(command.getObject().getDescription()))); }",
        "ins2PreCode":"protected void addObjectExtraActions(List<DBEPersistAction> actions, org.jkiss.dbeaver.model.impl.sql.edit.SQLObjectEditor.NestedObjectCommand<ExasolScript, SQLObjectEditor<ExasolScript, ExasolSchema>.PropertyHandler> command) { if (command.getProperty(\"description\") != null) { actions.add(new SQLDatabasePersistAction(\"Comment on Script\",\"COMMENT ON SCRIPT \" + command.getObject().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" IS \" + SQLUtils.quoteString(command.getObject().getDescription()))); }",
        "label":0
    },
    {
        "ins1AddCode":"if (command.getProperties().containsKey(DBConstants.PROP_ID_ENABLED)) {",
        "ins1DelCode":"if (command.getProperties().containsKey(\"enabled\")) {",
        "ins1PreCode":"ObjectChangeCommand command, Map<String, Object> options) { final ExasolTableForeignKey constraint = command.getObject();  if (command.getProperties().containsKey(\"enabled\")) { actionList.add( new SQLDatabasePersistAction(\"Alter FK\",",
        "ins2PreCode":"ObjectChangeCommand command, Map<String, Object> options) final ExasolTableUniqueKey constraint = command.getObject(); if (command.getProperties().containsKey(\"enabled\")) actionList.add( new SQLDatabasePersistAction(\"Alter PK\",",
        "label":1
    },
    {
        "ins1AddCode":"addPropertiesToEnvironment(this.context,",
        "ins1DelCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins1PreCode":"public void parseLevelsCaseInsensitive() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=TrAcE\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins2PreCode":"public void parseLevelsTrimsWhitespace() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot= trace \"); this.initializer.initialize(this.context.getEnvironment(),",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset<String,String> newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1DelCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":" Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}};  CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);  LocalListener l = new LocalListener();",
        "ins2PreCode":"Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}}; = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); LocalListener l = new LocalListener();",
        "label":1
    },
    {
        "ins1AddCode":"void bindToArrayShouldUsePropertyEditor() {",
        "ins1DelCode":"public void bindToArrayShouldUsePropertyEditor() {",
        "ins1PreCode":"public void bindToArrayShouldUsePropertyEditor() {  MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "ins2PreCode":"public void bindToCollectionShouldUsePropertyEditor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource();",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"setDatasetGroup(dataset.getGroup());",
        "ins1PreCode":" this.dataset = dataset; if (dataset != null) { setDatasetGroup(dataset.getGroup()); dataset.addChangeListener(this); }",
        "ins2PreCode":"this.dataset = dataset; if (dataset != null) { setDatasetGroup(dataset.getGroup()); dataset.addChangeListener(this); }",
        "label":1
    },
    {
        "ins1AddCode":"g2.addURLSeries(new ArrayList<>(u2));",
        "ins1DelCode":"g2.addURLSeries(new java.util.ArrayList(u2));",
        "ins1PreCode":"u2.add(\"URL XXX\"); g1.addURLSeries(u2); assertFalse(g1.equals(g2)); g2.addURLSeries(new java.util.ArrayList(u2)); assertTrue(g1.equals(g2));",
        "ins2PreCode":"u2.add(\"URL XXX\"); g1.addURLSeries(u2); assertFalse(g1.equals(g2)); g2.addURLSeries(new java.util.ArrayList(u2)); assertTrue(g1.equals(g2));",
        "label":1
    },
    {
        "ins1AddCode":"GrayPaintScale g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"GrayPaintScale g2 = (GrayPaintScale) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { GrayPaintScale g1 = new GrayPaintScale(); GrayPaintScale g2 = (GrayPaintScale) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public synchronized StaticRoutingDecisionProvider addBlacklistSignature(@NonNull String signature) {",
        "ins1DelCode":"public synchronized StaticRoutingDecisionProvider addBlacklistSignature(@Nonnull String signature) {",
        "ins1PreCode":"public synchronized StaticRoutingDecisionProvider addBlacklistSignature(@Nonnull String signature) { if (this.blacklistSignaturesFromUserControlledList.add(signature)) { LOGGER.log(Level.INFO, \"Signature [{0}] added to the blacklist\", signature);",
        "ins2PreCode":"public synchronized StaticRoutingDecisionProvider remove(@Nonnull String signature) { if (this.whitelistSignaturesFromUserControlledList.remove(signature)) { LOGGER.log(Level.INFO, \"Signature [{0}] removed from the whitelist\", signature);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWeb.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"DefaultXYDataset<String> d = new DefaultXYDataset<>();",
        "ins1DelCode":"DefaultXYDataset d = new DefaultXYDataset();",
        "ins1PreCode":"public void testFindLiveItemsLowerBound_Unordered() { DefaultXYDataset d = new DefaultXYDataset();  ",
        "ins2PreCode":"public void testFindLiveItemsLowerBound_Ascending() { DefaultXYDataset d = new DefaultXYDataset() {",
        "label":0
    },
    {
        "ins1AddCode":"endSource = Objects.requireNonNull(closingIndicator.apply(startItem), \"The closingIndicator returned a null ObservableSource\");",
        "ins1DelCode":"endSource = ObjectHelper.requireNonNull(closingIndicator.apply(startItem), \"The closingIndicator returned a null ObservableSource\");",
        "ins1PreCode":" ObservableSource<V> endSource; try { endSource = ObjectHelper.requireNonNull(closingIndicator.apply(startItem), \"The closingIndicator returned a null ObservableSource\"); } catch (Throwable ex) { upstream.dispose();",
        "ins2PreCode":"Publisher<V> endSource; try { endSource = ObjectHelper.requireNonNull(closingIndicator.apply(startItem), \"The closingIndicator returned a null Publisher\"); } catch (Throwable ex) { upstream.cancel();",
        "label":1
    },
    {
        "ins1AddCode":"TesterAccessLogValve alv = new TesterAccessLogValve(); ctx.getPipeline().addValve(alv); List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > 0); assertTrue(entry.toString(), entry.getTime() < REQUEST_TIME);",
        "ins1DelCode":"",
        "ins1PreCode":" ctx.addApplicationListener(TrackingRequestListener.class.getName());  tomcat.start();  StringBuilder url = new StringBuilder(48); url.append(\"http://localhost:\"); url.append(getPort()); url.append(\"/stage1?iter=\"); url.append(iter); if (useThread) { url.append(\"&useThread=y\"); } ByteChunk res = getUrl(url.toString());  StringBuilder expected = new StringBuilder(\"requestInitialized-\"); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); loop--; } expected.append(\"NonAsyncServletGet-\"); expected.append(\"requestDestroyed\"); assertEquals(expected.toString(), res.toString());",
        "ins2PreCode":"ctx.addApplicationListener(TrackingRequestListener.class.getName()); tomcat.start(); StringBuilder url = new StringBuilder(48); url.append(\"http://localhost:\"); url.append(getPort()); url.append(\"/stage1?iter=\"); url.append(iter); if (useThread) { url.append(\"&useThread=y\"); } ByteChunk res = getUrl(url.toString()); StringBuilder expected = new StringBuilder(\"requestInitialized-\"); int loop = iter; while (loop > 0) { expected.append(\"DispatchingServletGet-\"); loop--; } expected.append(\"DispatchingServletGet-\"); expected.append(\"ErrorServletGet-onError-onComplete-requestDestroyed\"); assertEquals(expected.toString(), res.toString());",
        "label":1
    },
    {
        "ins1AddCode":".schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>, \" + \"ints array<int>\")",
        "ins1DelCode":".schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>\")",
        "ins1PreCode":"Dataset<ArrayRecord> dataset = spark .read() .format(\"json\") .schema(\"id int, intervals array<struct<startTime: bigint, endTime: bigint>>\") .load(\"src/test/resources/test-data/with-array-fields.json\") .as(encoder);",
        "ins2PreCode":"Dataset<MapRecord> dataset = spark .read() .format(\"json\") .schema(\"id int, intervals map<string, struct<startTime: bigint, endTime: bigint>>\") .load(\"src/test/resources/test-data/with-map-fields.json\") .as(encoder);",
        "label":0
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (count++ == 1) { return null; } else { return new ArrayList<Integer>(); } }",
        "ins2PreCode":"if (count++ == 1) { return null; } else { return new ArrayList<Integer>(); } }",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<List<String>> rdd = jsc.parallelize(Arrays.asList( for (FPGrowth.FreqItemset<String> itemset : freqItemsets) {",
        "ins1DelCode":"JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {",
        "ins1PreCode":"public void runFPGrowth() {  @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  List<FPGrowth.FreqItemset<String>> freqItemsets = model.freqItemsets().toJavaRDD().collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {  List<String> items = itemset.javaItems();",
        "ins2PreCode":"public void runFPGrowthSaveLoad() { @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2); FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD() assertEquals(18, freqItemsets.size()); for (FPGrowth.FreqItemset<String> itemset: freqItemsets) { List<String> items = itemset.javaItems();",
        "label":0
    },
    {
        "ins1AddCode":"String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type; if (innerHits.containsKey(name)) { throw new IllegalArgumentException(\"[inner_hits] already contains an entry for key [\" + name + \"]\"); }",
        "ins1DelCode":"String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type;",
        "ins1PreCode":"protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) { if (innerHitBuilder != null) { Map<String, InnerHitContextBuilder> children = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(query, children); String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : type; InnerHitContextBuilder innerHitContextBuilder = new ParentChildInnerHitContextBuilder(type, true, query, innerHitBuilder, children); innerHits.put(name, innerHitContextBuilder); }",
        "ins2PreCode":"public void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) { if (innerHitBuilder != null) { Map<String, InnerHitContextBuilder> children = new HashMap<>(); InnerHitContextBuilder.extractInnerHits(query, children); String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : path; innerHits.put(name, innerHitContextBuilder); InnerHitContextBuilder.extractInnerHits(query, children); innerHits.put(name, innerHitContextBuilder); }",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Jenkins.READ, Item.READ)",
        "ins1DelCode":".authorizedTo(Jenkins.READ, Job.READ)",
        "ins1PreCode":"@Test public void dummyRangeShouldFailIfJobNameIsEmpty() { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(\"\", \"1\"); assertThat(result, failedWith(3));",
        "ins2PreCode":"@Test public void dummyRangeShouldFailIfJobNameIsSpace() { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(\" \", \"1\"); assertThat(result, failedWith(3));",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession session = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession session = sqlSessionFactory.openSession(); try { } finally { session.close();",
        "ins1PreCode":"public void shouldGetBlogsWithAuthorsAndPosts() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); List<Blog> blogs = mapper.selectBlogsWithAutorAndPosts(); assertEquals(2, blogs.size()); assertTrue(blogs.get(0) instanceof Proxy); assertEquals(101, blogs.get(0).getAuthor().getId()); assertEquals(1, blogs.get(0).getPosts().size()); assertEquals(1, blogs.get(0).getPosts().get(0).getId()); assertTrue(blogs.get(1) instanceof Proxy); assertEquals(102, blogs.get(1).getAuthor().getId()); assertEquals(1, blogs.get(1).getPosts().size()); assertEquals(2, blogs.get(1).getPosts().get(0).getId()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldGetBlogsWithAuthorsAndPostsEagerly() { SqlSession session = sqlSessionFactory.openSession(); try { BoundBlogMapper mapper = session.getMapper(BoundBlogMapper.class); List<Blog> blogs = mapper.selectBlogsWithAutorAndPostsEagerly(); assertEquals(2, blogs.size()); assertFalse(blogs.get(0) instanceof Factory); assertEquals(101, blogs.get(0).getAuthor().getId()); assertEquals(1, blogs.get(0).getPosts().size()); assertEquals(1, blogs.get(0).getPosts().get(0).getId()); assertFalse(blogs.get(1) instanceof Factory); assertEquals(102, blogs.get(1).getAuthor().getId()); assertEquals(1, blogs.get(1).getPosts().size()); assertEquals(2, blogs.get(1).getPosts().get(0).getId()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"AssertionError ae = bc.getError();",
        "ins1DelCode":"AssertionFailedError ae = bc.getError();",
        "ins1PreCode":"SubAntTest.BasedirChecker bc = new SubAntTest.BasedirChecker(dirs); buildRule.getProject().addBuildListener(bc); buildRule.executeTarget(target); AssertionFailedError ae = bc.getError(); if (ae != null) { throw ae;",
        "ins2PreCode":"BasedirChecker bc = new BasedirChecker(dirs); buildRule.getProject().addBuildListener(bc); buildRule.executeTarget(target); AssertionFailedError ae = bc.getError(); if (ae != null) { throw ae;",
        "label":1
    },
    {
        "ins1AddCode":"Object b = new Object(); v.add(b); assertSame(b, v.elementAt(1));",
        "ins1DelCode":"v.add(new Object());",
        "ins1PreCode":"v = new VectorSet(3, 1); Object a = new Object(); v.add(a); v.add(new Object()); v.add(O); assertEquals(3, v.size());",
        "ins2PreCode":"v = new VectorSet(3, 1); Object a = new Object(); v.add(a); v.add(new Object()); v.add(O); assertEquals(3, v.size());",
        "label":1
    },
    {
        "ins1AddCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() { try (SqlSession session = sqlMapper.openSession()) {",
        "ins1DelCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { } finally { session.close();",
        "ins1PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"blog_id\", 1); }}); assertEquals(2, posts.size()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldFindPostsWithAuthorIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"author_id\", 101); }}); assertEquals(3, posts.size()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"SearchContext searchContext, Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException { long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, return asMultiBucketAggregator(this, searchContext, parent);",
        "ins1DelCode":"Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException { long maxOrd = valuesSource.globalMaxOrd(context.searcher()); return new ParentToChildrenAggregator(name, factories, context, parent, childFilter, return asMultiBucketAggregator(this, context, parent);",
        "ins1PreCode":"protected Aggregator doCreateInternal(WithOrdinals valuesSource, Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {  long maxOrd = valuesSource.globalMaxOrd(context.searcher()); if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, context, parent, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData); } else { return asMultiBucketAggregator(this, context, parent); }",
        "ins2PreCode":"protected Aggregator doCreateInternal(WithOrdinals valuesSource, Aggregator children, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException { long maxOrd = valuesSource.globalMaxOrd(context.searcher()); if (collectsFromSingleBucket) { return new ChildrenToParentAggregator(name, factories, context, children, childFilter, parentFilter, valuesSource, maxOrd, pipelineAggregators, metaData); } else { return asMultiBucketAggregator(this, context, children); }",
        "label":1
    },
    {
        "ins1AddCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=a,en-gb;q=0.5\")); Assert.assertEquals(Q0_500, actual.get(0).getQuality(), 0.0001);",
        "ins1DelCode":"List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=a\")); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "ins1PreCode":"public void testMalformed02() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=a\"));  Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "ins2PreCode":"public void testMalformed03() throws Exception { List<AcceptLanguage> actual = AcceptLanguage.parse(new StringReader(\"en-gb;q=0.5a\")); Assert.assertEquals(1, actual.size()); Assert.assertEquals(L_EN_GB, actual.get(0).getLocale()); Assert.assertEquals(Q0_000, actual.get(0).getQuality(), 0.0001);",
        "label":1
    },
    {
        "ins1AddCode":"void specificResourceAsFile() {",
        "ins1DelCode":"public void specificResourceAsFile() {",
        "ins1PreCode":"public void specificResourceAsFile() { String location = \"file:src/test/resources/specificlocation.properties\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void specificResourceDefaultsToFile() { String location = \"src/test/resources/specificlocation.properties\"; TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1AddCode":"void updateTimestampEnabled() {",
        "ins1DelCode":"public void updateTimestampEnabled() {",
        "ins1PreCode":"public void updateTimestampEnabled() { final String timestampField = \"timestamp\"; final String baseDate = \"2000-1-1\";",
        "ins2PreCode":"public void updateTimestampDisabled() { final String timestampField = \"timestamp\"; final String baseDate = \"2000-1-1\";",
        "label":1
    },
    {
        "ins1AddCode":"void testGetNamesAndItemsLinked() {",
        "ins1DelCode":"public void testGetNamesAndItemsLinked() {",
        "ins1PreCode":"public void testGetNamesAndItemsLinked() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins2PreCode":"public void testGetNamesAndItemsLinkedWithNoMatchingInfo() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"users, products, features, 0.7, false, false);",
        "ins1DelCode":"users, products, features, 0.7, false);",
        "ins1PreCode":"int users = 50; int products = 100; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, false);  JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "ins2PreCode":"int users = 100; int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, false); JavaRDD<Rating> data = sc.parallelize(testData._1());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<List<Integer>> ts = new TestSubscriber<>(); BufferExactUnboundedSubscriber<Integer, List<Integer>> sub = new BufferExactUnboundedSubscriber<>( ts, Functions.justSupplier((List<Integer>) new ArrayList<Integer>()), 1, TimeUnit.SECONDS, sch); sub.buffer = new ArrayList<>();",
        "ins1DelCode":"TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); BufferExactUnboundedSubscriber<Integer, List<Integer>> sub = new BufferExactUnboundedSubscriber<Integer, List<Integer>>( ts, Functions.justSupplier((List<Integer>)new ArrayList<Integer>()), 1, TimeUnit.SECONDS, sch); sub.buffer = new ArrayList<Integer>();",
        "ins1PreCode":"public void timedInternalState() { TestScheduler sch = new TestScheduler();  TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();  BufferExactUnboundedSubscriber<Integer, List<Integer>> sub = new BufferExactUnboundedSubscriber<Integer, List<Integer>>( ts, Functions.justSupplier((List<Integer>)new ArrayList<Integer>()), 1, TimeUnit.SECONDS, sch);  sub.onSubscribe(new BooleanSubscription());  assertFalse(sub.isDisposed());  sub.onError(new TestException()); sub.onNext(1); sub.onComplete();  sub.run();  sub.dispose();  assertTrue(sub.isDisposed());  sub.buffer = new ArrayList<Integer>(); sub.enter(); sub.onComplete();",
        "ins2PreCode":"public void timedInternalState() { TestScheduler sch = new TestScheduler(); TestObserver<List<Integer>> to = new TestObserver<List<Integer>>(); BufferExactUnboundedObserver<Integer, List<Integer>> sub = new BufferExactUnboundedObserver<Integer, List<Integer>>( to, Functions.justSupplier((List<Integer>)new ArrayList<Integer>()), 1, TimeUnit.SECONDS, sch); sub.onSubscribe(Disposable.empty()); assertFalse(sub.isDisposed()); sub.onError(new TestException()); sub.onNext(1); sub.onComplete(); sub.run(); sub.dispose(); assertTrue(sub.isDisposed()); sub.buffer = new ArrayList<Integer>(); sub.enter(); sub.onComplete();",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertNotNull(is);",
        "ins1DelCode":"assertNotNull(is);",
        "ins1PreCode":" HttpURLConnection conn = getConnection(\"http://localhost:\" + getPort() + \"/\"); InputStream is = conn.getInputStream(); assertNotNull(is);",
        "ins2PreCode":"HttpURLConnection conn = getConnection(\"http://localhost:\" + getPort() + \"/\"); InputStream is = conn.getInputStream(); assertNotNull(is);",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<List<List<Integer>>> sequences = jsc.parallelize(Arrays.asList( for (PrefixSpan.FreqSequence<Integer> freqSeq : localFreqSeqs) {",
        "ins1DelCode":"JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) {",
        "ins1PreCode":"public void runPrefixSpan() { JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences); JavaRDD<FreqSequence<Integer>> freqSeqs = model.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size());  for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence(); long freq = freqSeq.freq();",
        "ins2PreCode":"public void runPrefixSpanSaveLoad() { JavaRDD<List<List<Integer>>> sequences = sc.parallelize(Arrays.asList( Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3)), Arrays.asList(Arrays.asList(1), Arrays.asList(3, 2), Arrays.asList(1, 2)), Arrays.asList(Arrays.asList(1, 2), Arrays.asList(5)), Arrays.asList(Arrays.asList(6)) ), 2); PrefixSpan prefixSpan = new PrefixSpan() .setMinSupport(0.5) .setMaxPatternLength(5); PrefixSpanModel<Integer> model = prefixSpan.run(sequences); JavaRDD<FreqSequence<Integer>> freqSeqs = newModel.freqSequences().toJavaRDD(); List<FreqSequence<Integer>> localFreqSeqs = freqSeqs.collect(); Assert.assertEquals(5, localFreqSeqs.size()); for (PrefixSpan.FreqSequence<Integer> freqSeq: localFreqSeqs) { List<List<Integer>> seq = freqSeq.javaSequence(); long freq = freqSeq.freq();",
        "label":0
    },
    {
        "ins1AddCode":"HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1DelCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1PreCode":"int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value());",
        "ins1DelCode":"given(this.response.statusCode()).willReturn(HttpStatus.OK);",
        "ins1PreCode":"void filterShouldRecordTimer() { ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\")",
        "ins2PreCode":"void filterWhenUriTemplatePresentShouldRecordTimer() { ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")) given(this.response.statusCode()).willReturn(HttpStatus.OK); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\")",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, s1.indexOf(1.0));",
        "ins1DelCode":"assertEquals(0, s1.indexOf(new Double(1.0)));",
        "ins1PreCode":"s1.add(1.0, 1.0, 1.0, 2.0); s1.add(2.0, 2.0, 2.0, 3.0); s1.add(3.0, 3.0, 3.0, 4.0); assertEquals(0, s1.indexOf(new Double(1.0)));",
        "ins2PreCode":"s1.add(1.0, 1.0, 1.0, 2.0); s1.add(2.0, 2.0, 2.0, 3.0); s1.add(3.0, 3.0, 3.0, 4.0); assertEquals(0, s1.indexOf(new XYCoordinate(1.0, 1.0)));",
        "label":0
    },
    {
        "ins1AddCode":"void cloudFoundryPlatformActiveSetsCloudControllerUrl() {",
        "ins1DelCode":"public void cloudFoundryPlatformActiveSetsCloudControllerUrl() {",
        "ins1PreCode":"public void cloudFoundryPlatformActiveSetsCloudControllerUrl() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:https://my-cloud-controller.com\").run((context) -> {",
        "ins2PreCode":"public void cloudFoundryPlatformActiveSetsCloudControllerUrl() { this.contextRunner.withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:https://my-cloud-controller.com\").run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"source.subscribe(new BufferExactUnboundedObserver<>( new SerializedObserver<>(t), source.subscribe(new BufferExactBoundedObserver<>( new SerializedObserver<>(t), source.subscribe(new BufferSkipBoundedObserver<>( new SerializedObserver<>(t),",
        "ins1DelCode":"source.subscribe(new BufferExactUnboundedObserver<T, U>( new SerializedObserver<U>(t), source.subscribe(new BufferExactBoundedObserver<T, U>( new SerializedObserver<U>(t), source.subscribe(new BufferSkipBoundedObserver<T, U>( new SerializedObserver<U>(t),",
        "ins1PreCode":"protected void subscribeActual(Observer<? super U> t) { if (timespan == timeskip && maxSize == Integer.MAX_VALUE) { source.subscribe(new BufferExactUnboundedObserver<T, U>( new SerializedObserver<U>(t), bufferSupplier, timespan, unit, scheduler)); return; } Scheduler.Worker w = scheduler.createWorker();  if (timespan == timeskip) { source.subscribe(new BufferExactBoundedObserver<T, U>( new SerializedObserver<U>(t), bufferSupplier, timespan, unit, maxSize, restartTimerOnMaxSize, w )); return; }   source.subscribe(new BufferSkipBoundedObserver<T, U>( new SerializedObserver<U>(t), bufferSupplier, timespan, timeskip, unit, w)); ",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super U> s) { if (timespan == timeskip && maxSize == Integer.MAX_VALUE) { source.subscribe(new BufferExactUnboundedSubscriber<T, U>( new SerializedSubscriber<U>(s), bufferSupplier, timespan, unit, scheduler)); return; } Scheduler.Worker w = scheduler.createWorker(); if (timespan == timeskip) { source.subscribe(new BufferExactBoundedSubscriber<T, U>( new SerializedSubscriber<U>(s), bufferSupplier, timespan, unit, maxSize, restartTimerOnMaxSize, w )); return; } source.subscribe(new BufferSkipBoundedSubscriber<T, U>( new SerializedSubscriber<U>(s), bufferSupplier, timespan, timeskip, unit, w));",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertThat(cache.getName()).isEqualTo(\"default\"); Assertions.assertThat(mapper.ping()).isEqualTo(\"Hello\"); Assertions.assertThat(mapper.selectOne()).isEqualTo(\"1\"); Assertions.assertThat(mapper.selectFromVariable()).isEqualTo(\"9999\");",
        "ins1DelCode":"Assert.assertThat(cache.getName(), Is.is(\"default\")); Assert.assertThat(mapper.ping(), Is.is(\"Hello\")); Assert.assertThat(mapper.selectOne(), Is.is(\"1\")); Assert.assertThat(mapper.selectFromVariable(), Is.is(\"9999\"));",
        "ins1PreCode":"configuration.addMapper(XmlMapper.class); SupportClasses.CustomCache cache = SupportClasses.Utils.unwrap(configuration.getCache(XmlMapper.class.getName()));  Assert.assertThat(cache.getName(), Is.is(\"default\"));  SqlSession sqlSession = factory.openSession(); try { XmlMapper mapper = sqlSession.getMapper(XmlMapper.class);  Assert.assertThat(mapper.ping(), Is.is(\"Hello\")); Assert.assertThat(mapper.selectOne(), Is.is(\"1\")); Assert.assertThat(mapper.selectFromVariable(), Is.is(\"9999\"));  } finally {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void persistSession() throws Exception {",
        "ins1DelCode":"public void persistSession() throws Exception {",
        "ins1PreCode":"public void persistSession() throws Exception { AbstractServletWebServerFactory factory = getFactory(); factory.getSession().setPersistent(true);",
        "ins2PreCode":"public void disableDoesNotSaveSessionFiles() throws Exception { TomcatServletWebServerFactory factory = getFactory(); this.webServer = factory.getWebServer(sessionServletRegistration());",
        "label":0
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"test value\");",
        "ins1DelCode":"entry.setField(\"field\", \"test value\");",
        "ins1PreCode":"public void completeBeginnigOfSecondWordReturnsWord() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry); ",
        "ins2PreCode":"public void completePartOfWordReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"test value\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1AddCode":"this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler,",
        "ins1DelCode":"this.messageConverters, this.requestFactory, this.uriTemplateHandler,",
        "ins1PreCode":"Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers,",
        "ins2PreCode":"Collection<? extends ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, append(this.interceptors, interceptors));",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":" Observable<Integer> result = source.withLatestFrom(other, COMBINER);  TestObserverEx<Integer> to = new TestObserverEx<Integer>();  result.subscribe(to);",
        "ins2PreCode":"Observable<Integer> result = source.withLatestFrom(other, COMBINER); TestObserverEx<Integer> to = new TestObserverEx<Integer>(); result.subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"Defaults defaults = project.getUmlFactoryDefaults();",
        "ins1DelCode":"UmlFactoryDefaults defaults = project.getUmlFactoryDefaults();",
        "ins1PreCode":"}  Project project = ProjectManager.getManager().getCurrentProject(); UmlFactoryDefaults defaults = project.getUmlFactoryDefaults(); Object attr = Model.getUmlFactory().buildNode(Model.getMetaTypes().getAttribute(), classifier, null, defaults); TargetManager.getInstance().setTarget(attr);",
        "ins2PreCode":"} Project project = ProjectManager.getManager().getCurrentProject(); UmlFactoryDefaults defaults = project.getUmlFactoryDefaults(); Object attr = Model.getUmlFactory().buildNode(Model.getMetaTypes().getOperation(), classifier, null, defaults); TargetManager.getInstance().setTarget(attr);",
        "label":1
    },
    {
        "ins1AddCode":"Boolean premanagedOptional = DependencyManagerUtils.getPremanagedOptional( node ); if ( premanagedOptional != null && !premanagedOptional.equals( dep.getOptional() ) ) { buffer.append( \" (optionality managed from \" ).append( premanagedOptional ); appendManagementSource( buffer, art, \"optional\" ); buffer.append( ')' ); }",
        "ins1DelCode":"",
        "ins1PreCode":"buffer.append( ')' ); } } else { buffer.append( project.getGroupId() ); buffer.append( ':' ).append( project.getArtifactId() ); buffer.append( ':' ).append( project.getPackaging() ); buffer.append( ':' ).append( project.getVersion() ); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(out, \"out\"); Args.nullNotPermitted(chart, \"chart\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\");",
        "ins1PreCode":"int width, int height, ChartRenderingInfo info, boolean encodeAlpha, int compression) throws IOException {  ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\"); BufferedImage chartImage = chart.createBufferedImage(width, height, BufferedImage.TYPE_INT_ARGB, info);",
        "ins2PreCode":"int width, int height, ChartRenderingInfo info) throws IOException { ParamChecks.nullNotPermitted(out, \"out\"); ParamChecks.nullNotPermitted(chart, \"chart\"); BufferedImage image = chart.createBufferedImage(width, height, BufferedImage.TYPE_INT_RGB, info);",
        "label":1
    },
    {
        "ins1AddCode":"Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, null, config));",
        "ins1DelCode":"Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config));",
        "ins1PreCode":"asnOnlyProperties.remove(GeoIpProcessor.Property.IP); String asnProperty = RandomPicks.randomFrom(Randomness.get(), asnOnlyProperties).toString(); config.put(\"properties\", Collections.singletonList(asnProperty)); Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)); assertThat(e.getMessage(), equalTo(\"[properties] illegal property value [\" + asnProperty + \"]. valid values are [IP, COUNTRY_ISO_CODE, COUNTRY_NAME, CONTINENT_NAME]\"));",
        "ins2PreCode":"cityOnlyProperties.remove(GeoIpProcessor.Property.IP); String cityProperty = RandomPicks.randomFrom(Randomness.get(), cityOnlyProperties).toString(); config.put(\"properties\", Collections.singletonList(cityProperty)); Exception e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)); assertThat(e.getMessage(), equalTo(\"[properties] illegal property value [\" + cityProperty + \"]. valid values are [IP, ASN, ORGANIZATION_NAME]\"));",
        "label":1
    },
    {
        "ins1AddCode":"cd.add(Disposable.empty());",
        "ins1DelCode":"cd.add(Disposables.empty());",
        "ins1PreCode":"Runnable run2 = new Runnable() { @Override public void run() { cd.add(Disposables.empty()); } };",
        "ins2PreCode":"Runnable run2 = new Runnable() { @Override public void run() { cd.addAll(Disposables.empty()); } };",
        "label":1
    },
    {
        "ins1AddCode":"assertThatExceptionOfType(CloudFoundryAuthorizationException.class) .isThrownBy(() -> this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())))) .satisfies(reasonRequirement(Reason.TOKEN_EXPIRED));",
        "ins1DelCode":"this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.TOKEN_EXPIRED)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "ins1PreCode":"given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"jti\\\": \\\"0236399c350c47f3ae77e67a75e75e7d\\\", \\\"exp\\\": 1477509977, \\\"scope\\\": [\\\"actuator.read\\\"]}\"; this.thrown .expect(AuthorizationExceptionMatcher.withReason(Reason.TOKEN_EXPIRED)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "ins2PreCode":"given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS); String header = \"{ \\\"alg\\\": \\\"RS256\\\",  \\\"kid\\\": \\\"valid-key\\\", \\\"typ\\\": \\\"JWT\\\"}\"; String claims = \"{ \\\"exp\\\": 2147483647, \\\"iss\\\": \\\"http://localhost:8080/uaa/oauth/token\\\", \\\"scope\\\": [\\\"foo.bar\\\"]}\"; this.thrown.expect( AuthorizationExceptionMatcher.withReason(Reason.INVALID_AUDIENCE)); this.tokenValidator.validate( new Token(getSignedToken(header.getBytes(), claims.getBytes())));",
        "label":1
    },
    {
        "ins1AddCode":"void parseIgnoresCommentsAfterEntry() throws IOException {",
        "ins1DelCode":"public void parseIgnoresCommentsAfterEntry() throws IOException {",
        "ins1PreCode":"public void parseIgnoresCommentsAfterEntry() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test}}\" + \"@comment{some text and \\\\latex}\"));",
        "ins2PreCode":"public void parseIgnoresTextBeforeEntry() throws IOException { ParserResult result = parser .parse(new StringReader(\"comment{some text and \\\\latex\" + \"@article{test,author={Ed von Test}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception {",
        "ins1DelCode":"public void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception {",
        "ins1PreCode":"public void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\r\\n ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimWHEREANDWithTABForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\t ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void removeEdge_existingSelfLoopEdge() { assume().that(graphIsMutable()).isTrue(); assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"= new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new BoxAndWhiskerRenderer());",
        "ins2PreCode":"= new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 0.5, null, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new BoxAndWhiskerRenderer());",
        "label":1
    },
    {
        "ins1AddCode":"target.setLocation( \"properties\", InputLocation.merge( target.getLocation( \"properties\" ), source.getLocation( \"properties\" ), sourceDominant ) );",
        "ins1DelCode":"",
        "ins1PreCode":"merged.putAll( target.getProperties() ); } target.setProperties( merged );",
        "ins2PreCode":"merged.putAll( target.getProperties() ); } target.setProperties( merged );",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<?> plot = (XYPlot) chart.getPlot();",
        "ins1DelCode":"XYPlot<String> plot = (XYPlot) chart.getPlot();",
        "ins1PreCode":"DefaultXYDataset<String> dataset = new DefaultXYDataset<>(); JFreeChart chart = ChartFactory.createXYLineChart(\"Title\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, true, false, false); XYPlot<String> plot = (XYPlot) chart.getPlot(); plot.setRenderer(1, new XYLineAndShapeRenderer()); try {",
        "ins2PreCode":"DefaultXYDataset<String> dataset = new DefaultXYDataset<>(); JFreeChart chart = ChartFactory.createXYLineChart(\"Title\", \"X\", \"Y\", dataset, PlotOrientation.VERTICAL, true, false, false); XYPlot<String> plot = (XYPlot) chart.getPlot(); plot.setRenderer(null); try {",
        "label":1
    },
    {
        "ins1AddCode":".withMessageStartingWith(\"Search location '\").withMessageEndingWith(\"' must end with '*/'\");",
        "ins1DelCode":".withMessage(\"Wildcard patterns must end with '*/'\");",
        "ins1PreCode":"\"spring.config.location=\" + location); assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildcard patterns must end with '*/'\");",
        "ins2PreCode":"\"spring.config.location=\" + location); assertThatIllegalStateException() .isThrownBy(() -> this.initializer.postProcessEnvironment(this.environment, this.application)) .withMessage(\"Wildard pattern with multiple '*'s cannot be used as search location\");",
        "label":0
    },
    {
        "ins1AddCode":"(ShuffleWriteMetrics) args[4], (BlockId) args[0]",
        "ins1DelCode":"(ShuffleWriteMetrics) args[4]",
        "ins1PreCode":"(Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4] ); }",
        "ins2PreCode":"(Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4] ); }",
        "label":1
    },
    {
        "ins1AddCode":"figNode = (FigNode) ((UMLDiagram) diag).drop(node, null);",
        "ins1DelCode":"figNode = ((UMLDiagram) diag).drop(node, null);",
        "ins1PreCode":"Diagram diag = ((LayerPerspective) lay).getDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.debug(\"TODO: StateDiagramRenderer getFigNodeFor\");",
        "ins2PreCode":"Diagram diag = ((LayerPerspective) lay).getDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.error(\"TODO: CollabDiagramRenderer getFigNodeFor\");",
        "label":1
    },
    {
        "ins1AddCode":"this.environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(this.environment); initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile);",
        "ins1DelCode":"MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); this.loggingSystem.initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile);",
        "ins1PreCode":"void testMaxHistoryPropertyWithXmlConfiguration() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\"); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, \"classpath:logback-include-base.xml\", logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\");",
        "ins2PreCode":"private void testTotalSizeCapProperty(String sizeValue, String expectedFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", sizeValue); LoggingInitializationContext loggingInitializationContext = new LoggingInitializationContext(environment); File file = new File(tmpDir(), \"logback-test.log\"); LogFile logFile = getLogFile(file.getPath(), null); this.loggingSystem.initialize(loggingInitializationContext, null, logFile); this.logger.info(\"Hello world\"); assertThat(getLineWithText(file, \"Hello world\")).contains(\"INFO\");",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2));",
        "ins1DelCode":"JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });",
        "ins1PreCode":"Arrays.asList(9,10,11));  JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });  JavaTestUtils.attachTestOutputStream(transformed);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void addLogPathProperty() { \"logging.file.path=\" + this.tempDir); assertThat(output).startsWith(new File(this.tempDir.toFile(), \"spring.log\").getAbsolutePath());",
        "ins1DelCode":"public void addLogPathProperty() { \"logging.file.path=\" + this.temp.getRoot()); assertThat(output).startsWith(new File(this.temp.getRoot(), \"spring.log\").getAbsolutePath());",
        "ins1PreCode":"public void addLogPathProperty() { addPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.path=\" + this.temp.getRoot()); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class); String existingOutput = this.output.toString(); logger.info(\"Hello world\"); String output = this.output.toString().substring(existingOutput.length()).trim(); assertThat(output).startsWith(new File(this.temp.getRoot(), \"spring.log\").getAbsolutePath());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private void assertMapValuesCleared(TestMapOrBuilder testMapOrBuilder) { assertEquals(0, testMapOrBuilder.getInt32ToInt32Field().size()); assertEquals(0, testMapOrBuilder.getInt32ToInt32FieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToStringField().size()); assertEquals(0, testMapOrBuilder.getInt32ToStringFieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToBytesField().size()); assertEquals(0, testMapOrBuilder.getInt32ToBytesFieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToEnumField().size()); assertEquals(0, testMapOrBuilder.getInt32ToEnumFieldCount()); assertEquals(0, testMapOrBuilder.getInt32ToMessageField().size()); assertEquals(0, testMapOrBuilder.getInt32ToMessageFieldCount()); assertEquals(0, testMapOrBuilder.getStringToInt32Field().size()); assertEquals(0, testMapOrBuilder.getStringToInt32FieldCount());",
        "ins1DelCode":"private void assertMapValuesCleared(TestMap message) { assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToStringField().size()); assertEquals(0, message.getInt32ToBytesField().size()); assertEquals(0, message.getInt32ToEnumField().size()); assertEquals(0, message.getInt32ToMessageField().size()); assertEquals(0, message.getStringToInt32Field().size());",
        "ins1PreCode":"private void assertMapValuesCleared(TestMap message) { assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToStringField().size()); assertEquals(0, message.getInt32ToBytesField().size()); assertEquals(0, message.getInt32ToEnumField().size()); assertEquals(0, message.getInt32ToMessageField().size()); assertEquals(0, message.getStringToInt32Field().size());",
        "ins2PreCode":"private void assertMapValuesCleared(TestMap message) { assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToStringField().size()); assertEquals(0, message.getInt32ToBytesField().size()); assertEquals(0, message.getInt32ToEnumField().size()); assertEquals(0, message.getInt32ToMessageField().size()); assertEquals(0, message.getStringToInt32Field().size());",
        "label":1
    },
    {
        "ins1AddCode":"series.add(jan1st2002, 42); clone.update(jan1st2002, 10);",
        "ins1DelCode":"series.add(jan1st2002, new Integer(42)); clone.update(jan1st2002, new Integer(10));",
        "ins1PreCode":"public void testClone() throws CloneNotSupportedException { TimeSeries series = new TimeSeries(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, new Integer(42));  TimeSeries clone; clone = (TimeSeries) series.clone(); clone.setKey(\"Clone Series\"); clone.update(jan1st2002, new Integer(10));  int seriesValue = series.getValue(jan1st2002).intValue();",
        "ins2PreCode":"public void testClone() throws CloneNotSupportedException { TimePeriodValues series = new TimePeriodValues(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, new Integer(42)); assertEquals(\"Clone Series\", clone.getKey()); TimePeriodValues clone = (TimePeriodValues) series.clone(); clone.setKey(\"Clone Series\"); clone.update(0, new Integer(10)); int seriesValue = series.getValue(0).intValue();",
        "label":1
    },
    {
        "ins1AddCode":"if (!e.getMessage().contains(\"failed with return code\")) {",
        "ins1DelCode":"if (e.getMessage().indexOf(\"failed with return code\") == -1) {",
        "ins1PreCode":"Execute.runCommand(javah, cmd.getCommandline()); return true; } catch (BuildException e) { if (e.getMessage().indexOf(\"failed with return code\") == -1) { throw e; }",
        "ins2PreCode":"Execute.runCommand(javah, cmd.getCommandline()); return true; } catch (BuildException e) { if (e.getMessage().indexOf(\"failed with return code\") == -1) { throw e; }",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot p2 = (XYPlot) TestUtils.serialised(p1);",
        "ins1DelCode":"XYPlot p2 = (XYPlot) TestUtilities.serialised(p1);",
        "ins1PreCode":"p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); XYPlot p2 = (XYPlot) TestUtilities.serialised(p1); assertEquals(p1, p2); ",
        "ins2PreCode":"p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty());  assertFalse(((Disposable)observer).isDisposed());",
        "ins2PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); assertFalse(((Disposable)observer).isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"protected void writeJar(String baseName, File jarFile, Hashtable<String, File> files, String publicId) throws BuildException {",
        "ins1DelCode":"protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException {",
        "ins1PreCode":"protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException { if (ejbdeploy) { ",
        "ins2PreCode":"protected void writeJar(String baseName, File jarFile, Hashtable files, String publicId) throws BuildException { if (!keepGeneric) {",
        "label":1
    },
    {
        "ins1AddCode":"void testSameUpdateAfterCommitSimple() {",
        "ins1DelCode":"public void testSameUpdateAfterCommitSimple() {",
        "ins1PreCode":"public void testSameUpdateAfterCommitSimple() { try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.SIMPLE)) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "ins2PreCode":"public void testSameUpdateAfterCommitReuse() { try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.REUSE)) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"if (!tunnelSpec.isEmpty()) {",
        "ins1DelCode":"if (tunnelSpec.length() > 0) {",
        "ins1PreCode":"public void setLocaltunnels(final String tunnels) { for (String tunnelSpec : tunnels.split(\", \")) { if (tunnelSpec.length() > 0) { final String[] spec = tunnelSpec.split(\":\", 3); final int lport = Integer.parseInt(spec[0]);",
        "ins2PreCode":"public void setRemotetunnels(final String tunnels) { for (String tunnelSpec : tunnels.split(\", \")) { if (tunnelSpec.length() > 0) { final String[] spec = tunnelSpec.split(\":\", 3); final int rport = Integer.parseInt(spec[0]);",
        "label":1
    },
    {
        "ins1AddCode":"String systemDefault;",
        "ins1DelCode":"String systemDefault = null;",
        "ins1PreCode":"public Regexp newRegexp(Project p) throws BuildException { String systemDefault = null; if (p == null) { systemDefault = System.getProperty(MagicNames.REGEXP_IMPL);",
        "ins2PreCode":"public RegexpMatcher newRegexpMatcher(Project p) throws BuildException { String systemDefault = null; if (p == null) { systemDefault = System.getProperty(MagicNames.REGEXP_IMPL);",
        "label":1
    },
    {
        "ins1AddCode":"void getEndpointsShouldIncludeRestControllerEndpoints() {",
        "ins1DelCode":"public void getEndpointsShouldIncludeRestControllerEndpoints() {",
        "ins1PreCode":"public void getEndpointsShouldIncludeRestControllerEndpoints() { this.contextRunner.withUserConfiguration(TestRestControllerEndpoint.class) .run(assertDiscoverer((discoverer) -> {",
        "ins2PreCode":"public void getEndpointsShouldDiscoverProxyRestControllerEndpoints() { this.contextRunner.withUserConfiguration(TestProxyRestControllerEndpoint.class) .run(assertDiscoverer((discoverer) -> {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "label":1
    },
    {
        "ins1AddCode":"BibEntry e = new BibEntry(StandardEntryType.InProceedings); e.setField(StandardField.TITLE, \"Fruity features\"); e.setField(StandardField.KEYWORDS, \"banana, pineapple, orange\");",
        "ins1DelCode":"BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS); e.setField(\"title\", \"Fruity features\"); e.setField(\"keywords\", \"banana, pineapple, orange\");",
        "ins1PreCode":"public void testSearchAllFields() { BibEntry e = new BibEntry(BibtexEntryTypes.INPROCEEDINGS); e.setField(\"title\", \"Fruity features\"); e.setField(\"keywords\", \"banana, pineapple, orange\");  SearchQuery searchQuery = new SearchQuery(\"anyfield==\\\"fruity features\\\"\", false, false);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE));",
        "ins1DelCode":"TextFlow description = createDescription(query, true, false);",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case sensitive.\")); TextFlow description = createDescription(query, true, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete(); observer.onError(new TestException());",
        "ins2PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onComplete(); observer.onError(new TestException());",
        "label":1
    },
    {
        "ins1AddCode":"DefaultPieDataset<String> d1 = new DefaultPieDataset<>(); DefaultPieDataset<String> d2 = (DefaultPieDataset) TestUtils.serialised(d1);",
        "ins1DelCode":"DefaultPieDataset d1 = new DefaultPieDataset(); DefaultPieDataset d2 = (DefaultPieDataset) TestUtils.serialised(d1);",
        "ins1PreCode":"public void testSerialization() { DefaultPieDataset d1 = new DefaultPieDataset(); d1.setValue(\"C1\", 234.2); d1.setValue(\"C2\", null); d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7);  DefaultPieDataset d2 = (DefaultPieDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testSerialization() { DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); d1.setValue(\"C1\", 234.2); d1.setValue(\"C2\", null); d1.setValue(\"C3\", 345.9); d1.setValue(\"C4\", 452.7); DefaultKeyedValuesDataset d1 = new DefaultKeyedValuesDataset(); assertEquals(d1, d2);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Color.GRAY, r.getBaseOutlinePaint()); assertEquals(Color.GRAY, r.lookupSeriesOutlinePaint(0));",
        "ins1DelCode":"assertEquals(Color.gray, r.getBaseOutlinePaint()); assertEquals(Color.gray, r.lookupSeriesOutlinePaint(0));",
        "ins1PreCode":"public void testOutlinePaintLookup() { BarRenderer r = new BarRenderer(); assertEquals(Color.gray, r.getBaseOutlinePaint());   r.setAutoPopulateSeriesOutlinePaint(false); assertEquals(Color.gray, r.lookupSeriesOutlinePaint(0)); assertNull(r.getSeriesOutlinePaint(0)); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".flatMapSingle(new Function<Integer, SingleSource<Integer>>() {",
        "ins1DelCode":".flatMapSingleElement(new Function<Integer, SingleSource<Integer>>() {",
        "ins1PreCode":"public void singleErrors() { Maybe.just(1) .flatMapSingleElement(new Function<Integer, SingleSource<Integer>>() { @Override public SingleSource<Integer> apply(final Integer integer) throws Exception {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"getTomcatInstanceTestWebapp(false, true);",
        "ins1DelCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start();",
        "ins1PreCode":"public void testBug45427() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() +",
        "ins2PreCode":"public void testScriptingExpression() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start(); ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/test/script-expr.jsp\");",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, SecurityFilterChain.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "label":0
    },
    {
        "ins1AddCode":"if (schema == null) continue;",
        "ins1DelCode":"",
        "ins1PreCode":"String columnName = dbResult.getString(3); String description = dbResult.getString(4); GenericSchema schema = parentSchema != null ? parentSchema : dataSource.getSchema(schemaName);  result.add(new AbstractObjectReference(objectName, schema, description, GenericTableColumn.class, RelationalObjectType.TYPE_TABLE_COLUMN) { @Override",
        "ins2PreCode":"String columnName = dbResult.getString(3); String description = dbResult.getString(4); GenericSchema schema = parentSchema != null ? parentSchema : dataSource.getSchema(schemaName); result.add(new AbstractObjectReference(objectName, schema, description, GenericTableColumn.class, RelationalObjectType.TYPE_TABLE_COLUMN) { @Override",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<Vector> rdd1 = uniformJavaVectorRDD(jsc, m, n); JavaRDD<Vector> rdd2 = uniformJavaVectorRDD(jsc, m, n, p); JavaRDD<Vector> rdd3 = uniformJavaVectorRDD(jsc, m, n, p, seed); for (JavaRDD<Vector> rdd : Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1DelCode":"JavaRDD<Vector> rdd1 = uniformJavaVectorRDD(sc, m, n); JavaRDD<Vector> rdd2 = uniformJavaVectorRDD(sc, m, n, p); JavaRDD<Vector> rdd3 = uniformJavaVectorRDD(sc, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1PreCode":"int n = 10; int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = uniformJavaVectorRDD(sc, m, n); JavaRDD<Vector> rdd2 = uniformJavaVectorRDD(sc, m, n, p); JavaRDD<Vector> rdd3 = uniformJavaVectorRDD(sc, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); Assert.assertEquals(n, rdd.first().size());",
        "ins2PreCode":"int n = 10; int p = 2; long seed = 1L; JavaRDD<Vector> rdd1 = normalJavaVectorRDD(sc, m, n); JavaRDD<Vector> rdd2 = normalJavaVectorRDD(sc, m, n, p); JavaRDD<Vector> rdd3 = normalJavaVectorRDD(sc, m, n, p, seed); for (JavaRDD<Vector> rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); Assert.assertEquals(n, rdd.first().size());",
        "label":1
    },
    {
        "ins1AddCode":"public void customBeanNameGenerator() {",
        "ins1DelCode":"public void customBeanNameGenerator() throws Exception {",
        "ins1PreCode":"public void customBeanNameGenerator() throws Exception { TestSpringApplication application = new TestSpringApplication( ExampleWebConfig.class);",
        "ins2PreCode":"public void customBeanNameGeneratorWithNonWebApplication() throws Exception { TestSpringApplication application = new TestSpringApplication( ExampleWebConfig.class);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<String> ts = new TestSubscriberEx<>(new DefaultSubscriber<String>() {",
        "ins1DelCode":"TestSubscriberEx<String> ts = new TestSubscriberEx<String>(new DefaultSubscriber<String>() {",
        "ins1PreCode":"final CountDownLatch latch = new CountDownLatch(1); final CountDownLatch running = new CountDownLatch(2);  TestSubscriberEx<String> ts = new TestSubscriberEx<String>(new DefaultSubscriber<String>() {  @Override",
        "ins2PreCode":"final CountDownLatch latch = new CountDownLatch(1); final CountDownLatch running = new CountDownLatch(2); TestObserverEx<String> to = new TestObserverEx<String>(new DefaultObserver<String>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"throw new ProfileException(\"Invalid XMI data!\", e);",
        "ins1DelCode":"LOG.error(\"Exception while loading profile \", e); throw new ProfileException(\"Invalid XMI data!\");",
        "ins1PreCode":"Collection elements = xmiReader.parse(inputSource, true); return elements; } catch (UmlException e) { LOG.error(\"Exception while loading profile \", e); throw new ProfileException(\"Invalid XMI data!\"); } }",
        "ins2PreCode":"Collection elements = xmiReader.parse(inputSource, true); return elements; } catch (UmlException e) { LOG.error(\"Exception while loading profile \", e); throw new ProfileException(\"Invalid XMI data!\"); } }",
        "label":0
    },
    {
        "ins1AddCode":"queue = new SpscLinkedArrayQueue<>(bufferSize);",
        "ins1DelCode":"queue = new SpscLinkedArrayQueue<T>(bufferSize);",
        "ins1PreCode":"} }  queue = new SpscLinkedArrayQueue<T>(bufferSize);  downstream.onSubscribe(this);",
        "ins2PreCode":"} } queue = new SpscLinkedArrayQueue<T>(prefetch); downstream.onSubscribe(this);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertNeverAtNotMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts); ",
        "ins2PreCode":"public void assertNeverAtMatchingValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"@NonNull Publisher<@NonNull ? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<@NonNull TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<@NonNull TRightEnd>> rightEnd,",
        "ins1DelCode":"@NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd,",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> groupJoin( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super Flowable<TRight>, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins2PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Observable<R> groupJoin( @NonNull ObservableSource<? extends TRight> other, @NonNull Function<? super T, ? extends ObservableSource<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends ObservableSource<TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super Observable<TRight>, ? extends R> resultSelector Objects.requireNonNull(other, \"other is null\");",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"} };  TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  Flowable.fromIterable(it).subscribe(ts);",
        "ins2PreCode":"} }; TestSubscriber<Integer> ts = new TestSubscriber<Integer>(5); Flowable.fromIterable(it).subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"void bindToArrayWhenNotInOrderShouldReturnPopulatedArray() {",
        "ins1DelCode":"public void bindToArrayWhenNotInOrderShouldReturnPopulatedArray() {",
        "ins1PreCode":"public void bindToArrayWhenNotInOrderShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[1]\", \"2\");",
        "ins2PreCode":"public void bindToCollectionWhenNotInOrderShouldReturnPopulatedCollection() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[1]\", \"2\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Collections.emptyList(), result);",
        "ins1DelCode":"Assert.assertEquals(Collections.emptyList(), result);",
        "ins1PreCode":"autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"test\"))); Assert.assertEquals(Collections.emptyList(), result);",
        "ins2PreCode":"autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"test\"))); Assert.assertEquals(Collections.emptyList(), result);",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);",
        "ins1DelCode":"final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);",
        "ins1PreCode":"final Integer[] a = new Integer[1000]; Arrays.fill(a, 1);  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);  Maybe.just(1)",
        "ins2PreCode":"final Integer[] a = new Integer[1000]; Arrays.fill(a, 1); final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); Maybe.just(1)",
        "label":1
    },
    {
        "ins1AddCode":"void testLangRawWithMapper() {",
        "ins1DelCode":"public void testLangRawWithMapper() {",
        "ins1PreCode":"public void testLangRawWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "ins2PreCode":"public void testLangVelocityWithMapper() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Parameter p = new Parameter(true, \"Fli%\");",
        "label":1
    },
    {
        "ins1AddCode":"void lombokSimplePropertyWithOnlyGetterOnFieldShouldNotBeExposed() throws IOException {",
        "ins1DelCode":"public void lombokSimplePropertyWithOnlyGetterOnFieldShouldNotBeExposed() throws IOException {",
        "ins1PreCode":"public void lombokSimplePropertyWithOnlyGetterOnFieldShouldNotBeExposed() throws IOException { process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(LombokExplicitProperties.class);",
        "ins2PreCode":"public void lombokSimplePropertyWithOnlySetterOnFieldShouldNotBeExposed() throws IOException { process(LombokExplicitProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(LombokExplicitProperties.class);",
        "label":1
    },
    {
        "ins1AddCode":"StackedBarRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"StackedBarRenderer r2 = (StackedBarRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StackedBarRenderer r1 = new StackedBarRenderer(); StackedBarRenderer r2 = (StackedBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); DefaultCategoryItemRenderer r1 = new DefaultCategoryItemRenderer(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":" LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); plot.setDataset(newData); assertEquals(true, l.flag);",
        "label":1
    },
    {
        "ins1AddCode":"lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "ins1DelCode":"MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "ins1PreCode":"super.setUp();  NumberFieldType fieldType = new NumberFieldType(\"field\", NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType);  SortedNumericDoubleValues doubleValues = mock(SortedNumericDoubleValues.class); when(doubleValues.advanceExact(anyInt())).thenReturn(true); when(doubleValues.nextValue()).thenReturn(2.718);  LeafNumericFieldData atomicFieldData = mock(LeafNumericFieldData.class); when(atomicFieldData.getDoubleValues()).thenReturn(doubleValues);  IndexNumericFieldData fieldData = mock(IndexNumericFieldData.class); when(fieldData.getFieldName()).thenReturn(\"field\"); when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "ins2PreCode":"super.setUp(); NumberFieldMapper.NumberFieldType fieldType = new NumberFieldMapper.NumberFieldType(\"field\", NumberFieldMapper.NumberType.DOUBLE); MapperService mapperService = mock(MapperService.class); when(mapperService.fieldType(\"field\")).thenReturn(fieldType); when(mapperService.fieldType(\"alias\")).thenReturn(fieldType); SortedNumericDoubleValues doubleValues = mock(SortedNumericDoubleValues.class); when(doubleValues.advanceExact(anyInt())).thenReturn(true); when(doubleValues.nextValue()).thenReturn(2.718); LeafNumericFieldData atomicFieldData = mock(LeafNumericFieldData.class); when(atomicFieldData.getDoubleValues()).thenReturn(doubleValues); IndexNumericFieldData fieldData = mock(IndexNumericFieldData.class); when(fieldData.getFieldName()).thenReturn(\"field\"); when(fieldData.load(anyObject())).thenReturn(atomicFieldData); service = new ExpressionScriptEngine(); lookup = new SearchLookup(mapperService, (ignored, lookup) -> fieldData);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins1DelCode":"Assert.assertEquals(1, db.getEntryCount()); Assert.assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins1PreCode":"BibDatabase db = result.getDatabase();   Assert.assertEquals(1, db.getEntryCount()); Assert.assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "ins2PreCode":"BibDatabase db = result.getDatabase(); Assert.assertEquals(1, db.getEntryCount()); Assert.assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(\"year\"));",
        "label":1
    },
    {
        "ins1AddCode":"cmdl.setMaxmemory(maxMemory);",
        "ins1DelCode":"arg.setValue(\"-mx140M\");",
        "ins1PreCode":"JavaCC.TASKDEF_TYPE_JJTREE));  final Commandline.Argument arg = cmdl.createVmArgument(); arg.setValue(\"-mx140M\"); arg.setValue(\"-Dinstall.root=\" + javaccHome.getAbsolutePath()); ",
        "ins2PreCode":"JavaCC.TASKDEF_TYPE_JJDOC)); final Commandline.Argument arg = cmdl.createVmArgument(); arg.setValue(\"-mx140M\"); arg.setValue(\"-Dinstall.root=\" + javaccHome.getAbsolutePath());",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<KryoSerializable> ds = spark.createDataset(data, encoder);",
        "ins1DelCode":"Dataset<KryoSerializable> ds = context.createDataset(data, encoder);",
        "ins1PreCode":"Encoder<KryoSerializable> encoder = Encoders.kryo(KryoSerializable.class); List<KryoSerializable> data = Arrays.asList( new KryoSerializable(\"hello\"), new KryoSerializable(\"world\")); Dataset<KryoSerializable> ds = context.createDataset(data, encoder); Assert.assertEquals(data, ds.collectAsList());",
        "ins2PreCode":"Encoder<JavaSerializable> encoder = Encoders.javaSerialization(JavaSerializable.class); List<JavaSerializable> data = Arrays.asList( new JavaSerializable(\"hello\"), new JavaSerializable(\"world\")); Dataset<JavaSerializable> ds = context.createDataset(data, encoder); Assert.assertEquals(data, ds.collectAsList());",
        "label":1
    },
    {
        "ins1AddCode":"public void ofNameWhenRunOnAssociative() {",
        "ins1DelCode":"public void ofNameWhenRunOnAssociative() throws Exception {",
        "ins1PreCode":"public void ofNameWhenRunOnAssociative() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo[bar]\"); assertThat(name.toString()).isEqualTo(\"foo[bar]\");",
        "ins2PreCode":"public void ofNameWhenDotOnAssociative() throws Exception { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.bar\"); assertThat(name.toString()).isEqualTo(\"foo.bar\");",
        "label":1
    },
    {
        "ins1AddCode":"Processor processor = new SortProcessor(randomAlphaOfLength(10), null, fieldName, order, fieldName);",
        "ins1DelCode":"Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, order, fieldName);",
        "ins1PreCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); ingestDocument.setFieldValue(fieldName, randomAlphaOfLengthBetween(1, 10)); SortOrder order = randomBoolean() ? SortOrder.ASCENDING : SortOrder.DESCENDING; Processor processor = new SortProcessor(randomAlphaOfLength(10), fieldName, order, fieldName); try { processor.execute(ingestDocument);",
        "ins2PreCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); ingestDocument.setFieldValue(fieldName, randomAlphaOfLengthBetween(1, 10)); ingestDocument.setFieldValue(fieldName, randomAlphaOfLengthBetween(1, 10)); Processor processor = new JoinProcessor(randomAlphaOfLength(10), fieldName, \"-\", fieldName); try { processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1AddCode":"\"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"started_at_timestamp\\\":1369795079,\" \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\"); + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\\\"state_timestamp\\\":1369795079}\");",
        "ins1DelCode":"+ \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\");",
        "ins1PreCode":"+ \"\\\"instance_id\\\":\\\"bb7935245adf3e650dfb7c58a06e9ece\\\",\" + \"\\\"instance_index\\\":0,\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"foo\\\",\\\"uris\\\":[\\\"foo.cfapps.io\\\"],\" + \"\\\"started_at\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"started_at_timestamp\\\":1369795079,\" + \"\\\"host\\\":\\\"0.0.0.0\\\",\\\"port\\\":61034,\" + \"\\\"limits\\\":{\\\"mem\\\":128,\\\"disk\\\":1024,\\\"fds\\\":16384},\" + \"\\\"version\\\":\\\"3464e092-1c13-462e-a47c-807c30318a50\\\",\" + \"\\\"name\\\":\\\"dsyerenv\\\",\\\"uris\\\":[\\\"dsyerenv.cfapps.io\\\"],\" + \"\\\"users\\\":[],\\\"start\\\":\\\"2013-05-29 02:37:59 +0000\\\",\" + \"\\\"state_timestamp\\\":1369795079}\"); this.initializer.postProcessEnvironment(this.context.getEnvironment(), null); assertThat(getProperty(\"vcap\")).isNull();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals((Integer)1, person.getId());",
        "ins1DelCode":"assertEquals(1, person.getId());",
        "ins1PreCode":"try { MultipleReverseIncludePersonMapper personMapper = sqlSession.getMapper(MultipleReverseIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals(1, person.getId()); assertEquals(\"John\", person.getName()); ",
        "ins2PreCode":"try { ReverseIncludePersonMapper personMapper = sqlSession.getMapper(ReverseIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals(1, person.getId()); assertEquals(\"John\", person.getName());",
        "label":1
    },
    {
        "ins1AddCode":"Hashtable<String, String> files = getFiles(); assertEquals(\"Classfileset did not pick up expected number of class files\", \"class files\", 4, files.size()); 4, files.size()); assertThat(\"Result did not contain A.class\", files, hasKey(\"A.class\")); assertThat(\"Result did not contain B.class\", files, hasKey(\"B.class\")); assertThat(\"Result did not contain C.class\", files, hasKey(\"C.class\")); assertThat(\"Result did not contain D.class\", files, hasKey(\"D.class\"));",
        "ins1DelCode":"Project p = buildRule.getProject(); FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable<String, String> files = new Hashtable<>(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile); } assertEquals(\"Classfileset did not pick up expected number of \" + \"class files\", 4, files.size()); assertTrue(\"Result did not contain A.class\", files.containsKey(\"A.class\")); assertTrue(\"Result did not contain B.class\", files.containsKey(\"B.class\")); assertTrue(\"Result did not contain C.class\", files.containsKey(\"C.class\")); assertTrue(\"Result did not contain D.class\", files.containsKey(\"D.class\"));",
        "ins1PreCode":"public void testBasicSet() { Project p = buildRule.getProject(); buildRule.executeTarget(\"testbasicset\"); FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable<String, String> files = new Hashtable<>(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile); } assertEquals(\"Classfileset did not pick up expected number of \" + \"class files\", 4, files.size()); assertTrue(\"Result did not contain A.class\", files.containsKey(\"A.class\")); assertTrue(\"Result did not contain B.class\", files.containsKey(\"B.class\")); assertTrue(\"Result did not contain C.class\", files.containsKey(\"C.class\")); assertTrue(\"Result did not contain D.class\", files.containsKey(\"D.class\"));",
        "ins2PreCode":"public void testSmallSet() { Project p = buildRule.getProject(); buildRule.executeTarget(\"testsmallset\"); FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); for (String scannedFile : scanner.getIncludedFiles()) { Hashtable<String, String> files = new Hashtable<>(); for (String scannedFile : scanner.getIncludedFiles()) { files.put(scannedFile, scannedFile); } assertEquals(\"Classfileset did not pick up expected number of \" + \"class files\", 2, files.size()); assertTrue(\"Result did not contain B.class\", files.containsKey(\"B.class\")); assertTrue(\"Result did not contain B.class\", files.containsKey(\"B.class\")); assertTrue(\"Result did not contain C.class\", files.containsKey(\"C.class\")); assertTrue(\"Result did not contain B.class\", files.containsKey(\"B.class\"));",
        "label":0
    },
    {
        "ins1AddCode":"ELContext context = new ELContextImpl(factory);",
        "ins1DelCode":"ELContext context = new ELContextImpl();",
        "ins1PreCode":"public void testJavaKeyWordSuffix() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl();  TesterBeanA beanA = new TesterBeanA();",
        "ins2PreCode":"public void testJavaKeyWordIdentifier() { ExpressionFactory factory = ExpressionFactory.newInstance(); ELContext context = new ELContextImpl(); TesterBeanA beanA = new TesterBeanA();",
        "label":1
    },
    {
        "ins1AddCode":"return Objects.equals(appId, appExecId.appId);",
        "ins1DelCode":"return Objects.equal(appId, appExecId.appId);",
        "ins1PreCode":"if (o == null || getClass() != o.getClass()) return false;  AppId appExecId = (AppId) o; return Objects.equal(appId, appExecId.appId);",
        "ins2PreCode":"if (o == null || getClass() != o.getClass()) return false; AppExecId appExecId = (AppExecId) o; return Objects.equal(appId, appExecId.appId) && Objects.equal(execId, appExecId.execId);",
        "label":0
    },
    {
        "ins1AddCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext, int bufferSize) { Iterator<T> it = blockingIterable(bufferSize).iterator();",
        "ins1DelCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator();",
        "ins1PreCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator(); while (it.hasNext()) { try {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"List<Message> entryList = new ArrayList<>();",
        "ins1DelCode":"List<Message> entryList = new ArrayList<Message>();",
        "ins1PreCode":"private static void setMapValues(Message.Builder builder, String name, Map<?, ?> values) { List<Message> entryList = new ArrayList<Message>(); for (Map.Entry<?, ?> entry : values.entrySet()) { entryList.add(newMapEntry(builder, name, entry.getKey(), entry.getValue()));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"clientChannel.writeOneInbound(serverChannel.readOutbound());",
        "ins1DelCode":"clientChannel.writeInbound(serverChannel.readOutbound());",
        "ins1PreCode":"NettyUtils.createFrameDecoder(), MessageDecoder.INSTANCE);  while (!serverChannel.outboundMessages().isEmpty()) { clientChannel.writeInbound(serverChannel.readOutbound()); } ",
        "ins2PreCode":"NettyUtils.createFrameDecoder(), MessageDecoder.INSTANCE); while (!clientChannel.outboundMessages().isEmpty()) { serverChannel.writeInbound(clientChannel.readOutbound()); }",
        "label":1
    },
    {
        "ins1AddCode":"requestPath.substring(0, pos + 1), StandardCharsets.UTF_8) + path; relative = URLEncoder.DEFAULT.encode(requestPath, StandardCharsets.UTF_8) + path;",
        "ins1DelCode":"requestPath.substring(0, pos + 1), \"UTF-8\") + path; relative = URLEncoder.DEFAULT.encode(requestPath, \"UTF-8\") + path;",
        "ins1PreCode":"if (context.getDispatchersUseEncodedPaths()) { if (pos >= 0) { relative = URLEncoder.DEFAULT.encode( requestPath.substring(0, pos + 1), \"UTF-8\") + path; } else { relative = URLEncoder.DEFAULT.encode(requestPath, \"UTF-8\") + path; } } else {",
        "ins2PreCode":"return (context.getServletContext().getRequestDispatcher(path)); if (pos >= 0) { String relative = null; relative = requestPath.substring(0, pos + 1) + path; } else { relative = requestPath + path; } } else {",
        "label":0
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1.equals(r2));  assertTrue(checkIndependence(r1, r2)); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Processor processor = new ConvertProcessor(randomAlphaOfLength(10), null, fieldName, fieldName, Type.INTEGER, false);",
        "ins1DelCode":"Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.INTEGER, false);",
        "ins1PreCode":"String value = \"string-\" + randomAlphaOfLengthBetween(1, 10); ingestDocument.setFieldValue(fieldName, value);  Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.INTEGER, false); try { processor.execute(ingestDocument);",
        "ins2PreCode":"String value = \"string-\" + randomAlphaOfLengthBetween(1, 10); ingestDocument.setFieldValue(fieldName, value); Processor processor = new ConvertProcessor(randomAlphaOfLength(10), fieldName, fieldName, Type.FLOAT, false); try { processor.execute(ingestDocument);",
        "label":1
    },
    {
        "ins1AddCode":"a[0].subscribe(new SingleMap.MapSingleObserver<>(observer, new SingletonArrayFunc())); ZipCoordinator<T, R> parent = new ZipCoordinator<>(observer, n, zipper);",
        "ins1DelCode":"a[0].subscribe(new SingleMap.MapSingleObserver<T, R>(observer, new SingletonArrayFunc())); ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper);",
        "ins1PreCode":"}  if (n == 1) { a[0].subscribe(new SingleMap.MapSingleObserver<T, R>(observer, new SingletonArrayFunc())); return; }  ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper);  observer.onSubscribe(parent);",
        "ins2PreCode":"} if (n == 1) { a[0].subscribe(new MaybeMap.MapMaybeObserver<T, R>(observer, new SingletonArrayFunc())); return; } ZipCoordinator<T, R> parent = new ZipCoordinator<T, R>(observer, n, zipper); observer.onSubscribe(parent);",
        "label":1
    },
    {
        "ins1AddCode":"shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE); spillFilesCreated.clear(); spillFilesCreated.add(file);",
        "ins1DelCode":"when(shuffleMemoryManager.tryToAcquire(anyLong())).then(returnsFirstArg());",
        "ins1PreCode":"tempDir = new File(Utils.createTempDir$default$1()); taskContext = mock(TaskContext.class); when(taskContext.taskMetrics()).thenReturn(new TaskMetrics()); when(shuffleMemoryManager.tryToAcquire(anyLong())).then(returnsFirstArg()); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup,",
        "ins1DelCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition,",
        "ins1PreCode":"public void testNullGuardEq() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition, MethodHandles.publicLookup(), \"eq\",",
        "ins2PreCode":"public void testNullGuardEqWhenCached() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition, MethodHandles.publicLookup(), \"eq\",",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testGetNamesWithArray() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Array array = sqlSession.getConnection().createArrayOf(\"int\", new Integer[] { 1, 2, 5 });  Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"ids\", array); List<Name> names = spMapper.getNamesWithArray(parms); Object[] returnedIds = (Object[]) parms.get(\"returnedIds\"); assertEquals(4, returnedIds.length); assertEquals(3, parms.get(\"requestedRows\")); assertEquals(2, names.size()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testGetNamesWithArray_a2() throws SQLException { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class); Array array = sqlSession.getConnection().createArrayOf(\"int\", new Integer[] { 1, 2, 5 }); Map<String, Object> parms = new HashMap<String, Object>(); parms.put(\"ids\", array); List<Name> names = spMapper.getNamesWithArrayAnnotatedWithXMLResultMap(parms); Object[] returnedIds = (Object[]) parms.get(\"returnedIds\"); assertEquals(4, returnedIds.length); assertEquals(3, parms.get(\"requestedRows\")); assertEquals(2, names.size()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"List<Integer> result = new ArrayList<>();",
        "ins1DelCode":"List<Integer> result = new ArrayList<Integer>();",
        "ins1PreCode":"private List<Integer> getDatasetIndices(DatasetRenderingOrder order) { List<Integer> result = new ArrayList<Integer>(); for (Map.Entry<Integer, CategoryDataset> entry : this.datasets.entrySet()) {",
        "ins2PreCode":"private List<Integer> getRendererIndices(DatasetRenderingOrder order) { List<Integer> result = new ArrayList<Integer>(); for (Map.Entry<Integer, CategoryItemRenderer> entry: this.renderers.entrySet()) {",
        "label":1
    },
    {
        "ins1AddCode":"public void makeSpace(int count)",
        "ins1DelCode":"private void makeSpace(int count)",
        "ins1PreCode":"private void makeSpace(int count) { char[] tmp = null;",
        "ins2PreCode":"private void makeSpace(int count) { tmp = null;",
        "label":1
    },
    {
        "ins1AddCode":"if ( sourceDominant || tgt == null )",
        "ins1DelCode":"if ( tgt == null )",
        "ins1PreCode":"if ( src != null ) { DeploymentRepository tgt = target.getRepository(); if ( tgt == null ) { tgt = new DeploymentRepository();",
        "ins2PreCode":"if ( src != null ) { DeploymentRepository tgt = target.getSnapshotRepository(); if ( tgt == null ) { tgt = new DeploymentRepository();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"Pool cleaner threads should not be present.\",0, countPoolCleanerThreads()); assertEquals(\"Pool cleaner threads should be 1.\",1, countPoolCleanerThreads()); assertEquals(\"Pool cleaner threads should not be present after close.\",0, countPoolCleanerThreads());",
        "ins1DelCode":"",
        "ins1PreCode":"datasource.getPoolProperties().setTestWhileIdle(true); assertEquals(\"Pool cleaner should not be started yet.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null\", ConnectionPool.getPoolTimer());  datasource.getConnection().close(); assertEquals(\"Pool cleaner should have 1 cleaner.\",1,ConnectionPool.getPoolCleaners().size() ); assertNotNull(\"Pool timer should not be null\", ConnectionPool.getPoolTimer());  datasource.close(); assertEquals(\"Pool shutdown, no cleaners should be present.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null after shutdown\", ConnectionPool.getPoolTimer());",
        "ins2PreCode":"datasource.getPoolProperties().setTestWhileIdle(true); assertEquals(\"Pool cleaner should not be started yet.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null\", ConnectionPool.getPoolTimer()); datasource.getConnection().close(); assertEquals(\"Pool cleaner should have 1 cleaner.\",1,ConnectionPool.getPoolCleaners().size() ); assertNotNull(\"Pool timer should not be null\", ConnectionPool.getPoolTimer()); datasource.close(); assertEquals(\"Pool shutdown, no cleaners should be present.\",0,ConnectionPool.getPoolCleaners().size() ); assertNull(\"Pool timer should be null after shutdown\", ConnectionPool.getPoolTimer());",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( \"http://parent.url/org\", pom.getValue( \"organization/url\" ) );",
        "ins1DelCode":"assertEquals( \"http://parent.url/org/\", pom.getValue( \"organization/url\" ) );",
        "ins1PreCode":"{ PomTestWrapper pom = buildPom( \"url-inheritance/sub\" ); assertEquals( \"http://parent.url/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org/\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) ); assertEquals( \"http://parent.url/viewvc/child\", pom.getValue( \"scm/url\" ) );",
        "ins2PreCode":"{ PomTestWrapper pom = buildPom( \"url-inheritance/another-parent/sub\" ); assertEquals( \"http://parent.url/ap/child\", pom.getValue( \"url\" ) ); assertEquals( \"http://parent.url/org/\", pom.getValue( \"organization/url\" ) ); assertEquals( \"http://parent.url/license.txt\", pom.getValue( \"licenses[1]/url\" ) ); assertEquals( \"http://parent.url/viewvc/ap/child\", pom.getValue( \"scm/url\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"public void simple() {",
        "ins1DelCode":"public void simple() throws Exception {",
        "ins1PreCode":"public void simple() throws Exception { String s = \"one two\"; assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly(\"one\",",
        "ins2PreCode":"public void escaped() throws Exception { String s = \"o\\\\ ne two\"; assertThat(this.delimiter.delimit(s, 0).getArguments()).containsExactly(\"o\\\\ ne\",",
        "label":1
    },
    {
        "ins1AddCode":"public static String escapeXml(char[] arrayBuffer, int length) { return null;",
        "ins1DelCode":"public static String escapeXml(String buffer) { int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); return buffer;",
        "ins1PreCode":"public static String escapeXml(String buffer) { int start = 0; int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); StringBuilder escapedBuffer = null;  for (int i = 0; i < length; i++) { char c = arrayBuffer[i]; if (c <= HIGHEST_SPECIAL) { char[] escaped = specialCharactersRepresentation[c]; if (escaped != null) {  if (start == 0) { escapedBuffer = new StringBuilder(length + 5); }  if (start < i) { escapedBuffer.append(arrayBuffer,start,i-start); } start = i + 1;  escapedBuffer.append(escaped); } } }  if (start == 0) { return buffer; } ",
        "ins2PreCode":"public static String escapeXml(String buffer) { int start = 0; int length = buffer.length(); char[] arrayBuffer = buffer.toCharArray(); StringBuilder escapedBuffer = null; for (int i = 0; i < length; i++) { char c = arrayBuffer[i]; if (c <= HIGHEST_SPECIAL) { char[] escaped = specialCharactersRepresentation[c]; if (escaped != null) { if (start == 0) { escapedBuffer = new StringBuilder(length + 5); } if (start < i) { escapedBuffer.append(arrayBuffer,start,i-start); } start = i + 1; escapedBuffer.append(escaped); } } } if (start == 0) { return buffer; }",
        "label":0
    },
    {
        "ins1AddCode":"if (event.getTarget().getName().isEmpty()) {",
        "ins1DelCode":"if (event.getTarget().getName().equals(\"\")) {",
        "ins1PreCode":"public void targetStarted(BuildEvent event) { if (event.getTarget().getName().equals(\"\")) { return; }",
        "ins2PreCode":"public void targetStarted(BuildEvent event) { if (event.getTarget().getName().equals(\"\")) { return; }",
        "label":1
    },
    {
        "ins1AddCode":"failWithMessage(\"Unsupport type for JSON assert {}\", expected.getClass()); return null;",
        "ins1DelCode":"throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "ins1PreCode":"if (expected instanceof Resource) { return isEqualToJson((Resource) expected); } throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "ins2PreCode":"if (expected instanceof Resource) { return isNotEqualToJson((Resource) expected); } throw new AssertionError(\"Unsupport type for JSON assert \" + expected.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/result_handler_type/CreateDB.sql\");",
        "ins1DelCode":"Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn); conn.close();",
        "ins1PreCode":"SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close();  Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn); conn.close();  return sqlSessionFactory;",
        "ins2PreCode":"SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close(); Connection conn = sqlSessionFactory.getConfiguration().getEnvironment().getDataSource().getConnection(); initDb(conn); conn.close(); return sqlSessionFactory;",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\"));",
        "ins1DelCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "ins1PreCode":"   tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");  ",
        "ins2PreCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"Collection<Marker> markers = getRangeMarkers(index, layer); for (Marker marker : markers) {",
        "ins1DelCode":"Collection markers = getRangeMarkers(index, layer); Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next();",
        "ins1PreCode":"return; }  Collection markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { Iterator iterator = markers.iterator(); while (iterator.hasNext()) { Marker marker = (Marker) iterator.next(); r.drawRangeMarker(g2, this, axis, marker, dataArea); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 34; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 35; i++) jj_la1[i] = -1;",
        "ins1PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"buildRule.executeTarget(\"testFilenameAsParamNoSetting\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='-not-set-'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/two.txt\",      \"filename='-not-set-'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/three.txt\",    \"filename='-not-set-'\"); assertFileContains(buildRule.getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='-not-set-'\");",
        "ins1DelCode":"executeTarget(\"testFilenameAsParamNoSetting\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/two.txt\",      \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/three.txt\",    \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='-not-set-'\");",
        "ins1PreCode":"public void testFilenameAsParamNoSetting() throws Exception { executeTarget(\"testFilenameAsParamNoSetting\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/two.txt\",      \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/three.txt\",    \"filename='-not-set-'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='-not-set-'\");",
        "ins2PreCode":"public void testFilenameAndFiledirAsParam() throws Exception { executeTarget(\"testFilenameAndFiledirAsParam\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='one.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='one.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/one.txt\",      \"filename='one.xml'\"); assertFileContains(getOutputDir().getAbsoluteFile() + \"/dir/four.txt\", \"filename='four.xml'\");",
        "label":1
    },
    {
        "ins1AddCode":"Hashtable<String, String> files = new Hashtable<>(); for (String scannedFile : scanner.getIncludedFiles()) {",
        "ins1DelCode":"String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) {",
        "ins1PreCode":"buildRule.executeTarget(\"testsmallset\"); FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile); }",
        "ins2PreCode":"buildRule.executeTarget(\"testmethodparam\"); FileSet resultFileSet = p.getReference(RESULT_FILESET); DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile); }",
        "label":1
    },
    {
        "ins1AddCode":"o.onSubscribe(Disposable.empty());",
        "ins1DelCode":"o.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super String> o) { o.onSubscribe(Disposables.empty()); for (int i = 0; i < NUM_MSG; i++) { o.onNext(\"msg:\" + count.incrementAndGet());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void tryTerminateConsumerSingleError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty());  AtomicThrowable ex = new AtomicThrowable();",
        "ins2PreCode":"public void tryTerminateConsumerCompletableObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); AtomicThrowable ex = new AtomicThrowable();",
        "label":1
    },
    {
        "ins1AddCode":"final List<Integer> list = new ArrayList<>();",
        "ins1DelCode":"final List<Integer> list = new ArrayList<Integer>();",
        "ins1PreCode":"public void subscribeConsumerConsumerWithError() { final List<Integer> list = new ArrayList<Integer>();  Flowable.<Integer>error(new TestException()).subscribe(new Consumer<Integer>() {",
        "ins2PreCode":"public void subscribeConsumerConsumer() { final List<Integer> list = new ArrayList<Integer>(); Flowable.just(1).subscribe(new Consumer<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"foo.war\", cn21.getBaseName()); assertEquals(\"foo\", cn22.getBaseName());",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals(\"ROOT#bar\", cn18.getBaseName()); assertEquals(\"ROOT#bar##A\", cn19.getBaseName()); assertEquals(\"ROOT##A\", cn20.getBaseName());",
        "ins2PreCode":"assertEquals(\"/ROOT/bar\", cn18.getName()); assertEquals(\"/ROOT/bar##A\", cn19.getName()); assertEquals(\"##A\", cn20.getName());",
        "label":1
    },
    {
        "ins1AddCode":".collectInto(new HashSet<>(), new BiConsumer<HashSet<Integer>, Integer>() { .assertResult(new HashSet<>(Arrays.asList(1, 2)));",
        "ins1DelCode":".collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() { .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));",
        "ins1PreCode":"public void collectIntoObservable() { Observable.just(1, 1, 1, 1, 2) .collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() { @Override public void accept(HashSet<Integer> s, Integer v) throws Exception { s.add(v); } }).toObservable() .test() .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));",
        "ins2PreCode":"public void collectInto() { Observable.just(1, 1, 1, 1, 2) .collectInto(new HashSet<Integer>(), new BiConsumer<HashSet<Integer>, Integer>() { @Override public void accept(HashSet<Integer> s, Integer v) throws Exception { s.add(v); } Observable.just(1, 1, 1, 1, 2) .test() .assertResult(new HashSet<Integer>(Arrays.asList(1, 2)));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertValueSequence() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  ts.onSubscribe(new BooleanSubscription());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals(\"*\"));",
        "ins1DelCode":"CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\"));",
        "ins1PreCode":"corsFilter.doFilter(request, response, filterChain);  Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\")); Assert.assertTrue(((Boolean) request.getAttribute( CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());",
        "ins2PreCode":"corsFilter.doFilter(request, response, filterChain); Assert.assertTrue(response.getHeader( CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN).equals( \"https://www.apache.org\")); Assert.assertTrue(((Boolean) request.getAttribute( CorsFilter.HTTP_REQUEST_ATTRIBUTE_IS_CORS_REQUEST)).booleanValue());",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); renderer.setSeriesToolTipGenerator(0, tt);",
        "label":0
    },
    {
        "ins1AddCode":"prepareResponse((response) -> { prepareResponse((response) -> { .consumeNextWith((tokenKeys) -> assertThat(tokenKeys.get(\"test-key\")) expectRequest((request) -> assertThat(request.getPath()) expectRequest((request) -> assertThat(request.getPath())",
        "ins1DelCode":"prepareResponse(response -> { prepareResponse(response -> { .consumeNextWith(tokenKeys -> assertThat(tokenKeys.get(\"test-key\")) expectRequest(request -> assertThat(request.getPath()) expectRequest(request -> assertThat(request.getPath())",
        "ins1PreCode":"+ \"kqwIn7Glry9n9Suxygbf8g5AzpWcusZgDLIIZ7JTUldBb8qU2a0Dl4mvLZOn4wPo\\n\" + \"jfj9Cw2QICsc5+Pwf21fP+hzf+1WSRHbnYv8uanRO0gZ8ekGaghM/2H6gqJbo2nI\\n\" + \"JwIDAQAB\\n-----END PUBLIC KEY-----\"; prepareResponse(response -> { response.setBody(\"{\\\"token_endpoint\\\":\\\"/my-uaa.com\\\"}\"); response.setHeader(\"Content-Type\", \"application/json\"); }); String responseBody = \"{\\\"keys\\\" : [ {\\\"kid\\\":\\\"test-key\\\",\\\"value\\\" : \\\"\" + tokenKeyValue.replace(\"\\n\", \"\\\\n\") + \"\\\"} ]}\"; prepareResponse(response -> { response.setBody(responseBody); response.setHeader(\"Content-Type\", \"application/json\"); }); StepVerifier.create(this.securityService.fetchTokenKeys()) .consumeNextWith(tokenKeys -> assertThat(tokenKeys.get(\"test-key\")) .isEqualTo(tokenKeyValue)) .expectComplete().verify(); expectRequest(request -> assertThat(request.getPath()) .isEqualTo(\"/my-cloud-controller.com/info\")); expectRequest(request -> assertThat(request.getPath()) .isEqualTo(\"/my-uaa.com/token_keys\"));",
        "ins2PreCode":"response.setBody(\"{\\\"token_endpoint\\\":\\\"/my-uaa.com\\\"}\"); .isEqualTo(\"/my-cloud-controller.com/info\")); response.setBody(\"{\\\"token_endpoint\\\":\\\"/my-uaa.com\\\"}\"); prepareResponse(response -> { response.setBody(\"{\\\"token_endpoint\\\":\\\"/my-uaa.com\\\"}\"); response.setHeader(\"Content-Type\", \"application/json\"); }); String responseBody = \"{\\\"keys\\\": []}\"; response.setBody(\"{\\\"token_endpoint\\\":\\\"/my-uaa.com\\\"}\"); prepareResponse(response -> { response.setBody(responseBody); response.setHeader(\"Content-Type\", \"application/json\"); }); StepVerifier.create(this.securityService.fetchTokenKeys()) .consumeNextWith(tokenKeys -> assertThat(tokenKeys).hasSize(0)) .isEqualTo(\"/my-uaa.com/token_keys\")); .expectComplete().verify(); expectRequest(request -> assertThat(request.getPath()) .isEqualTo(\"/my-cloud-controller.com/info\")); expectRequest(request -> assertThat(request.getPath()) .isEqualTo(\"/my-uaa.com/token_keys\"));",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1DelCode":"assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins1PreCode":" String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString(); assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>02-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>04-hello world</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>06-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Long>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.count(value -> value));",
        "ins1DelCode":"Dataset<Tuple2<String, Long>> agged = grouped.agg(typed.count(value -> value));",
        "ins1PreCode":"public void testTypedAggregationCount() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg(typed.count(value -> value)); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 2L), new Tuple2<>(\"b\", 1L)),",
        "ins2PreCode":"public void testTypedAggregationCount() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Long>> agged = grouped.agg(typed.count(v -> v)); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 2L), new Tuple2<>(\"b\", 1L)),",
        "label":1
    },
    {
        "ins1AddCode":"return IntStream.range(0, authors.length()) .mapToObj(authors::getJSONObject) .map((author) -> new Author( author.optString(\"given\", \"\"), \"\", \"\", author.optString(\"family\", \"\"), \"\")) .collect(AuthorList.collect()) .getAsFirstLastNamesWithAnd();",
        "ins1DelCode":"AuthorList authorsParsed = new AuthorList(); for (int i = 0; i < authors.length(); i++) { JSONObject author = authors.getJSONObject(i); authorsParsed.addAuthor( author.optString(\"given\", \"\"), \"\", \"\", author.optString(\"family\", \"\"), \"\"); } return authorsParsed.getAsFirstLastNamesWithAnd();",
        "ins1PreCode":"}   AuthorList authorsParsed = new AuthorList(); for (int i = 0; i < authors.length(); i++) { JSONObject author = authors.getJSONObject(i); authorsParsed.addAuthor( author.optString(\"given\", \"\"), \"\", \"\", author.optString(\"family\", \"\"), \"\"); } return authorsParsed.getAsFirstLastNamesWithAnd();",
        "ins2PreCode":"} AuthorList authorsParsed = new AuthorList(); for (int i = 0; i < authors.length(); i++) { JSONObject author = authors.getJSONObject(i); AuthorList authorsParsed = new AuthorList(); authorsParsed.addAuthor(author.getString(\"literal\"), \"\", \"\", \"\", \"\"); return \"\"; return \"\"; authorsParsed.addAuthor(author.optString(\"given\", \"\"), \"\", \"\", author.optString(\"family\", \"\"), \"\"); return \"\"; } return authorsParsed.getAsFirstLastNamesWithAnd();",
        "label":0
    },
    {
        "ins1AddCode":"dirCache.add(dir);",
        "ins1DelCode":"dirCache.addElement(dir);",
        "ins1PreCode":"+ \"directory: \" + ftp.getReplyString()); } } dirCache.addElement(dir); } ftp.changeWorkingDirectory(cwd);",
        "ins2PreCode":"+ \"directory: \" + ftp.getReplyString()); } } dirCache.addElement(dir); } ftp.changeWorkingDirectory(cwd);",
        "label":1
    },
    {
        "ins1AddCode":"List<Path> result = fileFinder.findAssociatedFiles(entry, List.of(directory), PDF_EXTENSION); List<Path> expected = List.of(directory.resolve(\"directory/subdirectory/2003_Hippel_209.pdf\")); assertEquals(expected, result);",
        "ins1DelCode":"List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); List<Path> result = fileFinder.findAssociatedFiles(entry, dirs, extensions); assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/2003_Hippel_209.pdf\")), result);",
        "ins1PreCode":"void testYearAuthFirstPageFindFiles() throws Exception {  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[year]_[auth]_[firstpage].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(entry, dirs, extensions);   assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/2003_Hippel_209.pdf\")), result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(person.getId()).isEqualTo(1); assertThat(person.getFirstName()).isEqualTo(\"John\"); assertThat(person.getLastName()).isEqualTo(\"Smith\"); assertThat(person.getPersonType()).isEqualTo(Person.PersonType.PERSON); assertThat(employee.getId()).isEqualTo(2); assertThat(employee.getFirstName()).isEqualTo(\"Mike\"); assertThat(employee.getLastName()).isEqualTo(\"Jordan\"); assertThat(employee.getPersonType()).isEqualTo(Person.PersonType.EMPLOYEE);",
        "ins1DelCode":"assertThat(person.getId(), is(1)); assertThat(person.getFirstName(), is(\"John\")); assertThat(person.getLastName(), is(\"Smith\")); assertThat(person.getPersonType(), is(Person.PersonType.PERSON)); assertThat(employee.getId(), is(2)); assertThat(employee.getFirstName(), is(\"Mike\")); assertThat(employee.getLastName(), is(\"Jordan\")); assertThat(employee.getPersonType(), is(Person.PersonType.EMPLOYEE));",
        "ins1PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); { Person person = personMapper.findOneUsingConstructor(1); assertThat(person.getId(), is(1)); assertThat(person.getFirstName(), is(\"John\")); assertThat(person.getLastName(), is(\"Smith\")); assertThat(person.getPersonType(), is(Person.PersonType.PERSON)); } { Person employee = personMapper.findOneUsingConstructor(2); assertThat(employee.getId(), is(2)); assertThat(employee.getFirstName(), is(\"Mike\")); assertThat(employee.getLastName(), is(\"Jordan\")); assertThat(employee.getPersonType(), is(Person.PersonType.EMPLOYEE)); }",
        "ins2PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); { Person person = personMapper.findOneUsingSetter(1); assertThat(person.getId(), is(1)); assertThat(person.getFirstName(), is(\"John\")); assertThat(person.getLastName(), is(\"Smith\")); assertThat(person.getPersonType(), is(Person.PersonType.PERSON)); } { Person employee = personMapper.findOneUsingSetter(2); assertThat(employee.getId(), is(2)); assertThat(employee.getFirstName(), is(\"Mike\")); assertThat(employee.getLastName(), is(\"Jordan\")); assertThat(employee.getPersonType(), is(Person.PersonType.EMPLOYEE)); }",
        "label":1
    },
    {
        "ins1AddCode":"public void onError(@NonNull Throwable t) {",
        "ins1DelCode":"public void onError(Throwable t) {",
        "ins1PreCode":"public void onError(Throwable t) { if (done) { RxJavaPlugins.onError(t);",
        "ins2PreCode":"public void onError(@NonNull Throwable t) { if (done) { RxJavaPlugins.onError(t);",
        "label":0
    },
    {
        "ins1AddCode":"sql = String.format(SQL_UK_TAB,ExasolUtils.quoteString(exasolSchema.getName()), ExasolUtils.quoteString(forTable.getName()),ExasolUtils.quoteString(exasolSchema.getName()), ExasolUtils.quoteString(forTable.getName())); sql = String.format(SQL_UK_ALL,ExasolUtils.quoteString(exasolSchema.getName()),ExasolUtils.quoteString(exasolSchema.getName()));",
        "ins1DelCode":"sql = String.format(SQL_UK_TAB,ExasolUtils.quoteString(exasolSchema.getName()), ExasolUtils.quoteString(forTable.getName())); sql = String.format(SQL_UK_ALL,ExasolUtils.quoteString(exasolSchema.getName()));",
        "ins1PreCode":" String sql; if (forTable != null) { sql = String.format(SQL_UK_TAB,ExasolUtils.quoteString(exasolSchema.getName()), ExasolUtils.quoteString(forTable.getName())); } else { sql = String.format(SQL_UK_ALL,ExasolUtils.quoteString(exasolSchema.getName())); } ",
        "ins2PreCode":"String sql; if (forTable != null) { sql = String.format(SQL_FK_TAB,ExasolUtils.quoteString(exasolSchema.getName()),ExasolUtils.quoteString(forTable.getName())); } else { sql = String.format(SQL_FK_ALL,ExasolUtils.quoteString(exasolSchema.getName())); }",
        "label":1
    },
    {
        "ins1AddCode":"public void testTransformKeys() throws Exception {",
        "ins1DelCode":"public void testTransformKeys() {",
        "ins1PreCode":"public void testTransformKeys() { checkAnswer( mapDf.select(transform_keys(col(\"x\"), (k, v) -> k.plus(v))),",
        "ins2PreCode":"public void testTransformValues() { checkAnswer( mapDf.select(transform_values(col(\"x\"), (k, v) -> k.plus(v))),",
        "label":1
    },
    {
        "ins1AddCode":"newProtocols.add(MockOptInProtocol1.NAME); assertProtocolEnabled(MockOptInProtocol1.NAME, \"before the roundtrip\"); assertProtocolEnabled(MockOptInProtocol1.NAME, \"after the roundtrip\");",
        "ins1DelCode":"Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\"))); newProtocols.add(\"JNLP3-connect\"); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\")); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\"));",
        "ins1PreCode":"public void agentProtocols_singleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\")));  final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\"));  j.jenkins.reload();  final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have additional enabled protocol\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 1)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\"));",
        "ins2PreCode":"public void agentProtocols_multipleEnable_roundtrip() throws Exception { final Set<String> defaultProtocols = Collections.unmodifiableSet(j.jenkins.getAgentProtocols()); Assume.assumeThat(\"We assume that JNLP3-connect is disabled\", defaultProtocols, not(hasItem(\"JNLP3-connect\"))); final Set<String> newProtocols = new HashSet<>(defaultProtocols); newProtocols.add(\"JNLP3-connect\"); j.jenkins.setAgentProtocols(newProtocols); j.jenkins.save(); final Set<String> agentProtocolsBeforeReload = j.jenkins.getAgentProtocols(); assertThat(\"JNLP3-connect must be enabled before the roundtrip\", j.jenkins.getAgentProtocols(), hasItem(\"JNLP3-connect\")); j.jenkins.reload(); final Set<String> reloadedProtocols = j.jenkins.getAgentProtocols(); assertFalse(\"The protocol list must have been really reloaded\", agentProtocolsBeforeReload == reloadedProtocols); assertThat(\"We should have two additional enabled protocols\", reloadedProtocols.size(), equalTo(defaultProtocols.size() + 2)); assertThat(\"JNLP3-connect must be enabled after the roundtrip\", reloadedProtocols, hasItem(\"JNLP3-connect\"));",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final ExasolTableForeignKey constraint = command.getObject(); if (command.getProperties().containsKey(\"enabled\")) { actionList.add( new SQLDatabasePersistAction(\"Alter FK\", \"ALTER TABLE \" + constraint.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" MODIFY CONSTRAINT \" + constraint.getName() + \" \" + (constraint.getEnabled() ? \"ENABLE\" : \"DISABLE\") ) ); } }",
        "ins1DelCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final ExasolTableForeignKey constraint = command.getObject(); if (command.getProperties().containsKey(\"enabled\")) { actionList.add( new SQLDatabasePersistAction(\"Alter FK\", \"ALTER TABLE \" + constraint.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" MODIFY CONSTRAINT \" + constraint.getName() + \" \" + (constraint.getEnabled() ? \"ENABLE\" : \"DISABLE\") ) ); } }",
        "ins1PreCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final ExasolTableForeignKey constraint = command.getObject();  if (command.getProperties().containsKey(\"enabled\")) { actionList.add( new SQLDatabasePersistAction(\"Alter FK\",",
        "ins2PreCode":"protected void addObjectModifyActions(List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final ExasolTableUniqueKey constraint = command.getObject(); if (command.getProperties().containsKey(\"enabled\")) { actionList.add( new SQLDatabasePersistAction(\"Alter PK\",",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init(); tearDown();",
        "ins1PreCode":"public void testPoolThreads20Connections10() throws Exception { System.out.println(\"[testPoolThreads20Connections10] Starting fairness - Tomcat JDBC - Non Fair\"); init(); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown(); ",
        "ins2PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { System.out.println(\"[testPoolThreads20Connections10Fair] Starting fairness - Tomcat JDBC - Fair\"); init(); this.threadcount = 20; this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource; } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10Fair\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "label":1
    },
    {
        "ins1AddCode":"ErrorServlet error = new ErrorServlet(true);",
        "ins1DelCode":"ErrorServlet error = new ErrorServlet();",
        "ins1PreCode":"wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/stage1\", \"dispatch\");  ErrorServlet error = new ErrorServlet(); Tomcat.addServlet(ctx, \"error\", error); ctx.addServletMapping(\"/stage2\", \"error\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3); assertThat(network.edges()).containsExactly(E15, E41, E23);",
        "ins1DelCode":"assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder();",
        "ins1PreCode":"assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15)); assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder(); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15); assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);",
        "ins2PreCode":"assertTrue(networkAsMutableNetwork.addEdge(N1, N5, E15)); assertTrue(networkAsMutableNetwork.addEdge(N4, N1, E41)); assertTrue(networkAsMutableNetwork.addEdge(N2, N3, E23)); assertThat(network.nodes()).containsExactly(N1, N5, N4, N2, N3).inOrder(); assertThat(network.edges()).containsExactly(E15, E41, E23).inOrder(); assertThat(network.edgesConnecting(N1, N5)).containsExactly(E15); assertThat(network.edgesConnecting(N4, N1)).containsExactly(E41);",
        "label":1
    },
    {
        "ins1AddCode":"DateTickUnit unit = new DateTickUnit(DateTickUnitType.DAY, 1); Date nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault()); nsd = unit.addToDate(psd, TimeZone.getDefault());",
        "ins1DelCode":"DateTickUnit unit = new DateTickUnit(DateTickUnit.DAY, 1); Date nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd); nsd = unit.addToDate(psd);",
        "ins1PreCode":" Date end = new Date(apr22007.getLastMillisecond());  DateTickUnit unit = new DateTickUnit(DateTickUnit.DAY, 1); axis.setTickUnit(unit);   axis.setTickMarkPosition(DateTickMarkPosition.START);  axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime());  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE);  axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime());  axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime());  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());   axis.setTickMarkPosition(DateTickMarkPosition.END);  axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime());  axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "ins2PreCode":"Date end = new Date(apr22007.getLastMillisecond()); DateTickUnit unit = new DateTickUnit(DateTickUnit.DAY, 7); axis.setTickUnit(unit); axis.setTickMarkPosition(DateTickMarkPosition.START); axis.setRange(d0, end); Date psd = axis.previousStandardDate(d0, unit); Date nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d0.getTime()); assertTrue(nsd.getTime() >= d0.getTime()); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.MIDDLE); axis.setRange(d1, end); psd = axis.previousStandardDate(d1, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d1.getTime()); assertTrue(nsd.getTime() >= d1.getTime()); axis.setRange(d2, end); psd = axis.previousStandardDate(d2, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d2.getTime()); assertTrue(nsd.getTime() >= d2.getTime()); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setTickMarkPosition(DateTickMarkPosition.END); axis.setRange(d3, end); psd = axis.previousStandardDate(d3, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d3.getTime()); assertTrue(nsd.getTime() >= d3.getTime()); axis.setRange(d4, end); psd = axis.previousStandardDate(d4, unit); nsd = unit.addToDate(psd); assertTrue(psd.getTime() < d4.getTime()); assertTrue(nsd.getTime() >= d4.getTime());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertValue() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  ts.onSubscribe(new BooleanSubscription());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertFalse(corsFilter.isSupportsCredentials());",
        "ins1DelCode":"Assert.assertTrue(corsFilter.isSupportsCredentials());",
        "ins1PreCode":"Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0); Assert.assertTrue(corsFilter.isAnyOriginAllowed()); Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0); Assert.assertTrue(corsFilter.isSupportsCredentials()); Assert.assertTrue(corsFilter.getPreflightMaxAge() == 1800);",
        "ins2PreCode":"Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0); Assert.assertTrue(corsFilter.getAllowedOrigins().size() == 0); Assert.assertTrue(corsFilter.getExposedHeaders().size() == 0); Assert.assertFalse(corsFilter.isSupportsCredentials()); Assert.assertTrue(corsFilter.getPreflightMaxAge() == 0);",
        "label":0
    },
    {
        "ins1AddCode":"List<Row> actual = sqlContext.sql(\"SELECT * FROM people\").collectAsList(); Assert.assertEquals(expected, actual);",
        "ins1DelCode":"Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collectRows(); Assert.assertEquals(expected, Arrays.asList(actual));",
        "ins1PreCode":" Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); Row[] actual = sqlContext.sql(\"SELECT * FROM people\").collectRows();  List<Row> expected = new ArrayList<>(2); expected.add(RowFactory.create(\"Michael\", 29)); expected.add(RowFactory.create(\"Yin\", 28));  Assert.assertEquals(expected, Arrays.asList(actual));",
        "ins2PreCode":"Dataset<Row> df = sqlContext.createDataFrame(rowRDD, schema); df.registerTempTable(\"people\"); List<String> actual = sqlContext.sql(\"SELECT * FROM people\").toJavaRDD().map(new Function<Row, String>() { List<String> expected = new ArrayList<>(2); expected.add(\"Michael_29\"); expected.add(\"Yin_28\"); Assert.assertEquals(expected, actual);",
        "label":0
    },
    {
        "ins1AddCode":"Processor processor = new SplitProcessor(randomAlphaOfLength(10), null, fieldName, \"\\\\.\", false, false, fieldName);",
        "ins1DelCode":"Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, false, fieldName);",
        "ins1PreCode":"public void testSplit() throws Exception { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"127.0.0.1\"); Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, false, fieldName); processor.execute(ingestDocument); assertThat(ingestDocument.getFieldValue(fieldName, List.class), equalTo(Arrays.asList(\"127\", \"0\", \"0\", \"1\")));",
        "ins2PreCode":"public void testSplitWithTargetField() throws Exception { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random()); String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, \"127.0.0.1\"); Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, false, targetFieldName); processor.execute(ingestDocument); assertThat(ingestDocument.getFieldValue(targetFieldName, List.class), equalTo(Arrays.asList(\"127\", \"0\", \"0\", \"1\")));",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l);  XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(mapping, \"Mapping\");",
        "ins1DelCode":"ctx.addServletMapping(mapping, \"Mapping\");",
        "ins1PreCode":"Context ctx = tomcat.addContext(contextPath, null);  Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(mapping, \"Mapping\");  tomcat.start();",
        "ins2PreCode":"Context ctx = tomcat.addContext(contextPath, null); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); tomcat.start();",
        "label":0
    },
    {
        "ins1AddCode":"void matchWithIncludeFilter() throws Exception {",
        "ins1DelCode":"public void matchWithIncludeFilter() throws Exception {",
        "ins1PreCode":"public void matchWithIncludeFilter() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithIncludeFilter.class); assertThat(excludes(filter, Controller1.class)).isFalse();",
        "ins2PreCode":"public void matchWithExcludeFilter() throws Exception { WebMvcTypeExcludeFilter filter = new WebMvcTypeExcludeFilter(WithExcludeFilter.class); assertThat(excludes(filter, Controller2.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"list = new ArrayList<>();",
        "ins1DelCode":"list = new ArrayList<ParamIgnore>();",
        "ins1PreCode":"String key = ignore.toString(); List<ParamIgnore> list = ignores.get(key); if (list == null) { list = new ArrayList<ParamIgnore>(); ignores.put(key, list); }",
        "ins2PreCode":"String key = ignore.toString(); List<ParamOverride> list = overrides.get(key); if (list == null) { list = new ArrayList<ParamOverride>(); overrides.put(key, list); }",
        "label":0
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article\\n{\\ntest,author={Ed von Test}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (!(Model.getFacade().isAPseudostate(dm))) { return NO_PROBLEM; } Model.getPseudostateKind().getShallowHistory())) { } if (nOutgoing > 1) { return PROBLEM_FOUND; }",
        "ins1DelCode":"if (!(Model.getFacade().isAPseudostate(dm))) return NO_PROBLEM; Model.getPseudostateKind().getShallowHistory())) if (nOutgoing > 1) return PROBLEM_FOUND;",
        "ins1PreCode":"public boolean predicate2(Object dm, Designer dsgr) { if (!(Model.getFacade().isAPseudostate(dm))) return NO_PROBLEM; Object k = Model.getFacade().getKind(dm); if (!Model.getFacade().equalsPseudostateKind(k, Model.getPseudostateKind().getDeepHistory()) && !Model.getFacade().equalsPseudostateKind(k, Model.getPseudostateKind().getShallowHistory())) return NO_PROBLEM; Collection outgoing = Model.getFacade().getOutgoings(dm); int nOutgoing = outgoing == null ? 0 : outgoing.size(); if (nOutgoing > 1) return PROBLEM_FOUND; return NO_PROBLEM;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"NioTcpServer httpServer = new NioTcpServer(); httpServer.setReuseAddress(true); httpServer.setFilters(new LoggingFilter(\"INCOMING\"), new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new LoggingFilter(\"DECODED\"), new DummyHttpSever()); httpServer.getSessionConfig().setTcpNoDelay(true); httpServer.bind(new InetSocketAddress(8080)); httpServer.unbind();",
        "ins1DelCode":"NioTcpServer acceptor = new NioTcpServer(); acceptor.setFilters(new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new DummyHttpSever()); acceptor.getSessionConfig().setTcpNoDelay(true); acceptor.bind(new InetSocketAddress(8080)); acceptor.unbind();",
        "ins1PreCode":"public static void main(String[] args) throws Exception {  NioTcpServer acceptor = new NioTcpServer(); acceptor.setFilters(new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new DummyHttpSever());  acceptor.getSessionConfig().setTcpNoDelay(true);  acceptor.bind(new InetSocketAddress(8080));   Thread.sleep(20000); acceptor.unbind(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/MapperConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/selectkey/CreateDB.sql\");",
        "ins1DelCode":"Connection conn = null; try { Class.forName(\"org.hsqldb.jdbcDriver\"); conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:lname\", \"sa\", \"\"); Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/CreateDB.sql\"); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); runner.runScript(reader); conn.commit(); reader.close(); reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/MapperConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class); } finally { if (conn != null) { conn.close(); } }",
        "ins1PreCode":"public void setUp() throws Exception { Connection conn = null;  try { Class.forName(\"org.hsqldb.jdbcDriver\"); conn = DriverManager.getConnection(\"jdbc:hsqldb:mem:lname\", \"sa\", \"\");  Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/CreateDB.sql\");  ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setErrorLogWriter(null); runner.runScript(reader); conn.commit(); reader.close();  reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/MapperConfig.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().addMapper(AnnotatedMapper.class); } finally { if (conn != null) { conn.close(); } }",
        "ins2PreCode":"public static void setUp() throws Exception { Connection conn = session.getConnection(); public static void setUp() throws Exception { Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/result_handler/mybatis-config.xml\"); Connection conn = session.getConnection(); conn.close(); reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/result_handler/CreateDB.sql\"); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.setLogWriter(null); runner.runScript(reader); conn.close(); reader.close(); Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/result_handler/mybatis-config.xml\"); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); reader.close(); sqlSessionFactory.getConfiguration().addMapper(Mapper.class); session.close(); conn.close(); conn.close(); } }",
        "label":0
    },
    {
        "ins1AddCode":"ClientEndpointConfig.Builder.create().build(),",
        "ins1DelCode":"Builder.create().build(),",
        "ins1PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins2PreCode":"WebSocketContainer wsContainer = ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterEndpoint.class, Builder.create().build(), new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC)); new URI(\"http://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":1
    },
    {
        "ins1AddCode":"AsyncObserver<Long> async = new AsyncObserver<>(observer);",
        "ins1DelCode":"AsyncObserver<Long> async = new AsyncObserver<Long>(observer);",
        "ins1PreCode":"SlowObservable so = new SlowObservable(100, 0, \"testUnsubscribeAfterError\"); Observable<Long> o = Observable.unsafeCreate(so).retry(5);  AsyncObserver<Long> async = new AsyncObserver<Long>(observer);  o.subscribe(async);",
        "ins2PreCode":"SlowObservable so = new SlowObservable(100, 10, \"testTimeoutWithRetry\"); Observable<Long> o = Observable.unsafeCreate(so).timeout(80, TimeUnit.MILLISECONDS).retry(5); AsyncObserver<Long> async = new AsyncObserver<Long>(observer); o.subscribe(async);",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(result.isEmpty());",
        "ins1DelCode":"Assert.assertTrue(result.isEmpty());",
        "ins1PreCode":"List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);   Assert.assertTrue(result.isEmpty());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"checkNotNull(collection);",
        "ins1DelCode":"if (collection == null) { throw new NullPointerException(); }",
        "ins1PreCode":"public boolean addAll(Collection<? extends Long> collection) { ensureIsMutable();  if (collection == null) { throw new NullPointerException(); } ",
        "ins2PreCode":"public boolean addAll(Collection<? extends Double> collection) { ensureIsMutable(); if (collection == null) { throw new NullPointerException(); }",
        "label":1
    },
    {
        "ins1AddCode":"throw new IOException(sm.getString(\"endpoint.nio.keyMustBeCancelled\"));",
        "ins1DelCode":"throw new IOException(\"Key must be cancelled.\");",
        "ins1PreCode":"NioEndpoint.NioSocketWrapper att = (NioEndpoint.NioSocketWrapper) channel .getAttachment(); if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(to, channel, selector, att.getReadTimeout());",
        "ins2PreCode":"pool.write(from, getSocket(), selector, writeTimeout, block); updateLastWrite(); if (selector != null) { } catch (IOException x) { } pool.write(from, getSocket(), selector, writeTimeout, block);",
        "label":0
    },
    {
        "ins1AddCode":"throws AttributeNotFoundException, ReflectionException { Method m = null; AttributeInfo attrInfo = attributes.get(aname); if (attrInfo == null) throw new AttributeNotFoundException(\" Cannot find attribute \" + aname + \" for \" + resource); String getMethod = attrInfo.getGetMethod(); if (getMethod == null) throw new AttributeNotFoundException(\"Cannot find attribute \" + aname + \" get method name\"); Object object = null; NoSuchMethodException exception = null; try { object = mbean; m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG); } catch (NoSuchMethodException e) { exception = e; } if( m== null && resource != null ) { object = resource; exception=null; if( exception != null ) throw new ReflectionException(exception, \"Cannot find getter method \" + getMethod);",
        "ins1DelCode":"throws AttributeNotFoundException, MBeanException, ReflectionException { Method m=null; if( m==null ) { AttributeInfo attrInfo = attributes.get(aname); if (attrInfo == null) throw new AttributeNotFoundException(\" Cannot find attribute \" + aname + \" for \" + resource); String getMethod = attrInfo.getGetMethod(); if (getMethod == null) throw new AttributeNotFoundException(\"Cannot find attribute \" + aname + \" get method name\"); Object object = null; NoSuchMethodException exception = null; object = mbean; if( m== null && resource != null ) { try { object = resource; m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG); exception=null; } catch (NoSuchMethodException e) { exception = e; } } if( exception != null ) throw new ReflectionException(exception, \"Cannot find getter method \" + getMethod);",
        "ins1PreCode":"Method getGetter(String aname, BaseModelMBean mbean, Object resource) throws AttributeNotFoundException, MBeanException, ReflectionException {  Method m=null;  if( m==null ) { AttributeInfo attrInfo = attributes.get(aname); ",
        "ins2PreCode":"public Method getSetter(String aname, BaseModelMBean bean, Object resource) throws AttributeNotFoundException, MBeanException, ReflectionException { Method m=null; if( m==null ) { AttributeInfo attrInfo = attributes.get(aname);",
        "label":1
    },
    {
        "ins1AddCode":"if (x.getMessage().contains(\"option flag conflict\")) error = true;",
        "ins1DelCode":"if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true;",
        "ins1PreCode":"try { channel.start(Channel.DEFAULT); }catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; } assertTrue(error);",
        "ins2PreCode":"try { channel.start(Channel.DEFAULT); }catch ( ChannelException x ) { if ( x.getMessage().indexOf(\"option flag conflict\") >= 0 ) error = true; } assertFalse(error);",
        "label":1
    },
    {
        "ins1AddCode":"BibEntry entry = parsed.iterator().next(); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"List<BibEntry> parsed = result.getDatabase().getEntries(); assertEquals(1, parsed.size());  BibEntry e = parsed.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1AddCode":"XYIntervalSeriesCollection<String> c1 = new XYIntervalSeriesCollection<>(); XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"Series\"); XYIntervalSeriesCollection<String> c2 = CloneUtils.clone(c1); c1.addSeries(new XYIntervalSeries<>(\"Empty\")); c2.addSeries(new XYIntervalSeries<>(\"Empty\"));",
        "ins1DelCode":"XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); XYIntervalSeriesCollection c2 = CloneUtils.clone(c1); c1.addSeries(new XYIntervalSeries(\"Empty\")); c2.addSeries(new XYIntervalSeries(\"Empty\"));",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); XYIntervalSeriesCollection c2 = CloneUtils.clone(c1); assertTrue(c1 != c2); assertTrue(c1.getClass() == c2.getClass()); assertTrue(c1.equals(c2));   c1.addSeries(new XYIntervalSeries(\"Empty\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries(\"Empty\")); assertTrue(c1.equals(c2));",
        "ins2PreCode":"public void testSerialization() { XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); XYIntervalSeriesCollection c2 = TestUtils.serialised(c1); assertTrue(c1.equals(c2)); assertTrue(c1.equals(c2)); assertTrue(c1.equals(c2)); c1.addSeries(new XYIntervalSeries(\"Empty\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries(\"Empty\")); assertTrue(c1.equals(c2));",
        "label":1
    },
    {
        "ins1AddCode":"JNDIConnection connection = null; connection = get(); principal = authenticate(connection, username, credentials); close(connection); connection = get(); principal = authenticate(connection, username, credentials); release(connection); close(connection);",
        "ins1DelCode":"DirContext context = null; context = open(); principal = authenticate(context, username, credentials); if (context != null) close(context); context = open(); principal = authenticate(context, username, credentials); release(context); if (context != null) close(context);",
        "ins1PreCode":"public Principal authenticate(String username, String credentials) {  DirContext context = null; Principal principal = null;  try {   context = open();    try {   principal = authenticate(context, username, credentials);  } catch (NullPointerException | NamingException e) {                 containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials); }    release(context);   return principal;  } catch (NamingException e) {   containerLog.error(sm.getString(\"jndiRealm.exception\"), e);   if (context != null) close(context);  ",
        "ins2PreCode":"principal = getPrincipal(context, username, gssCredential); DirContext context = null; Principal principal = null; try { context = open(); try { principal = getPrincipal(context, username, gssCredential); } catch (NamingException e) { containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } release(context); return principal; } catch (NamingException e) { containerLog.error(sm.getString(\"jndiRealm.exception\"), e); if (context != null) close(context);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); List<Flowable<Integer>> sourceList = new ArrayList<>(i); Set<Integer> expected = new HashSet<>(i); Set<Integer> actual = new HashSet<>(ts.values());",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); Set<Integer> actual = new HashSet<Integer>(ts.values());",
        "ins1PreCode":"public void simpleAsync() { for (int i = 1; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); }  Flowable.merge(sourceList, i).subscribe(ts);  ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(ts.values());  assertEquals(expected, actual);",
        "ins2PreCode":"public void simpleOneLessAsync() { for (int i = 2; i < 50; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); List<Flowable<Integer>> sourceList = new ArrayList<Flowable<Integer>>(i); Set<Integer> expected = new HashSet<Integer>(i); for (int j = 1; j <= i; j++) { sourceList.add(Flowable.just(j).subscribeOn(Schedulers.io())); expected.add(j); } Flowable.merge(sourceList, i - 1).subscribe(ts); ts.awaitDone(1, TimeUnit.SECONDS); ts.assertNoErrors(); Set<Integer> actual = new HashSet<Integer>(ts.values()); assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1AddCode":"\"5: 1\\n\" + \"5: 0x00000002\\n\" + \"5: 0x0000000000000003\\n\" + \"5: \\\"4\\\"\\n\" + \"5: {\\n\" + \"  12: 6\\n\" + \"}\\n\" + \"5 {\\n\" + \"  10: 5\\n\" + \"}\\n\" + \"8: 1\\n\" + \"8: 2\\n\" + \"8: 3\\n\" + \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "ins1DelCode":"\"5: 1\\n\" + \"5: 0x00000002\\n\" + \"5: 0x0000000000000003\\n\" + \"5: \\\"4\\\"\\n\" + \"5 {\\n\" + \"  10: 5\\n\" + \"}\\n\" + \"8: 1\\n\" + \"8: 2\\n\" + \"8: 3\\n\" + \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "ins1PreCode":".build();  assertEquals( \"5: 1\\n\" + \"5: 0x00000002\\n\" + \"5: 0x0000000000000003\\n\" + \"5: \\\"4\\\"\\n\" + \"5 {\\n\" + \"  10: 5\\n\" + \"}\\n\" + \"8: 1\\n\" + \"8: 2\\n\" + \"8: 3\\n\" + \"15: 12379813812177893520\\n\" + \"15: 0xabcd1234\\n\" + \"15: 0xabcdef1234567890\\n\", TextFormat.printToString(message));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void nearMaxValueWithoutBackpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(Integer.MAX_VALUE - 1, 2).subscribe(ts); ",
        "ins2PreCode":"public void nearMaxValueWithBackpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(3L); Flowable.range(Integer.MAX_VALUE - 1, 2).subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, null, config));",
        "ins1DelCode":"ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config));",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"{{field1}}\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\")); assertThat(exception.getMetadata(\"es.processor_tag\").get(0), equalTo(processorTag));",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"message\", \"{{error}}\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config)); assertThat(exception.getMessage(), equalTo(\"java.lang.RuntimeException: could not compile script\")); assertThat(exception.getMetadata(\"es.processor_tag\").get(0), equalTo(processorTag));",
        "label":1
    },
    {
        "ins1AddCode":"void shouldSelectDiscriminatedPost() throws Exception {",
        "ins1DelCode":"public void shouldSelectDiscriminatedPost() throws Exception {",
        "ins1PreCode":"public void shouldSelectDiscriminatedPost() throws Exception {  Executor executor = createExecutor(new JdbcTransaction(ds, null, false));",
        "ins2PreCode":"public void shouldSelect2DiscriminatedPosts() throws Exception { Executor executor = createExecutor(new JdbcTransaction(ds, null, false));",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertNotNull(person, \"person must not be null\"); Assertions.assertEquals(\"Christian\", person.getFirstName()); Assertions.assertEquals(\"Poitras\", person.getLastName()); Assertions.assertNotNull(parent, \"parent must not be null\"); Assertions.assertEquals(\"John\", parent.getFirstName()); Assertions.assertEquals(\"Smith\", parent.getLastName());",
        "ins1DelCode":"Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex2(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "label":1
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1AddCode":"this.webServer = factory.getWebServer((context) -> context .addServlet(\"failing\", FailingServlet.class).setLoadOnStartup(0));",
        "ins1DelCode":"this.webServer = factory.getWebServer((context) -> { context.addServlet(\"failing\", FailingServlet.class).setLoadOnStartup(0); });",
        "ins1PreCode":"((StandardContext) context).setFailCtxIfServletStartFails(true); } }); this.webServer = factory.getWebServer((context) -> { context.addServlet(\"failing\", FailingServlet.class).setLoadOnStartup(0); }); assertThatExceptionOfType(WebServerException.class)",
        "ins2PreCode":"((StandardContext) context).setFailCtxIfServletStartFails(false); } }); this.webServer = factory.getWebServer((context) -> { context.addServlet(\"failing\", FailingServlet.class).setLoadOnStartup(0); }); this.webServer = factory.getWebServer((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"list.add(new IacrEprintFetcher(importFormatPreferences));",
        "ins1DelCode":"",
        "ins1PreCode":"list.add(new MathSciNet(importFormatPreferences)); list.add(new CrossRef()); list.add(new LibraryOfCongress()); list.sort(Comparator.comparing(WebFetcher::getName)); return list;",
        "ins2PreCode":"set.add(new MathSciNet(importFormatPreferences)); set.add(new CrossRef()); set.add(new CrossRef()); SortedSet<SearchBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); return set;",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void mapperToEmpty() { TestObserver<Integer> to = new TestObserver<Integer>();  assertTrue(ObservableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), to, new Function<Integer, ObservableSource<Integer>>() {",
        "ins2PreCode":"public void mapperToCrashingCallable() { TestObserver<Integer> to = new TestObserver<Integer>(); assertTrue(ObservableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), to, new Function<Integer, ObservableSource<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"Single.create(new SingleOnSubscribe<Object>() { @Override public void subscribe(SingleEmitter<Object> s) throws Exception { Disposable d = Disposables.empty(); s.setDisposable(d); try {",
        "ins2PreCode":"Single.create(new SingleOnSubscribe<Object>() { @Override public void subscribe(SingleEmitter<Object> s) throws Exception { Disposable d = Disposables.empty(); s.setDisposable(d); try {",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T1, @NonNull T2, @NonNull T3, @NonNull T4, @NonNull T5, @NonNull T6, @NonNull R> Observable<R> combineLatest(",
        "ins1DelCode":"public static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest(",
        "ins1PreCode":"public static <T1, T2, T3, T4, T5, T6, R> Observable<R> combineLatest( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T4> source4,",
        "ins2PreCode":"public static <T1, T2, T3, T4, T5, T6, R> Observable<R> zip( @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3, @NonNull ObservableSource<? extends T1> source1, @NonNull ObservableSource<? extends T2> source2, @NonNull ObservableSource<? extends T3> source3,",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<?> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0);",
        "label":0
    },
    {
        "ins1AddCode":"skipTokens(st, 2);",
        "ins1DelCode":"if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken();",
        "ins1PreCode":"Argo.KEY_IMPORT_GENERAL_SETTINGS_FLAGS); if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) { return false;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(m.entrySet()).containsExactlyElementsIn(expected.entrySet()).inOrder();",
        "ins1DelCode":"assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "ins1PreCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\");  assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "ins2PreCode":"ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "label":1
    },
    {
        "ins1AddCode":"&& isSelected(name, scannedDirs.get(name))) {",
        "ins1DelCode":"&& isSelected(name, (File) scannedDirs.get(name))) {",
        "ins1PreCode":" if (isIncluded(name)) { if (!isExcluded(name) && isSelected(name, (File) scannedDirs.get(name))) { filesIncluded.addElement(name); } else {",
        "ins2PreCode":"if (isIncluded(name)) { if (!isExcluded(name) && isSelected(name, (File) scannedDirs.get(name))) { filesIncluded.addElement(name); } else {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"expected.remove(ACMPortalFetcher.class);",
        "ins1PreCode":"expected.remove(SearchBasedParserFetcher.class);   expected.remove(ACMPortalFetcher.class); expected.remove(JstorFetcher.class); expected.remove(GoogleScholar.class);",
        "ins2PreCode":"expected.remove(JstorFetcher.class); expected.remove(ACMPortalFetcher.class); expected.remove(JstorFetcher.class); expected.remove(GoogleScholar.class);",
        "label":1
    },
    {
        "ins1AddCode":"ArgoDiagram diagram = createDiagram(ns, p.getProjectSettings().getDefaultDiagramSettings());",
        "ins1DelCode":"ArgoDiagram diagram = createDiagram(ns);",
        "ins1PreCode":"Object ns = findNamespace();  if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns); assert (diagram != null) : \"No diagram was returned by the concrete class\";",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"memoryManager = new TestMemoryManager( new SparkConf().set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator())); taskMemoryManager = new TaskMemoryManager(memoryManager, 0); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments(); return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins1DelCode":"shuffleMemoryManager = ShuffleMemoryManager.create(Long.MAX_VALUE, PAGE_SIZE_BYTES); taskMemoryManager = new TaskMemoryManager(new ExecutorMemoryManager(getMemoryAllocator())); sizeLimitedTaskMemoryManager = mock(TaskMemoryManager.class); when(sizeLimitedTaskMemoryManager.allocate(geq(1L << 20))).thenAnswer( new Answer<MemoryBlock>() { @Override public MemoryBlock answer(InvocationOnMock invocation) throws Throwable { if (((Long) invocation.getArguments()[0] / 8) > Integer.MAX_VALUE) { throw new OutOfMemoryError(\"Requested array size exceeds VM limit\"); } return new MemoryBlock(null, 0, (Long) invocation.getArguments()[0]); } );",
        "ins1PreCode":"public void setup() { shuffleMemoryManager = ShuffleMemoryManager.create(Long.MAX_VALUE, PAGE_SIZE_BYTES); taskMemoryManager = new TaskMemoryManager(new ExecutorMemoryManager(getMemoryAllocator()));   sizeLimitedTaskMemoryManager = mock(TaskMemoryManager.class); when(sizeLimitedTaskMemoryManager.allocate(geq(1L << 20))).thenAnswer( new Answer<MemoryBlock>() { @Override public MemoryBlock answer(InvocationOnMock invocation) throws Throwable { if (((Long) invocation.getArguments()[0] / 8) > Integer.MAX_VALUE) { throw new OutOfMemoryError(\"Requested array size exceeds VM limit\"); } return new MemoryBlock(null, 0, (Long) invocation.getArguments()[0]); } }",
        "ins2PreCode":"public void setUp() { when(diskBlockManager.createTempLocalBlock()).thenAnswer(new Answer<Tuple2<TempLocalBlockId, File>>() { when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); taskContext = mock(TaskContext.class); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments(); taskContext = mock(TaskContext.class); } Object[] args = invocationOnMock.getArguments(); } }",
        "label":0
    },
    {
        "ins1AddCode":"public void heap() throws IOException { new TaskMemoryManager(new TestMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128, null); final MemoryBlock page1 = memoryManager.allocatePage(128, null);",
        "ins1DelCode":"public void heap() { new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128);",
        "ins1PreCode":"public void heap() { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1, page1.getBaseOffset() + 42);",
        "ins2PreCode":"public void offHeap() { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new GrantEverythingMemoryManager(conf), 0); final MemoryBlock page0 = memoryManager.allocatePage(128); final MemoryBlock page1 = memoryManager.allocatePage(128); final long addressInPage1 = memoryManager.encodePageNumberAndOffset(page1, page1.getBaseOffset() + 42);",
        "label":1
    },
    {
        "ins1AddCode":"writeBlocking = true; synchronized (writeLock) { if (writeBlocking) { writeLock.wait(timeout); writeLock.wait(); if (writeBlocking) { writeBlocking = false;",
        "ins1DelCode":"if (blockWriteDone == null) { blockWriteDone = new AtomicBoolean(false); } else { blockWriteDone.set(false); } synchronized (blockWriteDone) { if (!blockWriteDone.get()) { blockWriteDone.wait(timeout); blockWriteDone.wait(); if (!blockWriteDone.get()) { blockWriteDone = null;",
        "ins1PreCode":"throw new EOFException(); } if (n == 0) { if (blockWriteDone == null) { blockWriteDone = new AtomicBoolean(false); } else { blockWriteDone.set(false); } registerWriteInterest(); synchronized (blockWriteDone) { if (!blockWriteDone.get()) { try { if (timeout > 0) { blockWriteDone.wait(timeout); } else { blockWriteDone.wait(); } } catch (InterruptedException e) {  } if (!blockWriteDone.get()) { throw new SocketTimeoutException(); } } } } } while (from.hasRemaining()); } finally { blockWriteDone = null; } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (OutputStream out = Files.newOutputStream(dest.toPath()); GZIPInputStream zIn = new GZIPInputStream(srcResource.getInputStream())) {",
        "ins1DelCode":"OutputStream out = null; GZIPInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new GZIPInputStream(fis); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn);",
        "ins1PreCode":"if (srcResource.getLastModified() > dest.lastModified()) { log(\"Expanding \" + srcResource.getName() + \" to \" + dest.getAbsolutePath());  OutputStream out = null; GZIPInputStream zIn = null; InputStream fis = null; try { out = Files.newOutputStream(dest.toPath()); fis = srcResource.getInputStream(); zIn = new GZIPInputStream(fis); byte[] buffer = new byte[BUFFER_SIZE]; int count = 0; do { out.write(buffer, 0, count); count = zIn.read(buffer, 0, buffer.length); } while (count != -1); } catch (IOException ioe) { String msg = \"Problem expanding gzip \" + ioe.getMessage(); throw new BuildException(msg, ioe, getLocation()); } finally { FileUtils.close(fis); FileUtils.close(out); FileUtils.close(zIn); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":".flatMapMaybe(Functions.justFunction(new Maybe<Integer>() { @Override protected void subscribeActual(MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\")); observer.onError(new TestException(\"Second\"));",
        "ins2PreCode":".flatMapSingle(Functions.justFunction(new Single<Integer>() { @Override protected void subscribeActual(SingleObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\")); observer.onError(new TestException(\"Second\"));",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" assertFalse(rco.isDisposed());  Disposable d = Disposables.empty();  rco.add(d);",
        "ins2PreCode":"assertFalse(rco.isDisposed()); Disposable d = Disposables.empty(); rco.add(d);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); Assert.assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); Assert.assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); Assert.assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); Assert.assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "ins1DelCode":"assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "ins1PreCode":"} try { while (loopcount.get()<iter) { assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); ds.getPool().testAllIdle(); ds.getPool().checkAbandoned(); ds.getPool().checkIdle(); } }catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } for (int i=0; i<threads.length; i++) { threads[i].join(); } System.out.println(\"Connect count:\"+Driver.connectCount.get()); System.out.println(\"DisConnect count:\"+Driver.disconnectCount.get()); assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "ins2PreCode":"} try { while (loopcount.get()<iter) { assertTrue(\"Size comparison(less than 11):\",ds.getPool().getSize()<=10); ds.getPool().testAllIdle(); ds.getPool().checkAbandoned(); ds.getPool().checkIdle(); } }catch (Exception x) { loopcount.set(iter); x.printStackTrace(); } for (int i=0; i<threads.length; i++) { threads[i].join(); } System.out.println(\"Connect count:\"+Driver.connectCount.get()); System.out.println(\"DisConnect count:\"+Driver.disconnectCount.get()); assertEquals(\"Size comparison:\",10, ds.getPool().getSize()); assertEquals(\"Idle comparison:\",10, ds.getPool().getIdle()); assertEquals(\"Used comparison:\",0, ds.getPool().getActive()); assertEquals(\"Connect count\",10,Driver.connectCount.get());",
        "label":1
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"public void testCreateMissingField() throws Exception { Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"public void testCreateMissingField() throws Exception { Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(\"Backslashes are only dangerous on Windows\", Functions.isWindows());",
        "ins1DelCode":"Assume.assumeTrue(\"Backslash are only dangerous on Windows\", Functions.isWindows());",
        "ins1PreCode":"public void fileParameter_cannotCreateFile_outsideOfBuildFolder_backslashEdition() throws Exception { Assume.assumeTrue(\"Backslash are only dangerous on Windows\", Functions.isWindows());  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void webEndpointsCanBeExposed() {",
        "ins1DelCode":"public void webEndpointsCanBeExposed() {",
        "ins1PreCode":"public void webEndpointsCanBeExposed() { WebApplicationContextRunner contextRunner = this.contextRunner .withPropertyValues(\"management.endpoints.web.exposure.include=*\");",
        "ins2PreCode":"public void singleWebEndpointCanBeExcluded() { WebApplicationContextRunner contextRunner = this.contextRunner.withPropertyValues( \"management.endpoints.web.exposure.include=*\", \"management.endpoints.web.exposure.exclude=shutdown\");",
        "label":1
    },
    {
        "ins1AddCode":"Answers.CALLS_REAL_METHODS);",
        "ins1DelCode":"withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS));",
        "ins1PreCode":"public void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); given(source.containsDescendantOf(name)) .willReturn(ConfigurationPropertyState.ABSENT);",
        "ins2PreCode":"public void containsDescendantOfWhenSourceReturnsTrueShouldReturnEmpty() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); given(source.containsDescendantOf(name)) .willReturn(ConfigurationPropertyState.PRESENT);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>(); new ConcatMapSingleMainObserver<>(",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>(); new ConcatMapSingleMainObserver<Integer, Integer>(",
        "ins1PreCode":"public void cancelNoConcurrentClean() { TestObserver<Integer> to = new TestObserver<Integer>(); ConcatMapSingleMainObserver<Integer, Integer> operator = new ConcatMapSingleMainObserver<Integer, Integer>( to, Functions.justFunction(Single.<Integer>never()), 16, ErrorMode.IMMEDIATE); ",
        "ins2PreCode":"public void cancelNoConcurrentClean() { TestObserver<Integer> to = new TestObserver<Integer>(); ConcatMapMaybeMainObserver<Integer, Integer> operator = new ConcatMapMaybeMainObserver<Integer, Integer>( to, Functions.justFunction(Maybe.<Integer>never()), 16, ErrorMode.IMMEDIATE);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"Map<String,List<String>> headers = new HashMap<>();",
        "ins1DelCode":"Map<String,List<String>> headers = new HashMap<String,List<String>>();",
        "ins1PreCode":"assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.contextRunner.withPropertyValues(\"management.endpoint.health.probes.enabled=true\")",
        "ins1DelCode":"this.contextRunner.withPropertyValues(\"management.health.probes.enabled=true\")",
        "ins1PreCode":"void probesWhenPropertyEnabledAddsBeans() { this.contextRunner.withPropertyValues(\"management.health.probes.enabled=true\") .run((context) -> assertThat(context).hasSingleBean(ApplicationAvailability.class) .hasSingleBean(LivenessStateHealthIndicator.class)",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (text.length() == 0) { return; }",
        "ins1DelCode":"",
        "ins1PreCode":"text.append(item.getText(i)); } } UIUtils.setClipboardContents(table.getDisplay(), TextTransfer.getInstance(), text.toString()); } });",
        "ins2PreCode":"text.append(item.getText(i)); } } UIUtils.setClipboardContents(tree.getDisplay(), TextTransfer.getInstance(), text.toString()); } });",
        "label":1
    },
    {
        "ins1AddCode":"verifyNoInteractions(func);",
        "ins1DelCode":"verifyZeroInteractions(func);",
        "ins1PreCode":" Observable<Object> fromCallableObservable = Observable.fromCallable(func);  verifyZeroInteractions(func);  fromCallableObservable.subscribe();",
        "ins2PreCode":"Flowable<Object> fromCallableFlowable = Flowable.fromCallable(func); verifyZeroInteractions(func); fromCallableFlowable.subscribe();",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1);",
        "ins1DelCode":"CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1);",
        "ins1PreCode":"CategoryPlot p1 = new CategoryPlot(dataset, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.HORIZONTAL); CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1); assertTrue(p1.equals(p2));",
        "ins2PreCode":"CategoryPlot p1 = new CategoryPlot(data, domainAxis, rangeAxis, renderer); p1.setOrientation(PlotOrientation.VERTICAL); CategoryPlot p2 = (CategoryPlot) TestUtilities.serialised(p1); assertEquals(p1, p2);",
        "label":1
    },
    {
        "ins1AddCode":"LassoModel model = new LassoWithSGD(1.0, 100, 0.01, 1.0).run(testRDD.rdd());",
        "ins1DelCode":"LassoModel model = LassoWithSGD.train(testRDD.rdd(), 100, 1.0, 0.01, 1.0);",
        "ins1PreCode":"List<LabeledPoint> validationData = LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LassoModel model = LassoWithSGD.train(testRDD.rdd(), 100, 1.0, 0.01, 1.0);  int numAccurate = validatePrediction(validationData, model);",
        "ins2PreCode":"List<LabeledPoint> validationData = LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1); LinearRegressionModel model = linSGDImpl.run(testRDD.rdd()); int numAccurate = validatePrediction(validationData, model);",
        "label":0
    },
    {
        "ins1AddCode":"public static void execute(Shell shell, @NotNull final DBSDataSourceContainer dataSourceContainer) { DBPDataSource dataSource = dataSourceContainer.getDataSource(); if (dataSource != null) { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSource); if (txnManager != null) { DBCSession session = dataSource.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); }",
        "ins1DelCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.commit(monitor); } catch (DBCException e) { throw new InvocationTargetException(e);",
        "ins1PreCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.commit(monitor); } catch (DBCException e) { throw new InvocationTargetException(e);",
        "ins2PreCode":"public static void execute(Shell shell, final DBSDataSourceContainer dataSourceContainer) { try { DBeaverUI.runInProgressService(new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(dataSourceContainer.getDataSource()); if (txnManager != null) { try { txnManager.rollback(monitor, null); } catch (DBCException e) { throw new InvocationTargetException(e);",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> error = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> error = new AtomicReference<Throwable>();",
        "ins1PreCode":"public void customObservableWithErrorInObserverSynchronous() { final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>();  ",
        "ins2PreCode":"public void takeWithErrorInObserver() { final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>();",
        "label":1
    },
    {
        "ins1AddCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput output) { assertThat(output)",
        "ins1DelCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput capturedOutput) { assertThat(capturedOutput)",
        "ins1PreCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput capturedOutput) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(capturedOutput) .doesNotContain(\"Reached the maximum number of URI tags for 'http.client.requests'.\") .doesNotContain(\"Are you using 'uriVariables'?\");",
        "ins2PreCode":"void shouldNotDenyNorLogIfMaxUrisIsNotReached(CapturedOutput capturedOutput) { this.contextRunner.withPropertyValues(\"management.metrics.web.client.max-uri-tags=5\").run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(capturedOutput) .doesNotContain(\"Reached the maximum number of URI tags for 'http.client.requests'.\") .doesNotContain(\"Are you using 'uriVariables'?\");",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2));",
        "ins1DelCode":"JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });",
        "ins1PreCode":"Arrays.asList(9,10,11));  JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> transformed = stream.transform( new Function<JavaRDD<Integer>, JavaRDD<Integer>>() { @Override public JavaRDD<Integer> call(JavaRDD<Integer> in) { return in.map(new Function<Integer, Integer>() { @Override public Integer call(Integer i) { return i + 2; } }); } });  JavaTestUtils.attachTestOutputStream(transformed);",
        "ins2PreCode":"Arrays.asList(9, 10, 11)); JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2)); JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); public void testTransform() { JavaDStream<Integer> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); List<List<Integer>> expected = Arrays.asList( public void testTransform() { public void testTransform() { JavaDStream<Integer> transformed = stream.transform(in -> in.map(i -> i + 2)); } } } } JavaTestUtils.attachTestOutputStream(transformed);",
        "label":0
    },
    {
        "ins1AddCode":"setMapValuesUsingAccessors(builder);",
        "ins1DelCode":"setMapValuesUsingMutableMap(builder);",
        "ins1PreCode":"TestMap.Builder builder = TestMap.newBuilder(); assertMapCounts(0, builder);  setMapValuesUsingMutableMap(builder); assertMapCounts(3, builder); ",
        "ins2PreCode":"TestMap.Builder builder = TestMap.newBuilder(); assertMapCounts(0, builder); setMapValues(builder); assertMapCounts(3, builder);",
        "label":0
    },
    {
        "ins1AddCode":"long ts1 = new File(getOutputDir(), \"test.txt\").lastModified(); assertTrue(ts1 < new File(getOutputDir(), \"test.txt\").lastModified());",
        "ins1DelCode":"String tmpdir = project.getProperty(\"tmp.dir\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); assertTrue(ts1 < new File(tmpdir, \"test.txt\").lastModified());",
        "ins1PreCode":"public void testNoPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); String tmpdir = project.getProperty(\"tmp.dir\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testNoPreserve\"); assertTrue(ts1 < new File(tmpdir, \"test.txt\").lastModified());",
        "ins2PreCode":"public void testPreserveLastModified() throws Exception { executeTarget(\"lastModifiedSetup\"); String tmpdir = project.getProperty(\"tmp.dir\"); long ts1 = new File(tmpdir, \"test.txt\").lastModified(); Thread.sleep(3000); executeTarget(\"testPreserve\"); assertTrue(ts1 == new File(tmpdir, \"test.txt\").lastModified());",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void tryTerminateConsumerCompletableObserverError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty());  AtomicThrowable ex = new AtomicThrowable();",
        "ins2PreCode":"public void tryTerminateConsumerEmitterError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); AtomicThrowable ex = new AtomicThrowable();",
        "label":1
    },
    {
        "ins1AddCode":"addMapper();",
        "ins1DelCode":"",
        "ins1PreCode":"public void shouldApplyTypeHandlerWithJdbcTypeSpecified() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins2PreCode":"public void shouldApplyTypeHandlerUsingConstructor() throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph.edgeValueOrDefault(1, 2, DEFAULT)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrDefault(2, 1, DEFAULT)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrDefault(2, 3, DEFAULT)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, DEFAULT)).isEqualTo(\"valueD\");",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(\"valueD\");  String toString = graph.toString(); assertThat(toString).doesNotContain(\"valueA\"); assertThat(toString).contains(\"valueB\"); assertThat(toString).contains(\"valueC\"); assertThat(toString).contains(\"valueD\");",
        "ins2PreCode":"assertThat(graph.edgeValueOrDefault(2, 1, null)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrDefault(2, 3, null)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrDefault(4, 4, null)).isEqualTo(\"valueD\"); String toString = graph.toString(); assertThat(toString).contains(\"valueA\"); assertThat(toString).contains(\"valueB\"); assertThat(toString).contains(\"valueC\"); assertThat(toString).contains(\"valueD\");",
        "label":1
    },
    {
        "ins1AddCode":"builder.putInt32ToStringField(2, \"2\"); builder.putInt32ToMessageField(2, TestMap.MessageValue.getDefaultInstance());",
        "ins1DelCode":"builder.getMutableInt32ToStringField().put(2, \"2\"); builder.getMutableInt32ToMessageField().put(2, TestMap.MessageValue.getDefaultInstance());",
        "ins1PreCode":" } assertEquals(newMap(1, \"1\"), builder.getInt32ToStringField()); builder.getMutableInt32ToStringField().put(2, \"2\"); assertEquals( newMap(1, \"1\", 2, \"2\"), builder.getInt32ToStringField());  Map<Integer, TestMap.MessageValue> messageMap = builder.getMutableInt32ToMessageField(); messageMap.put(1, TestMap.MessageValue.getDefaultInstance()); assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.build().getInt32ToMessageField()); try { messageMap.put(2, TestMap.MessageValue.getDefaultInstance()); fail(); } catch (UnsupportedOperationException e) {  } assertEquals(newMap(1, TestMap.MessageValue.getDefaultInstance()), builder.getInt32ToMessageField()); builder.getMutableInt32ToMessageField().put(2, TestMap.MessageValue.getDefaultInstance()); assertEquals( newMap(1, TestMap.MessageValue.getDefaultInstance(),",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"errors.tryAddThrowableOrReport(ex); errors.tryTerminateConsumer(downstream); errors.tryAddThrowableOrReport(ex); errors.tryTerminateConsumer(downstream); errors.tryAddThrowableOrReport(ex);",
        "ins1DelCode":"if (errors.addThrowable(ex)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(ex); } if (errors.addThrowable(ex)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(ex); } errors.addThrowable(ex);",
        "ins1PreCode":"Exceptions.throwIfFatal(ex); cancelled = true; this.upstream.dispose(); if (errors.addThrowable(ex)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(ex); } return; }  boolean empty = v == null;  if (d && empty) { cancelled = true; errors.tryTerminateConsumer(downstream); return; }  if (!empty) {  ObservableSource<? extends R> o;  try { o = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); cancelled = true; this.upstream.dispose(); queue.clear(); if (errors.addThrowable(ex)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(ex); } return; }  if (o instanceof Supplier) { R w;  try { w = ((Supplier<R>)o).get(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); errors.addThrowable(ex); continue; }",
        "ins2PreCode":"Exceptions.throwIfFatal(ex); cancelled = true; this.upstream.dispose(); if (errors.addThrowable(ex)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(ex); } return; } boolean empty = v == null; if (d && empty) { cancelled = true; errors.tryTerminateConsumer(downstream); return; } if (!empty) { ObservableSource<? extends R> o; try { o = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null ObservableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); cancelled = true; this.upstream.dispose(); queue.clear(); if (errors.addThrowable(ex)) { errors.tryTerminateConsumer(downstream); } else { RxJavaPlugins.onError(ex); } return; } if (o instanceof Supplier) { R w; try { w = ((Supplier<R>)o).get(); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); errors.addThrowable(ex); continue; }",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.REUSE)) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.REUSE); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testSameUpdateAfterCommitReuse() { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.REUSE); try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); person.setFirstName(\"Simone\");   personMapper.update(person); sqlSession.commit();   personMapper.update(person); sqlSession.commit(); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testSameUpdateAfterCommitBatch() { SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH); try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); person.setFirstName(\"Simone\"); personMapper.update(person); sqlSession.commit(); personMapper.update(person); sqlSession.commit(); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"testSubscriber.awaitDone(10, TimeUnit.SECONDS);",
        "ins1DelCode":"testSubscriber.awaitDone(5, TimeUnit.SECONDS);",
        "ins1PreCode":"};  Flowable.merge(f1).observeOn(Schedulers.computation()).take(Flowable.bufferSize() * 2).subscribe(testSubscriber); testSubscriber.awaitDone(5, TimeUnit.SECONDS); if (testSubscriber.errors().size() > 0) { testSubscriber.errors().get(0).printStackTrace();",
        "ins2PreCode":"}; Flowable.merge(f1).observeOn(Schedulers.computation()).take(Flowable.bufferSize() * 2).subscribe(testSubscriber); testSubscriber.awaitDone(5, TimeUnit.SECONDS); if (testSubscriber.errors().size() > 0) { testSubscriber.errors().get(0).printStackTrace();",
        "label":1
    },
    {
        "ins1AddCode":"new PushBlock(0, 0, 0, 0, ByteBuffer.wrap(new byte[2])), new PushBlock(0, 0, 1, 0, ByteBuffer.wrap(new byte[3])), new PushBlock(0, 0, 2, 0, ByteBuffer.wrap(new byte[5])), new PushBlock(0, 0, 3, 0, ByteBuffer.wrap(new byte[3])) new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0, 0)); MergedBlockMeta meta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0, 0); validateChunks(TEST_APP, 0, 0, 0, meta, new int[]{5, 5, 3}, new int[][]{{0, 1}, {2}, {3}});",
        "ins1DelCode":"new PushBlock(0, 0, 0, ByteBuffer.wrap(new byte[2])), new PushBlock(0, 1, 0, ByteBuffer.wrap(new byte[3])), new PushBlock(0, 2, 0, ByteBuffer.wrap(new byte[5])), new PushBlock(0, 3, 0, ByteBuffer.wrap(new byte[3])) new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); MergedBlockMeta meta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, meta, new int[]{5, 5, 3}, new int[][]{{0, 1}, {2}, {3}});",
        "ins1PreCode":"public void testDividingMergedBlocksIntoChunks() throws IOException { PushBlock[] pushBlocks = new PushBlock[] { new PushBlock(0, 0, 0, ByteBuffer.wrap(new byte[2])), new PushBlock(0, 1, 0, ByteBuffer.wrap(new byte[3])), new PushBlock(0, 2, 0, ByteBuffer.wrap(new byte[5])), new PushBlock(0, 3, 0, ByteBuffer.wrap(new byte[3])) }; pushBlockHelper(TEST_APP, NO_ATTEMPT_ID, pushBlocks); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); validateMergeStatuses(statuses, new int[] {0}, new long[] {13}); MergedBlockMeta meta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, meta, new int[]{5, 5, 3}, new int[][]{{0, 1}, {2}, {3}});",
        "ins2PreCode":"public void testFinalizeWithMultipleReducePartitions() throws IOException { PushBlock[] pushBlocks = new PushBlock[] { new PushBlock(0, 0, 0, ByteBuffer.wrap(new byte[2])), new PushBlock(0, 1, 0, ByteBuffer.wrap(new byte[3])), new PushBlock(0, 0, 0, ByteBuffer.wrap(new byte[2])), new PushBlock(0, 1, 0, ByteBuffer.wrap(new byte[3])), }; pushBlockHelper(TEST_APP, NO_ATTEMPT_ID, pushBlocks); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); validateMergeStatuses(statuses, new int[] {0, 1}, new long[] {5, 8}); MergedBlockMeta meta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, meta, new int[]{5}, new int[][]{{0, 1}});",
        "label":1
    },
    {
        "ins1AddCode":"StuckingServlet stuckingServlet = new StuckingServlet(6000L); try { Thread.sleep(500L); Assert.assertEquals(0, valve.getStuckThreadIds().length); Thread.sleep(3000L); Assert.assertEquals(1, valve.getStuckThreadIds().length); } finally { asyncThread.join(); }",
        "ins1DelCode":"StuckingServlet stuckingServlet = new StuckingServlet(5000L); Thread.sleep(1000L); Assert.assertEquals(0, valve.getStuckThreadIds().length); Thread.sleep(2000L); Assert.assertEquals(1, valve.getStuckThreadIds().length); asyncThread.join();",
        "ins1PreCode":"public void testDetection() throws Exception {  StuckingServlet stuckingServlet = new StuckingServlet(5000L); Wrapper servlet = Tomcat.addServlet(context, \"myservlet\", stuckingServlet); servlet.addMapping(\"/myservlet\");  StuckThreadDetectionValve valve = new StuckThreadDetectionValve(); valve.setThreshold(2); context.addValve(valve); context.setBackgroundProcessorDelay(1); tomcat.start();  Assert.assertEquals(0, valve.getStuckThreadIds().length);  final ByteChunk result = new ByteChunk(); Thread asyncThread = new Thread() { @Override public void run() { try { getUrl(\"http://localhost:\" + getPort() + \"/myservlet\", result, null); } catch (IOException e) { e.printStackTrace(); } }  }; asyncThread.start();  Thread.sleep(1000L); Assert.assertEquals(0, valve.getStuckThreadIds().length);  Thread.sleep(2000L); Assert.assertEquals(1, valve.getStuckThreadIds().length); ",
        "ins2PreCode":"public void testDetection() throws Exception { StuckingServlet stuckingServlet = new StuckingServlet(6000L); Wrapper servlet = Tomcat.addServlet(context, \"myservlet\", stuckingServlet); servlet.addMapping(\"/myservlet\"); StuckThreadDetectionValve valve = new StuckThreadDetectionValve(); valve.setThreshold(2); context.addValve(valve); context.setBackgroundProcessorDelay(1); tomcat.start(); Assert.assertEquals(0, valve.getStuckThreadIds().length); final ByteChunk result = new ByteChunk(); Thread asyncThread = new Thread() { @Override public void run() { try { getUrl(\"http://localhost:\" + getPort() + \"/myservlet\", result, null); } catch (IOException e) { e.printStackTrace(); } } }; asyncThread.start(); Thread.sleep(3000L); Assert.assertEquals(0, valve.getStuckThreadIds().length); Thread.sleep(3000L); Assert.assertEquals(1, valve.getStuckThreadIds().length);",
        "label":1
    },
    {
        "ins1AddCode":"StringBuilder target = new StringBuilder(\"testNested4x\"); fail(\"it is required to fail :-)\");",
        "ins1DelCode":"StringBuffer target = new StringBuffer(\"testNested4x\"); fail(\"it is required to fail :-)\") ;",
        "ins1PreCode":"+ \"not permitted in conjunction with if/unless attributes\";  char[] c = {'a', 'b', 'c'}; StringBuffer target = new StringBuffer(\"testNested4x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\") ; } catch (BuildException ex) { assertEquals(specificMessage, ex.getMessage());",
        "ins2PreCode":"String specificMessage = \"A single nested condition is required.\"; char[] c = {'a', 'b'}; StringBuffer target = new StringBuffer(\"testNested7x\"); for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString()); fail(\"it is required to fail :-)\") ; } catch (BuildException ex) { assertEquals(specificMessage, ex.getMessage());",
        "label":1
    },
    {
        "ins1AddCode":"ts.awaitDone(10, TimeUnit.SECONDS);",
        "ins1DelCode":"ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins1PreCode":"public void merge1AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(1, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors(); assertEquals(1000, ts.values().size());",
        "ins2PreCode":"public void merge10AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<>(); mergeNAsyncStreamsOfN(10, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertNoErrors(); assertEquals(10000, ts.values().size());",
        "label":1
    },
    {
        "ins1AddCode":"public void testToOnly() throws InterruptedException { server.join(60 * 1000); client.join(30 * 1000); assertFalse(testMailClient.getFailMessage(), testMailClient.isFailed());",
        "ins1DelCode":"public void testToOnly() { try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail(\"InterruptedException: \" + ie); } if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins1PreCode":"public void testToOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail(\"InterruptedException: \" + ie); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"corsConfiguration, interceptor, new EndpointLinksResolver(webEndpointDiscoverer.getEndpoints()));",
        "ins1DelCode":"corsConfiguration, interceptor);",
        "ins1PreCode":"return new CloudFoundryWebFluxEndpointHandlerMapping( new EndpointMapping(\"/cfApplication\"), webEndpointDiscoverer.getEndpoints(), endpointMediaTypes, corsConfiguration, interceptor);",
        "ins2PreCode":"return new CloudFoundryWebEndpointServletHandlerMapping( new EndpointMapping(\"/cfApplication\"), webEndpointDiscoverer.getEndpoints(), endpointMediaTypes, corsConfiguration, interceptor);",
        "label":1
    },
    {
        "ins1AddCode":"void deleteWhenRemoveChosenReturnsTrueButDoesNotDeletesFile() {",
        "ins1DelCode":"void deleteWhenRemoveChosenReturnsTrueButDoesNotDeletesFile() throws IOException {",
        "ins1PreCode":"void deleteWhenRemoveChosenReturnsTrueButDoesNotDeletesFile() throws IOException { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\"); when(dialogService.showCustomButtonDialogAndWait(",
        "ins2PreCode":"void deleteWhenDeleteChosenReturnsTrueAndDeletesFile() throws IOException { linkedFile = new LinkedFile(\"\", tempFile.toString(), \"\"); when(dialogService.showCustomButtonDialogAndWait(",
        "label":1
    },
    {
        "ins1AddCode":"TestUnknownEnumValue.Builder builder = TestUnknownEnumValue.newBuilder() .putInt32ToInt32Field(1, 1) .putInt32ToInt32Field(2, 54321);",
        "ins1DelCode":"TestUnknownEnumValue.Builder builder = TestUnknownEnumValue.newBuilder(); builder.getMutableInt32ToInt32Field().put(1, 1); builder.getMutableInt32ToInt32Field().put(2, 54321);",
        "ins1PreCode":"public void testUnknownEnumValues() throws Exception { TestUnknownEnumValue.Builder builder = TestUnknownEnumValue.newBuilder(); builder.getMutableInt32ToInt32Field().put(1, 1); builder.getMutableInt32ToInt32Field().put(2, 54321); ByteString data = builder.build().toByteString(); ",
        "ins2PreCode":"public void testUnknownEnumValues() throws Exception { TestUnknownEnumValue.Builder builder = TestUnknownEnumValue.newBuilder(); builder.getMutableInt32ToInt32Field().put(1, 1); builder.getMutableInt32ToInt32Field().put(2, 54321); ByteString data = builder.build().toByteString();",
        "label":1
    },
    {
        "ins1AddCode":"Object b = new Object(); v.add(b); assertSame(b, v.elementAt(1));",
        "ins1DelCode":"v.add(new Object());",
        "ins1PreCode":"v.add(O); Object a = new Object(); v.add(a); v.add(new Object()); assertEquals(3, v.size()); assertEquals(3, v.capacity());",
        "ins2PreCode":"v.add(O); Object a = new Object(); v.add(a); v.add(new Object()); assertEquals(3, v.size()); assertEquals(3, v.capacity());",
        "label":1
    },
    {
        "ins1AddCode":"}, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1DelCode":"}, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1PreCode":"public Flowable<Integer> apply(Integer v) { return inner; } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);  ts.assertValues(1, 2);",
        "ins2PreCode":"public Flowable<Integer> apply(Integer v) { return inner; } }).subscribe(ts); ts.assertValues(1, 2);",
        "label":0
    },
    {
        "ins1AddCode":"DefaultXYDataset<String> d1 = new DefaultXYDataset<>(); XYBarDataset<String> bd1 = new XYBarDataset<>(d1, 5.0);",
        "ins1DelCode":"DefaultXYDataset d1 = new DefaultXYDataset(); XYBarDataset bd1 = new XYBarDataset(d1, 5.0);",
        "ins1PreCode":"public void testPublicCloneable() { DefaultXYDataset d1 = new DefaultXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[][] data1 = new double[][] {x1, y1}; d1.addSeries(\"S1\", data1); XYBarDataset bd1 = new XYBarDataset(d1, 5.0); assertTrue(bd1 instanceof PublicCloneable);",
        "ins2PreCode":"public void testSerialization() { DefaultXYDataset d1 = new DefaultXYDataset(); double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[][] data1 = new double[][] {x1, y1}; d1.addSeries(\"S1\", data1); XYBarDataset bd1 = new XYBarDataset(d1, 5.0); assertEquals(bd1, bd2);",
        "label":1
    },
    {
        "ins1AddCode":"void testForArg() {",
        "ins1DelCode":"public void testForArg() {",
        "ins1PreCode":"public void testForArg() { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); {",
        "ins2PreCode":"public void testForResult() { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); {",
        "label":1
    },
    {
        "ins1AddCode":"public Class<?> getSetterType(String name) {",
        "ins1DelCode":"public Class getSetterType(String name) {",
        "ins1PreCode":"public Class getSetterType(String name) { PropertyTokenizer prop = new PropertyTokenizer(name); if (prop.hasNext()) {",
        "ins2PreCode":"public Class getGetterType(String name) { PropertyTokenizer prop = new PropertyTokenizer(name); if (prop.hasNext()) {",
        "label":1
    },
    {
        "ins1AddCode":"List<Country> countries = new ArrayList<>();",
        "ins1DelCode":"List<Country> countries = new ArrayList<Country>();",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); List<Country> countries = new ArrayList<Country>(); countries.add(new Country(\"China\", \"CN\")); countries.add(new Country(\"United Kiongdom\", \"GB\"));",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); List<Country> countries = new ArrayList<Country>(); countries.add(new Country(\"China\", \"CN\")); countries.add(new Country(\"United Kiongdom\", \"GB\"));",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> s1 = new XYSeries<>(\"Series 1\", true, false); XYSeries<String> s2 = new XYSeries<>(\"Series 2\", true, false);",
        "ins1DelCode":"XYSeries s1 = new XYSeries(\"Series 1\", true, false); XYSeries s2 = new XYSeries(\"Series 2\", true, false);",
        "ins1PreCode":"public void testAddSeries() { DefaultTableXYDataset d1 = new DefaultTableXYDataset(); d1.setAutoWidth(true); XYSeries s1 = new XYSeries(\"Series 1\", true, false); s1.add(3.0, 1.1); s1.add(7.0, 2.2); d1.addSeries(s1); assertEquals(3.0, d1.getXValue(0, 0), EPSILON); assertEquals(7.0, d1.getXValue(0, 1), EPSILON); assertEquals(1.0, d1.getStartXValue(0, 0), EPSILON); assertEquals(5.0, d1.getStartXValue(0, 1), EPSILON); assertEquals(5.0, d1.getEndXValue(0, 0), EPSILON); assertEquals(9.0, d1.getEndXValue(0, 1), EPSILON);   XYSeries s2 = new XYSeries(\"Series 2\", true, false); s2.add(7.5, 1.1); s2.add(9.0, 2.2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"label_16: jj_la1[43] = jj_gen; break label_16; jj_la1[44] = jj_gen;",
        "ins1DelCode":"label_14: jj_la1[36] = jj_gen; break label_14; jj_la1[37] = jj_gen;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_14: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[36] = jj_gen; break label_14; } jj_consume_token(COMMA); Expression(); } break; default: jj_la1[37] = jj_gen; ; }",
        "ins2PreCode":"case MINUS: case IDENTIFIER: MapEntry(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[38] = jj_gen; break label_15; } jj_consume_token(COMMA); MapEntry(); } break; default: jj_la1[38] = jj_gen; ; }",
        "label":1
    },
    {
        "ins1AddCode":"assertThatExceptionOfType(BindException.class) .isThrownBy(() -> this.binder.bind(\"foo\", INTEGER_ARRAY)) .satisfies((ex) -> { Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex .getCause()).getUnboundProperties(); assertThat(unbound.size()).isEqualTo(1); ConfigurationProperty property = unbound.iterator().next(); assertThat(property.getName().toString()).isEqualTo(\"foo[3]\"); assertThat(property.getValue()).isEqualTo(\"3\"); });",
        "ins1DelCode":"try { this.binder.bind(\"foo\", INTEGER_ARRAY); fail(\"No exception thrown\"); } catch (BindException ex) { Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex .getCause()).getUnboundProperties(); assertThat(unbound.size()).isEqualTo(1); ConfigurationProperty property = unbound.iterator().next(); assertThat(property.getName().toString()).isEqualTo(\"foo[3]\"); assertThat(property.getValue()).isEqualTo(\"3\"); }",
        "ins1PreCode":"source.put(\"foo[1]\", \"1\"); source.put(\"foo[3]\", \"3\"); this.sources.add(source); try { this.binder.bind(\"foo\", INTEGER_ARRAY); fail(\"No exception thrown\"); } catch (BindException ex) { Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex .getCause()).getUnboundProperties();",
        "ins2PreCode":"source.put(\"foo[1]\", \"1\"); source.put(\"foo[3]\", \"3\"); this.sources.add(source); try { this.binder.bind(\"foo\", INTEGER_LIST); fail(\"No exception thrown\"); } catch (BindException ex) { Set<ConfigurationProperty> unbound = ((UnboundConfigurationPropertiesException) ex .getCause()).getUnboundProperties();",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"ObservableSource<String> onSubscribe = new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); subsCount.incrementAndGet(); observer.onError(new RuntimeException(\"failed\"));",
        "ins2PreCode":"ObservableSource<String> onSubscribe = new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); subsCount.incrementAndGet(); observer.onError(new RuntimeException(\"failed\"));",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateStarShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateStarShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"CountDownLatch latch = new CountDownLatch(1); latch.countDown();",
        "ins1PreCode":"protected ConfigurableApplicationContext getContext( Supplier<ConfigurableApplicationContext> supplier) throws Exception { CountDownLatch latch = new CountDownLatch(1); AtomicReference<ConfigurableApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { ConfigurableApplicationContext context = supplier.get(); latch.countDown(); atomicReference.getAndSet(context); });",
        "ins2PreCode":"private AnnotationConfigServletWebApplicationContext getContext( Supplier<AnnotationConfigServletWebApplicationContext> supplier) CountDownLatch latch = new CountDownLatch(1); AtomicReference<AnnotationConfigServletWebApplicationContext> atomicReference = new AtomicReference<>(); Thread thread = new Thread(() -> { AnnotationConfigServletWebApplicationContext context = supplier.get(); latch.countDown(); atomicReference.getAndSet(context); });",
        "label":1
    },
    {
        "ins1AddCode":"parseAssociationName(modelElement, text);",
        "ins1DelCode":"NotationUtilityUml.parseModelElement(modelElement, text);",
        "ins1PreCode":"public void parse(Object modelElement, String text) { try { NotationUtilityUml.parseModelElement(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.association-name\";",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Rectangle2D bounds = TextUtils.getTextBounds(getText(), g2, fm);",
        "ins1DelCode":"Rectangle2D bounds = TextUtilities.getTextBounds(getText(), g2, fm);",
        "ins1PreCode":"protected Size2D arrangeFN(Graphics2D g2, double w) { g2.setFont(getFont()); FontMetrics fm = g2.getFontMetrics(getFont()); Rectangle2D bounds = TextUtilities.getTextBounds(getText(), g2, fm); if (bounds.getWidth() <= w) { return new Size2D(w, bounds.getHeight());",
        "ins2PreCode":"protected Size2D arrangeRR(Graphics2D g2, Range widthRange, g2.setFont(getFont()); FontMetrics fm = g2.getFontMetrics(getFont()); Rectangle2D bounds = TextUtilities.getTextBounds(getText(), g2, fm); if (bounds.getWidth() <= widthRange.getUpperBound() return new Size2D(bounds.getWidth(), bounds.getHeight());",
        "label":1
    },
    {
        "ins1AddCode":"result.add(new GenericTableTrigger(table, name, null));",
        "ins1DelCode":"result.add(new GenericTrigger(container, table, name, null));",
        "ins1PreCode":"try (JDBCResultSet dbResult = dbStat.executeQuery()) { while (dbResult.next()) { String name = JDBCUtils.safeGetString(dbResult, 1); result.add(new GenericTrigger(container, table, name, null)); } }",
        "ins2PreCode":"try (JDBCResultSet dbResult = dbStat.executeQuery()) { while (dbResult.next()) { String name = JDBCUtils.safeGetString(dbResult, 1); result.add(new GenericTrigger(container, table, name, null)); } }",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(tomcat.getConnector().setProperty(\"maxKeepAliveRequests\", \"1\"));",
        "ins1DelCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "ins1PreCode":"   tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");  ",
        "ins2PreCode":"tomcat.getConnector().setAttribute(\"maxKeepAliveRequests\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"final String script = \"{{#join}}{{/join}}\"; ScriptException e = expectThrows(ScriptException.class, () -> compile(script)); assertEquals(MustacheScriptEngine.NAME, e.getLang()); assertEquals(script, e.getScript()); final String script2 = \"{{#join delimiter='a'}}{{/join delimiter='b'}}\"; e = expectThrows(ScriptException.class, () -> compile(script2)); assertEquals(MustacheScriptEngine.NAME, e.getLang()); assertEquals(script2, e.getScript());",
        "ins1DelCode":"MustacheException e = expectThrows(MustacheException.class, () -> compile(\"{{#join}}{{/join}}\")); e = expectThrows(MustacheException.class, () -> compile(\"{{#join delimiter='a'}}{{/join delimiter='b'}}\"));",
        "ins1PreCode":"public void testsUnsupportedTagsJoin() { MustacheException e = expectThrows(MustacheException.class, () -> compile(\"{{#join}}{{/join}}\")); assertThat(e.getMessage(), containsString(\"Mustache function [join] must contain one and only one identifier\"));  e = expectThrows(MustacheException.class, () -> compile(\"{{#join delimiter='a'}}{{/join delimiter='b'}}\")); assertThat(e.getMessage(), containsString(\"Mismatched start/end tags\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"RidgeRegressionWithSGD ridgeSGDImpl = new RidgeRegressionWithSGD(1.0, 200, 0.0, 1.0);",
        "ins1DelCode":"RidgeRegressionWithSGD ridgeSGDImpl = new RidgeRegressionWithSGD(); ridgeSGDImpl.optimizer() .setStepSize(1.0) .setRegParam(0.0) .setNumIterations(200);",
        "ins1PreCode":"new ArrayList<>(data.subList(0, numExamples))); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);  RidgeRegressionWithSGD ridgeSGDImpl = new RidgeRegressionWithSGD(); ridgeSGDImpl.optimizer() .setStepSize(1.0) .setRegParam(0.0) .setNumIterations(200); RidgeRegressionModel model = ridgeSGDImpl.run(testRDD.rdd()); double unRegularizedErr = predictionError(validationData, model);",
        "ins2PreCode":"new ArrayList<>(data.subList(0, numExamples))); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples); model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.1); model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.1); JavaRDD<LabeledPoint> testRDD = jsc.parallelize( Assert.assertTrue(regularizedErr < unRegularizedErr); int numFeatures = 20; RidgeRegressionModel model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.0); double unRegularizedErr = predictionError(validationData, model);",
        "label":0
    },
    {
        "ins1AddCode":"p = Objects.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");",
        "ins1DelCode":"p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\");",
        "ins1PreCode":"Publisher<? extends R> p;  try { p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "ins2PreCode":"Publisher<? extends R> p; try { p = ObjectHelper.requireNonNull(mapper.apply(v), \"The mapper returned a null Publisher\"); } catch (Throwable e) { Exceptions.throwIfFatal(e);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":"BibEntry entry = entries.iterator().next();  assertEquals(1, entries.size()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(5, entry.getFields().size()); assertTrue(entry.getFields().contains(StandardField.AUTHOR));",
        "ins2PreCode":"BibEntry entry = entries.iterator().next(); assertEquals(1, entries.size()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(5, entry.getFields().size()); assertTrue(entry.getFields().contains(StandardField.AUTHOR));",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertTrue(blog instanceof Proxy);",
        "ins1DelCode":"Assert.assertTrue(blog instanceof Proxy);",
        "ins1PreCode":"public void shouldSelectBlogWithPostsAndAuthorUsingSubSelectsLazily() { try (SqlSession session = sqlMapper.openSession()) { Blog blog = session.selectOne(\"org.apache.ibatis.domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assert.assertTrue(blog instanceof Proxy); assertEquals(\"Jim Business\", blog.getTitle()); assertEquals(2, blog.getPosts().size());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void parentFirstWithDifferentProfile() {",
        "ins1DelCode":"public void parentFirstWithDifferentProfile() throws Exception {",
        "ins1PreCode":"public void parentFirstWithDifferentProfile() throws Exception { SpringApplicationBuilder application = new SpringApplicationBuilder( ExampleConfig.class).profiles(\"node\").properties(\"transport=redis\")",
        "ins2PreCode":"public void parentFirstWithDifferentProfileAndExplicitEnvironment() throws Exception { SpringApplicationBuilder application = new SpringApplicationBuilder( .profiles(\"node\").properties(\"transport=redis\")",
        "label":1
    },
    {
        "ins1AddCode":".withUserConfiguration(ServletWebServerConfiguration.class, MeterRegistryConfiguration.class) context.publishEvent( new ApplicationStartedEvent(new SpringApplication(), null, context.getSourceApplicationContext())); assertThat(context).hasSingleBean(TomcatMetricsBinder.class); SimpleMeterRegistry registry = context .getBean(SimpleMeterRegistry.class);",
        "ins1DelCode":".withUserConfiguration(ServletWebServerConfiguration.class) assertThat(context).hasSingleBean(TomcatMetrics.class); SimpleMeterRegistry registry = new SimpleMeterRegistry(); context.getBean(TomcatMetrics.class).bindTo(registry);",
        "ins1PreCode":".withConfiguration(AutoConfigurations.of( TomcatMetricsAutoConfiguration.class, ServletWebServerFactoryAutoConfiguration.class)) .withUserConfiguration(ServletWebServerConfiguration.class) .run((context) -> { assertThat(context).hasSingleBean(TomcatMetrics.class); SimpleMeterRegistry registry = new SimpleMeterRegistry(); context.getBean(TomcatMetrics.class).bindTo(registry); assertThat( registry.find(\"tomcat.sessions.active.max\").meter())",
        "ins2PreCode":".withConfiguration(AutoConfigurations.of( TomcatMetricsAutoConfiguration.class, ReactiveWebServerFactoryAutoConfiguration.class)) .withUserConfiguration(ReactiveWebServerConfiguration.class) .run((context) -> { assertThat(context).hasSingleBean(TomcatMetrics.class); SimpleMeterRegistry registry = new SimpleMeterRegistry(); context.getBean(TomcatMetrics.class).bindTo(registry); assertThat( registry.find(\"tomcat.sessions.active.max\").meter())",
        "label":1
    },
    {
        "ins1AddCode":"this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); response.sendError(400, \"BAD\"); });",
        "ins1DelCode":"this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); ((HttpServletResponse) response).sendError(400, \"BAD\"); } };",
        "ins1PreCode":"throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\")); this.request.setAsyncStarted(true); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); ((HttpServletResponse) response).sendError(400, \"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain); assertThat(this.chain.getRequest()).isEqualTo(this.request);",
        "ins2PreCode":"throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\")); assertThat(this.response.isCommitted()).isTrue(); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getResponse()) } }; this.filter.doFilter(this.request, this.response, this.chain); assertThat(this.chain.getRequest()).isEqualTo(this.request);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(0, 100000) .onErrorResumeWith(Flowable.just(1))",
        "ins2PreCode":"public void backpressure() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(0, 100000) .onErrorResumeWith(Observable.just(1))",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fusedEmpty() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  TakeLast source = new TakeLast(to);",
        "ins2PreCode":"public void nonfusedEmpty() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.NONE); TakeLast source = new TakeLast(to);",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<>(); aliasedRepos = new ArrayList<>(); List<ArtifactRepository> effectiveRepositories = new ArrayList<>(); List<ArtifactRepository> mirroredRepos = new ArrayList<>(); new ArrayList<>( aliasedRepos.size() ); new ArrayList<>( aliasedRepos.size() );",
        "ins1DelCode":"Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>(); aliasedRepos = new ArrayList<ArtifactRepository>(); List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>(); List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>(); new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() ); new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );",
        "ins1PreCode":"return null; }  Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>();  for ( ArtifactRepository repository : repositories ) { String key = repository.getId();  List<ArtifactRepository> aliasedRepos = reposByKey.get( key );  if ( aliasedRepos == null ) { aliasedRepos = new ArrayList<ArtifactRepository>(); reposByKey.put( key, aliasedRepos ); }  aliasedRepos.add( repository ); }  List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>();  for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() ) { List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>();  List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );  for ( ArtifactRepository aliasedRepo : aliasedRepos ) { releasePolicies.add( aliasedRepo.getReleases() ); mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() ); }  ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies );  List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() );  for ( ArtifactRepository aliasedRepo : aliasedRepos )",
        "ins2PreCode":"return null; } Map<String, List<ArtifactRepository>> reposByKey = new LinkedHashMap<String, List<ArtifactRepository>>(); for ( ArtifactRepository repository : repositories ) { String key = repository.getId(); List<ArtifactRepository> aliasedRepos = reposByKey.get( key ); if ( aliasedRepos == null ) { aliasedRepos = new ArrayList<ArtifactRepository>(); reposByKey.put( key, aliasedRepos ); } aliasedRepos.add( repository ); } List<ArtifactRepository> effectiveRepositories = new ArrayList<ArtifactRepository>(); for ( List<ArtifactRepository> aliasedRepos : reposByKey.values() ) { List<ArtifactRepository> mirroredRepos = new ArrayList<ArtifactRepository>(); List<ArtifactRepositoryPolicy> releasePolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() ); for ( ArtifactRepository aliasedRepo : aliasedRepos ) { releasePolicies.add( aliasedRepo.getReleases() ); mirroredRepos.addAll( aliasedRepo.getMirroredRepositories() ); } ArtifactRepositoryPolicy releasePolicy = getEffectivePolicy( releasePolicies ); List<ArtifactRepositoryPolicy> snapshotPolicies = new ArrayList<ArtifactRepositoryPolicy>( aliasedRepos.size() ); for ( ArtifactRepository aliasedRepo : aliasedRepos )",
        "label":1
    },
    {
        "ins1AddCode":"MinMaxCategoryRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"MinMaxCategoryRenderer r2 = (MinMaxCategoryRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { MinMaxCategoryRenderer r1 = new MinMaxCategoryRenderer(); MinMaxCategoryRenderer r2 = (MinMaxCategoryRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalBarRenderer r1 = new IntervalBarRenderer(); IntervalBarRenderer r1 = new IntervalBarRenderer(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"final ArrayList<String> list = new ArrayList<>();",
        "ins1DelCode":"final ArrayList<String> list = new ArrayList<String>();",
        "ins1PreCode":"} });  final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new Consumer<String>() { ",
        "ins2PreCode":"} }); final ArrayList<String> list = new ArrayList<String>(); os.subscribe(new Consumer<String>() {",
        "label":1
    },
    {
        "ins1AddCode":"void shouldTrimWHEREANDWithLFForFirstCondition() throws Exception {",
        "ins1DelCode":"public void shouldTrimWHEREANDWithLFForFirstCondition() throws Exception {",
        "ins1PreCode":"public void shouldTrimWHEREANDWithLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\n ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimWHEREANDWithCRLFForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE \\r\\n ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"CategoryItemEntity e2 = (CategoryItemEntity) TestUtils.serialised(e1);",
        "ins1DelCode":"CategoryItemEntity e2 = (CategoryItemEntity) TestUtilities.serialised(e1);",
        "ins1PreCode":"d.addValue(4.0, \"R2\", \"C2\"); CategoryItemEntity e1 = new CategoryItemEntity(new Rectangle2D.Double( 1.0, 2.0, 3.0, 4.0), \"ToolTip\", \"URL\", d, \"R2\", \"C2\"); CategoryItemEntity e2 = (CategoryItemEntity) TestUtilities.serialised(e1); assertEquals(e1, e2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if(!e.getClass().isAssignableFrom(AccessDeniedException3.class)){",
        "ins1DelCode":"if(!(e.getClass().isAssignableFrom(AccessDeniedException3.class))){",
        "ins1PreCode":"fail(\"User should not have permission to build project\"); } catch(Exception e){ if(!(e.getClass().isAssignableFrom(AccessDeniedException3.class))){ fail(\"AccessDeniedException should be thrown.\"); }",
        "ins2PreCode":"fail(\"User should not have permission to build project\"); } catch(Exception e){ if(!(e.getClass().isAssignableFrom(AccessDeniedException3.class))){ fail(\"AccessDeniedException should be thrown.\"); }",
        "label":1
    },
    {
        "ins1AddCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace()))",
        "ins1DelCode":".trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE))",
        "ins1PreCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = COMMA_SPLITTER .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); assertThat(family)",
        "ins2PreCode":"String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); assertThat(family)",
        "label":1
    },
    {
        "ins1AddCode":"List<Path> result = fileFinder.findAssociatedFiles(localEntry, List.of(directory), PDF_EXTENSION);",
        "ins1DelCode":"List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);",
        "ins1PreCode":"localEntry.setCitationKey(\"pdfInSubdirectory\"); localEntry.setField(StandardField.YEAR, \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[citationkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"} else if (adapter == DBAServerSessionManager.class) { } else if (adapter == DBCQueryPlanner.class) { return adapter.cast(new SQLServerQueryPlanner(this));",
        "ins1DelCode":"} else if (adapter == DBAServerSessionManager .class) {",
        "ins1PreCode":"public <T> T getAdapter(Class<T> adapter) { if (adapter == DBSStructureAssistant.class) { return adapter.cast(new SQLServerStructureAssistant(this)); } else if (adapter == DBAServerSessionManager .class) { return adapter.cast(new SQLServerSessionManager(this)); }",
        "ins2PreCode":"public <T> T getAdapter(Class<T> adapter) if (adapter == DBSStructureAssistant.class) { return adapter.cast(new ExasolStructureAssistant(this)); } else if (adapter == DBAServerSessionManager.class) { return adapter.cast(new ExasolServerSessionManager(this)); }",
        "label":1
    },
    {
        "ins1AddCode":"channel.stop(Channel.DEFAULT);",
        "ins1DelCode":"channel.stop(channel.DEFAULT);",
        "ins1PreCode":"exit.setDaemon(true); exit.start(); try { channel.stop(channel.DEFAULT);  }catch ( Exception x ) {",
        "ins2PreCode":"exit.setDaemon(true); exit.start(); try { channel.stop(channel.DEFAULT); }catch ( Exception x ) {",
        "label":1
    },
    {
        "ins1AddCode":"long offsetAndSize = getLong(ordinal); long offset = offsetAndSize >>> 32; int signum = ((int) (offsetAndSize & 0xfff) >> 8); assert signum >=0 && signum <= 2 : \"invalid signum \" + signum; int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; PlatformDependent.copyMemory(baseObject, baseOffset + offset, mag, PlatformDependent.INT_ARRAY_OFFSET, size * 4); BigInteger v = new BigInteger(0, EMPTY); PlatformDependent.UNSAFE.putInt(v, PlatformDependent.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); PlatformDependent.UNSAFE.putObjectVolatile(v, PlatformDependent.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale);",
        "ins1DelCode":"byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(new scala.math.BigDecimal(javaDecimal), precision, scale);",
        "ins1PreCode":"if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.apply(getLong(ordinal), precision, scale); } else { byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(new scala.math.BigDecimal(javaDecimal), precision, scale); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void shouldFlushAllItemsOnDemand() {",
        "ins1DelCode":"public void shouldFlushAllItemsOnDemand() {",
        "ins1PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new PerpetualCache(\"default\"); cache = new SynchronizedCache(cache);",
        "ins2PreCode":"public void shouldFlushAllItemsOnDemand() { FifoCache cache = new FifoCache(new PerpetualCache(\"default\")); FifoCache cache = new FifoCache(new PerpetualCache(\"default\"));",
        "label":1
    },
    {
        "ins1AddCode":"if (!PaintUtils.equal(this.errorIndicatorPaint, if (!ObjectUtils.equal(this.errorIndicatorStroke,",
        "ins1DelCode":"if (!PaintUtilities.equal(this.errorIndicatorPaint, if (!ObjectUtilities.equal(this.errorIndicatorStroke,",
        "ins1PreCode":"return false; } StatisticalBarRenderer that = (StatisticalBarRenderer) obj; if (!PaintUtilities.equal(this.errorIndicatorPaint, that.errorIndicatorPaint)) { return false; } if (!ObjectUtilities.equal(this.errorIndicatorStroke, that.errorIndicatorStroke)) { return false;",
        "ins2PreCode":"return false; } = (StatisticalLineAndShapeRenderer) obj; if (!PaintUtilities.equal(this.errorIndicatorPaint, that.errorIndicatorPaint)) { return false; } if (!ObjectUtilities.equal(this.errorIndicatorStroke, that.errorIndicatorStroke)) { return false;",
        "label":1
    },
    {
        "ins1AddCode":"try (NioHttpClient client = new NioHttpClient()) {",
        "ins1DelCode":"try (Netty4HttpClient client = new Netty4HttpClient()) {",
        "ins1PreCode":"transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());  try (Netty4HttpClient client = new Netty4HttpClient()) { final String url = \"/\" + new String(new byte[maxInitialLineLength], Charset.forName(\"UTF-8\")); final FullHttpRequest request = new DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, url);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void parseLevelsNone() {",
        "ins1DelCode":"public void parseLevelsNone() throws Exception {",
        "ins1PreCode":"public void parseLevelsNone() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=OFF\");",
        "ins2PreCode":"public void parseLevelsMapsFalseToOff() throws Exception { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=false\");",
        "label":1
    },
    {
        "ins1AddCode":"null, new TestTemplateService.MockTemplateScript.Factory(\"invalid_timezone\"), templatize(randomLocale(random())),",
        "ins1DelCode":"new TestTemplateService.MockTemplateScript.Factory(\"invalid_timezone\"), templatize(randomLocale(random())),",
        "ins1PreCode":"public void testInvalidTimezone() { DateProcessor processor = new DateProcessor(randomAlphaOfLength(10), new TestTemplateService.MockTemplateScript.Factory(\"invalid_timezone\"), templatize(randomLocale(random())), \"date_as_string\", Collections.singletonList(\"yyyy\"), \"date_as_date\"); Map<String, Object> document = new HashMap<>();",
        "ins2PreCode":"public void testInvalidLocale() { DateProcessor processor = new DateProcessor(randomAlphaOfLength(10), templatize(ZoneOffset.UTC), new TestTemplateService.MockTemplateScript.Factory(\"invalid_locale\"), \"date_as_string\", Collections.singletonList(\"yyyy\"), \"date_as_date\"); Map<String, Object> document = new HashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void differentError4() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onError(new RuntimeException()); try {",
        "ins2PreCode":"public void differentError4() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onError(new RuntimeException()); try {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testDBCPThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.threadcount = 20;",
        "ins2PreCode":"public void testPoolThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.threadcount = 20;",
        "label":1
    },
    {
        "ins1AddCode":"Page p = rule.createWebClient() .withThrowExceptionOnFailingStatusCode(false) .getPage(request); assertEquals(\"Creating job from copy should succeed.\", HttpURLConnection.HTTP_OK, p.getWebResponse().getStatusCode());",
        "ins1DelCode":"int result = ERROR_PRESET; try { result = rule.createWebClient() .getPage(request).getWebResponse().getStatusCode(); } catch (FailingHttpStatusCodeException e) { result = e.getResponse().getStatusCode(); } assertEquals(\"Creating job from copy should succeed.\", 200, result);",
        "ins1PreCode":" WebRequest request = new WebRequest(apiURL, HttpMethod.POST); deleteContentTypeHeader(request); int result = ERROR_PRESET; try { result = rule.createWebClient() .getPage(request).getWebResponse().getStatusCode(); } catch (FailingHttpStatusCodeException e) { result = e.getResponse().getStatusCode(); }  assertEquals(\"Creating job from copy should succeed.\", 200, result);",
        "ins2PreCode":"WebRequest request = new WebRequest(apiURL, HttpMethod.POST); deleteContentTypeHeader(request); int result = ERROR_PRESET; try { result = rule.createWebClient() .getPage(request).getWebResponse().getStatusCode(); } catch (FailingHttpStatusCodeException e) { result = e.getResponse().getStatusCode(); } assertEquals(\"Creating job from copy should fail.\", 400, result);",
        "label":1
    },
    {
        "ins1AddCode":"OHLCItem item2 = CloneUtils.clone(item1);",
        "ins1DelCode":"OHLCItem item2 = (OHLCItem) item1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { OHLCItem item1 = new OHLCItem(new Year(2006), 2.0, 4.0, 1.0, 3.0); OHLCItem item2 = (OHLCItem) item1.clone(); assertTrue(item1 != item2); assertTrue(item1.getClass() == item2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(network.hasEdgeConnecting(node, otherNode)).isFalse(); assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue(); assertThat(network.hasEdgeConnecting(node, otherNode)).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"switch (edgesConnecting.size()) { case 0: assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull(); break; case 1: assertThat(network.edgeConnectingOrNull(node, otherNode)) .isEqualTo(edgesConnecting.iterator().next()); break; default: try { network.edgeConnectingOrNull(node, otherNode); fail(); } catch (IllegalArgumentException expected) {} }",
        "ins2PreCode":"switch (edgesConnecting.size()) { case 0: assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull(); break; case 1: assertThat(network.edgeConnectingOrNull(node, otherNode)).isNull(); E edge = edgesConnecting.iterator().next(); break; default: try { network.edgeConnectingOrNull(node, otherNode); fail(); } catch (IllegalArgumentException expected) {} }",
        "label":1
    },
    {
        "ins1AddCode":"bibEntry.setField(\"publisher\", \"ADDISON WESLEY PUB CO INC\"); bibEntry.setField(\"pagetotal\", \"416\"); bibEntry.setField(\"date\", \"2018-01-06\");",
        "ins1DelCode":"bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"date\", \"2018-01-11\");",
        "ins1PreCode":"bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780134685991\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2018\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2018-01-11\"); bibEntry.setField(\"ean\", \"9780134685991\"); bibEntry.setField(\"isbn\", \"0134685997\");",
        "ins2PreCode":"bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780134685991\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2018\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2018-01-11\"); bibEntry.setField(\"ean\", \"9780134685991\"); bibEntry.setField(\"isbn\", \"0134685997\");",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(0L); List<Integer> list = new ArrayList<>(100);",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(0L); List<Integer> list = new ArrayList<Integer>(100);",
        "ins1PreCode":"void withBackpressureOneByOne(int start) { Flowable<Integer> source = Flowable.range(start, 100);  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(0L); ts.request(1); source.subscribe(ts);  List<Integer> list = new ArrayList<Integer>(100); for (int i = 0; i < 100; i++) { list.add(i + start);",
        "ins2PreCode":"void withBackpressureAllAtOnce(int start) { Flowable<Integer> source = Flowable.range(start, 100); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(0L); ts.request(100); source.subscribe(ts); List<Integer> list = new ArrayList<Integer>(100); for (int i = 0; i < 100; i++) { list.add(i + start);",
        "label":1
    },
    {
        "ins1AddCode":"String msg = \"statusmsg.bar.error.parsing.association-role\";",
        "ins1DelCode":"String msg = \"statusmsg.bar.error.parsing.association-end-name\";",
        "ins1PreCode":"try { parseRole(modelElement, text); } catch (ParseException pe) { String msg = \"statusmsg.bar.error.parsing.association-end-name\"; Object[] args = { pe.getLocalizedMessage(),",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Objects.requireNonNull(sources, \"sources is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(sources, \"sources is null\");",
        "ins1PreCode":"public static Completable concatArray(CompletableSource... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return complete();",
        "ins2PreCode":"public static Completable mergeArray(CompletableSource... sources) { ObjectHelper.requireNonNull(sources, \"sources is null\"); if (sources.length == 0) { return complete();",
        "label":1
    },
    {
        "ins1AddCode":"void getAccessLevelWhenSpaceDeveloperShouldReturnFull() {",
        "ins1DelCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() {",
        "ins1PreCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() { String responseBody = \"{\\\"read_sensitive_data\\\": true,\\\"read_basic_data\\\": true}\"; this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "ins2PreCode":"public void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() { String responseBody = \"{\\\"read_sensitive_data\\\": false,\\\"read_basic_data\\\": true}\"; this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "label":1
    },
    {
        "ins1AddCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup,",
        "ins1DelCode":"DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition,",
        "ins1PreCode":"public void testNullGuardAdd() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition, MethodHandles.publicLookup(), \"add\",",
        "ins2PreCode":"public void testNullGuardAddWhenCached() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(definition, MethodHandles.publicLookup(), \"add\",",
        "label":1
    },
    {
        "ins1AddCode":"assert node != null; LOG.error(\"TODO: CollabDiagramRenderer getFigNodeFor\"); throw new IllegalArgumentException( \"Node is not a recognised type. Received \" + node.getClass().getName());",
        "ins1DelCode":"LOG.debug(\"TODO: CollabDiagramRenderer getFigNodeFor\"); return null;",
        "ins1PreCode":"&& ((UMLDiagram) diag).doesAccept(node)) { figNode = ((UMLDiagram) diag).drop(node, null); } else { LOG.debug(\"TODO: CollabDiagramRenderer getFigNodeFor\"); return null; } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private void testMultipleReverseIncludes(SqlSessionFactory sqlSessionFactory) { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"private void testMultipleReverseIncludes(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"private void testMultipleReverseIncludes(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { MultipleReverseIncludePersonMapper personMapper = sqlSession.getMapper(MultipleReverseIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals((Integer)1, person.getId()); assertEquals(\"John\", person.getName());  } finally { sqlSession.close(); }",
        "ins2PreCode":"private void testReverseIncludes(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { ReverseIncludePersonMapper personMapper = sqlSession.getMapper(ReverseIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals((Integer)1, person.getId()); assertEquals(\"John\", person.getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"long after = TestHelper.awaitGC(GC_SLEEP_TIME, 20, start + 20 * 1000 * 1000);",
        "ins1DelCode":"System.gc(); Thread.sleep(100); long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();",
        "ins1PreCode":"System.gc(); Thread.sleep(100);  long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();  source = null;",
        "ins2PreCode":"System.gc(); Thread.sleep(100); long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed(); source = null;",
        "label":1
    },
    {
        "ins1AddCode":"for (Class<?> aClass : inf) { mp = aClass.getMethod(m.getName(), m.getParameterTypes());",
        "ins1DelCode":"for (int i = 0; i < inf.length; i++) { mp = inf[i].getMethod(m.getName(), m.getParameterTypes());",
        "ins1PreCode":"} Class<?>[] inf = type.getInterfaces(); Method mp = null; for (int i = 0; i < inf.length; i++) { try { mp = inf[i].getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp); if (mp != null) {",
        "ins2PreCode":"} Class<?>[] inf = type.getInterfaces(); Method mp = null; for (int i = 0; i < inf.length; i++) { try { mp = inf[i].getMethod(m.getName(), m.getParameterTypes()); mp = getMethod(mp.getDeclaringClass(), base, mp); if (mp != null) {",
        "label":1
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"target_field\", \"new_field\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"old_field\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertValuesOnlyThrowsWhenErrored() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(new BooleanSubscription()); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void parseRecognizesHeaderButIgnoresEncoding() throws IOException {",
        "ins1DelCode":"public void parseRecognizesHeaderButIgnoresEncoding() throws IOException {",
        "ins1PreCode":"public void parseRecognizesHeaderButIgnoresEncoding() throws IOException { ParserResult result = parser.parse(new StringReader(\"This file was created with JabRef 2.1 beta 2.\" + \"\\n\" + \"Encoding: Cp1252\" + \"\\n\" + \"\" + \"\\n\" + \"@INPROCEEDINGS{CroAnnHow05,\" + \"\\n\"",
        "ins2PreCode":"public void parseRecognizesFormatedEntry() throws IOException { ParserResult result = parser.parse( new StringReader(\"\" + \"@INPROCEEDINGS{CroAnnHow05,\" + \"\\n\"",
        "label":1
    },
    {
        "ins1AddCode":"try (org.apache.tools.zip.ZipFile zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\"))) {",
        "ins1DelCode":"org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); } finally { if (zf != null) { zf.close(); }",
        "ins1PreCode":"public void testTarFileSet() throws IOException { buildRule.executeTarget(\"testTarFileSet\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"asf-logo.gif\"); assertEquals(UnixStat.FILE_FLAG | 0446, ze.getUnixMode()); } finally { if (zf != null) { zf.close(); } }",
        "ins2PreCode":"public void testRewriteZeroPermissions() throws IOException { buildRule.executeTarget(\"rewriteZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(new File(buildRule.getProject().getProperty(\"output\"), \"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\"); assertEquals(UnixStat.FILE_FLAG | 0644, ze.getUnixMode()); } finally { if (zf != null) { zf.close(); } }",
        "label":1
    },
    {
        "ins1AddCode":"value instanceof Double",
        "ins1DelCode":"value instanceof Double  || value instanceof BigInteger",
        "ins1PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double  || value instanceof BigInteger ) { return ((Number)value).doubleValue();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return Stream.of(theFiles) .filter(Objects::nonNull) .filter(f -> test.test(f.getName()))",
        "ins1DelCode":"return Stream.of(theFiles).filter(f -> test.test(f.getName()))",
        "ins1PreCode":"Predicate<String> test = isCaseSensitive() ? lastpathelement::equals : lastpathelement::equalsIgnoreCase; return Stream.of(theFiles).filter(f -> test.test(f.getName())) .findFirst().orElse(null);",
        "ins2PreCode":"Predicate<String> test = isCaseSensitive() ? lastpathelement::equals : lastpathelement::equalsIgnoreCase; return Stream.of(theFiles).filter(f -> test.test(f.getName())) .findFirst().orElse(null);",
        "label":1
    },
    {
        "ins1AddCode":"TestUtils.checkIndependence(r1, r2);",
        "ins1DelCode":"",
        "ins1PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "ins2PreCode":"assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));",
        "label":1
    },
    {
        "ins1AddCode":"public void setDataset(int index, XYDataset<S> dataset) { XYDataset<S> existing = getDataset(index);",
        "ins1DelCode":"public void setDataset(int index, XYDataset dataset) { XYDataset existing = getDataset(index);",
        "ins1PreCode":"public void setDataset(int index, XYDataset dataset) { XYDataset existing = getDataset(index); if (existing != null) { existing.removeChangeListener(this);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile(@TempDir File tempDir) throws Exception { File testJar = new File(tempDir, \"t+e+s+t.jar\");",
        "ins1DelCode":"public void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile() throws Exception { File testJar = this.temporaryFolder.newFile(\"t+e+s+t.jar\");",
        "ins1PreCode":"public void whenJarHasAPlusInItsPathConnectionJarFileMatchesOriginalJarFile() throws Exception { File testJar = this.temporaryFolder.newFile(\"t+e+s+t.jar\"); TestJarCreator.createTestJar(testJar); URL url = new URL(null, \"jar:\" + testJar.toURI().toURL() + \"!/nested.jar!/3.dat\", this.handler);",
        "ins2PreCode":"public void whenJarHasASpaceInItsPathConnectionJarFileMatchesOriginalJarFile() throws Exception { File testJar = this.temporaryFolder.newFile(\"t e s t.jar\"); TestJarCreator.createTestJar(testJar); URL url = new URL(null, \"jar:\" + testJar.toURI().toURL() + \"!/nested.jar!/3.dat\", this.handler);",
        "label":1
    },
    {
        "ins1AddCode":"TcpServer tcpServer = TcpServer.create(); tcpServer = tcpServer.runOn(this.resourceFactory.getLoopResources()); if (this.ssl != null && this.ssl.isEnabled()) { TcpSslServerCustomizer sslServerCustomizer = new TcpSslServerCustomizer(this.ssl, this.sslStoreProvider); tcpServer = sslServerCustomizer.apply(tcpServer); } return TcpServerTransport.create(tcpServer.bindAddress(this::getListenAddress));",
        "ins1DelCode":"TcpServer tcpServer = TcpServer.create().runOn(this.resourceFactory.getLoopResources()) .bindAddress(this::getListenAddress); return TcpServerTransport.create(tcpServer); return TcpServerTransport.create(getListenAddress());",
        "ins1PreCode":"private ServerTransport<CloseableChannel> createTcpTransport() { if (this.resourceFactory != null) { TcpServer tcpServer = TcpServer.create().runOn(this.resourceFactory.getLoopResources()) .bindAddress(this::getListenAddress); return TcpServerTransport.create(tcpServer); } return TcpServerTransport.create(getListenAddress());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"HttpClient httpClient = this.httpClientBuilder.get().setSSLSocketFactory(socketFactory).build();",
        "ins1DelCode":"HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build();",
        "ins1PreCode":"this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); ClientHttpResponse response = getClientResponse(getLocalUrl(\"https\", \"/hello\"), HttpMethod.GET, new HttpComponentsClientHttpRequestFactory(httpClient));",
        "ins2PreCode":"this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); ClientHttpResponse response = getClientResponse(getLocalUrl(\"https\", \"/hello\"), HttpMethod.GET, new HttpComponentsClientHttpRequestFactory(httpClient));",
        "label":1
    },
    {
        "ins1AddCode":"List<List<Tuple2<Integer, Integer>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1DelCode":"List<List<Tuple2<String, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1PreCode":"JavaPairDStream<Integer, Integer> sorted = pairStream.transformToPair(in -> in.sortByKey());  JavaTestUtils.attachTestOutputStream(sorted); List<List<Tuple2<String, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ctx.addApplicationListener(WsContextListener.class.getName());",
        "ins1DelCode":"ctx.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false));",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false));  tomcat.start();",
        "ins2PreCode":"Tomcat.addServlet(ctx, \"default2\", new DefaultServlet()); ctx.addServletMapping(\"/servlets/*\", \"default2\"); ctx.addApplicationListener(new ApplicationListener( WsContextListener.class.getName(), false)); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler); TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler); TimeUnit.MILLISECONDS, socketWrapper, handshakeReadCompletionHandler);",
        "ins1DelCode":"TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler);",
        "ins1PreCode":" if (netInBuffer.position() == 0) { sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; }  TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer);  if (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) {   int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit)));  netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; }  String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols();  case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: sc.read(netInBuffer, AbstractEndpoint.toTimeout(endpoint.getConnectionTimeout()), TimeUnit.MILLISECONDS, socket, handshakeReadCompletionHandler); return 1; case UNDERFLOW:",
        "ins2PreCode":"netOutBuffer.position(0); netInBuffer.capacity() < endpoint.getSniParseLimit()) { handshakeStatus = sslEngine.getHandshakeStatus(); return -1; } TLSClientHelloExtractor extractor = new TLSClientHelloExtractor(netInBuffer); while (extractor.getResult() == ExtractorResult.UNDERFLOW && netInBuffer.capacity() < endpoint.getSniParseLimit()) { int newLimit = Math.min(netInBuffer.capacity() * 2, endpoint.getSniParseLimit()); log.info(sm.getString(\"channel.nio.ssl.expandNetInBuffer\", Integer.toString(newLimit))); netInBuffer = ByteBufferUtils.expand(netInBuffer, newLimit); netInBuffer.capacity() < endpoint.getSniParseLimit()) { handshakeStatus = sslEngine.getHandshakeStatus(); return -1; } String hostName = null; List<Cipher> clientRequestedCiphers = null; List<String> clientRequestedApplicationProtocols = null; switch (extractor.getResult()) { case COMPLETE: hostName = extractor.getSNIValue(); clientRequestedApplicationProtocols = extractor.getClientRequestedApplicationProtocols(); case NOT_PRESENT: clientRequestedCiphers = extractor.getClientRequestedCiphers(); break; case NEED_READ: netInBuffer.capacity() < endpoint.getSniParseLimit()) { handshakeStatus = sslEngine.getHandshakeStatus(); return -1; case UNDERFLOW:",
        "label":0
    },
    {
        "ins1AddCode":"List<String> values = new ArrayList<>();",
        "ins1DelCode":"List<String> values = new ArrayList<String>();",
        "ins1PreCode":"p.setProperty( \"key\", \"value\" ); p.setProperty( \"key2\", \"value2\" );  List<String> values = new ArrayList<String>(); values.add( \"${key}\" ); values.add( \"${key2}\" );",
        "ins2PreCode":"p.setProperty( \"key\", \"value\" ); p.setProperty( \"key2\", \"value2\" ); List<String> values = new ArrayList<String>(); values.add( \"${key2}\" ); values.add( \"${key2}\" );",
        "label":1
    },
    {
        "ins1AddCode":".authorizedTo(Item.READ, Jenkins.READ)",
        "ins1DelCode":".authorizedTo(Job.READ, Jenkins.READ)",
        "ins1PreCode":"assertThat(project.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));  final CLICommandInvoker.Result result = command .authorizedTo(Job.READ, Jenkins.READ) .invokeWithArgs(\"aProject\", \"1\", \"test\"); assertThat(result, failedWith(6));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"output.show(false);",
        "ins1DelCode":"System.out.println(output.select(\"userFeatures\", \"features\").first());",
        "ins1PreCode":" Dataset<Row> output = vectorSlicer.transform(dataset);  System.out.println(output.select(\"userFeatures\", \"features\").first());  spark.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testCallWithResultSet1() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);  Name name = spMapper.getName(1); assertNotNull(name); assertEquals(\"Wilma\", name.getFirstName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testCallWithResultSet1_a2() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SPMapper spMapper = sqlSession.getMapper(SPMapper.class); Name name = spMapper.getNameAnnotatedWithXMLResultMap(1); assertNotNull(name); assertEquals(\"Wilma\", name.getFirstName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService, genericExecutor);",
        "ins1DelCode":"ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);",
        "ins1PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);  Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"(new InitSequenceDiagram()).init();",
        "ins1PreCode":"(new InitActivityDiagram()).init(); (new InitCollaborationDiagram()).init(); (new InitDeploymentDiagram()).init(); (new InitSequenceDiagram()).init(); (new InitStateDiagram()).init(); (new InitClassDiagram()).init();",
        "ins2PreCode":"(new InitActivityDiagram()).init(); (new InitCollaborationDiagram()).init(); (new InitDeploymentDiagram()).init(); (new InitSequenceDiagram()).init(); (new InitStateDiagram()).init(); (new InitClassDiagram()).init();",
        "label":1
    },
    {
        "ins1AddCode":"t = t.trim().toLowerCase(Locale.ENGLISH);",
        "ins1DelCode":"t = t.trim().toLowerCase();",
        "ins1PreCode":"private String getCharset(URLConnection con) { for( String t : con.getContentType().split(\";\") ) { t = t.trim().toLowerCase(); if(t.startsWith(\"charset=\")) return t.substring(8);",
        "ins2PreCode":"private String getCharset(URLConnection con) { for( String t : con.getContentType().split(\";\") ) { t = t.trim().toLowerCase(); if(t.startsWith(\"charset=\")) return t.substring(8);",
        "label":1
    },
    {
        "ins1AddCode":"configureMockForOneAcknowledgementWrite(socketWrapper); configureMockForNoAcknowledgementWrite(socketWrapper);",
        "ins1DelCode":"configureMockForOneAckowledgementWrite(socketWrapper); configureMockForNoAckowledgementWrite(socketWrapper);",
        "ins1PreCode":"request.setExpectation(true);   configureMockForOneAckowledgementWrite(socketWrapper);  protocol.setContinueResponseTiming(ContinueResponseTiming.IMMEDIATELY.toString()); response.action(ActionCode.ACK, ContinueResponseTiming.IMMEDIATELY);   EasyMock.verify(socketWrapper);   configureMockForNoAckowledgementWrite(socketWrapper);  request.doRead(new DoNothingApplicationBufferHandler());",
        "ins2PreCode":"request.setExpectation(true); configureMockForOneAckowledgementWrite(socketWrapper); protocol.setContinueResponseTiming(ContinueResponseTiming.ON_REQUEST_BODY_READ.toString()); response.action(ActionCode.ACK, ContinueResponseTiming.IMMEDIATELY); EasyMock.verify(socketWrapper); configureMockForNoAckowledgementWrite(socketWrapper); request.doRead(new DoNothingApplicationBufferHandler());",
        "label":1
    },
    {
        "ins1AddCode":"return ByteString.copyFrom(result); final byte[] bytes = new byte[size]; System.arraycopy(buffer, originalBufferPos, bytes, 0, bufferedBytes); int tempPos = bufferedBytes; for (final byte[] chunk : chunks) { System.arraycopy(chunk, 0, bytes, tempPos, chunk.length); tempPos += chunk.length; return ByteString.wrap(bytes);",
        "ins1DelCode":"return ByteString.wrap(result); List<ByteString> byteStrings = new ArrayList<ByteString>(1 + chunks.size()); byteStrings.add(ByteString.copyFrom(buffer, originalBufferPos, bufferedBytes)); for (byte[] chunk : chunks) { byteStrings.add(ByteString.wrap(chunk)); return ByteString.copyFrom(byteStrings);",
        "ins1PreCode":"private ByteString readBytesSlowPath(final int size) throws IOException { final byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return ByteString.wrap(result); }  final int originalBufferPos = pos; final int bufferedBytes = bufferSize - pos;   totalBytesRetired += bufferSize; pos = 0; bufferSize = 0;   int sizeLeft = size - bufferedBytes;    List<byte[]> chunks = readRawBytesSlowPathRemainingChunks(sizeLeft);   List<ByteString> byteStrings = new ArrayList<ByteString>(1 + chunks.size()); byteStrings.add(ByteString.copyFrom(buffer, originalBufferPos, bufferedBytes)); for (byte[] chunk : chunks) { byteStrings.add(ByteString.wrap(chunk)); } return ByteString.copyFrom(byteStrings);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void predecessors_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"createCompartments();",
        "ins1DelCode":"addExtraCompartments(); addFig(getOperationsFig());",
        "ins1PreCode":"addFig(getBigPort()); addFig(getNameFig()); addFig(getStereotypeFig()); addExtraCompartments(); addFig(getOperationsFig());  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"project1.getBuildersList().add(createScriptBuilder(\"echo 1\")); project2.getBuildersList().add(createScriptBuilder(\"echo 1\"));",
        "ins1DelCode":"project1.getBuildersList().add(new Shell(\"echo 1\")); project2.getBuildersList().add(new Shell(\"echo 1\"));",
        "ins1PreCode":"@Test public void reloadJobManyShouldSucceedEvenAJobIsSpecifiedTwice() throws Exception {  FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\"));  assertThat(project1.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assume.assumeFalse(\"This test currently fails for APR\", getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Apr\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testTcpCloseInOnMessage() throws Exception { startServer(TestEndpointConfig.class);  TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.httpUpgrade(BaseEndpointConfig.PATH); client.sendMessage(\"Test\");",
        "ins2PreCode":"public void testWsCloseThenTcpCloseWhenOnMessageSends() throws Exception { startServer(TestEndpointConfig.class); TesterWsCloseClient client = new TesterWsCloseClient(\"localhost\", getPort()); client.httpUpgrade(BaseEndpointConfig.PATH); client.sendMessage(\"Test\");",
        "label":0
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>(); DefaultCategoryDataset<String, String> dataset2 = new DefaultCategoryDataset<>(); DefaultCategoryDataset<String, String> datasetA DefaultCategoryDataset<String, String> datasetB",
        "ins1DelCode":"DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); DefaultCategoryDataset dataset2 = new DefaultCategoryDataset(); DefaultCategoryDataset datasetA DefaultCategoryDataset datasetB",
        "ins1PreCode":"public void testSerialization5() { DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); CategoryAxis domainAxis1 = new CategoryAxis(\"Domain 1\"); NumberAxis rangeAxis1 = new NumberAxis(\"Range 1\"); BarRenderer renderer1 = new BarRenderer(); CategoryPlot p1 = new CategoryPlot(dataset1, domainAxis1, rangeAxis1, renderer1); CategoryAxis domainAxis2 = new CategoryAxis(\"Domain 2\"); NumberAxis rangeAxis2 = new NumberAxis(\"Range 2\"); BarRenderer renderer2 = new BarRenderer(); DefaultCategoryDataset dataset2 = new DefaultCategoryDataset(); p1.setDataset(1, dataset2); p1.setDomainAxis(1, domainAxis2); p1.setRangeAxis(1, rangeAxis2); p1.setRenderer(1, renderer2); CategoryPlot p2 = (CategoryPlot) TestUtils.serialised(p1); assertEquals(p1, p2);    CategoryAxis domainAxisA = p2.getDomainAxis(0); NumberAxis rangeAxisA = (NumberAxis) p2.getRangeAxis(0); DefaultCategoryDataset datasetA = (DefaultCategoryDataset) p2.getDataset(0); BarRenderer rendererA = (BarRenderer) p2.getRenderer(0); CategoryAxis domainAxisB = p2.getDomainAxis(1); NumberAxis rangeAxisB = (NumberAxis) p2.getRangeAxis(1); DefaultCategoryDataset datasetB = (DefaultCategoryDataset) p2.getDataset(1); BarRenderer rendererB  = (BarRenderer) p2.getRenderer(1);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"long after = TestHelper.awaitGC(GC_SLEEP_TIME, 20, start + 20 * 1000 * 1000);",
        "ins1DelCode":"System.gc(); Thread.sleep(100); long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();",
        "ins1PreCode":"System.gc(); Thread.sleep(100);  long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed();  source = null;",
        "ins2PreCode":"System.gc(); Thread.sleep(100); long after = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage().getUsed(); source = null;",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Object> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Object> to = new TestObserverEx<Object>();",
        "ins1PreCode":"public void assertValuePredicateEmpty() { TestObserverEx<Object> to = new TestObserverEx<Object>();  Observable.empty().subscribe(to);",
        "ins2PreCode":"public void assertValueAtPredicateEmpty() { TestObserverEx<Object> to = new TestObserverEx<Object>(); Observable.empty().subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"if (context.getName().equals(this.context.getName())) {",
        "ins1DelCode":"if (context.getPath().equals(this.context.getPath())) {",
        "ins1PreCode":"return; }  if (context.getPath().equals(this.context.getPath())) { writer.println(smClient.getString(\"managerServlet.noSelf\")); return;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public final <@NonNull R> Observable<R> replay(@NonNull Function<? super Observable<T>, ? extends ObservableSource<R>> selector, int bufferSize, long time, @NonNull TimeUnit unit, @NonNull Scheduler scheduler) {",
        "ins1DelCode":"public final <R> Observable<R> replay(@NonNull Function<? super Observable<T>, ? extends ObservableSource<R>> selector, int bufferSize, long time, @NonNull TimeUnit unit, @NonNull Scheduler scheduler) {",
        "ins1PreCode":"public final <R> Observable<R> replay(@NonNull Function<? super Observable<T>, ? extends ObservableSource<R>> selector, int bufferSize, long time, @NonNull TimeUnit unit, @NonNull Scheduler scheduler) { Objects.requireNonNull(selector, \"selector is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"public final <R> Observable<R> replay(@NonNull Function<? super Observable<T>, ? extends ObservableSource<R>> selector, int bufferSize, long time, @NonNull TimeUnit unit, @NonNull Scheduler scheduler, boolean eagerTruncate) { Objects.requireNonNull(selector, \"selector is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void tryTerminateConsumerMaybeObserverNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty());  AtomicThrowable ex = new AtomicThrowable();",
        "ins2PreCode":"public void tryTerminateConsumerSingleNoError() { TestObserver<Object> to = new TestObserver<Object>(); to.onSubscribe(Disposables.empty()); AtomicThrowable ex = new AtomicThrowable();",
        "label":1
    },
    {
        "ins1AddCode":"this.chain = new TestFilterChain((request, response, chain) -> { chain.call(); throw new IllegalStateException(\"BAD\"); });",
        "ins1DelCode":"this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new IllegalStateException(\"BAD\"); } };",
        "ins1PreCode":"public void subClassExceptionError() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new IllegalStateException(\"BAD\"); } }; this.filter.doFilter(this.request, this.response, this.chain); assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus())",
        "ins2PreCode":"public void nestedServletExceptionIsUnwrapped() throws Exception { this.filter.addErrorPages(new ErrorPage(RuntimeException.class, \"/500\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { super.doFilter(request, response); throw new NestedServletException(\"Wrapper\", new RuntimeException(\"BAD\")); } }; this.filter.doFilter(this.request, this.response, this.chain); assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus())",
        "label":1
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(-628444800000L, m.getFirstMillisecond(cal)); m.getFirstMillisecond((Calendar) null);",
        "ins1DelCode":"assertEquals(-628444800000L, m.getFirstMillisecond(zone)); m.getFirstMillisecond((TimeZone) null);",
        "ins1PreCode":"public void testGetFirstMillisecondWithTimeZone() { Month m = new Month(2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-628444800000L, m.getFirstMillisecond(zone));   boolean pass = false; try { m.getFirstMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "ins2PreCode":"public void testGetLastMillisecondWithTimeZone() { Month m = new Month(2, 1950); TimeZone zone = TimeZone.getTimeZone(\"America/Los_Angeles\"); assertEquals(-626025600001L, m.getLastMillisecond(zone)); boolean pass = false; try { m.getLastMillisecond((TimeZone) null); } catch (NullPointerException e) {",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(mapper, \"mapper is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(mapper, \"mapper is null\");",
        "ins1PreCode":"public final <R> Observable<R> concatMap(Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch) { ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) {",
        "ins2PreCode":"public final <R> Observable<R> concatMapDelayError(Function<? super T, ? extends ObservableSource<? extends R>> mapper, ObjectHelper.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) {",
        "label":1
    },
    {
        "ins1AddCode":"getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49726a.jsp\", res, headers);",
        "ins1DelCode":"getUrl(\"http://localhost:\" + getPort() + \"/test/bug49726a.jsp\", res, headers);",
        "ins1PreCode":"ByteChunk res = new ByteChunk(); Map<String,List<String>> headers = new HashMap<String,List<String>>();  getUrl(\"http://localhost:\" + getPort() + \"/test/bug49726a.jsp\", res, headers);  ",
        "ins2PreCode":"ByteChunk res = new ByteChunk(); Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/test/bug49726b.jsp\", res, headers);",
        "label":1
    },
    {
        "ins1AddCode":"ns1 = Model.getModelManagementFactory().buildPackage(\"P1\"); ns2 = Model.getModelManagementFactory().buildPackage(\"P2\");",
        "ins1DelCode":"ns1 = Model.getModelManagementFactory().buildPackage(\"P1\", null); ns2 = Model.getModelManagementFactory().buildPackage(\"P2\", null);",
        "ins1PreCode":"protected void setUp() throws Exception { super.setUp(); InitializeModel.initializeDefault(); ns1 = Model.getModelManagementFactory().buildPackage(\"P1\", null); ns2 = Model.getModelManagementFactory().buildPackage(\"P2\", null); c1 = Model.getCoreFactory().buildClass(\"A\", ns1); c2 = Model.getCoreFactory().buildClass(\"A\", ns1);",
        "ins2PreCode":"protected void setUp() throws Exception { super.setUp(); InitializeModel.initializeDefault(); ns1 = Model.getModelManagementFactory().buildPackage(\"P1\", null); ns2 = Model.getModelManagementFactory().buildPackage(\"P2\", null); c1 = Model.getCoreFactory().buildClass(\"A\", ns1); c2 = Model.getCoreFactory().buildClass(\"A\", ns1);",
        "label":1
    },
    {
        "ins1AddCode":"}, false, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"}, 2, false, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, false, ImmediateThinScheduler.INSTANCE); } });",
        "ins2PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, true, ImmediateThinScheduler.INSTANCE); } });",
        "label":1
    },
    {
        "ins1AddCode":"final ELArithmetic delegate = findDelegate(obj0, obj1); if (delegate == null) {",
        "ins1DelCode":"if (obj0 == null && obj1 == null) { final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) { if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGDECIMAL; else delegate = DOUBLE; } else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER; else delegate = LONG;",
        "ins1PreCode":"public static final Number subtract(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); }  final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) { if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGDECIMAL; else delegate = DOUBLE; } else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER; else delegate = LONG;  Number num0 = delegate.coerce(obj0);",
        "ins2PreCode":"public static final Number multiply(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return Long.valueOf(0); } final ELArithmetic delegate; if (BIGDECIMAL.matches(obj0, obj1)) delegate = BIGDECIMAL; else if (DOUBLE.matches(obj0, obj1)) { if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGDECIMAL; else delegate = DOUBLE; } else if (BIGINTEGER.matches(obj0, obj1)) delegate = BIGINTEGER; else delegate = LONG; Number num0 = delegate.coerce(obj0);",
        "label":1
    },
    {
        "ins1AddCode":"intData[i + rowId] = Platform.getInt(src, srcOffset);",
        "ins1DelCode":"intData[i + rowId] = Platform.getInt(src, srcOffset);;",
        "ins1PreCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { intData[i + rowId] = Platform.getInt(src, srcOffset);; srcIndex += 4; srcOffset += 4;",
        "ins2PreCode":"public void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { longData[i + rowId] = Platform.getLong(src, srcOffset); srcIndex += 8; srcOffset += 8;",
        "label":0
    },
    {
        "ins1AddCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); ",
        "ins2PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(3, message.getInt32ToInt32FieldMap().size()); assertEquals(111, message.getInt32ToInt32FieldMap().get(1).intValue()); assertEquals(33, message.getInt32ToInt32FieldMap().get(3).intValue()); assertEquals(44, message.getInt32ToInt32FieldMap().get(4).intValue()); assertEquals(3, message.getInt32ToStringFieldMap().size()); assertEquals(\"111\", message.getInt32ToStringFieldMap().get(1)); assertEquals(\"33\", message.getInt32ToStringFieldMap().get(3)); assertEquals(\"44\", message.getInt32ToStringFieldMap().get(4)); assertEquals(3, message.getInt32ToBytesFieldMap().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesFieldMap().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesFieldMap().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesFieldMap().get(4)); assertEquals(3, message.getInt32ToEnumFieldMap().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumFieldMap().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumFieldMap().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumFieldMap().get(4)); assertEquals(3, message.getInt32ToMessageFieldMap().size()); assertEquals(111, message.getInt32ToMessageFieldMap().get(1).getValue()); assertEquals(33, message.getInt32ToMessageFieldMap().get(3).getValue()); assertEquals(44, message.getInt32ToMessageFieldMap().get(4).getValue()); assertEquals(3, message.getStringToInt32FieldMap().size()); assertEquals(111, message.getStringToInt32FieldMap().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32FieldMap().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32FieldMap().get(\"4\").intValue());",
        "ins1DelCode":"assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(111, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(4).intValue()); assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"111\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"44\", message.getInt32ToStringField().get(4)); assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesField().get(4)); assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumField().get(4)); assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(111, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(44, message.getInt32ToMessageField().get(4).getValue()); assertEquals(3, message.getStringToInt32Field().size()); assertEquals(111, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32Field().get(\"4\").intValue());",
        "ins1PreCode":"private void assertMapValuesUpdated(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(111, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(4).intValue());  assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"111\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"44\", message.getInt32ToStringField().get(4));  assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"111\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"44\"), message.getInt32ToBytesField().get(4));  assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(1)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.QUX, message.getInt32ToEnumField().get(4));  assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(111, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(44, message.getInt32ToMessageField().get(4).getValue());  assertEquals(3, message.getStringToInt32Field().size()); assertEquals(111, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(44, message.getStringToInt32Field().get(\"4\").intValue());",
        "ins2PreCode":"private void assertMapValuesSet(TestMap message) { assertEquals(3, message.getInt32ToInt32Field().size()); assertEquals(11, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(3).intValue()); assertEquals(11, message.getInt32ToInt32Field().get(1).intValue()); assertEquals(3, message.getInt32ToStringField().size()); assertEquals(\"11\", message.getInt32ToStringField().get(1)); assertEquals(\"33\", message.getInt32ToStringField().get(3)); assertEquals(\"11\", message.getInt32ToStringField().get(1)); assertEquals(3, message.getInt32ToBytesField().size()); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesField().get(1)); assertEquals(TestUtil.toBytes(\"33\"), message.getInt32ToBytesField().get(3)); assertEquals(TestUtil.toBytes(\"11\"), message.getInt32ToBytesField().get(1)); assertEquals(3, message.getInt32ToEnumField().size()); assertEquals(TestMap.EnumValue.BAR, message.getInt32ToEnumField().get(2)); assertEquals(TestMap.EnumValue.BAZ, message.getInt32ToEnumField().get(3)); assertEquals(TestMap.EnumValue.FOO, message.getInt32ToEnumField().get(1)); assertEquals(3, message.getInt32ToMessageField().size()); assertEquals(11, message.getInt32ToMessageField().get(1).getValue()); assertEquals(33, message.getInt32ToMessageField().get(3).getValue()); assertEquals(11, message.getInt32ToMessageField().get(1).getValue()); assertEquals(3, message.getStringToInt32Field().size()); assertEquals(11, message.getStringToInt32Field().get(\"1\").intValue()); assertEquals(33, message.getStringToInt32Field().get(\"3\").intValue()); assertEquals(11, message.getStringToInt32Field().get(\"1\").intValue());",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/test\", \"NoContentLengthFlushingServlet\");",
        "ins1DelCode":"ctx.addServletMapping(\"/test\", \"NoContentLengthFlushingServlet\");",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"NoContentLengthFlushingServlet\", new NoContentLengthFlushingServlet()); ctx.addServletMapping(\"/test\", \"NoContentLengthFlushingServlet\");  tomcat.start();",
        "ins2PreCode":"Tomcat.addServlet(ctx, \"NoContentLengthConnectionCloseFlushingServlet\", new NoContentLengthConnectionCloseFlushingServlet()); Tomcat.addServlet(ctx, \"NoContentLengthConnectionCloseFlushingServlet\", tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1DelCode":"original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1PreCode":"Author original; Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally {",
        "ins2PreCode":"Author original; Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthorIfNecessary\", original); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); session.commit(); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally {",
        "label":1
    },
    {
        "ins1AddCode":"public void customEnvironment() {",
        "ins1DelCode":"public void customEnvironment() throws Exception {",
        "ins1PreCode":"public void customEnvironment() throws Exception { TestSpringApplication application = new TestSpringApplication( ExampleConfig.class);",
        "ins2PreCode":"public void propertiesFileEnhancesEnvironment() throws Exception { SpringApplication application = new SpringApplication(ExampleConfig.class); SpringApplication application = new SpringApplication(ExampleConfig.class);",
        "label":1
    },
    {
        "ins1AddCode":"TimePeriodValues<String> s = new TimePeriodValues<>(\"Test\");",
        "ins1DelCode":"TimePeriodValues s = new TimePeriodValues(\"Test\");",
        "ins1PreCode":"public void testGetMaxStartIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMaxStartIndex()); s.add(new SimpleTimePeriod(100L, 200L), 1.0);",
        "ins2PreCode":"public void testGetMinMiddleIndex() { TimePeriodValues s = new TimePeriodValues(\"Test\"); assertEquals(-1, s.getMinMiddleIndex()); s.add(new SimpleTimePeriod(100L, 200L), 1.0);",
        "label":1
    },
    {
        "ins1AddCode":"return Decimal.createUnsafe(getLong(ordinal), precision, scale);",
        "ins1DelCode":"return Decimal.apply(getLong(ordinal), precision, scale);",
        "ins1PreCode":"return null; } if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.apply(getLong(ordinal), precision, scale); } else { byte[] bytes = getBinary(ordinal);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void loadDefaultPropertiesFile() {",
        "ins1DelCode":"public void loadDefaultPropertiesFile() throws Exception {",
        "ins1PreCode":"public void loadDefaultPropertiesFile() throws Exception { this.environment.setDefaultProfiles(\"thedefault\"); this.initializer.setSearchNames(\"testprofiles\");",
        "ins2PreCode":"public void loadTwoPropertiesFile() throws Exception { String property = this.environment.getProperty(\"the.property\"); this.initializer.postProcessEnvironment(this.environment, this.application);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, message.getInt32ToInt32FieldMap().size()); assertEquals(0, message.getInt32ToMessageFieldMap().size()); assertEquals(22, message.getInt32ToInt32FieldMap().get(11).intValue()); assertEquals(44, message.getInt32ToInt32FieldMap().get(33).intValue()); assertEquals(222, message.getInt32ToMessageFieldMap().get(111).getValue()); assertEquals(444, message.getInt32ToMessageFieldMap().get(333).getValue()); assertEquals(66, message.getInt32ToInt32FieldMap().get(55).intValue()); assertEquals(666, message.getInt32ToMessageFieldMap().get(555).getValue()); assertEquals(55, message.getInt32ToInt32FieldMap().get(55).intValue()); assertEquals(555, message.getInt32ToMessageFieldMap().get(555).getValue()); assertEquals(11, message.getInt32ToInt32FieldMap().get(22).intValue()); assertEquals(33, message.getInt32ToInt32FieldMap().get(44).intValue()); assertEquals(55, message.getInt32ToInt32FieldMap().get(55).intValue());",
        "ins1DelCode":"assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToMessageField().size()); assertEquals(22, message.getInt32ToInt32Field().get(11).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(33).intValue()); assertEquals(222, message.getInt32ToMessageField().get(111).getValue()); assertEquals(444, message.getInt32ToMessageField().get(333).getValue()); assertEquals(66, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(666, message.getInt32ToMessageField().get(555).getValue()); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(555, message.getInt32ToMessageField().get(555).getValue()); assertEquals(11, message.getInt32ToInt32Field().get(22).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(44).intValue()); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue());",
        "ins1PreCode":"builder.clearField(f(\"int32_to_int32_field\")); builder.clearField(f(\"int32_to_message_field\")); message = builder.build(); assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToMessageField().size());   setMapValues(builder, \"int32_to_int32_field\", mapForValues(11, 22, 33, 44)); setMapValues( builder, \"int32_to_message_field\", mapForValues( 111, MessageValue.newBuilder().setValue(222).build(), 333, MessageValue.newBuilder().setValue(444).build())); message = builder.build(); assertEquals(22, message.getInt32ToInt32Field().get(11).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(33).intValue()); assertEquals(222, message.getInt32ToMessageField().get(111).getValue()); assertEquals(444, message.getInt32ToMessageField().get(333).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 66)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(666).build())); message = builder.build(); assertEquals(66, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(666, message.getInt32ToMessageField().get(555).getValue());   builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 55)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(555).build())); message = builder.build(); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(555, message.getInt32ToMessageField().get(555).getValue());   for (int i = 0; i < builder.getRepeatedFieldCount(f(\"int32_to_int32_field\")); i++) { Message mapEntry = (Message) builder.getRepeatedField(f(\"int32_to_int32_field\"), i); int oldKey = ((Integer) getFieldValue(mapEntry, \"key\")).intValue(); int oldValue = ((Integer) getFieldValue(mapEntry, \"value\")).intValue();  Message.Builder mapEntryBuilder = mapEntry.toBuilder(); setFieldValue(mapEntryBuilder, \"key\", oldValue); setFieldValue(mapEntryBuilder, \"value\", oldKey); builder.setRepeatedField(f(\"int32_to_int32_field\"), i, mapEntryBuilder.build()); } message = builder.build(); assertEquals(11, message.getInt32ToInt32Field().get(22).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(44).intValue()); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue());",
        "ins2PreCode":"builder.clearField(f(\"int32_to_int32_field\")); builder.clearField(f(\"int32_to_message_field\")); message = builder.build(); assertEquals(0, message.getInt32ToInt32Field().size()); assertEquals(0, message.getInt32ToMessageField().size()); setMapValues(builder, \"int32_to_int32_field\", mapForValues(11, 22, 33, 44)); setMapValues( builder, \"int32_to_message_field\", mapForValues( 111, MessageValue.newBuilder().setValue(222).build(), 333, MessageValue.newBuilder().setValue(444).build())); message = builder.build(); assertEquals(22, message.getInt32ToInt32Field().get(11).intValue()); assertEquals(44, message.getInt32ToInt32Field().get(33).intValue()); assertEquals(222, message.getInt32ToMessageField().get(111).getValue()); assertEquals(444, message.getInt32ToMessageField().get(333).getValue()); builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 66)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(666).build())); message = builder.build(); assertEquals(66, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(666, message.getInt32ToMessageField().get(555).getValue()); builder.addRepeatedField( f(\"int32_to_int32_field\"), newMapEntry(builder, \"int32_to_int32_field\", 55, 55)); builder.addRepeatedField( f(\"int32_to_message_field\"), newMapEntry( builder, \"int32_to_message_field\", 555, MessageValue.newBuilder().setValue(555).build())); message = builder.build(); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue()); assertEquals(555, message.getInt32ToMessageField().get(555).getValue()); for (int i = 0; i < builder.getRepeatedFieldCount(f(\"int32_to_int32_field\")); i++) { Message mapEntry = (Message) builder.getRepeatedField(f(\"int32_to_int32_field\"), i); int oldKey = ((Integer) getFieldValue(mapEntry, \"key\")).intValue(); int oldValue = ((Integer) getFieldValue(mapEntry, \"value\")).intValue(); Message.Builder mapEntryBuilder = mapEntry.toBuilder(); setFieldValue(mapEntryBuilder, \"key\", oldValue); setFieldValue(mapEntryBuilder, \"value\", oldKey); builder.setRepeatedField(f(\"int32_to_int32_field\"), i, mapEntryBuilder.build()); } message = builder.build(); assertEquals(11, message.getInt32ToInt32Field().get(22).intValue()); assertEquals(33, message.getInt32ToInt32Field().get(44).intValue()); assertEquals(55, message.getInt32ToInt32Field().get(55).intValue());",
        "label":1
    },
    {
        "ins1AddCode":"c.putFloatsLittleEndian(rowId, total, buffer.array(), offset);",
        "ins1DelCode":"c.putFloats(rowId, total, buffer.array(), offset);",
        "ins1PreCode":" if (buffer.hasArray()) { int offset = buffer.arrayOffset() + buffer.position(); c.putFloats(rowId, total, buffer.array(), offset); } else { for (int i = 0; i < total; i += 1) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(2, features.size());",
        "ins1DelCode":"Assert.assertEquals(features.size(), 2);",
        "ins1PreCode":" for (Row r : output.select(\"userFeatures\", \"features\").takeAsList(2)) { Vector features = r.getAs(1); Assert.assertEquals(features.size(), 2); }",
        "ins2PreCode":".setInputCol(\"userFeatures\").setOutputCol(\"features\"); VectorSlicer vectorSlicer = new VectorSlicer() .setInputCol(\"userFeatures\").setOutputCol(\"features\"); }",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeQuantum + \" - Quantum\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), hashCodeCloudComputing + \" - Cloud Computing\", \"result.bib\")));",
        "ins1DelCode":"assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"result.bib\")));",
        "ins1PreCode":" testCrawler.performCrawl();  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"ArXiv.bib\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"Springer.bib\")));  assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"result.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"studyResult.bib\")));",
        "ins2PreCode":"getTestStudyRepository(); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"Springer.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"2 - Cloud Computing\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"3 - TestSearchQuery3\", \"ArXiv.bib\"))); assertTrue(Files.exists(Path.of(tempRepositoryDirectory.toString(), \"1 - Quantum\")));",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(endpoint.getEndpointId()) .isEqualTo(EndpointId.of(\"testservlet\"));",
        "ins1DelCode":"assertThat(endpoint.getId()).isEqualTo(\"testservlet\");",
        "ins1PreCode":".getEndpoints(); assertThat(endpoints).hasSize(1); ExposableServletEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testservlet\"); assertThat(endpoint.getEndpointServlet()).isNotNull(); assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);",
        "ins2PreCode":".getEndpoints(); assertThat(endpoints).hasSize(1); ExposableServletEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testservlet\"); assertThat(endpoint.getEndpointServlet()).isNotNull(); assertThat(endpoint).isInstanceOf(DiscoveredEndpoint.class);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Object> to = new TestObserverEx<>(); TestSubscriberEx<Object> ts = new TestSubscriberEx<>(); TestObserverEx<Object> to = new TestObserverEx<>(); TestObserverEx<Object> to = new TestObserverEx<>(); TestObserverEx<Object> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Object> to = new TestObserverEx<Object>(); TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>(); TestObserverEx<Object> to = new TestObserverEx<Object>(); TestObserverEx<Object> to = new TestObserverEx<Object>(); TestObserverEx<Object> to = new TestObserverEx<Object>();",
        "ins1PreCode":" if (o instanceof ObservableSource) { ObservableSource<?> os = (ObservableSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof Publisher) { Publisher<?> os = (Publisher<?>) o; TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>();  os.subscribe(ts);  ts.awaitDone(5, TimeUnit.SECONDS);  ts.assertSubscribed();  if (expected != null) { ts.assertValues(expected); } if (error) { ts.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { ts.assertNoErrors().assertComplete(); } }  if (o instanceof SingleSource) { SingleSource<?> os = (SingleSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof MaybeSource) { MaybeSource<?> os = (MaybeSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);  to.awaitDone(5, TimeUnit.SECONDS);  to.assertSubscribed();  if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } }  if (o instanceof CompletableSource) { CompletableSource os = (CompletableSource) o; TestObserverEx<Object> to = new TestObserverEx<Object>();  os.subscribe(to);",
        "ins2PreCode":"if (o instanceof ObservableSource) { ObservableSource<?> os = (ObservableSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>(); os.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS); to.assertSubscribed(); if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } } if (o instanceof Publisher) { Publisher<?> os = (Publisher<?>) o; TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>(); os.subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS); ts.assertSubscribed(); if (expected != null) { ts.assertValues(expected); } if (error) { ts.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { ts.assertNoErrors().assertComplete(); } } if (o instanceof SingleSource) { SingleSource<?> os = (SingleSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>(); os.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS); to.assertSubscribed(); if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } } if (o instanceof MaybeSource) { MaybeSource<?> os = (MaybeSource<?>) o; TestObserverEx<Object> to = new TestObserverEx<Object>(); os.subscribe(to); to.awaitDone(5, TimeUnit.SECONDS); to.assertSubscribed(); if (expected != null) { to.assertValues(expected); } if (error) { to.assertError(TestException.class) .assertErrorMessage(\"error\") .assertNotComplete(); } else { to.assertNoErrors().assertComplete(); } } if (o instanceof CompletableSource) { CompletableSource os = (CompletableSource) o; TestObserverEx<Object> to = new TestObserverEx<Object>(); os.subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"bibEntry.setType(StandardEntryType.Book); bibEntry.setCiteKey(\"9780134685991\"); bibEntry.setField(StandardField.TITLE, \"Effective Java\"); bibEntry.setField(StandardField.PUBLISHER, \"Addison Wesley\"); bibEntry.setField(StandardField.YEAR, \"2018\"); bibEntry.setField(StandardField.AUTHOR, \"Bloch, Joshua\"); bibEntry.setField(StandardField.DATE, \"2018-01-11\"); bibEntry.setField(new UnknownField(\"ean\"), \"9780134685991\"); bibEntry.setField(StandardField.ISBN, \"0134685997\"); bibEntry.setField(StandardField.URL, \"https://www.ebook.de/de/product/28983211/joshua_bloch_effective_java.html\");",
        "ins1DelCode":"bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780134685991\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2018\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2018-01-11\"); bibEntry.setField(\"ean\", \"9780134685991\"); bibEntry.setField(\"isbn\", \"0134685997\"); bibEntry.setField(\"url\", \"https://www.ebook.de/de/product/28983211/joshua_bloch_effective_java.html\");",
        "ins1PreCode":"fetcher = new IsbnFetcher(mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS));  bibEntry = new BibEntry(); bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780134685991\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2018\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2018-01-11\"); bibEntry.setField(\"ean\", \"9780134685991\"); bibEntry.setField(\"isbn\", \"0134685997\"); bibEntry.setField(\"url\", \"https://www.ebook.de/de/product/28983211/joshua_bloch_effective_java.html\");",
        "ins2PreCode":"fetcher = new IsbnViaEbookDeFetcher(mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS)); bibEntry = new BibEntry(); bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780134685991\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2018\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2018-01-11\"); bibEntry.setField(\"ean\", \"9780134685991\"); bibEntry.setField(\"isbn\", \"0134685997\"); bibEntry.setField(\"url\", \"https://www.ebook.de/de/product/28983211/joshua_bloch_effective_java.html\");",
        "label":1
    },
    {
        "ins1AddCode":"label_16: jj_la1[41] = jj_gen; break label_16; jj_la1[42] = jj_gen;",
        "ins1DelCode":"label_15: jj_la1[40] = jj_gen; break label_15; jj_la1[41] = jj_gen;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[40] = jj_gen; break label_15; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[42] = jj_gen; break label_16; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"throw new AttributeNotFoundException(sm.getString(\"managedMBean.noAttribute\", aname, resource)); throw new ReflectionException(exception, sm.getString(\"managedMBean.noGet\", getMethod, resource));",
        "ins1DelCode":"throw new AttributeNotFoundException(\" Cannot find attribute \" + aname + \" for \" + resource); throw new ReflectionException(exception, \"Cannot find getter method \" + getMethod);",
        "ins1PreCode":"AttributeInfo attrInfo = attributes.get(aname);  if (attrInfo == null) throw new AttributeNotFoundException(\" Cannot find attribute \" + aname + \" for \" + resource);  String getMethod = attrInfo.getGetMethod();  Object object = null; NoSuchMethodException exception = null; try { object = mbean; m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG); } catch (NoSuchMethodException e) { exception = e; } if (m == null && resource != null) { try { object = resource; m = object.getClass().getMethod(getMethod, NO_ARGS_PARAM_SIG); exception=null; } catch (NoSuchMethodException e) { exception = e; } } if (exception != null) { throw new ReflectionException(exception, \"Cannot find getter method \" + getMethod); } ",
        "ins2PreCode":"AttributeInfo attrInfo = attributes.get(aname); if (attrInfo == null) { throw new AttributeNotFoundException(\" Cannot find attribute \" + aname); String setMethod = attrInfo.getSetMethod(); Object object = null; NoSuchMethodException exception = null; try { object = bean; m = object.getClass().getMethod(setMethod, signature); } catch (NoSuchMethodException e) { exception = e; } if (m == null && resource != null) { try { object = resource; m = object.getClass().getMethod(setMethod, signature); exception=null; } catch (NoSuchMethodException e) { exception = e; } } if (exception != null) { throw new ReflectionException(exception, \"Cannot find setter method \" + setMethod + \" \" + resource); }",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Object> testSubscriber = TestSubscriber.create(); .subscribe(testSubscriber); testSubscriber.awaitDone(5, TimeUnit.SECONDS);",
        "ins1DelCode":"TestSubscriber<Object> testObserver = TestSubscriber.create(); .subscribe(testObserver); testObserver.awaitDone(5, TimeUnit.SECONDS);",
        "ins1PreCode":"public void combine2Flowable2Errors() throws Exception { List<Throwable> errors = TestHelper.trackPluginErrors(); try { TestSubscriber<Object> testObserver = TestSubscriber.create();  TestScheduler testScheduler = new TestScheduler();  Flowable<Integer> emptyFlowable = Flowable.timer(10, TimeUnit.MILLISECONDS, testScheduler) .flatMap(new Function<Long, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Long aLong) throws Exception { return Flowable.error(new Exception()); } }); Flowable<Object> errorFlowable = Flowable.timer(100, TimeUnit.MILLISECONDS, testScheduler).map(new Function<Long, Object>() { @Override public Object apply(Long aLong) throws Exception { throw new Exception(); } });  Flowable.combineLatestDelayError( Arrays.asList( emptyFlowable .doOnEach(new Consumer<Notification<Integer>>() { @Override public void accept(Notification<Integer> integerNotification) throws Exception { System.out.println(\"emptyFlowable: \" + integerNotification); } }) .doFinally(new Action() { @Override public void run() throws Exception { System.out.println(\"emptyFlowable: doFinally\"); } }), errorFlowable .doOnEach(new Consumer<Notification<Object>>() { @Override public void accept(Notification<Object> integerNotification) throws Exception { System.out.println(\"errorFlowable: \" + integerNotification); } }) .doFinally(new Action() { @Override public void run() throws Exception { System.out.println(\"errorFlowable: doFinally\"); } })), new Function<Object[], Object>() { @Override public Object apply(Object[] objects) throws Exception { return 0; } } ) .doOnEach(new Consumer<Notification<Object>>() { @Override public void accept(Notification<Object> integerNotification) throws Exception { System.out.println(\"combineLatestDelayError: \" + integerNotification); } }) .doFinally(new Action() { @Override public void run() throws Exception { System.out.println(\"combineLatestDelayError: doFinally\"); } }) .subscribe(testObserver);  testScheduler.advanceTimeBy(100, TimeUnit.MILLISECONDS);  testObserver.awaitDone(5, TimeUnit.SECONDS);  assertTrue(errors.toString(), errors.isEmpty());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<String>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"private static JFreeChart createChart() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection(series1); return ChartFactory.createXYAreaChart(\"Area Chart\", \"Domain\", \"Range\", dataset);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> thrown = new AtomicReference<>(null);",
        "ins1DelCode":"final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>(null);",
        "ins1PreCode":"public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer) throws Throwable { final AtomicInteger count = new AtomicInteger(0); final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>(null); final int numThreads = 3; final Thread[] threads = new Thread[numThreads];",
        "ins2PreCode":"public void testSupplierThreadSafe(Function<Supplier<Boolean>, Supplier<Boolean>> memoizer) throws Throwable { final AtomicInteger count = new AtomicInteger(0); final AtomicReference<Throwable> thrown = new AtomicReference<Throwable>(null); final int numThreads = 3; final Thread[] threads = new Thread[numThreads];",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1DelCode":"AUTH_HEADER.getHeader());",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD1, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(METHOD, USER_NAME, PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"when(filePreferences.getFileDirectoryPattern()).thenReturn(\"[entrytype]\");",
        "ins1DelCode":"when(filePreferences.getFileDirPattern()).thenReturn(\"[entrytype]\");",
        "ins1PreCode":"void movesFileWithFileDirPattern() throws Exception { when(filePreferences.getFileDirPattern()).thenReturn(\"[entrytype]\"); cleanup.cleanup(entry); ",
        "ins2PreCode":"void movesFileWithSubdirectoryPattern() throws Exception { when(filePreferences.getFileDirPattern()).thenReturn(\"[entrytype]/[year]/[auth]\"); cleanup.cleanup(entry);",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(mapping, \"Include\"); ctx.addServletMappingDecoded(\"/mapping\", \"Mapping\");",
        "ins1DelCode":"ctx.addServletMapping(mapping, \"Include\"); ctx.addServletMapping(\"/mapping\", \"Mapping\");",
        "ins1PreCode":"Context ctx = tomcat.addContext(contextPath, null);  Tomcat.addServlet(ctx, \"Include\", new IncludeServlet()); ctx.addServletMapping(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\");  tomcat.start();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void inEdges_checkReturnedSetMutability() { addNode(N2); Set<String> inEdges = network.inEdges(N2); try { inEdges.add(E12);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Long> ts = new TestSubscriber<>(new DefaultSubscriber<Long>() {",
        "ins1DelCode":"TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {",
        "ins1PreCode":"public void fixBackpressureWithBuffer() throws InterruptedException { final CountDownLatch l1 = new CountDownLatch(100); final CountDownLatch l2 = new CountDownLatch(150); TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() {  @Override",
        "ins2PreCode":"public void fixBackpressureWithBuffer() throws InterruptedException { final CountDownLatch l1 = new CountDownLatch(100); final CountDownLatch l2 = new CountDownLatch(150); TestSubscriber<Long> ts = new TestSubscriber<Long>(new DefaultSubscriber<Long>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"this.launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(this.launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); this.launcher.launch(new String[0]);",
        "ins1DelCode":"PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); launcher.launch(new String[0]);",
        "ins1PreCode":"void testUserSpecifiedClassLoader() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\"); System.setProperty(\"loader.classLoader\", URLClassLoader.class.getName()); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); launcher.launch(new String[0]); waitFor(\"Hello World\");",
        "ins2PreCode":"void testUserSpecifiedClassPathOrder() throws Exception { System.setProperty(\"loader.path\", \"more-jars/app.jar,jars/app.jar\"); System.setProperty(\"loader.classLoader\", URLClassLoader.class.getName()); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()) launcher.launch(new String[0]); waitFor(\"Hello Other World\");",
        "label":1
    },
    {
        "ins1AddCode":"new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 1, 0, 0)); new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0, 0); validateChunks(TEST_APP, 0, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "ins1DelCode":"new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "ins1PreCode":"useTestFiles(true, false); RemoteBlockPushResolver.PushBlockStreamCallback callback1 = (RemoteBlockPushResolver.PushBlockStreamCallback) pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); RemoteBlockPushResolver.AppShufflePartitionInfo partitionInfo = callback1.getPartitionInfo();  TestMergeShuffleFile testIndexFile = (TestMergeShuffleFile) partitionInfo.getIndexFile(); testIndexFile.close(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); callback2.onData(callback2.getID(), ByteBuffer.wrap(new byte[5]));   callback2.onComplete(callback2.getID()); assertEquals(\"index position\", 16, testIndexFile.getPos());   testIndexFile.restore(); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); assertEquals(\"index position\", 24, testIndexFile.getPos()); validateMergeStatuses(statuses, new int[] {0}, new long[] {9}); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 5}, new int[][] {{0}, {1}});",
        "ins2PreCode":"useTestFiles(false, true); RemoteBlockPushResolver.PushBlockStreamCallback callback1 = (RemoteBlockPushResolver.PushBlockStreamCallback) pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); callback1.onData(callback1.getID(), ByteBuffer.wrap(new byte[4])); callback1.onComplete(callback1.getID()); RemoteBlockPushResolver.AppShufflePartitionInfo partitionInfo = callback1.getPartitionInfo(); TestMergeShuffleFile testMetaFile = (TestMergeShuffleFile) partitionInfo.getMetaFile(); testMetaFile.close(); StreamCallbackWithID callback2 = pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 1, 0, 0)); callback2.onData(callback2.getID(), ByteBuffer.wrap(new byte[5])); callback2.onComplete(callback2.getID()); assertEquals(\"index position\", 16, partitionInfo.getIndexFile().getPos()); testMetaFile.restore(); MergeStatuses statuses = pushResolver.finalizeShuffleMerge( new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0)); assertEquals(\"index position\", 24, partitionInfo.getIndexFile().getPos()); validateMergeStatuses(statuses, new int[] {0}, new long[] {11}); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[] {4, 7}, new int[][] {{0}, {1, 2}});",
        "label":1
    },
    {
        "ins1AddCode":"try (Connection con = datasource.getConnection()) { Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); }",
        "ins1DelCode":"Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "ins1PreCode":"this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(100); this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(2000); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "ins2PreCode":"this.datasource.getPoolProperties().setTimeBetweenEvictionRunsMillis(100); this.datasource.getPoolProperties().setRemoveAbandoned(true); this.datasource.getPoolProperties().setRemoveAbandonedTimeout(1); Connection con = datasource.getConnection(); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); Thread.sleep(200); Assert.assertEquals(\"Number of connections active/busy should be 1\",1,datasource.getPool().getActive()); con.close();",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); }",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); sqlSession.close();",
        "ins1PreCode":"public void testEnumWithOgnlDirectorWithInterface() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); sqlSession.close();",
        "ins2PreCode":"public void testEnumWithOgnlDirectorNameAttributeWithInterface() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = personMapper.selectAllByTypeNameAttributeWithInterface(new PersonType() { @Override public Type getType() { return Person.Type.DIRECTOR; } }); Assert.assertEquals(\"Persons must contain 1 persons\", 1, persons.size()); sqlSession.close();",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> reversed = pairStream.map(Tuple2::_2);",
        "ins1DelCode":"JavaDStream<Integer> reversed = pairStream.map(in -> in._2());",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); JavaTestUtils.attachTestOutputStream(reversed); List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".run(data); validatePrediction(model, users, products, testData._2(), 0.3, false, testData._3());",
        "ins1DelCode":".run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins1PreCode":" MatrixFactorizationModel model = new ALS().setRank(features) .setIterations(iterations) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"List<Row> data = Arrays.asList( RowFactory.create(0, Vectors.dense(1.0, 0.1, -8.0)), RowFactory.create(1, Vectors.dense(2.0, 1.0, -4.0)), RowFactory.create(2, Vectors.dense(4.0, 10.0, 8.0)) ); StructType schema = new StructType(new StructField[]{ new StructField(\"id\", DataTypes.IntegerType, false, Metadata.empty()), new StructField(\"features\", new VectorUDT(), false, Metadata.empty()) }); Dataset<Row> dataFrame = spark.createDataFrame(data, schema); scaledData.select(\"features\", \"scaledFeatures\").show();",
        "ins1DelCode":"Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); scaledData.show();",
        "ins1PreCode":".getOrCreate();   Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  spark.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"socketBufferHandler.configureReadBufferForRead(); ByteBuffer readBuffer = socketBufferHandler.getReadBuffer(); socketBufferHandler.configureReadBufferForRead();",
        "ins1DelCode":"ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer(); readBuffer.clear(); readBuffer.flip(); } else if (nRead == 0) { readBuffer.flip();",
        "ins1PreCode":"public int read(boolean block, byte[] b, int off, int len) throws IOException {  ByteBuffer readBuffer = getSocket().getBufHandler().getReadBuffer(); int remaining = readBuffer.remaining();   if (remaining >= len) { readBuffer.get(b, off, len); return len; }   int leftToWrite = len; int newOffset = off; if (remaining > 0) { readBuffer.get(b, off, remaining); leftToWrite -= remaining; newOffset += remaining; }   readBuffer.clear(); int nRead = fillReadBuffer(block);    if (nRead > 0) { readBuffer.flip(); if (nRead > leftToWrite) { readBuffer.get(b, newOffset, leftToWrite); leftToWrite = 0; } else { readBuffer.get(b, newOffset, nRead); leftToWrite -= nRead; } } else if (nRead == 0) { readBuffer.flip(); } else if (nRead == -1) { ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void testCallWithResultSet3() {",
        "ins1DelCode":"public void testCallWithResultSet3() {",
        "ins1PreCode":"public void testCallWithResultSet3() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins2PreCode":"public void testCallWithResultSet4() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"Binder binder, ResourceLoader resourceLoader, List<String> names) {",
        "ins1DelCode":"ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction;",
        "ins1PreCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLocationResolver<?>> instantiator = new Instantiator<>(ConfigDataLocationResolver.class, (availableParameters) -> {",
        "ins2PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> {",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"@SuppressWarnings(\"unchecked\")",
        "ins1PreCode":"Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<>(observer);  @SuppressWarnings(\"unchecked\") TestObservable<Observable<String>> observableOfObservables = new TestObservable<>(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2)); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "ins2PreCode":"Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<>(subscriber, 0L); Subscriber<String> subscriber = TestHelper.mockSubscriber(); final Flowable<String> concat = Flowable.concat(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2)); final Flowable<String> concat = Flowable.concat(Flowable.unsafeCreate(w1), Flowable.unsafeCreate(w2));",
        "label":0
    },
    {
        "ins1AddCode":"Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), PgContainer.getUnpooledDataSource());",
        "ins1DelCode":"String url = postgres.start(EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"postgres_genkeys\", \"postgres\", \"root\", Collections.emptyList()); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.postgresql.Driver\", url, null));",
        "ins1PreCode":"static void setUp() throws Exception {  String url = postgres.start(EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"postgres_genkeys\", \"postgres\", \"root\", Collections.emptyList());  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.postgresql.Driver\", url, null)); configuration.setEnvironment(environment); configuration.setUseGeneratedKeys(true);",
        "ins2PreCode":"static void setUp() throws Exception { String url = postgres.start(EmbeddedPostgres.cachedRuntimeConfig(Paths.get(System.getProperty(\"java.io.tmpdir\"), \"pgembed\")), \"localhost\", SocketUtil.findFreePort(), \"refcursor\", \"postgres\", \"root\", Collections.emptyList()); Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.postgresql.Driver\", url, null)); configuration.setEnvironment(environment); configuration.setEnvironment(environment);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"FFTFFFFFFTTF\", selectorRule.selectionString(s));",
        "ins1DelCode":"DependSelector s = new DependSelector(); String results = selectorRule.selectionString(s); assertEquals(\"FFTFFFFFFTTF\", results);",
        "ins1PreCode":"public void testGlobMapperRelativePath() { DependSelector s = new DependSelector(); File subdir = new File(\"selectortest/tar/bz2\"); s.setTargetdir(subdir);  Mapper.MapperType glob = new Mapper.MapperType(); glob.setValue(\"glob\");  Mapper m = s.createMapper(); m.setType(glob); m.setFrom(\"*.bz2\"); m.setTo(\"*.tar.bz2\");  String results = selectorRule.selectionString(s); assertEquals(\"FFTFFFFFFTTF\", results);",
        "ins2PreCode":"public void testRestrictedGlobMapper() { DependSelector s = new DependSelector(); File subdir = new File(selectorRule.getBeddir(), \"tar/bz2\"); s.setTargetdir(subdir); Mapper.MapperType glob = new Mapper.MapperType(); glob.setValue(\"glob\"); Mapper m = s.createMapper(); m.setType(glob); m.setFrom(\"*.bz2\"); m.setTo(\"*.tar.bz2\"); String results = selectorRule.selectionString(s); assertEquals(\"FFFFFFFFFTTF\", results);",
        "label":1
    },
    {
        "ins1AddCode":"private StringManager(String packageName, Locale locale) { ResourceBundle bnd = null; bnd = ResourceBundle.getBundle(bundleName, locale); } catch (MissingResourceException ex) { if (cl != null) { bnd = ResourceBundle.getBundle(bundleName, locale, cl); } catch (MissingResourceException ex2) { bundle = bnd; Locale bundleLocale = bundle.getLocale(); if (bundleLocale.equals(Locale.ROOT)) { this.locale = Locale.ENGLISH; } else { this.locale = bundleLocale; } this.locale = null;",
        "ins1DelCode":"private StringManager(String packageName) { ResourceBundle b = null; b = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) { if( cl != null ) { b = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) { this.bundle = b; locale = bundle.getLocale(); locale = null;",
        "ins1PreCode":"private StringManager(String packageName) { ResourceBundle b = null;  String bundleName = packageName + \".LocalStrings\"; try { b = ResourceBundle.getBundle(bundleName, Locale.getDefault()); } catch( MissingResourceException ex ) {    ClassLoader cl = Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { b = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } catch(MissingResourceException ex2) {  } } }  this.bundle = b; if (bundle != null) { locale = bundle.getLocale(); } else { locale = null; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"exportFormat.export(databaseContext, tmpFile.toPath(), charset, entries);",
        "ins1DelCode":"String filename = tmpFile.getCanonicalPath(); exportFormat.performExport(databaseContext, filename, charset, entries);",
        "ins1PreCode":"public void testPerformExportForSingleEditor() throws Exception { File tmpFile = testFolder.newFile(); String filename = tmpFile.getCanonicalPath(); BibEntry entry = new BibEntry(); entry.setField(\"editor\", \"Someone, Van Something\"); List<BibEntry> entries = Arrays.asList(entry);  exportFormat.performExport(databaseContext, filename, charset, entries);  List<String> lines = Files.readAllLines(tmpFile.toPath());",
        "ins2PreCode":"public void testPerformExportForMultipleEditors() throws Exception { File tmpFile = testFolder.newFile(); String filename = tmpFile.getCanonicalPath(); BibEntry entry = new BibEntry(); entry.setField(\"editor\", \"von Neumann, John and Smith, John and Black Brown, Peter\"); List<BibEntry> entries = Arrays.asList(entry); exportFormat.performExport(databaseContext, filename, charset, entries); List<String> lines = Files.readAllLines(tmpFile.toPath());",
        "label":1
    },
    {
        "ins1AddCode":"Disposable bs = Disposable.empty();",
        "ins1DelCode":"Disposable bs = Disposables.empty();",
        "ins1PreCode":".connect() .dispose();  Disposable bs = Disposables.empty();  sub[0].onSubscribe(bs);",
        "ins2PreCode":".connect() .dispose(); Disposable bs = Disposables.empty(); sub[0].onSubscribe(bs);",
        "label":1
    },
    {
        "ins1AddCode":"String location = getLocation(); if ( !location.isEmpty() ) { buffer.append( \" @ \" ); buffer.append( location ); }",
        "ins1DelCode":"buffer.append( \" @ \" ).append( getLocation() );",
        "ins1PreCode":" buffer.append( '[' ).append( getSeverity() ).append( \"] \" ); buffer.append( getMessage() ); buffer.append( \" @ \" ).append( getLocation() );  return buffer.toString();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return UTF8String.fromAddress(baseObject, baseOffset + offset, size);",
        "ins1DelCode":"MemoryBlock mb = MemoryBlock.allocateFromObject(baseObject, baseOffset + offset, size); return new UTF8String(mb);",
        "ins1PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; MemoryBlock mb = MemoryBlock.allocateFromObject(baseObject, baseOffset + offset, size); return new UTF8String(mb);",
        "ins2PreCode":"final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize; MemoryBlock mb = MemoryBlock.allocateFromObject(baseObject, baseOffset + offset, size); return new UTF8String(mb);",
        "label":1
    },
    {
        "ins1AddCode":"Composite catPanel = UIUtils.createComposite(sash, 1); Composite buttonsPanel = UIUtils.createComposite(catPanel, 3); Composite tablesPanel = UIUtils.createComposite(sash, 1); Composite buttonsPanel = UIUtils.createComposite(tablesPanel, 3);",
        "ins1DelCode":"Composite catPanel = UIUtils.createPlaceholder(sash, 1); Composite buttonsPanel = UIUtils.createPlaceholder(catPanel, 3, 5); Composite tablesPanel = UIUtils.createPlaceholder(sash, 1); Composite buttonsPanel = UIUtils.createPlaceholder(tablesPanel, 3, 5);",
        "ins1PreCode":"sash.setLayoutData(new GridData(GridData.FILL_BOTH));  { Composite catPanel = UIUtils.createPlaceholder(sash, 1); catPanel.setLayoutData(new GridData(GridData.FILL_BOTH)); schemasTable = new Table(catPanel, SWT.BORDER | SWT.CHECK); schemasTable.addListener(SWT.Selection, event -> { TableItem item = (TableItem) event.item; PostgreSchema catalog = (PostgreSchema) item.getData(); if (event.detail == SWT.CHECK) { schemasTable.select(schemasTable.indexOf(item)); checkedObjects.remove(catalog); } loadTables(catalog); updateState(); }); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; schemasTable.setLayoutData(gd);  Composite buttonsPanel = UIUtils.createPlaceholder(catPanel, 3, 5); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); new Label(buttonsPanel, SWT.NONE).setLayoutData(new GridData(GridData.GRAB_HORIZONTAL)); createCheckButtons(buttonsPanel, schemasTable); }  final Button exportViewsCheck; { Composite tablesPanel = UIUtils.createPlaceholder(sash, 1); tablesPanel.setLayoutData(new GridData(GridData.FILL_BOTH));  tablesTable = new Table(tablesPanel, SWT.BORDER | SWT.CHECK); GridData gd = new GridData(GridData.FILL_BOTH); gd.heightHint = 50; tablesTable.setLayoutData(gd); tablesTable.addListener(SWT.Selection, event -> { if (event.detail == SWT.CHECK) { updateCheckedTables(); updateState(); } });  Composite buttonsPanel = UIUtils.createPlaceholder(tablesPanel, 3, 5); buttonsPanel.setLayoutData(new GridData(GridData.FILL_HORIZONTAL)); exportViewsCheck = UIUtils.createCheckbox(buttonsPanel, PostgreMessages.wizard_backup_page_object_checkbox_show_view, false);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final List<GroupedFlowable<Integer, Integer>> groups = new ArrayList<>();",
        "ins1DelCode":"final List<GroupedFlowable<Integer, Integer>> groups = new ArrayList<GroupedFlowable<Integer, Integer>>();",
        "ins1PreCode":"public void abandonedGroupsNoDataloss() { final List<GroupedFlowable<Integer, Integer>> groups = new ArrayList<GroupedFlowable<Integer, Integer>>();  Flowable.range(1, 1000)",
        "ins2PreCode":"public void abandonedGroupsNoDataloss() { final List<GroupedObservable<Integer, Integer>> groups = new ArrayList<GroupedObservable<Integer, Integer>>(); Observable.range(1, 1000)",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('a');  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'd');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'd', 'd');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder(charactersOf(\"ac\")); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'c', 'd'); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b', 'c', 'd', 'd');",
        "label":1
    },
    {
        "ins1AddCode":"AtomicThrowable errors = this.errors; if (errors.get() != null) { errors.tryTerminateConsumer(e);",
        "ins1DelCode":"AtomicThrowable error = this.error; if (error.get() != null) { e.onError(error.terminate());",
        "ins1PreCode":"void drainLoop() { ObservableEmitter<T> e = emitter; SpscLinkedArrayQueue<T> q = queue; AtomicThrowable error = this.error; int missed = 1; for (;;) {  for (;;) { if (e.isDisposed()) { q.clear(); return; }  if (error.get() != null) { q.clear(); e.onError(error.terminate()); return; }",
        "ins2PreCode":"void drainLoop() { BaseEmitter<T> e = emitter; SimplePlainQueue<T> q = queue; AtomicThrowable error = this.error; int missed = 1; for (;;) { for (;;) { if (e.isCancelled()) { q.clear(); return; } if (error.get() != null) { q.clear(); e.onError(error.terminate()); return; }",
        "label":1
    },
    {
        "ins1AddCode":"} else if (!\"META-INF/MANIFEST.MF\".equals(genericEntry.getName())) {",
        "ins1DelCode":"} else if (!genericEntry.getName() .equals(\"META-INF/MANIFEST.MF\")) {",
        "ins1PreCode":"}  replaceEntries.put(filepath, genericEntry); } else if (!genericEntry.getName() .equals(\"META-INF/MANIFEST.MF\")) {  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".take(2)",
        "ins1DelCode":".limit(2)",
        "ins1PreCode":"final MaybeSubject<Integer> cs = MaybeSubject.create();  TestSubscriber<Integer> ts = pp.mergeWith(cs) .limit(2) .subscribeWith(new TestSubscriber<Integer>(2) { @Override",
        "ins2PreCode":"final SingleSubject<Integer> cs = SingleSubject.create(); TestSubscriber<Integer> ts = pp.mergeWith(cs) .limit(2) .subscribeWith(new TestSubscriber<Integer>(2) { @Override",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(directedGraph.addEdge(N1, N2, E12)).isTrue();",
        "ins1DelCode":"assertThat(directedGraph.addEdgeV2(N1, N2, E12)).isTrue();",
        "ins1PreCode":"MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed() .expectedEdgeCount(EDGE_COUNT) .build(); assertThat(directedGraph.addEdgeV2(N1, N2, E12)).isTrue(); assertThat(directedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12)); assertThat(directedGraph.edgesConnecting(N2, N1)).isEmpty();",
        "ins2PreCode":"MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected() .expectedEdgeCount(EDGE_COUNT) .build(); assertThat(undirectedGraph.addEdgeV2(N1, N2, E12)).isTrue(); assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12)); assertThat(undirectedGraph.edgesConnecting(N2, N1)).isEqualTo(ImmutableSet.of(E12));",
        "label":1
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.data, that.data)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.data, that.data)) {",
        "ins1PreCode":"if (this.xPosition != that.xPosition) { return false; } if (!ObjectUtils.equal(this.data, that.data)) { return false; }",
        "ins2PreCode":"if (this.xPosition != that.xPosition) { return false; } if (!ObjectUtils.equal(this.data, that.data)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"List<ModelObject> itemList = newRuns(1, 10);",
        "ins1DelCode":"List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10));",
        "ins1PreCode":"public void test_olderThan_leaving_part_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, 4L); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList); ",
        "ins2PreCode":"public void test_newerThan_lt_oldest() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, 0L, null); List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10)); historyPageFilter.add(itemList);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"escaped \\\\} bracket\"), entry.getField(StandardField.REVIEW));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"escaped \\\\} bracket\"), entry.getField(\"review\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\} bracket\"), entry.getField(\"review\")); assertFalse(result.hasWarnings());",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"author @ good\"), entry.getField(\"author\")); assertEquals(1, parsed.size());",
        "label":1
    },
    {
        "ins1AddCode":"seed = Objects.requireNonNull(seedSupplier.get(), \"The seedSupplier returned a null value\");",
        "ins1DelCode":"seed = ObjectHelper.requireNonNull(seedSupplier.get(), \"The seedSupplier returned a null value\");",
        "ins1PreCode":"R seed;  try { seed = ObjectHelper.requireNonNull(seedSupplier.get(), \"The seedSupplier returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"R seed; try { seed = ObjectHelper.requireNonNull(seedSupplier.get(), \"The seedSupplier returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"static DynamicMBean createMBean(ContextEnvironment environment) DynamicMBean mbean = managed.createMBean(environment);",
        "ins1DelCode":"static ModelMBean createMBean(ContextEnvironment environment) ModelMBean mbean = managed.createMBean(environment);",
        "ins1PreCode":"static ModelMBean createMBean(ContextEnvironment environment) throws Exception {  String mname = createManagedName(environment); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception(\"ManagedBean is not found with \"+mname); throw new MBeanException(e); } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ModelMBean mbean = managed.createMBean(environment); ObjectName oname = createObjectName(domain, environment); if( mserver.isRegistered( oname ))  {",
        "ins2PreCode":"static ModelMBean createMBean(Group group) throws Exception { String mname = createManagedName(group); ManagedBean managed = registry.findManagedBean(mname); if (managed == null) { Exception e = new Exception(\"ManagedBean is not found with \"+mname); throw new MBeanException(e); } String domain = managed.getDomain(); if (domain == null) domain = mserver.getDefaultDomain(); ModelMBean mbean = managed.createMBean(group); ObjectName oname = createObjectName(domain, group); if( mserver.isRegistered( oname ))  {",
        "label":1
    },
    {
        "ins1AddCode":"if (kind > 56) kind = 56; if (kind > 57) kind = 57; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; if (kind > 56) kind = 56; if (kind > 57) kind = 57; if (kind > 56) kind = 56; if (kind > 57) kind = 57; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; if (kind > 57) kind = 57; if (kind > 56) kind = 56; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 57) kind = 57; if (kind > 56) kind = 56; if (kind > 57) kind = 57;",
        "ins1DelCode":"if (kind > 55) kind = 55; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; if (kind > 55) kind = 55; if (kind > 55) kind = 55; if (kind > 56) kind = 56; if (kind > 55) kind = 55; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; if (kind > 55) kind = 55; if (kind > 56) kind = 56; if (kind > 55) kind = 55; if (kind > 55) kind = 55; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; if (kind > 56) kind = 56;",
        "ins1PreCode":"} else if ((0x1800000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 56) kind = 56; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break;",
        "ins2PreCode":"} else if ((0x1800000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); } else if (curChar == 39) jjCheckNAddStates(23, 25); else if (curChar == 34) jjCheckNAddStates(26, 28); else if (curChar == 46) jjCheckNAdd(1); break; case 30: if ((0x3ff001000000000L & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x3ff001000000000L & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 1: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(1, 2); break; case 3: if ((0x280000000000L & l) != 0L) jjCheckNAdd(4); break; case 4: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(4); break; case 5: if (curChar == 34) jjCheckNAddStates(26, 28); break; case 6: if ((0xfffffffbffffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 8: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(26, 28); break; case 9: if (curChar == 34 && kind > 13) kind = 13; break; case 10: if (curChar == 39) jjCheckNAddStates(23, 25); break; case 11: if ((0xffffff7fffffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 13: if ((0x8400000000L & l) != 0L) jjCheckNAddStates(23, 25); break; case 14: if (curChar == 39 && kind > 13) kind = 13; break; case 15: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAddStates(18, 22); break; case 16: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 10) kind = 10; jjCheckNAdd(16); break; case 17: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(17, 18); break; case 18: if (curChar != 46) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 19: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAddTwoStates(19, 20); break; case 21: if ((0x280000000000L & l) != 0L) jjCheckNAdd(22); break; case 22: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(22); break; case 23: if ((0x3ff000000000000L & l) != 0L) jjCheckNAddTwoStates(23, 24); break; case 25: if ((0x280000000000L & l) != 0L) jjCheckNAdd(26); break; case 26: if ((0x3ff000000000000L & l) == 0L) break; if (kind > 11) kind = 11; jjCheckNAdd(26); break; case 27: if ((0x1800000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 28: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x3ff001000000000L & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else if (curChar < 128) { long l = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 56) kind = 56; jjCheckNAdd(29); } if ((0x7fffffe87fffffeL & l) != 0L) { if (kind > 55) kind = 55; jjCheckNAdd(28); } break; case 2: if ((0x2000000020L & l) != 0L) jjAddStates(29, 30); break; case 6: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(26, 28); break; case 7: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 8; break; case 8: if (curChar == 92) jjCheckNAddStates(26, 28); break; case 11: if ((0xffffffffefffffffL & l) != 0L) jjCheckNAddStates(23, 25); break; case 12: if (curChar == 92) jjstateSet[jjnewStateCnt++] = 13; break; case 13: if (curChar == 92) jjCheckNAddStates(23, 25); break; case 20: if ((0x2000000020L & l) != 0L) jjAddStates(31, 32); break; case 24: if ((0x2000000020L & l) != 0L) jjAddStates(33, 34); break; case 28: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break; case 29: if ((0x7fffffe87fffffeL & l) == 0L) break; if (kind > 56) kind = 56; jjCheckNAdd(29); break; default : break; } } while(i != startsAt); } else { int hiByte = (int)(curChar >> 8); int i1 = hiByte >> 6; long l1 = 1L << (hiByte & 077); int i2 = (curChar & 0xff) >> 6; long l2 = 1L << (curChar & 077); do { switch(jjstateSet[--i]) { case 0: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAddTwoStates(28, 29); break; case 30: if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 55) kind = 55; jjCheckNAdd(28); } if (jjCanMove_1(hiByte, i1, i2, l1, l2)) { if (kind > 56) kind = 56; jjCheckNAdd(29); } break; case 6: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(26, 28); break; case 11: if (jjCanMove_0(hiByte, i1, i2, l1, l2)) jjAddStates(23, 25); break; case 28: if (!jjCanMove_1(hiByte, i1, i2, l1, l2)) break; if (kind > 55) kind = 55; jjCheckNAdd(28); break;",
        "label":1
    },
    {
        "ins1AddCode":"readBlocking = true; synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) { } if (readBlocking) { throw new SocketTimeoutException(); } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } readBlocking = false;",
        "ins1DelCode":"readBlock = new CountDownLatch(1); if (timeout > 0) { if (!readBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } else { readBlock.await(); } catch (InterruptedException e) { throw new EOFException(); readBlock = null; } nRead = socket.read(to); if (nRead == -1) { throw new EOFException();",
        "ins1PreCode":"if (block && nRead == 0) { long timeout = getReadTimeout(); try { readBlock = new CountDownLatch(1); registerReadInterest(); if (timeout > 0) { if (!readBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { readBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { readBlock = null; } nRead = socket.read(to);",
        "ins2PreCode":"if (block) { long timeout = getWriteTimeout(); try { writeBlock = new CountDownLatch(1); registerWriteInterest(); if (timeout > 0) { if (!writeBlock.await(timeout, TimeUnit.MILLISECONDS)) { throw new SocketTimeoutException(); } } else { writeBlock.await(); } } catch (InterruptedException e) { throw new EOFException(); } finally { writeBlock = null; } n = socket.write(from);",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1); observer.onComplete();",
        "ins2PreCode":"new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(1); subscriber.onComplete();",
        "label":0
    },
    {
        "ins1AddCode":".loadKeyMaterial(keyStore, \"password\".toCharArray(), new PrivateKeyStrategy() { @Override public String chooseAlias( Map<String, PrivateKeyDetails> aliases, Socket socket) { return \"spring-boot\"; } }) .build());",
        "ins1DelCode":".loadKeyMaterial(keyStore, \"password\".toCharArray()).build());",
        "ins1PreCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory) .build();",
        "ins2PreCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory) .build();",
        "label":0
    },
    {
        "ins1AddCode":"AuthorList firstAuthorList = AuthorList.of(new Author(\"A\", null, null, null, null)); AuthorList secondAuthorList = AuthorList.of(new Author(\"A\", null, null, null, null)); AuthorList thirdAuthorList = AuthorList.of(new Author(\"A\", null, null, null, null));",
        "ins1DelCode":"AuthorList firstAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); AuthorList secondAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); AuthorList thirdAuthorList = new AuthorList(new Author(\"A\", null, null, null, null));",
        "ins1PreCode":"public void equalsTrueTransitive() { AuthorList firstAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); AuthorList secondAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); AuthorList thirdAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); assertEquals(firstAuthorList, secondAuthorList); assertEquals(secondAuthorList, thirdAuthorList);",
        "ins2PreCode":"public void equalsTrueConsistent() { AuthorList firstAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); AuthorList secondAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); AuthorList firstAuthorList = new AuthorList(new Author(\"A\", null, null, null, null)); assertEquals(firstAuthorList, secondAuthorList); assertEquals(firstAuthorList, secondAuthorList);",
        "label":0
    },
    {
        "ins1AddCode":"return Objects.equals(appId, appExecId.appId);",
        "ins1DelCode":"return Objects.equal(appId, appExecId.appId);",
        "ins1PreCode":"if (o == null || getClass() != o.getClass()) return false;  AppId appExecId = (AppId) o; return Objects.equal(appId, appExecId.appId);",
        "ins2PreCode":"if (o == null || getClass() != o.getClass()) return false; AppExecId appExecId = (AppExecId) o; return Objects.equal(appId, appExecId.appId) && Objects.equal(execId, appExecId.execId);",
        "label":0
    },
    {
        "ins1AddCode":"RenameProcessor renameProcessor = factory.create(null, processorTag, null, config);",
        "ins1DelCode":"RenameProcessor renameProcessor = factory.create(null, processorTag, config);",
        "ins1PreCode":"config.put(\"field\", \"old_field\"); config.put(\"target_field\", \"new_field\"); String processorTag = randomAlphaOfLength(10); RenameProcessor renameProcessor = factory.create(null, processorTag, config); assertThat(renameProcessor.getTag(), equalTo(processorTag)); assertThat(renameProcessor.getField().newInstance(Collections.emptyMap()).execute(), equalTo(\"old_field\"));",
        "ins2PreCode":"config.put(\"field\", \"old_field\"); config.put(\"target_field\", \"new_field\"); String processorTag = randomAlphaOfLength(10); RenameProcessor renameProcessor = factory.create(null, processorTag, config); assertThat(renameProcessor.getTag(), equalTo(processorTag)); assertThat(renameProcessor.getField().newInstance(Collections.emptyMap()).execute(), equalTo(\"old_field\"));",
        "label":1
    },
    {
        "ins1AddCode":"this.datasets.put(index, dataset);",
        "ins1DelCode":"this.datasets.set(index, dataset);",
        "ins1PreCode":"if (existing != null) { existing.removeChangeListener(this); } this.datasets.set(index, dataset); if (dataset != null) { dataset.addChangeListener(this);",
        "ins2PreCode":"if (existing != null) { existing.removeChangeListener(this); } this.datasets.put(index, dataset); if (dataset != null) { dataset.addChangeListener(this);",
        "label":0
    },
    {
        "ins1AddCode":"sub.onSubscribe(Disposable.empty());",
        "ins1DelCode":"sub.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super Integer> sub) { sub.onSubscribe(Disposables.empty()); sub.onNext(1); sub.onNext(2);",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super Integer> sub) { sub.onSubscribe(new BooleanSubscription()); sub.onNext(1); sub.onNext(2);",
        "label":0
    },
    {
        "ins1AddCode":"String completePath; if (!\"\".equals(vpath)) { && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) {",
        "ins1DelCode":"String completePath = null; if (!vpath.equals(\"\")) { && !file.getName().equals(\".\") && !file.getName().equals(\"..\")) {",
        "ins1PreCode":"if (!ftp.changeWorkingDirectory(dir)) { return; } String completePath = null; if (!vpath.equals(\"\")) { completePath = rootPath + task.getSeparator() + vpath.replace(File.separatorChar, task.getSeparator().charAt(0)); } else { completePath = rootPath; } FTPFile[] newfiles = listFiles(completePath, false);  if (newfiles == null) { ftp.changeToParentDirectory(); return; } for (int i = 0; i < newfiles.length; i++) { FTPFile file = newfiles[i]; if (file != null && !file.getName().equals(\".\") && !file.getName().equals(\"..\")) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file));",
        "ins2PreCode":"if (!ftp.changeWorkingDirectory(dir)) { return; } String completePath = null; if (!vpath.equals(\"\")) { completePath = rootPath + remoteFileSep + vpath.replace(File.separatorChar, remoteFileSep.charAt(0)); } else { completePath = rootPath; } FTPFile[] newfiles = listFiles(completePath, false); if (newfiles == null) { ftp.changeToParentDirectory(); return; } for (int i = 0; i < newfiles.length; i++) { FTPFile file = newfiles[i]; if (file != null && !file.getName().equals(\".\") && !file.getName().equals(\"..\")) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file));",
        "label":0
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis();",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis();",
        "label":0
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa8_2(active0, 0x100000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa8_2(active0, 0x80000000000L);",
        "ins1PreCode":"switch(curChar) { case 101: return jjMoveStringLiteralDfa8_2(active0, 0x80000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 111: return jjMoveStringLiteralDfa9_2(active0, 0x80000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaBisectingKMeansExample\").getOrCreate(); List<Row> data = Arrays.asList( ); Dataset<Row> dataset = spark.createDataFrame(data, schema); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JavaBisectingKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); JavaRDD<Row> data = jsc.parallelize(Arrays.asList( )); Dataset<Row> dataset = jsql.createDataFrame(data, schema); jsc.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaBisectingKMeansExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   JavaRDD<Row> data = jsc.parallelize(Arrays.asList( RowFactory.create(Vectors.dense(0.1, 0.1, 0.1)), RowFactory.create(Vectors.dense(0.3, 0.3, 0.25)), RowFactory.create(Vectors.dense(0.1, 0.1, -0.1)), RowFactory.create(Vectors.dense(20.3, 20.1, 19.9)), RowFactory.create(Vectors.dense(20.2, 20.1, 19.7)), RowFactory.create(Vectors.dense(18.9, 20.0, 19.7)) ));  StructType schema = new StructType(new StructField[]{ new StructField(\"features\", new VectorUDT(), false, Metadata.empty()), });  Dataset<Row> dataset = jsql.createDataFrame(data, schema);  BisectingKMeans bkm = new BisectingKMeans().setK(2); BisectingKMeansModel model = bkm.fit(dataset);  System.out.println(\"Compute Cost: \" + model.computeCost(dataset));  Vector[] clusterCenters = model.clusterCenters(); for (int i = 0; i < clusterCenters.length; i++) { Vector clusterCenter = clusterCenters[i]; System.out.println(\"Cluster Center \" + i + \": \" + clusterCenter); }   jsc.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public void setPackagenames(String packages) { StringTokenizer tok = new StringTokenizer(packages, \",\");",
        "ins1DelCode":"public void setPackagenames(String src) { StringTokenizer tok = new StringTokenizer(src, \",\");",
        "ins1PreCode":"public void setPackagenames(String src) { StringTokenizer tok = new StringTokenizer(src, \",\"); while (tok.hasMoreTokens()) { String p = tok.nextToken();",
        "ins2PreCode":"public void setExcludePackageNames(String src) { StringTokenizer tok = new StringTokenizer(src, \",\"); while (tok.hasMoreTokens()) { String p = tok.nextToken();",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":".switchMap(Functions.justFunction(new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException()); observer.onComplete();",
        "ins2PreCode":".switchMap(Functions.justFunction(new Flowable<Integer>() { @Override protected void subscribeActual(Subscriber<? super Integer> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onError(new TestException()); subscriber.onComplete();",
        "label":0
    },
    {
        "ins1AddCode":".set(\"spark.memory.offHeap.size\", \"256mb\") .set(\"spark.shuffle.spill.compress\", \"false\") .set(\"spark.shuffle.compress\", \"false\"));",
        "ins1DelCode":".set(\"spark.memory.offHeap.size\", \"256mb\")); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins1PreCode":"new TestMemoryManager( new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0);  tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer( new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments();  return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "ins2PreCode":"new CompressStream(), new CompressStream(), File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); tempDir = Utils.createTempDir(System.getProperty(\"java.io.tmpdir\"), \"unsafe-test\"); spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer( new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments(); return new DiskBlockObjectWriter( (File) args[1], (SerializerInstance) args[2], (Integer) args[3], new CompressStream(), false, (ShuffleWriteMetrics) args[4], (BlockId) args[0] ); } }); when(blockManager.wrapForCompression(any(BlockId.class), any(InputStream.class))) .then(returnsSecondArg());",
        "label":0
    },
    {
        "ins1AddCode":"void transformationOfAnnotationOnConstructor() {",
        "ins1DelCode":"public void transformationOfAnnotationOnConstructor() {",
        "ins1PreCode":"public void transformationOfAnnotationOnConstructor() { ClassNode classNode = new ClassNode(\"Test\", 0, new ClassNode(Object.class)); this.moduleNode.addClass(classNode);",
        "ins2PreCode":"public void transformationOfAnnotationOnMethod() { ClassNode classNode = new ClassNode(\"Test\", 0, new ClassNode(Object.class)); this.moduleNode.addClass(classNode);",
        "label":1
    },
    {
        "ins1AddCode":"this.launcher = new PropertiesLauncher(); this.launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);",
        "ins1DelCode":"PropertiesLauncher launcher = new PropertiesLauncher(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add);",
        "ins1PreCode":"void testUserSpecifiedRootOfJarPathWithDotAndJarPrefix() throws Exception { System.setProperty(\"loader.path\", \"jar:file:./src/test/resources/nested-jars/app.jar!/./\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins2PreCode":"void testUserSpecifiedJarFileWithNestedArchives() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = new ArrayList<>(); launcher.getClassPathArchivesIterator().forEachRemaining(archives::add); assertThat(archives).areExactly(1, endingWith(\"foo.jar!/\"));",
        "label":1
    },
    {
        "ins1AddCode":"List<Archive> archives = CollectionUtils.iteratorToList(launcher.getClassPathArchivesIterator());",
        "ins1DelCode":"List<Archive> archives = launcher.getClassPathArchives();",
        "ins1PreCode":"void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.jar\", \"BOOT-INF\")); JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot, true)); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).hasSize(2); assertThat(getUrls(archives)).containsOnly(new File(explodedRoot, \"BOOT-INF/classes\").toURI().toURL(),",
        "ins2PreCode":"void explodedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.war\", \"WEB-INF\")); WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot, true)); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).hasSize(2); assertThat(getUrls(archives)).containsOnly(new File(explodedRoot, \"WEB-INF/classes\").toURI().toURL(),",
        "label":1
    },
    {
        "ins1AddCode":"jj_la1[37] = jj_gen; jj_la1[38] = jj_gen;",
        "ins1DelCode":"jj_la1[36] = jj_gen; jj_la1[37] = jj_gen;",
        "ins1PreCode":"; break; default: jj_la1[36] = jj_gen; break label_15; }",
        "ins2PreCode":"; break; default: jj_la1[41] = jj_gen; break label_16; }",
        "label":1
    },
    {
        "ins1AddCode":"List<ModelObject> runs = newRuns(1, 2); List<Queue.Item> queueItems = newQueueItems(3, 4); historyPageFilter.add(runs, queueItems);",
        "ins1DelCode":"List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 2)); itemList.addAll(newQueueItems(3, 4)); Assert.assertEquals(HistoryPageEntry.getEntryId(1), HistoryPageEntry.getEntryId(itemList.get(0))); historyPageFilter.add(itemList); Assert.assertEquals(4, HistoryPageEntry.getEntryId(itemList.get(0)));",
        "ins1PreCode":"public void test_latest_partial_page() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null); List<ModelObject> itemList = new ArrayList<ModelObject>();  itemList.addAll(newRuns(1, 2)); itemList.addAll(newQueueItems(3, 4));   Assert.assertEquals(HistoryPageEntry.getEntryId(1), HistoryPageEntry.getEntryId(itemList.get(0))); historyPageFilter.add(itemList); Assert.assertEquals(4, HistoryPageEntry.getEntryId(itemList.get(0)));  Assert.assertEquals(false, historyPageFilter.hasUpPage);",
        "ins2PreCode":"public void test_latest_longer_list() throws IOException { HistoryPageFilter<ModelObject> historyPageFilter = newPage(5, null, null); List<ModelObject> itemList = new ArrayList<ModelObject>(); itemList.addAll(newRuns(1, 10)); itemList.addAll(newQueueItems(11, 12)); Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.runs.get(0).getEntryId()); historyPageFilter.add(itemList); Assert.assertEquals(HistoryPageEntry.getEntryId(10), historyPageFilter.runs.get(0).getEntryId()); Assert.assertEquals(false, historyPageFilter.hasUpPage);",
        "label":0
    },
    {
        "ins1AddCode":"void exceptionsIncludeClassPackaging(CapturedOutput output) { assertThat(fileContents).contains(\"[junit-\"); assertThat(output).contains(\"[junit-\");",
        "ins1DelCode":"public void exceptionsIncludeClassPackaging() { Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins1PreCode":"public void exceptionsIncludeClassPackaging() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins2PreCode":"public void exceptionsIncludeClassPackaging() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = containsString(\"[junit-\"); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\")); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "label":1
    },
    {
        "ins1AddCode":"return f.concatMapDelayError(Functions.justFunction(Observable.just(2)), true, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"return f.concatMapDelayError(Functions.justFunction(Observable.just(2)), 2, true, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"TestHelper.checkDoubleOnSubscribeObservable(new Function<Observable<Object>, ObservableSource<Integer>>() { @Override public ObservableSource<Integer> apply(Observable<Object> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Observable.just(2)), 2, true, ImmediateThinScheduler.INSTANCE); } });",
        "ins2PreCode":"TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Object> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(2)), 2, true, ImmediateThinScheduler.INSTANCE); } });",
        "label":1
    },
    {
        "ins1AddCode":"thread.setContextClassLoader(processor.getUpgradeToken().getApplicationClassLoader());",
        "ins1DelCode":"thread.setContextClassLoader(applicationLoader);",
        "ins1PreCode":"Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(applicationLoader); listener.onError(t); } catch (Throwable t2) {",
        "ins2PreCode":"Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(applicationLoader); listener.onError(t); } catch (Throwable t2) {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"i = testEvent(MsgStringEncoder.class.getName()+\":init\", 0); i = testEvent(MsgStringDecoder.class.getName()+\":init\", i); i = testEvent(MsgByteEncoder.class.getName()+\":init\", i); i = testEvent(MsgByteDecoder.class.getName()+\":init\", i); i = testEvent(MsgStringEncoder.class.getName()+\":destroy\", i); i = testEvent(MsgStringDecoder.class.getName()+\":destroy\", i); i = testEvent(MsgByteEncoder.class.getName()+\":destroy\", i); i = testEvent(MsgByteDecoder.class.getName()+\":destroy\", i);",
        "ins1PreCode":"Assert.assertNull(server.t);   i = testEvent(MsgStringEncoder.class.getName()+\":init\", 0); i = testEvent(MsgStringDecoder.class.getName()+\":init\", i); i = testEvent(MsgByteEncoder.class.getName()+\":init\", i); i = testEvent(MsgByteDecoder.class.getName()+\":init\", i); i = testEvent(MsgStringEncoder.class.getName()+\":destroy\", i); i = testEvent(MsgStringDecoder.class.getName()+\":destroy\", i); i = testEvent(MsgByteEncoder.class.getName()+\":destroy\", i); i = testEvent(MsgByteDecoder.class.getName()+\":destroy\", i);",
        "ins2PreCode":"Assert.assertNull(server.t); i = testEvent(MsgStringEncoder.class.getName()+\":init\", 0); i = testEvent(MsgStringDecoder.class.getName()+\":init\", i); i = testEvent(MsgByteEncoder.class.getName()+\":init\", i); i = testEvent(MsgByteDecoder.class.getName()+\":init\", i); i = testEvent(MsgStringEncoder.class.getName()+\":destroy\", i); i = testEvent(MsgStringDecoder.class.getName()+\":destroy\", i); i = testEvent(MsgByteEncoder.class.getName()+\":destroy\", i); i = testEvent(MsgByteDecoder.class.getName()+\":destroy\", i);",
        "label":1
    },
    {
        "ins1AddCode":"JavaDoubleRDD rdd1 = uniformJavaRDD(jsc, m); JavaDoubleRDD rdd2 = uniformJavaRDD(jsc, m, p); JavaDoubleRDD rdd3 = uniformJavaRDD(jsc, m, p, seed); for (JavaDoubleRDD rdd : Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1DelCode":"JavaDoubleRDD rdd1 = uniformJavaRDD(sc, m); JavaDoubleRDD rdd2 = uniformJavaRDD(sc, m, p); JavaDoubleRDD rdd3 = uniformJavaRDD(sc, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) {",
        "ins1PreCode":"long m = 1000L; int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = uniformJavaRDD(sc, m); JavaDoubleRDD rdd2 = uniformJavaRDD(sc, m, p); JavaDoubleRDD rdd3 = uniformJavaRDD(sc, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); }",
        "ins2PreCode":"long m = 1000L; int p = 2; long seed = 1L; JavaDoubleRDD rdd1 = normalJavaRDD(sc, m); JavaDoubleRDD rdd2 = normalJavaRDD(sc, m, p); JavaDoubleRDD rdd3 = normalJavaRDD(sc, m, p, seed); for (JavaDoubleRDD rdd: Arrays.asList(rdd1, rdd2, rdd3)) { Assert.assertEquals(m, rdd.count()); }",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\nb}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\tb}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\"));",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(getFileUtils().isLeadingPath(new File(\"/foo\"), new File(\"/foo/bar\"), true)); assertTrue(getFileUtils().isLeadingPath(new File(\"/foo\"), new File(\"/foo/baz/../bar\"), true)); assertTrue(getFileUtils().isLeadingPath(new File(\"/foo\"), new File(\"/foo/../foo/bar\"), true)); assertFalse(getFileUtils().isLeadingPath(new File(\"/foo\"), new File(\"/foobar\"), true)); assertFalse(getFileUtils().isLeadingPath(new File(\"/foo\"), new File(\"/bar\"), true));",
        "ins1DelCode":"assertTrue(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foo/bar\"), true)); assertTrue(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foo/baz/../bar\"), true)); assertTrue(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foo/../foo/bar\"), true)); assertFalse(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foobar\"), true)); assertFalse(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/bar\"), true));",
        "ins1PreCode":"public void isLeadingPathCanonicalVersionWorksAsExpectedOnUnix() throws IOException { assumeFalse(\"Test doesn't run on DOS\", Os.isFamily(\"dos\")); assertTrue(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foo/bar\"), true)); assertTrue(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foo/baz/../bar\"), true)); assertTrue(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foo/../foo/bar\"), true)); assertFalse(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/foobar\"), true)); assertFalse(FILE_UTILS.isLeadingPath(new File(\"/foo\"), new File(\"/bar\"), true));",
        "ins2PreCode":"public void isLeadingPathCanonicalVersionWorksAsExpectedOnDos() throws IOException { assumeTrue(\"Test only runs on DOS\", Os.isFamily(\"dos\")); assertTrue(FILE_UTILS.isLeadingPath(new File(\"C:\\\\foo\"), new File(\"C:\\\\foo\\\\bar\"), true)); assertTrue(FILE_UTILS.isLeadingPath(new File(\"C:\\\\foo\"), new File(\"C:\\\\foo\\\\baz\\\\..\\\\bar\"), true)); assertTrue(FILE_UTILS.isLeadingPath(new File(\"C:\\\\foo\"), new File(\"C:\\\\foo\\\\..\\\\foo\\\\bar\"), true)); assertFalse(FILE_UTILS.isLeadingPath(new File(\"C:\\\\foo\"), new File(\"C:\\\\foobar\"), true)); assertFalse(FILE_UTILS.isLeadingPath(new File(\"C:\\\\foo\"), new File(\"C:\\\\bar\"), true));",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(this.output.toString()).contains( assertThat(this.output.toString()) .contains(\"Are you using 'uriVariables'?\");",
        "ins1DelCode":"assertThat(this.output).contains( assertThat(this.output).contains(\"Are you using 'uriVariables'?\");",
        "ins1PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.output).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output).contains(\"Are you using 'uriVariables'?\"); });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor));",
        "ins1DelCode":"Arrays.asList(firstContributor, secondContributor));",
        "ins1PreCode":"ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE); assertThatExceptionOfType(BindException.class).isThrownBy(() -> binder.bind(\"test\", String.class))",
        "ins2PreCode":"ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE); assertThatExceptionOfType(BindException.class).isThrownBy(() -> binder.bind(\"test\", String.class))",
        "label":1
    },
    {
        "ins1AddCode":"List<Tuple2<Integer, String>> out = new ArrayList<>();",
        "ins1DelCode":"List<Tuple2<Integer, String>> out = Lists.newArrayList();",
        "ins1PreCode":" JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<Integer, String> flatMapped = stream.flatMapToPair(s -> { List<Tuple2<Integer, String>> out = Lists.newArrayList(); for (String letter : s.split(\"(?!^)\")) { out.add(new Tuple2<>(s.length(), letter));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.y, that.y)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.y, that.y)) {",
        "ins1PreCode":"if (!this.x.equals(that.x)) { return false; } if (!ObjectUtils.equal(this.y, that.y)) { return false; }",
        "ins2PreCode":"if (!this.x.equals(that.x)) { return false; } if (!ObjectUtils.equal(this.obj, that.obj)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\");",
        "ins1DelCode":"Objects.requireNonNull(marker, \"marker\"); Objects.requireNonNull(layer, \"layer\");",
        "ins1PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { Objects.requireNonNull(marker, \"marker\"); Objects.requireNonNull(layer, \"layer\"); List<Marker> markers; if (layer == Layer.FOREGROUND) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"BindHandler handler = mock(BindHandler.class, Answers.CALLS_REAL_METHODS);",
        "ins1DelCode":"BindHandler handler = mock(BindHandler.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS));",
        "ins1PreCode":"public void bindToCollectionShouldTriggerOnSuccess() { this.sources.add(new MockConfigurationPropertySource(\"foo[0]\", \"1\", \"line1\")); BindHandler handler = mock(BindHandler.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); this.binder.bind(\"foo\", INTEGER_LIST, handler); InOrder inOrder = inOrder(handler);",
        "ins2PreCode":"public void bindToArrayShouldTriggerOnSuccess() { this.sources.add(new MockConfigurationPropertySource(\"foo[0]\", \"1\", \"line1\")); BindHandler handler = mock(BindHandler.class, withSettings().defaultAnswer(Answers.CALLS_REAL_METHODS)); this.binder.bind(\"foo\", target, handler); InOrder inOrder = inOrder(handler);",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 43; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 36; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult);",
        "ins1DelCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);",
        "ins1PreCode":"public void testDuplicateFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  assertEquals(expectedCrossingResult, crossingResult);",
        "ins2PreCode":"public void testUnknownKey() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); assertEquals(expectedCrossingResult, crossingResult);",
        "label":1
    },
    {
        "ins1AddCode":"blocks.put(\"shufflePush_0_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); blocks.put(\"shufflePush_0_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_0_1_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_0_2_0\"), any());",
        "ins1DelCode":"blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_2_0\"), any());",
        "ins1PreCode":"public void testServerFailures() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_1_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_2_0\"), any());",
        "ins2PreCode":"public void testHandlingRetriableFailures() { LinkedHashMap<String, ManagedBuffer> blocks = Maps.newLinkedHashMap(); blocks.put(\"shufflePush_0_0_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[12]))); blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]); BlockPushingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushFailure(eq(\"shufflePush_0_1_0\"), any());",
        "label":1
    },
    {
        "ins1AddCode":"StringBuilder buffer = new StringBuilder( 256 );",
        "ins1DelCode":"StringBuilder buffer = new StringBuilder();",
        "ins1PreCode":"public String extendedToString() { StringBuilder buffer = new StringBuilder();  buffer.append( \"\\nArtifact Metadata\\n--------------------------\" );",
        "ins2PreCode":"public String extendedToString() { StringBuilder buffer = new StringBuilder(); buffer.append( \"\\nRepository Metadata\\n--------------------------\" );",
        "label":1
    },
    {
        "ins1AddCode":"RRset rrset = new RRset();",
        "ins1DelCode":"RRset<TXTRecord> rrset = new RRset<>();",
        "ins1PreCode":"\"TXT 13 0 3600 19700101000003 19700101000000 25719 . m6sD/b0ZbfBXsQruhq5dYTnHGaA+PRTL5Y1W36rMdnGBb7eOJRRzDS5Wk5hZlrS4RUKQ/tKMCn7lsl9fn4U2lw==\", Name.root);  RRset<TXTRecord> rrset = new RRset<>(); rrset.addRR(txt); rrset.addRR(rrsig);",
        "ins2PreCode":"\"TXT 3 0 3600 19700101000003 19700101000000 36714 . AAAycZeIdBGB7vjlFzd5+ZgV8IxGRLpLierdV1KO4SGIy707hKUXJRc=\", Name.root); RRset<TXTRecord> set = new RRset<>(); set.addRR(txt); set.addRR(rrsig);",
        "label":1
    },
    {
        "ins1AddCode":"final List<Disposable> subscriptions = new ArrayList<>(); final List<Thread> threads = new ArrayList<>();",
        "ins1DelCode":"final List<Disposable> subscriptions = new ArrayList<Disposable>(); final List<Thread> threads = new ArrayList<Thread>();",
        "ins1PreCode":"public void concurrentSetDisposableShouldNotInterleave() throws InterruptedException { final int count = 10; final List<Disposable> subscriptions = new ArrayList<Disposable>();  final CountDownLatch start = new CountDownLatch(1); final CountDownLatch end = new CountDownLatch(count);  final List<Thread> threads = new ArrayList<Thread>(); for (int i = 0; i < count; i++) { final Disposable subscription = mock(Disposable.class);",
        "ins2PreCode":"public void concurrentSetDisposableShouldNotInterleave() throws InterruptedException { final int count = 10; final List<Disposable> subscriptions = new ArrayList<Disposable>(); final CountDownLatch start = new CountDownLatch(1); final CountDownLatch end = new CountDownLatch(count); final List<Thread> threads = new ArrayList<Thread>(); for (int i = 0; i < count; i++) { final Disposable subscription = mock(Disposable.class);",
        "label":1
    },
    {
        "ins1AddCode":"void getLoggingConfigurations() {",
        "ins1DelCode":"public void getLoggingConfigurations() {",
        "ins1PreCode":"public void getLoggingConfigurations() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null);",
        "ins2PreCode":"public void getLoggingConfigurations() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null);",
        "label":1
    },
    {
        "ins1AddCode":"Collection<CategoryMarker> markers;",
        "ins1DelCode":"Collection<Marker> markers;",
        "ins1PreCode":"boolean notify) { Args.nullNotPermitted(marker, \"marker\"); Args.nullNotPermitted(layer, \"layer\"); Collection<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundDomainMarkers.get(index);",
        "ins2PreCode":"boolean notify) { markers.add(marker); } else if (layer == Layer.BACKGROUND) { Collection<Marker> markers; if (layer == Layer.FOREGROUND) { markers = this.foregroundRangeMarkers.get(index);",
        "label":0
    },
    {
        "ins1AddCode":"if(this.getState().equals(LifecycleState.STARTED)) fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);",
        "ins1DelCode":"fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);",
        "ins1PreCode":"  postWelcomeFiles(); fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"stderr.println(node_s + \": \" + e.getMessage());",
        "ins1DelCode":"stderr.println(String.format(node_s + \": \" + e.getMessage()));",
        "ins1PreCode":"throw e; }  stderr.println(String.format(node_s + \": \" + e.getMessage())); errorOccurred = true; continue;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"target.setUrl( extrapolateChildUrl( src, context ) );",
        "ins1DelCode":"target.setUrl( appendPath( src, context ) );",
        "ins1PreCode":"} else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) ); }",
        "ins2PreCode":"} else if ( target.getUrl() == null ) { target.setUrl( appendPath( src, context ) ); target.setLocation( \"url\", source.getLocation( \"url\" ) ); }",
        "label":1
    },
    {
        "ins1AddCode":"assumeTrue(loginFailureMessage, loginSucceeded); assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1DelCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir));",
        "ins1PreCode":"public void test2ButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\"));",
        "ins2PreCode":"public void test2bisButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSucceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\"));",
        "label":1
    },
    {
        "ins1AddCode":"private int fillReadBuffer(boolean block, ByteBuffer buffer) throws IOException { int n = 0; if (block) { do { n = socket.read(buffer); if (n == -1) { throw new EOFException(); } if (n == 0) { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) { if (readBlocking) { readBlocking = false; throw new SocketTimeoutException(); } readBlocking = false; } while (n == 0); } else { n = socket.read(buffer); if (n == -1) { throw new EOFException(); return n;",
        "ins1DelCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } if (block && nRead == 0) { try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } catch (InterruptedException e) { } if (readBlocking) { throw new SocketTimeoutException(); nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; return nRead;",
        "ins1PreCode":"private int fillReadBuffer(boolean block, ByteBuffer to) throws IOException { int nRead; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } if (block && nRead == 0) { long timeout = getReadTimeout(); try { readBlocking = true; registerReadInterest(); synchronized (readLock) { if (readBlocking) { try { if (timeout > 0) { readLock.wait(timeout); } else { readLock.wait(); } } catch (InterruptedException e) {  } if (readBlocking) { throw new SocketTimeoutException(); } } } nRead = socket.read(to); if (nRead == -1) { throw new EOFException(); } } finally { readBlocking = false; } } return nRead;",
        "ins2PreCode":"protected void doWrite(boolean block, ByteBuffer from) throws IOException { int n = 0; NioChannel socket = getSocket(); if (socket instanceof ClosedNioChannel) { throw new ClosedChannelException(); } n = socket.write(from); if (n == -1) { throw new EOFException(); } if (block) { long timeout = getWriteTimeout(); try { writeBlocking = true; registerWriteInterest(); synchronized (writeLock) { if (writeBlocking) { try { if (timeout > 0) { writeLock.wait(timeout); } else { writeLock.wait(); } } catch (InterruptedException e) { } if (writeBlocking) { throw new SocketTimeoutException(); } } } n = socket.write(from); if (n == -1) { throw new EOFException(); } } finally { writeBlocking = false; } } registerWriteInterest();",
        "label":0
    },
    {
        "ins1AddCode":"this.chain = new TestFilterChain( (request, response, chain) -> response.sendError(400, \"BAD\"));",
        "ins1DelCode":"this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { ((HttpServletResponse) response).sendError(400, \"BAD\"); super.doFilter(request, response); } };",
        "ins1PreCode":"public void globalError() throws Exception { this.filter.addErrorPages(new ErrorPage(\"/error\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { ((HttpServletResponse) response).sendError(400, \"BAD\"); super.doFilter(request, response); } }; this.filter.doFilter(this.request, this.response, this.chain); assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus())",
        "ins2PreCode":"public void statusError() throws Exception { this.filter.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, \"/400\")); this.chain = new MockFilterChain() { @Override public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException { ((HttpServletResponse) response).sendError(400, \"BAD\"); super.doFilter(request, response); } }; this.filter.doFilter(this.request, this.response, this.chain); assertThat(((HttpServletResponseWrapper) this.chain.getResponse()).getStatus())",
        "label":1
    },
    {
        "ins1AddCode":"try (DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\")) {",
        "ins1DelCode":"DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { } finally { session.close();",
        "ins1PreCode":"throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Commit transaction\"); try { txnManager.commit(session); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } }",
        "ins2PreCode":"throws InvocationTargetException, InterruptedException { DBCTransactionManager txnManager = DBUtils.getTransactionManager(context); if (txnManager != null) { DBCSession session = context.openSession(monitor, DBCExecutionPurpose.UTIL, \"Rollback transaction\"); try { txnManager.rollback(session, null); } catch (DBCException e) { throw new InvocationTargetException(e); } finally { session.close(); } }",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":" }  to.onSubscribe(Disposables.empty());  to.assertSubscribed();",
        "ins2PreCode":"} to.onSubscribe(Disposables.empty()); to.assertSubscribed();",
        "label":1
    },
    {
        "ins1AddCode":"getTomcatInstance().getConnector().getProtocolHandlerClassName().contains(\"Nio2\"));",
        "ins1DelCode":"getTomcatInstance().getConnector().getProtocol() .equals(\"org.apache.coyote.http11.Http11Nio2Protocol\"));",
        "ins1PreCode":"public void testUpgradeInternal() throws Exception { Assume.assumeTrue( \"Only supported on NIO 2\", getTomcatInstance().getConnector().getProtocol() .equals(\"org.apache.coyote.http11.Http11Nio2Protocol\"));  UpgradeConnection uc = doUpgrade(EchoAsync.class);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(lines.get(2)).contains(\"refererOne (field \" + RefererTwo.class.getName()); assertThat(lines.get(4)).contains(\"refererTwo (field \" + BeanOne.class.getName());",
        "ins1DelCode":"assertThat(lines.get(2)).contains(\"refererOne \" + \"(field \" + RefererTwo.class.getName()); assertThat(lines.get(4)).contains(\"refererTwo \" + \"(field \" + BeanOne.class.getName());",
        "ins1PreCode":"assertThat(lines.get(0)) .isEqualTo(\"The dependencies of some of the beans in the application context form a cycle:\"); assertThat(lines.get(1)).isEqualTo(\"\"); assertThat(lines.get(2)).contains(\"refererOne \" + \"(field \" + RefererTwo.class.getName()); assertThat(lines.get(3)).isEqualTo(\"      \u2193\"); assertThat(lines.get(4)).contains(\"refererTwo \" + \"(field \" + BeanOne.class.getName()); assertThat(lines.get(5)).isEqualTo(\"\u250c\u2500\u2500\u2500\u2500\u2500\u2510\"); assertThat(lines.get(6))",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"@NonNull Publisher<@NonNull ? extends T> source1, @NonNull Publisher<@NonNull ? extends T> source2, @NonNull Publisher<@NonNull ? extends T> source3, @NonNull Publisher<@NonNull ? extends T> source4) {",
        "ins1DelCode":"@NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) {",
        "ins1PreCode":"public static <T> Flowable<T> merge( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> mergeDelayError( @NonNull Publisher<? extends T> source1, @NonNull Publisher<? extends T> source2, @NonNull Publisher<? extends T> source3, @NonNull Publisher<? extends T> source4) { Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\");",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor); Assert.assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy); Assert.assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr); Assert.assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "ins1DelCode":"assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor); assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "ins1PreCode":"  String actualXForwardedFor = actualRequest.getHeader(\"x-forwarded-for\"); assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor);  String actualXForwardedBy = actualRequest.getHeader(\"x-forwarded-by\"); assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy);  String actualRemoteAddr = actualRequest.getRemoteAddr(); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);  String actualRemoteHost = actualRequest.getRemoteHost(); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "ins2PreCode":"String actualXForwardedFor = actualRequest.getHeader(\"x-forwarded-for\"); assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor); String actualXForwardedBy = actualRequest.getHeader(\"x-forwarded-by\"); assertEquals(\"all proxies are trusted, they must appear in x-forwarded-by\", \"proxy1, proxy2\", actualXForwardedBy); String actualRemoteAddr = actualRequest.getRemoteAddr(); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr); String actualRemoteHost = actualRequest.getRemoteHost(); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "label":1
    },
    {
        "ins1AddCode":"List<String> columnNames = Arrays.asList(\"entrytype\", \"author/editor\", \"title\", \"year\", \"journal/booktitle\", \"citationkey\", \"printed\");",
        "ins1DelCode":"List<String> columnNames = Arrays.asList(\"entrytype\", \"author/editor\", \"title\", \"year\", \"journal/booktitle\", \"bibtexkey\", \"printed\");",
        "ins1PreCode":"void testChangeColumnPreferencesVariableNamesFor51() { List<String> columnNames = Arrays.asList(\"entrytype\", \"author/editor\", \"title\", \"year\", \"journal/booktitle\", \"bibtexkey\", \"printed\"); List<String> columnWidths = Arrays.asList(\"75\", \"300\", \"470\", \"60\", \"130\", \"100\", \"30\"); ",
        "ins2PreCode":"void testChangeColumnPreferencesVariableNamesBackwardsCompatibility() { List<String> columnNames = Arrays.asList(\"entrytype\", \"author/editor\", \"title\", \"year\", \"journal/booktitle\", \"bibtexkey\", \"printed\"); List<String> columnWidths = Arrays.asList(\"75\", \"300\", \"470\", \"60\", \"130\", \"100\", \"30\");",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (renderer instanceof BarRenderer3D) { BarRenderer3D br3d = (BarRenderer3D) renderer; br3d.setWallPaint(this.wallPaint); } if (renderer instanceof LineRenderer3D) { LineRenderer3D lr3d = (LineRenderer3D) renderer; lr3d.setWallPaint(this.wallPaint); }",
        "ins1PreCode":"}   if (renderer instanceof BarRenderer3D) { BarRenderer3D br3d = (BarRenderer3D) renderer; br3d.setWallPaint(this.wallPaint); }   if (renderer instanceof LineRenderer3D) { LineRenderer3D lr3d = (LineRenderer3D) renderer; lr3d.setWallPaint(this.wallPaint); } ",
        "ins2PreCode":"} if (renderer instanceof XYBarRenderer) { XYBarRenderer br = (XYBarRenderer) renderer; br.setBarPainter(this.xyBarPainter); } if (renderer instanceof XYBarRenderer) { XYBarRenderer br = (XYBarRenderer) renderer; br.setBarPainter(this.xyBarPainter); }",
        "label":0
    },
    {
        "ins1AddCode":"CombinedDomainCategoryPlot plot2 = CloneUtils.clone(plot1);",
        "ins1DelCode":"CombinedDomainCategoryPlot plot2 = (CombinedDomainCategoryPlot) plot1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedDomainCategoryPlot plot1 = createPlot(); CombinedDomainCategoryPlot plot2 = (CombinedDomainCategoryPlot) plot1.clone(); assertTrue(plot1 != plot2); assertTrue(plot1.getClass() == plot2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CombinedRangeCategoryPlot plot1 = createPlot(); CombinedRangeCategoryPlot plot2 = (CombinedRangeCategoryPlot) plot1.clone(); assertTrue(plot1 != plot2); assertTrue(plot1.getClass() == plot2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"List<JavaDStream<?>> listOfDStreams1 = Arrays.asList(stream1, stream2); (listOfRDDs, time) -> { Assert.assertEquals(2, listOfRDDs.size()); return null; Arrays.asList(stream1, stream2, pairStream1.toJavaDStream()); (listOfRDDs, time) -> { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = (PairFunction<Integer, Integer, Integer>) i -> new Tuple2<>(i, i); return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3);",
        "ins1DelCode":"List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2); new Function2<List<JavaRDD<?>>, Time, JavaRDD<Long>>() { @Override public JavaRDD<Long> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(2, listOfRDDs.size()); return null; } Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream()); new Function2<List<JavaRDD<?>>, Time, JavaPairRDD<Integer, Tuple2<Integer, String>>>() { @Override public JavaPairRDD<Integer, Tuple2<Integer, String>> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer i) { return new Tuple2<>(i, i); } }; return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3); }",
        "ins1PreCode":"JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream( JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1));  List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2);   ssc.transform( listOfDStreams1, new Function2<List<JavaRDD<?>>, Time, JavaRDD<Long>>() { @Override public JavaRDD<Long> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(2, listOfRDDs.size()); return null; } } );  List<JavaDStream<?>> listOfDStreams2 = Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream());  JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair( listOfDStreams2, new Function2<List<JavaRDD<?>>, Time, JavaPairRDD<Integer, Tuple2<Integer, String>>>() { @Override public JavaPairRDD<Integer, Tuple2<Integer, String>> call(List<JavaRDD<?>> listOfRDDs, Time time) { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>)listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>)listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>)listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer i) { return new Tuple2<>(i, i); } }; return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3); }",
        "ins2PreCode":"JavaPairDStream<Integer, String> pairStream1 = JavaPairDStream.fromJavaDStream( JavaTestUtils.attachTestInputStream(ssc, pairStream1input, 1)); List<JavaDStream<?>> listOfDStreams1 = Arrays.<JavaDStream<?>>asList(stream1, stream2); JavaDStream<Long> transformed1 = ssc.transform( List<JavaDStream<?>> listOfDStreams2 = listOfDStreams2, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Arrays.asList(2) listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Assert.assertEquals(2, listOfRDDs.size()); return null; } } ); List<JavaDStream<?>> listOfDStreams2 = Arrays.<JavaDStream<?>>asList(stream1, stream2, pairStream1.toJavaDStream()); JavaPairDStream<Integer, Tuple2<Integer, String>> transformed2 = ssc.transformToPair( List<JavaDStream<?>> listOfDStreams2 = List<List<Tuple2<Integer, Tuple2<Integer, String>>>> result = Arrays.asList(2) JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2); listOfDStreams1, (List<JavaRDD<?>> listOfRDDs, Time time) -> { Assert.assertEquals(3, listOfRDDs.size()); JavaRDD<Integer> rdd1 = (JavaRDD<Integer>) listOfRDDs.get(0); JavaRDD<Integer> rdd2 = (JavaRDD<Integer>) listOfRDDs.get(1); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2); JavaRDD<Tuple2<Integer, String>> rdd3 = (JavaRDD<Tuple2<Integer, String>>) listOfRDDs.get(2); JavaPairRDD<Integer, String> prdd3 = JavaPairRDD.fromJavaRDD(rdd3); PairFunction<Integer, Integer, Integer> mapToTuple = PairFunction<Integer, Integer, Integer> mapToTuple = Arrays.asList(2) PairFunction<Integer, Integer, Integer> mapToTuple = (Integer i) -> new Tuple2<>(i, i); } }); return rdd1.union(rdd2).mapToPair(mapToTuple).join(prdd3); }",
        "label":0
    },
    {
        "ins1AddCode":"String script = \"addWithState(4, 5, test, 0.0)\";",
        "ins1DelCode":"String script = \"testAddWithState(4, 5, test, 0.0)\";",
        "ins1PreCode":"public void testRepeatedClassBinding() { String script = \"testAddWithState(4, 5, test, 0.0)\"; BindingsTestScript.Factory factory = scriptEngine.compile(null, script, BindingsTestScript.CONTEXT, Collections.emptyMap()); BindingsTestScript executableScript = factory.newInstance();",
        "ins2PreCode":"public void testBoundClassBinding() { String script = \"testAddWithState(4, bound, test, 0.0)\"; BindingsTestScript.Factory factory = scriptEngine.compile(null, script, BindingsTestScript.CONTEXT, Collections.emptyMap()); BindingsTestScript executableScript = factory.newInstance();",
        "label":1
    },
    {
        "ins1AddCode":"Args.requireNonNegative(index, \"index\");",
        "ins1DelCode":"ParamChecks.requireNonNegative(index, \"index\");",
        "ins1PreCode":"public CategoryAxis getDomainAxisForDataset(int index) { ParamChecks.requireNonNegative(index, \"index\"); CategoryAxis axis; List axisIndices = (List) this.datasetToDomainAxesMap.get(",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"entry.setField(StandardField.AUTHOR, \"BlaBla\"); \"  note    = {some note},\" + OS.NEWLINE +",
        "ins1DelCode":"entry.setField(\"author\", \"BlaBla\"); \"  note    = {some note},\" + OS.NEWLINE +",
        "ins1PreCode":"BibEntry entry = entries.iterator().next();   entry.setField(\"author\", \"BlaBla\");  ",
        "ins2PreCode":"BibEntry entry = entries.iterator().next(); entry.setField(\"author\", \"BlaBla\");",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> error = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> error = new AtomicReference<Throwable>();",
        "ins1PreCode":" final AtomicInteger groupCounter = new AtomicInteger(); final AtomicInteger eventCounter = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>();  grouped.flatMap(new Function<GroupedFlowable<Integer, String>, Flowable<String>>() {",
        "ins2PreCode":"final AtomicInteger groupCounter = new AtomicInteger(); final AtomicInteger eventCounter = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); grouped.flatMap(new Function<GroupedObservable<Integer, String>, Observable<String>>() {",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"PublishSubject<Integer> source = PublishSubject.create(); PublishSubject<Integer> until = PublishSubject.create();  TestObserverEx<Integer> to = new TestObserverEx<Integer>();  source.takeUntil(until).subscribe(to);",
        "ins2PreCode":"PublishSubject<Integer> source = PublishSubject.create(); PublishSubject<Integer> until = PublishSubject.create(); TestObserverEx<Integer> to = new TestObserverEx<Integer>(); source.takeUntil(until).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"= new DefaultStatisticalCategoryDataset<>(); dataset.add(1.0, 2.0, \"S1\", \"C1\"); dataset.add(3.0, 4.0, \"S1\", \"C2\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new StatisticalBarRenderer());",
        "ins2PreCode":"= new DefaultStatisticalCategoryDataset<>(); dataset.add(1.0, 2.0, \"S1\", \"C1\"); dataset.add(3.0, 4.0, \"S1\", \"C2\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new StatisticalLineAndShapeRenderer());",
        "label":1
    },
    {
        "ins1AddCode":"Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList(",
        "ins1DelCode":"scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList(",
        "ins1PreCode":"int iterations = 15; int users = 100; int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, false); ",
        "ins2PreCode":"int iterations = 15; int users = 80; int products = 160; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, true, true);",
        "label":0
    },
    {
        "ins1AddCode":"Set<Class<?>> expected = new HashSet<>(controlClasses.loadClasses()); expected.remove(GrobidCitationFetcher.class);",
        "ins1DelCode":"Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());",
        "ins1PreCode":"Set<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences); try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(SearchBasedFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet());  expected.remove(SearchBasedParserFetcher.class);",
        "ins2PreCode":"Set<FulltextFetcher> fullTextFetchers = WebFetchers.getFullTextFetchers(importFormatPreferences); try (ScanResult scanResult = classGraph.scan()) { ClassInfoList controlClasses = scanResult.getClassesImplementing(FulltextFetcher.class.getCanonicalName()); Set<Class<?>> expected = controlClasses.loadClasses().stream().collect(Collectors.toSet()); assertEquals(expected, getClasses(fullTextFetchers));",
        "label":0
    },
    {
        "ins1AddCode":"null, data + 4L * rowId, count * 4L); long offset = data + 4L * rowId;",
        "ins1DelCode":"null, data + 4 * rowId, count * 4); long offset = data + 4 * rowId;",
        "ins1PreCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 4 * rowId, count * 4); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 4 * rowId; for (int i = 0; i < count; ++i, offset += 4, srcOffset += 4) { Platform.putInt(null, offset,",
        "ins2PreCode":"public void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { if (!bigEndianPlatform) { Platform.copyMemory(src, srcIndex + Platform.BYTE_ARRAY_OFFSET, null, data + 8 * rowId, count * 8); } else { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; long offset = data + 8 * rowId; for (int i = 0; i < count; ++i, offset += 8, srcOffset += 8) { Platform.putLong(null, offset,",
        "label":1
    },
    {
        "ins1AddCode":"pp.publish(Functions.identity()).subscribe(ts);",
        "ins1DelCode":"pp.publish(new Function<Flowable<Integer>, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Flowable<Integer> f) { return f; } }).subscribe(ts);",
        "ins1PreCode":" PublishProcessor<Integer> pp = PublishProcessor.create();  pp.publish(new Function<Flowable<Integer>, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Flowable<Integer> f) { return f; } }).subscribe(ts);  for (int i = 0; i < Flowable.bufferSize() * 2; i++) {",
        "ins2PreCode":"PublishProcessor<Integer> pp = PublishProcessor.create(); new FlowablePublishMulticast<>(pp, new Function<Flowable<Integer>, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Flowable<Integer> f) { return f; } }, Flowable.bufferSize(), true).subscribe(ts); for (int i = 0; i < Flowable.bufferSize() * 2; i++) {",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<String> value1 = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<String> value1 = new AtomicReference<String>();",
        "ins1PreCode":"public void subscribeCompletionRaceCondition() { for (int i = 0; i < 50; i++) { final ReplaySubject<String> subject = ReplaySubject.createUnbounded(); final AtomicReference<String> value1 = new AtomicReference<String>();  subject.subscribe(new Consumer<String>() {",
        "ins2PreCode":"public void subscribeCompletionRaceCondition() { for (int i = 0; i < 50; i++) { final AtomicReference<String> value1 = new AtomicReference<String>(); final AtomicReference<String> value1 = new AtomicReference<String>(); processor.subscribe(new Consumer<String>() {",
        "label":1
    },
    {
        "ins1AddCode":"TesterUtil.addRandomDomain(channels);",
        "ins1DelCode":"",
        "ins1PreCode":"channels[i].addChannelListener(listeners[i]); channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ); }",
        "ins2PreCode":"channels[i].addMembershipListener(listeners[i]); channels[i] = new GroupChannel(); }",
        "label":0
    },
    {
        "ins1AddCode":"void entriesAreParsedHeader() throws IOException {",
        "ins1DelCode":"public void entriesAreParsedHeader() throws IOException {",
        "ins1PreCode":"public void entriesAreParsedHeader() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeader, importFormatPreferences, fileMonitor); BibDatabase db = result.getDatabase();",
        "ins2PreCode":"public void entriesAreParsedHeaderAndSignature() throws IOException { ParserResult result = OpenDatabase.loadDatabase(bibHeaderAndSignature, importFormatPreferences, fileMonitor); BibDatabase db = result.getDatabase();",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"resource\") @SuppressWarnings(\"resource\") for (int i = 0; i < read; ++i) {",
        "ins1DelCode":"int index = 0; for (int i = 0; i < read; ++i, ++index) {",
        "ins1PreCode":" FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { return false;",
        "ins2PreCode":"FileInputStream fis1 = new FileInputStream(file1); FileInputStream fis2 = new FileInputStream(file2); int index = 0; int read = 0; while ((read = fis1.read(buffer1)) != -1) { fis2.read(buffer2); for (int i = 0; i < read; ++i, ++index) { if (buffer1[i] != buffer2[i]) { return false;",
        "label":1
    },
    {
        "ins1AddCode":"List<DB2Parameter> listDBParameters = new ArrayList<>();",
        "ins1DelCode":"List<DB2Parameter> listDBParameters = new ArrayList<DB2Parameter>();",
        "ins1PreCode":"{ LOG.debug(\"readDBCfg\");  List<DB2Parameter> listDBParameters = new ArrayList<DB2Parameter>(); JDBCPreparedStatement dbStat = session.prepareStatement(SEL_DBCFG); try {",
        "ins2PreCode":"{ LOG.debug(\"readDBMCfg\"); List<DB2Parameter> listDBMParameters = new ArrayList<DB2Parameter>(); JDBCPreparedStatement dbStat = session.prepareStatement(SEL_DBMCFG); try {",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyMapXml() { SqlSession sqlSession = sqlSessionFactory.openSession();  try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2WithSelectKeyWithKeyMapXml(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"barney_fred\", name.getGeneratedName());  name.setName(\"Wilma\"); rows = mapper.updateTable2WithSelectKeyWithKeyMapXml(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"Wilma_fred\", name.getGeneratedName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testAnnotatedUpdateTable2WithSelectKeyWithKeyObjectXml() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Name name = new Name(); name.setName(\"barney\"); AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); int rows = mapper.insertTable2WithSelectKeyWithKeyObjectXml(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"barney_fred\", name.getGeneratedName()); name.setName(\"Wilma\"); rows = mapper.updateTable2WithSelectKeyWithKeyObjectXml(name); assertEquals(1, rows); assertEquals(22, name.getNameId()); assertEquals(\"Wilma_fred\", name.getGeneratedName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"JenkinsRule.WebClient wc = j.createWebClient() .withThrowExceptionOnFailingStatusCode(false); assertEquals(HttpURLConnection.HTTP_NOT_FOUND, p.getWebResponse().getStatusCode());",
        "ins1DelCode":"JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); assertEquals(p.getWebResponse().getStatusCode(), 404);",
        "ins1PreCode":"} j.createWebClient().goTo(\"plugin/credentials/images/24x24/credentials.png\", \"image/png\");  JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); WebRequest request = new WebRequest(new URL(j.getURL() + \"plugin/credentials/.xml\"));    request.setAdditionalHeader(\"Accept-Language\", \"../../../../jenkinsTests.tmp/\" + j.jenkins.getRootDir().getName() + \"/config\");  Page p = wc.getPage(request); assertEquals(p.getWebResponse().getStatusCode(), 404); assertNotEquals(p.getWebResponse().getContentType(), \"application/xml\");",
        "ins2PreCode":"} j.createWebClient().goTo(\"plugin/credentials/images/24x24/credentials.png\", \"image/png\"); JenkinsRule.WebClient wc = j.createWebClient(); wc.getOptions().setThrowExceptionOnFailingStatusCode(false); WebRequest request = new WebRequest(new URL(j.getURL() + \"plugin/credentials/.ini\")); request.setAdditionalHeader(\"Accept-Language\", \"../../../../../../../../../../../../windows/win\"); Page p = wc.getPage(request); assertEquals(p.getWebResponse().getStatusCode(), 404); assertEquals(p.getWebResponse().getContentType(), \"text/html\");",
        "label":1
    },
    {
        "ins1AddCode":"if (grant.getGrantee().equals(this.getName()))",
        "ins1DelCode":"if (grant.getName().equals(this.getName()))",
        "ins1PreCode":" for(ExasolTableGrant grant: this.dataSource.getTableGrants(monitor)) { if (grant.getName().equals(this.getName())) { grants.add(grant);",
        "ins2PreCode":"for(ExasolViewGrant grant: this.dataSource.getViewGrants(monitor)) { if (grant.getName().equals(this.getName())) { grants.add(grant);",
        "label":1
    },
    {
        "ins1AddCode":"assertTrue(range.getLowerBound() <= -30, \"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound()); assertTrue(range.getUpperBound() >= 30, \"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound()); range.getLowerBound(), range.getLowerBound() <= -30); range.getUpperBound(), range.getUpperBound() >= 30);",
        "ins1DelCode":"assertTrue(\"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound(), range.getLowerBound() <= -30); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30);",
        "ins1PreCode":"assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound(), range.getLowerBound() <= -30); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "ins2PreCode":"assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound(), range.getLowerBound() <= -30); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30);",
        "label":1
    },
    {
        "ins1AddCode":"chooser.setDialogTitle(Translator.localize(\"action.deploy-profile\")); chooser.setApproveButtonText(Translator.localize(\"filechooser.export\")); ProjectBrowser.getInstance().trySaveWithProgressMonitor(true, theFile, false);",
        "ins1DelCode":"chooser.setDialogTitle(\"Save Profile\"); chooser.setApproveButtonText(\"Save\"); ProjectBrowser.getInstance().trySaveWithProgressMonitor( true, theFile, false);",
        "ins1PreCode":"PersistenceManager pm = PersistenceManager.getInstance();  JFileChooser chooser = new JFileChooser(); chooser.setDialogTitle(\"Save Profile\"); chooser.setFileView(ProjectFileView.getInstance()); chooser.setApproveButtonText(\"Save\"); chooser.setAcceptAllFileFilterUsed(true); pm.setXmiFileChooserFilter(chooser); if (fn.length() > 0) { fn = PersistenceManager.getInstance().getBaseName(fn); chooser.setSelectedFile(new File(fn)); } int result = chooser.showSaveDialog(ArgoFrame.getFrame()); if (result == JFileChooser.APPROVE_OPTION) { theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name); ProjectBrowser.getInstance().trySaveWithProgressMonitor( true, theFile, false); } }",
        "ins2PreCode":"PersistenceManager pm = PersistenceManager.getInstance(); JFileChooser chooser = new JFileChooser(); chooser.setDialogTitle(Translator.localize( chooser.setFileView(ProjectFileView.getInstance()); chooser.setApproveButtonText(Translator.localize( chooser.setAcceptAllFileFilterUsed(true); pm.setXmiFileChooserFilter(chooser); if (fn.length() > 0) { fn = PersistenceManager.getInstance().getBaseName(fn); chooser.setSelectedFile(new File(fn)); } int result = chooser.showSaveDialog(ArgoFrame.getFrame()); if (result == JFileChooser.APPROVE_OPTION) { File theFile = chooser.getSelectedFile(); if (theFile != null) { String name = theFile.getName(); name = pm.fixXmiExtension(name); theFile = new File(theFile.getParent(), name); ProjectBrowser.getInstance().trySaveWithProgressMonitor( false, theFile, false); } }",
        "label":0
    },
    {
        "ins1AddCode":"public void liveReloadDisabled() {",
        "ins1DelCode":"public void liveReloadDisabled() throws Exception {",
        "ins1PreCode":"public void liveReloadDisabled() throws Exception { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.livereload.enabled\", false);",
        "ins2PreCode":"public void restartDisabled() throws Exception { Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.restart.enabled\", false);",
        "label":1
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa6_1(active0, 0x80000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa6_1(active0, 0x40000000000L);",
        "ins1PreCode":"switch(curChar) { case 110: return jjMoveStringLiteralDfa6_1(active0, 0x40000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 99: return jjMoveStringLiteralDfa7_1(active0, 0x40000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"try (Reader configReader = Resources.getResourceAsReader(resource)) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), return sqlSessionFactory; }",
        "ins1DelCode":"Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close(); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), return sqlSessionFactory;",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryXmlConfig(String resource) throws Exception { Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close();  BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(),",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryXmlConfig(String resource) throws Exception { Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close(); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(),",
        "label":1
    },
    {
        "ins1AddCode":"void getPageWhenUrlIsRelativeAndNoPortWillUseLocalhost8080() throws Exception {",
        "ins1DelCode":"public void getPageWhenUrlIsRelativeAndNoPortWillUseLocalhost8080() throws Exception {",
        "ins1PreCode":"public void getPageWhenUrlIsRelativeAndNoPortWillUseLocalhost8080() throws Exception { MockEnvironment environment = new MockEnvironment(); WebClient client = new LocalHostWebClient(environment);",
        "ins2PreCode":"public void getPageWhenUrlIsRelativeAndHasPortWillUseLocalhostPort() throws Exception { MockEnvironment environment = new MockEnvironment(); WebClient client = new LocalHostWebClient(environment);",
        "label":1
    },
    {
        "ins1AddCode":"static String add_escapes(String str) {",
        "ins1DelCode":"protected String add_escapes(String str) {",
        "ins1PreCode":"protected String add_escapes(String str) { StringBuilder retval = new StringBuilder(); char ch;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void validateTokenWhenExpiredShouldThrowException() throws Exception {",
        "ins1DelCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception {",
        "ins1PreCode":"public void validateTokenWhenExpiredShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\"));",
        "ins2PreCode":"public void validateTokenWhenAudienceIsNotValidShouldThrowException() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(Mono.just(VALID_KEYS)); given(this.securityService.getUaaUrl()).willReturn(Mono.just(\"http://localhost:8080/uaa\"));",
        "label":1
    },
    {
        "ins1AddCode":"LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) { long baseOffset = array.getBaseOffset() + startIndex * 8L; long limit = baseOffset + numRecords * 16L; for (long offset = baseOffset; offset < limit; offset += 16) { for (long offset = baseOffset; offset < limit; offset += 16) {",
        "ins1DelCode":"LongArray array, int numRecords, int startByteIndex, int endByteIndex) { long limit = array.getBaseOffset() + numRecords * 16; for (long offset = array.getBaseOffset(); offset < limit; offset += 16) { for (long offset = array.getBaseOffset(); offset < limit; offset += 16) {",
        "ins1PreCode":"private static long[][] getKeyPrefixArrayCounts( LongArray array, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][]; long bitwiseMax = 0; long bitwiseMin = -1L; long limit = array.getBaseOffset() + numRecords * 16; Object baseObject = array.getBaseObject(); for (long offset = array.getBaseOffset(); offset < limit; offset += 16) { long value = Platform.getLong(baseObject, offset + 8); bitwiseMax |= value; bitwiseMin &= value; } long bitsChanged = bitwiseMin ^ bitwiseMax; for (int i = startByteIndex; i <= endByteIndex; i++) { if (((bitsChanged >>> (i * 8)) & 0xff) != 0) { counts[i] = new long[256]; for (long offset = array.getBaseOffset(); offset < limit; offset += 16) { counts[i][(int)((Platform.getLong(baseObject, offset + 8) >>> (i * 8)) & 0xff)]++; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 50; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<List<String>> rdd = jsc.parallelize(Arrays.asList( for (FPGrowth.FreqItemset<String> itemset : freqItemsets) {",
        "ins1DelCode":"JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {",
        "ins1PreCode":"public void runFPGrowth() {  @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  List<FPGrowth.FreqItemset<String>> freqItemsets = model.freqItemsets().toJavaRDD().collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {  List<String> items = itemset.javaItems();",
        "ins2PreCode":"public void runFPGrowthSaveLoad() { @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2); FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD() assertEquals(18, freqItemsets.size()); for (FPGrowth.FreqItemset<String> itemset: freqItemsets) { List<String> items = itemset.javaItems();",
        "label":0
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\") WeakReference<Object> weakReference = (WeakReference<Object>) delegate.getObject(key);",
        "ins1DelCode":"WeakReference weakReference = (WeakReference) delegate.getObject(key);",
        "ins1PreCode":"public Object getObject(Object key) { Object result = null; WeakReference weakReference = (WeakReference) delegate.getObject(key); if (weakReference != null) { result = weakReference.get();",
        "ins2PreCode":"public Object getObject(Object key) { Object result = null; SoftReference softReference = (SoftReference) delegate.getObject(key); if (softReference != null) { result = softReference.get();",
        "label":1
    },
    {
        "ins1AddCode":"privateKey = privateKey.replace(\"\\n\", \"\"); byte[] pkcs8EncodedBytes = Base64Utils.decodeFromString(privateKey);",
        "ins1DelCode":"byte[] pkcs8EncodedBytes = Base64.decodeBase64(privateKey);",
        "ins1PreCode":"+ \"J/OOn5zOs8yf26os0q3+JUM=\\n-----END PRIVATE KEY-----\"; String privateKey = signingKey.replace(\"-----BEGIN PRIVATE KEY-----\\n\", \"\"); privateKey = privateKey.replace(\"-----END PRIVATE KEY-----\", \"\"); byte[] pkcs8EncodedBytes = Base64.decodeBase64(privateKey); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes); KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");",
        "ins2PreCode":"+ \"J/OOn5zOs8yf26os0q3+JUM=\\n-----END PRIVATE KEY-----\"; String privateKey = signingKey.replace(\"-----BEGIN PRIVATE KEY-----\\n\", \"\"); privateKey = privateKey.replace(\"-----END PRIVATE KEY-----\", \"\"); byte[] pkcs8EncodedBytes = Base64.decodeBase64(privateKey); PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(pkcs8EncodedBytes); KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);",
        "ins1PreCode":"public void drainMaxLoopDontAccept() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription());  QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public long requested() { return 1; }  @Override public long produced(long n) { return 0; }  @Override public int leave(int m) { return 0; }  @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1); ",
        "ins2PreCode":"public void checkTerminatedDelayErrorEmpty() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(new BooleanSubscription()); QueueDrain<Integer, Integer> qd = new QueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; } @Override public boolean done() { return false; } @Override public Throwable error() { return null; } @Override public boolean enter() { return true; } @Override public long requested() { return 0; } @Override public long produced(long n) { return 0; } @Override public int leave(int m) { return 0; } @Override public boolean accept(Subscriber<? super Integer> a, Integer v) { return false; } }; SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); ts.assertResult();",
        "label":1
    },
    {
        "ins1AddCode":"Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, false, fieldName);",
        "ins1DelCode":"Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, fieldName);",
        "ins1PreCode":"public void testSplitFieldNotFound() throws Exception { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); String fieldName = RandomDocumentPicks.randomFieldName(random()); Processor processor = new SplitProcessor(randomAlphaOfLength(10), fieldName, \"\\\\.\", false, fieldName); try { processor.execute(ingestDocument);",
        "ins2PreCode":"public void testJoinNonExistingField() throws Exception { IngestDocument ingestDocument = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); String fieldName = RandomDocumentPicks.randomFieldName(random()); Processor processor = new JoinProcessor(randomAlphaOfLength(10), fieldName, \"-\", fieldName); try { processor.execute(ingestDocument);",
        "label":0
    },
    {
        "ins1AddCode":"XContentParseException exception = expectThrows(XContentParseException.class, () -> PrecisionAtK.fromXContent(parser)); assertThat(exception.getMessage(), containsString(\"[precision] unknown field\"));",
        "ins1DelCode":"IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> PrecisionAtK.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[precision] unknown field\"));",
        "ins1PreCode":"try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { parser.nextToken(); parser.nextToken(); IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> PrecisionAtK.fromXContent(parser)); assertThat(exception.getMessage(), startsWith(\"[precision] unknown field\")); }",
        "ins2PreCode":"try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) { Exception exception = expectThrows(Exception.class, () -> RankEvalSpec.parse(parser)); assertThat(exception.getMessage(), containsString(\"[rank_eval] failed to parse field\")); }",
        "label":0
    },
    {
        "ins1AddCode":"JarFile jarFile = JarFileWrapper.unwrap(connection.getJarFile()); assertThat(jarFile.getRootJarFile().getFile()).isEqualTo(testJar); jarFile.close();",
        "ins1DelCode":"assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); connection.getJarFile().close();",
        "ins1PreCode":"URL url = new URL(null, \"jar:\" + testJar.toURI().toURL() + \"!/nested.jar!/3.dat\", this.handler); JarURLConnection connection = (JarURLConnection) url.openConnection(); try { assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); } finally { connection.getJarFile().close(); }",
        "ins2PreCode":"URL url = new URL(null, \"jar:\" + testJar.toURI().toURL() + \"!/nested.jar!/3.dat\", this.handler); JarURLConnection connection = (JarURLConnection) url.openConnection(); try { assertThat(connection.getJarFile().getRootJarFile().getFile()).isEqualTo(testJar); } finally { connection.getJarFile().close(); }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void merge1AsyncStreamOf1() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(1, 1).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1AsyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(1, 1000).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericView sourceObject, Map<String, Object> options) throws DBException {",
        "ins1DelCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException {",
        "ins1PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, sourceObject, \"Read HSQLDB view source\")) {",
        "ins2PreCode":"public String getViewDDL(DBRProgressMonitor monitor, GenericTable sourceObject, Map<String, Object> options) throws DBException { GenericDataSource dataSource = sourceObject.getDataSource(); try (JDBCSession session = DBUtils.openMetaSession(monitor, sourceObject, \"Read H2 view source\")) {",
        "label":1
    },
    {
        "ins1AddCode":"Path file = Path.of(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI());",
        "ins1DelCode":"Path file = Paths.get(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI());",
        "ins1PreCode":"void testWithNbibFile() throws IOException, URISyntaxException { Path file = Paths.get(MedlinePlainImporter.class.getResource(\"NbibImporterTest.nbib\").toURI());  List<BibEntry> entries = importer.importDatabase(file, StandardCharsets.UTF_8).getDatabase().getEntries();",
        "ins2PreCode":"void testWithMultipleEntries() throws IOException, URISyntaxException { .get(MedlinePlainImporter.class.getResource(\"MedlinePlainImporterStringOutOfBounds.txt\").toURI()); List<BibEntry> entries = importer.importDatabase(file, Charsets.UTF_8).getDatabase().getEntries();",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"ROOT\", cn1.getBaseName()); Assert.assertEquals(\"ROOT\", cn2.getBaseName()); Assert.assertEquals(\"ROOT\", cn3.getBaseName()); Assert.assertEquals(\"foo\", cn4.getBaseName()); Assert.assertEquals(\"foo#bar\", cn5.getBaseName()); Assert.assertEquals(\"ROOT##A\", cn6.getBaseName()); Assert.assertEquals(\"ROOT##B\", cn7.getBaseName()); Assert.assertEquals(\"ROOT##C\", cn8.getBaseName()); Assert.assertEquals(\"foo##D\", cn9.getBaseName()); Assert.assertEquals(\"foo#bar##E\", cn10.getBaseName()); Assert.assertEquals(\"ROOT\", cn11.getBaseName()); Assert.assertEquals(\"foo\", cn12.getBaseName()); Assert.assertEquals(\"foo#bar\", cn13.getBaseName()); Assert.assertEquals(\"ROOT##A\", cn14.getBaseName()); Assert.assertEquals(\"foo##D\", cn15.getBaseName()); Assert.assertEquals(\"foo#bar##E\", cn16.getBaseName()); Assert.assertEquals(\"ROOT\", cn17.getBaseName()); Assert.assertEquals(\"ROOT#bar\", cn18.getBaseName()); Assert.assertEquals(\"ROOT#bar##A\", cn19.getBaseName()); Assert.assertEquals(\"ROOT##A\", cn20.getBaseName()); Assert.assertEquals(\"foo.war\", cn21.getBaseName()); Assert.assertEquals(\"foo\", cn22.getBaseName());",
        "ins1DelCode":"assertEquals(\"ROOT\", cn1.getBaseName()); assertEquals(\"ROOT\", cn2.getBaseName()); assertEquals(\"ROOT\", cn3.getBaseName()); assertEquals(\"foo\", cn4.getBaseName()); assertEquals(\"foo#bar\", cn5.getBaseName()); assertEquals(\"ROOT##A\", cn6.getBaseName()); assertEquals(\"ROOT##B\", cn7.getBaseName()); assertEquals(\"ROOT##C\", cn8.getBaseName()); assertEquals(\"foo##D\", cn9.getBaseName()); assertEquals(\"foo#bar##E\", cn10.getBaseName()); assertEquals(\"ROOT\", cn11.getBaseName()); assertEquals(\"foo\", cn12.getBaseName()); assertEquals(\"foo#bar\", cn13.getBaseName()); assertEquals(\"ROOT##A\", cn14.getBaseName()); assertEquals(\"foo##D\", cn15.getBaseName()); assertEquals(\"foo#bar##E\", cn16.getBaseName()); assertEquals(\"ROOT\", cn17.getBaseName()); assertEquals(\"ROOT#bar\", cn18.getBaseName()); assertEquals(\"ROOT#bar##A\", cn19.getBaseName()); assertEquals(\"ROOT##A\", cn20.getBaseName()); assertEquals(\"foo.war\", cn21.getBaseName()); assertEquals(\"foo\", cn22.getBaseName());",
        "ins1PreCode":"public void testGetBaseName() { assertEquals(\"ROOT\", cn1.getBaseName()); assertEquals(\"ROOT\", cn2.getBaseName()); assertEquals(\"ROOT\", cn3.getBaseName()); assertEquals(\"foo\", cn4.getBaseName()); assertEquals(\"foo#bar\", cn5.getBaseName()); assertEquals(\"ROOT##A\", cn6.getBaseName()); assertEquals(\"ROOT##B\", cn7.getBaseName()); assertEquals(\"ROOT##C\", cn8.getBaseName()); assertEquals(\"foo##D\", cn9.getBaseName()); assertEquals(\"foo#bar##E\", cn10.getBaseName()); assertEquals(\"ROOT\", cn11.getBaseName()); assertEquals(\"foo\", cn12.getBaseName()); assertEquals(\"foo#bar\", cn13.getBaseName()); assertEquals(\"ROOT##A\", cn14.getBaseName()); assertEquals(\"foo##D\", cn15.getBaseName()); assertEquals(\"foo#bar##E\", cn16.getBaseName()); assertEquals(\"ROOT\", cn17.getBaseName()); assertEquals(\"ROOT#bar\", cn18.getBaseName()); assertEquals(\"ROOT#bar##A\", cn19.getBaseName()); assertEquals(\"ROOT##A\", cn20.getBaseName()); assertEquals(\"foo.war\", cn21.getBaseName()); assertEquals(\"foo\", cn22.getBaseName());",
        "ins2PreCode":"public void testGetName() { assertEquals(\"\", cn1.getName()); assertEquals(\"\", cn2.getName()); assertEquals(\"\", cn3.getName()); assertEquals(\"/foo\", cn4.getName()); assertEquals(\"/foo/bar\", cn5.getName()); assertEquals(\"##A\", cn6.getName()); assertEquals(\"##B\", cn7.getName()); assertEquals(\"##C\", cn8.getName()); assertEquals(\"/foo##D\", cn9.getName()); assertEquals(\"/foo/bar##E\", cn10.getName()); assertEquals(\"\", cn11.getName()); assertEquals(\"/foo\", cn12.getName()); assertEquals(\"/foo/bar\", cn13.getName()); assertEquals(\"##A\", cn14.getName()); assertEquals(\"/foo##D\", cn15.getName()); assertEquals(\"/foo/bar##E\", cn16.getName()); assertEquals(\"\", cn17.getName()); assertEquals(\"/ROOT/bar\", cn18.getName()); assertEquals(\"/ROOT/bar##A\", cn19.getName()); assertEquals(\"##A\", cn20.getName()); assertEquals(\"/foo.war\", cn21.getName()); assertEquals(\"/foo\", cn22.getName());",
        "label":1
    },
    {
        "ins1AddCode":"if (!vpath.isEmpty()) { && !\".\".equals(file.getName()) && !\"..\".equals(file.getName())) {",
        "ins1DelCode":"if (!vpath.equals(\"\")) { && !file.getName().equals(\".\") && !file.getName().equals(\"..\")) {",
        "ins1PreCode":"return; } String completePath = null; if (!vpath.equals(\"\")) { completePath = rootPath + remoteFileSep + vpath.replace(File.separatorChar, remoteFileSep.charAt(0)); } else { completePath = rootPath; } FTPFile[] newfiles = listFiles(completePath, false);  if (newfiles == null) { ftp.changeToParentDirectory(); return; } for (int i = 0; i < newfiles.length; i++) { FTPFile file = newfiles[i]; if (file != null && !file.getName().equals(\".\") && !file.getName().equals(\"..\")) { String name = vpath + file.getName(); scannedDirs.put(name, new FTPFileProxy(file));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(graph.edgeValueOrNull(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValueOrNull(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValueOrNull(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValueOrNull(4, 4)).isEqualTo(\"valueD\");",
        "ins1DelCode":"assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\");",
        "ins1PreCode":"graph.putEdgeValue(2, 3, \"valueC\"); graph.putEdgeValue(4, 4, \"valueD\");  assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueA\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\");  String toString = graph.toString();",
        "ins2PreCode":"graph.putEdgeValue(2, 3, \"valueC\"); graph.putEdgeValue(4, 4, \"valueD\"); assertThat(graph.edgeValue(1, 2)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 1)).isEqualTo(\"valueB\"); assertThat(graph.edgeValue(2, 3)).isEqualTo(\"valueC\"); assertThat(graph.edgeValue(4, 4)).isEqualTo(\"valueD\"); String toString = graph.toString();",
        "label":1
    },
    {
        "ins1AddCode":"\"  number  = {1},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  number  = {1},\" + OS.NEWLINE +",
        "ins1PreCode":"void testSerialization() throws IOException { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.Article);  entry.setField(StandardField.AUTHOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins2PreCode":"void writeEntryWithOrField() throws Exception { StringWriter stringWriter = new StringWriter(); BibEntry entry = new BibEntry(StandardEntryType.InBook); entry.setField(StandardField.EDITOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\"); entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\"); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString(); String expected = OS.NEWLINE + \"@InBook{,\" + OS.NEWLINE + \"  editor  = {Foo Bar},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"}\" + OS.NEWLINE; assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1AddCode":"return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, this.messageConverters, setOf(interceptors), this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "ins1DelCode":"return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, Collections.unmodifiableSet(new LinkedHashSet<>(interceptors)));",
        "ins1PreCode":"public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, Collections.unmodifiableSet(new LinkedHashSet<>(interceptors)));",
        "ins2PreCode":"Collection<? extends ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.detectRequestFactory, this.rootUri, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.restTemplateCustomizers, this.requestFactoryCustomizer, append(this.interceptors, interceptors));",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":".flatMapMaybe(Functions.justFunction(new Maybe<Integer>() { @Override protected void subscribeActual(MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\")); observer.onError(new TestException(\"Second\"));",
        "ins2PreCode":".flatMapMaybe(Functions.justFunction(new Maybe<Integer>() { @Override protected void subscribeActual(MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\")); observer.onError(new TestException(\"Second\"));",
        "label":1
    },
    {
        "ins1AddCode":"void testMappedStatementCache() throws Exception {",
        "ins1DelCode":"public void testMappedStatementCache() throws Exception {",
        "ins1PreCode":"public void testMappedStatementCache() throws Exception { try (Reader configReader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/xml_external_ref/MapperConfig.xml\")) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader);",
        "ins2PreCode":"public void testMappedStatementCache() throws Exception { try (Reader configReader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/xml_external_ref/MultipleCrossIncludeMapperConfig.xml\")) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( \"it:generate-metadata\", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"it:generate-test-metadata\", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() );",
        "ins1DelCode":"assertEquals( \"plexus-component-metadata:generate-metadata\", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"plexus-component-metadata:generate-test-metadata\", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() );",
        "ins1PreCode":"assertEquals( \"clean:clean\", executionPlan.get( 0 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"resources:resources\", executionPlan.get( 1 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"compiler:compile\", executionPlan.get( 2 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"plexus-component-metadata:generate-metadata\", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"resources:testResources\", executionPlan.get( 4 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"compiler:testCompile\", executionPlan.get( 5 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"plexus-component-metadata:generate-test-metadata\", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"surefire:test\", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"jar:jar\", executionPlan.get( 8 ).getMojoDescriptor().getFullGoalName() );",
        "ins2PreCode":"assertEquals( \"jar:jar\", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"resources:resources\", executionPlan.get( 0 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"compiler:compile\", executionPlan.get( 1 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"plexus-component-metadata:generate-metadata\", executionPlan.get( 2 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"resources:testResources\", executionPlan.get( 3 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"compiler:testCompile\", executionPlan.get( 4 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"plexus-component-metadata:generate-test-metadata\", executionPlan.get( 5 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"surefire:test\", executionPlan.get( 6 ).getMojoDescriptor().getFullGoalName() ); assertEquals( \"jar:jar\", executionPlan.get( 7 ).getMojoDescriptor().getFullGoalName() );",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void interruptTerminalEventAwaitAndUnsubscribe() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final Thread t0 = Thread.currentThread();",
        "ins2PreCode":"public void interruptTerminalEventAwaitAndUnsubscribe() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); final Thread t0 = Thread.currentThread();",
        "label":1
    },
    {
        "ins1AddCode":"if (showVisibility == showem) { return; }",
        "ins1DelCode":"if (showVisibility == showem) return;",
        "ins1PreCode":"public void setShowVisibility(final boolean showem) { if (showVisibility == showem) return;  Memento memento = new Memento() {",
        "ins2PreCode":"public void setShowMultiplicity(final boolean showem) { if (showMultiplicity == showem) return; Memento memento = new Memento() {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (rs.cancelled) { rs.index = null; return; } if (index.get() != null) { continue; }",
        "ins1PreCode":"index = n; }  if (index.get() != null) { continue; } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TomcatConnectorCustomizer ssl = new SslConnectorCustomizer(getSsl(), getSslStoreProvider()); ssl.customize(connector); TomcatConnectorCustomizer compression = new CompressionConnectorCustomizer(getCompression()); compression.customize(connector);",
        "ins1DelCode":"if (getSsl() != null && getSsl().isEnabled()) { customizeSsl(connector); } if (getCompression() != null && getCompression().getEnabled()) { customizeCompression(connector); }",
        "ins1PreCode":" connector.setProperty(\"bindOnInit\", \"false\");  if (getSsl() != null && getSsl().isEnabled()) { customizeSsl(connector); } if (getCompression() != null && getCompression().getEnabled()) { customizeCompression(connector); } for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"r1.setDefaultItemLabelGenerator(new IntervalCategoryItemLabelGenerator()); r1.setDefaultItemLabelGenerator(new IntervalCategoryItemLabelGenerator());",
        "ins1DelCode":"r1.setBaseItemLabelGenerator(new IntervalCategoryItemLabelGenerator()); r1.setBaseItemLabelGenerator(new IntervalCategoryItemLabelGenerator());",
        "ins1PreCode":"public void testCloning2() throws CloneNotSupportedException { BarRenderer r1 = new BarRenderer(); r1.setBaseItemLabelGenerator(new IntervalCategoryItemLabelGenerator()); BarRenderer r2 = (BarRenderer) r1.clone();  assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));  r1 = new BarRenderer(); r1.setSeriesItemLabelGenerator(0, new IntervalCategoryItemLabelGenerator()); r2 = (BarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass()); assertTrue(r1.equals(r2));  r1 = new BarRenderer(); r1.setBaseItemLabelGenerator(new IntervalCategoryItemLabelGenerator()); r2 = (BarRenderer) r1.clone(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa7_2(active0, 0x100000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa7_2(active0, 0x80000000000L);",
        "ins1PreCode":"switch(curChar) { case 99: return jjMoveStringLiteralDfa7_2(active0, 0x80000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 101: return jjMoveStringLiteralDfa8_2(active0, 0x80000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(\"Subject still has observers!\", ps.hasObservers());",
        "ins1DelCode":"assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins1PreCode":"to .assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins2PreCode":"to .assertResult(1); assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset<String> dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYDataset dataset = new XYSeriesCollection<>(series1);",
        "ins1PreCode":"series1.add(1.0, 1.0); series1.add(2.0, 2.0); series1.add(3.0, 3.0); XYDataset dataset = new XYSeriesCollection<>(series1);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Graph<Integer, String> undirectedGraph = GraphBuilder.undirected() .expectedEdgeCount(EDGE_COUNT) .build();",
        "ins1DelCode":"UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(config().expectedEdgeCount(EDGE_COUNT));",
        "ins1PreCode":"public void createUndirected_expectedEdgeCount() { UndirectedGraph<Integer, String> undirectedGraph = Graphs.createUndirected(config().expectedEdgeCount(EDGE_COUNT)); assertThat(undirectedGraph.addEdge(E12, N1, N2)).isTrue(); assertThat(undirectedGraph.edgesConnecting(N1, N2)).isEqualTo(ImmutableSet.of(E12));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final SparkConf conf = new SparkConf().set(\"spark.memory.offHeap.enabled\", \"false\");",
        "ins1DelCode":"final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\");",
        "ins1PreCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0);",
        "ins2PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0);",
        "label":0
    },
    {
        "ins1AddCode":"List<String> lines; lines = Files.readAllLines(path, StandardCharsets.UTF_8); String content = String.join(\"\\n\", lines); return JavaLocalizationEntryParser.getLanguageKeysInString(content, type).stream() .map(key -> new LocalizationEntry(path, key, type)) .collect(Collectors.toList());",
        "ins1DelCode":"List<LocalizationEntry> result = new ArrayList<>(); List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); String content = String.join(\"\\n\", lines); List<String> keys = JavaLocalizationEntryParser.getLanguageKeysInString(content, type); for (String key : keys) { result.add(new LocalizationEntry(path, key, type)); } return result;",
        "ins1PreCode":"private static List<LocalizationEntry> getLanguageKeysInJavaFile(Path path, LocalizationBundleForTest type) { List<LocalizationEntry> result = new ArrayList<>();  try { List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); String content = String.join(\"\\n\", lines);  List<String> keys = JavaLocalizationEntryParser.getLanguageKeysInString(content, type);  for (String key : keys) { result.add(new LocalizationEntry(path, key, type)); } } catch (IOException exception) { throw new RuntimeException(exception); }  return result;",
        "ins2PreCode":"private static List<LocalizationEntry> getLocalizationParametersInJavaFile(Path path, LocalizationBundleForTest type) { List<LocalizationEntry> result = new ArrayList<>(); try { List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8); String content = String.join(\"\\n\", lines); List<String> keys = JavaLocalizationEntryParser.getLocalizationParameter(content, type); for (String key : keys) { result.add(new LocalizationEntry(path, key, type)); } } catch (IOException exception) { throw new RuntimeException(exception); } return result;",
        "label":1
    },
    {
        "ins1AddCode":"if (Execute.isFailure(process.execute())) {",
        "ins1DelCode":"if (process.execute() != 0) {",
        "ins1PreCode":"process.setCommandline(cmdl.getCommandline());  try { if (process.execute() != 0) { throw new BuildException(\"JJTree failed.\"); }",
        "ins2PreCode":"process.setCommandline(cmdl.getCommandline()); try { if (process.execute() != 0) { throw new BuildException(\"JJDoc failed.\"); }",
        "label":1
    },
    {
        "ins1AddCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), null, \"source_field\",",
        "ins1DelCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\",",
        "ins1PreCode":"public void testCityWithMissingLocation() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false, new GeoIpCache(1000), false);",
        "ins2PreCode":"public void testCountryWithMissingLocation() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-Country.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false, new GeoIpCache(1000), false);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1 = new StandardCategoryURLGenerator();",
        "ins2PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); CategoryURLGenerator url2 = renderer.getItemURLGenerator(0, 0);",
        "label":0
    },
    {
        "ins1AddCode":"SerializedSubscriber<T> z = new SerializedSubscriber<>(s); FlowableProcessor<Object> processor = UnicastProcessor.create(8).toSerialized(); WhenReceiver<T, Object> receiver = new WhenReceiver<>(source); RepeatWhenSubscriber<T> subscriber = new RepeatWhenSubscriber<>(z, processor, receiver);",
        "ins1DelCode":"SerializedSubscriber<T> z = new SerializedSubscriber<T>(s); FlowableProcessor<Object> processor = UnicastProcessor.<Object>create(8).toSerialized(); WhenReceiver<T, Object> receiver = new WhenReceiver<T, Object>(source); RepeatWhenSubscriber<T> subscriber = new RepeatWhenSubscriber<T>(z, processor, receiver);",
        "ins1PreCode":"public void subscribeActual(Subscriber<? super T> s) {  SerializedSubscriber<T> z = new SerializedSubscriber<T>(s);  FlowableProcessor<Object> processor = UnicastProcessor.<Object>create(8).toSerialized();  Publisher<?> when;  try { when = Objects.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, s); return; }  WhenReceiver<T, Object> receiver = new WhenReceiver<T, Object>(source);  RepeatWhenSubscriber<T> subscriber = new RepeatWhenSubscriber<T>(z, processor, receiver);  receiver.subscriber = subscriber;",
        "ins2PreCode":"public void subscribeActual(Subscriber<? super T> s) { SerializedSubscriber<T> z = new SerializedSubscriber<T>(s); FlowableProcessor<Throwable> processor = UnicastProcessor.<Throwable>create(8).toSerialized(); Publisher<?> when; try { when = Objects.requireNonNull(handler.apply(processor), \"handler returned a null Publisher\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); EmptySubscription.error(ex, s); return; } WhenReceiver<T, Throwable> receiver = new WhenReceiver<T, Throwable>(source); RetryWhenSubscriber<T> subscriber = new RetryWhenSubscriber<T>(z, processor, receiver); receiver.subscriber = subscriber;",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(\"one\"); observer.onNext(\"two\");",
        "ins2PreCode":"Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(\"one\"); subscriber.onNext(\"two\");",
        "label":0
    },
    {
        "ins1AddCode":"org.eclipse.aether.graph.Dependency dep = node.getDependency(); org.eclipse.aether.artifact.Artifact art = dep.getArtifact();",
        "ins1DelCode":"org.sonatype.aether.graph.Dependency dep = node.getDependency(); org.sonatype.aether.artifact.Artifact art = dep.getArtifact(); if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ).append( \")\" ); } if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ).append( \")\" ); }",
        "ins1PreCode":"{ StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.sonatype.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.sonatype.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art ); buffer.append( ':' ).append( dep.getScope() );  if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ).append( \")\" ); }  if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ).append( \")\" ); } }",
        "ins2PreCode":"{ StringBuilder buffer = new StringBuilder( 128 ); buffer.append( indent ); org.sonatype.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.sonatype.aether.artifact.Artifact art = dep.getArtifact(); buffer.append( art ); buffer.append( ':' ).append( dep.getScope() ); if ( node.getPremanagedScope() != null && !node.getPremanagedScope().equals( dep.getScope() ) ) { buffer.append( \" (scope managed from \" ).append( node.getPremanagedScope() ); } if ( node.getPremanagedVersion() != null && !node.getPremanagedVersion().equals( art.getVersion() ) ) { buffer.append( \" (version managed from \" ).append( node.getPremanagedVersion() ); } }",
        "label":0
    },
    {
        "ins1AddCode":"Disposable d1 = Disposable.empty(); Disposable d2 = Disposable.empty();",
        "ins1DelCode":"Disposable d1 = Disposables.empty(); Disposable d2 = Disposables.empty();",
        "ins1PreCode":"@Override protected void subscribeActual(Observer<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty();  observer.onSubscribe(d2);",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super T> observer) { try { Disposable d1 = Disposables.empty(); observer.onSubscribe(d1); Disposable d2 = Disposables.empty(); observer.onSubscribe(d2);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Object> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Object> ts = new TestSubscriber<Object>();",
        "ins1PreCode":"public void just() { TestSubscriber<Object> ts = new TestSubscriber<Object>(); Flowable.just(1) .flatMap(",
        "ins2PreCode":"public void just() { TestObserver<Object> to = new TestObserver<Object>(); Observable.just(1) .flatMap(",
        "label":1
    },
    {
        "ins1AddCode":"final long originalPos = position; UnsafeUtil.putByte(buffer, position++, (byte) value); UnsafeUtil.putByte(buffer, position++, (byte) ((value & 0x7F) | 0x80)); int delta = (int) (position - originalPos);",
        "ins1DelCode":"final long originalPos = ARRAY_BASE_OFFSET + position; long pos = originalPos; UnsafeUtil.putByte(buffer, pos++, (byte) value); UnsafeUtil.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); int delta = (int) (pos - originalPos); position += delta;",
        "ins1PreCode":"final void bufferUInt32NoTag(int value) { if (HAS_UNSAFE_ARRAY_OPERATIONS) { final long originalPos = ARRAY_BASE_OFFSET + position; long pos = originalPos; while (true) { if ((value & ~0x7F) == 0) { UnsafeUtil.putByte(buffer, pos++, (byte) value); break; } else { UnsafeUtil.putByte(buffer, pos++, (byte) ((value & 0x7F) | 0x80)); value >>>= 7; } } int delta = (int) (pos - originalPos); position += delta; totalBytesWritten += delta; } else {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"String results = decoder.decode(ByteBuffer.wrap(\"a string\\na\".getBytes()), context); assertEquals(\"a string\", results); assertEquals(\"a string\", results);",
        "ins1DelCode":"String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\na\".getBytes()), context); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(1, results.length); assertEquals(\"a string\", results[0]);",
        "ins1PreCode":"public void testThatContextIsMaintainedBetweenMessages() { TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.UNIX); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\na\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(1, context.getBuffer().position()); results = decoder.decode(ByteBuffer.wrap(\" string\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"public void testThatContextIsMaintainedBetweenMessages() { TextLineDecoder decoder = new TextLineDecoder(LineDelimiter.WINDOWS); Context context = decoder.createDecoderState(); String[] results = decoder.decode(ByteBuffer.wrap(\"a string\\r\\na\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(1, context.getBuffer().position()); results = decoder.decode(ByteBuffer.wrap(\" string\\r\\n\".getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(\"a string\", results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1AddCode":"when(() -> mapper.insertMultiParams_keyPropertyWithoutParamName(country, 1));",
        "ins1DelCode":"when(mapper).insertMultiParams_keyPropertyWithoutParamName(country, 1);",
        "ins1PreCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(mapper).insertMultiParams_keyPropertyWithoutParamName(country, 1); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining( \"Could not determine which parameter to assign generated keys to. \"",
        "ins2PreCode":"try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(mapper).insertMultiParams_keyPropertyWithWrongParamName(country, 1); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining( \"Could not find parameter 'bogus'. \"",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "ins1DelCode":"assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins1PreCode":"assertThat(result, failedWith(6)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Connect permission\")); assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins2PreCode":"assertThat(result, failedWith(6)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Connect permission\")); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Connect permission\"));",
        "label":0
    },
    {
        "ins1AddCode":"this.queue = new MpscLinkedQueue<>();",
        "ins1DelCode":"this.queue = new MpscLinkedQueue<Object>();",
        "ins1PreCode":"AbstractWindowObserver(Observer<? super Observable<T>> downstream, long timespan, TimeUnit unit, int bufferSize) { this.downstream = downstream; this.queue = new MpscLinkedQueue<Object>(); this.timespan = timespan; this.unit = unit;",
        "ins2PreCode":"AbstractWindowSubscriber(Subscriber<? super Flowable<T>> downstream, long timespan, TimeUnit unit, int bufferSize) { this.downstream = downstream; this.queue = new MpscLinkedQueue<Object>(); this.timespan = timespan; this.unit = unit;",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void merge1SyncStreamOf1000000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(1, 1000000).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1000SyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNSyncStreamsOfN(1000, 1000).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"void shouldUpdateUserSelective() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"public void shouldUpdateUserSelective() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldUpdateUserSelective() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = new User(); user.setId(999); user.setName(\"MyBatis\"); mapper.insert(user);  user.setName(null); mapper.updateSelective(user);  User loadedUser = mapper.getUser(999); assertEquals(\"MyBatis\", loadedUser.getName());  } finally { sqlSession.close(); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"PublishConnection<T> fresh = new PublishConnection<>(current);",
        "ins1DelCode":"PublishConnection<T> fresh = new PublishConnection<T>(current);",
        "ins1PreCode":"conn = current.get();  if (conn == null || conn.isDisposed()) { PublishConnection<T> fresh = new PublishConnection<T>(current); if (!current.compareAndSet(conn, fresh)) { continue;",
        "ins2PreCode":"conn = current.get(); if (conn == null || conn.isDisposed()) { PublishConnection<T> fresh = new PublishConnection<T>(current, bufferSize); if (!current.compareAndSet(conn, fresh)) { continue;",
        "label":1
    },
    {
        "ins1AddCode":"if (nanos <= 0) { }",
        "ins1DelCode":"if (nanos <= 0)",
        "ins1PreCode":"try { E x; while ( (x = unlinkFirst()) == null) { if (nanos <= 0) return null; nanos = notEmpty.awaitNanos(nanos);",
        "ins2PreCode":"try { E x; while ( (x = unlinkLast()) == null) { if (nanos <= 0) return null; nanos = notEmpty.awaitNanos(nanos);",
        "label":1
    },
    {
        "ins1AddCode":"BibEntry entry1 = new BibEntry() .withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); CitationKeyGenerator.cleanKey(generateKey(entry1, \"[auth]\",",
        "ins1DelCode":"BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\",",
        "ins1PreCode":"void testcrossrefSchool() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);  assertEquals(\"UniLinkoepingCE\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "ins2PreCode":"void testcrossrefInstituteOfTechnology() { BibDatabase database = new BibDatabase(); BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCitationKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Massachusetts Institute of Technology}\"); database.insertEntry(entry1); database.insertEntry(entry2); assertEquals(\"MIT\", CitationKeyGenerator.cleanKey(generateKey(entry1, \"auth\", database), DEFAULT_UNWANTED_CHARACTERS));",
        "label":1
    },
    {
        "ins1AddCode":"verify(listener, times(1)).onBlockFetchFailure(eq(\"b1\"), any()); verify(listener, times(2)).onBlockFetchFailure(eq(\"b2\"), any());",
        "ins1DelCode":"verify(listener, times(1)).onBlockFetchFailure(eq(\"b1\"), (Throwable) any()); verify(listener, times(2)).onBlockFetchFailure(eq(\"b2\"), (Throwable) any());",
        "ins1PreCode":"  verify(listener, times(1)).onBlockFetchSuccess(\"b0\", blocks.get(\"b0\")); verify(listener, times(1)).onBlockFetchFailure(eq(\"b1\"), (Throwable) any()); verify(listener, times(2)).onBlockFetchFailure(eq(\"b2\"), (Throwable) any());",
        "ins2PreCode":"verify(listener, times(1)).onBlockFetchSuccess(\"b0\", blocks.get(\"b0\")); verify(listener, times(1)).onBlockFetchFailure(eq(\"b1\"), (Throwable) any()); verify(listener, times(1)).onBlockFetchFailure(eq(\"b2\"), (Throwable) any());",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 50; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"XYSeries<String> series1 = new XYSeries<>(\"Series 1\"); XYDataset dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYSeries series1 = new XYSeries(\"Series 1\"); XYDataset dataset = new XYSeriesCollection(series1);",
        "ins1PreCode":"public void testReplaceDataset() {   XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1);  LocalListener l = new LocalListener();",
        "ins2PreCode":"public void testReplaceDataset() { XYSeries series1 = new XYSeries(\"Series 1\"); series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection(series1); LocalListener l = new LocalListener();",
        "label":1
    },
    {
        "ins1AddCode":"OfflineCause.UserCause cause = (OfflineCause.UserCause) slave.toComputer().getOfflineCause();",
        "ins1DelCode":"UserCause cause = (UserCause) slave.toComputer().getOfflineCause();",
        "ins1PreCode":"assertThat(result, succeededSilently()); assertTrue(slave.toComputer().isOffline());  UserCause cause = (UserCause) slave.toComputer().getOfflineCause(); assertThat(cause.toString(), endsWith(\"Custom cause message\")); assertThat(cause.getUser(), equalTo(command.user()));",
        "ins2PreCode":"assertThat(result, succeededSilently()); assertTrue(slave.toComputer().isOffline()); UserCause cause = (UserCause) slave.toComputer().getOfflineCause(); assertThat(cause.toString(), endsWith(\"Custom cause message\")); assertThat(cause.getUser(), equalTo(command.user()));",
        "label":1
    },
    {
        "ins1AddCode":".flags(new ArrayList<ResultFlag>() {",
        "ins1DelCode":".flags(new ArrayList() {",
        "ins1PreCode":"final ResultMap tagResultMap = new ResultMap.Builder(config, \"tagResultMap\", Tag.class, new ArrayList<ResultMapping>() { { add(new ResultMapping.Builder(config, \"id\", \"tag_id\", registry.getTypeHandler(int.class)) .flags(new ArrayList() { { add(ResultFlag.ID);",
        "ins2PreCode":"final ResultMap tagResultMap = new ResultMap.Builder(config, \"tagResultMap\", Tag.class, new ArrayList<ResultMapping>() { { add(new ResultMapping.Builder(config, \"id\", \"tag_id\", registry.getTypeHandler(int.class)) .flags(new ArrayList() { { add(ResultFlag.ID);",
        "label":1
    },
    {
        "ins1AddCode":"private boolean doFileIsNew(List<CvsTagEntry> entries, String line) { entries.add(entry);",
        "ins1DelCode":"private boolean doFileIsNew(Vector entries, String line) { entries.addElement(entry);",
        "ins1PreCode":"private boolean doFileIsNew(Vector entries, String line) { int index = line.indexOf(FILE_IS_NEW); if (index == -1) { return false; }   String filename = line.substring(0, index); String rev = null; int indexrev = line.indexOf(REVISION, index); if (indexrev != -1) { rev = line.substring(indexrev + REVISION.length()); } CvsTagEntry entry = new CvsTagEntry(filename, rev); entries.addElement(entry); log(entry.toString(), Project.MSG_VERBOSE); return true;",
        "ins2PreCode":"private boolean doFileWasRemoved(Vector entries, String line) { int index = line.indexOf(FILE_WAS_REMOVED); if (index == -1) { return false; } String filename = line.substring(0, index); String rev = null; int indexrev = line.indexOf(REVISION, index); if (indexrev != -1) { rev = line.substring(indexrev + REVISION.length()); } CvsTagEntry entry = new CvsTagEntry(filename, null, rev); entries.addElement(entry); log(entry.toString(), Project.MSG_VERBOSE); return true;",
        "label":1
    },
    {
        "ins1AddCode":"if (Model.getFacade().isAExpression(expr)) { } else if (Model.getFacade().isAConstraint(expr)) { }",
        "ins1DelCode":"if (Model.getFacade().isAExpression(expr)) else if (Model.getFacade().isAConstraint(expr))",
        "ins1PreCode":"static String generateExpression(Object expr) { if (Model.getFacade().isAExpression(expr)) return generateUninterpreted( (String) Model.getFacade().getBody(expr)); else if (Model.getFacade().isAConstraint(expr)) return generateExpression(Model.getFacade().getBody(expr)); return \"\";",
        "ins2PreCode":"private static String generateExpression(Object expr) { if (Model.getFacade().isAExpression(expr)) { return generateUninterpreted( (String) Model.getFacade().getBody(expr)); } else if (Model.getFacade().isAConstraint(expr)) { return generateExpression(Model.getFacade().getBody(expr)); return \"\";",
        "label":0
    },
    {
        "ins1AddCode":"if (!ObjectUtils.equal(this.stroke, that.stroke)) { if (!PaintUtils.equal(this.outlinePaint, that.outlinePaint)) { if (!PaintUtils.equal(this.fillPaint, that.fillPaint)) {",
        "ins1DelCode":"if (!ObjectUtilities.equal(this.stroke, that.stroke)) { if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) { if (!PaintUtilities.equal(this.fillPaint, that.fillPaint)) {",
        "ins1PreCode":"if (!Arrays.equals(this.polygon, that.polygon)) { return false; } if (!ObjectUtilities.equal(this.stroke, that.stroke)) { return false; } if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!PaintUtilities.equal(this.fillPaint, that.fillPaint)) { return false; }",
        "ins2PreCode":"if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!ObjectUtilities.equal(this.stroke, that.stroke)) { return false; } if (!PaintUtilities.equal(this.outlinePaint, that.outlinePaint)) { return false; } if (!PaintUtilities.equal(this.fillPaint, that.fillPaint)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ObservableZip<>(sources, null, zipper, bufferSize, delayError));",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));",
        "ins1PreCode":"} Objects.requireNonNull(zipper, \"zipper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new ObservableZip<T, R>(sources, null, zipper, bufferSize, delayError));",
        "ins2PreCode":"} Objects.requireNonNull(combiner, \"combiner is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new FlowableCombineLatest<T, R>(sources, combiner, bufferSize, false));",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(POSSIBLY_DAMAGED_PWD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"BlockPushingListener listener = pushBlocks( verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockPushSuccess(eq(\"shufflePush_0_2_0\"), any());",
        "ins1DelCode":"BlockFetchingListener listener = pushBlocks( verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_2_0\"), any());",
        "ins1PreCode":"blocks.put(\"shufflePush_0_2_0\", new NettyManagedBuffer(Unpooled.wrappedBuffer(new byte[23]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]);  BlockFetchingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\",0,  0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2)));  verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_1_0\"), any()); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_2_0\"), any());",
        "ins2PreCode":"blocks.put(\"shufflePush_0_2_0\", new NioManagedBuffer(ByteBuffer.wrap(new byte[0]))); String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]); BlockFetchingListener listener = pushBlocks( blocks, blockIds, Arrays.asList(new PushBlockStream(\"app-id\", 0, 0, 0, 0, 0), new PushBlockStream(\"app-id\", 0, 0, 1, 0, 1), new PushBlockStream(\"app-id\", 0, 0, 2, 0, 2))); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any()); verify(listener, times(1)).onBlockFetchSuccess(eq(\"shufflePush_0_0_0\"), any());",
        "label":1
    },
    {
        "ins1AddCode":"Rectangle2D bounds = TextUtils.getTextBounds(tickLabel, g2,",
        "ins1DelCode":"Rectangle2D bounds = TextUtilities.getTextBounds(tickLabel, g2,",
        "ins1PreCode":"}   Rectangle2D bounds = TextUtilities.getTextBounds(tickLabel, g2, g2.getFontMetrics()); double tickLabelLength = isVerticalTickLabels()",
        "ins2PreCode":"} Rectangle2D bounds = TextUtilities.getTextBounds(tickLabel, g2, g2.getFontMetrics()); double tickLabelLength = isVerticalTickLabels()",
        "label":1
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.arrowStroke, that.arrowStroke)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.arrowStroke, that.arrowStroke)) {",
        "ins1PreCode":"if (!this.arrowPaint.equals(that.arrowPaint)) { return false; } if (!ObjectUtils.equal(this.arrowStroke, that.arrowStroke)) { return false; }",
        "ins2PreCode":"if (!this.arrowPaint.equals(that.arrowPaint)) { return false; } if (!ObjectUtils.equal(this.arrowStroke, that.arrowStroke)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldResolveListTypeParam() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { PersonMapper mapper = sqlSession.getMapper(PersonMapper.class); List<Person> persons = mapper.selectList(null); assertEquals(2, persons.size()); assertEquals(\"Jane\", persons.get(0).getName()); assertEquals(\"John\", persons.get(1).getName()); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldResolveParameterizedReturnType() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { PersonListMapper mapper = sqlSession.getMapper(PersonListMapper.class); List<Person> persons = mapper.select(null); assertEquals(2, persons.size()); assertEquals(\"Jane\", persons.get(0).getName()); assertEquals(\"John\", persons.get(1).getName()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"}, false, 2);",
        "ins1DelCode":"}, 2, false);",
        "ins1PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, false); } });",
        "ins2PreCode":"public Publisher<Integer> apply(Integer v) throws Throwable { return Flowable.just(v).hide(); } }, 2, true); } });",
        "label":1
    },
    {
        "ins1AddCode":"List<Integer> axisIndices = Arrays.asList(new Integer[] {0, 1}); axisIndices = Arrays.asList(new Integer[] {1, 2});",
        "ins1DelCode":"List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)});",
        "ins1PreCode":"plot.mapDatasetToRangeAxis(0, 1); assertEquals(yAxis2, plot.getRangeAxisForDataset(0));  List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis, plot.getRangeAxisForDataset(0));  axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToRangeAxes(0, axisIndices); assertEquals(yAxis2, plot.getRangeAxisForDataset(0));",
        "ins2PreCode":"plot.mapDatasetToDomainAxis(0, 1); assertEquals(xAxis2, plot.getDomainAxisForDataset(0)); List axisIndices = Arrays.asList(new Integer[] {new Integer(0), new Integer(1)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis, plot.getDomainAxisForDataset(0)); axisIndices = Arrays.asList(new Integer[] {new Integer(1), new Integer(2)}); plot.mapDatasetToDomainAxes(0, axisIndices); assertEquals(xAxis2, plot.getDomainAxisForDataset(0));",
        "label":1
    },
    {
        "ins1AddCode":"for (Class<?> type : types) { if (type == null) { sb.append(type.getName()).append(\", \");",
        "ins1DelCode":"for (int i = 0; i < types.length; i++) { if (types[i] == null) { sb.append(types[i].getName()).append(\", \");",
        "ins1PreCode":"private static final String paramString(Class<?>[] types) { if (types != null) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < types.length; i++) { if (types[i] == null) { sb.append(\"null, \"); } else { sb.append(types[i].getName()).append(\", \"); } }",
        "ins2PreCode":"private static final String paramString(Class<?>[] types) { if (types != null) { StringBuilder sb = new StringBuilder(); for (int i = 0; i < types.length; i++) { if (types[i] == null) { sb.append(\"null, \"); } else { sb.append(types[i].getName()).append(\", \"); } }",
        "label":1
    },
    {
        "ins1AddCode":"cs = Objects.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\");",
        "ins1DelCode":"cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\");",
        "ins1PreCode":"CompletableSource cs;  try { cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"CompletableSource cs; try { cs = ObjectHelper.requireNonNull(mapper.apply(value), \"The mapper returned a null CompletableSource\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"protected FigNode getNodePresentationFor(Layer lay, Object modelElement) {",
        "ins1DelCode":"private FigNode getNodePresentationFor(Layer lay, Object modelElement) {",
        "ins1PreCode":"private FigNode getNodePresentationFor(Layer lay, Object modelElement) { assert modelElement != null : \"A modelElement must be supplied\"; for (Object fig : lay.getContentsNoEdges()) {",
        "ins2PreCode":"private FigNode getNodePresentationFor(Layer lay, Object modelElement) { assert modelElement != null : \"A modelElement must be supplied\"; for (Object fig : lay.getContentsNoEdges()) {",
        "label":0
    },
    {
        "ins1AddCode":"log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\");",
        "ins1DelCode":"log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception());",
        "ins1PreCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try {",
        "ins2PreCode":"protected void doClose() { if (log.isDebugEnabled()) { log.debug(\"Calling [\" + getEndpoint() + \"].closeSocket([\" + this + \"])\", new Exception()); } try {",
        "label":1
    },
    {
        "ins1AddCode":"ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\")));",
        "ins1DelCode":"ds.setBasedir(new File(getProject().getProperty(\"output\")));",
        "ins1PreCode":"public void testPatternsDifferInCaseScanningSensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"}); ds.scan();",
        "ins2PreCode":"public void testParentDiffersInCaseScanningSensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/beta/\"}); ds.scan();",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> subplot1 = plot.getSubplots().get(0);",
        "ins1DelCode":"XYPlot subplot1 = plot.getSubplots().get(0);",
        "ins1PreCode":"CombinedDomainXYPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); XYPlot subplot1 = plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero());",
        "ins2PreCode":"CombinedDomainCategoryPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this); CategoryPlot subplot1 = plot.getSubplots().get(0); NumberAxis yAxis = (NumberAxis) subplot1.getRangeAxis(); yAxis.setAutoRangeIncludesZero(!yAxis.getAutoRangeIncludesZero());",
        "label":0
    },
    {
        "ins1AddCode":"MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).apply(springSecurity()).addFilter(filter) .build();",
        "ins1DelCode":"Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) .addFilter(filter).build();",
        "ins1PreCode":"void securityConfigurationShouldAllowAccess() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\")); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) .addFilter(filter).build(); mockMvc.perform(MockMvcRequestBuilders.get(DEFAULT_CONTEXT_PATH + \"/restart\").header(DEFAULT_SECRET_HEADER_NAME, \"supersecret\")).andExpect(status().isOk());",
        "ins2PreCode":"void securityConfigurationShouldAllowAccessToCustomPath() throws Exception { this.context = getContext(() -> loadContext(\"spring.devtools.remote.secret:supersecret\", DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); Filter securityFilterChain = this.context.getBean(BeanIds.SPRING_SECURITY_FILTER_CHAIN, Filter.class); MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.context).addFilter(securityFilterChain) .addFilter(filter).build(); MockMvcRequestBuilders.get(\"/test/custom/restart\").header(DEFAULT_SECRET_HEADER_NAME, \"supersecret\")) .andExpect(status().isOk());",
        "label":1
    },
    {
        "ins1AddCode":"t1.onSubscribe(Disposable.empty());",
        "ins1DelCode":"t1.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super String> t1) { t1.onSubscribe(Disposables.empty()); System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis())); last = System.currentTimeMillis();",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super String> t1) { t1.onSubscribe(new BooleanSubscription()); System.out.println(count.get() + \" @ \" + String.valueOf(last - System.currentTimeMillis())); last = System.currentTimeMillis();",
        "label":0
    },
    {
        "ins1AddCode":"errors.add(new IllegalStateException(\"onSubscribe not called in proper order\")); errors.add(new NullPointerException(\"onError received a null Throwable\")); } else { errors.add(t);",
        "ins1DelCode":"errors.add(new NullPointerException(\"onSubscribe not called in proper order\")); errors.add(t); errors.add(new IllegalStateException(\"onError received a null Throwable\"));",
        "ins1PreCode":"if (!checkSubscriptionOnce) { checkSubscriptionOnce = true; if (upstream.get() == null) { errors.add(new NullPointerException(\"onSubscribe not called in proper order\")); } } try { lastThread = Thread.currentThread(); errors.add(t);  if (t == null) { errors.add(new IllegalStateException(\"onError received a null Throwable\")); } ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (args.length > 0 ) { try { size = Integer.parseInt(args[0]); } catch (Exception e){ } } try (ServerSocket srvSocket = new ServerSocket(9999)) { System.out.println(\"Listening on 9999\"); Socket socket = srvSocket.accept(); socket.setReceiveBufferSize(size); InputStream in = socket.getInputStream(); Thread t = new Thread() { @Override public void run() { while ( true ) { try { Thread.sleep(1000); printStats(start, mb, count, df, total); }catch ( Exception x ) {  } } } }; t.setDaemon(true); t.start(); while ( true ) { if ( first ) { first = false; start = System.currentTimeMillis(); } int len = in.read(buf); if ( len == -1 ) { printStats(start, mb, count, df, total); System.exit(1); } xbuf.append(buf,0,len); if ( bytes.intValue() != len ) { bytes = new BigDecimal((double)len); } total = total.add(bytes); while ( xbuf.countPackages(true) > 0 ) { xbuf.extractPackage(true); count++; } mb += ( (double) len) / 1024 / 1024; if ( ((count) % 10000) == 0 ) { printStats(start, mb, count, df, total);",
        "ins1DelCode":"if (args.length > 0 ) try {size=Integer.parseInt(args[0]);}catch(Exception x){  } ServerSocket srvSocket = new ServerSocket(9999); System.out.println(\"Listening on 9999\"); Socket socket = srvSocket.accept(); socket.setReceiveBufferSize(size); InputStream in = socket.getInputStream(); Thread t = new Thread() { @Override public void run() { while ( true ) { try { Thread.sleep(1000); printStats(start, mb, count, df, total); }catch ( Exception x ) {  } }; t.setDaemon(true); t.start(); while ( true ) { if ( first ) { first = false; start = System.currentTimeMillis();} int len = in.read(buf); if ( len == -1 ) { printStats(start, mb, count, df, total); System.exit(1); } xbuf.append(buf,0,len); if ( bytes.intValue() != len ) bytes = new BigDecimal((double)len); total = total.add(bytes); while ( xbuf.countPackages(true) > 0 ) { xbuf.extractPackage(true); count++; } mb += ( (double) len) / 1024 / 1024; if ( ((count) % 10000) == 0 ) { printStats(start, mb, count, df, total); }",
        "ins1PreCode":"public static void main(String[] args) throws Exception { int size = 43800; if (args.length > 0 ) try {size=Integer.parseInt(args[0]);}catch(Exception x){  } XByteBuffer xbuf = new XByteBuffer(43800,true); ServerSocket srvSocket = new ServerSocket(9999); System.out.println(\"Listening on 9999\"); Socket socket = srvSocket.accept(); socket.setReceiveBufferSize(size); InputStream in = socket.getInputStream(); Thread t = new Thread() { @Override public void run() { while ( true ) { try { Thread.sleep(1000); printStats(start, mb, count, df, total); }catch ( Exception x ) {  } } } }; t.setDaemon(true); t.start();  while ( true ) { if ( first ) { first = false; start = System.currentTimeMillis();} int len = in.read(buf); if ( len == -1 ) { printStats(start, mb, count, df, total); System.exit(1); } xbuf.append(buf,0,len); if ( bytes.intValue() != len ) bytes = new BigDecimal((double)len); total = total.add(bytes); while ( xbuf.countPackages(true) > 0 ) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"throw new IllegalArgumentException(sm.getString(\"userMBean.invalidRole\", rolename));",
        "ins1DelCode":"throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\");",
        "ins1PreCode":"} Role role = group.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(\"Invalid role name '\" + rolename + \"'\"); } group.addRole(role);",
        "ins2PreCode":"} Role role = group.getUserDatabase().findRole(rolename); if (role == null) { throw new IllegalArgumentException(\"Invalid role name [\" + rolename + \"]\"); } group.removeRole(role);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32);",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);",
        "ins1PreCode":"public void observerCheckTerminatedDelayErrorEmptyResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return null; }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  Disposable d = Disposable.empty();",
        "ins2PreCode":"public void observerCheckTerminatedDelayErrorNonEmpty() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty()); ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; } @Override public boolean done() { return false; } @Override public Throwable error() { return null; } @Override public boolean enter() { return true; } @Override public int leave(int m) { return 0; } @Override public void accept(Observer<? super Integer> a, Integer v) { } }; SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\");",
        "ins1DelCode":"dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), null, new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\");",
        "ins1PreCode":"try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), null, new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), new Double(4.0), null, new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "label":1
    },
    {
        "ins1AddCode":"assertThatExceptionOfType(NoSuchBeanDefinitionException.class) .isThrownBy(() -> this.context.getBean(OptionalLiveReloadServer.class));",
        "ins1DelCode":"this.thrown.expect(NoSuchBeanDefinitionException.class); this.context.getBean(OptionalLiveReloadServer.class);",
        "ins1PreCode":"Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.livereload.enabled\", false); this.context = initializeAndRun(Config.class, properties); this.thrown.expect(NoSuchBeanDefinitionException.class); this.context.getBean(OptionalLiveReloadServer.class);",
        "ins2PreCode":"Map<String, Object> properties = new HashMap<>(); properties.put(\"spring.devtools.restart.enabled\", false); this.context = initializeAndRun(Config.class, properties); this.thrown.expect(NoSuchBeanDefinitionException.class); this.context.getBean(ClassPathFileSystemWatcher.class);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertNull(\"all proxies are internal, x-forwarded-for must be null\", actualXForwardedFor); Assert.assertNull(\"all proxies are internal, x-forwarded-by must be null\", actualXForwardedBy); Assert.assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr); Assert.assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "ins1DelCode":"assertNull(\"all proxies are internal, x-forwarded-for must be null\", actualXForwardedFor); assertNull(\"all proxies are internal, x-forwarded-by must be null\", actualXForwardedBy); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "ins1PreCode":"  String actualXForwardedFor = actualRequest.getHeader(\"x-forwarded-for\"); assertNull(\"all proxies are internal, x-forwarded-for must be null\", actualXForwardedFor);  String actualXForwardedBy = actualRequest.getHeader(\"x-forwarded-by\"); assertNull(\"all proxies are internal, x-forwarded-by must be null\", actualXForwardedBy);  String actualRemoteAddr = actualRequest.getRemoteAddr(); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr);  String actualRemoteHost = actualRequest.getRemoteHost(); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "ins2PreCode":"String actualXForwardedFor = actualRequest.getHeader(\"x-forwarded-for\"); assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor); String actualXForwardedBy = actualRequest.getHeader(\"x-forwarded-by\"); assertNull(\"all proxies are trusted, x-forwarded-for must be null\", actualXForwardedFor); String actualRemoteAddr = actualRequest.getRemoteAddr(); assertEquals(\"remoteAddr\", \"140.211.11.130\", actualRemoteAddr); String actualRemoteHost = actualRequest.getRemoteHost(); assertEquals(\"remoteHost\", \"140.211.11.130\", actualRemoteHost);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,-2,3', expected string with a range M-N\")); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse '1,2,-3', expected string with a range M-N\"));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"ERROR: Unable to parse \\'1,-2,3\\', expected string with a range M-N\")); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse \\'1,2,-3\\', expected string with a range M-N\"));",
        "ins1PreCode":".invokeWithArgs(PROJECT_NAME, \"1,-2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse \\'1,-2,3\\', expected string with a range M-N\"));  result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \"1,2,-3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse \\'1,2,-3\\', expected string with a range M-N\"));",
        "ins2PreCode":".invokeWithArgs(PROJECT_NAME, \",2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ',2,3', expected correct notation M,N or M-N\")); result = command .authorizedTo(Jenkins.READ, Job.READ) .invokeWithArgs(PROJECT_NAME, \",2,3\"); assertThat(result, failedWith(3)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: Unable to parse ',2,3', expected correct notation M,N or M-N\"));",
        "label":0
    },
    {
        "ins1AddCode":"synchronized (items) { for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } nMatchingItems++; } synchronized (items) { for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } childIndices[nMatchingItems] = getIndexOfChild(pn, item); children[nMatchingItems] = item; nMatchingItems++; }",
        "ins1DelCode":"for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; nMatchingItems++; } for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; childIndices[nMatchingItems] = getIndexOfChild(pn, item); children[nMatchingItems] = item; nMatchingItems++; }",
        "ins1PreCode":"for (PriorityNode pn : PriorityNode.getPriorityList()) { path[1] = pn; int nMatchingItems = 0; for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } nMatchingItems++; } if (nMatchingItems == 0) { continue; } int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } childIndices[nMatchingItems] = getIndexOfChild(pn, item);",
        "ins2PreCode":"for (PriorityNode pn : PriorityNode.getPriorityList()) { path[1] = pn; int nMatchingItems = 0; for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } nMatchingItems++; } if (nMatchingItems == 0) { continue; } int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems]; nMatchingItems = 0; for (ToDoItem item : items) { if (item.getPriority() != pn.getPriority()) { continue; } childIndices[nMatchingItems] = getIndexOfChild(pn, item);",
        "label":1
    },
    {
        "ins1AddCode":"(constraint.getEnabled() ? ExasolConstants.KEYWORD_ENABLE : ExasolConstants.KEYWORD_DISABLE)",
        "ins1DelCode":"(constraint.getEnabled() ? \"ENABLE\" : \"DISABLE\")",
        "ins1PreCode":"new SQLDatabasePersistAction(\"Alter FK\", \"ALTER TABLE \" + constraint.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" MODIFY CONSTRAINT \" + constraint.getName() + \" \" + (constraint.getEnabled() ? \"ENABLE\" : \"DISABLE\") ) );",
        "ins2PreCode":"new SQLDatabasePersistAction(\"Alter PK\", \"ALTER TABLE \" + constraint.getTable().getFullyQualifiedName(DBPEvaluationContext.DDL) + \" MODIFY CONSTRAINT \" + constraint.getName() + \" \" + (constraint.getEnabled() ? \"ENABLE\" : \"DISABLE\") ); );",
        "label":1
    },
    {
        "ins1AddCode":"SpscArrayQueue<Object> q = new SpscArrayQueue<>(16);",
        "ins1DelCode":"SpscArrayQueue<Object> q = new SpscArrayQueue<Object>(16);",
        "ins1PreCode":"public void spscArrayQueueBiOffer() { SpscArrayQueue<Object> q = new SpscArrayQueue<Object>(16); q.offer(1, 2); ",
        "ins2PreCode":"public void spscLinkedArrayQueueBiOffer() { SpscLinkedArrayQueue<Object> q = new SpscLinkedArrayQueue<Object>(16); q.offer(1, 2);",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.locationNotFoundAction = locationNotFoundAction;",
        "ins1DelCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, boolean allLocationsOptional, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.allLocationsOptional = allLocationsOptional;",
        "ins1PreCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, boolean allLocationsOptional, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass()); this.allLocationsOptional = allLocationsOptional; Instantiator<ConfigDataLocationResolver<?>> instantiator = new Instantiator<>(ConfigDataLocationResolver.class, (availableParameters) -> {",
        "ins2PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, boolean allLocationsOptional, List<String> names) { ConfigDataLoaders(DeferredLogFactory logFactory, boolean allLocationsOptional, List<String> names) { this.logger = logFactory.getLog(getClass()); this.allLocationsOptional = allLocationsOptional; Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> availableParameters.add(Log.class, logFactory::getLog));",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), entry.getField(\"file\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), e.getField(\"file\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,file = {D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), e.getField(\"file\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,date = {1-4~} # nov}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"1-4~#nov#\"), e.getField(\"date\"));",
        "label":1
    },
    {
        "ins1AddCode":"expected.remove(IsbnViaOttoBibFetcher.class);",
        "ins1DelCode":"",
        "ins1PreCode":" expected.remove(IsbnViaChimboriFetcher.class); expected.remove(IsbnViaEbookDeFetcher.class); assertEquals(expected, getClasses(idFetchers));",
        "ins2PreCode":"expected.remove(SearchBasedParserFetcher.class); expected.remove(SearchBasedParserFetcher.class); assertEquals(expected, getClasses(searchBasedFetchers));",
        "label":1
    },
    {
        "ins1AddCode":"if (checkTerminate(d, q)) {",
        "ins1DelCode":"if (d && (q == null || q.isEmpty())) {",
        "ins1PreCode":" SpscLinkedArrayQueue<R> q = queue.get();  if (d && (q == null || q.isEmpty())) { errors.tryTerminateConsumer(downstream); return;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>(subscriber);",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>(subscriber);",
        "ins1PreCode":"PublishProcessor<String> r2 = PublishProcessor.create();  Subscriber<String> subscriber = TestHelper.mockSubscriber(); TestSubscriber<String> ts = new TestSubscriber<String>(subscriber);  Flowable.zip(r1, r2, zipr2).subscribe(ts);",
        "ins2PreCode":"PublishSubject<String> r2 = PublishSubject.create(); Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); Observable.zip(r1, r2, zipr2).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testDBCPThreads20Connections10Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "ins2PreCode":"public void testPoolThreads10Connections20Validate() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setTestOnBorrow(true);",
        "label":1
    },
    {
        "ins1AddCode":"void validateTokenShouldFetchTokenKeysIfNull() throws Exception {",
        "ins1DelCode":"public void validateTokenShouldFetchTokenKeysIfNull() throws Exception {",
        "ins1PreCode":"public void validateTokenShouldFetchTokenKeysIfNull() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS); given(this.securityService.getUaaUrl()).willReturn(\"http://localhost:8080/uaa\");",
        "ins2PreCode":"public void validateTokenWhenValidShouldNotFetchTokenKeys() throws Exception { verify(this.securityService, Mockito.never()).fetchTokenKeys(); given(this.securityService.getUaaUrl()).willReturn(\"http://localhost:8080/uaa\");",
        "label":1
    },
    {
        "ins1AddCode":"void lombokInnerClassProperties() {",
        "ins1DelCode":"public void lombokInnerClassProperties() {",
        "ins1PreCode":"public void lombokInnerClassProperties() { ConfigurationMetadata metadata = compile(LombokInnerClassProperties.class); assertThat(metadata).has(Metadata.withGroup(\"config\").fromSource(LombokInnerClassProperties.class));",
        "ins2PreCode":"public void innerClassProperties() { ConfigurationMetadata metadata = compile(InnerClassProperties.class); assertThat(metadata).has(Metadata.withGroup(\"config\").fromSource(InnerClassProperties.class));",
        "label":1
    },
    {
        "ins1AddCode":"void shouldPickSoleTypeHandlerOnXmlResultMap() {",
        "ins1DelCode":"public void shouldPickSoleTypeHandlerOnXmlResultMap() {",
        "ins1PreCode":"public void shouldPickSoleTypeHandlerOnXmlResultMap() { addMapper(); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() { addMapper(); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"new Publisher[] { Flowable.just(1L), Flowable.fromIterable(iterate(elements)) }, }",
        "ins1DelCode":"}, Flowable.just(1L), Flowable.fromIterable(iterate(elements))",
        "ins1PreCode":"public Long apply(Object[] a) throws Exception { return (Long)a[0]; } }, Flowable.just(1L), Flowable.fromIterable(iterate(elements)) ) ;",
        "ins2PreCode":"public Long apply(Object[] a) throws Exception { return (Long)a[0]; } }, Flowable.just(1L), Flowable.fromIterable(iterate(elements)) ) ;",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":" to = new TestObserverEx<Integer>();  to.onSubscribe(Disposables.empty());  to.onNext(null);",
        "ins2PreCode":"to = TestObserver.create(); to.onSubscribe(Disposables.empty()); to.onNext(null);",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(4, result.size()); Assertions.assertEquals(\"id\", result.get(\"property\")); Assertions.assertEquals(\"val1\", result.get(\"attr1\")); Assertions.assertEquals(\"val2\", result.get(\"attr2\")); Assertions.assertEquals(\"val3\", result.get(\"attr3\"));",
        "ins1DelCode":"Assert.assertEquals(4, result.size()); Assert.assertEquals(\"id\", result.get(\"property\")); Assert.assertEquals(\"val1\", result.get(\"attr1\")); Assert.assertEquals(\"val2\", result.get(\"attr2\")); Assert.assertEquals(\"val3\", result.get(\"attr3\"));",
        "ins1PreCode":"public void simplePropertyWithManyAttributes() { Map<String, String> result = new ParameterExpression(\"id, attr1=val1, attr2=val2, attr3=val3\"); Assert.assertEquals(4, result.size()); Assert.assertEquals(\"id\", result.get(\"property\")); Assert.assertEquals(\"val1\", result.get(\"attr1\")); Assert.assertEquals(\"val2\", result.get(\"attr2\")); Assert.assertEquals(\"val3\", result.get(\"attr3\"));",
        "ins2PreCode":"public void expressionWithManyAttributes() { Map<String, String> result = new ParameterExpression(\"(id.toString()), attr1=val1, attr2=val2, attr3=val3\"); Assert.assertEquals(4, result.size()); Assert.assertEquals(\"val1\", result.get(\"attr1\")); Assert.assertEquals(\"val1\", result.get(\"attr1\")); Assert.assertEquals(\"val2\", result.get(\"attr2\")); Assert.assertEquals(\"val3\", result.get(\"attr3\"));",
        "label":1
    },
    {
        "ins1AddCode":"public List<BibEntry> parseEntries(InputStream inputStream) {",
        "ins1DelCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException {",
        "ins1PreCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException { try { return importDatabase(",
        "ins2PreCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException { try { return Collections.emptyList();",
        "label":0
    },
    {
        "ins1AddCode":"Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null, null);",
        "ins1DelCode":"Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null);",
        "ins1PreCode":"public void testDependenciesFig3() {  Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null); Stream a = new Stream(Integer.valueOf(1), handler); Stream b = new Stream(Integer.valueOf(2), handler);",
        "ins2PreCode":"public void testDependenciesFig4() { Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null); Stream a = new Stream(Integer.valueOf(1), handler); Stream b = new Stream(Integer.valueOf(2), handler);",
        "label":1
    },
    {
        "ins1AddCode":"void servletPropertySourcesAreNotCopiedOverIfNotWebEnvironment() {",
        "ins1DelCode":"public void servletPropertySourcesAreNotCopiedOverIfNotWebEnvironment() {",
        "ins1PreCode":"public void servletPropertySourcesAreNotCopiedOverIfNotWebEnvironment() { StandardServletEnvironment standardServletEnvironment = new StandardServletEnvironment(); StandardEnvironment convertedEnvironment = this.environmentConverter",
        "ins2PreCode":"public void servletPropertySourcesArePresentWhenTypeToConvertIsWeb() { StandardEnvironment standardEnvironment = new StandardEnvironment(); StandardEnvironment convertedEnvironment = this.environmentConverter",
        "label":1
    },
    {
        "ins1AddCode":"DefaultIntervalXYDataset<String> dataset = new DefaultIntervalXYDataset<>();",
        "ins1DelCode":"DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset();",
        "ins1PreCode":"public void testIterateToFindDomainBounds_IntervalXYDataset() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {0.8, 3.2, 3.0}; double[] x1Start = new double[] {0.9, 1.9, 2.9};",
        "ins2PreCode":"public void testIterateToFindRangeBounds_IntervalXYDataset() { DefaultIntervalXYDataset dataset = new DefaultIntervalXYDataset(); double[] x1 = new double[] {0.8, 3.2, 3.0}; double[] x1Start = new double[] {0.9, 1.9, 2.9};",
        "label":1
    },
    {
        "ins1AddCode":"public void testPerformExportForSingleAuthor(@TempDir Path testFolder) throws Exception {",
        "ins1DelCode":"public void testPerformExportForSingleAuthor(@TempDirectory.TempDir Path testFolder) throws Exception {",
        "ins1PreCode":"public void testPerformExportForSingleAuthor(@TempDirectory.TempDir Path testFolder) throws Exception { Path path = testFolder.resolve(\"ThisIsARandomlyNamedFile\"); ",
        "ins2PreCode":"public void testPerformExportForMultipleAuthors(@TempDirectory.TempDir Path testFolder) throws Exception { Path path = testFolder.resolve(\"ThisIsARandomlyNamedFile\");",
        "label":1
    },
    {
        "ins1AddCode":"public Publisher<? extends Integer> apply(Integer v) { public Publisher<? extends Integer> apply(Integer v) { public Single<? extends Integer> apply(Integer v) {",
        "ins1DelCode":"public Publisher<? extends Integer> apply(Integer v) throws Exception { public Publisher<? extends Integer> apply(Integer v) throws Exception { public Single<? extends Integer> apply(Integer v) throws Exception {",
        "ins1PreCode":" flowablePlain = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.just(v); } });  flowableConvert = source.switchMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toFlowable(); } });  flowableDedicated = source.switchMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v); }",
        "ins2PreCode":"flowablePlain = source.concatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Flowable.just(v); } }); flowableConvert = source.concatMap(new Function<Integer, Publisher<? extends Integer>>() { @Override public Publisher<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toFlowable(); } }); flowableDedicated = source.concatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v); }",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void interruptTerminalEventAwait() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final Thread t0 = Thread.currentThread();",
        "ins2PreCode":"public void interruptTerminalEventAwaitTimed() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); final Thread t0 = Thread.currentThread();",
        "label":1
    },
    {
        "ins1AddCode":"if (!ObjectUtils.equal(this.y, that.y)) {",
        "ins1DelCode":"if (!ObjectUtilities.equal(this.y, that.y)) {",
        "ins1PreCode":"if (!this.x.equals(that.x)) { return false; } if (!ObjectUtilities.equal(this.y, that.y)) { return false; }",
        "ins2PreCode":"if (!this.x.equals(that.x)) { return false; } if (!ObjectUtilities.equal(this.obj, that.obj)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"public void onError(@NonNull Throwable t) {",
        "ins1DelCode":"public void onError(Throwable t) {",
        "ins1PreCode":"public void onError(Throwable t) { if (!checkSubscriptionOnce) { checkSubscriptionOnce = true;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Context ctx = tomcat.addContext(\"\", null);",
        "ins1DelCode":"Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));",
        "ins1PreCode":"new JreMemoryLeakPreventionListener());   Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));  Tomcat.addServlet(ctx, \"leakServlet1\",",
        "ins2PreCode":"new JreMemoryLeakPreventionListener()); Context ctx = tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\")); Tomcat.addServlet(ctx, \"leakServlet2\",",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(Integer.valueOf(2), user.getId()); Assertions.assertEquals(\"User2\", user.getName()); Assertions.assertEquals(\"Chien\", user.getPets().get(0).getPetName()); Assertions.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName());",
        "ins1DelCode":"Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(\"Chien\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_Inline(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(\"Chien\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_External(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertEquals(\"Chien\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); }",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Object> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Object> to = new TestObserverEx<Object>();",
        "ins1PreCode":"public void errorReceived() { TestObserverEx<Object> to = new TestObserverEx<Object>(); TestException ex = new TestException(\"boo\"); Flowable.error(ex).ignoreElements().subscribe(to);",
        "ins2PreCode":"public void errorReceived() { TestObserverEx<Object> to = new TestObserverEx<Object>(); TestException ex = new TestException(\"boo\"); Observable.error(ex).ignoreElements().subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"final List<Throwable> errors = new ArrayList<>();",
        "ins1DelCode":"final List<Throwable> errors = new ArrayList<Throwable>();",
        "ins1PreCode":"public void mapWithError() { final List<Throwable> errors = new ArrayList<Throwable>();  Flowable<String> w = Flowable.just(\"one\", \"fail\", \"two\", \"three\", \"fail\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void merge10AsyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(10, 1000).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge1000AsyncStreamOf1000() { TestObserver<Integer> to = new TestObserver<Integer>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"void completeReturnsWholeFieldValue() { database.insertEntry(entry); Collection<String> result = autoCompleter.provideSuggestions(getRequest((\"te\")));",
        "ins1DelCode":"public void completeReturnsWholeFieldValue() { autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"te\")));",
        "ins1PreCode":"public void completeReturnsWholeFieldValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"test value\"); autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"te\"))); assertEquals(Collections.singletonList(\"test value\"), result);",
        "ins2PreCode":"public void completeValueReturnsValue() { BibEntry entry = new BibEntry(); entry.setField(StandardField.TITLE, \"testValue\"); autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"testValue\"))); assertEquals(Arrays.asList(\"testValue\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"Set<IdBasedFetcher> idFetchers = WebFetchers.getIdBasedFetchers(importFormatPreferences);",
        "ins1DelCode":"List<IdBasedFetcher> idFetchers = WebFetchers.getIdBasedFetchers(importFormatPreferences);",
        "ins1PreCode":"void getIdBasedFetchersReturnsAllFetcherDerivingFromIdBasedFetcher() throws Exception { List<IdBasedFetcher> idFetchers = WebFetchers.getIdBasedFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) {",
        "ins2PreCode":"void getSearchBasedFetchersReturnsAllFetcherDerivingFromSearchBasedFetcher() throws Exception { List<SearchBasedFetcher> searchBasedFetchers = WebFetchers.getSearchBasedFetchers(importFormatPreferences); try (ScanResult scanResult = classGraph.scan()) {",
        "label":1
    },
    {
        "ins1AddCode":"for (Thread thread : threads) { thread.start();",
        "ins1DelCode":"for (Thread value : threads) { value.start();",
        "ins1PreCode":"} }; } for (Thread value : threads) { value.start(); } for (Thread thread : threads) {",
        "ins2PreCode":"} }; } for (Thread value : threads) { value.start(); } for (Thread thread : threads) {",
        "label":1
    },
    {
        "ins1AddCode":"Map<Object, ReportSet> merged = new LinkedHashMap<>( ( src.size() + tgt.size() ) * 2 ); target.setReportSets( new ArrayList<>( merged.values() ) );",
        "ins1DelCode":"Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 ); target.setReportSets( new ArrayList<ReportSet>( merged.values() ) );",
        "ins1PreCode":"if ( !src.isEmpty() ) { List<ReportSet> tgt = target.getReportSets(); Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 );  for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); merged.put( key, element ); }  for ( ReportSet element : src ) { Object key = getReportSetKey( element ); ReportSet existing = merged.get( key ); if ( existing != null ) { mergeReportSet( existing, element, sourceDominant, context ); } else { merged.put( key, element ); } }  target.setReportSets( new ArrayList<ReportSet>( merged.values() ) ); }",
        "ins2PreCode":"if ( !src.isEmpty() ) { List<ReportSet> tgt = target.getReportSets(); Map<Object, ReportSet> merged = new LinkedHashMap<Object, ReportSet>( ( src.size() + tgt.size() ) * 2 ); for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); merged.put( key, element ); } for ( ReportSet element : tgt ) { Object key = getReportSetKey( element ); ReportSet existing = merged.get( key ); if ( existing != null ) { mergeReportSet( element, existing, sourceDominant, context ); } merged.put( key, rset ); { merged.put( key, element ); } } target.setReportSets( new ArrayList<ReportSet>( merged.values() ) ); }",
        "label":1
    },
    {
        "ins1AddCode":"if (c == -1) { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); } else if (r == -1) { throw new UnknownKeyException(\"Unknown rowKey: \" + rowKey); } else {",
        "ins1DelCode":"if (c != -1) { else { throw new UnknownKeyException(\"Unknown columnKey: \" + columnKey); }",
        "ins1PreCode":"public Number getPercentComplete(Comparable rowKey, Comparable columnKey) { int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getPercentComplete(r, c + this.firstCategoryIndex);",
        "ins2PreCode":"public Number getPercentComplete(Comparable rowKey, Comparable columnKey, int r = getRowIndex(rowKey); int c = getColumnIndex(columnKey); if (c != -1) { return this.underlying.getPercentComplete(r, c + this.firstCategoryIndex, subinterval);",
        "label":0
    },
    {
        "ins1AddCode":"UnsafeRow rowCopy = new UnsafeRow(numFields); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);",
        "ins1DelCode":"UnsafeRow rowCopy = new UnsafeRow(); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, numFields, sizeInBytes);",
        "ins1PreCode":"public UnsafeRow copy() { UnsafeRow rowCopy = new UnsafeRow(); final byte[] rowDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, rowDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes ); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); return rowCopy;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public List<BibEntry> parseEntries(InputStream inputStream) {",
        "ins1DelCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException {",
        "ins1PreCode":"public List<BibEntry> parseEntries(InputStream inputStream) throws ParseException { try { return importDatabase(",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"WsContextListener.class.getName(), false));",
        "ins1DelCode":"WsListener.class.getName(), false));",
        "ins1PreCode":"Tomcat.addServlet(ctx, \"webdav\", new WebdavServlet()); ctx.addServletMapping(\"/webdav/*\", \"webdav\"); ctx.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false));  tomcat.start();",
        "ins2PreCode":"Tomcat.addServlet(ctx, \"default2\", new DefaultServlet()); ctx.addServletMapping(\"/servlets/*\", \"default2\"); ctx.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false)); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"when(preferences.shouldSaveInOriginalOrder()).thenReturn(true);",
        "ins1DelCode":"when(preferences.isSaveInOriginalOrder()).thenReturn(true);",
        "ins1PreCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData()); ",
        "ins2PreCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding)); when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "label":1
    },
    {
        "ins1AddCode":"String getQualifiedName(Element element) {",
        "ins1DelCode":"public String getQualifiedName(Element element) {",
        "ins1PreCode":"public String getQualifiedName(Element element) { if (element == null) { return null;",
        "ins2PreCode":"static String getQualifiedName(Element element) { if (element != null) { return null;",
        "label":0
    },
    {
        "ins1AddCode":"if (IS_NETWARE) { if (IS_AIX) { jExecutable = findInDir(JAVA_HOME + \"/sh\", command); jExecutable = findInDir(JAVA_HOME + \"/bin\", command);",
        "ins1DelCode":"if (isNetware) { if (isAix) { jExecutable = findInDir(javaHome + \"/sh\", command); jExecutable = findInDir(javaHome + \"/bin\", command);",
        "ins1PreCode":"public static String getJreExecutable(String command) { if (isNetware) {     return command; }  File jExecutable = null;  if (isAix) {   jExecutable = findInDir(javaHome + \"/sh\", command); }  if (jExecutable == null) { jExecutable = findInDir(javaHome + \"/bin\", command); } ",
        "ins2PreCode":"public static String getJdkExecutable(String command) { if (isNetware) { return command; } File jExecutable = null; if (isAix) { jExecutable = findInDir(javaHome + \"/../sh\", command); } if (jExecutable == null) { jExecutable = findInDir(javaHome + \"/../bin\", command); }",
        "label":1
    },
    {
        "ins1AddCode":"settings = createSettings(); settings = createBuilderWithPort().put(httpMaxInitialLineLengthSetting.getKey(), maxInitialLineLength + \"b\").build();",
        "ins1DelCode":"settings = Settings.EMPTY; settings = Settings.builder().put(httpMaxInitialLineLengthSetting.getKey(), maxInitialLineLength + \"b\").build();",
        "ins1PreCode":"final Setting<ByteSizeValue> httpMaxInitialLineLengthSetting = HttpTransportSettings.SETTING_HTTP_MAX_INITIAL_LINE_LENGTH; if (randomBoolean()) { maxInitialLineLength = httpMaxInitialLineLengthSetting.getDefault(Settings.EMPTY).bytesAsInt(); settings = Settings.EMPTY; } else { maxInitialLineLength = randomIntBetween(1, 8192); settings = Settings.builder().put(httpMaxInitialLineLengthSetting.getKey(), maxInitialLineLength + \"b\").build(); } ",
        "ins2PreCode":"final Setting<ByteSizeValue> httpMaxInitialLineLengthSetting = HttpTransportSettings.SETTING_HTTP_MAX_INITIAL_LINE_LENGTH; if (randomBoolean()) { maxInitialLineLength = httpMaxInitialLineLengthSetting.getDefault(Settings.EMPTY).bytesAsInt(); settings = Settings.EMPTY; } else { maxInitialLineLength = randomIntBetween(1, 8192); settings = Settings.builder().put(httpMaxInitialLineLengthSetting.getKey(), maxInitialLineLength + \"b\").build(); }",
        "label":1
    },
    {
        "ins1AddCode":"if (process.execute() != 0) {",
        "ins1DelCode":"if (Execute.isFailure(process.execute())) {",
        "ins1PreCode":"process.setCommandline(cmdl.getCommandline());  try { if (Execute.isFailure(process.execute())) { throw new BuildException(\"JJTree failed.\"); }",
        "ins2PreCode":"process.setCommandline(cmdl.getCommandline()); try { if (Execute.isFailure(process.execute())) { throw new BuildException(\"JJDoc failed.\"); }",
        "label":1
    },
    {
        "ins1AddCode":"IntervalBarRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"IntervalBarRenderer r2 = (IntervalBarRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalBarRenderer r1 = new IntervalBarRenderer(); IntervalBarRenderer r2 = (IntervalBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Engine.Builder engineBuilder = vehicleBuilder.getEngineBuilder().setLiters(20); engineBuilder.setLiters(50); assertEquals(50, vehicleBuilder.getEngine().getLiters());",
        "ins1DelCode":"vehicleBuilder.getEngineBuilder().setLiters(20);",
        "ins1PreCode":"for (int i = 0; i < 4; i++) { vehicleBuilder.getWheelBuilder(i).setRadius(5).setWidth(i + 10); } vehicleBuilder.getEngineBuilder().setLiters(20);  vehicle = vehicleBuilder.build();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"long waitTime = System.currentTimeMillis(); updateStatsBorrow(p, System.currentTimeMillis() - waitTime);",
        "ins1DelCode":"long waitTime = 0; waitTime = System.currentTimeMillis(); waitTime = System.currentTimeMillis() - waitTime; updateStatsBorrow(p, waitTime);",
        "ins1PreCode":"boolean blockWhenExhausted = getBlockWhenExhausted();  boolean create; long waitTime = 0;  while (p == null) { create = false; if (blockWhenExhausted) { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = idleObjects.takeFirst(); } else { waitTime = System.currentTimeMillis(); p = idleObjects.pollFirst(borrowMaxWaitMillis, TimeUnit.MILLISECONDS); waitTime = System.currentTimeMillis() - waitTime; } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = idleObjects.pollFirst(); if (p == null) { create = true; p = create(); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } }  if (p != null) { try { factory.activateObject(p); } catch (Exception e) { try { destroy(p); } catch (Exception e1) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(p); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) {  } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } }  updateStatsBorrow(p, waitTime);  return p.getObject();",
        "ins2PreCode":"boolean blockWhenExhausted = getBlockWhenExhausted(); boolean create; long waitTime = 0; while (p == null) { create = false; if (blockWhenExhausted) { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { if (borrowMaxWaitMillis < 0) { p = objectDeque.getIdleObjects().takeFirst(); } else { waitTime = System.currentTimeMillis(); if (borrowMaxWaitMillis < 0) { borrowMaxWaitMillis, TimeUnit.MILLISECONDS); waitTime = System.currentTimeMillis() - waitTime; } } if (p == null) { throw new NoSuchElementException( \"Timeout waiting for idle object\"); } if (!p.allocate()) { p = null; } } else { p = objectDeque.getIdleObjects().pollFirst(); if (p == null) { create = true; p = create(key); } if (p == null) { throw new NoSuchElementException(\"Pool exhausted\"); } if (!p.allocate()) { p = null; } } if (p != null) { try { factory.activateObject(key, p); } catch (Exception e) { try { destroy(key, p, true); } catch (Exception e1) { } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to activate object\"); nsee.initCause(e); throw nsee; } } if (p != null && (getTestOnBorrow() || create && getTestOnCreate())) { boolean validate = false; Throwable validationThrowable = null; try { validate = factory.validateObject(key, p); } catch (Throwable t) { PoolUtils.checkRethrow(t); validationThrowable = t; } if (!validate) { try { destroy(key, p, true); destroyedByBorrowValidationCount.incrementAndGet(); } catch (Exception e) { } p = null; if (create) { NoSuchElementException nsee = new NoSuchElementException( \"Unable to validate object\"); nsee.initCause(validationThrowable); throw nsee; } } } } } updateStatsBorrow(p, waitTime); return p.getObject();",
        "label":1
    },
    {
        "ins1AddCode":"if (array[icounter] != null && array[icounter].isDirectory()) { if (!\".\".equals(array[icounter].getName()) candidateFound = true; target = fiddleName(array[icounter].getName()); task.log(\"will try to cd to \" target + \" where a directory called \" + array[icounter].getName() + target + \" where a directory called \" + array[icounter].getName() \" exists\", Project.MSG_DEBUG); + \" exists\", Project.MSG_DEBUG); for (int pcounter = 0; pcounter < array.length; pcounter++) { if (array[pcounter] != null candidateFound = false; break; } } if (candidateFound) {",
        "ins1DelCode":"if (array[icounter] != null && array[icounter].isDirectory() && !\".\".equals(array[icounter].getName()) candidateFound = true; target = fiddleName(array[icounter].getName()); task.log(\"will try to cd to \" + target + \" where a directory called \" + array[icounter].getName() + \" exists\", Project.MSG_DEBUG); for (int pcounter = 0; pcounter < array.length; pcounter++) { if (array[pcounter] != null candidateFound = false; } if (candidateFound) { break;",
        "ins1PreCode":"boolean candidateFound = false; String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory() && !\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) { candidateFound = true;",
        "ins2PreCode":"boolean candidateFound = false; String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory() && !\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) { candidateFound = true;",
        "label":1
    },
    {
        "ins1AddCode":"fireTreeNodesChanged(this, path, childIndices, children);",
        "ins1DelCode":"fireNodesChanged(path, childIndices, children);",
        "ins1PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesChanged(path, childIndices, children); }",
        "ins2PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesInserted(path, childIndices, children); }",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(StandardField.AUTHOR));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"author\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"author\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test and Second Author and Third Author\"), entry.getField(\"editor\"));",
        "label":1
    },
    {
        "ins1AddCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(paddedBytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1DelCode":"HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1PreCode":"System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length);  Assert.assertEquals( HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));  hashcodes.add(HiveHasher.hashUnsafeBytes( paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); } ",
        "ins2PreCode":"System.arraycopy(strBytes, 0, paddedBytes, 0, strBytes.length); Assert.assertEquals( hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), hasher.hashUnsafeWords(paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(hasher.hashUnsafeWords( paddedBytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); }",
        "label":1
    },
    {
        "ins1AddCode":"void shouldFlushAllItemsOnDemand() {",
        "ins1DelCode":"public void shouldFlushAllItemsOnDemand() {",
        "ins1PreCode":"public void shouldFlushAllItemsOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\")); for (int i = 0; i < 5; i++) {",
        "ins2PreCode":"public void shouldFlushAllItemsOnDemand() { Cache cache = new LruCache(new PerpetualCache(\"default\")); for (int i = 0; i < 5; i++) {",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 100; ++i) { String results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertEquals(sb.toString(), results);",
        "ins1DelCode":"for(int i=0; i < 100;++i) { String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]);",
        "ins1PreCode":"TextLineDecoder decoder = new TextLineDecoder(); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "ins2PreCode":"TextLineDecoder decoder = new TextLineDecoder(); Context context = decoder.createDecoderState(); StringBuffer sb = new StringBuffer(); for(int i=0; i < 100;++i) { sb.append(\"a string\"); } String[] results = decoder.decode(ByteBuffer.wrap((sb.toString() + \"\\r\\n\").getBytes()), context); assertNotNull(results); assertEquals(1, results.length); assertEquals(sb.toString(), results[0]); assertEquals(0, context.getBuffer().position());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"} int num = (int) (Flowable.bufferSize() * 1.1); AtomicInteger c = new AtomicInteger(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); firehose(c).onBackpressureDrop() .observeOn(Schedulers.computation())",
        "ins2PreCode":"} int num = (int) (Flowable.bufferSize() * 1.1); AtomicInteger c = new AtomicInteger(); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); firehose(c).onBackpressureDrop() assertEquals(num, onNextEvents.size());",
        "label":1
    },
    {
        "ins1AddCode":"addTableCell(result, row, getField(e, InternalField.KEY_FIELD)); addTableCell(result, row, new GetOpenOfficeType().format(e.getType().getName())); addTableCell(result, row, getField(e, StandardField.ADDRESS)); addTableCell(result, row, getField(e, StandardField.ASSIGNEE)); addTableCell(result, row, getField(e, StandardField.ANNOTE)); addTableCell(result, row, getField(e, StandardField.AUTHOR)); addTableCell(result, row, getField(e, StandardField.BOOKTITLE)); addTableCell(result, row, getField(e, StandardField.CHAPTER)); addTableCell(result, row, getField(e, StandardField.DAY)); addTableCell(result, row, getField(e, StandardField.DAYFILED)); addTableCell(result, row, getField(e, StandardField.EDITION)); addTableCell(result, row, getField(e, StandardField.EDITOR)); addTableCell(result, row, getField(e, StandardField.HOWPUBLISHED)); addTableCell(result, row, getField(e, StandardField.INSTITUTION)); addTableCell(result, row, getField(e, StandardField.JOURNAL)); addTableCell(result, row, getField(e, StandardField.LANGUAGE)); addTableCell(result, row, getField(e, StandardField.MONTH)); addTableCell(result, row, getField(e, StandardField.MONTHFILED)); addTableCell(result, row, getField(e, StandardField.NATIONALITY)); addTableCell(result, row, getField(e, StandardField.NOTE)); addTableCell(result, row, getField(e, StandardField.NUMBER)); addTableCell(result, row, getField(e, StandardField.ORGANIZATION)); addTableCell(result, row, getField(e, StandardField.PAGES)); addTableCell(result, row, getField(e, StandardField.PUBLISHER)); addTableCell(result, row, getField(e, StandardField.REVISION)); addTableCell(result, row, getField(e, StandardField.SCHOOL)); addTableCell(result, row, getField(e, StandardField.SERIES)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, StandardField.TITLE)))); addTableCell(result, row, getField(e, new UnknownField(\"reporttype\"))); addTableCell(result, row, getField(e, StandardField.VOLUME)); addTableCell(result, row, getField(e, StandardField.YEAR)); addTableCell(result, row, getField(e, StandardField.YEARFILED)); addTableCell(result, row, getField(e, StandardField.URL)); addTableCell(result, row, getField(e, StandardField.ISBN));",
        "ins1DelCode":"addTableCell(result, row, getField(e, BibEntry.KEY_FIELD)); addTableCell(result, row, new GetOpenOfficeType().format(e.getType())); addTableCell(result, row, getField(e, FieldName.ADDRESS)); addTableCell(result, row, getField(e, FieldName.ASSIGNEE)); addTableCell(result, row, getField(e, FieldName.ANNOTE)); addTableCell(result, row, getField(e, FieldName.AUTHOR)); addTableCell(result, row, getField(e, FieldName.BOOKTITLE)); addTableCell(result, row, getField(e, FieldName.CHAPTER)); addTableCell(result, row, getField(e, FieldName.DAY)); addTableCell(result, row, getField(e, FieldName.DAYFILED)); addTableCell(result, row, getField(e, FieldName.EDITION)); addTableCell(result, row, getField(e, FieldName.EDITOR)); addTableCell(result, row, getField(e, FieldName.HOWPUBLISHED)); addTableCell(result, row, getField(e, FieldName.INSTITUTION)); addTableCell(result, row, getField(e, FieldName.JOURNAL)); addTableCell(result, row, getField(e, FieldName.LANGUAGE)); addTableCell(result, row, getField(e, FieldName.MONTH)); addTableCell(result, row, getField(e, FieldName.MONTHFILED)); addTableCell(result, row, getField(e, FieldName.NATIONALITY)); addTableCell(result, row, getField(e, FieldName.NOTE)); addTableCell(result, row, getField(e, FieldName.NUMBER)); addTableCell(result, row, getField(e, FieldName.ORGANIZATION)); addTableCell(result, row, getField(e, FieldName.PAGES)); addTableCell(result, row, getField(e, FieldName.PUBLISHER)); addTableCell(result, row, getField(e, FieldName.REVISION)); addTableCell(result, row, getField(e, FieldName.SCHOOL)); addTableCell(result, row, getField(e, FieldName.SERIES)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, FieldName.TITLE)))); addTableCell(result, row, getField(e, \"reporttype\")); addTableCell(result, row, getField(e, FieldName.VOLUME)); addTableCell(result, row, getField(e, FieldName.YEAR)); addTableCell(result, row, getField(e, FieldName.YEARFILED)); addTableCell(result, row, getField(e, FieldName.URL)); addTableCell(result, row, getField(e, FieldName.ISBN));",
        "ins1PreCode":" for (BibEntry e : entries) { row = result.createElement(\"table:table-row\"); addTableCell(result, row, getField(e, BibEntry.KEY_FIELD)); addTableCell(result, row, new GetOpenOfficeType().format(e.getType())); addTableCell(result, row, getField(e, FieldName.ADDRESS)); addTableCell(result, row, getField(e, FieldName.ASSIGNEE)); addTableCell(result, row, getField(e, FieldName.ANNOTE)); addTableCell(result, row, getField(e, FieldName.AUTHOR)); addTableCell(result, row, getField(e, FieldName.BOOKTITLE)); addTableCell(result, row, getField(e, FieldName.CHAPTER)); addTableCell(result, row, getField(e, FieldName.DAY)); addTableCell(result, row, getField(e, FieldName.DAYFILED)); addTableCell(result, row, getField(e, FieldName.EDITION)); addTableCell(result, row, getField(e, FieldName.EDITOR)); addTableCell(result, row, getField(e, FieldName.HOWPUBLISHED)); addTableCell(result, row, getField(e, FieldName.INSTITUTION)); addTableCell(result, row, getField(e, FieldName.JOURNAL)); addTableCell(result, row, getField(e, FieldName.LANGUAGE)); addTableCell(result, row, getField(e, FieldName.MONTH)); addTableCell(result, row, getField(e, FieldName.MONTHFILED)); addTableCell(result, row, getField(e, FieldName.NATIONALITY)); addTableCell(result, row, getField(e, FieldName.NOTE)); addTableCell(result, row, getField(e, FieldName.NUMBER)); addTableCell(result, row, getField(e, FieldName.ORGANIZATION)); addTableCell(result, row, getField(e, FieldName.PAGES)); addTableCell(result, row, getField(e, FieldName.PUBLISHER)); addTableCell(result, row, getField(e, FieldName.REVISION)); addTableCell(result, row, getField(e, FieldName.SCHOOL)); addTableCell(result, row, getField(e, FieldName.SERIES)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, FieldName.TITLE)))); addTableCell(result, row, getField(e, \"reporttype\")); addTableCell(result, row, getField(e, FieldName.VOLUME)); addTableCell(result, row, getField(e, FieldName.YEAR)); addTableCell(result, row, getField(e, FieldName.YEARFILED)); addTableCell(result, row, getField(e, FieldName.URL)); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, getField(e, FieldName.ISBN)); table.appendChild(row); }",
        "ins2PreCode":"for (BibEntry e : entries) { row = result.createElement(\"table:table-row\"); addTableCell(result, row, getField(e, BibEntry.KEY_FIELD)); addTableCell(result, row, new GetOpenOfficeType().format(e.getType())); addTableCell(result, row, getField(e, FieldName.ADDRESS)); addTableCell(result, row, getField(e, FieldName.ASSIGNEE)); addTableCell(result, row, getField(e, FieldName.ANNOTE)); addTableCell(result, row, getField(e, FieldName.AUTHOR)); addTableCell(result, row, getField(e, FieldName.BOOKTITLE)); addTableCell(result, row, getField(e, FieldName.CHAPTER)); addTableCell(result, row, getField(e, FieldName.DAY)); addTableCell(result, row, getField(e, FieldName.DAYFILED)); addTableCell(result, row, getField(e, FieldName.EDITION)); addTableCell(result, row, getField(e, FieldName.EDITOR)); addTableCell(result, row, getField(e, FieldName.HOWPUBLISHED)); addTableCell(result, row, getField(e, FieldName.INSTITUTION)); addTableCell(result, row, getField(e, FieldName.JOURNAL)); addTableCell(result, row, getField(e, FieldName.LANGUAGE)); addTableCell(result, row, getField(e, FieldName.MONTH)); addTableCell(result, row, getField(e, FieldName.MONTHFILED)); addTableCell(result, row, getField(e, FieldName.NATIONALITY)); addTableCell(result, row, getField(e, FieldName.NOTE)); addTableCell(result, row, getField(e, FieldName.NUMBER)); addTableCell(result, row, getField(e, FieldName.ORGANIZATION)); addTableCell(result, row, getField(e, FieldName.PAGES)); addTableCell(result, row, getField(e, FieldName.PUBLISHER)); addTableCell(result, row, getField(e, FieldName.REVISION)); addTableCell(result, row, getField(e, FieldName.SCHOOL)); addTableCell(result, row, getField(e, FieldName.SERIES)); addTableCell(result, row, new RemoveWhitespace().format(new RemoveBrackets().format(getField(e, FieldName.TITLE)))); addTableCell(result, row, getField(e, \"reporttype\")); addTableCell(result, row, getField(e, FieldName.VOLUME)); addTableCell(result, row, getField(e, FieldName.YEAR)); addTableCell(result, row, getField(e, FieldName.YEARFILED)); addTableCell(result, row, getField(e, FieldName.URL)); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, \"\"); addTableCell(result, row, getField(e, FieldName.ISBN)); table.appendChild(row); }",
        "label":1
    },
    {
        "ins1AddCode":"ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\")));",
        "ins1DelCode":"ds.setBasedir(new File(getProject().getProperty(\"output\")));",
        "ins1PreCode":"public void testExcludeHasPrecedence() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] { \"alpha/**\"",
        "ins2PreCode":"public void testAlternateIncludeExclude() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] { \"alpha/**\",",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(); TestObserverEx<Integer> to2 = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(); TestObserverEx<Integer> to2 = new TestObserverEx<Integer>();",
        "ins1PreCode":".concatWith(Observable.<Integer>error(new TestException())) .replay().autoConnect();  TestObserverEx<Integer> to = new TestObserverEx<Integer>(); source.subscribe(to);  to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); to.assertNotComplete(); Assert.assertEquals(1, to.errors().size());  TestObserverEx<Integer> to2 = new TestObserverEx<Integer>(); source.subscribe(to2); ",
        "ins2PreCode":".concatWith(Observable.<Integer>error(new TestException())) .replay().autoConnect(); TestObserverEx<Integer> to = new TestObserverEx<Integer>(); source.subscribe(to); to.assertValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); to.assertNotComplete(); Assert.assertEquals(1, to.errors().size()); TestObserverEx<Integer> to2 = new TestObserverEx<Integer>(); source.subscribe(to2);",
        "label":1
    },
    {
        "ins1AddCode":"StandardXYToolTipGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"StandardXYToolTipGenerator g2 = (StandardXYToolTipGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { StandardXYToolTipGenerator g1 = new StandardXYToolTipGenerator(); StandardXYToolTipGenerator g2 = (StandardXYToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { = new StandardCategoryItemLabelGenerator(); = (StandardCategoryItemLabelGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"ScriptProcessor processor = factory.create(null, randomAlphaOfLength(10), null, configMap);",
        "ins1DelCode":"ScriptProcessor processor = factory.create(null, randomAlphaOfLength(10), configMap);",
        "ins1PreCode":"Map<String, Object> configMap = new HashMap<>(); String randomType = randomFrom(\"id\", \"source\"); configMap.put(randomType, \"foo\"); ScriptProcessor processor = factory.create(null, randomAlphaOfLength(10), configMap); assertThat(processor.getScript().getLang(), equalTo(randomType.equals(\"id\") ? null : Script.DEFAULT_SCRIPT_LANG)); assertThat(processor.getScript().getType().toString(), equalTo(INGEST_SCRIPT_PARAM_TO_TYPE.get(randomType)));",
        "ins2PreCode":"Map<String, Object> configMap = new HashMap<>(); String randomType = randomFrom(\"id\", \"source\"); configMap.put(randomType, \"foo\"); ScriptProcessor processor = factory.create(null, randomAlphaOfLength(10), configMap); assertThat(processor.getScript().getLang(), equalTo(randomType.equals(\"id\") ? null : Script.DEFAULT_SCRIPT_LANG)); assertThat(processor.getScript().getType().toString(), equalTo(INGEST_SCRIPT_PARAM_TO_TYPE.get(randomType)));",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"client.setPort(getPort());",
        "ins1PreCode":"public Exception doAbortedUploadTest(AbortedUploadClient client, boolean limited, boolean swallow) { client.setPort(getPort()); Exception ex = client.doRequest(limited, swallow); if (log.isDebugEnabled()) {",
        "ins2PreCode":"public Exception doAbortedPOSTTest(AbortedPOSTClient client, int status, boolean swallow) { client.setPort(getPort()); Exception ex = client.doRequest(status, swallow); if (log.isDebugEnabled()) {",
        "label":1
    },
    {
        "ins1AddCode":"List<String> profileNames = new ArrayList<>();",
        "ins1DelCode":"List<String> profileNames = new ArrayList<String>();",
        "ins1PreCode":"this.action.begin(this.interpretationContext, null, this.attributes); ArgumentCaptor<Profiles> profiles = ArgumentCaptor.forClass(Profiles.class); verify(this.environment).acceptsProfiles(profiles.capture()); List<String> profileNames = new ArrayList<String>(); profiles.getValue().matches((profile) -> { profileNames.add(profile);",
        "ins2PreCode":"this.action.begin(this.interpretationContext, null, this.attributes); ArgumentCaptor<Profiles> profiles = ArgumentCaptor.forClass(Profiles.class); verify(this.environment).acceptsProfiles(profiles.capture()); List<String> profileNames = new ArrayList<String>(); profiles.getValue().matches((profile) -> { profileNames.add(profile);",
        "label":1
    },
    {
        "ins1AddCode":"final String packageName = getPackage(); if (!packageName.isEmpty()) { name = packageName + '.' + name;",
        "ins1DelCode":"if (getPackage().length() > 0) { name = getPackage() + '.' + name;",
        "ins1PreCode":"if (name.indexOf('.') != -1) { return null; } if (getPackage().length() > 0) { name = getPackage() + '.' + name; } final GenericDescriptor result = pool.findSymbol(name);",
        "ins2PreCode":"if (name.indexOf('.') != -1) { return null; } if (getPackage().length() > 0) { name = getPackage() + '.' + name; } final GenericDescriptor result = pool.findSymbol(name);",
        "label":1
    },
    {
        "ins1AddCode":"channelPinger.install(mockChannel, null); ChannelPinger.setUpPingForChannel(mockChannel, null, ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 420, true);",
        "ins1DelCode":"channelPinger.install(mockChannel); ChannelPinger.setUpPingForChannel(mockChannel, ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 420, true);",
        "ins1PreCode":"System.setProperty(\"hudson.slaves.ChannelPinger.pingInterval\", \"7\");  ChannelPinger channelPinger = new ChannelPinger(); channelPinger.install(mockChannel);  verify(mockChannel).call(eq(new ChannelPinger.SetUpRemotePing(ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 420))); verifyStatic(); ChannelPinger.setUpPingForChannel(mockChannel, ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 420, true);",
        "ins2PreCode":"System.setProperty(\"hudson.slaves.ChannelPinger.pingInterval\", \"7\"); ChannelPinger channelPinger = new ChannelPinger(); channelPinger.install(mockChannel); verify(mockChannel).call(eq(new ChannelPinger.SetUpRemotePing(ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 73))); verifyStatic(); ChannelPinger.setUpPingForChannel(mockChannel, ChannelPinger.PING_TIMEOUT_SECONDS_DEFAULT, 73, true);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":".timeout(Functions.justFunction(new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\")); observer.onNext(2);",
        "ins2PreCode":".timeout(Functions.justFunction(new Observable<Integer>() { @Override protected void subscribeActual(Observer<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); observer.onError(new TestException(\"First\")); observer.onNext(2);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.of(SearchRules.SearchFlags.REGULAR_EXPRESSION));",
        "ins1DelCode":"TextFlow description = createDescription(query, false, true);",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the regular expression \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, true);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private static void exportOpenDocumentSpreadsheet(Path file, BibDatabase database, List<BibEntry> entries)",
        "ins1DelCode":"private static void exportOpenDocumentSpreadsheet(File file, BibDatabase database, List<BibEntry> entries)",
        "ins1PreCode":"private static void exportOpenDocumentSpreadsheet(File file, BibDatabase database, List<BibEntry> entries) throws IOException { ",
        "ins2PreCode":"private static void exportOpenOfficeCalc(File file, BibDatabase database, List<BibEntry> entries) throws Exception { private static void exportOpenOfficeCalc(File file, BibDatabase database, List<BibEntry> entries) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ObservableSwitchMap<>(this, mapper, bufferSize, false));",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, false));",
        "ins1PreCode":"} return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, false));",
        "ins2PreCode":"} return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableSwitchMap<T, R>(this, mapper, bufferSize, true));",
        "label":1
    },
    {
        "ins1AddCode":"TimeSeries<String> series = new TimeSeries<>(\"Test Series\"); TimeSeries<String> clone = CloneUtils.clone(series);",
        "ins1DelCode":"TimeSeries series = new TimeSeries(\"Test Series\"); TimeSeries clone = CloneUtils.clone(series);",
        "ins1PreCode":"public void testClone() throws CloneNotSupportedException { TimeSeries series = new TimeSeries(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42);  TimeSeries clone = CloneUtils.clone(series); clone.setKey(\"Clone Series\"); clone.update(jan1st2002, 10);",
        "ins2PreCode":"public void testClone() throws CloneNotSupportedException { TimePeriodValues series = new TimePeriodValues(\"Test Series\"); RegularTimePeriod jan1st2002 = new Day(1, MonthConstants.JANUARY, 2002); series.add(jan1st2002, 42); TimePeriodValues clone = (TimePeriodValues) series.clone(); clone.setKey(\"Clone Series\"); clone.update(0, 10);",
        "label":0
    },
    {
        "ins1AddCode":"range.getLowerBound(), range.getLowerBound() <= -30); range.getUpperBound(), range.getUpperBound() >= 30); assertTrue(range.getLowerBound() <= -30, \"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound()); assertTrue(range.getUpperBound() >= 30, \"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound());",
        "ins1DelCode":"assertTrue(\"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound(), range.getLowerBound() <= -30); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30);",
        "ins1PreCode":"assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound(), range.getLowerBound() <= -30); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30); ",
        "ins2PreCode":"assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis(); Range range = axis.getRange(); assertTrue(\"Expecting the lower bound of the range to be around -30: \" + range.getLowerBound(), range.getLowerBound() <= -30); assertTrue(\"Expecting the upper bound of the range to be around 30: \" + range.getUpperBound(), range.getUpperBound() >= 30);",
        "label":1
    },
    {
        "ins1AddCode":"ParameterValueMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, CloudFoundryWebEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebEndpointDiscoverer( EndpointPathResolver.useEndpointId(), Collections.emptyList(), Collections.emptyList()); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( endpointDiscoverer.getEndpoints(), endpointMediaTypes,",
        "ins1DelCode":"ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, CloudFoundryWebAnnotationEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebAnnotationEndpointDiscoverer( EndpointPathResolver.useEndpointId(), null, null, CloudFoundryReactiveHealthEndpointWebExtension.class); ReactiveCloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( endpointDiscoverer.discoverEndpoints(), endpointMediaTypes,",
        "ins1PreCode":"public CloudFoundryWebFluxEndpointHandlerMapping cloudFoundryWebFluxEndpointHandlerMapping( ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, WebClient.Builder webClientBuilder) { CloudFoundryWebAnnotationEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebAnnotationEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null, CloudFoundryReactiveHealthEndpointWebExtension.class); ReactiveCloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( webClientBuilder, this.applicationContext.getEnvironment()); return new CloudFoundryWebFluxEndpointHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "ins2PreCode":"public CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping( ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, RestTemplateBuilder restTemplateBuilder) { CloudFoundryWebAnnotationEndpointDiscoverer endpointDiscoverer = new CloudFoundryWebAnnotationEndpointDiscoverer( this.applicationContext, parameterMapper, endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null, CloudFoundryHealthEndpointWebExtension.class); CloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( restTemplateBuilder, this.applicationContext.getEnvironment()); return new CloudFoundryWebEndpointServletHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, getCorsConfiguration(), securityInterceptor);",
        "label":0
    },
    {
        "ins1AddCode":"if (npSettings.isShowVisibilities() == showem) { npSettings.setShowVisibilities(showem); npSettings.setShowVisibilities(!showem);",
        "ins1DelCode":"if (diaDefault.isShowVisibility() == showem) { diaDefault.setShowVisibility(showem); diaDefault.setShowVisibility(!showem);",
        "ins1PreCode":"public void setShowVisibility(final boolean showem) { if (diaDefault.isShowVisibility() == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_VISIBILITY;  public void redo() { diaDefault.setShowVisibility(showem); fireNotationEvent(key, !showem, showem); }  public void undo() { diaDefault.setShowVisibility(!showem); fireNotationEvent(key, showem, !showem); }",
        "ins2PreCode":"public void setShowMultiplicity(final boolean showem) { if (diaDefault.isShowMultiplicity() == showem) { return; } Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_MULTIPLICITY; public void redo() { diaDefault.setShowMultiplicity(showem); fireNotationEvent(key, !showem, showem); } public void undo() { diaDefault.setShowMultiplicity(!showem); fireNotationEvent(key, showem, !showem); }",
        "label":1
    },
    {
        "ins1AddCode":"Collection<CategoryMarker> markers for (CategoryMarker m : markers) { Collection<CategoryMarker> markers",
        "ins1DelCode":"Collection<Marker> markers for (Marker m : markers) { Collection<Marker> markers",
        "ins1PreCode":"public void clearDomainMarkers(int index) { Integer key = index; if (this.backgroundDomainMarkers != null) { Collection<Marker> markers = this.backgroundDomainMarkers.get(key); if (markers != null) { for (Marker m : markers) { m.removeChangeListener(this); } markers.clear(); } } if (this.foregroundDomainMarkers != null) { Collection<Marker> markers = this.foregroundDomainMarkers.get(key); if (markers != null) {",
        "ins2PreCode":"public void clearRangeMarkers(int index) { Integer key = index; if (this.backgroundRangeMarkers != null) { Collection<Marker> markers = this.backgroundRangeMarkers.get(key); if (markers != null) { for (Marker m : markers) { m.removeChangeListener(this); } markers.clear(); } } if (this.foregroundRangeMarkers != null) { Collection<Marker> markers = this.foregroundRangeMarkers.get(key); if (markers != null) {",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(d1, new NumberAxis(\"x\"), JFreeChart chart = new JFreeChart(plot);",
        "ins1DelCode":"XYPlot plot = new XYPlot(d1, new NumberAxis(\"x\"), new JFreeChart(plot);",
        "ins1PreCode":"d2.addSeries(s5);  XYAreaRenderer r = new XYAreaRenderer(); XYPlot plot = new XYPlot(d1, new NumberAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, d2); new JFreeChart(plot); LegendItem li = r.getLegendItem(1, 2); assertEquals(\"S5\", li.getLabel());",
        "ins2PreCode":"d2.addSeries(s5); XYDotRenderer r = new XYDotRenderer(); XYPlot<String> plot = new XYPlot<>(d1, new NumberAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, d2); new JFreeChart(plot); LegendItem li = r.getLegendItem(1, 2); assertEquals(\"S5\", li.getLabel());",
        "label":0
    },
    {
        "ins1AddCode":"config.put(\"field\", \"{{field1}}\");",
        "ins1DelCode":"config.put(\"field\", \"field1\");",
        "ins1PreCode":"public void testInvalidMustacheTemplate() throws Exception { RemoveProcessor.Factory factory = new RemoveProcessor.Factory(TestTemplateService.instance(true)); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config));",
        "ins2PreCode":"public void testInvalidMustacheTemplate() throws Exception { FailProcessor.Factory factory = new FailProcessor.Factory(TestTemplateService.instance(true)); Map<String, Object> config = new HashMap<>(); config.put(\"message\", \"error\"); String processorTag = randomAlphaOfLength(10); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> factory.create(null, processorTag, config));",
        "label":1
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(subplot, \"subplot\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(subplot, \"subplot\");",
        "ins1PreCode":"public void remove(XYPlot subplot) { ParamChecks.nullNotPermitted(subplot, \"subplot\"); int position = -1; int size = this.subplots.size();",
        "ins2PreCode":"public void remove(CategoryPlot subplot) { ParamChecks.nullNotPermitted(subplot, \"subplot\"); int position = -1; int size = this.subplots.size();",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Row> sentenceData = spark.createDataFrame(data, schema);",
        "ins1DelCode":"Dataset<Row> sentenceData = jsql.createDataFrame(data, schema);",
        "ins1PreCode":"new StructField(\"sentence\", DataTypes.StringType, false, Metadata.empty()) });  Dataset<Row> sentenceData = jsql.createDataFrame(data, schema); Tokenizer tokenizer = new Tokenizer() .setInputCol(\"sentence\")",
        "ins2PreCode":"new StructField(\"sentence\", DataTypes.StringType, false, Metadata.empty()) }); Dataset<Row> sentenceData = spark.createDataFrame(data, schema); Tokenizer tokenizer = new Tokenizer().setInputCol(\"sentence\").setOutputCol(\"words\"); .setInputCol(\"words\")",
        "label":0
    },
    {
        "ins1AddCode":"Object ns = findNamespace(); if (ns != null && isValidNamespace(ns)) { ArgoDiagram diagram = createDiagram(ns); assert (diagram != null) : \"No diagram was returned by the concrete class\"; p.addMember(diagram); ExplorerEventAdaptor.getInstance().modelElementAdded( diagram.getNamespace()); TargetManager.getInstance().setTarget(diagram); } else { LOG.error(\"No valid namespace found\"); throw new IllegalStateException(\"No valid namespace found\"); }",
        "ins1DelCode":"ArgoDiagram diagram = createDiagram(p.getRoot()); assert (diagram != null) : \"No diagram was returned by the concrete class\"; p.addMember(diagram); ExplorerEventAdaptor.getInstance().modelElementAdded( diagram.getNamespace()); TargetManager.getInstance().setTarget(diagram);",
        "ins1PreCode":"  Project p = ProjectManager.getManager().getCurrentProject(); ArgoDiagram diagram = createDiagram(p.getRoot()); assert (diagram != null) : \"No diagram was returned by the concrete class\";",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<>(subscriber);",
        "ins1DelCode":"FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber);",
        "ins1PreCode":".unsafeCreate(so) .retry(retry5);  FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber);  f.subscribe(async);",
        "ins2PreCode":".unsafeCreate(so) .retry(retry5); FlowableRetryTest.AsyncSubscriber<Long> async = new FlowableRetryTest.AsyncSubscriber<Long>(subscriber); f.subscribe(async);",
        "label":1
    },
    {
        "ins1AddCode":"NioTcpServer httpServer = new NioTcpServer(); httpServer.setFilters(new LoggingFilter(\"INCOMING\"), new ProtocolCodecFilter<HttpPdu, ByteBuffer>( HttpServerEncoder.class, HttpServerDecoder.class), new LoggingFilter(\"DECODED\"), new DummyHttpSever()); httpServer.getSessionConfig().setTcpNoDelay(true); httpServer.getSessionConfig().setSslContext(BogusSslContextFactory.getInstance(true)); httpServer.bind(new InetSocketAddress(8080)); httpServer.unbind();",
        "ins1DelCode":"NioTcpServer acceptor = new NioTcpServer(); acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"), new DummyHttpSever()); acceptor.getSessionConfig().setTcpNoDelay(true); acceptor.getSessionConfig().setSslContext(BogusSslContextFactory.getInstance(true)); acceptor.bind(new InetSocketAddress(8080)); acceptor.unbind();",
        "ins1PreCode":"public static void main(String[] args) throws Exception {  NioTcpServer acceptor = new NioTcpServer();  acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"), new DummyHttpSever());  acceptor.getSessionConfig().setTcpNoDelay(true);   acceptor.getSessionConfig().setSslContext(BogusSslContextFactory.getInstance(true));  acceptor.bind(new InetSocketAddress(8080));   Thread.sleep(20000); acceptor.unbind(); ",
        "ins2PreCode":"public static void main(String[] args) throws Exception { NioTcpServer acceptor = new NioTcpServer(); acceptor.setFilters(new ProtocolCodecFilter<HttpPdu, ByteBuffer>( new DummyHttpSever()); acceptor.getSessionConfig().setTcpNoDelay(true); acceptor.getSessionConfig().setTcpNoDelay(true); acceptor.bind(new InetSocketAddress(8080)); Thread.sleep(20000); acceptor.unbind();",
        "label":0
    },
    {
        "ins1AddCode":"Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null, null);",
        "ins1DelCode":"Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null);",
        "ins1PreCode":"public void testDependenciesFig5NonExclusive() {  Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null); Stream a = new Stream(Integer.valueOf(1), handler); Stream b = new Stream(Integer.valueOf(2), handler);",
        "ins2PreCode":"public void testDependenciesFig5Exclusive() { Http2UpgradeHandler handler = new Http2UpgradeHandler(null, null); Stream a = new Stream(Integer.valueOf(1), handler); Stream b = new Stream(Integer.valueOf(2), handler);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void assertValuesOnlyThrowsWhenErrored() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void assertValuesOnlyThrowsWhenErrored() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposable.empty());",
        "label":0
    },
    {
        "ins1AddCode":"DefaultIntervalXYDataset<String> d = createSampleDataset1();",
        "ins1DelCode":"DefaultIntervalXYDataset d = createSampleDataset1();",
        "ins1PreCode":"public void testGetStartYValue() { DefaultIntervalXYDataset d = createSampleDataset1(); assertEquals(1.09, d.getStartYValue(0, 0), EPSILON); assertEquals(2.09, d.getStartYValue(0, 1), EPSILON);",
        "ins2PreCode":"public void testGetEndYValue() { DefaultIntervalXYDataset d = createSampleDataset1(); assertEquals(1.11, d.getEndYValue(0, 0), EPSILON); assertEquals(2.11, d.getEndYValue(0, 1), EPSILON);",
        "label":1
    },
    {
        "ins1AddCode":"q = new AppendOnlyLinkedArrayList<>(4);",
        "ins1DelCode":"q = new AppendOnlyLinkedArrayList<Object>(4);",
        "ins1PreCode":"if (emitting) { AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(4); queue = q; }",
        "ins2PreCode":"if (emitting) { AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(4); queue = q; }",
        "label":1
    },
    {
        "ins1AddCode":"ioBuffer.position(11);",
        "ins1DelCode":"ioBuffer.position(10);",
        "ins1PreCode":" IoBuffer ioBuffer = new IoBuffer(bb1, bb2, bb3);  ioBuffer.position(10);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DNSSEC.verify(rrset, rrsig, dnskey, Instant.ofEpochMilli(60));",
        "ins1DelCode":"DNSSEC.verify(rrset, rrsig, dnskey, new Date(60));",
        "ins1PreCode":"RRset<TXTRecord> rrset = new RRset<>(); rrset.addRR(txt); rrset.addRR(rrsig); DNSSEC.verify(rrset, rrsig, dnskey, new Date(60));",
        "ins2PreCode":"RRset<TXTRecord> rrset = new RRset<>(); rrset.addRR(txt); rrset.addRR(rrsig); DNSSEC.verify(rrset, rrsig, dnskey, new Date(60));",
        "label":1
    },
    {
        "ins1AddCode":"try ( Reader in = input )",
        "ins1DelCode":"try ( final Reader in = input )",
        "ins1PreCode":"{ Objects.requireNonNull( input, \"input cannot be null\" );  try ( final Reader in = input ) { return new MetadataXpp3Reader().read( in, isStrict( options ) );",
        "ins2PreCode":"{ Objects.requireNonNull( input, \"input cannot be null\" ); try ( final InputStream in = input ) { return new MetadataXpp3Reader().read( in, isStrict( options ) );",
        "label":1
    },
    {
        "ins1AddCode":"if (log.isInfoEnabled()) log.info(sm.getString(\"simpleTcpCluster.member.added\", member)); log.error(sm.getString(\"simpleTcpCluster.member.addFailed\"), x);",
        "ins1DelCode":"if (log.isInfoEnabled()) log.info(\"Replication member added:\" + member); log.error(\"Unable to connect to replication system.\", x);",
        "ins1PreCode":"public void memberAdded(Member member) { try { hasMembers = channel.hasMembers(); if (log.isInfoEnabled()) log.info(\"Replication member added:\" + member);  fireLifecycleEvent(BEFORE_MEMBERREGISTER_EVENT, member);  registerMember(member);   fireLifecycleEvent(AFTER_MEMBERREGISTER_EVENT, member); } catch (Exception x) { log.error(\"Unable to connect to replication system.\", x); } ",
        "ins2PreCode":"public void memberDisappeared(Member member) { try { hasMembers = channel.hasMembers(); if (log.isInfoEnabled()) log.info(\"Received member disappeared:\" + member); fireLifecycleEvent(BEFORE_MEMBERUNREGISTER_EVENT, member); unregisterMember(member); fireLifecycleEvent(AFTER_MEMBERUNREGISTER_EVENT, member); } catch (Exception x) { log.error(\"Unable remove cluster node from replication system.\", x); }",
        "label":1
    },
    {
        "ins1AddCode":"v = Objects.requireNonNull(combiner.apply(objects), \"combiner returned a null value\");",
        "ins1DelCode":"v = ObjectHelper.requireNonNull(combiner.apply(objects), \"combiner returned a null value\");",
        "ins1PreCode":"R v;  try { v = ObjectHelper.requireNonNull(combiner.apply(objects), \"combiner returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "ins2PreCode":"R v; try { v = ObjectHelper.requireNonNull(combiner.apply(objects), \"The combiner returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);",
        "label":1
    },
    {
        "ins1AddCode":"final String toDir = buildRule.getProject().getProperty(\"to.dir\"); assertTrue(new File(toDir + \"/file1.txt\").exists()); assertTrue(new File(toDir + \"/file2.txt\").exists()); assertTrue(new File(toDir + \"/file3.txt\").exists());",
        "ins1DelCode":"File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "ins1PreCode":"public void testPathAsResource() { buildRule.executeTarget(\"testPathAsResource\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "ins2PreCode":"public void testZipfileset() { buildRule.executeTarget(\"testZipfileset\"); File file1 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file1.txt\"); File file2 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file2.txt\"); File file3 = new File(buildRule.getProject().getProperty(\"to.dir\") + \"/file3.txt\"); assertTrue(file1.exists()); assertTrue(file2.exists()); assertTrue(file3.exists());",
        "label":1
    },
    {
        "ins1AddCode":".putAllInt32ToInt32Field(source.getInt32ToInt32FieldMap()) .putAllInt32ToStringField(source.getInt32ToStringFieldMap()) .putAllInt32ToBytesField(source.getInt32ToBytesFieldMap()) .putAllInt32ToEnumField(source.getInt32ToEnumFieldMap()) .putAllInt32ToMessageField(source.getInt32ToMessageFieldMap()) .putAllStringToInt32Field(source.getStringToInt32FieldMap());",
        "ins1DelCode":".putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "ins1PreCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "ins2PreCode":"private void copyMapValues(TestMap source, TestMap.Builder destination) { destination .putAllInt32ToInt32Field(source.getInt32ToInt32Field()) .putAllInt32ToStringField(source.getInt32ToStringField()) .putAllInt32ToBytesField(source.getInt32ToBytesField()) .putAllInt32ToEnumField(source.getInt32ToEnumField()) .putAllInt32ToMessageField(source.getInt32ToMessageField()) .putAllStringToInt32Field(source.getStringToInt32Field());",
        "label":1
    },
    {
        "ins1AddCode":"ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null, null);",
        "ins1DelCode":"IndexMetadata build = IndexMetadata.builder(\"\") .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null);",
        "ins1PreCode":"TermRangeQuery query = new TermRangeQuery(\"field1\", new BytesRef(\"a\"), new BytesRef(\"z\"), true, true); DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetadata build = IndexMetadata.builder(\"\") .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null); fieldMapper.processQuery(query, parseContext); ParseContext.Document document = parseContext.doc();",
        "ins2PreCode":"PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\"); DocumentMapper documentMapper = mapperService.documentMapper(); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); IndexMetadata build = IndexMetadata.builder(\"\") .settings(Settings.builder().put(IndexMetadata.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(documentMapper, null, null); fieldMapper.processQuery(phraseQuery, parseContext); ParseContext.Document document = parseContext.doc();",
        "label":1
    },
    {
        "ins1AddCode":"private boolean toLong(LongWrapper toLongResult, boolean allowDecimal) { if (b == separator && allowDecimal) {",
        "ins1DelCode":"public boolean toLong(LongWrapper toLongResult) { if (b == separator) {",
        "ins1PreCode":"public boolean toLong(LongWrapper toLongResult) { int offset = 0; while (offset < this.numBytes && getByte(offset) <= ' ') offset++; if (offset == this.numBytes) return false;  int end = this.numBytes - 1; while (end > offset && getByte(end) <= ' ') end--;  byte b = getByte(offset); final boolean negative = b == '-'; if (negative || b == '+') { if (end - offset == 0) { return false; } offset++; }  final byte separator = '.'; final int radix = 10; final long stopValue = Long.MIN_VALUE / radix; long result = 0;  while (offset <= end) { b = getByte(offset); offset++; if (b == separator) {  ",
        "ins2PreCode":"public boolean toInt(IntWrapper intWrapper) { int offset = 0; while (offset < this.numBytes && getByte(offset) <= ' ') offset++; if (offset == this.numBytes) return false; int end = this.numBytes - 1; while (end > offset && getByte(end) <= ' ') end--; byte b = getByte(offset); final boolean negative = b == '-'; if (negative || b == '+') { if (end - offset == 0) { return false; } offset++; } final byte separator = '.'; final int radix = 10; final int stopValue = Integer.MIN_VALUE / radix; int result = 0; while (offset <= end) { b = getByte(offset); offset++; if (b == separator) {",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, null); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertNull(credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession session = factory.openSession()) { List<Author> authors = session.selectList(\"getAllAuthors\"); assertEquals(1, authors.size()); assertEquals(4, authors.get(0).getPosts().size());",
        "ins1DelCode":"SqlSession session = factory.openSession(); try { List<Author> authors = session.selectList(\"getAllAuthors\"); assertEquals(1, authors.size()); assertEquals(4, authors.get(0).getPosts().size()); } finally { session.close();",
        "ins1PreCode":"public void shouldNotOverwriteCollectionOnNestedResultMap() { SqlSession session = factory.openSession(); try { List<Author> authors = session.selectList(\"getAllAuthors\"); assertEquals(1, authors.size()); assertEquals(4, authors.get(0).getPosts().size()); } finally { session.close(); }",
        "ins2PreCode":"public void shouldNotOverwriteCollectionOnNestedQuery() { SqlSession session = factory.openSession(); try { List<Author> authors = session.selectList(\"getAllAuthorsNestedQuery\"); assertEquals(1, authors.size()); assertEquals(4, authors.get(0).getPosts().size()); } finally { session.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\")));",
        "ins1DelCode":"ds.setBasedir(new File(getProject().getProperty(\"output\")));",
        "ins1PreCode":"public void testFullPathMatchesCaseInsensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setCaseSensitive(false); ds.setBasedir(new File(getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/beta/gamma/GAMMA.XML\"}); ds.scan();",
        "ins2PreCode":"public void testExcludeOneFile() { DirectoryScanner ds = new DirectoryScanner(); ds.scan(); ds.setBasedir(new File(getProject().getProperty(\"output\"))); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, ds.scan();",
        "label":1
    },
    {
        "ins1AddCode":"mgr.startInternal();",
        "ins1DelCode":"result.append(\", Randoms: \"); result.append(mgr.randoms.size());",
        "ins1PreCode":"result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); System.out.println(result.toString());",
        "ins2PreCode":"result.append(threadCount); result.append(\", Time(ms): \"); result.append(end-start); result.append(\", Randoms: \"); result.append(mgr.randoms.size()); System.out.println(result.toString());",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"return new Completable() { @Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty());  assertFalse(((Disposable)observer).isDisposed());",
        "ins2PreCode":"return new Completable() { @Override protected void subscribeActual(CompletableObserver observer) { observer.onSubscribe(Disposables.empty()); assertFalse(((Disposable)observer).isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":".withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, Department of Electrical Engineering}\");",
        "ins1DelCode":".withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, Department of Electrical Engineering}}\");",
        "ins1PreCode":".withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, Department of Electrical Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);",
        "ins2PreCode":".withField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry() .withCitationKey(\"entry2\") .withField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); database.insertEntry(entry1); database.insertEntry(entry2);",
        "label":1
    },
    {
        "ins1AddCode":"validateAccessLog(alv, 1, 200, Bug49528Servlet.THREAD_SLEEP_TIME,",
        "ins1DelCode":"List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > Bug49528Servlet.THREAD_SLEEP_TIME); assertTrue(entry.toString(), entry.getTime() <",
        "ins1PreCode":"assertEquals(\"1false2true3true4true5false\", servlet.getResult());   List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > Bug49528Servlet.THREAD_SLEEP_TIME); assertTrue(entry.toString(), entry.getTime() < Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins2PreCode":"assertEquals(\"1false2true3true4true5false\", servlet.getResult()); List<Entry> entries = alv.getEntries(); assertEquals(1, entries.size()); Entry entry = entries.get(0); assertEquals(200, entry.getStatus()); assertTrue(entry.toString(), entry.getTime() > Bug49567Servlet.THREAD_SLEEP_TIME); assertTrue(entry.toString(), entry.getTime() < Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, stopwatch.elapsed(NANOSECONDS)); assertEquals(2, stopwatch.elapsed(NANOSECONDS)); assertEquals(0, stopwatch.elapsed(NANOSECONDS));",
        "ins1DelCode":"assertEquals(0, stopwatch.elapsedTime(NANOSECONDS)); assertEquals(2, stopwatch.elapsedTime(NANOSECONDS)); assertEquals(0, stopwatch.elapsedTime(NANOSECONDS));",
        "ins1PreCode":"public void testReset_whileRunning() { ticker.advance(1); stopwatch.start(); assertEquals(0, stopwatch.elapsedTime(NANOSECONDS)); ticker.advance(2); assertEquals(2, stopwatch.elapsedTime(NANOSECONDS)); stopwatch.reset(); assertFalse(stopwatch.isRunning()); ticker.advance(3); assertEquals(0, stopwatch.elapsedTime(NANOSECONDS));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaRDD<List<String>> documents = sc.parallelize(Arrays.asList( Arrays.asList(\"this is a sentence\".split(\" \")), Arrays.asList(\"this is another sentence\".split(\" \")), Arrays.asList(\"this is still a sentence\".split(\" \"))), 2);",
        "ins1DelCode":"JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")), Lists.newArrayList(\"this is still a sentence\".split(\" \"))), 2);",
        "ins1PreCode":" HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")), Lists.newArrayList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents); termFreqs.collect();",
        "ins2PreCode":"HashingTF tf = new HashingTF(); @SuppressWarnings(\"unchecked\") JavaRDD<ArrayList<String>> documents = sc.parallelize(Lists.newArrayList( Lists.newArrayList(\"this is a sentence\".split(\" \")), Lists.newArrayList(\"this is another sentence\".split(\" \")), Lists.newArrayList(\"this is still a sentence\".split(\" \"))), 2); JavaRDD<Vector> termFreqs = tf.transform(documents); termFreqs.collect();",
        "label":1
    },
    {
        "ins1AddCode":"if (nMatchingItems == 0) { continue; }",
        "ins1DelCode":"if (nMatchingItems == 0) continue;",
        "ins1PreCode":"} nMatchingItems++; } if (nMatchingItems == 0) continue; int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems];",
        "ins2PreCode":"} nMatchingItems++; } if (nMatchingItems == 0) { int[] childIndices = new int[nMatchingItems]; Object[] children = new Object[nMatchingItems];",
        "label":0
    },
    {
        "ins1AddCode":"void getAccessLevelWhenTokenIsNotValidShouldThrowException() {",
        "ins1DelCode":"public void getAccessLevelWhenTokenIsNotValidShouldThrowException() {",
        "ins1PreCode":"public void getAccessLevelWhenTokenIsNotValidShouldThrowException() { this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS)) .andExpect(header(\"Authorization\", \"bearer my-access-token\")).andRespond(withUnauthorizedRequest());",
        "ins2PreCode":"public void getAccessLevelWhenForbiddenShouldThrowException() { this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS)) .andExpect(header(\"Authorization\", \"bearer my-access-token\"))",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void subscribe(final Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); System.out.println(\"TestSingleThreadedObservable subscribed to ...\"); t = new Thread(new Runnable() {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"formatter.addBody(sb, al, StandardField.EDITOR.getName(), DocBookVersion.DOCBOOK_5);",
        "ins1DelCode":"formatter.addBody(sb, al, FieldName.EDITOR, DocBookVersion.DOCBOOK_5);",
        "ins1PreCode":"StringBuilder sb = new StringBuilder(100); AuthorList al = AuthorList.parse(fieldText); DocBookAuthorFormatter formatter = new DocBookAuthorFormatter(); formatter.addBody(sb, al, FieldName.EDITOR, DocBookVersion.DOCBOOK_5); return sb.toString();",
        "ins2PreCode":"StringBuilder sb = new StringBuilder(100); AuthorList al = AuthorList.parse(fieldText); DocBookAuthorFormatter authorFormatter = new DocBookAuthorFormatter(); authorFormatter.addBody(sb, al, FieldName.AUTHOR, DocBookVersion.DOCBOOK_5); return sb.toString();",
        "label":1
    },
    {
        "ins1AddCode":"void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {",
        "ins1DelCode":"public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception {",
        "ins1PreCode":"public void sslNeedsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory);",
        "ins2PreCode":"public void sslWantsClientAuthenticationSucceedsWithClientCertificate() throws Exception { AbstractServletWebServerFactory factory = getFactory(); addTestTxtFile(factory);",
        "label":1
    },
    {
        "ins1AddCode":"private boolean isIncluded(final TokenizedPath path) {",
        "ins1DelCode":"private boolean isIncluded(TokenizedPath path) {",
        "ins1PreCode":"private boolean isIncluded(TokenizedPath path) { ensureNonPatternSetsReady(); ",
        "ins2PreCode":"private boolean isExcluded(TokenizedPath name) { ensureNonPatternSetsReady();",
        "label":1
    },
    {
        "ins1AddCode":"void integrationTest() throws IOException {",
        "ins1DelCode":"public void integrationTest() throws IOException {",
        "ins1PreCode":"public void integrationTest() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) { Mapper mapper = session.getMapper(Mapper.class);",
        "ins2PreCode":"public void integrationTest() throws IOException { try (SqlSession session = sqlSessionFactory.openSession()) { Mapper mapper = session.getMapper(Mapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "ins1DelCode":"BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));",
        "ins1PreCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());",
        "ins2PreCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());",
        "label":1
    },
    {
        "ins1AddCode":"YIntervalSeries<String> s1 = new YIntervalSeries<>(\"S1\");",
        "ins1DelCode":"YIntervalSeries s1 = new YIntervalSeries(\"S1\");",
        "ins1PreCode":"public void testClear() { YIntervalSeries s1 = new YIntervalSeries(\"S1\"); s1.addChangeListener(this); s1.clear();",
        "ins2PreCode":"public void testClear() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); s1.addChangeListener(this); s1.clear();",
        "label":1
    },
    {
        "ins1AddCode":"fetcher = new IsbnFetcher(mock(ImportFormatPreferences.class, Answers.RETURNS_DEEP_STUBS));",
        "ins1DelCode":"fetcher = new IsbnFetcher(JabRefPreferences.getInstance().getImportFormatPreferences());",
        "ins1PreCode":"public void setUp() { fetcher = new IsbnFetcher(JabRefPreferences.getInstance().getImportFormatPreferences());  bibEntry = new BibEntry();",
        "ins2PreCode":"public void setUp() { fetcher = new IsbnViaEbookDeFetcher(JabRefPreferences.getInstance().getImportFormatPreferences()); bibEntry = new BibEntry();",
        "label":1
    },
    {
        "ins1AddCode":"public void builderCustomizers() {",
        "ins1DelCode":"public void builderCustomizers() throws Exception {",
        "ins1PreCode":"public void builderCustomizers() throws Exception { UndertowServletWebServerFactory factory = getFactory(); UndertowBuilderCustomizer[] customizers = new UndertowBuilderCustomizer[4];",
        "ins2PreCode":"public void deploymentInfo() throws Exception { UndertowServletWebServerFactory factory = getFactory(); UndertowDeploymentInfoCustomizer[] customizers = new UndertowDeploymentInfoCustomizer[4];",
        "label":1
    },
    {
        "ins1AddCode":"hits[i] = new SearchHit(i, Integer.toString(i), Collections.emptyMap(), Collections.emptyMap());",
        "ins1DelCode":"hits[i] = new SearchHit(i, Integer.toString(i), Collections.emptyMap());",
        "ins1PreCode":"rated.add(new RatedDocument(\"index\", Integer.toString(i), relevanceRatings[i])); } } hits[i] = new SearchHit(i, Integer.toString(i), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null, OriginalIndices.NONE)); }",
        "ins2PreCode":"ratedDocs.add(new RatedDocument(\"index\", Integer.toString(i), relevanceRatings[i])); } } hits[i] = new SearchHit(i, Integer.toString(i), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null, OriginalIndices.NONE)); }",
        "label":1
    },
    {
        "ins1AddCode":"for ( Resource resource : build.getResources() ) for ( Resource resource : build.getTestResources() ) List<String> filters = new ArrayList<String>(); for ( String filter : build.getFilters() )",
        "ins1DelCode":"for ( Iterator i = build.getResources().iterator(); i.hasNext(); ) Resource resource = (Resource) i.next(); for ( Iterator i = build.getTestResources().iterator(); i.hasNext(); ) Resource resource = (Resource) i.next(); List filters = new ArrayList(); for ( Iterator i = build.getFilters().iterator(); i.hasNext(); ) String filter = (String) i.next();",
        "ins1PreCode":" build.setTestSourceDirectory( alignToBaseDirectory( build.getTestSourceDirectory(), basedir ) );  for ( Iterator i = build.getResources().iterator(); i.hasNext(); ) { Resource resource = (Resource) i.next();  resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) ); }  for ( Iterator i = build.getTestResources().iterator(); i.hasNext(); ) { Resource resource = (Resource) i.next();  resource.setDirectory( alignToBaseDirectory( resource.getDirectory(), basedir ) ); }  if ( build.getFilters() != null ) { List filters = new ArrayList(); for ( Iterator i = build.getFilters().iterator(); i.hasNext(); ) { String filter = (String) i.next();  filters.add( alignToBaseDirectory( filter, basedir ) );",
        "ins2PreCode":"build.setTestSourceDirectory( unalignFromBaseDirectory( build.getTestSourceDirectory(), basedir ) ); for ( Iterator i = build.getResources().iterator(); i.hasNext(); ) { Resource resource = (Resource) i.next(); resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) ); } for ( Iterator i = build.getTestResources().iterator(); i.hasNext(); ) { Resource resource = (Resource) i.next(); resource.setDirectory( unalignFromBaseDirectory( resource.getDirectory(), basedir ) ); } if ( build.getFilters() != null ) { List filters = new ArrayList(); for ( Iterator i = build.getFilters().iterator(); i.hasNext(); ) { String filter = (String) i.next(); filters.add( unalignFromBaseDirectory( filter, basedir ) );",
        "label":1
    },
    {
        "ins1AddCode":"socketBufferHandler.configureReadBufferForWrite(); nRead = pool.read(socketBufferHandler.getReadBuffer(), nRead = channel.read(socketBufferHandler.getReadBuffer());",
        "ins1DelCode":"nRead = pool.read(channel.getBufHandler().getReadBuffer(), nRead = channel.read(channel.getBufHandler().getReadBuffer());",
        "ins1PreCode":"if (att == null) { throw new IOException(\"Key must be cancelled.\"); } nRead = pool.read(channel.getBufHandler().getReadBuffer(), channel, selector, att.getTimeout()); } catch (EOFException eof) { nRead = -1; } finally { if (selector != null) { pool.put(selector); } } } else { nRead = channel.read(channel.getBufHandler().getReadBuffer()); } return nRead;",
        "ins2PreCode":"if (selector != null) { } catch (IOException x) { } pool.write(socketWriteBuffer, getSocket(), selector, writeTimeout, block); if (getSocket().flush(true, selector, writeTimeout)) break; } catch (IOException x) { writeBufferFlipped = true; } finally { if (selector != null) { pool.put(selector); } } } finally { socketWriteBuffer.flip(); } writeBufferFlipped = false;",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"Thread.sleep(1000);",
        "ins1PreCode":"}); threadPool.submit(exec_task); beforeCli.block(); Thread.sleep(1000); assertJenkinsInQuietMode(); try {",
        "ins2PreCode":"}); threadPool.submit(exec_task); beforeCli.block(); Thread.sleep(1000); assertJenkinsInQuietMode(); return null;",
        "label":0
    },
    {
        "ins1AddCode":"for (Map.Entry<String,String> e : modelEnvVar.entrySet()) {",
        "ins1DelCode":"for (Entry<String,String> e : modelEnvVar.entrySet()) {",
        "ins1PreCode":"return false;  SortedMap<String,String> envs = getEnvironmentVariables(); for (Entry<String,String> e : modelEnvVar.entrySet()) { String v = envs.get(e.getKey()); if(v==null || !v.equals(e.getValue()))",
        "ins2PreCode":"return false; SortedMap<String,String> envs = getEnvironmentVariables2(); for (Entry<String,String> e : modelEnvVar.entrySet()) { String v = envs.get(e.getKey()); if(v==null || !v.equals(e.getValue()))",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(endpoint.getEndpointId()) .isEqualTo(EndpointId.of(\"testcontroller\"));",
        "ins1DelCode":"assertThat(endpoint.getId()).isEqualTo(\"testcontroller\");",
        "ins1PreCode":".getEndpoints(); assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testcontroller\"); assertThat(endpoint.getController()) .isInstanceOf(TestProxyControllerEndpoint.class);",
        "ins2PreCode":".getEndpoints(); assertThat(endpoints).hasSize(1); ExposableControllerEndpoint endpoint = endpoints.iterator().next(); assertThat(endpoint.getId()).isEqualTo(\"testrestcontroller\"); assertThat(endpoint.getController()) .isInstanceOf(TestRestControllerEndpoint.class);",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> p1 = new XYPlot<>(); XYPlot<String> p2 = new XYPlot<>();",
        "ins1DelCode":"XYPlot p1 = new XYPlot(); XYPlot p2 = new XYPlot();",
        "ins1PreCode":"public void testEquals_ObjectList3() { XYPlot p1 = new XYPlot(); p1.setRangeAxis(new NumberAxis(\"A\")); XYPlot p2 = new XYPlot(); p2.setRangeAxis(new NumberAxis(\"A\")); assertEquals(p1, p2);",
        "ins2PreCode":"public void testEquals_ObjectList() { CategoryPlot<String, String> p1 = new CategoryPlot<>(); p1.setDomainAxis(new CategoryAxis(\"A\")); CategoryPlot<String, String> p2 = new CategoryPlot<>(); p2.setDomainAxis(new CategoryAxis(\"A\")); assertEquals(p1, p2);",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); Assert.assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "ins1DelCode":"assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "ins1PreCode":" String result = res.toString();  assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "ins2PreCode":"String result = res.toString(); assertTrue(result.indexOf(\"<p>${'00-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'01-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'02-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'03-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'04-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>#{'05-hello world'}</p>\") > 0); assertTrue(result.indexOf(\"<p>${'06-hello world'}</p>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"assertFalse(\"Subject still has observers!\", ps.hasObservers());",
        "ins1DelCode":"assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins1PreCode":"to .assertResult(1);  assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "ins2PreCode":"to .assertResult(1); assertFalse(\"Subject still has subscribers!\", ps.hasObservers());",
        "label":1
    },
    {
        "ins1AddCode":"validatePrediction(model, users, products, testData._2(), 0.4, true, testData._3());",
        "ins1DelCode":"validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins1PreCode":".setIterations(iterations) .setImplicitPrefs(true) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "ins2PreCode":".setIterations(iterations) .setImplicitPrefs(true) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.4, true, testData._3());",
        "label":1
    },
    {
        "ins1AddCode":"LOGGER.log(FINE, \"Failed to resolve class\", e); LOGGER.log(FINE, \"Failed to resolve class\", e);",
        "ins1DelCode":"LOGGER.log(WARNING,\"Failed to resolve class\",e); LOGGER.log(WARNING,\"Failed to resolve class\",e);",
        "ins1PreCode":"Object item = readItem(reader, context, items); items.add(item); } catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); }",
        "ins2PreCode":"Object item = readItem(reader, context, collection); collection.add(item); } catch (CannotResolveClassException e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e); RobustReflectionConverter.addErrorInContext(context, e); }",
        "label":1
    },
    {
        "ins1AddCode":"Iterable<String> family = Splitter.on(\",\")",
        "ins1DelCode":"Iterable<String> family = Splitter.on(',')",
        "ins1PreCode":"public void testStringSplitWithTrim() { String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.whitespace())) .split(jacksons);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void bindToCollectionShouldAlsoCallSetterIfPresent() {",
        "ins1DelCode":"public void bindToCollectionShouldAlsoCallSetterIfPresent() {",
        "ins1PreCode":"public void bindToCollectionShouldAlsoCallSetterIfPresent() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.items\", \"a,b,c\");",
        "ins2PreCode":"public void bindToCollectionWithNoDefaultConstructor() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo.items\", \"a,b,c,c\");",
        "label":1
    },
    {
        "ins1AddCode":"BehaviorDisposable<T>[] a = observers.get(); if (observers.compareAndSet(a, b)) {",
        "ins1DelCode":"BehaviorDisposable<T>[] a = subscribers.get(); if (subscribers.compareAndSet(a, b)) {",
        "ins1PreCode":"void remove(BehaviorDisposable<T> rs) { for (;;) { BehaviorDisposable<T>[] a = subscribers.get(); int len = a.length; if (len == 0) { return; } int j = -1; for (int i = 0; i < len; i++) { if (a[i] == rs) { j = i; break; } }  if (j < 0) { return; } BehaviorDisposable<T>[] b; if (len == 1) { b = EMPTY; } else { b = new BehaviorDisposable[len - 1]; System.arraycopy(a, 0, b, 0, j); System.arraycopy(a, j + 1, b, j, len - j - 1); } if (subscribers.compareAndSet(a, b)) { return; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ExceptionHelper.nullCheck(e, \"onError called with a null Throwable.\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(e, \"onError called with null. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins1PreCode":"public void onError(Throwable e) { ObjectHelper.requireNonNull(e, \"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (once.compareAndSet(false, true)) { this.error = e;",
        "ins2PreCode":"public void onError(@NonNull Throwable e) { ObjectHelper.requireNonNull(e, \"onError called with null. Null values are generally not allowed in 2.x operators and sources.\"); if (once.compareAndSet(false, true)) { this.error = e;",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"\", cn1.getName()); Assert.assertEquals(\"\", cn2.getName()); Assert.assertEquals(\"\", cn3.getName()); Assert.assertEquals(\"/foo\", cn4.getName()); Assert.assertEquals(\"/foo/bar\", cn5.getName()); Assert.assertEquals(\"##A\", cn6.getName()); Assert.assertEquals(\"##B\", cn7.getName()); Assert.assertEquals(\"##C\", cn8.getName()); Assert.assertEquals(\"/foo##D\", cn9.getName()); Assert.assertEquals(\"/foo/bar##E\", cn10.getName()); Assert.assertEquals(\"\", cn11.getName()); Assert.assertEquals(\"/foo\", cn12.getName()); Assert.assertEquals(\"/foo/bar\", cn13.getName()); Assert.assertEquals(\"##A\", cn14.getName()); Assert.assertEquals(\"/foo##D\", cn15.getName()); Assert.assertEquals(\"/foo/bar##E\", cn16.getName()); Assert.assertEquals(\"\", cn17.getName()); Assert.assertEquals(\"/ROOT/bar\", cn18.getName()); Assert.assertEquals(\"/ROOT/bar##A\", cn19.getName()); Assert.assertEquals(\"##A\", cn20.getName()); Assert.assertEquals(\"/foo.war\", cn21.getName()); Assert.assertEquals(\"/foo\", cn22.getName());",
        "ins1DelCode":"assertEquals(\"\", cn1.getName()); assertEquals(\"\", cn2.getName()); assertEquals(\"\", cn3.getName()); assertEquals(\"/foo\", cn4.getName()); assertEquals(\"/foo/bar\", cn5.getName()); assertEquals(\"##A\", cn6.getName()); assertEquals(\"##B\", cn7.getName()); assertEquals(\"##C\", cn8.getName()); assertEquals(\"/foo##D\", cn9.getName()); assertEquals(\"/foo/bar##E\", cn10.getName()); assertEquals(\"\", cn11.getName()); assertEquals(\"/foo\", cn12.getName()); assertEquals(\"/foo/bar\", cn13.getName()); assertEquals(\"##A\", cn14.getName()); assertEquals(\"/foo##D\", cn15.getName()); assertEquals(\"/foo/bar##E\", cn16.getName()); assertEquals(\"\", cn17.getName()); assertEquals(\"/ROOT/bar\", cn18.getName()); assertEquals(\"/ROOT/bar##A\", cn19.getName()); assertEquals(\"##A\", cn20.getName()); assertEquals(\"/foo.war\", cn21.getName()); assertEquals(\"/foo\", cn22.getName());",
        "ins1PreCode":"public void testGetName() { assertEquals(\"\", cn1.getName()); assertEquals(\"\", cn2.getName()); assertEquals(\"\", cn3.getName()); assertEquals(\"/foo\", cn4.getName()); assertEquals(\"/foo/bar\", cn5.getName()); assertEquals(\"##A\", cn6.getName()); assertEquals(\"##B\", cn7.getName()); assertEquals(\"##C\", cn8.getName()); assertEquals(\"/foo##D\", cn9.getName()); assertEquals(\"/foo/bar##E\", cn10.getName()); assertEquals(\"\", cn11.getName()); assertEquals(\"/foo\", cn12.getName()); assertEquals(\"/foo/bar\", cn13.getName()); assertEquals(\"##A\", cn14.getName()); assertEquals(\"/foo##D\", cn15.getName()); assertEquals(\"/foo/bar##E\", cn16.getName()); assertEquals(\"\", cn17.getName()); assertEquals(\"/ROOT/bar\", cn18.getName()); assertEquals(\"/ROOT/bar##A\", cn19.getName()); assertEquals(\"##A\", cn20.getName()); assertEquals(\"/foo.war\", cn21.getName()); assertEquals(\"/foo\", cn22.getName());",
        "ins2PreCode":"public void testGetDisplayName() { assertEquals(\"/\", cn1.getDisplayName()); assertEquals(\"/\", cn2.getDisplayName()); assertEquals(\"/\", cn3.getDisplayName()); assertEquals(\"/foo\", cn4.getDisplayName()); assertEquals(\"/foo/bar\", cn5.getDisplayName()); assertEquals(\"/##A\", cn6.getDisplayName()); assertEquals(\"/##B\", cn7.getDisplayName()); assertEquals(\"/##C\", cn8.getDisplayName()); assertEquals(\"/foo##D\", cn9.getDisplayName()); assertEquals(\"/foo/bar##E\", cn10.getDisplayName()); assertEquals(\"/\", cn11.getDisplayName()); assertEquals(\"/foo\", cn12.getDisplayName()); assertEquals(\"/foo/bar\", cn13.getDisplayName()); assertEquals(\"/##A\", cn14.getDisplayName()); assertEquals(\"/foo##D\", cn15.getDisplayName()); assertEquals(\"/foo/bar##E\", cn16.getDisplayName()); assertEquals(\"/\", cn17.getDisplayName()); assertEquals(\"/ROOT/bar\", cn18.getDisplayName()); assertEquals(\"/ROOT/bar##A\", cn19.getDisplayName()); assertEquals(\"/##A\", cn20.getDisplayName()); assertEquals(\"/foo.war\", cn21.getDisplayName()); assertEquals(\"/foo\", cn22.getDisplayName());",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1DelCode":"assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);",
        "ins1PreCode":"public void stableIncidentEdgeOrder_edges_returnsInStableOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE);  populateStarShapedGraph();",
        "ins2PreCode":"public void stableIncidentEdgeOrder_incidentEdges_returnsInEdgeInsertionOrder() { assume().that(incidentEdgeOrder().type()).isEqualTo(ElementOrder.Type.STABLE); populateStarShapedGraph();",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"RenameProcessor.Factory factory = new RenameProcessor.Factory();",
        "ins1PreCode":"public void testCreateNoFieldPresent() throws Exception { RenameProcessor.Factory factory = new RenameProcessor.Factory(); Map<String, Object> config = new HashMap<>(); config.put(\"target_field\", \"new_field\");",
        "ins2PreCode":"public void testCreateNoToPresent() throws Exception { RenameProcessor.Factory factory = new RenameProcessor.Factory(); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"old_field\");",
        "label":1
    },
    {
        "ins1AddCode":"HttpPipelinedRequest<FullHttpRequest> pipelinedRequest = requests.get(i); NioHttpRequest nioHttpRequest = new NioHttpRequest(pipelinedRequest.getRequest(), pipelinedRequest.getSequence()); NioHttpResponse resp = nioHttpRequest.createResponse(RestStatus.OK, BytesArray.EMPTY);",
        "ins1DelCode":"final FullHttpResponse httpResponse = new DefaultFullHttpResponse(HTTP_1_1, OK); int sequence = requests.get(i).getSequence(); NioHttpResponse resp = new NioHttpResponse(sequence, httpResponse);",
        "ins1PreCode":" ArrayList<ChannelPromise> promises = new ArrayList<>(); for (int i = 1; i < requests.size(); ++i) { final FullHttpResponse httpResponse = new DefaultFullHttpResponse(HTTP_1_1, OK); ChannelPromise promise = embeddedChannel.newPromise(); promises.add(promise); int sequence = requests.get(i).getSequence(); NioHttpResponse resp = new NioHttpResponse(sequence, httpResponse); embeddedChannel.writeAndFlush(resp, promise); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestUtils.serialised(kv2D1);",
        "ins1DelCode":"TestUtilities.serialised(kv2D1);",
        "ins1PreCode":"kv2D1.addValue(new Double(452.7), \"Row2\", \"Col2\");  DefaultKeyedValues2D kv2D2 = (DefaultKeyedValues2D) TestUtilities.serialised(kv2D1); assertEquals(kv2D1, kv2D2);",
        "ins2PreCode":"d1.addValue(new Double(452.7), \"Row2\", \"Col2\"); DefaultKeyedValues2DDataset d2 = (DefaultKeyedValues2DDataset) TestUtilities.serialised(d1); assertEquals(d1, d2);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void mapperCrashes() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  assertTrue(FlowableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), ts, new Function<Integer, Publisher<Integer>>() {",
        "ins2PreCode":"public void mapperToJust() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); assertTrue(FlowableScalarXMap.tryScalarXMapSubscribe(new OneCallablePublisher(), ts, new Function<Integer, Publisher<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"fireTreeNodesChanged(this, path, childIndices, children);",
        "ins1DelCode":"fireNodesChanged(path, childIndices, children);",
        "ins1PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesChanged(path, childIndices, children); } }",
        "ins2PreCode":"children[nMatchingItems] = item; nMatchingItems++; } fireNodesInserted(path, childIndices, children); } }",
        "label":1
    },
    {
        "ins1AddCode":"} else if ((-result) == Status.ETIMEDOUT || (-result) == Status.TIMEUP) { if (block) { throw new SocketTimeoutException( sm.getString(\"iib.readtimeout\")); } else { return 0; }",
        "ins1DelCode":"",
        "ins1PreCode":"} eagain = true; return 0; } else if (-result == Status.APR_EOF) { throw new EOFException(sm.getString(\"socket.apr.clientAbort\")); } else if ((OS.IS_WIN32 || OS.IS_WIN64) && (-result == Status.APR_OS_START_SYSERR + 10053)) {  throw new EOFException(sm.getString(\"socket.apr.clientAbort\"));",
        "ins2PreCode":"} if (remaining >= len) { return len; } else if (nRead == 0) { throw new EOFException(); } else if (nRead == 0) { if (remaining > 0) { throw new EOFException();",
        "label":0
    },
    {
        "ins1AddCode":"Result result = analyze(constantScoreQuery);",
        "ins1DelCode":"Result result = analyze(constantScoreQuery, Version.CURRENT);",
        "ins1PreCode":"public void testExtractQueryMetadata_constantScoreQuery() { TermQuery termQuery1 = new TermQuery(new Term(\"_field\", \"_term\")); ConstantScoreQuery constantScoreQuery = new ConstantScoreQuery(termQuery1); Result result = analyze(constantScoreQuery, Version.CURRENT); assertThat(result.verified, is(true)); assertThat(result.minimumShouldMatch, equalTo(1));",
        "ins2PreCode":"public void testExtractQueryMetadata_boostQuery() { TermQuery termQuery1 = new TermQuery(new Term(\"_field\", \"_term\")); BoostQuery constantScoreQuery = new BoostQuery(termQuery1, 1f); Result result = analyze(constantScoreQuery, Version.CURRENT); assertThat(result.verified, is(true)); assertThat(result.minimumShouldMatch, equalTo(1));",
        "label":1
    },
    {
        "ins1AddCode":"Iterable<String> family = COMMA_SPLITTER ASSERT.that(family).hasContentsInOrder(",
        "ins1DelCode":"Iterable<String> family = Splitter.on(',') assertContentsInOrder(family,",
        "ins1PreCode":"public void testCharacterSplitWithTrim() { String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(',') .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); assertContentsInOrder(family, \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "ins2PreCode":"public void testStringSplitWithTrim() { String jacksons = \"arfo(Marlon)aorf, (Michael)orfa, afro(Jackie)orfa, \" + \"ofar(Jemaine), aff(Tito)\"; Iterable<String> family = Splitter.on(\",\") .trimResults(CharMatcher.anyOf(\"afro\").or(CharMatcher.WHITESPACE)) .split(jacksons); assertContentsInOrder(family, \"(Marlon)\", \"(Michael)\", \"(Jackie)\", \"(Jemaine)\", \"(Tito)\");",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(new Observer<Integer>() {",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(new Observer<Integer>() {",
        "ins1PreCode":"public void completeDelegateThrows() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(new Observer<Integer>() {  @Override",
        "ins2PreCode":"public void errorDelegateThrows() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(new Observer<Integer>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"if (project.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null && System.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null) {",
        "ins1DelCode":"if (System.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null) {",
        "ins1PreCode":"} } assertTrue(\"No exports\", resExports.isEmpty()); if (System.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null) { assertEquals(\"Expected classpath\", cp.toString(), resCp); }",
        "ins2PreCode":"} } assertTrue(\"No exports\", resExports.isEmpty()); if (System.getProperty(MagicNames.BUILD_SYSCLASSPATH) == null) { assertEquals(\"Expected modulepath\", mp.toString(), resMp); }",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void backpressure() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); Flowable.range(0, 100000) .onErrorResumeNext(new Function<Throwable, Flowable<Integer>>() {",
        "ins2PreCode":"public void backpressure() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(0, 100000) .onErrorResumeNext(new Function<Throwable, Observable<Integer>>() {",
        "label":1
    },
    {
        "ins1AddCode":"if (isValidValue(fields()[0], other.strings_column)) { this.strings_column = data().deepCopy(fields()[0].schema(), other.strings_column); if (isValidValue(fields()[1], other.string_to_int_column)) { this.string_to_int_column = data().deepCopy(fields()[1].schema(), other.string_to_int_column); if (isValidValue(fields()[2], other.complex_column)) { this.complex_column = data().deepCopy(fields()[2].schema(), other.complex_column);",
        "ins1DelCode":"if (isValidValue(fields()[0], other.bool_column)) { this.bool_column = data().deepCopy(fields()[0].schema(), other.bool_column); if (isValidValue(fields()[1], other.int_column)) { this.int_column = data().deepCopy(fields()[1].schema(), other.int_column); if (isValidValue(fields()[2], other.long_column)) { this.long_column = data().deepCopy(fields()[2].schema(), other.long_column); if (isValidValue(fields()[3], other.float_column)) { this.float_column = data().deepCopy(fields()[3].schema(), other.float_column); fieldSetFlags()[3] = true; } if (isValidValue(fields()[4], other.double_column)) { this.double_column = data().deepCopy(fields()[4].schema(), other.double_column); fieldSetFlags()[4] = true; } if (isValidValue(fields()[5], other.binary_column)) { this.binary_column = data().deepCopy(fields()[5].schema(), other.binary_column); fieldSetFlags()[5] = true; } if (isValidValue(fields()[6], other.string_column)) { this.string_column = data().deepCopy(fields()[6].schema(), other.string_column); fieldSetFlags()[6] = true; } if (isValidValue(fields()[7], other.maybe_bool_column)) { this.maybe_bool_column = data().deepCopy(fields()[7].schema(), other.maybe_bool_column); fieldSetFlags()[7] = true; } if (isValidValue(fields()[8], other.maybe_int_column)) { this.maybe_int_column = data().deepCopy(fields()[8].schema(), other.maybe_int_column); fieldSetFlags()[8] = true; } if (isValidValue(fields()[9], other.maybe_long_column)) { this.maybe_long_column = data().deepCopy(fields()[9].schema(), other.maybe_long_column); fieldSetFlags()[9] = true; } if (isValidValue(fields()[10], other.maybe_float_column)) { this.maybe_float_column = data().deepCopy(fields()[10].schema(), other.maybe_float_column); fieldSetFlags()[10] = true; } if (isValidValue(fields()[11], other.maybe_double_column)) { this.maybe_double_column = data().deepCopy(fields()[11].schema(), other.maybe_double_column); fieldSetFlags()[11] = true; } if (isValidValue(fields()[12], other.maybe_binary_column)) { this.maybe_binary_column = data().deepCopy(fields()[12].schema(), other.maybe_binary_column); fieldSetFlags()[12] = true; } if (isValidValue(fields()[13], other.maybe_string_column)) { this.maybe_string_column = data().deepCopy(fields()[13].schema(), other.maybe_string_column); fieldSetFlags()[13] = true; } if (isValidValue(fields()[14], other.strings_column)) { this.strings_column = data().deepCopy(fields()[14].schema(), other.strings_column); fieldSetFlags()[14] = true; } if (isValidValue(fields()[15], other.string_to_int_column)) { this.string_to_int_column = data().deepCopy(fields()[15].schema(), other.string_to_int_column); fieldSetFlags()[15] = true; } if (isValidValue(fields()[16], other.complex_column)) { this.complex_column = data().deepCopy(fields()[16].schema(), other.complex_column); fieldSetFlags()[16] = true; }",
        "ins1PreCode":"private Builder(org.apache.spark.sql.execution.datasources.parquet.test.avro.ParquetAvroCompat.Builder other) { super(other); if (isValidValue(fields()[0], other.bool_column)) { this.bool_column = data().deepCopy(fields()[0].schema(), other.bool_column); fieldSetFlags()[0] = true; } if (isValidValue(fields()[1], other.int_column)) { this.int_column = data().deepCopy(fields()[1].schema(), other.int_column); fieldSetFlags()[1] = true; } if (isValidValue(fields()[2], other.long_column)) { this.long_column = data().deepCopy(fields()[2].schema(), other.long_column); fieldSetFlags()[2] = true; } if (isValidValue(fields()[3], other.float_column)) { this.float_column = data().deepCopy(fields()[3].schema(), other.float_column); fieldSetFlags()[3] = true; } if (isValidValue(fields()[4], other.double_column)) { this.double_column = data().deepCopy(fields()[4].schema(), other.double_column); fieldSetFlags()[4] = true; } if (isValidValue(fields()[5], other.binary_column)) { this.binary_column = data().deepCopy(fields()[5].schema(), other.binary_column); fieldSetFlags()[5] = true; } if (isValidValue(fields()[6], other.string_column)) { this.string_column = data().deepCopy(fields()[6].schema(), other.string_column); fieldSetFlags()[6] = true; } if (isValidValue(fields()[7], other.maybe_bool_column)) { this.maybe_bool_column = data().deepCopy(fields()[7].schema(), other.maybe_bool_column); fieldSetFlags()[7] = true; } if (isValidValue(fields()[8], other.maybe_int_column)) { this.maybe_int_column = data().deepCopy(fields()[8].schema(), other.maybe_int_column); fieldSetFlags()[8] = true; } if (isValidValue(fields()[9], other.maybe_long_column)) { this.maybe_long_column = data().deepCopy(fields()[9].schema(), other.maybe_long_column); fieldSetFlags()[9] = true; } if (isValidValue(fields()[10], other.maybe_float_column)) { this.maybe_float_column = data().deepCopy(fields()[10].schema(), other.maybe_float_column); fieldSetFlags()[10] = true; } if (isValidValue(fields()[11], other.maybe_double_column)) { this.maybe_double_column = data().deepCopy(fields()[11].schema(), other.maybe_double_column); fieldSetFlags()[11] = true; } if (isValidValue(fields()[12], other.maybe_binary_column)) { this.maybe_binary_column = data().deepCopy(fields()[12].schema(), other.maybe_binary_column); fieldSetFlags()[12] = true; } if (isValidValue(fields()[13], other.maybe_string_column)) { this.maybe_string_column = data().deepCopy(fields()[13].schema(), other.maybe_string_column); fieldSetFlags()[13] = true; } if (isValidValue(fields()[14], other.strings_column)) { this.strings_column = data().deepCopy(fields()[14].schema(), other.strings_column); fieldSetFlags()[14] = true; } if (isValidValue(fields()[15], other.string_to_int_column)) { this.string_to_int_column = data().deepCopy(fields()[15].schema(), other.string_to_int_column); fieldSetFlags()[15] = true; } if (isValidValue(fields()[16], other.complex_column)) { this.complex_column = data().deepCopy(fields()[16].schema(), other.complex_column); fieldSetFlags()[16] = true; }",
        "ins2PreCode":"private Builder(org.apache.spark.sql.execution.datasources.parquet.test.avro.ParquetAvroCompat other) { if (isValidValue(fields()[1], other.int_column)) { if (isValidValue(fields()[0], other.bool_column)) { this.bool_column = data().deepCopy(fields()[0].schema(), other.bool_column); fieldSetFlags()[0] = true; } if (isValidValue(fields()[1], other.int_column)) { this.int_column = data().deepCopy(fields()[1].schema(), other.int_column); fieldSetFlags()[1] = true; } if (isValidValue(fields()[2], other.long_column)) { this.long_column = data().deepCopy(fields()[2].schema(), other.long_column); fieldSetFlags()[2] = true; } if (isValidValue(fields()[3], other.float_column)) { this.float_column = data().deepCopy(fields()[3].schema(), other.float_column); fieldSetFlags()[3] = true; } if (isValidValue(fields()[4], other.double_column)) { this.double_column = data().deepCopy(fields()[4].schema(), other.double_column); fieldSetFlags()[4] = true; } if (isValidValue(fields()[5], other.binary_column)) { this.binary_column = data().deepCopy(fields()[5].schema(), other.binary_column); fieldSetFlags()[5] = true; } if (isValidValue(fields()[6], other.string_column)) { this.string_column = data().deepCopy(fields()[6].schema(), other.string_column); fieldSetFlags()[6] = true; } if (isValidValue(fields()[7], other.maybe_bool_column)) { this.maybe_bool_column = data().deepCopy(fields()[7].schema(), other.maybe_bool_column); fieldSetFlags()[7] = true; } if (isValidValue(fields()[8], other.maybe_int_column)) { this.maybe_int_column = data().deepCopy(fields()[8].schema(), other.maybe_int_column); fieldSetFlags()[8] = true; } if (isValidValue(fields()[9], other.maybe_long_column)) { this.maybe_long_column = data().deepCopy(fields()[9].schema(), other.maybe_long_column); fieldSetFlags()[9] = true; } if (isValidValue(fields()[10], other.maybe_float_column)) { this.maybe_float_column = data().deepCopy(fields()[10].schema(), other.maybe_float_column); fieldSetFlags()[10] = true; } if (isValidValue(fields()[11], other.maybe_double_column)) { this.maybe_double_column = data().deepCopy(fields()[11].schema(), other.maybe_double_column); fieldSetFlags()[11] = true; } if (isValidValue(fields()[12], other.maybe_binary_column)) { this.maybe_binary_column = data().deepCopy(fields()[12].schema(), other.maybe_binary_column); fieldSetFlags()[12] = true; } if (isValidValue(fields()[13], other.maybe_string_column)) { this.maybe_string_column = data().deepCopy(fields()[13].schema(), other.maybe_string_column); fieldSetFlags()[13] = true; } if (isValidValue(fields()[14], other.strings_column)) { this.strings_column = data().deepCopy(fields()[14].schema(), other.strings_column); fieldSetFlags()[14] = true; } if (isValidValue(fields()[15], other.string_to_int_column)) { this.string_to_int_column = data().deepCopy(fields()[15].schema(), other.string_to_int_column); fieldSetFlags()[15] = true; } if (isValidValue(fields()[16], other.complex_column)) { this.complex_column = data().deepCopy(fields()[16].schema(), other.complex_column); fieldSetFlags()[16] = true; }",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, \" \" + PASSWORD + \" \"); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(POSSIBLY_DAMAGED_PWD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"return Objects.equals(appId, o.appId) && Objects.equals(execId, o.execId)",
        "ins1DelCode":"return Objects.equal(appId, o.appId) && Objects.equal(execId, o.execId)",
        "ins1PreCode":"public boolean equals(Object other) { if (other != null && other instanceof OpenBlocks) { OpenBlocks o = (OpenBlocks) other; return Objects.equal(appId, o.appId) && Objects.equal(execId, o.execId) && Arrays.equals(blockIds, o.blockIds); }",
        "ins2PreCode":"public boolean equals(Object other) { if (other != null && other instanceof RemoveBlocks) { RemoveBlocks o = (RemoveBlocks) other; return Objects.equal(appId, o.appId) && Objects.equal(execId, o.execId) && Arrays.equals(blockIds, o.blockIds); }",
        "label":1
    },
    {
        "ins1AddCode":"receiverInfo.executorId();",
        "ins1DelCode":"",
        "ins1PreCode":"receiverInfo.name(); receiverInfo.active(); receiverInfo.location(); receiverInfo.lastErrorMessage(); receiverInfo.lastError(); receiverInfo.lastErrorTime();",
        "ins2PreCode":"receiverInfo.name(); receiverInfo.active(); receiverInfo.location(); receiverInfo.lastErrorMessage(); receiverInfo.lastError(); receiverInfo.lastErrorTime();",
        "label":1
    },
    {
        "ins1AddCode":"Executor executor = createExecutor(new JdbcTransaction(ds, null, false));",
        "ins1DelCode":"DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection));",
        "ins1PreCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try { Author author = new Author(99, \"someone\", \"******\", \"someone@apache.org\", null, null);",
        "ins2PreCode":"public void shouldUpdateAuthor() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try { Author author = new Author(101, \"someone\", \"******\", \"someone@apache.org\", null, Section.NEWS);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Object> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Object> to = new TestObserver<Object>();",
        "ins1PreCode":"public void assertValuePredicateEmpty() { TestObserver<Object> to = new TestObserver<Object>();  Observable.empty().subscribe(to);",
        "ins2PreCode":"public void assertValueAtPredicateEmpty() { TestObserver<Object> to = new TestObserver<Object>(); Observable.empty().subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(5));",
        "ins1DelCode":"this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30));",
        "ins1PreCode":"ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")).build(); given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value()); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\") .tags(\"method\", \"GET\", \"uri\", \"/projects/spring-boot\", \"status\", \"200\").timer().count()).isEqualTo(1);",
        "ins2PreCode":"ClientRequest request = ClientRequest .create(HttpMethod.GET, URI.create(\"https://example.com/projects/spring-boot\")) given(this.response.rawStatusCode()).willReturn(HttpStatus.OK.value()); this.filterFunction.filter(request, this.exchange).block(Duration.ofSeconds(30)); assertThat(this.registry.get(\"http.client.requests\") .tags(\"method\", \"GET\", \"uri\", \"/projects/{project}\", \"status\", \"200\").timer().count()).isEqualTo(1);",
        "label":1
    },
    {
        "ins1AddCode":"RidgeRegressionModel model = new RidgeRegressionWithSGD(1.0, 200, 0.0, 1.0) .run(testRDD.rdd()); model = new RidgeRegressionWithSGD(1.0, 200, 0.1, 1.0) .run(testRDD.rdd());",
        "ins1DelCode":"RidgeRegressionModel model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.0); model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.1);",
        "ins1PreCode":"new ArrayList<>(data.subList(0, numExamples))); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);  RidgeRegressionModel model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.0); double unRegularizedErr = predictionError(validationData, model);  model = RidgeRegressionWithSGD.train(testRDD.rdd(), 200, 1.0, 0.1); double regularizedErr = predictionError(validationData, model); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"setMapValuesUsingMutableMap(sourceBuilder); assertMapValuesSet(source); assertEquals(3, destination.getInt32ToEnumFieldCount());",
        "ins1DelCode":"setMapValues(sourceBuilder);",
        "ins1PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValues(sourceBuilder); TestMap source = sourceBuilder.build(); ",
        "ins2PreCode":"public void testPutAll() throws Exception { TestMap.Builder sourceBuilder = TestMap.newBuilder(); setMapValues(sourceBuilder); TestMap source = sourceBuilder.build();",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> complete = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> complete = new AtomicReference<Throwable>();",
        "ins1PreCode":" Completable c = c1.ambWith(c2);  final AtomicReference<Throwable> complete = new AtomicReference<Throwable>();  c.subscribe(Functions.EMPTY_ACTION, new Consumer<Throwable>() {",
        "ins2PreCode":"Completable c = c1.ambWith(c2); final AtomicReference<Throwable> complete = new AtomicReference<Throwable>(); c.subscribe(Functions.EMPTY_ACTION, new Consumer<Throwable>() {",
        "label":1
    },
    {
        "ins1AddCode":"void shouldFindPostByIDWithDynamicSql() {",
        "ins1DelCode":"public void shouldFindPostByIDWithDynamicSql() {",
        "ins1PreCode":"public void shouldFindPostByIDWithDynamicSql() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\",",
        "ins2PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() { try (SqlSession session = sqlMapper.openSession()) { List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\",",
        "label":1
    },
    {
        "ins1AddCode":"void roundTripTest() throws IOException {",
        "ins1DelCode":"public void roundTripTest() throws IOException {",
        "ins1PreCode":"public void roundTripTest() throws IOException {  String bibtexEntry = \"@Article{test,\" + OS.NEWLINE +",
        "ins2PreCode":"public void roundTripWithPrependingNewlines() throws IOException { String bibtexEntry = \"\\r\\n@Article{test,\" + OS.NEWLINE +",
        "label":1
    },
    {
        "ins1AddCode":"if (parent != null && !ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException(",
        "ins1DelCode":"if (parent != null) { if (!ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException( }",
        "ins1PreCode":"if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); if (parent != null) { if (!ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException( \"could not change to directory: %s\",",
        "ins2PreCode":"if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); if (parent != null && !ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException( \"could not change to directory: %s\",",
        "label":0
    },
    {
        "ins1AddCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build());",
        "ins1DelCode":"SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray(), (aliases, socket) -> \"spring-boot\").build());",
        "ins1PreCode":"this.webServer.start(); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(new FileInputStream(new File(\"src/test/resources/test.jks\")), \"secret\".toCharArray()); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory(new SSLContextBuilder() .loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray(), (aliases, socket) -> \"spring-boot\").build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "ins2PreCode":"this.webServer.start(); KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType()); keyStore.load(new FileInputStream(new File(\"src/test/resources/test.jks\")), \"secret\".toCharArray()); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()) .loadKeyMaterial(keyStore, \"password\".toCharArray()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient);",
        "label":0
    },
    {
        "ins1AddCode":"return jjStartNfaWithStates_0(3, 17, 15); return jjStartNfaWithStates_0(3, 19, 15);",
        "ins1DelCode":"return jjStartNfaWithStates_0(3, 17, 17); return jjStartNfaWithStates_0(3, 19, 17);",
        "ins1PreCode":"case 69: case 101: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(3, 17, 17); break; case 76: case 108: if ((active0 & 0x80000L) != 0L) return jjStartNfaWithStates_0(3, 19, 17); break; case 83:",
        "ins2PreCode":"case 69: case 101: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 17); break; case 69: case 101: if ((active0 & 0x40000L) != 0L) return jjStartNfaWithStates_0(4, 18, 17); break; case 69:",
        "label":0
    },
    {
        "ins1AddCode":"\"Invalid value for retriesAllowed attribute: %s\", retriesAllowed); retriesAllowed); \"Invalid value for retriesAllowed attribute: %s\", retriesAllowed); retriesAllowed);",
        "ins1DelCode":"\"Invalid value for retriesAllowed attribute: \" + retriesAllowed); \"Invalid value for retriesAllowed attribute: \" + retriesAllowed);",
        "ins1PreCode":"int retries = Integer.parseInt(retriesAllowed); if (retries < Retryable.RETRY_FOREVER) { throw new BuildException( \"Invalid value for retriesAllowed attribute: \" + retriesAllowed);  } this.retriesAllowed = retries; } catch (NumberFormatException px) { throw new BuildException( \"Invalid value for retriesAllowed attribute: \" + retriesAllowed);  }",
        "ins2PreCode":"int retries = Integer.parseInt(retriesAllowed); if (retries < Retryable.RETRY_FOREVER) { throw new BuildException( \"Invalid value for retriesAllowed attribute: \" + retriesAllowed); } this.retriesAllowed = retries; } catch (NumberFormatException px) { throw new BuildException( \"Invalid value for retriesAllowed attribute: \" + retriesAllowed); }",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( 2, result.getRepeatedFieldCount( result.getDescriptorForType().findFieldByName(\"repeated_foreign_message\")));",
        "ins1DelCode":"assertEquals(result.getRepeatedFieldCount(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")), 2);",
        "ins1PreCode":" assertTrue(result.getField(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")) instanceof List<?>); assertEquals(result.getRepeatedFieldCount(result.getDescriptorForType() .findFieldByName(\"repeated_foreign_message\")), 2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"\"/test/bug49nnn/bug49297MultipleImport1.jsp\", res, null);",
        "ins1DelCode":"\"/test/bug49nnn/bug49297MultipleImport1.jsp\", res, new HashMap<String,List<String>>());",
        "ins1PreCode":" ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297MultipleImport1.jsp\", res, new HashMap<String,List<String>>());  Assert.assertEquals(200, sc);",
        "ins2PreCode":"ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49297MultipleImport2.jsp\", res, new HashMap<String,List<String>>()); Assert.assertEquals(200, sc);",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { availableParameters.add(ConfigurableBootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapRegistry.class, bootstrapContext);",
        "ins1DelCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) {",
        "ins1PreCode":"ConfigDataLocationResolvers(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, Binder binder, ResourceLoader resourceLoader, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction;",
        "ins2PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction;",
        "label":0
    },
    {
        "ins1AddCode":"} catch (NullPointerException | NamingException e) {",
        "ins1DelCode":"} catch (NullPointerException | CommunicationException | ServiceUnavailableException e) {",
        "ins1PreCode":" principal = authenticate(context, username, credentials);  } catch (NullPointerException | CommunicationException | ServiceUnavailableException e) {  ",
        "ins2PreCode":"principal = getPrincipal(context, username, gssCredential); } catch (NamingException e) { } catch (CommunicationException | ServiceUnavailableException e) {",
        "label":0
    },
    {
        "ins1AddCode":"this.queue = new SpscLinkedArrayQueue<>(bufferSize);",
        "ins1DelCode":"this.queue = new SpscLinkedArrayQueue<Object>(bufferSize);",
        "ins1PreCode":"this.time = time; this.unit = unit; this.scheduler = scheduler; this.queue = new SpscLinkedArrayQueue<Object>(bufferSize); this.delayError = delayError;",
        "ins2PreCode":"this.time = time; this.unit = unit; this.scheduler = scheduler; this.queue = new SpscLinkedArrayQueue<Object>(bufferSize); this.delayError = delayError;",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/keycolumn/MapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testInsertAnnotated() throws Exception { Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/keycolumn/MapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = sqlSessionFactory.openSession(); try { InsertMapper mapper = sqlSession.getMapper(InsertMapper.class); Name name = new Name(); name.setFirstName(\"Fred\"); name.setLastName(\"Flintstone\");  int rows = mapper.insertNameAnnotated(name);  assertNotNull(name.getId()); assertEquals(1, rows); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertMapped() throws Exception { Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/keycolumn/MapperConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); SqlSession sqlSession = sqlSessionFactory.openSession(); try { InsertMapper mapper = sqlSession.getMapper(InsertMapper.class); Name name = new Name(); name.setFirstName(\"Fred\"); name.setLastName(\"Flintstone\"); int rows = mapper.insertNameMapped(name); assertNotNull(name.getId()); assertEquals(1, rows); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"((Context) entry.value).destroySubcontext(name.getSuffix(1));",
        "ins1DelCode":"((Context) entry.value).unbind(name.getSuffix(1));",
        "ins1PreCode":" if (name.size() > 1) { if (entry.type == NamingEntry.CONTEXT) { ((Context) entry.value).unbind(name.getSuffix(1)); } else { throw new NamingException",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void getFileDirectoriesWithRelativeDottedDbParent() { Path file = Path.of(\"./relative/subdir\").resolve(\"biblio.bib\"); BibDatabaseContext database = new BibDatabaseContext(); database.setDatabasePath(file); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent())), database.getFileDirectoriesAsPaths(fileDirPrefs));",
        "ins1DelCode":"public void getFileDirectoriesWithRelativeDottedDbParent() { Path file = Paths.get(\"./relative/subdir\").resolve(\"biblio.bib\"); BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabasePath(file); List<String> fileDirectories = dbContext.getFileDirectories(StandardField.FILE, fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()), fileDirectories);",
        "ins1PreCode":"public void getFileDirectoriesWithRelativeDottedDbParent() { Path file = Paths.get(\"./relative/subdir\").resolve(\"biblio.bib\");  BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabasePath(file); List<String> fileDirectories = dbContext.getFileDirectories(StandardField.FILE, fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()), fileDirectories);",
        "ins2PreCode":"public void getFileDirectoriesWithAbsoluteDbParent() { Path file = Paths.get(\"/absolute/subdir\").resolve(\"biblio.bib\"); BibDatabaseContext dbContext = new BibDatabaseContext(); dbContext.setDatabasePath(file); List<String> fileDirectories = dbContext.getFileDirectories(StandardField.FILE, fileDirPrefs); assertEquals(Collections.singletonList(currentWorkingDir.resolve(file.getParent()).toString()), fileDirectories);",
        "label":1
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts = new TestSubscriber<>(subscriber);",
        "ins1DelCode":"final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);",
        "ins1PreCode":" }).when(subscriber).onComplete();  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(subscriber);  new Thread(new Runnable() {",
        "ins2PreCode":"}).when(o).onComplete(); final TestObserver<Integer> to = new TestObserver<Integer>(o); new Thread(new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"v = Objects.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1DelCode":"v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"R v;  try { v = ObjectHelper.requireNonNull(mapper.apply(t), \"The mapper returned a null value\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex);  ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"for (;;) { try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable ex) { Exceptions.throwIfFatal(ex); ParallelFailureHandling h; try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(expectedURL.toString(), webResource.getURL().toString());",
        "ins1DelCode":"Assert.assertTrue(expectedURL.toString().equalsIgnoreCase(webResource.getURL().toString()));",
        "ins1PreCode":"expectedURL.append(docBase.getCanonicalFile().toURI().toURL().toString()); expectedURL.append(\"*/WEB-INF/lib/test.jar!/META-INF/resources/index.html\");  Assert.assertTrue(expectedURL.toString().equalsIgnoreCase(webResource.getURL().toString()));",
        "ins2PreCode":"expectedURL.append(docBase.getCanonicalFile().toURI().toURL().toString()); expectedURL.append(\"WEB-INF/lib/test-lib.jar!/META-INF/tags/echo.tag\"); Assert.assertTrue(expectedURL.toString().equalsIgnoreCase(webResource.getURL().toString()));",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void shouldUpdateUser() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = new User(); user.setId(999); user.setName(\"MyBatis\"); mapper.insert(user);  user.setName(\"MyBatis3\"); mapper.update(user);  User loadedUser = mapper.getUser(999); assertEquals(\"MyBatis3\", loadedUser.getName());  } finally { sqlSession.close(); }",
        "ins2PreCode":"public void shouldDeleteUser() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = new User(); user.setId(999); user.setName(\"MyBatis\"); mapper.insert(user); user.setName(\"MyBatis3\"); mapper.insert(user); User loadedUser = mapper.getUser(999); assertNull(loadedUser); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"this.datasets.put(index, dataset);",
        "ins1DelCode":"this.datasets.set(index, dataset);",
        "ins1PreCode":"if (existing != null) { existing.removeChangeListener(this); } this.datasets.set(index, dataset); if (dataset != null) { dataset.addChangeListener(this);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"as.add(Disposable.empty());",
        "ins1DelCode":"as.add(Disposables.empty());",
        "ins1PreCode":"public void subscribe(final Observer<? super Integer> observer) { Worker inner = Schedulers.newThread().createWorker(); final CompositeDisposable as = new CompositeDisposable(); as.add(Disposables.empty()); as.add(inner); ",
        "ins2PreCode":"public void subscribe(final Observer<? super Integer> observer) { Worker inner = Schedulers.newThread().createWorker(); final CompositeDisposable as = new CompositeDisposable(); as.add(Disposables.empty()); as.add(inner);",
        "label":1
    },
    {
        "ins1AddCode":"() -> client.get().uri(\"/actuator/health\").accept(MediaType.APPLICATION_JSON).exchange().expectStatus() .jsonPath(\"components.alpha.status\").isEqualTo(\"UP\").jsonPath(\"components.bravo.status\") .isEqualTo(\"UP\").jsonPath(\"components.charlie.status\").isEqualTo(\"DOWN\"));",
        "ins1DelCode":"() -> client.get().uri(\"/actuator/health\").exchange().expectStatus() .jsonPath(\"details.alpha.status\").isEqualTo(\"UP\").jsonPath(\"details.bravo.status\") .isEqualTo(\"UP\").jsonPath(\"details.charlie.status\").isEqualTo(\"DOWN\"));",
        "ins1PreCode":"HealthIndicator healthIndicator = () -> Health.down().build(); ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); withHealthContributor(context, \"charlie\", healthIndicator, reactiveHealthIndicator, () -> client.get().uri(\"/actuator/health\").exchange().expectStatus() .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\") .jsonPath(\"details.alpha.status\").isEqualTo(\"UP\").jsonPath(\"details.bravo.status\") .isEqualTo(\"UP\").jsonPath(\"details.charlie.status\").isEqualTo(\"DOWN\"));",
        "ins2PreCode":"HealthIndicator healthIndicator = () -> Health.down().build(); ReactiveHealthIndicator reactiveHealthIndicator = () -> Mono.just(Health.down().build()); withHealthContributor(context, \"charlie\", healthIndicator, reactiveHealthIndicator, () -> client.get().uri(\"/actuator/health/charlie\").exchange().expectStatus() .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\")); .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\")); .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE).expectBody().jsonPath(\"status\").isEqualTo(\"DOWN\"));",
        "label":0
    },
    {
        "ins1AddCode":"FastRemovalDequeue<Object> q = new FastRemovalDequeue<>(2);",
        "ins1DelCode":"FastRemovalDequeue<Object> q = new FastRemovalDequeue<Object>(2);",
        "ins1PreCode":"public void testSingleUnpopPop() throws Exception { FastRemovalDequeue<Object> q = new FastRemovalDequeue<Object>(2);  Object o1 = new Object();",
        "ins2PreCode":"public void testSinglePushUnpush() throws Exception { FastRemovalDequeue<Object> q = new FastRemovalDequeue<Object>(2); Object o1 = new Object();",
        "label":1
    },
    {
        "ins1AddCode":"Function2<Integer, Integer, Integer> add = (a, b) -> a + b;",
        "ins1DelCode":"Function2<Integer, Integer, Integer> add = new Function2<Integer, Integer, Integer>() { @Override public Integer call(Integer a, Integer b) { return a + b; } };",
        "ins1PreCode":"public void treeReduce() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(-5, -4, -3, -2, -1, 1, 2, 3, 4), 10); Function2<Integer, Integer, Integer> add = new Function2<Integer, Integer, Integer>() { @Override public Integer call(Integer a, Integer b) { return a + b; } }; for (int depth = 1; depth <= 10; depth++) { int sum = rdd.treeReduce(add, depth);",
        "ins2PreCode":"public void treeAggregate() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(-5, -4, -3, -2, -1, 1, 2, 3, 4), 10); Function2<Integer, Integer, Integer> add = new Function2<Integer, Integer, Integer>() { @Override public Integer call(Integer a, Integer b) { return a + b; } }; for (int depth = 1; depth <= 10; depth++) { int sum = rdd.treeAggregate(0, add, add, depth);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, calls.get());",
        "ins1DelCode":"assertEquals(1, calls.get());",
        "ins1PreCode":".test(true) .assertEmpty();  assertEquals(1, calls.get());",
        "ins2PreCode":".test(true) .assertEmpty(); assertEquals(1, calls.get());",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 52; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1DelCode":"AUTH_HEADER.getHeader());",
        "ins1PreCode":"new BasicAuthHeader(METHOD, USER_NAME, PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD + \" \", USER_NAME, PASSWORD); final BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader()); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataEnvironmentContributor firstContributor = createBoundImportContributor(configData, 0); ConfigDataEnvironmentContributor secondContributor = createBoundImportContributor(configData, 1);",
        "ins1DelCode":"ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext);",
        "ins1PreCode":"secondPropertySource.setProperty(\"spring.config.activate.on-profile\", \"production\"); secondPropertySource.setProperty(\"test\", \"two\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor));",
        "ins2PreCode":"firstPropertySource.setProperty(\"spring.config.activate.on-profile\", \"production\"); secondPropertySource.setProperty(\"test\", \"${other}\"); ConfigData configData = new ConfigData(Arrays.asList(firstPropertySource, secondPropertySource)); ConfigDataEnvironmentContributor firstContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 0, this.activationContext); ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor));",
        "label":1
    },
    {
        "ins1AddCode":"void invokeShouldInvokeMethod() {",
        "ins1DelCode":"public void invokeShouldInvokeMethod() {",
        "ins1PreCode":"public void invokeShouldInvokeMethod() { ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, this.operationMethod, this.parameterValueMapper);",
        "ins2PreCode":"public void invokeShouldResolveParameters() { ReflectiveOperationInvoker invoker = new ReflectiveOperationInvoker(this.target, this.operationMethod, this.parameterValueMapper);",
        "label":1
    },
    {
        "ins1AddCode":"if (Execute.isFailure(result)) {",
        "ins1DelCode":"if (Execute.isFailure(0)) {",
        "ins1PreCode":"checkOptions(commandLine);  int result = run(commandLine); if (Execute.isFailure(0)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation());",
        "ins2PreCode":"checkOptions(commandLine); result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation());",
        "label":0
    },
    {
        "ins1AddCode":"FileSystemUtils.deleteRecursively(this.exploded.get()); File extracted = new File(this.exploded.get(), jarEntry.getName());",
        "ins1DelCode":"FileSystemUtils.deleteRecursively(this.exploded); File extracted = new File(this.exploded, jarEntry.getName());",
        "ins1PreCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded, jarEntry.getName()); if (jarEntry.isDirectory()) { extracted.mkdirs();",
        "ins2PreCode":"private void explodeArchive(File archive) throws IOException { FileSystemUtils.deleteRecursively(this.exploded); JarFile jarFile = new JarFile(archive); Enumeration<JarEntry> entries = jarFile.entries(); while (entries.hasMoreElements()) { JarEntry jarEntry = entries.nextElement(); File extracted = new File(this.exploded, jarEntry.getName()); if (jarEntry.isDirectory()) { extracted.mkdirs();",
        "label":0
    },
    {
        "ins1AddCode":"do { } while (!socket.flush(true, selector, writeTimeout));",
        "ins1DelCode":"if (block) { do { if (socket.flush(true, selector, writeTimeout)) { break; } } while (true); }",
        "ins1PreCode":"if (block) {  do { if (socket.flush(true, selector, writeTimeout)) { break; } } while (true); } } finally {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1);  Disposable d = Disposables.empty();  QueueDrainHelper.drainMaxLoop(q, ts, false, d, qd);",
        "ins2PreCode":"SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1); public boolean enter() { QueueDrainHelper.drainMaxLoop(q, ts, false, null, qd);",
        "label":0
    },
    {
        "ins1AddCode":"for (String scannedFile : scannedFiles) { files.put(scannedFile, scannedFile);",
        "ins1DelCode":"for (int i = 0; i < scannedFiles.length; ++i) { files.put(scannedFiles[i], scannedFiles[i]);",
        "ins1PreCode":"DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (int i = 0; i < scannedFiles.length; ++i) { files.put(scannedFiles[i], scannedFiles[i]); } assertEquals(\"Classfileset did not pick up expected number of \"",
        "ins2PreCode":"DirectoryScanner scanner = resultFileSet.getDirectoryScanner(p); String[] scannedFiles = scanner.getIncludedFiles(); Hashtable files = new Hashtable(); for (int i = 0; i < scannedFiles.length; ++i) { files.put(scannedFiles[i], scannedFiles[i]); } assertEquals(\"Classfileset did not pick up expected number of \"",
        "label":1
    },
    {
        "ins1AddCode":"invokeCircularReferenceCheck((DataType) o, stk, p);",
        "ins1DelCode":"pushAndInvokeCircularReferenceCheck((DataType) o, stk, p);",
        "ins1PreCode":"for (Iterator i = getNested().iterator(); i.hasNext();) { Object o = i.next(); if (o instanceof DataType) { pushAndInvokeCircularReferenceCheck((DataType) o, stk, p); } }",
        "ins2PreCode":"for (Iterator i = rc.iterator(); i.hasNext();) { Object o = i.next(); if (o instanceof DataType) { pushAndInvokeCircularReferenceCheck((DataType) o, stk, p); } }",
        "label":0
    },
    {
        "ins1AddCode":"for (char ch : Arrays.asList('a', 'b', 'c')) { target.setCharAt(target.length() - 1, ch);",
        "ins1DelCode":"char[] c = {'a', 'b', 'c'}; for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]);",
        "ins1PreCode":"String specificMessage = \"Nested conditions \" + \"not permitted in conjunction with if/unless attributes\";  char[] c = {'a', 'b', 'c'}; StringBuilder target = new StringBuilder(\"testNested4x\");  for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString());",
        "ins2PreCode":"String specificMessage = \"A single nested condition is required.\"; String specificMessage = \"A single nested condition is required.\"; char[] c = {'a', 'b'}; StringBuilder target = new StringBuilder(\"testNested7x\"); for (int i = 0; i < c.length; i++) { target.setCharAt(target.length() - 1, c[i]); try { buildRule.executeTarget(target.toString());",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < count; ++i, srcOffset += 4) { if (bigEndianPlatform) { intData[i + rowId] = java.lang.Integer.reverseBytes(intData[i + rowId]); }",
        "ins1DelCode":"for (int i = 0; i < count; ++i) { srcIndex += 4; srcOffset += 4;",
        "ins1PreCode":"public void putIntsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { intData[i + rowId] = Platform.getInt(src, srcOffset); srcIndex += 4; srcOffset += 4; }",
        "ins2PreCode":"public void putLongsLittleEndian(int rowId, int count, byte[] src, int srcIndex) { int srcOffset = srcIndex + Platform.BYTE_ARRAY_OFFSET; for (int i = 0; i < count; ++i) { longData[i + rowId] = Platform.getLong(src, srcOffset); srcIndex += 8; srcOffset += 8; }",
        "label":1
    },
    {
        "ins1AddCode":"SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<>();",
        "ins1DelCode":"SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true); List<Integer> values = new ArrayList<Integer>();",
        "ins1PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, true);  Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError());  List<Integer> values = new ArrayList<Integer>();  buf.next(1);",
        "ins2PreCode":"public void timedAndSizedTruncationError() { TestScheduler test = new TestScheduler(); SizeAndTimeBoundReplayBuffer<Integer> buf = new SizeAndTimeBoundReplayBuffer<Integer>(2, 2000, TimeUnit.MILLISECONDS, test, false); Assert.assertFalse(buf.hasCompleted()); Assert.assertFalse(buf.hasError()); List<Integer> values = new ArrayList<Integer>(); buf.next(1);",
        "label":1
    },
    {
        "ins1AddCode":"LongArray array, long numRecords, int startByteIndex, int endByteIndex) { long maxOffset = array.getBaseOffset() + numRecords * 8L;",
        "ins1DelCode":"LongArray array, int numRecords, int startByteIndex, int endByteIndex) { long maxOffset = array.getBaseOffset() + numRecords * 8;",
        "ins1PreCode":"private static long[][] getCounts( LongArray array, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][];   long bitwiseMax = 0; long bitwiseMin = -1L; long maxOffset = array.getBaseOffset() + numRecords * 8; Object baseObject = array.getBaseObject(); for (long offset = array.getBaseOffset(); offset < maxOffset; offset += 8) {",
        "ins2PreCode":"private static long[][] getKeyPrefixArrayCounts( LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][]; long bitwiseMax = 0; long bitwiseMin = -1L; long baseOffset = array.getBaseOffset() + startIndex * 8L; Object baseObject = array.getBaseObject(); for (long offset = baseOffset; offset < limit; offset += 16) {",
        "label":0
    },
    {
        "ins1AddCode":"public void testCcOnly() throws InterruptedException { server.join(60 * 1000); client.join(30 * 1000); assertFalse(testMailClient.getFailMessage(), testMailClient.isFailed());",
        "ins1DelCode":"public void testCcOnly() { try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); } if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins1PreCode":"public void testCcOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.cc(\"cc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"Cc: cc@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins2PreCode":"public void testBccOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start(); ClientThread testMailClient = new ClientThread(); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" ); Thread client = new Thread(testMailClient); client.start(); try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); } String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals( expectedResult.length(), result.length() ); assertEquals( expectedResult, result ); if ( testMailClient.isFailed() ) { fail( testMailClient.getFailMessage() ); }",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/\", \"bug54220\");",
        "ins1DelCode":"ctx.addServletMapping(\"/\", \"bug54220\");",
        "ins1PreCode":"Context ctx = tomcat.addContext(\"\", null);  Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(false)); ctx.addServletMapping(\"/\", \"bug54220\");  tomcat.start();",
        "ins2PreCode":"Context ctx = tomcat.addContext(\"\", null); Tomcat.addServlet(ctx, \"bug54220\", new Bug54220Servlet(true)); ctx.addServletMapping(\"/\", \"bug54220\"); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d1 = Disposable.empty(); Disposable d2 = Disposable.empty();",
        "ins1DelCode":"Disposable d1 = Disposables.empty(); Disposable d2 = Disposables.empty();",
        "ins1PreCode":"@Override protected void subscribeActual(SingleObserver<? super T> observer) { try { Disposable d1 = Disposables.empty();  observer.onSubscribe(d1);  Disposable d2 = Disposables.empty();  observer.onSubscribe(d2);",
        "ins2PreCode":"@Override protected void subscribeActual(Observer<? super T> observer) { try { Disposable d1 = Disposables.empty(); observer.onSubscribe(d1); Disposable d2 = Disposables.empty(); observer.onSubscribe(d2);",
        "label":1
    },
    {
        "ins1AddCode":"if (engine.findChild(name) == installedHost) {",
        "ins1DelCode":"if (engine.findChild(name) == host) {",
        "ins1PreCode":"}   if (engine.findChild(name) == host) { writer.println (sm.getString(\"hostManagerServlet.cannotStartOwnHost\", name));",
        "ins2PreCode":"} if (engine.findChild(name) == host) { writer.println (sm.getString(\"hostManagerServlet.cannotStopOwnHost\", name));",
        "label":1
    },
    {
        "ins1AddCode":"void testCallWithResultSet3_a2() {",
        "ins1DelCode":"public void testCallWithResultSet3_a2() {",
        "ins1PreCode":"public void testCallWithResultSet3_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins2PreCode":"public void testCallWithResultSet4_a2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"a1.setArrowPaint(Color.BLUE); a2.setArrowPaint(Color.BLUE);",
        "ins1DelCode":"a1.setArrowPaint(Color.blue); a2.setArrowPaint(Color.blue);",
        "ins1PreCode":"assertTrue(a1.equals(a2));   a1.setArrowPaint(Color.blue); assertFalse(a1.equals(a2)); a2.setArrowPaint(Color.blue); assertTrue(a1.equals(a2)); ",
        "ins2PreCode":"assertTrue(a1.equals(a2)); a1.setArrowPaint(Color.blue); assertFalse(a1.equals(a2)); a2.setArrowPaint(Color.blue); assertTrue(a1.equals(a2));",
        "label":1
    },
    {
        "ins1AddCode":"void bindToMapWithCustomConverter() {",
        "ins1DelCode":"public void bindToMapWithCustomConverter() {",
        "ins1PreCode":"public void bindToMapWithCustomConverter() { DefaultConversionService conversionService = new DefaultConversionService(); conversionService.addConverter(new MapConverter());",
        "ins2PreCode":"public void bindToMapWithCustomConverterAndChildElements() { DefaultConversionService conversionService = new DefaultConversionService(); conversionService.addConverter(new MapConverter());",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" assertFalse(rso.isDisposed());  Disposable d = Disposables.empty();  rso.add(d);",
        "ins2PreCode":"assertFalse(rso.isDisposed()); Disposable d = Disposables.empty(); rso.add(d);",
        "label":1
    },
    {
        "ins1AddCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() {",
        "ins1DelCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception {",
        "ins1PreCode":"public void getAccessLevelWhenSpaceDeveloperShouldReturnFull() throws Exception { String responseBody = \"{\\\"read_sensitive_data\\\": true,\\\"read_basic_data\\\": true}\"; this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "ins2PreCode":"public void getAccessLevelWhenNotSpaceDeveloperShouldReturnRestricted() String responseBody = \"{\\\"read_sensitive_data\\\": false,\\\"read_basic_data\\\": true}\"; this.server.expect(requestTo(CLOUD_CONTROLLER_PERMISSIONS))",
        "label":1
    },
    {
        "ins1AddCode":"protected <S extends Comparable<S>> void applyToXYPlot(XYPlot<S> plot) { for (XYPlot<S> subplot : cp.getSubplots()) {",
        "ins1DelCode":"protected <S extends Comparable<S>> void  applyToXYPlot(XYPlot<S> plot) { for (XYPlot subplot : cp.getSubplots()) {",
        "ins1PreCode":"protected <S extends Comparable<S>> void  applyToXYPlot(XYPlot<S> plot) { plot.setAxisOffset(this.axisOffset); plot.setDomainZeroBaselinePaint(this.baselinePaint);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"i = (b + a) >>> 1;",
        "ins1DelCode":"i = (b + a) / 2;",
        "ins1PreCode":" int i = 0; while (true) { i = (b + a) / 2; int result = compare(name, start, end, map[i].name); if (result == 1) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void shouldGetAUser() {",
        "ins1DelCode":"public void shouldGetAUser() {",
        "ins1PreCode":"public void shouldGetAUser() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins2PreCode":"public void shouldGetAUserFromAnnotation() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { AnnotationMapper mapper = sqlSession.getMapper(AnnotationMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Void> to1 = new TestObserver<>(); final TestObserver<Void> to2 = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Void> to1 = new TestObserver<Void>(); final TestObserver<Void> to2 = new TestObserver<Void>();",
        "ins1PreCode":" final Completable c = ps.ignoreElements().cache();  final TestObserver<Void> to1 = new TestObserver<Void>();  final TestObserver<Void> to2 = new TestObserver<Void>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"final Completable c = ps.ignoreElements().cache(); final TestObserver<Void> to2 = new TestObserver<Void>(); final TestObserver<Void> to2 = new TestObserver<Void>(); Runnable r1 = new Runnable() {",
        "label":0
    },
    {
        "ins1AddCode":"ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, null, config));",
        "ins1DelCode":"ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config));",
        "ins1PreCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop()); Map<String, Object> config = new HashMap<>(); config.put(\"patterns\", Collections.singletonList(\"(?<foo>\\\\w+)\")); ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)); assertThat(e.getMessage(), equalTo(\"[field] required property is missing\"));",
        "ins2PreCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop()); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"foo\"); ElasticsearchParseException e = expectThrows(ElasticsearchParseException.class, () -> factory.create(null, null, config)); assertThat(e.getMessage(), equalTo(\"[patterns] required property is missing\"));",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(1, parsedEntries.size()); assertEquals(testEntry + OS.NEWLINE, parsedEntry.getParsedSerialization());",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(testEntry + OS.NEWLINE, e.getParsedSerialization());",
        "ins1PreCode":"String testEntry = \"@article{test,author={Ed von Test}}\"; ParserResult result = parser .parse(new StringReader(testEntry + OS.NEWLINE + OS.NEWLINE + OS.NEWLINE + \"  \" + OS.NEWLINE)); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(testEntry + OS.NEWLINE, e.getParsedSerialization()); assertEquals(\"\", result.getDatabase().getEpilog());",
        "ins2PreCode":"String testEntry = \"@article{test,author={Ed von Test}}\"; ParserResult result = parser .parse(new StringReader(testEntry + OS.NEWLINE + OS.NEWLINE + OS.NEWLINE + \" epilogue \" + OS.NEWLINE)); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(testEntry + OS.NEWLINE, e.getParsedSerialization()); assertEquals(\"epilogue\", result.getDatabase().getEpilog());",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(requestMatcher).extracting(\"pattern\").isEqualTo(\"/custom/example\");",
        "ins1DelCode":"assertThat(ReflectionTestUtils.getField(requestMatcher, \"pattern\")).isEqualTo(\"/custom/example\");",
        "ins1PreCode":"this.contextRunner.withUserConfiguration(TestMvcConfiguration.class).run((context) -> { AntPathRequestMatcherProvider matcherProvider = context.getBean(AntPathRequestMatcherProvider.class); RequestMatcher requestMatcher = matcherProvider.getRequestMatcher(\"/example\"); assertThat(ReflectionTestUtils.getField(requestMatcher, \"pattern\")).isEqualTo(\"/custom/example\"); });",
        "ins2PreCode":".withUserConfiguration(TestJerseyConfiguration.class).run((context) -> { AntPathRequestMatcherProvider matcherProvider = context RequestMatcher requestMatcher = matcherProvider.getRequestMatcher(\"/example\"); assertThat(ReflectionTestUtils.getField(requestMatcher, \"pattern\")).isEqualTo(\"/admin/example\"); });",
        "label":1
    },
    {
        "ins1AddCode":"multicastEvent(new ApplicationStartingEvent(this.bootstrapContext, this.springApplication, new String[0]));",
        "ins1DelCode":"multicastEvent(new ApplicationStartingEvent(this.springApplication, new String[0]));",
        "ins1PreCode":"void closingContextCleansUpLoggingSystem() { System.setProperty(LoggingSystem.SYSTEM_PROPERTY, TestCleanupLoggingSystem.class.getName()); multicastEvent(new ApplicationStartingEvent(this.springApplication, new String[0])); TestCleanupLoggingSystem loggingSystem = (TestCleanupLoggingSystem) ReflectionTestUtils .getField(this.initializer, \"loggingSystem\");",
        "ins2PreCode":"void applicationFailedEventCleansUpLoggingSystem() { System.setProperty(LoggingSystem.SYSTEM_PROPERTY, TestCleanupLoggingSystem.class.getName()); multicastEvent(new ApplicationStartingEvent(this.springApplication, new String[0])); TestCleanupLoggingSystem loggingSystem = (TestCleanupLoggingSystem) ReflectionTestUtils .getField(this.initializer, \"loggingSystem\");",
        "label":1
    },
    {
        "ins1AddCode":"void setGroupAddsPreviousAssignmentsExplicitToExplicit() {",
        "ins1DelCode":"void setGroupAddsPreviousAssignmentsExplicitToExplicit() throws Exception {",
        "ins1PreCode":"void setGroupAddsPreviousAssignmentsExplicitToExplicit() throws Exception { ExplicitGroup oldGroup = new ExplicitGroup(\"OldGroup\", GroupHierarchyType.INDEPENDENT, ','); oldGroup.add(entry);",
        "ins2PreCode":"void setGroupWithFalseDoesNotAddsPreviousAssignments() throws Exception { ExplicitGroup oldGroup = new ExplicitGroup(\"OldGroup\", GroupHierarchyType.INDEPENDENT, ','); oldGroup.add(entry);",
        "label":1
    },
    {
        "ins1AddCode":"Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList(",
        "ins1DelCode":"scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList(",
        "ins1PreCode":"int iterations = 15; int users = 50; int products = 100; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, false, false); ",
        "ins2PreCode":"int iterations = 15; int users = 100; int products = 200; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, false, false);",
        "label":1
    },
    {
        "ins1AddCode":"final DoubleValuesSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.needsScores(); bindings.add(variable, valueSource);",
        "ins1DelCode":"final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource());",
        "ins1PreCode":"} else {   final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {",
        "ins2PreCode":"} else { final ValueSource valueSource = getDocValueSource(variable, lookup); needsScores |= valueSource.getSortField(false).needsScores(); bindings.add(variable, valueSource.asDoubleValuesSource()); } } catch (Exception e) {",
        "label":1
    },
    {
        "ins1AddCode":"if (host.getState().isAvailable()) { writer.println (sm.getString(\"hostManagerServlet.alreadyStarted\", name)); return; }",
        "ins1DelCode":"",
        "ins1PreCode":"}   try { host.start(); writer.println (sm.getString(\"hostManagerServlet.started\", name)); } catch (Throwable t) {",
        "ins2PreCode":"} try { host.stop(); writer.println (sm.getString(\"hostManagerServlet.stopped\", name)); } catch (Throwable t) {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"File tmp = File.createTempFile(\"tmp\", \"props\"); tmp.deleteOnExit();",
        "ins1PreCode":" lpf.remove(\"prop.beta\");  File tmp = File.createTempFile(\"tmp\", \"props\"); tmp.deleteOnExit(); lpf.saveAs(tmp); ",
        "ins2PreCode":"lpf.remove(\"prop.beta\"); File tmp = File.createTempFile(\"tmp\", \"props\"); tmp.deleteOnExit(); lpf.saveAs(tmp);",
        "label":1
    },
    {
        "ins1AddCode":"SerialUtils.writePaint(this.majorTickPaint, stream); SerialUtils.writeStroke(this.majorTickStroke, stream); SerialUtils.writePaint(this.minorTickPaint, stream); SerialUtils.writeStroke(this.minorTickStroke, stream); SerialUtils.writePaint(this.tickLabelPaint, stream);",
        "ins1DelCode":"SerialUtilities.writePaint(this.majorTickPaint, stream); SerialUtilities.writeStroke(this.majorTickStroke, stream); SerialUtilities.writePaint(this.minorTickPaint, stream); SerialUtilities.writeStroke(this.minorTickStroke, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "ins1PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.majorTickPaint, stream); SerialUtilities.writeStroke(this.majorTickStroke, stream); SerialUtilities.writePaint(this.minorTickPaint, stream); SerialUtilities.writeStroke(this.minorTickStroke, stream); SerialUtilities.writePaint(this.tickLabelPaint, stream);",
        "ins2PreCode":"private void writeObject(ObjectOutputStream stream) throws IOException { stream.defaultWriteObject(); SerialUtilities.writePaint(this.paint, stream); SerialUtilities.writeStroke(this.domainGridlineStroke, stream); SerialUtilities.writePaint(this.paint, stream); SerialUtilities.writeStroke(this.domainGridlineStroke, stream); SerialUtilities.writePaint(this.paint, stream);",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>(); return new HashSet<>(); return new HashMap<>(); Map<Integer, Collection<String>> expected = new HashMap<>(); expected.put(3, new HashSet<>(Arrays.asList(\"eee\")));",
        "ins1DelCode":"return new ArrayList<String>(); return new HashSet<String>(); return new HashMap<Integer, Collection<String>>(); Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\")));",
        "ins1PreCode":"@Override public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<String>(); } else { return new HashSet<String>(); } } };  Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<Integer, Collection<String>>(); } };  Single<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory);  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\")));  mapped.subscribe(singleObserver);",
        "ins2PreCode":"@Override public Collection<String> apply(Integer t1) { if (t1 == 2) { return new ArrayList<String>(); } else { return new HashSet<String>(); } } }; Function<String, String> identity = new Function<String, String>() { @Override public String apply(String v) { return v; } }; Supplier<Map<Integer, Collection<String>>> mapSupplier = new Supplier<Map<Integer, Collection<String>>>() { @Override public Map<Integer, Collection<String>> get() { return new HashMap<Integer, Collection<String>>(); } }; Single<Map<Integer, Collection<String>>> mapped = source .toMultimap(lengthFunc, identity, mapSupplier, collectionFactory); Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(2, Arrays.asList(\"cc\", \"dd\")); expected.put(3, new HashSet<String>(Arrays.asList(\"eee\"))); mapped.subscribe(singleObserver);",
        "label":1
    },
    {
        "ins1AddCode":"List<Tuple<HttpPipelinedResponse, ChannelPromise>> inflightResponses = aggregator.removeAllInflightResponses(); for (Tuple<HttpPipelinedResponse, ChannelPromise> inflightResponse : inflightResponses) {",
        "ins1DelCode":"List<Tuple<Netty4HttpResponse, ChannelPromise>> inflightResponses = aggregator.removeAllInflightResponses(); for (Tuple<Netty4HttpResponse, ChannelPromise> inflightResponse : inflightResponses) {",
        "ins1PreCode":"public void close(ChannelHandlerContext ctx, ChannelPromise promise) { List<Tuple<Netty4HttpResponse, ChannelPromise>> inflightResponses = aggregator.removeAllInflightResponses();  if (inflightResponses.isEmpty() == false) { ClosedChannelException closedChannelException = new ClosedChannelException(); for (Tuple<Netty4HttpResponse, ChannelPromise> inflightResponse : inflightResponses) { try { inflightResponse.v2().setFailure(closedChannelException);",
        "ins2PreCode":"public void close(ChannelHandlerContext ctx, ChannelPromise promise) { List<Tuple<NioHttpResponse, NettyListener>> inflightResponses = aggregator.removeAllInflightResponses(); if (inflightResponses.isEmpty() == false) { ClosedChannelException closedChannelException = new ClosedChannelException(); for (Tuple<NioHttpResponse, NettyListener> inflightResponse : inflightResponses) { try { inflightResponse.v2().setFailure(closedChannelException);",
        "label":0
    },
    {
        "ins1AddCode":"q = new AppendOnlyLinkedArrayList<>(QUEUE_LINK_SIZE);",
        "ins1DelCode":"q = new AppendOnlyLinkedArrayList<Object>(QUEUE_LINK_SIZE);",
        "ins1PreCode":"done = true; AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(QUEUE_LINK_SIZE); queue = q; }",
        "ins2PreCode":"done = true; AppendOnlyLinkedArrayList<Object> q = queue; if (q == null) { q = new AppendOnlyLinkedArrayList<Object>(QUEUE_LINK_SIZE); queue = q; }",
        "label":1
    },
    {
        "ins1AddCode":"void testWithComplex2() { Person person = personMapper.getWithComplex2(2L);",
        "ins1DelCode":"public void testWithComplex2() { Person person = personMapper.getWithComplex2(2l);",
        "ins1PreCode":"public void testWithComplex2() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex2(2l); Assertions.assertNotNull(person, \"person must not be null\"); Assertions.assertEquals(\"Christian\", person.getFirstName());",
        "ins2PreCode":"public void testWithComplex3() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assertions.assertNotNull(person, \"person must not be null\"); Assertions.assertEquals(\"Christian\", person.getFirstName());",
        "label":1
    },
    {
        "ins1AddCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 's'; Character b = d;\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testdefToCharacterImplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; Character b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; Character b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; Character b = d;\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_LONG, credentials.getUsername());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, BASE64_CRIB); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_LONG, credentials.getUsername());",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void assertNeverAtMatchingPredicate() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  Flowable.just(1, 2).subscribe(ts);",
        "ins2PreCode":"public void assertNeverAtNotMatchingPredicate() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); Flowable.just(2, 3).subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"d.addValue(1.0, \"R1\", \"C1\"); assertEquals(1.0, d.getValue(\"R1\", \"C1\"));",
        "ins1DelCode":"d.addValue(new Double(1.0), \"R1\", \"C1\"); assertEquals(new Double(1.0), d.getValue(\"R1\", \"C1\"));",
        "ins1PreCode":"public void testGetValue() { DefaultKeyedValues2D d = new DefaultKeyedValues2D(); d.addValue(new Double(1.0), \"R1\", \"C1\"); assertEquals(new Double(1.0), d.getValue(\"R1\", \"C1\")); boolean pass = false; try {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void argsWithParamAnnos() {",
        "ins1DelCode":"public void argsWithParamAnnos() {",
        "ins1PreCode":"public void argsWithParamAnnos() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class);",
        "ins2PreCode":"public void argsByActualNames() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { UseActualNameMapper mapper = sqlSession.getMapper(UseActualNameMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"public void issue2890NoStackoverflow() throws InterruptedException, TimeoutException { long awaitTerminationTimeout = 100_000; if (!executor.awaitTermination(awaitTerminationTimeout, TimeUnit.MILLISECONDS)) { throw new TimeoutException(\"Completed \" + counter.get() + \"/\" + n + \" before timed out after \" + awaitTerminationTimeout + \" milliseconds.\"); }",
        "ins1DelCode":"public void issue2890NoStackoverflow() throws InterruptedException { executor.awaitTermination(20000, TimeUnit.MILLISECONDS);",
        "ins1PreCode":"public void issue2890NoStackoverflow() throws InterruptedException { final ExecutorService executor = Executors.newFixedThreadPool(2); final Scheduler sch = Schedulers.from(executor);  Function<Integer, Observable<Integer>> func = new Function<Integer, Observable<Integer>>() { @Override public Observable<Integer> apply(Integer t) { Observable<Integer> flowable = Observable.just(t) .subscribeOn(sch) ; Subject<Integer> processor = UnicastSubject.create(); flowable.subscribe(processor); return processor; } };  int n = 5000; final AtomicInteger counter = new AtomicInteger();  Observable.range(1, n).concatMap(func, 2, ImmediateThinScheduler.INSTANCE).subscribe(new DefaultObserver<Integer>() { @Override public void onNext(Integer t) {  try { Thread.sleep(1); } catch (InterruptedException e) {  } if (counter.getAndIncrement() % 100 == 0) { System.out.print(\"testIssue2890NoStackoverflow -> \"); System.out.println(counter.get()); }; }  @Override public void onComplete() { executor.shutdown(); }  @Override public void onError(Throwable e) { executor.shutdown(); } });  executor.awaitTermination(20000, TimeUnit.MILLISECONDS);  assertEquals(n, counter.get());",
        "ins2PreCode":"public void issue2890NoStackoverflow() throws InterruptedException { final ExecutorService executor = Executors.newFixedThreadPool(2); final Scheduler sch = Schedulers.from(executor); Function<Integer, Flowable<Integer>> func = new Function<Integer, Flowable<Integer>>() { @Override public Flowable<Integer> apply(Integer t) { Flowable<Integer> flowable = Flowable.just(t) .subscribeOn(sch) ; FlowableProcessor<Integer> processor = UnicastProcessor.create(); flowable.subscribe(processor); return processor; } }; int n = 5000; final AtomicInteger counter = new AtomicInteger(); Flowable.range(1, n).concatMap(func, 2, ImmediateThinScheduler.INSTANCE).subscribe(new DefaultSubscriber<Integer>() { @Override public void onNext(Integer t) { try { Thread.sleep(1); } catch (InterruptedException e) { } if (counter.getAndIncrement() % 100 == 0) { System.out.print(\"testIssue2890NoStackoverflow -> \"); System.out.println(counter.get()); }; } @Override public void onComplete() { executor.shutdown(); } @Override public void onError(Throwable e) { executor.shutdown(); } }); executor.awaitTermination(20000, TimeUnit.MILLISECONDS); assertEquals(n, counter.get());",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.fromFuture(ft);",
        "ins1DelCode":"Disposable d = Disposables.fromFuture(ft);",
        "ins1PreCode":"public void normal() { FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, null); Disposable d = Disposables.fromFuture(ft); assertFalse(d.isDisposed()); ",
        "ins2PreCode":"public void interruptible() { FutureTask<Object> ft = new FutureTask<Object>(Functions.EMPTY_RUNNABLE, null); Disposable d = Disposables.fromFuture(ft, true); assertFalse(d.isDisposed());",
        "label":1
    },
    {
        "ins1AddCode":"final UnsafeRow row = new UnsafeRow(numFields); row.pointTo(baseObject, baseOffset + offset, size);",
        "ins1DelCode":"final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size);",
        "ins1PreCode":"final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size); return row;",
        "ins2PreCode":"final long offsetAndSize = getLong(ordinal); return null; final int size = (int) offsetAndSize; final UnsafeRow row = new UnsafeRow(); row.pointTo(baseObject, baseOffset + offset, numFields, size); return row;",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init(); tearDown();",
        "ins1PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { System.out.println(\"[testPoolThreads20Connections10Fair] Starting fairness - Tomcat JDBC - Fair\"); init(); this.threadcount = 20; this.datasource.getPoolProperties().setFairQueue(true); this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource;  } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10Fair\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "ins2PreCode":"public void testPoolThreads20Connections10FairAsync() throws Exception { System.out.println(\"[testPoolThreads20Connections10FairAsync] Starting fairness - Tomcat JDBC - Fair - Async\"); init(); this.threadcount = 20; this.datasource.getPoolProperties().setFairQueue(true); this.transferProperties(); this.datasource.getConnection().close(); latch = new CountDownLatch(threadcount); long start = System.currentTimeMillis(); TestThread[] threads = new TestThread[threadcount]; for (int i=0; i<threadcount; i++) { threads[i] = new TestThread(); threads[i].setName(\"tomcat-pool-\"+i); threads[i].d = this.datasource; } for (int i=0; i<threadcount; i++) { threads[i].start(); } if (!latch.await(complete+1000,TimeUnit.MILLISECONDS)) { System.out.println(\"Latch timed out.\"); } this.run = false; long delta = System.currentTimeMillis() - start; printThreadResults(threads,\"testPoolThreads20Connections10FairAsync\",Driver.connectCount.get(),10); System.out.println(\"Test completed in: \" + delta + \"ms.\"); tearDown();",
        "label":1
    },
    {
        "ins1AddCode":"String template; template = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; template = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; template = template.replace(TABLE_NAME_PLACEHOLDER, getFullyQualifiedName(DBPEvaluationContext.DDL)); try (JDBCStatement statement = session.createStatement()) { String sql = template.replace(FOREIGN_KEY_NAME_PLACEHOLDER,  fk.getName()); statement.executeUpdate(sql);",
        "ins1DelCode":"String sql; sql = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; sql = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; try (JDBCPreparedStatement statement = session.prepareStatement(sql)) { statement.setString(1, getFullyQualifiedName(DBPEvaluationContext.DDL)); statement.setString(2, fk.getName()); statement.executeUpdate();",
        "ins1PreCode":"return; }  String sql; if (enable) { sql = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; } else { sql = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; }  try (JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Changing referential integrity\")) { try (JDBCPreparedStatement statement = session.prepareStatement(sql)) { statement.setString(1, getFullyQualifiedName(DBPEvaluationContext.DDL)); for (DBPNamedObject fk: foreignKeys) { statement.setString(2, fk.getName()); statement.executeUpdate(); } } catch (SQLException e) {",
        "ins2PreCode":"return; } String sql; if (enable) { sql = ENABLE_REFERENTIAL_INTEGRITY_STATEMENT; } else { sql = DISABLE_REFERENTIAL_INTEGRITY_STATEMENT; } try (JDBCSession session = DBUtils.openMetaSession(monitor, this, \"Changing referential integrity\")) { try (JDBCPreparedStatement statement = session.prepareStatement(sql)) { statement.setString(1, getFullyQualifiedName(DBPEvaluationContext.DDL)); for (DBPNamedObject fk: foreignKeys) { statement.setString(2, fk.getName()); statement.executeUpdate(); } } catch (SQLException e) {",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Object> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>();",
        "ins1PreCode":"public void assertValuePredicateEmpty() { TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>();  Flowable.empty().subscribe(ts);",
        "ins2PreCode":"public void assertValueAtPredicateEmpty() { TestSubscriberEx<Object> ts = new TestSubscriberEx<Object>(); Flowable.empty().subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"Set<String> packagesToScan = new LinkedHashSet<>(Arrays.asList(basePackages));",
        "ins1DelCode":"Set<String> packagesToScan = new LinkedHashSet<>(); packagesToScan.addAll(Arrays.asList(basePackages));",
        "ins1PreCode":"metadata.getAnnotationAttributes(ServletComponentScan.class.getName())); String[] basePackages = attributes.getStringArray(\"basePackages\"); Class<?>[] basePackageClasses = attributes.getClassArray(\"basePackageClasses\"); Set<String> packagesToScan = new LinkedHashSet<>(); packagesToScan.addAll(Arrays.asList(basePackages)); for (Class<?> basePackageClass : basePackageClasses) { packagesToScan.add(ClassUtils.getPackageName(basePackageClass));",
        "ins2PreCode":"metadata.getAnnotationAttributes(EntityScan.class.getName())); String[] basePackages = attributes.getStringArray(\"basePackages\"); String[] basePackages = attributes.getStringArray(\"basePackages\"); Set<String> packagesToScan = new LinkedHashSet<>(); packagesToScan.addAll(Arrays.asList(basePackages)); for (Class<?> basePackageClass : basePackageClasses) { packagesToScan.add(ClassUtils.getPackageName(basePackageClass));",
        "label":1
    },
    {
        "ins1AddCode":"when(diskBlockManager.createTempLocalBlock()).thenAnswer(invocationOnMock -> { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); any(ShuffleWriteMetrics.class))).thenAnswer(invocationOnMock -> { });",
        "ins1DelCode":"when(diskBlockManager.createTempLocalBlock()).thenAnswer( new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { } });",
        "ins1PreCode":"spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer( new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments(); ",
        "ins2PreCode":"spillFilesCreated.clear(); MockitoAnnotations.initMocks(this); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager); when(diskBlockManager.createTempLocalBlock()).thenAnswer( new Answer<Tuple2<TempLocalBlockId, File>>() { @Override public Tuple2<TempLocalBlockId, File> answer(InvocationOnMock invocationOnMock) throws Throwable { TempLocalBlockId blockId = new TempLocalBlockId(UUID.randomUUID()); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); spillFilesCreated.add(file); return Tuple2$.MODULE$.apply(blockId, file); } }); when(blockManager.getDiskWriter( any(BlockId.class), any(File.class), any(SerializerInstance.class), anyInt(), any(ShuffleWriteMetrics.class))).thenAnswer(new Answer<DiskBlockObjectWriter>() { @Override public DiskBlockObjectWriter answer(InvocationOnMock invocationOnMock) throws Throwable { Object[] args = invocationOnMock.getArguments();",
        "label":1
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"plugin-config-attributes/w-plugin-mgmt\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"plugin-config-attributes/w-plugin-mngt\" );",
        "ins1PreCode":"public void testPluginConfigurationUsingAttributesWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"plugin-config-attributes/w-plugin-mngt\" ); assertEquals( \"src\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@todir\" ) ); assertEquals( \"true\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@overwrite\" ) );",
        "ins2PreCode":"public void testPluginConfigurationUsingAttributesWithPluginManagementAndProfile() throws Exception { PomTestWrapper pom = buildPom( \"plugin-config-attributes/w-profile\", \"maven-core-it\" ); assertEquals( \"src\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@todir\" ) ); assertEquals( \"true\", pom.getValue( \"build/plugins[1]/configuration/domParam/copy/@overwrite\" ) );",
        "label":0
    },
    {
        "ins1AddCode":"List<BibEntry> newEntries = newDB.getEntries(); assertEquals(2, newEntries.size()); assertTrue(newEntries.get(0).hasChanged()); assertTrue(newEntries.get(1).hasChanged());",
        "ins1DelCode":"assertEquals(2, newDB.getEntries().size());",
        "ins1PreCode":"assertTrue(auxResult.getGeneratedBibDatabase().hasEntries()); assertEquals(0, auxResult.getUnresolvedKeysCount()); BibDatabase newDB = auxResult.getGeneratedBibDatabase(); assertEquals(2, newDB.getEntries().size()); assertEquals(2, auxResult.getResolvedKeysCount()); assertEquals(2, auxResult.getFoundKeysInAux());",
        "ins2PreCode":"assertTrue(auxResult.getGeneratedBibDatabase().hasEntries()); assertEquals(1, auxResult.getUnresolvedKeysCount()); BibDatabase newDB = auxResult.getGeneratedBibDatabase(); assertEquals(2, newDB.getEntries().size()); assertEquals(2, auxResult.getResolvedKeysCount()); assertEquals(3, auxResult.getFoundKeysInAux());",
        "label":0
    },
    {
        "ins1AddCode":"ordered.verify(customizer).customize(any(Builder.class));",
        "ins1DelCode":"ordered.verify(customizer).customize((Builder) any());",
        "ins1PreCode":"this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) customizers); for (UndertowBuilderCustomizer customizer : customizers) { ordered.verify(customizer).customize((Builder) any()); }",
        "ins2PreCode":"this.webServer = factory.getWebServer(); InOrder ordered = inOrder((Object[]) customizers); for (UndertowDeploymentInfoCustomizer customizer : customizers) { ordered.verify(customizer).customize((DeploymentInfo) any()); }",
        "label":1
    },
    {
        "ins1AddCode":"assertNotNull(blog.getAuthor(), \"author should not be null\"); assertTrue(posts != null && !posts.isEmpty(), \"posts should not be empty\");",
        "ins1DelCode":"assertNotNull(\"author should not be null\", blog.getAuthor()); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty());",
        "ins1PreCode":"Blog blog = mapper.selectBlogUsingConstructor(1); assertEquals(1, blog.getId()); assertEquals(\"Jim Business\", blog.getTitle()); assertNotNull(\"author should not be null\", blog.getAuthor()); List<Post> posts = blog.getPosts(); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty()); }",
        "ins2PreCode":"Blog blog = mapper.selectBlogByIdUsingConstructor(1); assertEquals(1, blog.getId()); assertEquals(\"Jim Business\", blog.getTitle()); assertNotNull(\"author should not be null\", blog.getAuthor()); List<Post> posts = blog.getPosts(); assertTrue(\"posts should not be empty\", posts != null && !posts.isEmpty()); }",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedBarChart(",
        "ins2PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createAreaChart(\"Area Chart\", \"Domain\", \"Range\",",
        "label":1
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { KairosMeterRegistry registry = context.getBean(KairosMeterRegistry.class);",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { GraphiteMeterRegistry registry = context.getBean(GraphiteMeterRegistry.class);",
        "label":1
    },
    {
        "ins1AddCode":"Function2<Integer, Integer, Integer> add = (a, b) -> a + b;",
        "ins1DelCode":"Function2<Integer, Integer, Integer> add = new Function2<Integer, Integer, Integer>() { @Override public Integer call(Integer a, Integer b) { return a + b; } };",
        "ins1PreCode":"public void foldReduce() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 1, 2, 3, 5, 8, 13)); Function2<Integer, Integer, Integer> add = new Function2<Integer, Integer, Integer>() { @Override public Integer call(Integer a, Integer b) { return a + b; } };  int sum = rdd.fold(0, add);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"HttpClient httpClient = this.httpClientBuilder.get().setSSLSocketFactory(socketFactory).build();",
        "ins1DelCode":"HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build();",
        "ins1PreCode":"this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); String localUrl = getLocalUrl(\"https\", \"/test.txt\");",
        "ins2PreCode":"this.webServer.start(); SSLConnectionSocketFactory socketFactory = new SSLConnectionSocketFactory( new SSLContextBuilder().loadTrustMaterial(null, new TrustSelfSignedStrategy()).build()); HttpClient httpClient = HttpClients.custom().setSSLSocketFactory(socketFactory).build(); HttpComponentsClientHttpRequestFactory requestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); assertThat(getResponse(getLocalUrl(\"https\", \"/test.txt\"), requestFactory)).isEqualTo(\"test\");",
        "label":1
    },
    {
        "ins1AddCode":"URI.create(\"https://example.com/projects/spring-boot\")).build();",
        "ins1DelCode":"URI.create(\"http://example.com/projects/spring-boot\")).build();",
        "ins1PreCode":"public void filterWhenIoExceptionThrownShouldRecordTimer() { ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")).build(); ExchangeFunction errorExchange = (r) -> Mono.error(new IOException()); this.filterFunction.filter(request, errorExchange)",
        "ins2PreCode":"public void filterWhenExceptionThrownShouldRecordTimer() { ClientRequest request = ClientRequest.create(HttpMethod.GET, URI.create(\"http://example.com/projects/spring-boot\")).build(); ExchangeFunction exchange = (r) -> Mono.error(new IllegalArgumentException()); this.filterFunction.filter(request, exchange)",
        "label":1
    },
    {
        "ins1AddCode":"void validateConfiguration() throws SQLException {",
        "ins1DelCode":"public void validateConfiguration() throws SQLException {",
        "ins1PreCode":"public void validateConfiguration() throws SQLException { assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2); DataSource dataSource = this.context.getBean(DataSource.class);",
        "ins2PreCode":"public void validateConfiguration() throws SQLException { assertThat(this.context.getBeansOfType(DataSource.class)).hasSize(2); DataSource dataSource = this.context.getBean(DataSource.class);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void noMultipleSubscriptions() { PublishSubject<Object> other = PublishSubject.create();  TestObserver<Integer> to = new TestObserver<Integer>();  final AtomicInteger subscribed = new AtomicInteger();",
        "ins2PreCode":"public void completeTriggersSubscription() { PublishSubject<Object> other = PublishSubject.create(); TestObserver<Integer> to = new TestObserver<Integer>(); final AtomicInteger subscribed = new AtomicInteger();",
        "label":1
    },
    {
        "ins1AddCode":"return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, collectsFromSingleBucket, metadata);",
        "ins1DelCode":"if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, metadata); } else { return asMultiBucketAggregator(this, searchContext, parent); }",
        "ins1PreCode":"} WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ParentToChildrenAggregator(name, factories, searchContext, parent, childFilter, parentFilter, valuesSource, maxOrd, metadata); } else { return asMultiBucketAggregator(this, searchContext, parent); }",
        "ins2PreCode":"} WithOrdinals valuesSource = (WithOrdinals) rawValuesSource; long maxOrd = valuesSource.globalMaxOrd(searchContext.searcher()); if (collectsFromSingleBucket) { return new ChildrenToParentAggregator(name, factories, searchContext, children, childFilter, parentFilter, valuesSource, maxOrd, metadata); } else { return asMultiBucketAggregator(this, searchContext, children); }",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(onRequest, \"onRequest is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(onRequest, \"onRequest is null\");",
        "ins1PreCode":"public final ParallelFlowable<T> doOnRequest(@NonNull LongConsumer onRequest) { ObjectHelper.requireNonNull(onRequest, \"onRequest is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(),",
        "ins2PreCode":"public final ParallelFlowable<T> doOnCancel(@NonNull Action onCancel) { ObjectHelper.requireNonNull(onCancel, \"onCancel is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, Functions.emptyConsumer(),",
        "label":1
    },
    {
        "ins1AddCode":"final byte[] key = JavaUtils.bufferToArray(entry.getKey());",
        "ins1DelCode":"final byte[] key = entry.getKey().array();",
        "ins1PreCode":"}  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc =",
        "ins2PreCode":"} for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc =",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { (availableParameters) -> { availableParameters.add(Log.class, logFactory::getLog); availableParameters.add(ConfigurableBootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapContext.class, bootstrapContext); availableParameters.add(BootstrapRegistry.class, bootstrapContext); });",
        "ins1DelCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { (availableParameters) -> availableParameters.add(Log.class, logFactory::getLog));",
        "ins1PreCode":"ConfigDataLoaders(DeferredLogFactory logFactory, ConfigDataLocationNotFoundAction locationNotFoundAction, List<String> names) { this.logger = logFactory.getLog(getClass()); this.locationNotFoundAction = locationNotFoundAction; Instantiator<ConfigDataLoader<?>> instantiator = new Instantiator<>(ConfigDataLoader.class, (availableParameters) -> availableParameters.add(Log.class, logFactory::getLog)); this.loaders = instantiator.instantiate(names); this.locationTypes = getLocationTypes(this.loaders);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final AtomicReference<Object> o = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Object> o = new AtomicReference<Object>();",
        "ins1PreCode":"} });  final AtomicReference<Object> o = new AtomicReference<Object>();  rs",
        "ins2PreCode":"} }); final AtomicReference<Object> o = new AtomicReference<Object>(); rs",
        "label":1
    },
    {
        "ins1AddCode":"rdd.mapToPair(pair -> new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2()))) .saveAsNewAPIHadoopFile(outputDir, IntWritable.class, Text.class, assertEquals(pairs.toString(), output.map(Tuple2::toString).collect().toString());",
        "ins1DelCode":"rdd.mapToPair(new PairFunction<Tuple2<Integer, String>, IntWritable, Text>() { @Override public Tuple2<IntWritable, Text> call(Tuple2<Integer, String> pair) { return new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2())); } }).saveAsNewAPIHadoopFile( outputDir, IntWritable.class, Text.class, assertEquals(pairs.toString(), output.map(new Function<Tuple2<IntWritable, Text>, String>() { @Override public String call(Tuple2<IntWritable, Text> x) { return x.toString(); } }).collect().toString());",
        "ins1PreCode":"); JavaPairRDD<Integer, String> rdd = sc.parallelizePairs(pairs);  rdd.mapToPair(new PairFunction<Tuple2<Integer, String>, IntWritable, Text>() { @Override public Tuple2<IntWritable, Text> call(Tuple2<Integer, String> pair) { return new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2())); } }).saveAsNewAPIHadoopFile( outputDir, IntWritable.class, Text.class, org.apache.hadoop.mapreduce.lib.output.SequenceFileOutputFormat.class);  JavaPairRDD<IntWritable, Text> output = sc.sequenceFile(outputDir, IntWritable.class, Text.class); assertEquals(pairs.toString(), output.map(new Function<Tuple2<IntWritable, Text>, String>() { @Override public String call(Tuple2<IntWritable, Text> x) { return x.toString(); } }).collect().toString());",
        "ins2PreCode":"); JavaPairRDD<Integer, String> rdd = sc.parallelizePairs(pairs); rdd.mapToPair(new PairFunction<Tuple2<Integer, String>, IntWritable, Text>() { @Override public Tuple2<IntWritable, Text> call(Tuple2<Integer, String> pair) { return new Tuple2<>(new IntWritable(pair._1()), new Text(pair._2())); } public void readWithNewAPIHadoopFile() throws IOException { }).saveAsHadoopFile(outputDir, IntWritable.class, Text.class, SequenceFileOutputFormat.class); org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat.class, JavaPairRDD<IntWritable, Text> output = sc.newAPIHadoopFile(outputDir, }).saveAsHadoopFile(outputDir, IntWritable.class, Text.class, SequenceFileOutputFormat.class); assertEquals(pairs.toString(), output.map(new Function<Tuple2<IntWritable, Text>, String>() { @Override public String call(Tuple2<IntWritable, Text> x) { return x.toString(); } }).collect().toString());",
        "label":1
    },
    {
        "ins1AddCode":"if (!PaintUtils.equal(this.backgroundPaint, that.backgroundPaint)) { if (!PaintUtils.equal(this.foregroundPaint, that.foregroundPaint)) {",
        "ins1DelCode":"if (!PaintUtilities.equal(this.backgroundPaint, that.backgroundPaint)) { if (!PaintUtilities.equal(this.foregroundPaint, that.foregroundPaint)) {",
        "ins1PreCode":"return false; } ArcDialFrame that = (ArcDialFrame) obj; if (!PaintUtilities.equal(this.backgroundPaint, that.backgroundPaint)) { return false; } if (!PaintUtilities.equal(this.foregroundPaint, that.foregroundPaint)) { return false; }",
        "ins2PreCode":"return false; } StandardDialFrame that = (StandardDialFrame) obj; if (!PaintUtilities.equal(this.backgroundPaint, that.backgroundPaint)) { return false; } if (!PaintUtilities.equal(this.foregroundPaint, that.foregroundPaint)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1DelCode":"assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins2PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1AddCode":"vm.run(Collections.emptyList());",
        "ins1DelCode":"List<BibEntry> v = new ArrayList<>(); vm.run(v);",
        "ins1PreCode":"VM vm = new VM(\"FUNCTION {test} { \\\"Johnny Foo { and } Mary Bar\\\" num.names$ }\" + \"EXECUTE {test}\");  List<BibEntry> v = new ArrayList<>(); vm.run(v); assertEquals(1, vm.getStack().pop()); assertEquals(0, vm.getStack().size());",
        "ins2PreCode":"VM vm = new VM(\"FUNCTION {test} { \\\"H\\\" chr.to.int$ }\" + \"EXECUTE {test}\"); VM vm = new VM(\"FUNCTION {test} { \\\"H\\\" chr.to.int$ }\" + \"EXECUTE {test}\"); List<BibEntry> v = new ArrayList<>(); vm.run(v); assertEquals(72, vm.getStack().pop()); assertEquals(0, vm.getStack().size());",
        "label":1
    },
    {
        "ins1AddCode":"List<Row> data = Arrays.asList( RowFactory.create(0, Vectors.dense(1.0, 0.1, -8.0)), RowFactory.create(1, Vectors.dense(2.0, 1.0, -4.0)), RowFactory.create(2, Vectors.dense(4.0, 10.0, 8.0)) ); StructType schema = new StructType(new StructField[]{ new StructField(\"id\", DataTypes.IntegerType, false, Metadata.empty()), new StructField(\"features\", new VectorUDT(), false, Metadata.empty()) }); Dataset<Row> dataFrame = spark.createDataFrame(data, schema); scaledData.select(\"features\", \"scaledFeatures\").show();",
        "ins1DelCode":"Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); scaledData.show();",
        "ins1PreCode":".getOrCreate();   Dataset<Row> dataFrame = spark .read() .format(\"libsvm\") .load(\"data/mllib/sample_libsvm_data.txt\"); MaxAbsScaler scaler = new MaxAbsScaler() .setInputCol(\"features\") .setOutputCol(\"scaledFeatures\");   MaxAbsScalerModel scalerModel = scaler.fit(dataFrame);   Dataset<Row> scaledData = scalerModel.transform(dataFrame); scaledData.show();  spark.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Diagram diag = ((LayerPerspective) lay).getDiagram();",
        "ins1DelCode":"ArgoDiagram diag = ProjectManager.getManager().getCurrentProject() .getActiveDiagram();",
        "ins1PreCode":"Map styleAttributes) {  FigNode figNode = null; ArgoDiagram diag = ProjectManager.getManager().getCurrentProject() .getActiveDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) {",
        "ins2PreCode":"Object node, Map styleAttributes) { FigNode figNode = null; ArgoDiagram diag = ProjectManager.getManager().getCurrentProject() .getActiveDiagram(); if (diag instanceof UMLDiagram && ((UMLDiagram) diag).doesAccept(node)) {",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testPoolThreads10Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(false);",
        "ins2PreCode":"public void testPoolThreads10Connections10Fair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true);",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, xAxis, yAxis, renderer);",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer);",
        "ins1PreCode":"CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer);  ",
        "ins2PreCode":"CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"DirectoryScanner ds = new DirectoryScanner();",
        "ins1PreCode":"public void testPatternsDifferInCaseScanningInsensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"});",
        "ins2PreCode":"public void testParentDiffersInCaseScanningInsensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(buildRule.getProject().getProperty(\"output\"))); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/beta/\"});",
        "label":1
    },
    {
        "ins1AddCode":"getDefaultEncoding()); this.storage = new TemporaryContentStorage(platform, tempFile, getDefaultEncoding());",
        "ins1DelCode":"platform.getPreferenceStore().getString(ModelPreferences.CONTENT_HEX_ENCODING)); this.storage = new TemporaryContentStorage(platform, tempFile);",
        "ins1PreCode":"storage = BytesContentStorage.createFromStream( bs, contentLength, platform.getPreferenceStore().getString(ModelPreferences.CONTENT_HEX_ENCODING)); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else {  File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + blob.hashCode()); } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = blob.getBinaryStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); } this.storage = new TemporaryContentStorage(platform, tempFile); } ",
        "ins2PreCode":"storage = BytesContentStorage.createFromStream( bs, contentLength, platform.getPreferenceStore().getString(ModelPreferences.CONTENT_HEX_ENCODING)); } } catch (IOException e) { throw new DBCException(\"IO error while reading content\", e); } catch (Throwable e) { throw new DBCException(e, dataSource); } } else { File tempFile; try { tempFile = ContentUtils.createTempContentFile(monitor, platform, \"blob\" + bfile.hashCode()); } } catch (IOException e) { throw new DBCException(\"Can't create temporary file\", e); } try (OutputStream os = new FileOutputStream(tempFile)) { try (InputStream bs = getInputStream()) { ContentUtils.copyStreams(bs, contentLength, os, monitor); } } catch (IOException e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(\"IO error while copying stream\", e); } catch (Throwable e) { ContentUtils.deleteTempFile(tempFile); throw new DBCException(e, dataSource); } this.storage = new TemporaryContentStorage(platform, tempFile); }",
        "label":1
    },
    {
        "ins1AddCode":"dialogService.showErrorDialogAndWait(Localization.lang(\"Error pushing entries\"), Localization.lang(\"Could not connect to Vim server. Make sure that Vim is running with correct server name.\")); \"Vim is running<BR>with correct server name.\") \"</HTML>\", dialogService.showErrorDialogAndWait(Localization.lang(\"Error pushing entries\"), Localization.lang(\"Could not run the 'vim' program.\"));",
        "ins1DelCode":"JOptionPane.showMessageDialog( panel.frame(), \"<HTML>\" + Localization.lang(\"Could not connect to Vim server. Make sure that \" + \"Vim is running<BR>with correct server name.\") + \"</HTML>\", Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); JOptionPane.showMessageDialog( panel.frame(), Localization.lang(\"Could not run the 'vim' program.\"), Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE);",
        "ins1PreCode":"public void operationCompleted(BasePanel panel) { if (couldNotConnect) { JOptionPane.showMessageDialog( panel.frame(), \"<HTML>\" + Localization.lang(\"Could not connect to Vim server. Make sure that \" + \"Vim is running<BR>with correct server name.\") + \"</HTML>\", Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else if (couldNotCall) { JOptionPane.showMessageDialog( panel.frame(), Localization.lang(\"Could not run the 'vim' program.\"), Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else { super.operationCompleted(panel);",
        "ins2PreCode":"public void operationCompleted(BasePanel panel) { if (couldNotConnect) { JOptionPane.showMessageDialog(panel.frame(), JOptionPane.showMessageDialog(panel.frame(), JOptionPane.showMessageDialog(panel.frame(), \"<HTML>\" + Localization.lang(\"Could not connect to a running gnuserv process. Make sure that \" + \"Emacs or XEmacs is running,<BR>and that the server has been started \" + \"(by running the command 'server-start'/'gnuserv-start').\") + \"</HTML>\", Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else if (couldNotCall) { JOptionPane.showMessageDialog(panel.frame(), JOptionPane.showMessageDialog(panel.frame(), Localization.lang(\"Could not run the gnuclient/emacsclient program. Make sure you have \" Localization.lang(\"Error\"), JOptionPane.ERROR_MESSAGE); } else { super.operationCompleted(panel);",
        "label":0
    },
    {
        "ins1AddCode":"if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY))) { Color newColor = CSSUtils.getCurrentEditorConnectionColor(widget); if (newColor != null) { CTabFolder nativeWidget = (CTabFolder) ((CTabFolderElement) element).getNativeWidget(); if (nativeWidget.getRenderer() instanceof CTabRendering) { ((CTabRendering) nativeWidget.getRenderer()).setSelectedTabFill(newColor); } else { nativeWidget.setBackground(newColor); } return true;",
        "ins1DelCode":"Color newColor = getCurrentEditorConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) { CTabFolder nativeWidget = (CTabFolder) ((CTabFolderElement) element).getNativeWidget(); if (nativeWidget.getRenderer() instanceof CTabRendering) { ((CTabRendering) nativeWidget.getRenderer()).setSelectedTabFill(newColor); } else { nativeWidget.setBackground(newColor); return true;",
        "ins1PreCode":"return false; }  Color newColor = getCurrentEditorConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) { CTabFolder nativeWidget = (CTabFolder) ((CTabFolderElement) element).getNativeWidget(); if (nativeWidget.getRenderer() instanceof CTabRendering) {",
        "ins2PreCode":"return false; } Color newColor = CustomSelectedTabFillHandler.getCurrentEditorConnectionColor(); if (DBStyles.COLORED_BY_CONNECTION_TYPE.equals(widget.getData(CSSSWTConstants.CSS_CLASS_NAME_KEY)) && newColor != null) { CTabFolder nativeWidget = (CTabFolder) ((CTabFolderElement) element).getNativeWidget(); if (nativeWidget.getRenderer() instanceof CTabRendering) {",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION);",
        "ins2PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION);",
        "label":0
    },
    {
        "ins1AddCode":"final String name = LOG.log(Level.SEVERE, \"Class not found \" + className, e);",
        "ins1DelCode":"final String name = LOG.error(\"Class not found \" + className, e);",
        "ins1PreCode":"metaTypeByName.put(name, clazz); nameByMetaType.put(clazz, name); } catch (ClassNotFoundException e) { LOG.error(\"Class not found \" + className, e); } }",
        "ins2PreCode":"metaTypeByName.put(name, clazz); nameByMetaType.put(clazz, name); } catch (ClassNotFoundException e) { LOG.error(\"Class not found \" + className, e); } }",
        "label":1
    },
    {
        "ins1AddCode":"HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request).getRequest();",
        "ins1DelCode":"HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);",
        "ins1PreCode":"request.addHeader(\"x-forwarded-for\", \"proxy2\");   HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);  ",
        "ins2PreCode":"request.setHeader(\"x-forwarded-for\", \"140.211.11.130, proxy1, proxy2, 192.168.0.10, 192.168.0.11\"); HttpServletRequest actualRequest = testRemoteIpFilter(filterDef, request);",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":" assertFalse(rmo.isDisposed());  Disposable d = Disposables.empty();  rmo.add(d);",
        "ins2PreCode":"assertFalse(rmo.isDisposed()); Disposable d = Disposables.empty(); rmo.add(d);",
        "label":1
    },
    {
        "ins1AddCode":"notationProviderName.cleanListener();",
        "ins1DelCode":"notationProviderName.cleanListener(this, own);",
        "ins1PreCode":"protected void initNotationProviders(Object own) { if (notationProviderName != null) { notationProviderName.cleanListener(this, own); } ",
        "ins2PreCode":"protected void initNotationProviders(Object own) { if (notationProviderName != null) { notationProviderName.cleanListener(this, own); }",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"b\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"c\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\")); assertEquals(Optional.of(\"a b\"), e.getField(\"b\")); assertEquals(Optional.of(\"a b\"), e.getField(\"c\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\n\\nb},\" + \"b = {a\\n \\nb},\" + \"c = {a \\n \\n b}}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\")); assertEquals(Optional.of(\"a b\"), e.getField(\"b\")); assertEquals(Optional.of(\"a b\"), e.getField(\"c\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,a = {a\\t\\tb},\" + \"b = {a\\t \\tb},\" + \"c = {a \\t \\t b}}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); BibEntry e = c.iterator().next(); assertEquals(Optional.of(\"a b\"), e.getField(\"a\")); assertEquals(Optional.of(\"a b\"), e.getField(\"b\")); assertEquals(Optional.of(\"a b\"), e.getField(\"c\"));",
        "label":1
    },
    {
        "ins1AddCode":"Executor executor = createExecutor(new JdbcTransaction(ds, null, false));",
        "ins1DelCode":"DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection));",
        "ins1PreCode":"public void shouldInsertNewAuthor() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try { Author author = new Author(99, \"someone\", \"******\", \"someone@apache.org\", null, Section.NEWS);",
        "ins2PreCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception { DataSource ds = createBlogDataSource(); Connection connection = ds.getConnection(); Executor executor = createExecutor(new JdbcTransaction(connection)); try { Author author = new Author(99, \"someone\", \"******\", \"someone@apache.org\", null, null);",
        "label":1
    },
    {
        "ins1AddCode":"report.append(String .format(\"%nThe use of configuration keys that have been renamed was found in the environment:%n%n\"));",
        "ins1DelCode":"report.append(String.format( \"%nThe use of configuration keys that have been \" + \"renamed was found in the environment:%n%n\"));",
        "ins1PreCode":"return null; } StringBuilder report = new StringBuilder(); report.append(String.format( \"%nThe use of configuration keys that have been \" + \"renamed was found in the environment:%n%n\")); append(report, content); report.append(String.format(\"%n\"));",
        "ins2PreCode":"return null; } StringBuilder report = new StringBuilder(); report.append(String.format( \"%nThe use of configuration keys that are no longer \" + \"supported was found in the environment:%n%n\")); append(report, content); report.append(String.format(\"%n\"));",
        "label":0
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> u1 = new DefaultCategoryDataset<>(); SlidingCategoryDataset<String, String> d1 = new SlidingCategoryDataset<>(u1, 0, 5); SlidingCategoryDataset<String, String> d2; DefaultCategoryDataset<String, String> u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset();",
        "ins1DelCode":"DefaultCategoryDataset u1 = new DefaultCategoryDataset(); SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2; DefaultCategoryDataset u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultCategoryDataset u1 = new DefaultCategoryDataset(); u1.addValue(1.0, \"R1\", \"C1\"); u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); SlidingCategoryDataset d2; d2 = (SlidingCategoryDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass()); assertTrue(d1.equals(d2));   u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\"); assertTrue(d1.equals(d2));",
        "ins2PreCode":"public void testSerialization() { DefaultCategoryDataset u1 = new DefaultCategoryDataset(); u1.addValue(1.0, \"R1\", \"C1\"); u1.addValue(2.0, \"R1\", \"C2\"); SlidingCategoryDataset d1 = new SlidingCategoryDataset(u1, 0, 5); DefaultCategoryDataset u2 SlidingCategoryDataset d2 = (SlidingCategoryDataset) assertTrue(d1.equals(d2)); assertTrue(d1.equals(d2)); assertTrue(d1.equals(d2)); u1.addValue(3.0, \"R1\", \"C3\"); assertFalse(d1.equals(d2)); DefaultCategoryDataset u2 = (DefaultCategoryDataset) d2.getUnderlyingDataset(); u2.addValue(3.0, \"R1\", \"C3\"); assertTrue(d1.equals(d2));",
        "label":1
    },
    {
        "ins1AddCode":"new SparkConf() .set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeapSize\", \"256mb\"));",
        "ins1DelCode":"new SparkConf().set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator()));",
        "ins1PreCode":"public void setup() { memoryManager = new TestMemoryManager( new SparkConf().set(\"spark.unsafe.offHeap\", \"\" + useOffHeapMemoryAllocator())); taskMemoryManager = new TaskMemoryManager(memoryManager, 0); ",
        "ins2PreCode":"public void setUp() { when(blockManager.getDiskWriter( new CompressStream(), sparkConf = new SparkConf(); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager);",
        "label":0
    },
    {
        "ins1AddCode":"int nRead = fillReadBuffer(block && remaining == 0);",
        "ins1DelCode":"int nRead = fillReadBuffer(block);",
        "ins1PreCode":"}   int nRead = fillReadBuffer(block);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"String sql = LOCK_ITEM_QUERY; if (!dataSource.isAtLeastV9()) { sql = LOCK_ITEM_QUERY_8V; } try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(sql)) {",
        "ins1DelCode":"try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {",
        "ins1PreCode":" List<OracleLockItem> locks = new ArrayList<>();  try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) {  String otype = (String) options.get(LockGraphManager.keyType);",
        "ins2PreCode":"List<ExasolLockItem> locks = new ArrayList<>(); try (JDBCPreparedStatement dbStat = ((JDBCSession) session).prepareStatement(LOCK_ITEM_QUERY)) { String otype = (String) options.get(LockGraphManager.keyType);",
        "label":0
    },
    {
        "ins1AddCode":"CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes, useClassLoaderResources);",
        "ins1DelCode":"CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);",
        "ins1PreCode":"if (cacheEntry == null) {  int objectMaxSizeBytes = getObjectMaxSizeBytes(); CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);  ",
        "ins2PreCode":"if (cacheEntry == null) { int objectMaxSizeBytes = getObjectMaxSizeBytes(); CachedResource newCacheEntry = new CachedResource(this, root, path, getTtl(), objectMaxSizeBytes);",
        "label":1
    },
    {
        "ins1AddCode":"private byte[] readRawBytesSlowPath( final int size, boolean ensureNoLeakedReferences) throws IOException { return ensureNoLeakedReferences ? result.clone() : result;",
        "ins1DelCode":"private byte[] readRawBytesSlowPath(final int size) throws IOException { return result;",
        "ins1PreCode":"private byte[] readRawBytesSlowPath(final int size) throws IOException {  byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return result; } ",
        "ins2PreCode":"private ByteString readBytesSlowPath(final int size) throws IOException { final byte[] result = readRawBytesSlowPathOneChunk(size); if (result != null) { return ByteString.wrap(result); }",
        "label":0
    },
    {
        "ins1AddCode":"void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception {",
        "ins1DelCode":"public void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception {",
        "ins1PreCode":"public void explodedJarHasOnlyBootInfClassesAndContentsOfBootInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.jar\", \"BOOT-INF\")); JarLauncher launcher = new JarLauncher(new ExplodedArchive(explodedRoot, true));",
        "ins2PreCode":"public void explodedWarHasOnlyWebInfClassesAndContentsOfWebInfLibOnClasspath() throws Exception { File explodedRoot = explode(createJarArchive(\"archive.war\", \"WEB-INF\")); WarLauncher launcher = new WarLauncher(new ExplodedArchive(explodedRoot, true));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\");",
        "ins1DelCode":"",
        "ins1PreCode":" ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\");",
        "ins2PreCode":"ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\");",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertSame(Flowable.empty(), Maybe.mergeArrayDelayError());",
        "ins1PreCode":".test() .assertFailure(TestException.class, 1);  assertSame(Flowable.empty(), Maybe.mergeArrayDelayError());",
        "ins2PreCode":".test() .assertFailure(TestException.class, 1); public void mergeDelayError2() {",
        "label":0
    },
    {
        "ins1AddCode":"} else if (adapter == DBAUserChangePassword.class) { return adapter.cast(new SQLServerChangeLoginPassword(this));",
        "ins1DelCode":"",
        "ins1PreCode":"return adapter.cast(new SQLServerStructureAssistant(this)); } else if (adapter == DBAServerSessionManager.class) { return adapter.cast(new SQLServerSessionManager(this)); } return super.getAdapter(adapter);",
        "ins2PreCode":"return adapter.cast(new ExasolStructureAssistant(this)); } else if (adapter == DBAServerSessionManager.class) { return adapter.cast(new ExasolServerSessionManager(this)); } return super.getAdapter(adapter);",
        "label":0
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\")",
        "ins1DelCode":"",
        "ins1PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag); ValueAxis axis = plot.getRangeAxis();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Class<?> valueType = scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType(); Object constant = scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant(); irConstantNode.attachDecoration(new IRDExpressionType(valueType)); irConstantNode.setConstant(constant);",
        "ins1DelCode":"irConstantNode.setExpressionType(scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant());",
        "ins1PreCode":"public void visitNumeric(ENumeric userNumericNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userNumericNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant());  scriptScope.putDecoration(userNumericNode, new IRNodeDecoration(irConstantNode));",
        "ins2PreCode":"public void visitDecimal(EDecimal userDecimalNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(userDecimalNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userDecimalNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userDecimalNode, StandardConstant.class).getStandardConstant()); scriptScope.putDecoration(userDecimalNode, new IRNodeDecoration(irConstantNode));",
        "label":1
    },
    {
        "ins1AddCode":"getTomcatInstanceTestWebapp(false, true);",
        "ins1DelCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start();",
        "ins1PreCode":"public void testBug54801() throws Exception { Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());  tomcat.start();  ByteChunk bc = new ByteChunk();",
        "ins2PreCode":"public void testBug54821() throws Exception { Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath()); tomcat.start(); ByteChunk bc = new ByteChunk();",
        "label":1
    },
    {
        "ins1AddCode":"final Collection<?> collection = (Collection<?>) values; if (collection.isEmpty()) {",
        "ins1DelCode":"@SuppressWarnings(\"unchecked\") final Collection<MType> collection = (Collection<MType>) values; if (collection.size() == 0) {",
        "ins1PreCode":" int size = -1; if (values instanceof Collection) { @SuppressWarnings(\"unchecked\") final Collection<MType> collection = (Collection<MType>) values; if (collection.size() == 0) { return this; }",
        "ins2PreCode":"int size = -1; if (values instanceof Collection) { @SuppressWarnings(\"unchecked\") final Collection<MType> collection = (Collection<MType>) values; if (collection.size() == 0) { return this; }",
        "label":1
    },
    {
        "ins1AddCode":"assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject()));",
        "ins1DelCode":"Assume.assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject()));",
        "ins1PreCode":"public void testPseudoTahoeRefid() { Assume.assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject()));  buildRule.executeTarget(\"test-pseudo-tahoe-refid\");",
        "ins2PreCode":"public void testPseudoTahoeNested() { Assume.assumeTrue(\"No regexp matcher is present\", RegexpMatcherFactory.regexpMatcherPresent(buildRule.getProject())); buildRule.executeTarget(\"test-pseudo-tahoe-nested\");",
        "label":1
    },
    {
        "ins1AddCode":"XYIntervalSeriesCollection c2 = TestUtils.serialised(c1);",
        "ins1DelCode":"XYIntervalSeriesCollection c2 = (XYIntervalSeriesCollection) TestUtils.serialised(c1);",
        "ins1PreCode":"XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); XYIntervalSeriesCollection c2 = (XYIntervalSeriesCollection) TestUtils.serialised(c1); assertEquals(c1, c2); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class) .withPropertyValues(\"management.metrics.export.wavefront.api-token=abcde\").run((context) -> {",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> {",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1DelCode":"assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_SYNCHRONIZED_ACK|Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_UDP); Thread.sleep(250); System.err.println(\"Finished SYNC_ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins2PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),Channel.SEND_OPTIONS_USE_ACK|Channel.SEND_OPTIONS_MULTICAST); Thread.sleep(250); System.err.println(\"Finished ACK\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "label":1
    },
    {
        "ins1AddCode":"File javaFile = new File(ctxt.getServletJavaFileName()); if (log.isDebugEnabled()) log.debug(\"Deleting \" + javaFile); if (javaFile.exists()) { if (!javaFile.delete()) { log.warn(Localizer.getMessage( \"jsp.warning.compiler.javafile.delete.fail\", javaFile.getAbsolutePath()));",
        "ins1DelCode":"String javaFileName = ctxt.getServletJavaFileName(); if (javaFileName != null) { File javaFile = new File(javaFileName); if (log.isDebugEnabled()) log.debug(\"Deleting \" + javaFile); if (javaFile.exists()) { if (!javaFile.delete()) { log.warn(Localizer.getMessage( \"jsp.warning.compiler.javafile.delete.fail\", javaFile.getAbsolutePath())); }",
        "ins1PreCode":"removeGeneratedClassFiles();  try { String javaFileName = ctxt.getServletJavaFileName(); if (javaFileName != null) { File javaFile = new File(javaFileName); if (log.isDebugEnabled()) log.debug(\"Deleting \" + javaFile);",
        "ins2PreCode":"public void removeGeneratedClassFiles() { try { String classFileName = ctxt.getClassFileName(); if (classFileName != null) { File classFile = new File(classFileName); if (log.isDebugEnabled()) log.debug(\"Deleting \" + classFile);",
        "label":0
    },
    {
        "ins1AddCode":"final int size = (int) offsetAndSize;",
        "ins1DelCode":"final int size = (int) (offsetAndSize & ((1L << 32) - 1));",
        "ins1PreCode":"} else { final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) (offsetAndSize & ((1L << 32) - 1)); final UnsafeArrayData array = new UnsafeArrayData(); array.pointTo(baseObject, baseOffset + offset, size);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"AsyncDisposable<T> as = new AsyncDisposable<>(observer, this);",
        "ins1DelCode":"AsyncDisposable<T> as = new AsyncDisposable<T>(observer, this);",
        "ins1PreCode":"protected void subscribeActual(Observer<? super T> observer) { AsyncDisposable<T> as = new AsyncDisposable<T>(observer, this); observer.onSubscribe(as); if (add(as)) {",
        "ins2PreCode":"protected void subscribeActual(Subscriber<? super T> s) { AsyncSubscription<T> as = new AsyncSubscription<T>(s, this); s.onSubscribe(as); if (add(as)) {",
        "label":1
    },
    {
        "ins1AddCode":"byte[] bytes = getBinary(ordinal); BigInteger bigInteger = new BigInteger(bytes); BigDecimal javaDecimal = new BigDecimal(bigInteger, scale); return Decimal.apply(javaDecimal, precision, scale);",
        "ins1DelCode":"long offsetAndSize = getLong(ordinal); long offset = offsetAndSize >>> 32; int signum = ((int) (offsetAndSize & 0xfff) >> 8); assert signum >=0 && signum <= 2 : \"invalid signum \" + signum; int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; Platform.copyMemory( baseObject, baseOffset + offset, mag, Platform.INT_ARRAY_OFFSET, size * 4); BigInteger v = new BigInteger(0, EMPTY); Platform.putInt(v, Platform.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); Platform.putObjectVolatile(v, Platform.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale);",
        "ins1PreCode":"if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.apply(getLong(ordinal), precision, scale); } else { long offsetAndSize = getLong(ordinal); long offset = offsetAndSize >>> 32; int signum = ((int) (offsetAndSize & 0xfff) >> 8); assert signum >=0 && signum <= 2 : \"invalid signum \" + signum; int size = (int) (offsetAndSize & 0xff); int[] mag = new int[size]; Platform.copyMemory( baseObject, baseOffset + offset, mag, Platform.INT_ARRAY_OFFSET, size * 4);   BigInteger v = new BigInteger(0, EMPTY); Platform.putInt(v, Platform.BIG_INTEGER_SIGNUM_OFFSET, signum - 1); Platform.putObjectVolatile(v, Platform.BIG_INTEGER_MAG_OFFSET, mag); return Decimal.apply(new BigDecimal(v, scale), precision, scale); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(@NotNull Throwable error) {",
        "ins1DelCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(Throwable error) {",
        "ins1PreCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(Throwable error) { String message = error.getMessage(); if (!CommonUtils.isEmpty(message)) {",
        "ins2PreCode":"public DBPErrorAssistant.ErrorPosition getErrorPosition(Throwable error) { String message = error.getMessage(); if (!CommonUtils.isEmpty(message)) {",
        "label":1
    },
    {
        "ins1AddCode":"TimedNode<Object> h = new TimedNode<>(null, 0L);",
        "ins1DelCode":"TimedNode<Object> h = new TimedNode<Object>(null, 0L);",
        "ins1PreCode":"this.maxAge = ObjectHelper.verifyPositive(maxAge, \"maxAge\"); this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<Object> h = new TimedNode<Object>(null, 0L); this.tail = h; this.head = h;",
        "ins2PreCode":"this.maxAge = ObjectHelper.verifyPositive(maxAge, \"maxAge\"); this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<T> h = new TimedNode<T>(null, 0L); this.tail = h; this.head = h;",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 36; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 33; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 33; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"final List<String> events = new ArrayList<>();",
        "ins1DelCode":"final List<String> events = new ArrayList<String>();",
        "ins1PreCode":"public void usingDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events); final Consumer<Throwable> onError = createOnErrorAction(events);",
        "ins2PreCode":"public void usingDoesNotDisposesEagerlyBeforeError() { final List<String> events = new ArrayList<String>(); final Supplier<Resource> resourceFactory = createResourceFactory(events); final Consumer<Throwable> onError = createOnErrorAction(events);",
        "label":1
    },
    {
        "ins1AddCode":"HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize), HiveHasher.hashUnsafeBytes(bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize)); hashcodes.add(HiveHasher.hashUnsafeBytes( bytes, Platform.BYTE_ARRAY_OFFSET, byteArrSize));",
        "ins1DelCode":"MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb)); hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb));",
        "ins1PreCode":"int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes);  Assert.assertEquals( HiveHasher.hashUnsafeBytesBlock(mb), HiveHasher.hashUnsafeBytesBlock(mb));  hashcodes.add(HiveHasher.hashUnsafeBytesBlock(mb)); } ",
        "ins2PreCode":"int byteArrSize = rand.nextInt(100) * 8; byte[] bytes = new byte[byteArrSize]; rand.nextBytes(bytes); MemoryBlock mb = ByteArrayMemoryBlock.fromArray(bytes); Assert.assertEquals( hasher.hashUnsafeWordsBlock(mb), hasher.hashUnsafeWordsBlock(mb)); hashcodes.add(hasher.hashUnsafeWordsBlock(mb)); }",
        "label":1
    },
    {
        "ins1AddCode":"p.addProperty(new ParametersDefinitionProperty(Collections.singletonList( FileUtils.write(uploadedFile, \"test1\", StandardCharsets.UTF_8);",
        "ins1DelCode":"p.addProperty(new ParametersDefinitionProperty(Arrays.asList( FileUtils.write(uploadedFile, \"test1\");",
        "ins1PreCode":"public void fileParameter_canStillUse_doubleDotsInFileName() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.addProperty(new ParametersDefinitionProperty(Arrays.asList( new FileParameterDefinition(\"weird..name.txt\", null) )));  File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, \"test1\");  FreeStyleBuild build = j.assertBuildStatusSuccess(p.scheduleBuild2(0, new Cause.UserIdCause(), new ParametersAction(",
        "ins2PreCode":"public void fileParameter_canStillUse_TildeInFileName() throws Exception { FreeStyleProject p = j.createFreeStyleProject(); p.addProperty(new ParametersDefinitionProperty(Arrays.asList( new FileParameterDefinition(\"~name\", null) ))); File uploadedFile = tmp.newFile(); FileUtils.write(uploadedFile, \"test1\"); FreeStyleBuild build = j.assertBuildStatusSuccess(p.scheduleBuild2(0, new Cause.UserIdCause(), new ParametersAction(",
        "label":1
    },
    {
        "ins1AddCode":"if (maxMessageSize > -1 && maxMessageSize > session.getMaxTextMessageBufferSize()) { if (maxMessageSize > Integer.MAX_VALUE) { } session.setMaxTextMessageBufferSize((int) maxMessageSize); }",
        "ins1DelCode":"",
        "ins1PreCode":"indexSession, maxMessageSize);   Class<?> type = method.getParameterTypes()[indexPayload]; if (Util.isPrimitive(type)) { primitiveType = type; return; } else { primitiveType = null; }",
        "ins2PreCode":"indexSession, maxMessageSize); super(pojo, method, session, params, indexPayload, convert, if (Binary.class.isAssignableFrom(decoderClazz)) { decoder.init(config); decoder.init(config); } else { if (decoderClazzes != null) { }",
        "label":1
    },
    {
        "ins1AddCode":"String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]); BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new OpenBlocks(\"app-id\", \"exec-id\", blockIds), conf);",
        "ins1DelCode":"BlockFetchingListener listener = fetchBlocks(blocks);",
        "ins1PreCode":"blocks.put(\"b1\", null); blocks.put(\"b2\", null);  BlockFetchingListener listener = fetchBlocks(blocks);  ",
        "ins2PreCode":"blocks.put(\"b1\", null); blocks.put(\"b1\", null); BlockFetchingListener listener = fetchBlocks(blocks);",
        "label":1
    },
    {
        "ins1AddCode":"void customExceptionConversionWord(CapturedOutput output) { assertThat(fileContents).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\"); assertThat(output).contains(\"java.lang.RuntimeException: Expected\").doesNotContain(\"Wrapped by:\");",
        "ins1DelCode":"public void customExceptionConversionWord() { Matcher<String> expectedOutput = Matchers.allOf(containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); assertThat(fileContents).is(Matched.by(expectedOutput));",
        "ins1PreCode":"public void customExceptionConversionWord() { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(this.initializationContext, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf(containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput)); } finally {",
        "ins2PreCode":"public void customExceptionConversionWord() { System.setProperty(LoggingSystemProperties.EXCEPTION_CONVERSION_WORD, \"%ex\"); try { this.loggingSystem.beforeInitialize(); this.logger.info(\"Hidden\"); this.loggingSystem.initialize(null, null, getLogFile(null, tmpDir())); Matcher<String> expectedOutput = Matchers.allOf(containsString(\"java.lang.RuntimeException: Expected\"), not(containsString(\"Wrapped by:\"))); this.output.expect(expectedOutput); this.logger.warn(\"Expected exception\", new RuntimeException(\"Expected\", new RuntimeException(\"Cause\"))); String fileContents = contentOf(new File(tmpDir() + \"/spring.log\")); assertThat(fileContents).is(Matched.by(expectedOutput)); } finally {",
        "label":1
    },
    {
        "ins1AddCode":"if (returnedInput != null) { if (returnedInput.remaining() < len) { len = returnedInput.remaining(); returnedInput.get(b, off, len); if (returnedInput.remaining() == 0) { returnedInput = null;",
        "ins1DelCode":"if (leftOverInput != null) { if (leftOverInput.remaining() < len) { len = leftOverInput.remaining(); leftOverInput.get(b, off, len); if (leftOverInput.remaining() == 0) { leftOverInput = null;",
        "ins1PreCode":"throw new IOException(sm.getString(\"socket.apr.closed\", getSocket())); }  if (leftOverInput != null) { if (leftOverInput.remaining() < len) { len = leftOverInput.remaining(); } leftOverInput.get(b, off, len); if (leftOverInput.remaining() == 0) { leftOverInput = null; } return len;",
        "ins2PreCode":"throw new EOFException(); } if (nRead > leftToWrite) { if (remaining >= len) { int remaining = readBuffer.remaining(); } readBuffer.get(b, off, len); if (remaining > 0) { leftToWrite -= remaining; } return len;",
        "label":0
    },
    {
        "ins1AddCode":"TestSingle<Integer> tc = new TestSingle<>();",
        "ins1DelCode":"TestSingle<Integer> tc = new TestSingle<Integer>();",
        "ins1PreCode":"public void dispose() { TestSingle<Integer> tc = new TestSingle<Integer>(); tc.dispose(); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(asList(m.entrySet())).isEqualTo(asList(expected.entrySet()));",
        "ins1DelCode":"assertThat(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "ins1PreCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "ins2PreCode":"ImmutableMap<String, String> expected = ImmutableMap.of(\"boy\", \"tom\", \"girl\", \"tina\", \"cat\", \"kitty\", \"dog\", \"tommy\"); assertThat(m).isEqualTo(expected); assertThat(asList(m.entrySet())).is(asList(expected.entrySet()));",
        "label":1
    },
    {
        "ins1AddCode":"this.bootstrapRegistry, Arrays.asList(firstContributor, secondContributor));",
        "ins1DelCode":"Arrays.asList(firstContributor, secondContributor));",
        "ins1PreCode":"ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext); assertThat(binder.bind(\"test\", String.class).get()).isEqualTo(\"one\");",
        "ins2PreCode":"ConfigDataEnvironmentContributor secondContributor = ConfigDataEnvironmentContributor.ofImported(null, configData, 1, this.activationContext); ConfigDataEnvironmentContributors contributors = new ConfigDataEnvironmentContributors(this.logFactory, Arrays.asList(firstContributor, secondContributor)); Binder binder = contributors.getBinder(this.activationContext); assertThat(binder.bind(\"test\", String.class).get()).isEqualTo(\"two\");",
        "label":1
    },
    {
        "ins1AddCode":"final SparkConf conf = new SparkConf().set(\"spark.memory.offHeap.enabled\", \"false\");",
        "ins1DelCode":"final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\");",
        "ins1PreCode":"public void heap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"false\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0);",
        "ins2PreCode":"public void offHeap() throws IOException { final SparkConf conf = new SparkConf().set(\"spark.unsafe.offHeap\", \"true\"); final TaskMemoryManager memoryManager = new TaskMemoryManager(new TestMemoryManager(conf), 0);",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); renderer.setSeriesToolTipGenerator(0, tt);",
        "label":0
    },
    {
        "ins1AddCode":".withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2);",
        "ins1DelCode":".withPropertyValues(\"management.metrics.web.client.max-uri-tags=10\") WebClient.Builder builder = context.getBean(WebClient.Builder.class); WebClient webClient = builder.clientConnector(this.connector).build(); MetricsProperties properties = context .getBean(MetricsProperties.class); int maxUriTags = properties.getWeb().getClient().getMaxUriTags(); MeterRegistry registry = context.getBean(MeterRegistry.class); for (int i = 0; i < maxUriTags + 10; i++) { webClient.get().uri(\"http://example.org/projects/\" + i).exchange() .block(); } assertThat(registry.get(\"http.client.requests\").meters()) .hasSize(maxUriTags);",
        "ins1PreCode":"public void afterMaxUrisReachedFurtherUrisAreDenied() { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=10\") .run((context) -> { WebClient.Builder builder = context.getBean(WebClient.Builder.class); WebClient webClient = builder.clientConnector(this.connector).build(); MetricsProperties properties = context .getBean(MetricsProperties.class); int maxUriTags = properties.getWeb().getClient().getMaxUriTags(); MeterRegistry registry = context.getBean(MeterRegistry.class); for (int i = 0; i < maxUriTags + 10; i++) { webClient.get().uri(\"http://example.org/projects/\" + i).exchange() .block(); } assertThat(registry.get(\"http.client.requests\").meters()) .hasSize(maxUriTags); assertThat(this.out.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\");",
        "ins2PreCode":"public void afterMaxUrisReachedFurtherUrisAreDenied() { this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") .run((context) -> { this.contextRunner assertThat(this.out.toString()) this.contextRunner .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") MeterRegistry registry = getInitializedMeterRegistry(context); .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); }); } assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); .withPropertyValues(\"management.metrics.web.client.max-uri-tags=2\") assertThat(this.out.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\");",
        "label":0
    },
    {
        "ins1AddCode":"jj_la1[42] = jj_gen; jj_la1[43] = jj_gen;",
        "ins1DelCode":"jj_la1[43] = jj_gen; jj_la1[44] = jj_gen;",
        "ins1PreCode":"} break; default: jj_la1[44] = jj_gen; ; }",
        "ins2PreCode":"} break; default: jj_la1[45] = jj_gen; ; }",
        "label":1
    },
    {
        "ins1AddCode":"if (credentials == null || serverCredentials == null) { if (containerLog.isTraceEnabled()) { containerLog.trace(sm.getString(\"realmBase.authenticateFailure\", username)); } return null; }",
        "ins1DelCode":"",
        "ins1PreCode":" String serverCredentials = getPassword(username);  boolean validated = getCredentialHandler().matches(credentials, serverCredentials); if (!validated) { if (containerLog.isTraceEnabled()) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private void assertReadLittleEndian32(byte[] data, int value) throws Exception { for (InputType inputType : InputType.values()) { for (int blockSize = 1; blockSize <= 16; blockSize *= 2) { CodedInputStream input = inputType.newDecoder(data, blockSize); assertEquals(inputType.name(), value, input.readRawLittleEndian32()); assertTrue(inputType.name(), input.isAtEnd()); }",
        "ins1DelCode":"private void assertReadLittleEndian32(byte[] data, int value) throws Exception { CodedInputStream input = CodedInputStream.newInstance(data); assertEquals(value, input.readRawLittleEndian32()); assertTrue(input.isAtEnd()); for (int blockSize = 1; blockSize <= 16; blockSize *= 2) { input = CodedInputStream.newInstance( new SmallBlockInputStream(data, blockSize)); assertEquals(value, input.readRawLittleEndian32()); assertTrue(input.isAtEnd());",
        "ins1PreCode":"private void assertReadLittleEndian32(byte[] data, int value) throws Exception { CodedInputStream input = CodedInputStream.newInstance(data); assertEquals(value, input.readRawLittleEndian32()); assertTrue(input.isAtEnd());   for (int blockSize = 1; blockSize <= 16; blockSize *= 2) { input = CodedInputStream.newInstance( new SmallBlockInputStream(data, blockSize)); assertEquals(value, input.readRawLittleEndian32()); assertTrue(input.isAtEnd()); }",
        "ins2PreCode":"private void assertReadLittleEndian64(byte[] data, long value) throws Exception { CodedInputStream input = CodedInputStream.newInstance(data); assertEquals(value, input.readRawLittleEndian64()); assertTrue(input.isAtEnd()); for (int blockSize = 1; blockSize <= 16; blockSize *= 2) { input = CodedInputStream.newInstance( new SmallBlockInputStream(data, blockSize)); assertEquals(value, input.readRawLittleEndian64()); assertTrue(input.isAtEnd()); }",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(adapter.stream()).hasSize(2); assertThat(adapter.stream()).hasSize(3);",
        "ins1DelCode":"assertThat(adapter.stream().count()).isEqualTo(2); assertThat(adapter.stream().count()).isEqualTo(3);",
        "ins1PreCode":"EnumerablePropertySource<?> source = new MapPropertySource(\"test\", map); SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.setThrowException(true); map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(3);",
        "ins2PreCode":"EnumerablePropertySource<?> source = new OriginTrackedMapPropertySource(\"test\", map); SpringIterableConfigurationPropertySource adapter = new SpringIterableConfigurationPropertySource(source, DefaultPropertyMapper.INSTANCE); assertThat(adapter.stream().count()).isEqualTo(2); map.put(\"key1\", \"value1\"); map.put(\"key3\", \"value3\"); assertThat(adapter.stream().count()).isEqualTo(3);",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\") XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":" LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws Exception {",
        "ins1DelCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException {",
        "ins1PreCode":"void portClashOfSecondaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> { assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {",
        "ins2PreCode":"void portClashOfPrimaryConnectorResultsInPortInUseException() throws IOException { doWithBlockedPort((port) -> { assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> {",
        "label":0
    },
    {
        "ins1AddCode":"sortedRDD = rdd.sortByKey(Collections.reverseOrder(), false);",
        "ins1DelCode":"sortedRDD = rdd.sortByKey(Collections.<Integer>reverseOrder(), false);",
        "ins1PreCode":"assertEquals(new Tuple2<>(3, 2), sortedPairs.get(2));   sortedRDD = rdd.sortByKey(Collections.<Integer>reverseOrder(), false); assertEquals(new Tuple2<>(-1, 1), sortedRDD.first()); sortedPairs = sortedRDD.collect();",
        "ins2PreCode":"assertEquals(new Tuple2<>(3, 2), sortedPairs.get(2)); sortedRDD = rdd.sortBy(new Function<Tuple2<Integer, Integer>, Integer>() { assertEquals(new Tuple2<>(-1, 1), sortedRDD.first()); sortedPairs = sortedRDD.collect();",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), key.length)); Assert.assertTrue( arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), value.length)); Assert.assertTrue( arrayEquals(key, loc.getKeyBase(), loc.getKeyOffset(), loc.getKeyLength())); Assert.assertTrue( arrayEquals(value, loc.getValueBase(), loc.getValueOffset(), loc.getValueLength()));",
        "ins1DelCode":"Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength()));",
        "ins1PreCode":"Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } }  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength())); } } finally {",
        "ins2PreCode":"Assert.assertTrue(loc.isDefined()); Assert.assertEquals(key.length, loc.getKeyLength()); Assert.assertEquals(value.length, loc.getValueLength()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), key.length)); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), value.length)); } } for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = JavaUtils.bufferToArray(entry.getKey()); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc = map.lookup(key, Platform.BYTE_ARRAY_OFFSET, key.length); Assert.assertTrue(loc.isDefined()); Assert.assertTrue(arrayEquals(key, loc.getKeyAddress(), loc.getKeyLength())); Assert.assertTrue(arrayEquals(value, loc.getValueAddress(), loc.getValueLength())); } } finally {",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(buildRule.getFullLog(), not(containsString(\"Skipped grammar file.\"))); assertThat(buildRule.getFullLog(), not(containsString(\"Skipped grammar file.\")));",
        "ins1DelCode":"assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog()); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog());",
        "ins1PreCode":"public void testNormalRecompile() { buildRule.executeTarget(\"test9\"); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog());  FileUtilities.rollbackTimestamps(buildRule.getOutputDir(), 5);  buildRule.executeTarget(\"normalRecompile\"); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog());",
        "ins2PreCode":"public void testSupergrammarChangeRecompile() { buildRule.executeTarget(\"test9\"); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog()); FileUtilities.rollbackTimestamps(buildRule.getOutputDir(), 5); buildRule.executeTarget(\"supergrammarChangeRecompile\"); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog());",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}};  CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); ",
        "ins2PreCode":"{new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1AddCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8, true);",
        "ins1DelCode":"AUTH_HEADER.getHeader(), StandardCharsets.UTF_8);",
        "ins1PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, SHORT_PASSWORD); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(SHORT_PASSWORD, credentials.getPassword());",
        "ins2PreCode":"new BasicAuthHeader(NICE_METHOD, USER_NAME, PASSWORD, \"    \"); BasicAuthenticator.BasicCredentials credentials = new BasicAuthenticator.BasicCredentials( AUTH_HEADER.getHeader(), StandardCharsets.UTF_8); Assert.assertEquals(USER_NAME, credentials.getUsername()); Assert.assertEquals(PASSWORD, credentials.getPassword());",
        "label":1
    },
    {
        "ins1AddCode":"ds.setBasedir(new File(getProject().getProperty(\"output\")));",
        "ins1DelCode":"ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\"));",
        "ins1PreCode":"public void testPatternsDifferInCaseScanningInsensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/\"}); ds.setCaseSensitive(false);",
        "ins2PreCode":"public void testParentDiffersInCaseScanningInsensitive() { DirectoryScanner ds = new DirectoryScanner(); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/\", \"ALPHA/beta/\"}); ds.setCaseSensitive(false);",
        "label":1
    },
    {
        "ins1AddCode":"null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\", null, \"'def'\"",
        "ins1DelCode":"null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\"",
        "ins1PreCode":"\"'!=='\", \"'&'\", \"'^'\", \"'|'\", \"'&&'\", \"'||'\", \"'?'\", \"':'\", \"'?:'\", \"'::'\", \"'->'\", \"'=~'\", \"'==~'\", \"'++'\", \"'--'\", \"'='\", \"'+='\", \"'-='\", \"'*='\", \"'/='\", \"'%='\", \"'&='\", \"'^='\", \"'|='\", \"'<<='\", \"'>>='\", \"'>>>='\", null, null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\"",
        "ins2PreCode":"\"'!=='\", \"'&'\", \"'^'\", \"'|'\", \"'&&'\", \"'||'\", \"'?'\", \"':'\", \"'?:'\", \"'::'\", \"'->'\", \"'=~'\", \"'==~'\", \"'++'\", \"'--'\", \"'='\", \"'+='\", \"'-='\", \"'*='\", \"'/='\", \"'%='\", \"'&='\", \"'^='\", \"'|='\", \"'<<='\", \"'>>='\", \"'>>>='\", null, null, null, null, null, null, \"'true'\", \"'false'\", \"'null'\"",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"init();",
        "ins1PreCode":"public void testPoolThreads20Connections10() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(false);",
        "ins2PreCode":"public void testPoolThreads20Connections10Fair() throws Exception { init(); this.datasource.getPoolProperties().setMaxActive(10); this.datasource.getPoolProperties().setFairQueue(true);",
        "label":1
    },
    {
        "ins1AddCode":"pushResolver.receiveBlockDataAsStream( new PushBlockStream(TEST_APP, NO_ATTEMPT_ID, 0, 0, 0, 0)); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, NO_ATTEMPT_ID, 0));",
        "ins1DelCode":"pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0));",
        "ins1PreCode":"public void testFailureAfterMultipleDataBlocks() throws IOException { StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); assertEquals(\"num-chunks\", 0, blockMeta.getNumChunks());",
        "ins2PreCode":"public void testFailureAfterComplete() throws IOException { StreamCallbackWithID stream = pushResolver.receiveBlockDataAsStream(new PushBlockStream(TEST_APP, 0, 0, 0, 0)); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[2])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[3])); stream.onData(stream.getID(), ByteBuffer.wrap(new byte[4])); stream.onFailure(stream.getID(), new RuntimeException(\"Forced Failure\")); pushResolver.finalizeShuffleMerge(new FinalizeShuffleMerge(TEST_APP, 0)); MergedBlockMeta blockMeta = pushResolver.getMergedBlockMeta(TEST_APP, 0, 0); validateChunks(TEST_APP, 0, 0, blockMeta, new int[]{9}, new int[][]{{0}});",
        "label":1
    },
    {
        "ins1AddCode":"Statement statement = configureDataSourceBehavior(",
        "ins1DelCode":"Statement statement = configureDataSourceBehaviour(",
        "ins1PreCode":"ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:hsql://localhost\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "ins2PreCode":"ConfigurableApplicationContext context = createContext(\"org.h2.Driver\", \"jdbc:h2:mem:test\", DataSourceAutoConfiguration.class, DataSourceSpyConfiguration.class); Statement statement = configureDataSourceBehaviour( context.getBean(DataSource.class)); context.close();",
        "label":1
    },
    {
        "ins1AddCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), MatcherWatchdog.noop());",
        "ins1DelCode":"GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop());",
        "ins1PreCode":"public void testBuild() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop());  Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"public void testBuildWithIgnoreMissing() throws Exception { GrokProcessor.Factory factory = new GrokProcessor.Factory(Collections.emptyMap(), ThreadWatchdog.noop()); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"new ArrayList<String>(message.getStringToInt32FieldMap().keySet()));",
        "ins1DelCode":"new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins1PreCode":" assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":"assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet())); Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "label":1
    },
    {
        "ins1AddCode":"List<String> results = new ArrayList<>();",
        "ins1DelCode":"ArrayList<String> results = new ArrayList<>();",
        "ins1PreCode":"public String[] getRoles() {  User user = (User) this.resource; ArrayList<String> results = new ArrayList<>(); Iterator<Role> roles = user.getRoles(); while (roles.hasNext()) {",
        "ins2PreCode":"public String[] getRoles() { Group group = (Group) this.resource; ArrayList<String> results = new ArrayList<>(); Iterator<Role> roles = group.getRoles(); while (roles.hasNext()) {",
        "label":1
    },
    {
        "ins1AddCode":"String utf8Pass = \"123\\u00A3\";",
        "ins1DelCode":"String utf8Pass = \"123\u00a3\";",
        "ins1PreCode":"SecurityCollection collection = new SecurityCollection(); collection.addPatternDecoded(\"/\"); String utf8User = \"test\"; String utf8Pass = \"123\u00a3\";  tomcat.addUser(utf8User, utf8Pass);",
        "ins2PreCode":"SecurityCollection collection = new SecurityCollection(); collection.addPatternDecoded(\"/*\"); ctx.addConstraint(sc); ctx.addConstraint(sc); tomcat.addUser(USER, PWD);",
        "label":0
    },
    {
        "ins1AddCode":"final Jenkins jenkins = Jenkins.get();",
        "ins1DelCode":"final Jenkins jenkins = Jenkins.getActiveInstance();",
        "ins1PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.getActiveInstance();  final HashSet<String> hs = new HashSet<>(nodes);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleModule.class)).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isTrue();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWeb.class)).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"Iterator<? extends T> it = this.iterator;",
        "ins1DelCode":"Iterator<? extends T> it = this.it;",
        "ins1PreCode":"void slowPath(long r) { long e = 0L; Iterator<? extends T> it = this.it; Subscriber<? super T> a = downstream; ",
        "ins2PreCode":"void fastPath() { a.onError(ex); Iterator<? extends T> it = this.it; ConditionalSubscriber<? super T> a = downstream;",
        "label":1
    },
    {
        "ins1AddCode":"Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32FieldMap().keySet()));",
        "ins1DelCode":"Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "ins1PreCode":"TestMap message = builder.build();  assertEquals( Arrays.asList(\"1\", \"2\", \"3\"), new ArrayList<>(message.getStringToInt32Field().keySet()));",
        "ins2PreCode":"TestMap message = builder.build(); assertEquals( new ArrayList<String>(message.getStringToInt32Field().keySet()));",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Person must be a director\", Director.class, person.getClass());",
        "ins1DelCode":"Assert.assertEquals(\"Person must be a director\", (Object)Director.class, (Object)person.getClass());",
        "ins1PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.get(1L); Assert.assertNotNull(\"Person must not be null\", person); Assert.assertEquals(\"Person must be a director\", (Object)Director.class, (Object)person.getClass()); sqlSession.close();",
        "ins2PreCode":"PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.get2(1L); Assert.assertNotNull(\"Person must not be null\", person); Assert.assertEquals(\"Person must be a director\", (Object)Director.class, (Object)person.getClass()); sqlSession.close();",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(Tuple2::swap);",
        "ins1DelCode":"JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(x -> x.swap());",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> reversed = pairStream.mapToPair(x -> x.swap()); JavaTestUtils.attachTestOutputStream(reversed); List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<> (); Author author2 = (Author) ((JavassistProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>());",
        "ins1DelCode":"HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<String, ResultLoaderMap.LoadPair> (); Author author2 = (Author) ((JavassistProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>());",
        "ins1PreCode":"public void shouldFailCallingAnUnloadedProperty() throws Exception {  HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<String, ResultLoaderMap.LoadPair> (); unloadedProperties.put(\"ID\", null); Author author2 = (Author) ((JavassistProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId();",
        "ins2PreCode":"public void shouldFailCallingAnUnloadedProperty() throws Exception { HashMap<String, ResultLoaderMap.LoadPair> unloadedProperties = new HashMap<String, ResultLoaderMap.LoadPair>(); unloadedProperties.put(\"ID\", null); Author author2 = (Author) ((CglibProxyFactory)proxyFactory).createDeserializationProxy(author, unloadedProperties, new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId();",
        "label":1
    },
    {
        "ins1AddCode":"BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "ins1DelCode":"BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));",
        "ins1PreCode":" when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());",
        "ins2PreCode":"when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData(), new Defaults(BibDatabaseMode.BIBTEX)); databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, String[]> values = new HashMap<>();",
        "ins1DelCode":"Map<String, String[]> values = new HashMap<String, String[]>();",
        "ins1PreCode":"p.setProperty( \"key3\", \"value3\" ); p.setProperty( \"key4\", \"value4\" );  Map<String, String[]> values = new HashMap<String, String[]>(); values.put( \"key\", new String[] { \"${key}\", \"${key2}\" } ); values.put( \"key2\", new String[] { \"${key3}\", \"${key4}\" } );",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), entry.getField(StandardField.FILE));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), entry.getField(\"file\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"D:\\\\Documents\\\\literature\\\\Tansel-PRL2006.pdf\"), entry.getField(\"file\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"1-4~#nov#\"), entry.getField(\"date\"));",
        "label":1
    },
    {
        "ins1AddCode":"this.context = getContext( () -> loadContext(\"spring.devtools.remote.secret:supersecret\"));",
        "ins1DelCode":"loadContext(\"spring.devtools.remote.secret:supersecret\");",
        "ins1PreCode":"public void ignoresInvalidSecretInRequest() throws Exception { loadContext(\"spring.devtools.remote.secret:supersecret\"); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); this.request.setRequestURI(DEFAULT_CONTEXT_PATH + \"/restart\");",
        "ins2PreCode":"public void invokeRestartWithDefaultSetup() throws Exception { loadContext(\"spring.devtools.remote.secret:supersecret\"); DispatcherFilter filter = this.context.getBean(DispatcherFilter.class); this.request.setRequestURI(DEFAULT_CONTEXT_PATH + \"/restart\");",
        "label":1
    },
    {
        "ins1AddCode":"result.add(shrinkStatus(stat));",
        "ins1DelCode":"result.add(stat);",
        "ins1PreCode":"if (stat.isDirectory()) { addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(stat); } }",
        "ins2PreCode":"if (stat.isDirectory()) { addInputPathRecursively(result, fs, stat.getPath(), inputFilter); } else { result.add(stat); } }",
        "label":0
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0);",
        "label":0
    },
    {
        "ins1AddCode":"LayeredBarRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"LayeredBarRenderer r2 = (LayeredBarRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { LayeredBarRenderer r1 = new LayeredBarRenderer(); LayeredBarRenderer r2 = (LayeredBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"File dir1 = buildRule.getProject().resolveFile(\".\"); File dir2 = buildRule.getProject().resolveFile(\"subant/subant-test1\"); File dir3 = buildRule.getProject().resolveFile(\"subant/subant-test2\");",
        "ins1DelCode":"File dir1 = project.resolveFile(\".\"); File dir2 = project.resolveFile(\"subant/subant-test1\"); File dir3 = project.resolveFile(\"subant/subant-test2\");",
        "ins1PreCode":"public void testgenericantfile() { File dir1 = project.resolveFile(\".\"); File dir2 = project.resolveFile(\"subant/subant-test1\"); File dir3 = project.resolveFile(\"subant/subant-test2\");  testBaseDirs(\"testgenericantfile\",",
        "ins2PreCode":"public void testantfile() { File dir1 = project.resolveFile(\".\"); File dir2 = project.resolveFile(\"subant/subant-test1\"); File dir2 = project.resolveFile(\"subant/subant-test1\"); testBaseDirs(\"testantfile\",",
        "label":1
    },
    {
        "ins1AddCode":"set.add(new Medra());",
        "ins1DelCode":"",
        "ins1PreCode":"set.add(new LibraryOfCongress(importFormatPreferences)); set.add(new IacrEprintFetcher(importFormatPreferences)); set.add(new RfcFetcher(importFormatPreferences)); return set;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"(expectedJson != null ? expectedJson.toString() : null),",
        "ins1DelCode":"(expectedJson == null ? null : expectedJson.toString()),",
        "ins1PreCode":"} try { return JSONCompare.compareJSON( (expectedJson == null ? null : expectedJson.toString()), this.actual.toString(), compareMode); }",
        "ins2PreCode":"} try { return JSONCompare.compareJSON( (expectedJson == null ? null : expectedJson.toString()), this.actual.toString(), comparator); }",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"Project p = buildRule.getProject();",
        "ins1PreCode":"public void testBasic() {  Project p = buildRule.getProject(); p.setUserProperty(\"test.direct\", DIRECT_MESSAGE); p.setUserProperty(\"test.delayed\", DELAYED_MESSAGE);",
        "ins2PreCode":"public void testThreadCount() { Project p = buildRule.getProject(); p.setUserProperty(\"test.direct\", DIRECT_MESSAGE); p.setUserProperty(\"test.delayed\", DELAYED_MESSAGE);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts(), \"Check artifact list\" ); assertEquals( \"3.0\", getArtifact( \"b\", res.getArtifacts() ).getVersion(), \"Check version\" );",
        "ins1DelCode":"assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() ); assertEquals( \"Check version\", \"3.0\", getArtifact( \"b\", res.getArtifacts() ).getVersion() );",
        "ins1PreCode":"ArtifactSpec b = createArtifactSpec( \"b\", \"3.0\" );  ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() ); assertEquals( \"Check version\", \"3.0\", getArtifact( \"b\", res.getArtifacts() ).getVersion() );",
        "ins2PreCode":"ArtifactSpec b = createArtifactSpec( \"b\", \"2.0\" ); ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() ); assertEquals( \"Check version\", \"2.0\", getArtifact( \"b\", res.getArtifacts() ).getVersion() );",
        "label":1
    },
    {
        "ins1AddCode":"DefaultXYZDataset d2 = TestUtils.serialised(d1); d2 = TestUtils.serialised(d1);",
        "ins1DelCode":"DefaultXYZDataset d2 = (DefaultXYZDataset) TestUtils.serialised(d1); d2 = (DefaultXYZDataset) TestUtils.serialised(d1);",
        "ins1PreCode":"public void testSerialization() { DefaultXYZDataset d1 = new DefaultXYZDataset(); DefaultXYZDataset d2 = (DefaultXYZDataset) TestUtils.serialised(d1); assertEquals(d1, d2);   double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[] z1 = new double[] {7.0, 8.0, 9.0}; double[][] data1 = new double[][] {x1, y1, z1}; d1.addSeries(\"S1\", data1); d2 = (DefaultXYZDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "ins2PreCode":"public void testSerialization() { DefaultXYDataset d1 = new DefaultXYDataset(); DefaultXYDataset d2 = (DefaultXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2); double[] x1 = new double[] {1.0, 2.0, 3.0}; double[] y1 = new double[] {4.0, 5.0, 6.0}; double[] x1 = new double[] {1.0, 2.0, 3.0}; double[][] data1 = new double[][] {x1, y1}; d1.addSeries(\"S1\", data1); d2 = (DefaultXYDataset) TestUtils.serialised(d1); assertEquals(d1, d2);",
        "label":1
    },
    {
        "ins1AddCode":"Map<Integer, String> expected = new HashMap<>();",
        "ins1DelCode":"Map<Integer, String> expected = new HashMap<Integer, String>();",
        "ins1PreCode":" Observable<Map<Integer, String>> mapped = source.toMap(lengthFunc, duplicate).toObservable();  Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"aa\"); expected.put(2, \"bbbb\");",
        "ins2PreCode":"Single<Map<Integer, String>> mapped = source.toMap(lengthFunc); Map<Integer, String> expected = new HashMap<Integer, String>(); expected.put(1, \"a\"); expected.put(2, \"bb\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"a b\"), parsedEntry.getField(new UnknownField(\"a\"))); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(new UnknownField(\"b\"))); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(new UnknownField(\"c\")));",
        "ins1DelCode":"assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"b\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"c\"));",
        "ins1PreCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next();  assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"b\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"c\"));",
        "ins2PreCode":"Collection<BibEntry> parsedEntries = result.getDatabase().getEntries(); BibEntry parsedEntry = parsedEntries.iterator().next(); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"a\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"b\")); assertEquals(Optional.of(\"a b\"), parsedEntry.getField(\"c\"));",
        "label":1
    },
    {
        "ins1AddCode":"dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\");",
        "ins1DelCode":"dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), null, new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\");",
        "ins1PreCode":"try { DefaultBoxAndWhiskerCategoryDataset dataset = new DefaultBoxAndWhiskerCategoryDataset(); dataset.add(new BoxAndWhiskerItem(new Double(1.0), new Double(2.0), new Double(3.0), null, new Double(0.5), new Double(4.5), new Double(-0.5), new Double(5.5), null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"),",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertWarnings(RestMultiSearchAction.TYPES_DEPRECATION_MESSAGE);",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals(1, request.requests().get(1).getScriptParams().size()); assertEquals(1, request.requests().get(2).getScriptParams().size());",
        "ins2PreCode":"assertEquals(1, request.requests().get(0).getScriptParams().size()); assertEquals(1, request.requests().get(0).getScriptParams().size());",
        "label":0
    },
    {
        "ins1AddCode":"void testNoParent() {",
        "ins1DelCode":"public void testNoParent() {",
        "ins1PreCode":"public void testNoParent() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "ins2PreCode":"public void testNoParent() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsEmpty() {",
        "ins1DelCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsEmpty() throws Exception {",
        "ins1PreCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsEmpty() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "ins2PreCode":"@Test public void dummyRangeNumberSingleShouldSuccessIfBuildNumberIsComma() throws Exception { final CLICommandInvoker.Result result = command .authorizedTo(Jenkins.READ, Job.READ)",
        "label":1
    },
    {
        "ins1AddCode":"void prefixed() {",
        "ins1DelCode":"public void prefixed() {",
        "ins1PreCode":"public void prefixed() { assertThat(this.environment.resolvePlaceholders(\"${foo:}\")).isEmpty(); TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "ins2PreCode":"public void list() { assertThat(this.environment.resolvePlaceholders(\"${foo[1]:}\")).isEmpty(); TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.environment,",
        "label":1
    },
    {
        "ins1AddCode":"WsContextListener.class.getName(), false));",
        "ins1DelCode":"WsListener.class.getName(), false));",
        "ins1PreCode":"org.apache.catalina.Context ctxt  = tomcat.addWebapp( null, \"/examples\", appDir.getAbsolutePath()); ctxt.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false));  TesterSupport.initSsl(tomcat);",
        "ins2PreCode":"org.apache.catalina.Context ctxt  = tomcat.addWebapp( null, \"/examples\", appDir.getAbsolutePath()); ctxt.addApplicationListener(new ApplicationListener( WsListener.class.getName(), false)); TesterSupport.configureClientSsl();",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<String> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<String> to = new TestObserver<String>();",
        "ins1PreCode":"public void groupByBackpressure() throws InterruptedException {  TestObserver<String> to = new TestObserver<String>();  Observable.range(1, 4000)",
        "ins2PreCode":"public void groupByBackpressure2() throws InterruptedException { TestObserver<String> to = new TestObserver<String>(); TestObserver<String> to = new TestObserver<String>();",
        "label":1
    },
    {
        "ins1AddCode":"if (bufferSize - tempPos < FIXED32_SIZE) { refillBuffer(FIXED32_SIZE); pos = tempPos + FIXED32_SIZE;",
        "ins1DelCode":"if (bufferSize - tempPos < FIXED_32_SIZE) { refillBuffer(FIXED_32_SIZE); pos = tempPos + FIXED_32_SIZE;",
        "ins1PreCode":"public int readRawLittleEndian32() throws IOException { int tempPos = pos;  if (bufferSize - tempPos < FIXED_32_SIZE) { refillBuffer(FIXED_32_SIZE); tempPos = pos; }  final byte[] buffer = this.buffer; pos = tempPos + FIXED_32_SIZE; return (((buffer[tempPos] & 0xff)) | ((buffer[tempPos + 1] & 0xff) << 8)",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"\"  number  = {1},\" + OS.NEWLINE +",
        "ins1DelCode":"\"  number  = {1},\" + OS.NEWLINE +",
        "ins1PreCode":"void writeEntryWithOrField() throws Exception { StringWriter stringWriter = new StringWriter();  BibEntry entry = new BibEntry(StandardEntryType.InBook);  entry.setField(StandardField.EDITOR, \"Foo Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\");  entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\");  writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX);  String actual = stringWriter.toString();   String expected = OS.NEWLINE + \"@InBook{,\" + OS.NEWLINE + \"  editor  = {Foo Bar},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"}\" + OS.NEWLINE;   assertEquals(expected, actual);",
        "ins2PreCode":"void writeEntryWithOrFieldBothFieldsPresent() throws Exception { StringWriter stringWriter = new StringWriter(); BibEntry entry = new BibEntry(StandardEntryType.InBook); entry.setField(StandardField.EDITOR, \"Edi Bar\"); entry.setField(StandardField.JOURNAL, \"International Journal of Something\"); entry.setField(StandardField.NUMBER, \"1\"); entry.setField(StandardField.NOTE, \"some note\"); writer.write(entry, stringWriter, BibDatabaseMode.BIBTEX); String actual = stringWriter.toString(); String expected = OS.NEWLINE + \"@InBook{,\" + OS.NEWLINE + \"  editor  = {Edi Bar},\" + OS.NEWLINE + \"  note    = {some note},\" + OS.NEWLINE + \"  number  = {1},\" + OS.NEWLINE + \"  journal = {International Journal of Something},\" + OS.NEWLINE + \"}\" + OS.NEWLINE; assertEquals(expected, actual);",
        "label":1
    },
    {
        "ins1AddCode":"void testAsciiDocFormat() {",
        "ins1DelCode":"public void testAsciiDocFormat() {",
        "ins1PreCode":"public void testAsciiDocFormat() { String expectedCitation = \"[1] B. Smith, B. Jones, and J. Williams, ``Title of the test entry,'' __BibTeX Journal__, vol. 34, no. 3, pp. 45\u201367, Jul. 2016.\\n\"; BibEntry entry = TestEntry.getTestEntry();",
        "ins2PreCode":"public void testHtmlFormat() { \"    <div class=\\\"csl-left-margin\\\">[1]</div><div class=\\\"csl-right-inline\\\">B. Smith, B. Jones, and J. Williams, \u201cTitle of the test entry,\u201d <i>BibTeX Journal</i>, vol. 34, no. 3, pp. 45\u201367, Jul. 2016.</div>\\n\" + BibEntry entry = TestEntry.getTestEntry();",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false, true);",
        "ins1DelCode":"Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false);",
        "ins1PreCode":"this.errorAttributes = new DefaultErrorAttributes(true); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); ServerRequest serverRequest = buildServerRequest(request, error); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); assertThat(attributes.get(\"status\")).isEqualTo(400); assertThat(attributes.get(\"message\")).isEqualTo(\"invalid request\");",
        "ins2PreCode":"this.errorAttributes = new DefaultErrorAttributes(true); MockServerHttpRequest request = MockServerHttpRequest.get(\"/test\").build(); ServerRequest serverRequest = buildServerRequest(request, error); Map<String, Object> attributes = this.errorAttributes.getErrorAttributes(serverRequest, false); assertThat(attributes.get(\"status\")).isEqualTo(406); assertThat(attributes.get(\"message\")).isEqualTo(\"could not process request\");",
        "label":1
    },
    {
        "ins1AddCode":"public void transformForResolve( Artifact artifact, RepositoryRequest request ) String version = resolveVersion( artifact, request ); artifact.updateVersion( version, request.getLocalRepository() );",
        "ins1DelCode":"public void transformForResolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository ) String version = resolveVersion( artifact, localRepository, remoteRepositories ); artifact.updateVersion( version, localRepository );",
        "ins1PreCode":"public void transformForResolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository ) throws ArtifactResolutionException, ArtifactNotFoundException { if ( Artifact.RELEASE_VERSION.equals( artifact.getVersion() ) ) { try { String version = resolveVersion( artifact, localRepository, remoteRepositories );  if ( Artifact.RELEASE_VERSION.equals( version ) ) { throw new ArtifactNotFoundException( \"Unable to determine the release version\", artifact ); }  artifact.setBaseVersion( version ); artifact.updateVersion( version, localRepository ); } catch ( RepositoryMetadataResolutionException e )",
        "ins2PreCode":"public void transformForResolve( Artifact artifact, List<ArtifactRepository> remoteRepositories, ArtifactRepository localRepository ) throws ArtifactResolutionException, ArtifactNotFoundException { if ( Artifact.LATEST_VERSION.equals( artifact.getVersion() ) ) { try { String version = resolveVersion( artifact, localRepository, remoteRepositories ); if ( Artifact.LATEST_VERSION.equals( version ) ) { throw new ArtifactNotFoundException( \"Unable to determine the latest version\", artifact ); } artifact.setBaseVersion( version ); artifact.updateVersion( version, localRepository ); } catch ( RepositoryMetadataResolutionException e )",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = new XYPlot<>(dataset, xAxis, yAxis, renderer);",
        "ins1DelCode":"XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer);",
        "ins1PreCode":"NumberAxis xAxis = new NumberAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer); assertEquals(yAxis, plot.getRangeAxisForDataset(0)); ",
        "ins2PreCode":"NumberAxis xAxis = new NumberAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); XYItemRenderer renderer = new DefaultXYItemRenderer(); XYPlot plot = new XYPlot(dataset, xAxis, yAxis, renderer); assertEquals(xAxis, plot.getDomainAxisForDataset(0));",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); renderer.setSeriesToolTipGenerator(0, tt);",
        "label":0
    },
    {
        "ins1AddCode":"return RxJavaPlugins.onAssembly(new ParallelPeek<>(this,",
        "ins1DelCode":"return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this,",
        "ins1PreCode":"public final ParallelFlowable<T> doOnNext(@NonNull Consumer<? super T> onNext) { Objects.requireNonNull(onNext, \"onNext is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, onNext, Functions.emptyConsumer(),",
        "ins2PreCode":"public final ParallelFlowable<T> doAfterNext(@NonNull Consumer<? super T> onAfterNext) { Objects.requireNonNull(onAfterNext, \"onAfterNext is null\"); return RxJavaPlugins.onAssembly(new ParallelPeek<T>(this, onAfterNext, Functions.emptyConsumer(),",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(this.output).contains( assertThat(this.output).contains(\"Are you using 'uriVariables'?\");",
        "ins1DelCode":"assertThat(this.out.toString()).contains( assertThat(this.out.toString()) .contains(\"Are you using 'uriVariables'?\");",
        "ins1PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(2); assertThat(this.out.toString()).contains( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.out.toString()) .contains(\"Are you using 'uriVariables'?\"); });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"testFile.setLastModified(testFile.lastModified() - FileUtils.getFileUtils().getFileTimestampGranularity() * 5));",
        "ins1DelCode":"testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5)));",
        "ins1PreCode":"buildRule.executeTarget(\"lastModifiedSetup\"); File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5))); long ts1 = testFile.lastModified(); buildRule.executeTarget(\"testNoPreserve\");",
        "ins2PreCode":"buildRule.executeTarget(\"lastModifiedSetup\"); File testFile = new File(buildRule.getOutputDir(), \"test.txt\"); assumeTrue(\"Could not change file modification time\", testFile.setLastModified(testFile.lastModified() - (FileUtils.getFileUtils().getFileTimestampGranularity() * 5))); long ts1 = testFile.lastModified();buildRule.executeTarget(\"testPreserve\"); buildRule.executeTarget(\"lastModifiedSetup\");",
        "label":1
    },
    {
        "ins1AddCode":"dbStat.setQueryString(sql);",
        "ins1DelCode":"((JDBCStatementImpl) dbStat).setQueryString(sql);",
        "ins1PreCode":"} JDBCStatement dbStat = session.createStatement();  ((JDBCStatementImpl) dbStat).setQueryString(sql);  return dbStat;",
        "ins2PreCode":"} JDBCStatement dbStat = session.createStatement(); ((JDBCStatementImpl) dbStat).setQueryString(sql); return dbStat;",
        "label":0
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"},",
        "ins1DelCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"},",
        "ins1PreCode":"public void test2ButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"ALPHA/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"});",
        "ins2PreCode":"public void test2bisButCaseInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha/beta/gamma\"});",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset<String, String> dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data);",
        "ins1PreCode":"private static JFreeChart createChart() { Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}};  CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createStackedBarChart(\"Stacked Bar Chart\", \"Domain\", \"Range\", dataset);",
        "ins2PreCode":"private static JFreeChart createAreaChart() { Number[][] data = new Integer[][] {{-3, -2}, {-1, 1}, {2, 3}}; CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createAreaChart(\"Area Chart\", \"Domain\", \"Range\", \"C\", data);",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Thread> subscribeThread = new AtomicReference<>(); TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>(); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"UIEventLoopScheduler uiEventLoop = new UIEventLoopScheduler(); try { final ThreadSubscription subscription = new ThreadSubscription(); final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>(); Flowable<Integer> w = Flowable.unsafeCreate(new Publisher<Integer>() {  @Override public void subscribe(Subscriber<? super Integer> t1) { subscribeThread.set(Thread.currentThread()); t1.onSubscribe(subscription); t1.onNext(1); t1.onNext(2);     } });  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); w.subscribeOn(uiEventLoop).observeOn(Schedulers.computation()) .unsubscribeOn(uiEventLoop)",
        "ins2PreCode":"UIEventLoopScheduler uiEventLoop = new UIEventLoopScheduler(); try { final ThreadSubscription subscription = new ThreadSubscription(); final AtomicReference<Thread> subscribeThread = new AtomicReference<Thread>(); Flowable<Integer> w = Flowable.unsafeCreate(new Publisher<Integer>() { @Override public void subscribe(Subscriber<? super Integer> t1) { subscribeThread.set(Thread.currentThread()); t1.onSubscribe(subscription); t1.onNext(1); t1.onNext(2); } }); TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); w.subscribeOn(Schedulers.newThread()).observeOn(Schedulers.computation()) .unsubscribeOn(uiEventLoop)",
        "label":1
    },
    {
        "ins1AddCode":"checkNotNull(collection);",
        "ins1DelCode":"if (collection == null) { throw new NullPointerException(); }",
        "ins1PreCode":"public boolean addAll(Collection<? extends Float> collection) { ensureIsMutable();  if (collection == null) { throw new NullPointerException(); } ",
        "ins2PreCode":"public boolean addAll(Collection<? extends Boolean> collection) { ensureIsMutable(); if (collection == null) { throw new NullPointerException(); }",
        "label":1
    },
    {
        "ins1AddCode":"zf = new org.apache.tools.zip.ZipFile(new File(getProject().getProperty(\"output\"), \"test3.zip\"));",
        "ins1DelCode":"zf = new org.apache.tools.zip.ZipFile(getProject() .resolveFile(\"test3.zip\"));",
        "ins1PreCode":"executeTarget(\"testTarFileSet\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(getProject() .resolveFile(\"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"asf-logo.gif\"); assertEquals(UnixStat.FILE_FLAG | 0446, ze.getUnixMode());",
        "ins2PreCode":"executeTarget(\"rewriteZeroPermissions\"); org.apache.tools.zip.ZipFile zf = null; try { zf = new org.apache.tools.zip.ZipFile(getProject() .resolveFile(\"test3.zip\")); org.apache.tools.zip.ZipEntry ze = zf.getEntry(\"testdir/test.txt\"); assertEquals(UnixStat.FILE_FLAG | 0644, ze.getUnixMode());",
        "label":1
    },
    {
        "ins1AddCode":"OS.NEWLINE + OS.NEWLINE +",
        "ins1DelCode":"\"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE + OS.NEWLINE +",
        "ins1PreCode":"\"  author = {B},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: saveOrderConfig:specified;author;false;year;true;abstract;false;}\" + OS.NEWLINE,",
        "ins2PreCode":"\"  author = {B},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" OS.NEWLINE +",
        "label":1
    },
    {
        "ins1AddCode":"this.requestFactoryCustomizer, this.interceptors);",
        "ins1DelCode":"this.requestFactoryCustomizers, this.interceptors);",
        "ins1PreCode":"append(this.messageConverters, messageConverters), this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, this.interceptors);",
        "ins2PreCode":"this.messageConverters, this.requestFactorySupplier, this.uriTemplateHandler, this.errorHandler, this.basicAuthorization, this.restTemplateCustomizers, this.requestFactoryCustomizers, this.restTemplateCustomizers, this.requestFactoryCustomizers,",
        "label":1
    },
    {
        "ins1AddCode":"relative = requestPath.substring(0, pos + 1) + path; relative = requestPath + path;",
        "ins1DelCode":"relative = RequestUtil.normalize (requestPath.substring(0, pos + 1) + path); relative = RequestUtil.normalize(requestPath + path);",
        "ins1PreCode":"int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = RequestUtil.normalize (requestPath.substring(0, pos + 1) + path); } else { relative = RequestUtil.normalize(requestPath + path); } ",
        "ins2PreCode":"int pos = requestPath.lastIndexOf('/'); String relative = null; if (pos >= 0) { relative = RequestUtil.normalize (requestPath.substring(0, pos + 1) + path); } else { relative = RequestUtil.normalize(requestPath + path); }",
        "label":1
    },
    {
        "ins1AddCode":".run(data); validatePrediction(model, users, products, testData._2(), 0.3, false, testData._3());",
        "ins1DelCode":".run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins1PreCode":" MatrixFactorizationModel model = new ALS().setRank(features) .setIterations(iterations) .run(data.rdd()); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<?, ?> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1",
        "ins2PreCode":"public void testSetSeriesURLGenerator() { CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryURLGenerator url1",
        "label":1
    },
    {
        "ins1AddCode":"LongArray array, long startIndex, long numRecords, int startByteIndex, int endByteIndex) {",
        "ins1DelCode":"LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) {",
        "ins1PreCode":"private static long[][] getKeyPrefixArrayCounts( LongArray array, int startIndex, int numRecords, int startByteIndex, int endByteIndex) { long[][] counts = new long[8][]; long bitwiseMax = 0;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public Observable<? extends Integer> apply(Integer v) { public Observable<? extends Integer> apply(Integer v) { public Single<? extends Integer> apply(Integer v) {",
        "ins1DelCode":"public Observable<? extends Integer> apply(Integer v) throws Exception { public Observable<? extends Integer> apply(Integer v) throws Exception { public Single<? extends Integer> apply(Integer v) throws Exception {",
        "ins1PreCode":" observablePlain = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } });  observableConvert = source.concatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toObservable(); } });  observableDedicated = source.concatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v); }",
        "ins2PreCode":"observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } }); observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toObservable(); } }); observableDedicated = source.flatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v); }",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(finalResult != null && finalResult);",
        "ins1DelCode":"Assert.assertTrue(finalResult == null ? false : finalResult);",
        "ins1PreCode":"  Boolean finalResult = r.start(); Assert.assertTrue(finalResult == null ? false : finalResult);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"throw new BuilderException(\"An invalid property '\" + name + \"' was found in mapping #{\" + content + \"}.  Valid properties are \" + PARAMETER_PROPERTIES);",
        "ins1DelCode":"throw new BuilderException(\"An invalid property '\" + name + \"' was found in mapping #{\" + content + \"}.  Valid properties are \" + parameterProperties);",
        "ins1PreCode":"} else if (\"expression\".equals(name)) { throw new BuilderException(\"Expression based parameters are not supported yet\"); } else { throw new BuilderException(\"An invalid property '\" + name + \"' was found in mapping #{\" + content + \"}.  Valid properties are \" + parameterProperties); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"buildRule.executeTarget(target); String d = buildRule.getProject().getProperty(\"dest\") + \"/a/b/c/d\"; String f = buildRule.getProject().getProperty(\"dest\") + \"/e/f\"; assertTrue(buildRule.getFullLog().indexOf(\"Removing orphan file:\") > -1); assertContains(\"Removed 1 dangling file from\", buildRule.getFullLog()); assertContains(\"Removed 1 dangling directory from\", buildRule.getFullLog());",
        "ins1DelCode":"executeTarget(target); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; String f = getProject().getProperty(\"dest\") + \"/e/f\"; assertTrue(getFullLog().indexOf(\"Removing orphan file:\") > -1); assertDebuglogContaining(\"Removed 1 dangling file from\"); assertDebuglogContaining(\"Removed 1 dangling directory from\");",
        "ins1PreCode":"private void testCopyAndRemove(String target) { executeTarget(target); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsPresent(d); String f = getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsNotPresent(f); assertTrue(getFullLog().indexOf(\"Removing orphan file:\") > -1); assertDebuglogContaining(\"Removed 1 dangling file from\"); assertDebuglogContaining(\"Removed 1 dangling directory from\");",
        "ins2PreCode":"public void testCopyAndRemoveEmptyPreserve() { executeTarget(\"copyandremove-emptypreserve\"); String d = getProject().getProperty(\"dest\") + \"/a/b/c/d\"; assertFileIsPresent(d); String f = getProject().getProperty(\"dest\") + \"/e/f\"; assertFileIsNotPresent(f); assertTrue(getFullLog().indexOf(\"Removing orphan file:\") > -1); assertDebuglogContaining(\"Removed 1 dangling file from\"); assertDebuglogContaining(\"Removed 1 dangling directory from\");",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<Integer> reversed = pairStream.map(in -> in._2());",
        "ins1DelCode":"JavaDStream<Integer> reversed = pairStream.map( new Function<Tuple2<String, Integer>, Integer>() { @Override public Integer call(Tuple2<String, Integer> in) { return in._2(); } });",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map( new Function<Tuple2<String, Integer>, Integer>() { @Override public Integer call(Tuple2<String, Integer> in) { return in._2(); } });  JavaTestUtils.attachTestOutputStream(reversed);",
        "ins2PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); JavaDStream<Tuple2<String, Integer>> stream = public void testPairMap2() { JavaDStream<Tuple2<String, Integer>> stream = JavaDStream<Integer> reversed = pairStream.map(in -> in._2()); } } JavaTestUtils.attachTestOutputStream(reversed);",
        "label":0
    },
    {
        "ins1AddCode":"this.paint = SerialUtils.readPaint(stream); this.backgroundPaint = SerialUtils.readPaint(stream); this.outlinePaint = SerialUtils.readPaint(stream); this.outlineStroke = SerialUtils.readStroke(stream);",
        "ins1DelCode":"this.paint = SerialUtilities.readPaint(stream); this.backgroundPaint = SerialUtilities.readPaint(stream); this.outlinePaint = SerialUtilities.readPaint(stream); this.outlineStroke = SerialUtilities.readStroke(stream);",
        "ins1PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.paint = SerialUtilities.readPaint(stream); this.backgroundPaint = SerialUtilities.readPaint(stream); this.outlinePaint = SerialUtilities.readPaint(stream); this.outlineStroke = SerialUtilities.readStroke(stream);",
        "ins2PreCode":"private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException { stream.defaultReadObject(); this.paint = SerialUtilities.readPaint(stream); this.backgroundPaint = SerialUtilities.readPaint(stream); this.outlinePaint = SerialUtilities.readPaint(stream); this.outlineStroke = SerialUtilities.readStroke(stream);",
        "label":1
    },
    {
        "ins1AddCode":"iae.initCause(e);",
        "ins1DelCode":"jdkCompat.chainException(iae, e);",
        "ins1PreCode":"} catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for role \" + role); jdkCompat.chainException(iae, e); throw iae; }",
        "ins2PreCode":"} catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for role \" + role); jdkCompat.chainException(iae, e); throw iae; }",
        "label":1
    },
    {
        "ins1AddCode":"for (File file : files) {",
        "ins1DelCode":"for (int i = 0; i < files.length; i++) { File file = files[i];",
        "ins1PreCode":"}  IOException exception = null; for (int i = 0; i < files.length; i++) { File file = files[i]; try { forceDelete(file);",
        "ins2PreCode":"} IOException exception = null; for (int i = 0; i < files.length; i++) { File file = files[i]; try { forceDeleteOnExit(file);",
        "label":1
    },
    {
        "ins1AddCode":"XIntervalSeries<String> s1 = new XIntervalSeries<>(\"S1\");",
        "ins1DelCode":"XIntervalSeries s1 = new XIntervalSeries(\"S1\");",
        "ins1PreCode":"public void testClear() { XIntervalSeries s1 = new XIntervalSeries(\"S1\"); s1.addChangeListener(this); s1.clear();",
        "ins2PreCode":"public void testClear() { XYIntervalSeries s1 = new XYIntervalSeries(\"S1\"); s1.addChangeListener(this); s1.clear();",
        "label":1
    },
    {
        "ins1AddCode":"String expected = expectedURL.toString(); String actual = webResource.getURL().toString(); if (isWindows()){ expected = expected.toLowerCase(); actual = actual.toLowerCase(); } Assert.assertEquals(expected, actual);",
        "ins1DelCode":"Assert.assertEquals(expectedURL.toString(), webResource.getURL().toString());",
        "ins1PreCode":"expectedURL.append(docBase.getAbsoluteFile().toURI().toURL().toString()); expectedURL.append(\"*/WEB-INF/lib/test.jar!/META-INF/resources/index.html\");  Assert.assertEquals(expectedURL.toString(), webResource.getURL().toString());",
        "ins2PreCode":"expectedURL.append(docBase.getAbsoluteFile().toURI().toURL().toString()); expectedURL.append(\"WEB-INF/lib/test-lib.jar!/META-INF/tags/echo.tag\"); Assert.assertEquals(expectedURL.toString(), webResource.getURL().toString());",
        "label":1
    },
    {
        "ins1AddCode":"engine.findChild(name).start();",
        "ins1DelCode":"((Lifecycle) engine.findChild(name)).start();",
        "ins1PreCode":"  try { ((Lifecycle) engine.findChild(name)).start(); writer.println (sm.getString(\"hostManagerServlet.started\", name));",
        "ins2PreCode":"try { ((Lifecycle) engine.findChild(name)).stop(); writer.println (sm.getString(\"hostManagerServlet.stopped\", name));",
        "label":1
    },
    {
        "ins1AddCode":"TreeMap<Integer,ArrayList<ByteEntry>> tempMap = new TreeMap<Integer,ArrayList<ByteEntry>>(); Iterator<ByteEntry> entries = bcStats.keySet().iterator(); ByteEntry entry = entries.next(); int[] countA = bcStats.get(entry); ArrayList<ByteEntry> list = tempMap.get(count); list = new ArrayList<ByteEntry>(); ArrayList<ByteEntry> list = tempMap.get(key); ByteEntry entry = list.get(i); int[] count = bcStats.get(entry);",
        "ins1DelCode":"TreeMap tempMap = new TreeMap(); Iterator entries = bcStats.keySet().iterator(); ByteEntry entry = (ByteEntry) entries.next(); int[] countA = (int[]) bcStats.get(entry); ArrayList list = (ArrayList) tempMap.get(count); list = new ArrayList(); ArrayList list = (ArrayList) tempMap.get(key); ByteEntry[] list2 = (ByteEntry[]) list.toArray(new ByteEntry[list.size()]); ByteEntry entry = (ByteEntry) list.get(i); int[] count = (int[]) bcStats.get(entry);",
        "ins1PreCode":"if (bcCount > trainThreshold) { long t1 = System.currentTimeMillis();  TreeMap tempMap = new TreeMap(); Iterator entries = bcStats.keySet().iterator(); while (entries.hasNext()) { ByteEntry entry = (ByteEntry) entries.next(); int[] countA = (int[]) bcStats.get(entry); Integer count = new Integer(countA[0]);  ArrayList list = (ArrayList) tempMap.get(count); if (list == null) {  list = new ArrayList(); tempMap.put(count, list); } list.add(entry); }  int size = bcStats.size(); if (size > cacheSize) { size = cacheSize; } ByteEntry[] tempbcCache = new ByteEntry[size];   ByteChunk tempChunk = new ByteChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList list = (ArrayList) tempMap.get(key); ByteEntry[] list2 = (ByteEntry[]) list.toArray(new ByteEntry[list.size()]); for (int i = 0; i < list.size() && n < size; i++) { ByteEntry entry = (ByteEntry) list.get(i); tempChunk.setBytes(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempbcCache, n); if (insertPos == n) { tempbcCache[n + 1] = entry; } else { System.arraycopy(tempbcCache, insertPos + 1, tempbcCache, insertPos + 2, n - insertPos - 1); tempbcCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } bcCount = 0; bcStats.clear(); bcCache = tempbcCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug(\"ByteCache generation time: \" + (t2 - t1) + \"ms\"); } } else { bcCount++;  ByteEntry entry = new ByteEntry(); entry.value = value; int[] count = (int[]) bcStats.get(entry); if (count == null) { int end = bc.getEnd();",
        "ins2PreCode":"if (ccCount > trainThreshold) { long t1 = System.currentTimeMillis(); TreeMap tempMap = new TreeMap(); Iterator entries = ccStats.keySet().iterator(); while (entries.hasNext()) { CharEntry entry = (CharEntry) entries.next(); int[] countA = (int[]) ccStats.get(entry); Integer count = new Integer(countA[0]); ArrayList list = (ArrayList) tempMap.get(count); if (list == null) { list = new ArrayList(); tempMap.put(count, list); } list.add(entry); } int size = ccStats.size(); if (size > cacheSize) { size = cacheSize; } CharEntry[] tempccCache = new CharEntry[size]; CharChunk tempChunk = new CharChunk(); int n = 0; while (n < size) { Object key = tempMap.lastKey(); ArrayList list = (ArrayList) tempMap.get(key); CharEntry[] list2 = (CharEntry[]) list.toArray(new CharEntry[list.size()]); for (int i = 0; i < list.size() && n < size; i++) { CharEntry entry = (CharEntry) list.get(i); tempChunk.setChars(entry.name, 0, entry.name.length); int insertPos = findClosest(tempChunk, tempccCache, n); if (insertPos == n) { tempccCache[n + 1] = entry; } else { System.arraycopy(tempccCache, insertPos + 1, tempccCache, insertPos + 2, n - insertPos - 1); tempccCache[insertPos + 1] = entry; } n++; } tempMap.remove(key); } ccCount = 0; ccStats.clear(); ccCache = tempccCache; if (log.isDebugEnabled()) { long t2 = System.currentTimeMillis(); log.debug(\"CharCache generation time: \" + (t2 - t1) + \"ms\"); } } else { ccCount++; CharEntry entry = new CharEntry(); entry.value = value; int[] count = (int[]) ccStats.get(entry); if (count == null) { int end = cc.getEnd();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\} bracket\"), entry.getField(StandardField.REVIEW)); assertFalse(result.hasWarnings());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"author @ good\"), entry.getField(StandardField.AUTHOR)); assertEquals(1, parsed.size());",
        "label":1
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(3, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\")); assertEquals(Optional.of(\"8,\"), entry.getField(\"month\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(3, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\")); assertEquals(Optional.of(\"8,\"), e.getField(\"month\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},month={8,}},\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(3, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\")); assertEquals(Optional.of(\"8,\"), e.getField(\"month\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (diaDefault.isShowAssociationNames() == showem) { diaDefault.setShowAssociationNames(showem); diaDefault.setShowAssociationNames(!showem); doUndoable(memento);",
        "ins1DelCode":"if (showAssociationNames == showem) { showAssociationNames = showem; showAssociationNames = !showem; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "ins1PreCode":"public void setShowAssociationNames(final boolean showem) { if (showAssociationNames == showem) { return; }  Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_ASSOCIATION_NAMES;  public void redo() { showAssociationNames = showem; fireNotationEvent(key, !showem, showem); }  public void undo() { showAssociationNames = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "ins2PreCode":"public void setShowProperties(final boolean showem) { if (showProperties == showem) { return; } Memento memento = new Memento() { private final ConfigurationKey key = Notation.KEY_SHOW_PROPERTIES; public void redo() { showProperties = showem; fireNotationEvent(key, !showem, showem); } public void undo() { showProperties = !showem; fireNotationEvent(key, showem, !showem); } }; if (UndoManager.getInstance().isGenerateMementos()) { UndoManager.getInstance().addMemento(memento); } memento.redo(); ProjectManager.getManager().setSaveEnabled(true);",
        "label":1
    },
    {
        "ins1AddCode":"void parseRecognizesStringWithWhitespace() throws IOException {",
        "ins1DelCode":"public void parseRecognizesStringWithWhitespace() throws IOException {",
        "ins1PreCode":"public void parseRecognizesStringWithWhitespace() throws IOException { ParserResult result = parser .parse(new StringReader(\"@string {bourdieu = {Bourdieu, Pierre}}\"));",
        "ins2PreCode":"public void parseRecognizesStringInParenthesis() throws IOException { ParserResult result = parser .parse(new StringReader(\"@string(bourdieu = {Bourdieu, Pierre})\"));",
        "label":1
    },
    {
        "ins1AddCode":"this.messageConverters, copiedSetOf(interceptors), this.requestFactory, this.uriTemplateHandler,",
        "ins1DelCode":"this.messageConverters, setOf(interceptors), this.requestFactory, this.uriTemplateHandler,",
        "ins1PreCode":"public RestTemplateBuilder interceptors(Collection<ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, this.messageConverters, setOf(interceptors), this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "ins2PreCode":"public RestTemplateBuilder additionalInterceptors(Collection<? extends ClientHttpRequestInterceptor> interceptors) { Assert.notNull(interceptors, \"interceptors must not be null\"); return new RestTemplateBuilder(this.requestFactoryCustomizer, this.detectRequestFactory, this.rootUri, this.messageConverters, append(this.interceptors, interceptors), this.requestFactory, this.uriTemplateHandler, this.errorHandler, this.basicAuthentication, this.defaultHeaders, this.customizers, this.requestCustomizers);",
        "label":0
    },
    {
        "ins1AddCode":"if (errors.tryAddThrowableOrReport(ex)) {",
        "ins1DelCode":"if (errors.addThrowable(ex)) { } else { RxJavaPlugins.onError(ex);",
        "ins1PreCode":"void innerError(int index, Throwable ex) { if (errors.addThrowable(ex)) { boolean cancelOthers = true; if (delayError) { synchronized (this) { Object[] latest = this.latest; if (latest == null) { return; }  cancelOthers = latest[index] == null; if (cancelOthers || ++complete == latest.length) { done = true; } } } if (cancelOthers) { cancelSources(); } drain(); } else { RxJavaPlugins.onError(ex); }",
        "ins2PreCode":"void innerComplete(int index) { void innerComplete(int index) { boolean cancelOthers = false; if (cancelOthers) { synchronized (this) { Object[] latest = this.latest; if (latest == null) { return; } cancelOthers = latest[index] == null; if (cancelOthers || ++complete == latest.length) { done = true; } } } if (cancelOthers) { cancelSources(); } drain(); if (cancelOthers) { drain(); }",
        "label":0
    },
    {
        "ins1AddCode":"try ( final InputStream in = input ) return new MavenToolchainsXpp3Reader().read( in, isStrict( options ) );",
        "ins1DelCode":"try MavenToolchainsXpp3Reader r = new MavenToolchainsXpp3Reader(); return r.read( input, isStrict( options ) ); finally { IOUtil.close( input ); }",
        "ins1PreCode":"{ Validate.notNull( input, \"input cannot be null\" );  try { MavenToolchainsXpp3Reader r = new MavenToolchainsXpp3Reader(); return r.read( input, isStrict( options ) ); } catch ( XmlPullParserException e ) { throw new ToolchainsParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e ); } finally { IOUtil.close( input ); }",
        "ins2PreCode":"{ Validate.notNull( input, \"input cannot be null\" ); try { MetadataXpp3Reader r = new MetadataXpp3Reader(); return r.read( input, isStrict( options ) ); } catch ( XmlPullParserException e ) { throw new MetadataParseException( e.getMessage(), e.getLineNumber(), e.getColumnNumber(), e ); } finally { IOUtil.close( input ); }",
        "label":1
    },
    {
        "ins1AddCode":"for (XYAnnotation a : plot.getAnnotations()) { for (XYPlot subplot : cp.getSubplots()) { for (XYPlot subplot : cp.getSubplots()) {",
        "ins1DelCode":"Iterator iter = plot.getAnnotations().iterator(); while (iter.hasNext()) { XYAnnotation a = (XYAnnotation) iter.next(); Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { XYPlot subplot = (XYPlot) iterator.next(); Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { XYPlot subplot = (XYPlot) iterator.next();",
        "ins1PreCode":"}   Iterator iter = plot.getAnnotations().iterator(); while (iter.hasNext()) { XYAnnotation a = (XYAnnotation) iter.next(); applyToXYAnnotation(a); }  if (plot instanceof CombinedDomainXYPlot) { CombinedDomainXYPlot cp = (CombinedDomainXYPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { XYPlot subplot = (XYPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot); } } } if (plot instanceof CombinedRangeXYPlot) { CombinedRangeXYPlot cp = (CombinedRangeXYPlot) plot; Iterator iterator = cp.getSubplots().iterator(); while (iterator.hasNext()) { XYPlot subplot = (XYPlot) iterator.next(); if (subplot != null) { applyToPlot(subplot);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final GeoIpProcessor city = factory.create(null, \"_tag\", null, config);",
        "ins1DelCode":"final GeoIpProcessor city = factory.create(null, \"_tag\", config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"database_file\", \"GeoIP2-City.mmdb\"); final GeoIpProcessor city = factory.create(null, \"_tag\", config);  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JavaRDD<List<String>> rdd = jsc.parallelize(Arrays.asList( model.save(spark.sparkContext(), outputPath); (FPGrowthModel<String>) FPGrowthModel.load(spark.sparkContext(), outputPath); for (FPGrowth.FreqItemset<String> itemset : freqItemsets) {",
        "ins1DelCode":"JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( model.save(sc.sc(), outputPath); (FPGrowthModel<String>) FPGrowthModel.load(sc.sc(), outputPath); for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {",
        "ins1PreCode":"public void runFPGrowthSaveLoad() {  @SuppressWarnings(\"unchecked\") JavaRDD<List<String>> rdd = sc.parallelize(Arrays.asList( Arrays.asList(\"r z h k p\".split(\" \")), Arrays.asList(\"z y x w v u t s\".split(\" \")), Arrays.asList(\"s x o n r\".split(\" \")), Arrays.asList(\"x z y m t s q e\".split(\" \")), Arrays.asList(\"z\".split(\" \")), Arrays.asList(\"x z y r q t p\".split(\" \"))), 2);  FPGrowthModel<String> model = new FPGrowth() .setMinSupport(0.5) .setNumPartitions(2) .run(rdd);  File tempDir = Utils.createTempDir( System.getProperty(\"java.io.tmpdir\"), \"JavaFPGrowthSuite\"); String outputPath = tempDir.getPath();  try { model.save(sc.sc(), outputPath); @SuppressWarnings(\"unchecked\") FPGrowthModel<String> newModel = (FPGrowthModel<String>) FPGrowthModel.load(sc.sc(), outputPath); List<FPGrowth.FreqItemset<String>> freqItemsets = newModel.freqItemsets().toJavaRDD() .collect(); assertEquals(18, freqItemsets.size());  for (FPGrowth.FreqItemset<String> itemset: freqItemsets) {  List<String> items = itemset.javaItems();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.axes.put(index, axis);",
        "ins1DelCode":"this.axes.set(index, axis);",
        "ins1PreCode":"if (axis != null) { axis.setPlot(this); } this.axes.set(index, axis); if (axis != null) { axis.configure();",
        "ins2PreCode":"if (axis != null) { axis.setPlot(this); } this.domainAxes.put(index, axis); if (axis != null) { axis.configure();",
        "label":0
    },
    {
        "ins1AddCode":"public final <R> Observable<R> concatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { ObjectHelper.verifyPositive(bufferSize, \"bufferSize\"); return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, bufferSize, ErrorMode.IMMEDIATE));",
        "ins1DelCode":"public final <R> Observable<R> concatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch) { ObjectHelper.verifyPositive(prefetch, \"prefetch\"); return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, prefetch, ErrorMode.IMMEDIATE));",
        "ins1PreCode":"public final <R> Observable<R> concatMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int prefetch) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, prefetch, ErrorMode.IMMEDIATE));",
        "ins2PreCode":"public final <R> Observable<R> concatMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(prefetch, \"prefetch\"); if (this instanceof ScalarSupplier) { @SuppressWarnings(\"unchecked\") T v = ((ScalarSupplier<T>)this).get(); if (v == null) { return empty(); } return ObservableScalarXMap.scalarXMap(v, mapper); } return RxJavaPlugins.onAssembly(new ObservableConcatMap<>(this, mapper, prefetch, tillTheEnd ? ErrorMode.END : ErrorMode.BOUNDARY));",
        "label":1
    },
    {
        "ins1AddCode":"void testNaming() {",
        "ins1DelCode":"public void testNaming() {",
        "ins1PreCode":"public void testNaming() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(FooConfig.class) .withPropertyValues(\"foo.name:foo\");",
        "ins2PreCode":"public void testEmptyMapIsNotAdded() { ApplicationContextRunner contextRunner = new ApplicationContextRunner().withUserConfiguration(MapConfig.class); .getBeans().get(\"foo\");",
        "label":1
    },
    {
        "ins1AddCode":"Node<T> n = new Node<>(capacityHint); this.subscribers = new AtomicReference<>(EMPTY);",
        "ins1DelCode":"Node<T> n = new Node<T>(capacityHint); this.subscribers = new AtomicReference<CacheSubscription<T>[]>(EMPTY);",
        "ins1PreCode":"super(source); this.capacityHint = capacityHint; this.once = new AtomicBoolean(); Node<T> n = new Node<T>(capacityHint); this.head = n; this.tail = n; this.subscribers = new AtomicReference<CacheSubscription<T>[]>(EMPTY);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private static void assertBuffersEqual(ManagedBuffer buffer0, ManagedBuffer buffer1) throws Exception {",
        "ins1DelCode":"private void assertBuffersEqual(ManagedBuffer buffer0, ManagedBuffer buffer1) throws Exception {",
        "ins1PreCode":"private void assertBuffersEqual(ManagedBuffer buffer0, ManagedBuffer buffer1) throws Exception { ByteBuffer nio0 = buffer0.nioByteBuffer(); ByteBuffer nio1 = buffer1.nioByteBuffer();",
        "ins2PreCode":"private void assertBuffersEqual(ManagedBuffer buffer0, ManagedBuffer buffer1) throws Exception { ByteBuffer nio0 = buffer0.nioByteBuffer(); ByteBuffer nio1 = buffer1.nioByteBuffer();",
        "label":1
    },
    {
        "ins1AddCode":"if (!ObjectUtils.equal(this.subplots, that.subplots)) {",
        "ins1DelCode":"if (!ObjectUtilities.equal(this.subplots, that.subplots)) {",
        "ins1PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtilities.equal(this.subplots, that.subplots)) { return false; }",
        "ins2PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtilities.equal(this.subplots, that.subplots)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"static void setUp() throws Exception {",
        "ins1DelCode":"public static void setUp() throws Exception {",
        "ins1PreCode":"public static void setUp() throws Exception {  try (Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/named_constructor_args/mybatis-config.xml\")) {",
        "ins2PreCode":"public void setUp() throws Exception { try (Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/selectkey/MapperConfig.xml\")) {",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(expectedTrack, getTrack());",
        "ins1DelCode":"assertEquals(expectedTrack, getTrack());",
        "ins1PreCode":"Thread.sleep(50); count ++; } assertEquals(expectedTrack, getTrack());  ",
        "ins2PreCode":"Thread.sleep(50); count ++; } assertEquals(expectedTrack, getTrack());",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(renameProcessor.getField().newInstance(Collections.emptyMap()).execute(), equalTo(\"old_field\")); assertThat(renameProcessor.getTargetField().newInstance(Collections.emptyMap()).execute(), equalTo(\"new_field\"));",
        "ins1DelCode":"RenameProcessor.Factory factory = new RenameProcessor.Factory(); assertThat(renameProcessor.getField(), equalTo(\"old_field\")); assertThat(renameProcessor.getTargetField(), equalTo(\"new_field\"));",
        "ins1PreCode":"public void testCreate() throws Exception { RenameProcessor.Factory factory = new RenameProcessor.Factory(); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"old_field\"); config.put(\"target_field\", \"new_field\"); String processorTag = randomAlphaOfLength(10); RenameProcessor renameProcessor = factory.create(null, processorTag, config); assertThat(renameProcessor.getTag(), equalTo(processorTag)); assertThat(renameProcessor.getField(), equalTo(\"old_field\")); assertThat(renameProcessor.getTargetField(), equalTo(\"new_field\")); assertThat(renameProcessor.isIgnoreMissing(), equalTo(false));",
        "ins2PreCode":"public void testCreateWithIgnoreMissing() throws Exception { RenameProcessor.Factory factory = new RenameProcessor.Factory(); Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"old_field\"); config.put(\"target_field\", \"new_field\"); String processorTag = randomAlphaOfLength(10); RenameProcessor renameProcessor = factory.create(null, processorTag, config); assertThat(renameProcessor.getTag(), equalTo(processorTag)); assertThat(renameProcessor.getField(), equalTo(\"old_field\")); assertThat(renameProcessor.getTargetField(), equalTo(\"new_field\")); assertThat(renameProcessor.isIgnoreMissing(), equalTo(true));",
        "label":1
    },
    {
        "ins1AddCode":"Map<String, ?> body = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON) .exchangeToMono(toResponseBody()).block();",
        "ins1DelCode":"ClientResponse response = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON).exchange() .block(); Map<String, ?> body = getResponseBody(response);",
        "ins1PreCode":"void errorEndpointIsUsedWithEndpoint() { this.runner.run(withWebTestClient((client) -> { ClientResponse response = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON).exchange() .block(); Map<String, ?> body = getResponseBody(response); assertThat(body).hasEntrySatisfying(\"exception\", (value) -> assertThat(value).asString().contains(\"IllegalStateException\"));",
        "ins2PreCode":"void errorPageAndErrorControllerIncludeDetails() { .run(withWebTestClient((client) -> { ClientResponse response = client.get().uri(\"actuator/fail\").accept(MediaType.APPLICATION_JSON) .exchange().block(); Map<String, ?> body = getResponseBody(response); assertThat(body).hasEntrySatisfying(\"message\", (value) -> assertThat(value).asString().contains(\"Epic Fail\"));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(0, s1.indexOf(1.0));",
        "ins1DelCode":"assertEquals(0, s1.indexOf(new Double(1.0)));",
        "ins1PreCode":"s1.add(1.0, 1.0, 1.0, 2.0); s1.add(2.0, 2.0, 2.0, 3.0); s1.add(3.0, 3.0, 3.0, 4.0); assertEquals(0, s1.indexOf(new Double(1.0)));",
        "ins2PreCode":"s1.add(1.0, 1.0, 1.0, 2.0); s1.add(2.0, 2.0, 2.0, 3.0); s1.add(3.0, 3.0, 3.0, 4.0); assertEquals(0, s1.indexOf(new Double(1.0)));",
        "label":1
    },
    {
        "ins1AddCode":"NioTcpServer acceptor = new NioTcpServer();",
        "ins1DelCode":"NioTcpServer acceptor = new NioTcpServer(new NioSelectorLoop(), new NioSelectorLoop());",
        "ins1PreCode":"public static void main(String[] args) throws Exception {  NioTcpServer acceptor = new NioTcpServer(new NioSelectorLoop(), new NioSelectorLoop());  acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"),",
        "ins2PreCode":"public static void main(String[] args) throws Exception { NioTcpServer acceptor = new NioTcpServer(new NioSelectorLoop(), new NioSelectorLoop()); acceptor.setFilters(new LoggingFilter(\"INCOMING\"), new HttpServerCodec(), new LoggingFilter(\"DECODED\"),",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = (CategoryPlot) this.chart.getPlot();",
        "ins1DelCode":"CategoryPlot plot = (CategoryPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); StandardCategoryToolTipGenerator tt",
        "label":1
    },
    {
        "ins1AddCode":"File jExecutable = null; if (isAix) { } if (jExecutable == null) { jExecutable = findInDir(javaHome + \"/bin\", command);",
        "ins1DelCode":"File jExecutable = findInDir(javaHome + \"/bin\", command); if (jExecutable == null && isAix) {",
        "ins1PreCode":"return command; }  File jExecutable = findInDir(javaHome + \"/bin\", command);  if (jExecutable == null && isAix) {  ",
        "ins2PreCode":"return command; } File jExecutable = findInDir(javaHome + \"/../bin\", command); if (jExecutable == null && isAix) {",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset,",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset,",
        "ins1PreCode":"= new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, null, 0.5, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new BoxAndWhiskerRenderer());",
        "ins2PreCode":"= new DefaultBoxAndWhiskerCategoryDataset<>(); dataset.add(new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, null, 4.5, -0.5, 5.5, null), \"S1\", \"C1\"); CategoryPlot plot = new CategoryPlot(dataset, new CategoryAxis(\"Category\"), new NumberAxis(\"Value\"), new BoxAndWhiskerRenderer());",
        "label":1
    },
    {
        "ins1AddCode":"Subscriber<String> w = serializedSubscriber(new SafeSubscriber<>(tw));",
        "ins1DelCode":"Subscriber<String> w = serializedSubscriber(new SafeSubscriber<String>(tw));",
        "ins1PreCode":"try { TestConcurrencySubscriber tw = new TestConcurrencySubscriber();  Subscriber<String> w = serializedSubscriber(new SafeSubscriber<String>(tw)); w.onSubscribe(new BooleanSubscription()); ",
        "ins2PreCode":"try { TestConcurrencySubscriber tw = new TestConcurrencySubscriber(); Observer<String> w = serializedObserver(new SafeObserver<String>(tw)); w.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset, xAxis, yAxis, renderer);",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer);",
        "ins1PreCode":"CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer);  CategoryAxis xAxis2 = new CategoryAxis(\"X2\");",
        "ins2PreCode":"CategoryAxis xAxis = new CategoryAxis(\"X\"); NumberAxis yAxis = new NumberAxis(\"Y\"); CategoryItemRenderer renderer = new BarRenderer(); CategoryPlot plot = new CategoryPlot(dataset, xAxis, yAxis, renderer); CategoryAxis xAxis = new CategoryAxis(\"X\");",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(input.skip(1)).isEqualTo(0); assertThat(input.read(new byte[1],  0,  0)).isEqualTo(-1);",
        "ins1DelCode":"",
        "ins1PreCode":"InputStream input = stringUnderTest.newInput(); int stringSize = stringUnderTest.size(); int nearEndIndex = stringSize * 2 / 3; long skipped1 = input.skip(nearEndIndex); assertEquals(\"InputStream.skip()\", skipped1, nearEndIndex); assertEquals(\"InputStream.available()\", stringSize - skipped1, input.available()); assertTrue(\"InputStream.mark() is available\", input.markSupported()); input.mark(0); assertEquals( \"InputStream.skip(), read()\", stringUnderTest.byteAt(nearEndIndex) & 0xFF, input.read()); assertEquals(\"InputStream.available()\", stringSize - skipped1 - 1, input.available()); long skipped2 = input.skip(stringSize); assertEquals(\"InputStream.skip() incomplete\", skipped2, stringSize - skipped1 - 1); assertEquals(\"InputStream.skip(), no more input\", 0, input.available()); assertEquals(\"InputStream.skip(), no more input\", -1, input.read()); input.reset(); assertEquals(\"InputStream.reset() succeded\", stringSize - skipped1, input.available()); assertEquals( \"InputStream.reset(), read()\", stringUnderTest.byteAt(nearEndIndex) & 0xFF, input.read());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"LOGGER.log(WARNING,\"Failed to resolve class\",e); } catch (LinkageError e) { LOGGER.log(WARNING,\"Failed to resolve class\",e);",
        "ins1DelCode":"System.err.println(\"failed to locate class: \"+e);",
        "ins1PreCode":"Object item = readItem(reader, context, collection); collection.add(item); } catch (CannotResolveClassException e) { System.err.println(\"failed to locate class: \"+e); } reader.moveUp();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getDistribution() ); assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getConfiguration().getDistribution() ); assertEquals( \"testDistBase\", wrapper.getConfiguration().getDistributionBase() ); assertEquals( \"testDistPath\", wrapper.getConfiguration().getDistributionPath() ); assertEquals( \"testZipBase\", wrapper.getConfiguration().getZipBase() ); assertEquals( \"testZipPath\", wrapper.getConfiguration().getZipPath() );",
        "ins1DelCode":"Assert.assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getDistribution() ); Assert.assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getConfiguration().getDistribution() ); Assert.assertEquals( \"testDistBase\", wrapper.getConfiguration().getDistributionBase() ); Assert.assertEquals( \"testDistPath\", wrapper.getConfiguration().getDistributionPath() ); Assert.assertEquals( \"testZipBase\", wrapper.getConfiguration().getZipBase() ); Assert.assertEquals( \"testZipPath\", wrapper.getConfiguration().getZipPath() );",
        "ins1PreCode":"{ WrapperExecutor wrapper = WrapperExecutor.forWrapperPropertiesFile( propertiesFile );  Assert.assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getDistribution() ); Assert.assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getConfiguration().getDistribution() ); Assert.assertEquals( \"testDistBase\", wrapper.getConfiguration().getDistributionBase() ); Assert.assertEquals( \"testDistPath\", wrapper.getConfiguration().getDistributionPath() ); Assert.assertEquals( \"testZipBase\", wrapper.getConfiguration().getZipBase() ); Assert.assertEquals( \"testZipPath\", wrapper.getConfiguration().getZipPath() );",
        "ins2PreCode":"{ WrapperExecutor wrapper = WrapperExecutor.forProjectDirectory( testDir.getRoot().toPath() ); Assert.assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getDistribution() ); Assert.assertEquals( new URI( \"http://server/test/maven.zip\" ), wrapper.getConfiguration().getDistribution() ); Assert.assertEquals( \"testDistBase\", wrapper.getConfiguration().getDistributionBase() ); Assert.assertEquals( \"testDistPath\", wrapper.getConfiguration().getDistributionPath() ); Assert.assertEquals( \"testZipBase\", wrapper.getConfiguration().getZipBase() ); Assert.assertEquals( \"testZipPath\", wrapper.getConfiguration().getZipPath() );",
        "label":1
    },
    {
        "ins1AddCode":"TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor(), metaData);",
        "ins1DelCode":"TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor());",
        "ins1PreCode":"public void containsReturnsTrueForEntryInAux() throws Exception { Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor()); BibEntry inAux = new BibEntry(); inAux.setCiteKey(\"Darwin1888\");",
        "ins2PreCode":"public void containsReturnsTrueForEntryNotInAux() throws Exception { Path auxFile = Paths.get(TexGroupTest.class.getResource(\"paper.aux\").toURI()); TexGroup group = new TexGroup(\"paper\", GroupHierarchyType.INDEPENDENT, auxFile, new DefaultAuxParser(new BibDatabase()), new DummyFileUpdateMonitor()); BibEntry notInAux = new BibEntry(); notInAux.setCiteKey(\"NotInAux2017\");",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name fail\", res.toString()); Assert.assertEquals(\"Cookie name ok\", res.toString()); Assert.assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader);",
        "ins1DelCode":"assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name fail\", res.toString()); assertEquals(\"Cookie name ok\", res.toString()); assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader);",
        "ins1PreCode":"tomcat.start();  ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString());   Map<String,List<String>> headers = new HashMap<>(); getUrl(\"http://localhost:\" + getPort() + \"/switch\", res, headers); List<String> cookieHeaders = headers.get(\"Set-Cookie\"); for (String cookieHeader : cookieHeaders) { assertEquals(\"name=\\\"val?ue\\\"; Version=1\", cookieHeader); } ",
        "ins2PreCode":"tomcat.start(); ByteChunk res = getUrl(\"http://localhost:\" + getPort() + \"/invalid\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/null\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/blank\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidFwd\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/invalidStrict\"); assertEquals(\"Cookie name fail\", res.toString()); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); assertEquals(\"Cookie name ok\", res.toString()); tomcat.start(); res = getUrl(\"http://localhost:\" + getPort() + \"/valid\"); System.setProperty(\"org.apache.tomcat.util.http.ServerCookie.STRICT_NAMING\", public void testCookiesInstance() throws Exception { assertEquals(\"Cookie name fail\", res.toString()); }",
        "label":1
    },
    {
        "ins1AddCode":"static void setup() throws Exception {",
        "ins1DelCode":"public static void setup() throws Exception {",
        "ins1PreCode":"public static void setup() throws Exception { DataSource dataSource = BaseDataTest.createBlogDataSource(); TransactionFactory transactionFactory = new JdbcTransactionFactory();",
        "ins2PreCode":"public static void setup() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(BaseDataTest.BLOG_PROPERTIES); TransactionFactory transactionFactory = new JdbcTransactionFactory();",
        "label":1
    },
    {
        "ins1AddCode":"log.debug(\"Unrecognized Oracle object type: \" + objectTypeName); log.debug(\"Unsupported Oracle object type: \" + objectTypeName);",
        "ins1DelCode":"log.debug(\"Unrecognized object type: \" + objectTypeName); log.debug(\"Unsupported object type: \" + objectTypeName);",
        "ins1PreCode":"} OracleObjectType objectType = OracleObjectType.getByType(objectTypeName); if (objectType == null) { log.debug(\"Unrecognized object type: \" + objectTypeName); return objectName; } if (!objectType.isBrowsable()) { log.debug(\"Unsupported object type: \" + objectTypeName); return objectName; }",
        "ins2PreCode":"} DB2ObjectType objectType = DB2ObjectType.getByType(objectTypeName); if (objectType == null) { LOG.debug(\"Unrecognized object type: \" + objectTypeName); return objectName; } if (!objectType.isBrowsable()) { LOG.debug(\"Unsupported object type: \" + objectTypeName); return objectName; }",
        "label":0
    },
    {
        "ins1AddCode":"Map<Integer, Collection<String>> expected = new HashMap<>();",
        "ins1DelCode":"Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>();",
        "ins1PreCode":" Flowable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicateErr).toFlowable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\")); expected.put(2, Arrays.asList(\"cccc\", \"dddd\"));",
        "ins2PreCode":"Observable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicateErr).toObservable(); Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\")); expected.put(2, Arrays.asList(\"cccc\", \"dddd\"));",
        "label":1
    },
    {
        "ins1AddCode":"void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() {",
        "ins1DelCode":"public void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() {",
        "ins1PreCode":"public void containsDescendantOfWhenAllAreAbsentShouldReturnAbsent() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, Answers.CALLS_REAL_METHODS);",
        "ins2PreCode":"public void containsDescendantOfWhenAnyIsPresentShouldReturnPresent() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, Answers.CALLS_REAL_METHODS);",
        "label":1
    },
    {
        "ins1AddCode":".hasMessage(Strings.lenientFormat(\"\", Arrays.copyOfRange(params, 2, params.length)));",
        "ins1DelCode":".hasMessage(Preconditions.format(\"\", Arrays.copyOfRange(params, 2, params.length)));",
        "ins1PreCode":"assertThat(throwable).hasMessage(\"\"); } else { assertThat(throwable) .hasMessage(Preconditions.format(\"\", Arrays.copyOfRange(params, 2, params.length))); }",
        "ins2PreCode":"assertThat(throwable).hasMessage(\"\"); } else { assertThat(throwable) .hasMessage(Preconditions.format(\"\", Arrays.copyOfRange(params, 2, params.length))); }",
        "label":1
    },
    {
        "ins1AddCode":"ClassLoader genericLoader = null; genericLoader = getClassLoaderFromJar(genericJarFile); if (genericLoader != null && genericLoader instanceof AntClassLoader) { AntClassLoader loader = (AntClassLoader) genericLoader; loader.cleanup(); }",
        "ins1DelCode":"ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile); if (genericLoader instanceof AntClassLoader) { AntClassLoader loader = (AntClassLoader) genericLoader; loader.cleanup(); }",
        "ins1PreCode":"}   ClassLoader genericLoader = getClassLoaderFromJar(genericJarFile);  for (Enumeration e = genericEntries.keys(); e.hasMoreElements();) { String filepath = (String) e.nextElement();  if (wlEntries.containsKey(filepath)) {    JarEntry genericEntry = (JarEntry) genericEntries.get(filepath); JarEntry wlEntry = (JarEntry) wlEntries.get(filepath);  if ((genericEntry.getCrc() != wlEntry.getCrc()) || (genericEntry.getSize() != wlEntry.getSize())) {  if (genericEntry.getName().endsWith(\".class\")) {  String classname = genericEntry.getName().replace(File.separatorChar, '.');  classname = classname.substring(0, classname.lastIndexOf(\".class\"));  Class genclass = genericLoader.loadClass(classname);  if (genclass.isInterface()) {  log(\"Interface \" + genclass.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } else {  replaceEntries.put(filepath, genericEntry); } } else {  if (!genericEntry.getName().equals(\"META-INF/MANIFEST.MF\")) {  log(\"Non class file \" + genericEntry.getName() + \" has changed\", Project.MSG_VERBOSE); rebuild = true; break; } } } } else {   log(\"File \" + filepath + \" not present in weblogic jar\", Project.MSG_VERBOSE); rebuild = true; break; } }  if (!rebuild) { log(\"No rebuild needed - updating jar\", Project.MSG_VERBOSE); newWLJarFile = new File(weblogicJarFile.getAbsolutePath() + \".temp\"); if (newWLJarFile.exists()) { newWLJarFile.delete(); }  newJarStream = new JarOutputStream(new FileOutputStream(newWLJarFile)); newJarStream.setLevel(0);   for (Enumeration e = wlEntries.elements(); e.hasMoreElements();) { byte[] buffer = new byte[1024]; int bytesRead; InputStream is; JarEntry je = (JarEntry) e.nextElement();  if (je.getCompressedSize() == -1 || je.getCompressedSize() == je.getSize()) { newJarStream.setLevel(0); } else { newJarStream.setLevel(9); }   if (replaceEntries.containsKey(je.getName())) { log(\"Updating Bean class from generic Jar \" + je.getName(), Project.MSG_VERBOSE);  je = (JarEntry) replaceEntries.get(je.getName()); is = genericJar.getInputStream(je); } else {   is = wlJar.getInputStream(je); } newJarStream.putNextEntry(new JarEntry(je.getName()));  while ((bytesRead = is.read(buffer)) != -1) { newJarStream.write(buffer, 0, bytesRead); } is.close(); } } else { log(\"Weblogic Jar rebuild needed due to changed \" + \"interface or XML\", Project.MSG_VERBOSE); }  if (genericLoader instanceof AntClassLoader) { AntClassLoader loader = (AntClassLoader) genericLoader; loader.cleanup();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"PublishProcessor<Integer> source2 = PublishProcessor.create(); PublishProcessor<Integer> source3 = PublishProcessor.create();  TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  Flowable.ambArray(source1, source2, source3).subscribe(ts);",
        "ins2PreCode":"PublishSubject<Integer> source2 = PublishSubject.create(); PublishSubject<Integer> source3 = PublishSubject.create(); TestObserver<Integer> to = new TestObserver<Integer>(); Observable.ambArray(source1, source2, source3).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"void testSelectMap() throws Exception {",
        "ins1DelCode":"public void testSelectMap() throws Exception {",
        "ins1PreCode":"public void testSelectMap() throws Exception { String xmlConfig = \"org/apache/ibatis/submitted/result_handler_type/MapperConfig.xml\"; SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryXmlConfig(xmlConfig);",
        "ins2PreCode":"public void testSelectMapAnnotation() throws Exception { String xmlConfig = \"org/apache/ibatis/submitted/result_handler_type/MapperConfig.xml\"; SqlSessionFactory sqlSessionFactory = getSqlSessionFactoryXmlConfig(xmlConfig);",
        "label":1
    },
    {
        "ins1AddCode":"void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() {",
        "ins1DelCode":"public void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() {",
        "ins1PreCode":"public void containsDescendantOfWhenSourceReturnsFalseShouldReturnFalse() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, Answers.CALLS_REAL_METHODS);",
        "ins2PreCode":"public void containsDescendantOfWhenSourceReturnsTrueShouldReturnEmpty() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo\"); ConfigurationPropertySource source = mock(ConfigurationPropertySource.class, Answers.CALLS_REAL_METHODS);",
        "label":1
    },
    {
        "ins1AddCode":"public int read(byte[] buf, int offset, int size) {",
        "ins1DelCode":"@Override public int read(byte[] buf, int offset, int size) {",
        "ins1PreCode":"@Override public int read(byte[] buf, int offset, int size) { if (pos == data.length) { return -1;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void simpleGenericProperties() {",
        "ins1DelCode":"public void simpleGenericProperties() {",
        "ins1PreCode":"public void simpleGenericProperties() { ConfigurationMetadata metadata = compile(AbstractGenericProperties.class, SimpleGenericProperties.class); assertThat(metadata).has(Metadata.withGroup(\"generic\").fromSource(SimpleGenericProperties.class));",
        "ins2PreCode":"public void unresolvedGenericProperties() { ConfigurationMetadata metadata = compile(AbstractGenericProperties.class, UnresolvedGenericProperties.class); assertThat(metadata).has(Metadata.withGroup(\"generic\").fromSource(UnresolvedGenericProperties.class));",
        "label":1
    },
    {
        "ins1AddCode":"name.append('/');",
        "ins1DelCode":"name.append(\"/\");",
        "ins1PreCode":" String contextName = context.getName(); if (!contextName.startsWith(\"/\")) { name.append(\"/\"); } name.append(contextName);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"(Writeable.Reader<DeleteByQueryRequest>) DeleteByQueryRequest::new);",
        "ins1DelCode":"(Supplier<DeleteByQueryRequest>) DeleteByQueryRequest::new);",
        "ins1PreCode":"public TransportDeleteByQueryAction(Settings settings, ThreadPool threadPool, ActionFilters actionFilters, Client client, TransportService transportService, ScriptService scriptService, ClusterService clusterService) { super(settings, DeleteByQueryAction.NAME, transportService, actionFilters, (Supplier<DeleteByQueryRequest>) DeleteByQueryRequest::new); this.threadPool = threadPool; this.client = client;",
        "ins2PreCode":"public TransportUpdateByQueryAction(Settings settings, ThreadPool threadPool, ActionFilters actionFilters, Client client, TransportService transportService, ScriptService scriptService, ClusterService clusterService) { super(settings, UpdateByQueryAction.NAME, transportService, actionFilters, (Supplier<UpdateByQueryRequest>) UpdateByQueryRequest::new); this.threadPool = threadPool; this.client = client;",
        "label":1
    },
    {
        "ins1AddCode":"public boolean toLong(LongWrapper toLongResult) { return false; return false; int digit; if (b >= '0' && b <= '9') { digit = b - '0'; } else { return false; } return false; return false; byte currentByte = getByte(offset); if (currentByte < '0' || currentByte > '9') { return false; return false; toLongResult.value = result; return true;",
        "ins1DelCode":"public long toLong() { throw new NumberFormatException(\"Empty string\"); throw new NumberFormatException(toString()); int digit = getDigit(b); throw new NumberFormatException(toString()); throw new NumberFormatException(toString()); if (getDigit(getByte(offset)) == -1) { throw new NumberFormatException(toString()); throw new NumberFormatException(toString()); return result;",
        "ins1PreCode":"public long toLong() { if (numBytes == 0) { throw new NumberFormatException(\"Empty string\"); }  byte b = getByte(0); final boolean negative = b == '-'; int offset = 0; if (negative || b == '+') { offset++; if (numBytes == 1) { throw new NumberFormatException(toString()); } }  final byte separator = '.'; final int radix = 10; final long stopValue = Long.MIN_VALUE / radix; long result = 0;  while (offset < numBytes) { b = getByte(offset); offset++; if (b == separator) {    break; }  int digit = getDigit(b);    if (result < stopValue) { throw new NumberFormatException(toString()); }  result = result * radix - digit;    if (result > 0) { throw new NumberFormatException(toString()); } }     while (offset < numBytes) { if (getDigit(getByte(offset)) == -1) { throw new NumberFormatException(toString()); } offset++; }  if (!negative) { result = -result; if (result < 0) { throw new NumberFormatException(toString()); } }  return result;",
        "ins2PreCode":"public int toInt() { if (numBytes == 0) { throw new NumberFormatException(\"Empty string\"); } byte b = getByte(0); final boolean negative = b == '-'; int offset = 0; if (negative || b == '+') { offset++; if (numBytes == 1) { throw new NumberFormatException(toString()); } } final byte separator = '.'; final int radix = 10; final int stopValue = Integer.MIN_VALUE / radix; int result = 0; while (offset < numBytes) { b = getByte(offset); offset++; if (b == separator) { break; } int digit = getDigit(b); if (result < stopValue) { throw new NumberFormatException(toString()); } result = result * radix - digit; if (result > 0) { throw new NumberFormatException(toString()); } } while (offset < numBytes) { if (getDigit(getByte(offset)) == -1) { throw new NumberFormatException(toString()); } offset++; } if (!negative) { result = -result; if (result < 0) { throw new NumberFormatException(toString()); } } return result;",
        "label":1
    },
    {
        "ins1AddCode":"produced = e; missed = addAndGet(-missed); if (missed == 0) { break;",
        "ins1DelCode":"int w = get(); if (missed == w) { produced = e; missed = addAndGet(-missed); if (missed == 0) { break; } } else { missed = w;",
        "ins1PreCode":"return; }  int w = get(); if (missed == w) { produced = e; missed = addAndGet(-missed); if (missed == 0) { break; } } else { missed = w; } }",
        "ins2PreCode":"return; } int w = get(); if (missed == w) { produced = e; missed = addAndGet(-missed); if (missed == 0) { break; } } else { missed = w; } }",
        "label":1
    },
    {
        "ins1AddCode":"List<TestSubscriberEx<Long>> list = new ArrayList<>(100); TestSubscriberEx<Long> ts = new TestSubscriberEx<>(); List<Long> expected = new ArrayList<>();",
        "ins1DelCode":"List<TestSubscriberEx<Long>> list = new ArrayList<TestSubscriberEx<Long>>(100); TestSubscriberEx<Long> ts = new TestSubscriberEx<Long>(); List<Long> expected = new ArrayList<Long>();",
        "ins1PreCode":" Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024);  List<TestSubscriberEx<Long>> list = new ArrayList<TestSubscriberEx<Long>>(100); for (int i = 0; i < 100; i++) { TestSubscriberEx<Long> ts = new TestSubscriberEx<Long>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); }  List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) { expected.add((long)(i - 10));",
        "ins2PreCode":"Flowable<Long> output = cached.observeOn(Schedulers.computation(), false, 1024); List<TestSubscriberEx<Long>> list = new ArrayList<TestSubscriberEx<Long>>(100); for (int i = 0; i < 100; i++) { TestSubscriberEx<Long> ts = new TestSubscriberEx<Long>(); list.add(ts); output.skip(i * 10).take(10).subscribe(ts); } List<Long> expected = new ArrayList<Long>(); for (int i = 0; i < 10; i++) { expected.add((long)(i - 10));",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(network2).isSameInstanceAs(network1);",
        "ins1DelCode":"assertThat(network2).isSameAs(network1);",
        "ins1PreCode":"ImmutableNetwork.copyOf(NetworkBuilder.directed().<String, String>build()); Network<String, String> network2 = ImmutableNetwork.copyOf(network1);  assertThat(network2).isSameAs(network1);",
        "ins2PreCode":"ImmutableNetwork.copyOf(NetworkBuilder.directed().<String, String>build()); Network<String, String> network2 = ImmutableNetwork.copyOf(network1); assertThat(network2).isSameAs(network1);",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Void> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Void> to = new TestObserver<Void>();",
        "ins1PreCode":"public void delayErrorIterableCancelAfterHasNext() { final TestObserver<Void> to = new TestObserver<Void>();  Completable.mergeDelayError(new Iterable<Completable>() {",
        "ins2PreCode":"public void cancelAfterHasNext() { final TestObserver<Void> to = new TestObserver<Void>(); Completable.merge(new Iterable<Completable>() {",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(transpose.edgeConnectingOrNull(N1, N2)).isNull(); assertThat(transpose.edgeConnectingOrNull(N1, N2)).isEqualTo(E21);",
        "ins1DelCode":"",
        "ins1PreCode":"AbstractNetworkTest.validateNetwork(transpose);  assertThat(transpose.edgesConnecting(N1, N2)).isEmpty(); directedGraph.addEdge(N2, N1, E21);  assertThat(transpose.edgesConnecting(N1, N2)).containsExactly(E21); AbstractNetworkTest.validateNetwork(transpose);",
        "ins2PreCode":"AbstractNetworkTest.validateNetwork(transpose); assertThat(transpose.edgesConnecting(N1, N2)).isEmpty(); directedGraph.addEdge(N2, N1, E21); assertThat(transpose.edgesConnecting(N1, N2)).containsExactly(E21); AbstractNetworkTest.validateNetwork(transpose);",
        "label":0
    },
    {
        "ins1AddCode":"set.add(new ACMPortalFetcher());",
        "ins1DelCode":"",
        "ins1PreCode":"set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences));   ",
        "ins2PreCode":"set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences));",
        "label":0
    },
    {
        "ins1AddCode":"void testSeleckKeyReturnsNoData() { Assertions.assertThrows(PersistenceException.class, () -> sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms));",
        "ins1DelCode":"public void testSeleckKeyReturnsNoData() { Assertions.assertThrows(PersistenceException.class, () -> { sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms); });",
        "ins1PreCode":"public void testSeleckKeyReturnsNoData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<>(); parms.put(\"name\", \"Fred\"); Assertions.assertThrows(PersistenceException.class, () -> { sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertNoValuesInSelectKey\", parms); }); }",
        "ins2PreCode":"public void testSeleckKeyReturnsTooManyData() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Map<String, String> parms = new HashMap<>(); parms.put(\"name\", \"Fred\"); Assertions.assertThrows(PersistenceException.class, () -> { sqlSession.insert(\"org.apache.ibatis.submitted.selectkey.Table2.insertTooManyValuesInSelectKey\", parms); }); }",
        "label":1
    },
    {
        "ins1AddCode":"XIntervalSeries s2 = CloneUtils.clone(s1);",
        "ins1DelCode":"XIntervalSeries s2 = (XIntervalSeries) s1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XIntervalSeries s1 = new XIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); XIntervalSeries s2 = (XIntervalSeries) s1.clone(); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { VectorSeries s1 = new VectorSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); VectorSeries s2 = (VectorSeries) s1.clone(); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"ParsedDocument doc = mapper.parse(new SourceToParse(\"test\", \"type\", \"1\", BytesReference",
        "ins1DelCode":"ParsedDocument doc = mapper.parse(SourceToParse.source(\"test\", \"type\", \"1\", BytesReference",
        "ins1PreCode":" assertEquals(mapping, mapper.mappingSource().toString());  ParsedDocument doc = mapper.parse(SourceToParse.source(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject()",
        "ins2PreCode":"assertEquals(mapping, mapper.mappingSource().toString()); ParsedDocument doc = mapper.parse(SourceToParse.source(\"test\", \"type\", \"1\", BytesReference .bytes(XContentFactory.jsonBuilder() .startObject()",
        "label":1
    },
    {
        "ins1AddCode":"FetchResult res = fetchChunks(Arrays.asList(BUFFER_CHUNK_INDEX)); assertEquals(Sets.newHashSet(BUFFER_CHUNK_INDEX), res.successChunks); assertBufferListsEqual(Arrays.asList(bufferChunk), res.buffers);",
        "ins1DelCode":"FetchResult res = fetchChunks(Lists.newArrayList(BUFFER_CHUNK_INDEX)); assertEquals(res.successChunks, Sets.newHashSet(BUFFER_CHUNK_INDEX)); assertBufferListsEqual(res.buffers, Lists.newArrayList(bufferChunk));",
        "ins1PreCode":"public void fetchBufferChunk() throws Exception { FetchResult res = fetchChunks(Lists.newArrayList(BUFFER_CHUNK_INDEX)); assertEquals(res.successChunks, Sets.newHashSet(BUFFER_CHUNK_INDEX)); assertTrue(res.failedChunks.isEmpty()); assertBufferListsEqual(res.buffers, Lists.newArrayList(bufferChunk)); res.releaseBuffers();",
        "ins2PreCode":"public void fetchFileChunk() throws Exception { FetchResult res = fetchChunks(Lists.newArrayList(FILE_CHUNK_INDEX)); assertEquals(res.successChunks, Sets.newHashSet(FILE_CHUNK_INDEX)); assertTrue(res.failedChunks.isEmpty()); assertBufferListsEqual(res.buffers, Lists.newArrayList(fileChunk)); res.releaseBuffers();",
        "label":1
    },
    {
        "ins1AddCode":"modsExportFormat.export(databaseContext, tempFile.toPath(), charset, entries);",
        "ins1DelCode":"modsExportFormat.performExport(databaseContext, tempFile.getPath(), charset, entries);",
        "ins1PreCode":"List<BibEntry> entries = bibtexImporter.importDatabase(importFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI());  modsExportFormat.performExport(databaseContext, tempFile.getPath(), charset, entries);  Builder control = Input.from(Files.newInputStream(xmlFile));",
        "ins2PreCode":"List<BibEntry> entries = modsImporter.importDatabase(xmlFile, charset).getDatabase().getEntries(); Path xmlFile = Paths.get(ModsExportFormatTestFiles.class.getResource(xmlFileName).toURI()); modsExportFormat.performExport(databaseContext, tempFile.getPath(), charset, entries); Builder control = Input.from(Files.newInputStream(xmlFile));",
        "label":1
    },
    {
        "ins1AddCode":"entry.setField(StandardField.AUTHOR, \"BlaBla\"); \"  note         = {some note},\" + OS.NEWLINE +",
        "ins1DelCode":"entry.setField(\"author\", \"BlaBla\"); \"  note         = {some note},\" + OS.NEWLINE +",
        "ins1PreCode":"BibEntry entry = entries.iterator().next();   entry.setField(\"author\", \"BlaBla\");  ",
        "ins2PreCode":"BibEntry entry = entries.iterator().next(); entry.setField(\"howpublished\", \"asdf\");",
        "label":1
    },
    {
        "ins1AddCode":"logger.info( \"\" );",
        "ins1DelCode":"",
        "ins1PreCode":"public void forkSucceeded( ExecutionEvent event ) { if ( logger.isInfoEnabled() ) { StringBuilder buffer = new StringBuilder( 128 );  buffer.append( \"<<< \" ); append( buffer, event.getMojoExecution() ); buffer.append( \" < \" ); appendForkInfo( buffer, event.getMojoExecution().getMojoDescriptor() ); append( buffer, event.getProject() ); buffer.append( \" <<<\" );  logger.info( \"\" ); logger.info( buffer.toString() ); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(2, requested.get());",
        "ins1DelCode":"assertEquals(Long.MAX_VALUE, requested.get());",
        "ins1PreCode":"}).take(2).subscribe(ts);   assertEquals(Long.MAX_VALUE, requested.get());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Test {\\\" Test}\\\"}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Test {\\\" Test}\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = BibtexParser.parse( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1AddCode":"if (!\".\".equals(array[icounter].getName()) && !\"..\".equals(array[icounter].getName())) {",
        "ins1DelCode":"if (!array[icounter].getName().equals(\".\") && !array[icounter].getName().equals(\"..\")) {",
        "ins1PreCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory()) { if (!array[icounter].getName().equals(\".\") && !array[icounter].getName().equals(\"..\")) { candidateFound = true; target = fiddleName(array[icounter].getName());",
        "ins2PreCode":"String target = null; for (int icounter = 0; icounter < array.length; icounter++) { if (array[icounter] != null && array[icounter].isDirectory()) { if (!array[icounter].getName().equals(\".\") && !array[icounter].getName().equals(\"..\")) { candidateFound = true; target = fiddleName(array[icounter].getName());",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.SEVERE,",
        "ins1DelCode":"LOG.error(",
        "ins1PreCode":"public void setNamespace(Object handle) { if (!Model.getFacade().isANamespace(handle)) { LOG.error( \"Illegal argument. Object \" + handle + \" is not a namespace\"); throw new IllegalArgumentException(",
        "ins2PreCode":"public void setNamespace(Object handle) { if (!Model.getFacade().isANamespace(handle)) { LOG.error( \"Illegal argument. Object \" + handle + \" is not a namespace\"); throw new IllegalArgumentException(",
        "label":1
    },
    {
        "ins1AddCode":"\"vcap.application.cf_api:https://my-cloud-controller.com\")",
        "ins1DelCode":"\"vcap.application.cf_api:http://my-cloud-controller.com\")",
        "ins1PreCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(",
        "ins2PreCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run((context) -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(",
        "label":1
    },
    {
        "ins1AddCode":"acceptor.unbind();",
        "ins1DelCode":"acceptor.unbindAll();",
        "ins1PreCode":"  Thread.sleep(20000); acceptor.unbindAll(); ",
        "ins2PreCode":"Thread.sleep(20000); acceptor.unbindAll();",
        "label":1
    },
    {
        "ins1AddCode":"void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception {",
        "ins1DelCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception {",
        "ins1PreCode":"public void shouldInsertNewAuthorUsingSimpleNonPreparedStatements() throws Exception {  Executor executor = createExecutor(new JdbcTransaction(ds, null, false));",
        "ins2PreCode":"public void shouldUpdateAuthor() throws Exception { Executor executor = createExecutor(new JdbcTransaction(ds, null, false));",
        "label":1
    },
    {
        "ins1AddCode":"void expressionWithManyAttributes() {",
        "ins1DelCode":"public void expressionWithManyAttributes() {",
        "ins1PreCode":"public void expressionWithManyAttributes() { Map<String, String> result = new ParameterExpression(\"(id.toString()), attr1=val1, attr2=val2, attr3=val3\"); Assertions.assertEquals(4, result.size());",
        "ins2PreCode":"public void simplePropertyWithSpaceAndManyAttributes() { Map<String, String> result = new ParameterExpression(\"user name, attr1=val1, attr2=val2, attr3=val3\"); Assertions.assertEquals(4, result.size());",
        "label":1
    },
    {
        "ins1AddCode":"BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/type/BlobInputStreamTypeHandlerTest.sql\");",
        "ins1DelCode":"BaseDataTest.runScript(dataSource, \"org/apache/ibatis/type/BlobInputStreamTypeHandlerTest.sql\");",
        "ins1PreCode":"public static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\"); BaseDataTest.runScript(dataSource, \"org/apache/ibatis/type/BlobInputStreamTypeHandlerTest.sql\"); TransactionFactory transactionFactory = new JdbcTransactionFactory(); Environment environment = new Environment(\"Production\", transactionFactory, dataSource);",
        "ins2PreCode":"public static void setupSqlSessionFactory() throws Exception { DataSource dataSource = BaseDataTest.createUnpooledDataSource(\"org/apache/ibatis/type/jdbc.properties\"); BaseDataTest.runScript(dataSource, \"org/apache/ibatis/type/ClobReaderTypeHandlerTest.sql\"); TransactionFactory transactionFactory = new JdbcTransactionFactory(); Environment environment = new Environment(\"Production\", transactionFactory, dataSource);",
        "label":1
    },
    {
        "ins1AddCode":"sql.append(\" AND s.sql_child_number = sq.child_number (+)\");",
        "ins1DelCode":"sql.append(\" AND s.sql_child_number = sq.child_number\");",
        "ins1PreCode":"  if(atLeastV9) { sql.append(\" AND s.sql_child_number = sq.child_number\"); } if (!CommonUtils.getOption(options, OPTION_SHOW_BACKGROUND)) {",
        "ins2PreCode":"} catch (SQLException e) { sessions.add(new PostgreSession(dbResult)); } throw new DBException(e, session.getDataSource());",
        "label":0
    },
    {
        "ins1AddCode":"public void dispatchBadRequest(final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {",
        "ins1DelCode":"public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {",
        "ins1PreCode":"}  @Override public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) { causeReference.set(cause); try {",
        "ins2PreCode":"} @Override public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) { causeReference.set(cause); try {",
        "label":1
    },
    {
        "ins1AddCode":"@Override",
        "ins1DelCode":"",
        "ins1PreCode":"for (int i = 0; i < status.length; i++) { final int j = i; t[j] = new Thread() { public void run() { status[j].stop(); }",
        "ins2PreCode":"for (int i = 0; i < status.length; i++) { final int j = i; t[j] = new Thread() { public void run() { status[j].start(); }",
        "label":1
    },
    {
        "ins1AddCode":"GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), null, Collections.singletonMap(\"ONE\", \"1\"),",
        "ins1DelCode":"GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"),",
        "ins1PreCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, false, MatcherWatchdog.noop()); Exception e = expectThrows(Exception.class, () -> processor.execute(doc));",
        "ins2PreCode":"String fieldName = RandomDocumentPicks.randomFieldName(random()); IngestDocument doc = RandomDocumentPicks.randomIngestDocument(random(), new HashMap<>()); doc.setFieldValue(fieldName, 1); GrokProcessor processor = new GrokProcessor(randomAlphaOfLength(10), Collections.singletonMap(\"ONE\", \"1\"), Collections.singletonList(\"%{ONE:one}\"), fieldName, false, true, MatcherWatchdog.noop()); Exception e = expectThrows(Exception.class, () -> processor.execute(doc));",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2) && Os.isFamily(\"dos\")) { return; }",
        "ins1PreCode":"public void testTimeOutForked() throws Exception {   if (JavaEnvUtils.isJavaVersion(JavaEnvUtils.JAVA_1_2) && Os.isFamily(\"dos\")) { return; } Commandline cmd = getCommandline(TIME_OUT*2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assertions.assertEquals(10, users.size());",
        "ins1DelCode":"Assert.assertEquals(10, users.size());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); List<User> users = mapper.getAllUsers(); Assert.assertEquals(10, users.size()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { AnnotatedMapper mapper = sqlSession.getMapper(AnnotatedMapper.class); List<User> users = mapper.getAllUsers(); Assert.assertEquals(10, users.size()); }",
        "label":1
    },
    {
        "ins1AddCode":"throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + byte.class.getCanonicalName());",
        "ins1DelCode":"throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\");",
        "ins1PreCode":") { return ((Number)value).doubleValue(); } else { throw new ClassCastException(\"cannot explicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DBUserInterface.getInstance().showError( \"Export error\",",
        "ins1DelCode":"UIUtils.showErrorDialog( getShell(), \"Export error\",",
        "ins1PreCode":"return false; } catch (InvocationTargetException ex) { UIUtils.showErrorDialog( getShell(), \"Export error\", \"Cannot export scripts\",",
        "ins2PreCode":"return false; } catch (InvocationTargetException ex) { UIUtils.showErrorDialog( getShell(), \"Import error\", \"Cannot import projects\",",
        "label":1
    },
    {
        "ins1AddCode":"SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); initDb(sqlSessionFactory); return sqlSessionFactory;",
        "ins1DelCode":"Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c); c.close(); return new SqlSessionFactoryBuilder().build(configuration);",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(PersonMapper.class); configuration.addMapper(PetMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c); Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment); configuration.addMapper(MultipleCrossIncludePersonMapper.class); configuration.addMapper(MultipleCrossIncludePetMapper.class); c.close(); return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1AddCode":"sqlSession.clearCache();",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals((Integer) 5, parameter.getSum());    parameter = new Parameter(); parameter.setAddend1(2);",
        "ins2PreCode":"assertEquals((Integer) 5, parameter.getSum()); parameter = new Parameter(); parameter.setAddend1(2);",
        "label":0
    },
    {
        "ins1AddCode":"} else if (childType == MySQLTableUniqueKey.class) { return object.getConstraints(monitor); } else if (childType == MySQLTableCheckConstraint.class) {",
        "ins1DelCode":"} else if (childType == MySQLTableConstraint.class) {",
        "ins1PreCode":"public Collection<? extends DBSObject> getChildObjects(DBRProgressMonitor monitor, MySQLTableBase object, Class<? extends DBSObject> childType) throws DBException { if (childType == MySQLTableColumn.class) { return object.getAttributes(monitor); } else if (childType == MySQLTableConstraint.class) { return object.getConstraints(monitor); } else if (childType == MySQLTableForeignKey.class) {",
        "ins2PreCode":"public Collection<? extends DBSObject> getChildObjects(DBRProgressMonitor monitor, PostgreTableBase object, Class<? extends DBSObject> childType) throws DBException { if (childType == PostgreTableColumn.class) { return object.getAttributes(monitor); } else if (childType == PostgreTableConstraint.class) { return object.getConstraints(monitor); } else if (childType == PostgreTableForeign.class) {",
        "label":0
    },
    {
        "ins1AddCode":"int uaoSize = UnsafeAlignedOffset.getUaoSize(); final int required = length + uaoSize; UnsafeAlignedOffset.putSize(base, pageCursor, length); pageCursor += uaoSize;",
        "ins1DelCode":"final int required = length + 4; Platform.putInt(base, pageCursor, length); pageCursor += 4;",
        "ins1PreCode":" growPointerArrayIfNecessary();  final int required = length + 4; acquireNewPageIfNecessary(required);  final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length;",
        "ins2PreCode":"growPointerArrayIfNecessary(); final int required = length + 4; acquireNewPageIfNecessary(required); final Object base = currentPage.getBaseObject(); final long recordAddress = taskMemoryManager.encodePageNumberAndOffset(currentPage, pageCursor); Platform.putInt(base, pageCursor, length); pageCursor += 4; Platform.copyMemory(recordBase, recordOffset, base, pageCursor, length); pageCursor += length;",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(connectorsByService.values().iterator().next()).hasSize(connectors.length + 1);",
        "ins1DelCode":"assertThat(connectorsByService.values().iterator().next().length).isEqualTo(connectors.length + 1);",
        "ins1PreCode":"factory.addAdditionalTomcatConnectors(connectors); this.webServer = factory.getWebServer(); Map<Service, Connector[]> connectorsByService = ((TomcatWebServer) this.webServer).getServiceConnectors(); assertThat(connectorsByService.values().iterator().next().length).isEqualTo(connectors.length + 1);",
        "ins2PreCode":"factory.addAdditionalTomcatConnectors(connectors); this.webServer = factory.getWebServer(mock(HttpHandler.class)); Map<Service, Connector[]> connectorsByService = ((TomcatWebServer) this.webServer).getServiceConnectors(); assertThat(connectorsByService.values().iterator().next().length).isEqualTo(connectors.length + 1);",
        "label":1
    },
    {
        "ins1AddCode":"if (this.disableMBeanRegistry) { Registry.disableRegistry(); }",
        "ins1DelCode":"",
        "ins1PreCode":"public WebServer getWebServer(HttpHandler httpHandler) { Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath());",
        "ins2PreCode":"public WebServer getWebServer(ServletContextInitializer... initializers) { Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\"); tomcat.setBaseDir(baseDir.getAbsolutePath());",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> merge(",
        "ins1DelCode":"public static <T> Flowable<T> merge(",
        "ins1PreCode":"public static <T> Flowable<T> merge( @NonNull SingleSource<? extends T> source1, @NonNull SingleSource<? extends T> source2, @NonNull SingleSource<? extends T> source3, @NonNull SingleSource<? extends T> source4",
        "ins2PreCode":"public static <T> Flowable<T> mergeDelayError( @NonNull SingleSource<? extends T> source1, @NonNull SingleSource<? extends T> source2, @NonNull SingleSource<? extends T> source3, @NonNull SingleSource<? extends T> source4",
        "label":1
    },
    {
        "ins1AddCode":"updateLastRead();",
        "ins1DelCode":"lastRead = System.currentTimeMillis();",
        "ins1PreCode":"  int nRead = fillReadBuffer(block); lastRead = System.currentTimeMillis();  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertNotNull(map); Assert.assertEquals(1,map.size()); Assert.assertNull(SlowQueryReport.getPoolStats(pool.getName()));",
        "ins1DelCode":"assertNotNull(map); assertEquals(1,map.size()); assertNull(SlowQueryReport.getPoolStats(pool.getName()));",
        "ins1PreCode":"st.close(); } Map<String,SlowQueryReport.QueryStats> map = SlowQueryReport.getPoolStats(datasource.getPool().getName()); assertNotNull(map); assertEquals(1,map.size()); String key = map.keySet().iterator().next(); SlowQueryReport.QueryStats stats = map.get(key); System.out.println(\"Stats:\"+stats);  for (int i=0; i<count; i++) { PreparedStatement st = con.prepareStatement(slowSql); ResultSet rs = st.executeQuery(); rs.close(); st.close(); } System.out.println(\"Stats:\"+stats);  for (int i=0; i<count; i++) { CallableStatement st = con.prepareCall(slowSql); ResultSet rs = st.executeQuery(); rs.close(); st.close(); } System.out.println(\"Stats:\"+stats); ConnectionPool pool = datasource.getPool(); con.close(); tearDown();  assertNull(SlowQueryReport.getPoolStats(pool.getName()));",
        "ins2PreCode":"st.close(); } Map<String,SlowQueryReport.QueryStats> map = SlowQueryReport.getPoolStats(datasource.getPool().getName()); assertNotNull(map); assertEquals(1,map.size()); String key = map.keySet().iterator().next(); SlowQueryReport.QueryStats stats = map.get(key); System.out.println(\"Stats:\"+stats); for (int i=0; i<count; i++) { PreparedStatement st = con.prepareStatement(slowSql); ResultSet rs = st.executeQuery(); rs.close(); st.close(); } System.out.println(\"Stats:\"+stats); for (int i=0; i<count; i++) { CallableStatement st = con.prepareCall(slowSql); ResultSet rs = st.executeQuery(); rs.close(); st.close(); } System.out.println(\"Stats:\"+stats); ConnectionPool pool = datasource.getPool(); con.close(); tearDown(); assertNull(SlowQueryReport.getPoolStats(pool.getName()));",
        "label":1
    },
    {
        "ins1AddCode":"if (isBigEndian) { halfWord = Integer.reverseBytes(halfWord); } h1 = mixH1(h1, mixK1(halfWord));",
        "ins1DelCode":"int k1 = mixK1(halfWord); h1 = mixH1(h1, k1);",
        "ins1PreCode":"int h1 = seed; for (int i = 0; i < lengthInBytes; i += 4) { int halfWord = Platform.getInt(base, offset + i); int k1 = mixK1(halfWord); h1 = mixH1(h1, k1); } return h1;",
        "ins2PreCode":"int h1 = seed; for (int i = 0; i < lengthInBytes; i += 4) { int halfWord = Platform.getInt(base, offset + i); int k1 = mixK1(halfWord); h1 = mixH1(h1, k1); } return h1;",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), not(containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)));",
        "ins1DelCode":"assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins1PreCode":"assertThat(result, failedWith(6)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Agent/Disconnect permission\")); assertThat(result.stderr(), not(containsString(\"ERROR: Error occured while performing this command, see previous stderr output.\")));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(load(loader)).isEqualTo(1);",
        "ins1DelCode":"assertThat(loader.load()).isEqualTo(1);",
        "ins1PreCode":"void loadGroovyResource() { ClassPathResource resource = new ClassPathResource(\"sample-beans.groovy\", getClass()); BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource); assertThat(loader.load()).isEqualTo(1); assertThat(this.registry.containsBean(\"myGroovyComponent\")).isTrue(); ",
        "ins2PreCode":"void loadGroovyResourceWithNamespace() { ClassPathResource resource = new ClassPathResource(\"sample-namespace.groovy\", getClass()); BeanDefinitionLoader loader = new BeanDefinitionLoader(this.registry, resource); assertThat(loader.load()).isEqualTo(1); assertThat(this.registry.containsBean(\"myGroovyComponent\")).isTrue();",
        "label":1
    },
    {
        "ins1AddCode":"alv.validateAccessLog(1, 200, Bug49528Servlet.THREAD_SLEEP_TIME,",
        "ins1DelCode":"validateAccessLog(alv, 1, 200, Bug49528Servlet.THREAD_SLEEP_TIME,",
        "ins1PreCode":"assertEquals(\"1false2true3true4true5false\", servlet.getResult());   validateAccessLog(alv, 1, 200, Bug49528Servlet.THREAD_SLEEP_TIME, Bug49528Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "ins2PreCode":"assertEquals(\"1false2true3true4true5false\", servlet.getResult()); validateAccessLog(alv, 1, 200, Bug49567Servlet.THREAD_SLEEP_TIME, Bug49567Servlet.THREAD_SLEEP_TIME + REQUEST_TIME);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(o2, q.first.getContent()); Assert.assertEquals(o1, q.last.getContent()); Assert.assertEquals(o1, r1); Assert.assertEquals(o2, q.first.getContent()); Assert.assertEquals(o2, q.last.getContent()); Assert.assertEquals(o2, r2); Assert.assertNull(q.first); Assert.assertNull(q.last);",
        "ins1DelCode":"assertEquals(o2, q.first.getContent()); assertEquals(o1, q.last.getContent()); assertEquals(o1, r1); assertEquals(o2, q.first.getContent()); assertEquals(o2, q.last.getContent()); assertEquals(o2, r2); assertNull(q.first); assertNull(q.last);",
        "ins1PreCode":"q.push(o1); q.push(o2);  assertEquals(o2, q.first.getContent()); assertEquals(o1, q.last.getContent());  Object r1 = q.pop();  assertEquals(o1, r1); assertEquals(o2, q.first.getContent()); assertEquals(o2, q.last.getContent());   Object r2 = q.pop(); assertEquals(o2, r2); assertNull(q.first); assertNull(q.last);",
        "ins2PreCode":"q.unpop(o1); q.unpop(o2); assertEquals(o1, q.first.getContent()); assertEquals(o1, q.last.getContent()); Object r1 = q.pop(); assertEquals(o1, r1); assertEquals(o1, q.first.getContent()); assertEquals(o2, q.last.getContent()); Object r2 = q.pop(); assertEquals(o2, r2); assertNull(q.first); assertNull(q.last);",
        "label":1
    },
    {
        "ins1AddCode":"Processor processor = createSetProcessor(fieldName, \"bar\", null, false, false);",
        "ins1DelCode":"Processor processor = createSetProcessor(fieldName, \"bar\", false, false);",
        "ins1PreCode":"IngestDocument ingestDocument = new IngestDocument(new HashMap<>(), new HashMap<>()); Object fieldValue = \"foo\"; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = createSetProcessor(fieldName, \"bar\", false, false); processor.execute(ingestDocument); assertThat(ingestDocument.hasField(fieldName), equalTo(true));",
        "ins2PreCode":"IngestDocument ingestDocument = new IngestDocument(new HashMap<>(), new HashMap<>()); Object fieldValue = null; String fieldName = RandomDocumentPicks.addRandomField(random(), ingestDocument, fieldValue); Processor processor = createSetProcessor(fieldName, newValue, false, false); processor.execute(ingestDocument); assertThat(ingestDocument.hasField(fieldName), equalTo(true));",
        "label":1
    },
    {
        "ins1AddCode":"void testUserSpecifiedSlashPath() throws Exception {",
        "ins1DelCode":"public void testUserSpecifiedSlashPath() throws Exception {",
        "ins1PreCode":"public void testUserSpecifiedSlashPath() throws Exception { System.setProperty(\"loader.path\", \"jars/\"); PropertiesLauncher launcher = new PropertiesLauncher();",
        "ins2PreCode":"public void testUserSpecifiedRootOfJarPath() throws Exception { System.setProperty(\"loader.path\", \"jar:file:./src/test/resources/nested-jars/app.jar!/\"); PropertiesLauncher launcher = new PropertiesLauncher();",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals( createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts(), \"Check artifact list\" );",
        "ins1DelCode":"assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "ins1PreCode":"b.addDependency( \"c\", \"3.0\", Artifact.SCOPE_PROVIDED );  ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "ins2PreCode":"b.addDependency( \"c\", \"3.0\", true ); ArtifactResolutionResult res = collect( createSet( new Object[] { a.artifact, b.artifact } ) ); assertEquals( \"Check artifact list\", createSet( new Object[] { a.artifact, b.artifact } ), res.getArtifacts() );",
        "label":1
    },
    {
        "ins1AddCode":"cd.add(Disposable.fromRunnable(new Runnable() { cd.add(Disposable.fromRunnable(new Runnable() {",
        "ins1DelCode":"cd.add(Disposables.fromRunnable(new Runnable() { cd.add(Disposables.fromRunnable(new Runnable() {",
        "ins1PreCode":"public void success() { final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposables.fromRunnable(new Runnable() {  @Override public void run() { counter.incrementAndGet(); }  }));  cd.add(Disposables.fromRunnable(new Runnable() {  @Override",
        "ins2PreCode":"public void run() { final AtomicInteger counter = new AtomicInteger(); CompositeDisposable cd = new CompositeDisposable(); cd.add(Disposables.fromRunnable(new Runnable() { @Override public void run() { counter.incrementAndGet(); } })); cd.add(Disposables.fromRunnable(new Runnable() { @Override",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void backpressure1() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(1, 100000).takeLast(1) .observeOn(Schedulers.newThread())",
        "ins2PreCode":"public void backpressure2() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.range(1, 100000).takeLast(Flowable.bufferSize() * 4) .observeOn(Schedulers.newThread()).map(newSlowProcessor()).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"if (grant.getGrantee().equals(this.getName()))",
        "ins1DelCode":"if (grant.getName().equals(this.getName()))",
        "ins1PreCode":" for(ExasolViewGrant grant: this.dataSource.getViewGrants(monitor)) { if (grant.getName().equals(this.getName())) { grants.add(grant);",
        "ins2PreCode":"for(ExasolScriptGrant grant: this.dataSource.getScriptGrants(monitor)) { if (grant.getName().equals(this.getName())) { grants.add(grant);",
        "label":1
    },
    {
        "ins1AddCode":"void parseCommentContainingEntries() throws IOException {",
        "ins1DelCode":"public void parseCommentContainingEntries() throws IOException {",
        "ins1PreCode":"public void parseCommentContainingEntries() throws IOException {  String bibtexEntry = \"@Comment{@article{myarticle,}\" + OS.NEWLINE +",
        "ins2PreCode":"public void parseCommentContainingEntriesAndAtSymbols() throws IOException { String bibtexEntry = \"@Comment{@article{myarticle,}\" + OS.NEWLINE +",
        "label":1
    },
    {
        "ins1AddCode":"final TestObserver<Void> to = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Void> to = new TestObserver<Void>();",
        "ins1PreCode":"public void mapperCancels() { final TestObserver<Void> to = new TestObserver<Void>();  Observable.range(1, 5).switchMapCompletable(new Function<Integer, CompletableSource>() {",
        "ins2PreCode":"public void mapperCancels() { final TestObserver<Void> to = new TestObserver<Void>(); Flowable.range(1, 5).switchMapCompletable(new Function<Integer, CompletableSource>() {",
        "label":1
    },
    {
        "ins1AddCode":"SparkSession spark = SparkSession.builder().appName(\"JavaStopWordsRemoverExample\").getOrCreate(); List<Row> data = Arrays.asList( ); Dataset<Row> dataset = spark.createDataFrame(data, schema); spark.stop();",
        "ins1DelCode":"SparkConf conf = new SparkConf().setAppName(\"JavaStopWordsRemoverExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc); JavaRDD<Row> rdd = jsc.parallelize(Arrays.asList( )); Dataset<Row> dataset = jsql.createDataFrame(rdd, schema); jsc.stop();",
        "ins1PreCode":"public static void main(String[] args) { SparkConf conf = new SparkConf().setAppName(\"JavaStopWordsRemoverExample\"); JavaSparkContext jsc = new JavaSparkContext(conf); SQLContext jsql = new SQLContext(jsc);   StopWordsRemover remover = new StopWordsRemover() .setInputCol(\"raw\") .setOutputCol(\"filtered\");  JavaRDD<Row> rdd = jsc.parallelize(Arrays.asList( RowFactory.create(Arrays.asList(\"I\", \"saw\", \"the\", \"red\", \"baloon\")), RowFactory.create(Arrays.asList(\"Mary\", \"had\", \"a\", \"little\", \"lamb\")) ));  StructType schema = new StructType(new StructField[]{ new StructField( \"raw\", DataTypes.createArrayType(DataTypes.StringType), false, Metadata.empty()) });  Dataset<Row> dataset = jsql.createDataFrame(rdd, schema); remover.transform(dataset).show();  jsc.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final int uaoSize = UnsafeAlignedOffset.getUaoSize(); allocateMemoryForRecordIfNecessary(required);",
        "ins1DelCode":"growPointerArrayIfNecessary(); int uaoSize = UnsafeAlignedOffset.getUaoSize(); acquireNewPageIfNecessary(required);",
        "ins1PreCode":"spill(); }  growPointerArrayIfNecessary(); int uaoSize = UnsafeAlignedOffset.getUaoSize();  final int required = length + uaoSize; acquireNewPageIfNecessary(required);  final Object base = currentPage.getBaseObject();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final byte[] key = JavaUtils.bufferToArray(entry.getKey());",
        "ins1DelCode":"final byte[] key = entry.getKey().array();",
        "ins1PreCode":"}  for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc =",
        "ins2PreCode":"} for (Map.Entry<ByteBuffer, byte[]> entry : expected.entrySet()) { final byte[] key = entry.getKey().array(); final byte[] value = entry.getValue(); final BytesToBytesMap.Location loc =",
        "label":1
    },
    {
        "ins1AddCode":"for (VariableInfo varInfo : varInfos) { if (varInfo.getScope() != scope) if (declaredVariables.contains(varInfo)) String varName = varInfo.getVarName(); for (TagVariableInfo tagVarInfo : tagVarInfos) { if (tagVarInfo.getScope() != scope) if (declaredVariables.contains(tagVarInfo)) String varName = tagVarInfo.getNameGiven(); tagVarInfo.getNameFromAttribute()); } else if (tagVarInfo.getNameFromAttribute() != null) {",
        "ins1DelCode":"for (int i = 0; i < varInfos.length; i++) { if (varInfos[i].getScope() != scope) if (declaredVariables.contains(varInfos[i])) String varName = varInfos[i].getVarName(); for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) if (declaredVariables.contains(tagVarInfos[i])) String varName = tagVarInfos[i].getNameGiven(); tagVarInfos[i].getNameFromAttribute()); } else if (tagVarInfos[i].getNameFromAttribute() != null) {",
        "ins1PreCode":"List<Object> declaredVariables = n.getScriptingVars(scope);  if (varInfos.length > 0) { for (int i = 0; i < varInfos.length; i++) { if (varInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.printin(tmpVarName); out.print(\" = \"); out.print(varName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue;   if (declaredVariables.contains(tagVarInfos[i])) continue; String varName = tagVarInfos[i].getNameGiven(); if (varName == null) { varName = n.getTagData().getAttributeString( tagVarInfos[i].getNameFromAttribute()); } else if (tagVarInfos[i].getNameFromAttribute() != null) {  continue;",
        "ins2PreCode":"List<Object> declaredVariables = n.getScriptingVars(scope); if (varInfos.length > 0) { for (int i = 0; i < varInfos.length; i++) { if (varInfos[i].getScope() != scope) continue; if (declaredVariables.contains(varInfos[i])) continue; String varName = varInfos[i].getVarName(); String tmpVarName = \"_jspx_\" + varName + \"_\" + n.getCustomNestingLevel(); out.print(tmpVarName); out.print(\" = \"); out.printin(varName); out.println(\";\"); } } else { for (int i = 0; i < tagVarInfos.length; i++) { if (tagVarInfos[i].getScope() != scope) continue; if (declaredVariables.contains(tagVarInfos[i])) continue; String varName = tagVarInfos[i].getNameGiven(); if (varName == null) { varName = n.getTagData().getAttributeString( tagVarInfos[i].getNameFromAttribute()); } else if (tagVarInfos[i].getNameFromAttribute() != null) { continue;",
        "label":1
    },
    {
        "ins1AddCode":"void prepareTestInstanceShouldInjectMockBean() throws Exception { given(this.applicationContext.getBean(MockitoPostProcessor.class)).willReturn(this.postProcessor); TestContext testContext = mockTestContext(instance); given(testContext.getApplicationContext()).willReturn(this.applicationContext); this.listener.prepareTestInstance(testContext); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class));",
        "ins1DelCode":"public void prepareTestInstanceShouldInjectMockBean() throws Exception { this.listener.prepareTestInstance(mockTestContext(instance)); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class));",
        "ins1PreCode":"public void prepareTestInstanceShouldInjectMockBean() throws Exception { WithMockBean instance = new WithMockBean(); this.listener.prepareTestInstance(mockTestContext(instance)); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "ins2PreCode":"void beforeTestMethodShouldInjectMockBeanWhenDirtiesContextAttributeIsSet() throws Exception { WithMockBean instance = new WithMockBean(); this.listener.beforeTestMethod(mockTestContext); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); verify(this.postProcessor).inject(this.fieldCaptor.capture(), eq(instance), any(MockDefinition.class)); assertThat(this.fieldCaptor.getValue().getName()).isEqualTo(\"mockBean\");",
        "label":0
    },
    {
        "ins1AddCode":"final Disposable d = Disposable.empty();",
        "ins1DelCode":"final Disposable d = Disposables.empty();",
        "ins1PreCode":"public void basic() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty();  Flowable.<Integer>create(new FlowableOnSubscribe<Integer>() {",
        "ins2PreCode":"public void basicSerialized() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); Flowable.<Integer>create(new FlowableOnSubscribe<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"EnglishAnalyzer.ENGLISH_STOP_WORDS_SET);",
        "ins1DelCode":"StopAnalyzer.ENGLISH_STOP_WORDS_SET);",
        "ins1PreCode":"  PatternAnalyzer b = new PatternAnalyzer(Pattern.compile(\"\\\\W+\"), true, StopAnalyzer.ENGLISH_STOP_WORDS_SET); assertAnalyzesTo(b, \"The quick brown Fox,the abcd1234 (56.78) dc.\", new String[] { \"quick\", \"brown\", \"fox\", \"abcd1234\", \"56\", \"78\", \"dc\" });",
        "ins2PreCode":"PatternAnalyzer b = new PatternAnalyzer(Pattern.compile(\"\\\\s+\"), true, StopAnalyzer.ENGLISH_STOP_WORDS_SET); assertAnalyzesTo(b, \"The quick brown Fox,the abcd1234 (56.78) dc.\", new String[] { \"quick\", \"brown\", \"fox,the\", \"abcd1234\", \"(56.78)\", \"dc.\" });",
        "label":1
    },
    {
        "ins1AddCode":"Flowable.just(Flowable.just(1)).concatMapDelayError((Function)Functions.identity(), true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1DelCode":"Flowable.just(Flowable.just(1)).concatMapDelayError((Function)Functions.identity(), 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1PreCode":"public void concatMapDelayErrorJustJust() { TestSubscriber<Integer> ts = TestSubscriber.create();  Flowable.just(Flowable.just(1)).concatMapDelayError((Function)Functions.identity(), 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);  ts.assertValue(1);",
        "ins2PreCode":"public void concatMapJustJust() { TestSubscriber<Integer> ts = TestSubscriber.create(); Flowable.just(Flowable.just(1)).concatMap((Function)Functions.identity()).subscribe(ts); ts.assertValue(1);",
        "label":0
    },
    {
        "ins1AddCode":"LOG.log(Level.SEVERE, \"Invalid event:\" + event.getEventType());",
        "ins1DelCode":"LOG.error(\"Invalid event:\" + event.getEventType());",
        "ins1PreCode":"break;  default : LOG.error(\"Invalid event:\" + event.getEventType()); break; }",
        "ins2PreCode":"break; default: LOG.error(\"Invalid event:\" + event.getEventType()); break; }",
        "label":1
    },
    {
        "ins1AddCode":"return results.toArray(new String[0]);",
        "ins1DelCode":"return results.toArray(new String[results.size()]);",
        "ins1PreCode":"throw iae; } } return results.toArray(new String[results.size()]);",
        "ins2PreCode":"throw iae; } } return results.toArray(new String[results.size()]);",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> error = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> error = new AtomicReference<Throwable>();",
        "ins1PreCode":"public void takeWithErrorInObserver() { final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); Observable.just(\"1\", \"2\", \"three\", \"4\").take(3) .safeSubscribe(new DefaultObserver<String>() {",
        "ins2PreCode":"public void customObservableWithErrorInObserverSynchronous() { final AtomicInteger count = new AtomicInteger(); final AtomicReference<Throwable> error = new AtomicReference<Throwable>(); Flowable.just(\"1\", \"2\", \"three\", \"4\") .safeSubscribe(new DefaultSubscriber<String>() {",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\");",
        "ins1PreCode":"SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return concat(Flowable.fromArray(source1, source2, source3, source4));",
        "ins2PreCode":"SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return merge(Flowable.fromArray(source1, source2, source3, source4));",
        "label":1
    },
    {
        "ins1AddCode":"sparkConf = new SparkConf();",
        "ins1DelCode":"",
        "ins1PreCode":"public void setUp() { MockitoAnnotations.initMocks(this); tempDir = new File(Utils.createTempDir$default$1()); shuffleMemoryManager = new ShuffleMemoryManager(Long.MAX_VALUE); spillFilesCreated.clear();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"hits[i].shard(new SearchShardTarget(\"testnode\", new ShardId(\"index\", \"uuid\", 0), null, OriginalIndices.NONE));",
        "ins1DelCode":"hits[i].shard(new SearchShardTarget(\"testnode\", new Index(\"index\", \"uuid\"), 0, null));",
        "ins1PreCode":"} } hits[i] = new SearchHit(i, Integer.toString(i), new Text(\"type\"), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new Index(\"index\", \"uuid\"), 0, null)); } DiscountedCumulativeGain dcg = new DiscountedCumulativeGain();",
        "ins2PreCode":"} } hits[i] = new SearchHit(i, Integer.toString(i), new Text(\"type\"), Collections.emptyMap()); hits[i].shard(new SearchShardTarget(\"testnode\", new Index(\"index\", \"uuid\"), 0, null)); } DiscountedCumulativeGain dcg = new DiscountedCumulativeGain();",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> subscriber = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber); ",
        "ins2PreCode":"public void assertNotMatchValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1AddCode":"outerObserver.onSubscribe(Disposable.empty()); innerObserver.onSubscribe(Disposable.empty()); innerObserver.onSubscribe(Disposable.empty());",
        "ins1DelCode":"outerObserver.onSubscribe(Disposables.empty()); innerObserver.onSubscribe(Disposables.empty()); innerObserver.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<Observable<String>> source = Observable.unsafeCreate(new ObservableSource<Observable<String>>() { @Override public void subscribe(Observer<? super Observable<String>> outerObserver) { outerObserver.onSubscribe(Disposables.empty()); publishNext(outerObserver, 0, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 10, \"1-one\"); publishNext(innerObserver, 20, \"1-two\");  publishNext(innerObserver, 30, \"1-three\"); publishCompleted(innerObserver, 40); } })); publishNext(outerObserver, 25, Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> innerObserver) { innerObserver.onSubscribe(Disposables.empty()); publishNext(innerObserver, 10, \"2-one\"); publishNext(innerObserver, 20, \"2-two\");",
        "ins2PreCode":"Flowable<Flowable<String>> source = Flowable.unsafeCreate(new Publisher<Flowable<String>>() { @Override public void subscribe(Subscriber<? super Flowable<String>> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 0, Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 10, \"1-one\"); publishNext(subscriber, 20, \"1-two\"); publishNext(subscriber, 30, \"1-three\"); publishCompleted(subscriber, 40); } })); publishNext(subscriber, 25, Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); publishNext(subscriber, 10, \"2-one\"); publishNext(subscriber, 20, \"2-two\");",
        "label":0
    },
    {
        "ins1AddCode":"XYStepAreaRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"XYStepAreaRenderer r2 = (XYStepAreaRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYStepAreaRenderer r1 = new XYStepAreaRenderer(); XYStepAreaRenderer r2 = (XYStepAreaRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYAreaRenderer2 r1 = new StackedXYAreaRenderer2(); StackedXYAreaRenderer2 r2 = (StackedXYAreaRenderer2) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"Path auxFile = Path.of(AuxParserTest.class.getResource(\"nested.aux\").toURI());",
        "ins1DelCode":"Path auxFile = Paths.get(AuxParserTest.class.getResource(\"nested.aux\").toURI());",
        "ins1PreCode":"void testNestedAux() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\"); Path auxFile = Paths.get(AuxParserTest.class.getResource(\"nested.aux\").toURI()); try (InputStreamReader originalReader = new InputStreamReader(originalStream, StandardCharsets.UTF_8)) { ParserResult result = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(originalReader);",
        "ins2PreCode":"void testCrossRef() throws URISyntaxException, IOException { InputStream originalStream = AuxParserTest.class.getResourceAsStream(\"origin.bib\"); Path auxFile = Paths.get(AuxParserTest.class.getResource(\"crossref.aux\").toURI()); try (InputStreamReader originalReader = new InputStreamReader(originalStream, StandardCharsets.UTF_8)) { ParserResult result = new BibtexParser(importFormatPreferences, new DummyFileUpdateMonitor()).parse(originalReader);",
        "label":1
    },
    {
        "ins1AddCode":"h = Objects.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1DelCode":"h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\");",
        "ins1PreCode":"ParallelFailureHandling h;  try { h = ObjectHelper.requireNonNull(errorHandler.apply(++retries, ex), \"The errorHandler returned a null item\"); } catch (Throwable exc) { Exceptions.throwIfFatal(exc);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assertions.assertNotNull(person, \"Person must not be null\"); Assertions.assertEquals(Director.class, person.getClass(), \"Person must be a director\");",
        "ins1DelCode":"Assert.assertNotNull(\"Person must not be null\", person); Assert.assertEquals(\"Person must be a director\", Director.class, person.getClass());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.get(1L); Assert.assertNotNull(\"Person must not be null\", person); Assert.assertEquals(\"Person must be a director\", Director.class, person.getClass()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.get2(1L); Assert.assertNotNull(\"Person must not be null\", person); Assert.assertEquals(\"Person must be a director\", Director.class, person.getClass()); }",
        "label":1
    },
    {
        "ins1AddCode":"Collection<CategoryMarker> markers = getDomainMarkers(index, layer); for (CategoryMarker marker : markers) {",
        "ins1DelCode":"Collection<Marker> markers = getDomainMarkers(index, layer); for (Marker value : markers) { CategoryMarker marker = (CategoryMarker) value;",
        "ins1PreCode":"return; }  Collection<Marker> markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { for (Marker value : markers) { CategoryMarker marker = (CategoryMarker) value; r.drawDomainMarker(g2, this, axis, marker, dataArea); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (this.domainIsPointsInTime != that.domainIsPointsInTime) { return false; }",
        "ins1PreCode":"return false; } TimePeriodValuesCollection that = (TimePeriodValuesCollection) obj; if (this.domainIsPointsInTime != that.domainIsPointsInTime) { return false; }",
        "ins2PreCode":"return false; } TimeSeriesCollection that = (TimeSeriesCollection) obj; if (this.domainIsPointsInTime != that.domainIsPointsInTime) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"@NonNull SingleSource<? extends T> source1, @NonNull SingleSource<? extends T> source2, @NonNull SingleSource<? extends T> source3, @NonNull SingleSource<? extends T> source4",
        "ins1DelCode":"SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4",
        "ins1PreCode":"public static <T> Flowable<T> concat( SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) { Objects.requireNonNull(source1, \"source1 is null\");",
        "ins2PreCode":"public static <T> Flowable<T> merge( SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) { Objects.requireNonNull(source1, \"source1 is null\");",
        "label":1
    },
    {
        "ins1AddCode":"this.unit = Objects.requireNonNull(unit, \"unit is null\"); this.scheduler = Objects.requireNonNull(scheduler, \"scheduler is null\");",
        "ins1DelCode":"this.unit = ObjectHelper.requireNonNull(unit, \"unit is null\"); this.scheduler = ObjectHelper.requireNonNull(scheduler, \"scheduler is null\");",
        "ins1PreCode":"SizeAndTimeBoundReplayBuffer(int maxSize, long maxAge, TimeUnit unit, Scheduler scheduler) { this.maxSize = ObjectHelper.verifyPositive(maxSize, \"maxSize\"); this.maxAge = ObjectHelper.verifyPositive(maxAge, \"maxAge\"); this.unit = ObjectHelper.requireNonNull(unit, \"unit is null\"); this.scheduler = ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<Object> h = new TimedNode<Object>(null, 0L); this.tail = h;",
        "ins2PreCode":"SizeAndTimeBoundReplayBuffer(int maxSize, long maxAge, TimeUnit unit, Scheduler scheduler) { this.maxSize = ObjectHelper.verifyPositive(maxSize, \"maxSize\"); this.maxAge = ObjectHelper.verifyPositive(maxAge, \"maxAge\"); this.unit = ObjectHelper.requireNonNull(unit, \"unit is null\"); this.scheduler = ObjectHelper.requireNonNull(scheduler, \"scheduler is null\"); TimedNode<T> h = new TimedNode<T>(null, 0L); this.tail = h;",
        "label":1
    },
    {
        "ins1AddCode":"s1.remove(1.0); s2.remove(1.0);",
        "ins1DelCode":"s1.remove(new Double(1.0)); s2.remove(new Double(1.0));",
        "ins1PreCode":"assertTrue(s2.equals(s1));   s1.remove(new Double(1.0)); assertFalse(s1.equals(s2)); s2.remove(new Double(1.0)); assertTrue(s2.equals(s1));",
        "ins2PreCode":"assertTrue(s2.equals(s1)); s1.remove(new Double(1.0)); assertFalse(s1.equals(s2)); s2.remove(new Double(1.0)); assertTrue(s2.equals(s1));",
        "label":1
    },
    {
        "ins1AddCode":"if (byteEnabled && (value.length() < maxStringSize)) {",
        "ins1DelCode":"if (byteEnabled) {",
        "ins1PreCode":" if (bcCache == null) { String value = bc.toStringInternal(); if (byteEnabled) {  synchronized (bcStats) {",
        "ins2PreCode":"if (ccCache == null) { String value = cc.toStringInternal(); if (charEnabled) { synchronized (ccStats) {",
        "label":1
    },
    {
        "ins1AddCode":"CombinedRangeXYPlot<String> plot = createPlot();",
        "ins1DelCode":"CombinedRangeXYPlot plot = createPlot();",
        "ins1PreCode":"public void testNotification() { CombinedRangeXYPlot plot = createPlot(); JFreeChart chart = new JFreeChart(plot); chart.addChangeListener(this);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); initDb(sqlSessionFactory); return sqlSessionFactory;",
        "ins1DelCode":"Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c); c.close(); return new SqlSessionFactoryBuilder().build(configuration);",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c);  Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment);  configuration.addMapper(ResultMapReferencePersonMapper.class); configuration.addMapper(ResultMapReferencePetMapper.class); c.close();  return new SqlSessionFactoryBuilder().build(configuration);",
        "ins2PreCode":"private SqlSessionFactory getSqlSessionFactoryJavaConfig() throws Exception { Class.forName(\"org.hsqldb.jdbcDriver\"); Connection c = DriverManager.getConnection(\"jdbc:hsqldb:mem:xmlextref\", \"sa\", \"\"); initDb(c); Configuration configuration = new Configuration(); Environment environment = new Environment(\"development\", new JdbcTransactionFactory(), new UnpooledDataSource( \"org.hsqldb.jdbcDriver\", \"jdbc:hsqldb:mem:xmlextref\", null)); configuration.setEnvironment(environment); configuration.addMapper(ParameterMapReferencePersonMapper.class); configuration.addMapper(ParameterMapReferencePetMapper.class); c.close(); return new SqlSessionFactoryBuilder().build(configuration);",
        "label":1
    },
    {
        "ins1AddCode":"return info.getDomainLowerBound(true); result = minimum;",
        "ins1DelCode":"return new Double(info.getDomainLowerBound(true)); result = new Double(minimum);",
        "ins1PreCode":" if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return new Double(info.getDomainLowerBound(true)); } else { double minimum = Double.POSITIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) {  double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; value = intervalXYData.getStartXValue(series, item); } else { value = dataset.getXValue(series, item); } if (!Double.isNaN(value)) { minimum = Math.min(minimum, value); }  } } if (minimum == Double.POSITIVE_INFINITY) { result = null; } else { result = new Double(minimum); } }",
        "ins2PreCode":"if (dataset instanceof DomainInfo) { DomainInfo info = (DomainInfo) dataset; return new Double(info.getDomainUpperBound(true)); } else { double maximum = Double.NEGATIVE_INFINITY; int seriesCount = dataset.getSeriesCount(); for (int series = 0; series < seriesCount; series++) { int itemCount = dataset.getItemCount(series); for (int item = 0; item < itemCount; item++) { double value; if (dataset instanceof IntervalXYDataset) { IntervalXYDataset intervalXYData = (IntervalXYDataset) dataset; value = intervalXYData.getEndXValue(series, item); } else { value = dataset.getXValue(series, item); } if (!Double.isNaN(value)) { maximum = Math.max(maximum, value); } } } if (maximum == Double.NEGATIVE_INFINITY) { result = null; } else { result = new Double(maximum); } }",
        "label":0
    },
    {
        "ins1AddCode":"DBeaverUI.run(getContainer(), true, true, new DBRRunnableWithProgress() { public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException {",
        "ins1DelCode":"RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException {",
        "ins1PreCode":"public boolean performFinish() { final ScriptsExportData exportData = mainPage.getExportData(); try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try { exportScripts(monitor, exportData);",
        "ins2PreCode":"public boolean performFinish() { ex.getTargetException()); try { RuntimeUtils.run(getContainer(), true, true, new DBRRunnableWithProgress() { @Override public void run(DBRProgressMonitor monitor) throws InvocationTargetException, InterruptedException { try { importProjects(monitor);",
        "label":1
    },
    {
        "ins1AddCode":"Collection<CategoryMarker> markers = getDomainMarkers(index, layer); for (CategoryMarker marker : markers) {",
        "ins1DelCode":"Collection<Marker> markers = getDomainMarkers(index, layer); for (Marker value : markers) { CategoryMarker marker = (CategoryMarker) value;",
        "ins1PreCode":"return; }  Collection<Marker> markers = getDomainMarkers(index, layer); CategoryAxis axis = getDomainAxisForDataset(index); if (markers != null && axis != null) { for (Marker value : markers) { CategoryMarker marker = (CategoryMarker) value; r.drawDomainMarker(g2, this, axis, marker, dataArea); }",
        "ins2PreCode":"return; } Collection<Marker> markers = getRangeMarkers(index, layer); ValueAxis axis = getRangeAxisForDataset(index); if (markers != null && axis != null) { for (Marker marker : markers) { for (Marker marker : markers) { r.drawRangeMarker(g2, this, axis, marker, dataArea); }",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(1, pointField.fieldType().pointDataDimensionCount());",
        "ins1DelCode":"assertEquals(1, pointField.fieldType().pointDimensionCount());",
        "ins1PreCode":"IndexableField[] fields = doc.rootDoc().getFields(\"field\"); assertEquals(1, fields.length); IndexableField pointField = fields[0]; assertEquals(1, pointField.fieldType().pointDimensionCount()); assertEquals(1230, pointField.numericValue().longValue());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"CoreMatchers.equalTo(\"failed to parse setting [Ingest Field] with value [8912pb] as a size in bytes\"));",
        "ins1DelCode":"CoreMatchers.equalTo(\"failed to parse setting [\" + fieldName + \"] with value [8912pb] as a size in bytes\"));",
        "ins1PreCode":"Processor processor = newProcessor(fieldName, randomBoolean(), fieldName); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> processor.execute(ingestDocument)); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse setting [\" + fieldName + \"] with value [8912pb] as a size in bytes\")); assertThat(exception.getCause().getMessage(), CoreMatchers.containsString(\"Values greater than 9223372036854775807 bytes are not supported\"));",
        "ins2PreCode":"Processor processor = newProcessor(fieldName, randomBoolean(), fieldName); ElasticsearchException exception = expectThrows(ElasticsearchException.class, () -> processor.execute(ingestDocument)); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse [junk]\")); assertThat(exception.getMessage(), CoreMatchers.equalTo(\"failed to parse [junk]\"));",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(client.isResponse400());",
        "ins1DelCode":"assertTrue(client.isResponse400());",
        "ins1PreCode":"client.processRequest();   assertTrue(client.isResponse400());",
        "ins2PreCode":"client.processRequest(); assertTrue(client.isResponse200());",
        "label":1
    },
    {
        "ins1AddCode":"File appDir = new File(\"test/webapp\");",
        "ins1DelCode":"File appDir = new File(\"test/webapp-3.0\");",
        "ins1PreCode":" Tomcat tomcat = getTomcatInstance();  File appDir = new File(\"test/webapp-3.0\");  tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance(); File appDir = new File(\"test/webapp-3.0\"); tomcat.addWebapp(null, \"/test\", appDir.getAbsolutePath());",
        "label":1
    },
    {
        "ins1AddCode":"Maybe.concat(new CrashingMappedIterable<>(100, 1, 100, new Function<Integer, Maybe<Integer>>() {",
        "ins1DelCode":"Maybe.concat(new CrashingMappedIterable<Maybe<Integer>>(100, 1, 100, new Function<Integer, Maybe<Integer>>() {",
        "ins1PreCode":"public void hasNextThrows() { Maybe.concat(new CrashingMappedIterable<Maybe<Integer>>(100, 1, 100, new Function<Integer, Maybe<Integer>>() { @Override public Maybe<Integer> apply(Integer v) throws Exception {",
        "ins2PreCode":"public void nextThrows() { Maybe.concat(new CrashingMappedIterable<Maybe<Integer>>(100, 100, 1, new Function<Integer, Maybe<Integer>>() { @Override public Maybe<Integer> apply(Integer v) throws Exception {",
        "label":1
    },
    {
        "ins1AddCode":"DefaultCategoryDataset<String, String> dataset0 = new DefaultCategoryDataset<>(); DefaultCategoryDataset<String, String> dataset1 = new DefaultCategoryDataset<>();",
        "ins1DelCode":"DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset();",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { DefaultCategoryDataset dataset0 = new DefaultCategoryDataset(); dataset0.addValue(21.0, \"R1\", \"C1\"); dataset0.addValue(22.0, \"R2\", \"C1\"); DefaultCategoryDataset dataset1 = new DefaultCategoryDataset(); dataset1.addValue(23.0, \"R3\", \"C1\"); dataset1.addValue(24.0, \"R4\", \"C1\");",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);",
        "ins1PreCode":"public void doUpgrade(StaplerResponse rsp) throws IOException, ServletException { Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonUpgradeJob job = new HudsonUpgradeJob(getCoreSource(), Jenkins.getAuthentication()); if(!Lifecycle.get().canRewriteHudsonWar()) {",
        "ins2PreCode":"public void doRestart(StaplerResponse rsp) throws IOException, ServletException { Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER); HudsonDowngradeJob job = new HudsonDowngradeJob(getCoreSource(), Jenkins.getAuthentication()); Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);",
        "label":0
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(dataset0, new CategoryAxis(\"x\"),",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"),",
        "ins1PreCode":"dataset1.addValue(24.0, \"R4\", \"C1\"); dataset1.addValue(25.0, \"R5\", \"C1\"); CategoryStepRenderer r = new CategoryStepRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, dataset1);",
        "ins2PreCode":"dataset1.addValue(24.0, \"R4\", \"C1\"); dataset1.addValue(25.0, \"R5\", \"C1\"); BoxAndWhiskerRenderer r = new BoxAndWhiskerRenderer(); CategoryPlot plot = new CategoryPlot(dataset0, new CategoryAxis(\"x\"), new NumberAxis(\"y\"), r); plot.setDataset(1, dataset1);",
        "label":1
    },
    {
        "ins1AddCode":"IllegalArgumentException iae = new IllegalArgumentException(sm.getString(\"userMBean.createError.role\", role));",
        "ins1DelCode":"IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for role \" + role);",
        "ins1PreCode":"MBeanUtils.createObjectName(managed.getDomain(), role); results.add(oname.toString()); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for role \" + role); iae.initCause(e); throw iae;",
        "ins2PreCode":"ObjectName oname = MBeanUtils.createObjectName(managed.getDomain(), role); results.add(oname.toString()); } catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException( \"Cannot create object name for role \" + role); iae.initCause(e); throw iae;",
        "label":1
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(marker, \"marker\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(marker, \"marker\");",
        "ins1PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { ParamChecks.nullNotPermitted(marker, \"marker\"); ArrayList markers; if (layer == Layer.FOREGROUND) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"protected void setTarget(Object theNewTarget) { assert (getTarget() == null); assert (!(getTarget() instanceof Fig));",
        "ins1DelCode":"public void setTarget(Object theNewTarget) { if (getTarget() != null) { Enumeration enumeration = elements(); while (enumeration.hasMoreElements()) { Object base = enumeration.nextElement(); Model.getPump().removeModelEventListener( this, base, \"ownedElement\"); } Model.getPump().removeModelEventListener( this, getTarget(), \"base\"); }",
        "ins1PreCode":"public void setTarget(Object theNewTarget) { theNewTarget = theNewTarget instanceof Fig ? ((Fig) theNewTarget).getOwner() : theNewTarget; if (Model.getFacade().isAModelElement(theNewTarget) || theNewTarget instanceof Diagram) { if (getTarget() != null) { Enumeration enumeration = elements(); while (enumeration.hasMoreElements()) { Object base = enumeration.nextElement(); Model.getPump().removeModelEventListener( this, base, \"ownedElement\"); } Model.getPump().removeModelEventListener( this, getTarget(),",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"lookup = new SearchLookup(field -> field.equals(\"field\") ? fieldType : null,",
        "ins1DelCode":"lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null,",
        "ins1PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData);  service = new ExpressionScriptEngine(); lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "ins2PreCode":"when(fieldData.load(anyObject())).thenReturn(atomicFieldData); service = new ExpressionScriptEngine(); lookup = new SearchLookup(field -> field.equals(\"field\") || field.equals(\"alias\") ? fieldType : null, (ignored, lookup) -> fieldData);",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":" @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(\"one\"); observer.onError(new Throwable(\"injected failure\"));",
        "ins2PreCode":"@Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); subscriber.onNext(\"one\"); subscriber.onError(new Throwable(\"injected failure\"));",
        "label":0
    },
    {
        "ins1AddCode":"return Flowable.fromArray(source1, source2, source3, source4).flatMapSingle(Functions.identity(), true, Integer.MAX_VALUE);",
        "ins1DelCode":"return mergeDelayError(Flowable.fromArray(source1, source2, source3, source4));",
        "ins1PreCode":"Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\"); return mergeDelayError(Flowable.fromArray(source1, source2, source3, source4));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"initialize(this.initializationContext, null, null);",
        "ins1DelCode":"this.loggingSystem.initialize(this.initializationContext, null, null);",
        "ins1PreCode":"void getLoggingConfigurations() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(this.initializationContext, null, null); this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG); List<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();",
        "ins2PreCode":"void getLoggingConfigurations() { this.loggingSystem.beforeInitialize(); this.loggingSystem.initialize(null, null, null); this.loggingSystem.setLogLevel(getClass().getName(), LogLevel.DEBUG); List<LoggerConfiguration> configurations = this.loggingSystem.getLoggerConfigurations();",
        "label":0
    },
    {
        "ins1AddCode":"public StringBuilder getNestedDeclaration(DBRProgressMonitor monitor, GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) StringBuilder decl = super.getNestedDeclaration(monitor, owner, command, options);",
        "ins1DelCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) StringBuilder decl = super.getNestedDeclaration(owner, command, options);",
        "ins1PreCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(owner, command, options); final GenericTableColumn column = command.getObject(); if (column.isAutoIncrement()) {",
        "ins2PreCode":"public StringBuilder getNestedDeclaration(GenericTable owner, DBECommandAbstract<GenericTableColumn> command, Map<String, Object> options) { StringBuilder decl = super.getNestedDeclaration(owner, command, options); final GenericTableColumn column = command.getObject(); if (column.isAutoIncrement()) {",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\");",
        "ins1PreCode":"SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return merge(Flowable.fromArray(source1, source2, source3, source4));",
        "ins2PreCode":"SingleSource<? extends T> source1, SingleSource<? extends T> source2, SingleSource<? extends T> source3, SingleSource<? extends T> source4 ) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return mergeDelayError(Flowable.fromArray(source1, source2, source3, source4));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins1DelCode":"assertEquals(\"article\", entry.getType()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1PreCode":"BibEntry entry = parsed.iterator().next();  assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins2PreCode":"BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "label":1
    },
    {
        "ins1AddCode":"(\"Exception destroying group [\" + groupname + \"] MBean\");",
        "ins1DelCode":"(\"Exception destroying group \" + group + \" MBean\");",
        "ins1PreCode":"database.removeGroup(group); } catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException (\"Exception destroying group \" + group + \" MBean\"); iae.initCause(e); throw iae;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"value instanceof Double  || value instanceof BigInteger",
        "ins1DelCode":"value instanceof Double",
        "ins1PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double ) { return ((Number)value).doubleValue();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"project1.getBuildersList().add(createScriptBuilder(\"echo 1\")); project2.getBuildersList().add(createScriptBuilder(\"echo 1\")); project3.getBuildersList().add(createScriptBuilder(\"echo 1\"));",
        "ins1DelCode":"project1.getBuildersList().add(new Shell(\"echo 1\")); project2.getBuildersList().add(new Shell(\"echo 1\")); project3.getBuildersList().add(new Shell(\"echo 1\"));",
        "ins1PreCode":"@Test public void reloadJobManyShouldSucceed() throws Exception {  FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project3 = j.createFreeStyleProject(\"aProject3\"); project3.getBuildersList().add(new Shell(\"echo 1\"));  assertThat(project1.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "ins2PreCode":"@Test public void reloadJobManyShouldSucceedEvenAJobIsSpecifiedTwice() throws Exception { FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project2 = j.createFreeStyleProject(\"aProject2\"); project2.getBuildersList().add(new Shell(\"echo 1\")); FreeStyleProject project1 = j.createFreeStyleProject(\"aProject1\"); project1.getBuildersList().add(new Shell(\"echo 1\")); assertThat(project1.scheduleBuild2(0).get().getLog(), containsString(\"echo 1\"));",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"2014\"), db.getEntryByCitationKey(\"1\").get().getField(StandardField.YEAR));",
        "ins1DelCode":"assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "ins1PreCode":"  assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "ins2PreCode":"assertEquals(1, db.getEntryCount()); assertEquals(Optional.of(\"2014\"), db.getEntryByKey(\"1\").get().getField(StandardField.YEAR));",
        "label":1
    },
    {
        "ins1AddCode":"Args.nullNotPermitted(renderer, \"renderer\");",
        "ins1DelCode":"ParamChecks.nullNotPermitted(renderer, \"renderer\");",
        "ins1PreCode":"protected void applyToCategoryItemRenderer(CategoryItemRenderer renderer) { ParamChecks.nullNotPermitted(renderer, \"renderer\");  if (renderer instanceof AbstractRenderer) {",
        "ins2PreCode":"protected void applyToXYItemRenderer(XYItemRenderer renderer) { ParamChecks.nullNotPermitted(renderer, \"renderer\"); if (renderer instanceof AbstractRenderer) {",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); q.offer(1);  Disposable d = Disposables.empty();  QueueDrainHelper.drainMaxLoop(q, ts, false, d, qd);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts = new TestSubscriber<>(0L);",
        "ins1DelCode":"final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);",
        "ins1PreCode":"final Integer[] a = new Integer[1000]; Arrays.fill(a, 1);  final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L);  Single.just(1)",
        "ins2PreCode":"final Integer[] a = new Integer[1000]; Arrays.fill(a, 1); final TestSubscriber<Integer> ts = new TestSubscriber<Integer>(0L); Single.just(1)",
        "label":1
    },
    {
        "ins1AddCode":".withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", .run((context) -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping( context); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()) .isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()) .containsAll(Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\")); });",
        "ins1DelCode":".withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\")); });",
        "ins1PreCode":"public void cloudFoundryPlatformActive() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\")); });",
        "ins2PreCode":"public void cloudFoundryPlatformActive() { this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(context); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\")); });",
        "label":1
    },
    {
        "ins1AddCode":"void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException {",
        "ins1DelCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException {",
        "ins1PreCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException { ParserResult result = parser.parse( new StringReader(",
        "ins2PreCode":"public void parseRecognizesMonthFieldsWithFollowingComma() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},month={8,}},\"));",
        "label":1
    },
    {
        "ins1AddCode":"this.content = TextUtils.createTextBlock(this.text, this.font, this.content = TextUtils.createTextBlock(this.text, this.font,",
        "ins1DelCode":"this.content = TextUtilities.createTextBlock(this.text, this.font, this.content = TextUtilities.createTextBlock(this.text, this.font,",
        "ins1PreCode":"if (position == RectangleEdge.TOP || position == RectangleEdge.BOTTOM) { float maxWidth = (float) w; g2.setFont(this.font); this.content = TextUtilities.createTextBlock(this.text, this.font, this.paint, maxWidth, this.maximumLinesToDisplay, new G2TextMeasurer(g2)); this.content.setLineAlignment(this.textAlignment); Size2D contentSize = this.content.calculateDimensions(g2); if (this.expandToFitSpace) { return new Size2D(maxWidth, contentSize.getHeight()); } else { return contentSize; } } else if (position == RectangleEdge.LEFT || position == RectangleEdge.RIGHT) { float maxWidth = Float.MAX_VALUE; g2.setFont(this.font); this.content = TextUtilities.createTextBlock(this.text, this.font, this.paint, maxWidth, this.maximumLinesToDisplay, new G2TextMeasurer(g2));",
        "ins2PreCode":"if (position == RectangleEdge.TOP || position == RectangleEdge.BOTTOM) { float maxWidth = (float) widthRange.getUpperBound(); g2.setFont(this.font); this.content = TextUtilities.createTextBlock(this.text, this.font, this.paint, maxWidth, this.maximumLinesToDisplay, new G2TextMeasurer(g2)); this.content.setLineAlignment(this.textAlignment); Size2D contentSize = this.content.calculateDimensions(g2); if (this.expandToFitSpace) { return new Size2D(maxWidth, contentSize.getHeight()); } else { return contentSize; } } else if (position == RectangleEdge.LEFT || position == RectangleEdge.RIGHT) { float maxWidth = (float) widthRange.getUpperBound(); g2.setFont(this.font); this.content = TextUtilities.createTextBlock(this.text, this.font, this.paint, maxWidth, this.maximumLinesToDisplay, new G2TextMeasurer(g2));",
        "label":1
    },
    {
        "ins1AddCode":"void validateTokenWhenKidValidationSucceedsInTheSecondAttempt() throws Exception {",
        "ins1DelCode":"public void validateTokenWhenKidValidationSucceedsInTheSecondAttempt() throws Exception {",
        "ins1PreCode":"public void validateTokenWhenKidValidationSucceedsInTheSecondAttempt() throws Exception { ReflectionTestUtils.setField(this.tokenValidator, \"tokenKeys\", INVALID_KEYS); given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);",
        "ins2PreCode":"public void validateTokenShouldFetchTokenKeysIfNull() throws Exception { given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS); given(this.securityService.fetchTokenKeys()).willReturn(VALID_KEYS);",
        "label":1
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (count++ == 1) { return null; } else { return new ArrayList<Integer>(); } }",
        "ins2PreCode":"if (count++ == 1) { return null; } else { return new ArrayList<Integer>(); } }",
        "label":1
    },
    {
        "ins1AddCode":"\"FROM GV$SESSION s \\n\" + \"LEFT JOIN gv$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN gv$sess_io io ON ( s.sid = io.sid)\\n\" +",
        "ins1DelCode":"\"FROM V$SESSION s \\n\" + \"LEFT JOIN v$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN v$sess_io io ON ( s.sid = io.sid)\\n\" +",
        "ins1PreCode":"StringBuilder sql = new StringBuilder(); sql.append( \"SELECT s.*, sq.SQL_FULLTEXT, io.* \\n\" + \"FROM V$SESSION s \\n\" + \"LEFT JOIN v$sql sq ON (s.sql_address = sq.address AND s.sql_hash_value = sq.hash_value AND s.sql_child_number = sq.child_number)\\n\" + \"LEFT JOIN v$sess_io io ON ( s.sid = io.sid)\\n\" +  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XIntervalSeries<String> s1 = new XIntervalSeries<>(\"s1\"); XIntervalSeries<String> s2 = CloneUtils.clone(s1);",
        "ins1DelCode":"XIntervalSeries s1 = new XIntervalSeries(\"s1\"); XIntervalSeries s2 = CloneUtils.clone(s1);",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XIntervalSeries s1 = new XIntervalSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); XIntervalSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { VectorSeries s1 = new VectorSeries(\"s1\"); s1.add(1.0, 0.5, 1.5, 2.0); VectorSeries s2 = CloneUtils.clone(s1); assertTrue(s1 != s2); assertTrue(s1.getClass() == s2.getClass());",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(\"User1\", user.getName()); Assertions.assertEquals(\"foo\", customCache.getStringValue()); Assertions.assertEquals(10, customCache.getIntegerValue().intValue()); Assertions.assertEquals(1000, customCache.getLongValue());",
        "ins1DelCode":"Assert.assertEquals(\"User1\", user.getName()); Assert.assertEquals(\"foo\", customCache.getStringValue()); Assert.assertEquals(10, customCache.getIntegerValue().intValue()); Assert.assertEquals(1000, customCache.getLongValue());",
        "ins1PreCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUser(1); CustomCache customCache = unwrap(sqlSessionFactory.getConfiguration().getCache(Mapper.class.getName())); Assert.assertEquals(\"User1\", user.getName()); Assert.assertEquals(\"foo\", customCache.getStringValue()); Assert.assertEquals(10, customCache.getIntegerValue().intValue()); Assert.assertEquals(1000, customCache.getLongValue()); }",
        "ins2PreCode":"AnnotationMapper mapper = sqlSession.getMapper(AnnotationMapper.class); User user = mapper.getUser(1); CustomCache customCache = unwrap(sqlSessionFactory.getConfiguration().getCache(Mapper.class.getName())); Assert.assertEquals(\"User1\", user.getName()); Assert.assertEquals(\"foo\", customCache.getStringValue()); Assert.assertEquals(10, customCache.getIntegerValue().intValue()); Assert.assertEquals(1000, customCache.getLongValue()); }",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairDStream<String, Integer> updated = pairStream.updateStateByKey((values, state) -> { int out = 0; if (state.isPresent()) { out += state.get(); } for (Integer v : values) { out += v; } return Optional.of(out); });",
        "ins1DelCode":"JavaPairDStream<String, Integer> updated = pairStream.updateStateByKey( new Function2<List<Integer>, Optional<Integer>, Optional<Integer>>() { @Override public Optional<Integer> call(List<Integer> values, Optional<Integer> state) { int out = 0; if (state.isPresent()) { out += state.get(); } for (Integer v : values) { out += v; } return Optional.of(out); } });",
        "ins1PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream);  JavaPairDStream<String, Integer> updated = pairStream.updateStateByKey( new Function2<List<Integer>, Optional<Integer>, Optional<Integer>>() { @Override public Optional<Integer> call(List<Integer> values, Optional<Integer> state) { int out = 0; if (state.isPresent()) {",
        "ins2PreCode":"JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<String, Integer> updated = pairStream.updateStateByKey((values, state) -> { List<List<Tuple2<String, Integer>>> expected = Arrays.asList( Assert.assertEquals(expected, result); JavaPairDStream<String, Integer> updated = pairStream.updateStateByKey((values, state) -> { int out = 0; if (state.isPresent()) {",
        "label":0
    },
    {
        "ins1AddCode":"void javaBeanDeprecatedPropertyOnSetter() throws IOException {",
        "ins1DelCode":"public void javaBeanDeprecatedPropertyOnSetter() throws IOException {",
        "ins1PreCode":"public void javaBeanDeprecatedPropertyOnSetter() throws IOException { process(SimpleProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);",
        "ins2PreCode":"public void javaBeanPropertyWithDescription() throws IOException { process(SimpleProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(SimpleProperties.class);",
        "label":1
    },
    {
        "ins1AddCode":"TimePeriodValues s2 = TestUtils.serialised(s1);",
        "ins1DelCode":"TimePeriodValues s2 = (TimePeriodValues) TestUtils.serialised(s1);",
        "ins1PreCode":"s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimePeriodValues s2 = (TimePeriodValues) TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"name.append(\",context=\"); String contextName = ((Context)container).getName(); if (!contextName.startsWith(\"/\")) { contextName = \"/\" + contextName; } name.append(contextName);",
        "ins1DelCode":"name.append(\",path=\"); String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; } name.append(path);",
        "ins1PreCode":"StringBuilder name = new StringBuilder(\"type=Manager\");  if (container instanceof Context) { name.append(\",path=\"); Context context = (Context) container;  String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; } name.append(path);  name.append(\",host=\");",
        "ins2PreCode":"StringBuilder name = new StringBuilder(\"type=Loader\"); if (container instanceof Context) { name.append(\",path=\"); Context context = (Context) container; String path = context.getPath(); if (path.equals(\"\")) { path = \"/\"; } name.append(path); name.append(\",host=\");",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(\"Expecting attribute value printed\", log, containsString(\"Attribute attr1 = test\")); assertThat(\"Expecting nested element value printed\", log, containsString(\"Fileset basedir = \" + baseDir.getAbsolutePath()));",
        "ins1DelCode":"assertTrue(\"Expecting attribute value printed\", log.contains(\"Attribute attr1 = test\")); assertTrue(\"Expecting nested element value printed\", log.contains(\"Fileset basedir = \" + baseDir.getAbsolutePath()));",
        "ins1PreCode":"FileSet fileset = p.getReference(\"testfileset\"); File baseDir = fileset.getDir(p); String log = buildRule.getLog(); assertTrue(\"Expecting attribute value printed\", log.contains(\"Attribute attr1 = test\"));  assertTrue(\"Expecting nested element value printed\", log.contains(\"Fileset basedir = \" + baseDir.getAbsolutePath()));",
        "ins2PreCode":"FileSet fileset = p.getReference(\"testfileset\"); File baseDir = fileset.getDir(p); String log = buildRule.getLog(); assertTrue(\"Expecting attribute value to be printed\", log.contains(\"Attribute attr1 = test\")); assertTrue(\"Expecting nested element value to be printed\", log.contains(\"Fileset basedir = \" + baseDir.getAbsolutePath()));",
        "label":1
    },
    {
        "ins1AddCode":"given(this.bintrayService.isDistributionComplete(eq(releaseInfo), (Set<String>) any(), any())).willReturn(false, true); Set<String> artifactDigests = Collections.singleton(\"602e20176706d3cc7535f01ffdbe91b270ae5014\"); this.service.distribute(\"libs-release-local\", releaseInfo, artifactDigests); InOrder ordered = inOrder(this.bintrayService); ordered.verify(this.bintrayService).isDistributionComplete(releaseInfo, artifactDigests, SHORT_TIMEOUT); ordered.verify(this.bintrayService).isDistributionComplete(releaseInfo, artifactDigests, LONG_TIMEOUT);",
        "ins1DelCode":"given(this.bintrayService.isDistributionComplete(releaseInfo)).willReturn(true); this.service.distribute(\"libs-release-local\", releaseInfo); verify(this.bintrayService, times(1)).isDistributionComplete(releaseInfo);",
        "ins1PreCode":"void distributeWhenSuccessful() throws Exception { ReleaseInfo releaseInfo = getReleaseInfo(); given(this.bintrayService.isDistributionComplete(releaseInfo)).willReturn(true); this.server.expect(requestTo(\"https://repo.spring.io/api/build/distribute/example-build/example-build-1\")) .andExpect(method(HttpMethod.POST)) .andExpect(content().json( \"{\\\"sourceRepos\\\": [\\\"libs-release-local\\\"], \\\"targetRepo\\\" : \\\"spring-distributions\\\", \\\"async\\\":\\\"true\\\"}\")) .andExpect(header(\"Authorization\", \"Basic \" + Base64Utils.encodeToString(String .format(\"%s:%s\", this.properties.getUsername(), this.properties.getPassword()).getBytes()))) .andExpect(header(\"Content-Type\", MediaType.APPLICATION_JSON.toString())).andRespond(withSuccess()); this.service.distribute(\"libs-release-local\", releaseInfo); this.server.verify(); verify(this.bintrayService, times(1)).isDistributionComplete(releaseInfo);",
        "ins2PreCode":"void distributeWhenGettingPackagesTimesOut() throws Exception { ReleaseInfo releaseInfo = getReleaseInfo(); given(this.bintrayService.isDistributionComplete(releaseInfo)).willReturn(false); this.server.expect(requestTo(\"https://repo.spring.io/api/build/distribute/example-build/example-build-1\")) .andExpect(method(HttpMethod.POST)) .andExpect(content().json( \"{\\\"sourceRepos\\\": [\\\"libs-release-local\\\"], \\\"targetRepo\\\" : \\\"spring-distributions\\\", \\\"async\\\":\\\"true\\\"}\")) .andExpect(header(\"Authorization\", \"Basic \" + Base64Utils.encodeToString(String .format(\"%s:%s\", this.properties.getUsername(), this.properties.getPassword()).getBytes()))) .andExpect(header(\"Content-Type\", MediaType.APPLICATION_JSON.toString())).andRespond(withSuccess()); .isThrownBy(() -> this.service.distribute(\"libs-release-local\", releaseInfo)); this.server.verify(); verify(this.bintrayService, times(1)).isDistributionComplete(releaseInfo);",
        "label":1
    },
    {
        "ins1AddCode":".set(package$.MODULE$.SHUFFLE_SPILL_COMPRESS(), false) .set(package$.MODULE$.SHUFFLE_COMPRESS(), false));",
        "ins1DelCode":".set(\"spark.shuffle.spill.compress\", \"false\") .set(\"spark.shuffle.compress\", \"false\"));",
        "ins1PreCode":"new SparkConf() .set(\"spark.memory.offHeap.enabled\", \"\" + useOffHeapMemoryAllocator()) .set(\"spark.memory.offHeap.size\", \"256mb\") .set(\"spark.shuffle.spill.compress\", \"false\") .set(\"spark.shuffle.compress\", \"false\")); taskMemoryManager = new TaskMemoryManager(memoryManager, 0); ",
        "ins2PreCode":"anyInt(), File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); File file = File.createTempFile(\"spillFile\", \".spill\", tempDir); taskContext = mock(TaskContext.class); when(blockManager.diskBlockManager()).thenReturn(diskBlockManager);",
        "label":0
    },
    {
        "ins1AddCode":"JavaDoubleRDD doubles = rdd.mapToDouble(Integer::doubleValue).cache(); JavaPairRDD<Integer, Integer> pairs = rdd.mapToPair(x -> new Tuple2<>(x, x)).cache(); JavaRDD<String> strings = rdd.map(Object::toString).cache();",
        "ins1DelCode":"JavaDoubleRDD doubles = rdd.mapToDouble(new DoubleFunction<Integer>() { @Override public double call(Integer x) { return x.doubleValue(); } }).cache(); JavaPairRDD<Integer, Integer> pairs = rdd.mapToPair( new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer x) { return new Tuple2<>(x, x); } }).cache(); JavaRDD<String> strings = rdd.map(new Function<Integer, String>() { @Override public String call(Integer x) { return x.toString(); } }).cache();",
        "ins1PreCode":"public void map() { JavaRDD<Integer> rdd = sc.parallelize(Arrays.asList(1, 2, 3, 4, 5)); JavaDoubleRDD doubles = rdd.mapToDouble(new DoubleFunction<Integer>() { @Override public double call(Integer x) { return x.doubleValue(); } }).cache(); doubles.collect(); JavaPairRDD<Integer, Integer> pairs = rdd.mapToPair( new PairFunction<Integer, Integer, Integer>() { @Override public Tuple2<Integer, Integer> call(Integer x) { return new Tuple2<>(x, x); } }).cache(); pairs.collect(); JavaRDD<String> strings = rdd.map(new Function<Integer, String>() { @Override public String call(Integer x) { return x.toString(); } }).cache(); strings.collect();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Collections.singletonList(\"value\"), result);",
        "ins1DelCode":"Assert.assertEquals(Collections.singletonList(\"value\"), result);",
        "ins1PreCode":"autoCompleter.indexEntry(entry);  Collection<String> result = autoCompleter.call(getRequest((\"val\"))); Assert.assertEquals(Collections.singletonList(\"value\"), result);",
        "ins2PreCode":"autoCompleter.indexEntry(entry); Collection<String> result = autoCompleter.call(getRequest((\"lue\"))); Assert.assertEquals(Collections.singletonList(\"value\"), result);",
        "label":1
    },
    {
        "ins1AddCode":"TextFlow description = createDescription(query, EnumSet.noneOf(SearchFlags.class));",
        "ins1DelCode":"TextFlow description = createDescription(query, false, false);",
        "ins1PreCode":"List<Text> expectedTexts = Arrays.asList(TooltipTextUtil.createText(\"This search contains entries in which \"), TooltipTextUtil.createText(\"not \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"a\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"c\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" or \"), TooltipTextUtil.createText(\"the field \"), TooltipTextUtil.createText(\"e\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" contains the term \"), TooltipTextUtil.createText(\"x\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\". \"), TooltipTextUtil.createText(\"The search is case insensitive.\")); TextFlow description = createDescription(query, false, false);  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded);",
        "ins1DelCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded);",
        "ins1PreCode":"public void testProhibitSymlinks() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-setup\");",
        "ins2PreCode":"public void testFileSymlink() { Assume.assumeTrue(\"System does not support Symlinks\", supportsSymlinks); Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); buildRule.getProject().executeTarget(\"symlink-file-setup\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Collections.singletonList(author), result);",
        "ins1DelCode":"Assert.assertEquals(Collections.singletonList(author), result);",
        "ins1PreCode":"Author author = new Author(\"Eric\", \"E.\", \"von\", \"Hippel\", \"\");  Collection<Author> result = autoCompleter.call(getRequest((\"Eric\"))); Assert.assertEquals(Collections.singletonList(author), result);",
        "ins2PreCode":"Author author = new Author(\"Eric\", \"E.\", \"von\", \"Hippel\", \"\"); Collection<Author> result = autoCompleter.call(getRequest((\"von\"))); Assert.assertEquals(Collections.singletonList(author), result);",
        "label":1
    },
    {
        "ins1AddCode":"return jjMoveStringLiteralDfa7_1(active0, 0x80000000000L);",
        "ins1DelCode":"return jjMoveStringLiteralDfa7_1(active0, 0x100000000000L);",
        "ins1PreCode":"switch(curChar) { case 99: return jjMoveStringLiteralDfa7_1(active0, 0x100000000000L); default : break;",
        "ins2PreCode":"switch(curChar) { case 101: return jjMoveStringLiteralDfa8_1(active0, 0x100000000000L); default : break;",
        "label":1
    },
    {
        "ins1AddCode":"Tomcat.addServlet(ctx, \"TesterServlet\", new ServerNameTesterServlet()); Assert.assertEquals(\"request.getServerName() is [a] and request.getServerPort() is 80\", client.getResponseBody());",
        "ins1DelCode":"Tomcat.addServlet(ctx, \"TesterServlet\", new TesterServlet());",
        "ins1PreCode":"Context ctx = tomcat.addContext(\"\", null);   Tomcat.addServlet(ctx, \"TesterServlet\", new TesterServlet()); ctx.addServletMappingDecoded(\"/foo\", \"TesterServlet\"); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"result = 37 * result + HashUtils.hashCodeForDoubleArray( result = 37 * result + HashUtils.hashCodeForPaint(this.fillPaint); result = 37 * result + HashUtils.hashCodeForPaint(",
        "ins1DelCode":"result = 37 * result + HashUtilities.hashCodeForDoubleArray( result = 37 * result + HashUtilities.hashCodeForPaint(this.fillPaint); result = 37 * result + HashUtilities.hashCodeForPaint(",
        "ins1PreCode":"public int hashCode() { int result = 193; result = 37 * result + HashUtilities.hashCodeForDoubleArray( this.polygon); result = 37 * result + HashUtilities.hashCodeForPaint(this.fillPaint); result = 37 * result + HashUtilities.hashCodeForPaint( this.outlinePaint); if (this.stroke != null) {",
        "ins2PreCode":"public int hashCode() { int result = 193; result = 37 * result + HashUtilities.hashCodeForPaint( this.outlinePaint); result = 37 * result + HashUtilities.hashCodeForPaint(this.fillPaint); result = 37 * result + HashUtilities.hashCodeForPaint( this.outlinePaint); if (this.stroke != null) {",
        "label":0
    },
    {
        "ins1AddCode":"public void testAPIExample() throws InterruptedException { server.join(60 * 1000); client.join(30 * 1000); expectedResult.charAt(icounter) \" result \" + result.charAt(icounter)); expectedResult.substring(result.length())); result.substring(expectedResult.length())); assertFalse(testMailClient.getFailMessage(), testMailClient.isFailed());",
        "ins1DelCode":"public void testAPIExample() { try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); } for (int icounter = 0; icounter<expectedResult.length(); icounter++) { if (icounter < result.length()) { if (expectedResult.charAt(icounter) != result.charAt(icounter)) { System.out.println(\"posit \" + icounter + \" expected \" + expectedResult.charAt(icounter) + \" result \" + result.charAt(icounter)); } } } if (expectedResult.length()>result.length()) { System.out.println(\"excedent of expected result \" + expectedResult.substring(result.length())); } if (expectedResult.length()<result.length()) { System.out.println(\"excedent of result \" + result.substring(expectedResult.length())); } if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins1PreCode":"public void testAPIExample() {  ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start();  ClientThread testMailClient = new ClientThread();  testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.cc(\"cc1@you.com\"); testMailClient.cc(\"cc2@you.com\"); testMailClient.bcc(\"bcc@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" );  Thread client = new Thread(testMailClient); client.start();  try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail( \"InterruptedException: \" + ie ); }  String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc1@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <cc2@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <bcc@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"Cc: cc1@you.com, cc2@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; for (int icounter = 0; icounter<expectedResult.length(); icounter++) { if (icounter < result.length()) { if (expectedResult.charAt(icounter) != result.charAt(icounter)) { System.out.println(\"posit \" + icounter + \" expected \" + expectedResult.charAt(icounter) + \" result \" + result.charAt(icounter)); } } } if (expectedResult.length()>result.length()) { System.out.println(\"excedent of expected result \" + expectedResult.substring(result.length())); } if (expectedResult.length()<result.length()) { System.out.println(\"excedent of result \" + result.substring(expectedResult.length())); } assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "ins2PreCode":"public void testToOnly() { ServerThread testMailServer = new ServerThread(); Thread server = new Thread(testMailServer); server.start(); ClientThread testMailClient = new ClientThread(); testMailClient.from(\"Mail Message <EmailTaskTest@ant.apache.org>\"); testMailClient.to(\"to@you.com\"); testMailClient.to(\"to@you.com\"); testMailClient.to(\"to@you.com\"); testMailClient.to(\"to@you.com\"); testMailClient.setSubject(\"Test subject\"); testMailClient.setMessage( \"test line 1\\n\" + \"test line 2\" ); Thread client = new Thread(testMailClient); client.start(); try { server.join(60 * 1000); client.join(30 * 1000); } catch (InterruptedException ie ) { fail(\"InterruptedException: \" + ie); } String result = testMailServer.getResult(); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + \"HELO \" + local + \"\\r\\n\" + \"250 \" + local + \" Hello \" + local + \" [127.0.0.1], pleased to meet you\\r\\n\" + \"MAIL FROM: <EmailTaskTest@ant.apache.org>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"RCPT TO: <to@you.com>\\r\\n\" + \"250\\r\\n\" + \"DATA\\r\\n\" + \"354\\r\\n\" + \"Subject: Test subject\\r\\n\" + \"From: Mail Message <EmailTaskTest@ant.apache.org>\\r\\n\" + \"To: to@you.com\\r\\n\" + \"To: to@you.com\\r\\n\" + \"X-Mailer: org.apache.tools.mail.MailMessage (ant.apache.org)\\r\\n\" + \"\\r\\n\" + \"test line 1\\r\\n\" + \"test line 2\\r\\n\" + \"\\r\\n\" + \".\\r\\n\" + \"250\\r\\n\" + \"QUIT\\r\\n\" + \"221\\r\\n\"; assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult.length(), result.length()); fail(\"InterruptedException: \" + ie); assertEquals(expectedResult, result); assertEquals(expectedResult.length(), result.length()); } } } assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); assertEquals(expectedResult.length(), result.length()); } assertEquals(expectedResult.length(), result.length()); String expectedResult = \"220 test SMTP EmailTaskTest\\r\\n\" + assertEquals(expectedResult.length(), result.length()); } assertEquals(expectedResult.length(), result.length()); assertEquals(expectedResult, result); if (testMailClient.isFailed()) { fail(testMailClient.getFailMessage()); }",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(this.output.toString()).doesNotContain( assertThat(this.output.toString())",
        "ins1DelCode":"assertThat(this.output).doesNotContain( assertThat(this.output)",
        "ins1PreCode":".run((context) -> { MeterRegistry registry = getInitializedMeterRegistry(context); assertThat(registry.get(\"http.client.requests\").meters()).hasSize(3); assertThat(this.output).doesNotContain( \"Reached the maximum number of URI tags for 'http.client.requests'.\"); assertThat(this.output) .doesNotContain(\"Are you using 'uriVariables'?\"); });",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<String> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<String> ts = new TestSubscriber<String>();",
        "ins1PreCode":"public void groupByBackpressure() throws InterruptedException {  TestSubscriber<String> ts = new TestSubscriber<String>();  Flowable.range(1, 4000)",
        "ins2PreCode":"public void groupByBackpressure2() throws InterruptedException { TestObserver<String> to = new TestObserver<String>(); Thread.sleep(1);",
        "label":1
    },
    {
        "ins1AddCode":"log(sm.getString(\"managerServlet.error.start\", displayPath), t);",
        "ins1DelCode":"getServletContext().log(sm.getString(\"managerServlet.startFailed\", displayPath), t);",
        "ins1PreCode":"displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); getServletContext().log(sm.getString(\"managerServlet.startFailed\", displayPath), t); writer.println(smClient.getString(\"managerServlet.startFailed\", displayPath));",
        "ins2PreCode":"\"managerServlet.stopped\", displayPath)); } catch (Throwable t) { ExceptionUtils.handleThrowable(t); writer.println(smClient.getString(\"managerServlet.noContext\", String displayPath = cn.getDisplayName(); writer.println(smClient.getString(\"managerServlet.noContext\", \"managerServlet.stopped\", displayPath));",
        "label":0
    },
    {
        "ins1AddCode":"if ( src != null )",
        "ins1DelCode":"if ( source.getIssueManagement() != null )",
        "ins1PreCode":"Map<Object, Object> context ) { IssueManagement src = source.getIssueManagement(); if ( source.getIssueManagement() != null ) { IssueManagement tgt = target.getIssueManagement();",
        "ins2PreCode":"Map<Object, Object> context ) { CiManagement src = source.getCiManagement(); if ( source.getCiManagement() != null ) { CiManagement tgt = target.getCiManagement();",
        "label":1
    },
    {
        "ins1AddCode":"final List<String> events = new ArrayList<>();",
        "ins1DelCode":"final List<String> events = new ArrayList<String>();",
        "ins1PreCode":"public void usingDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events); final Action completion = createOnCompletedAction(events);",
        "ins2PreCode":"public void usingDoesNotDisposesEagerlyBeforeCompletion() { final List<String> events = new ArrayList<String>(); Supplier<Resource> resourceFactory = createResourceFactory(events); final Action completion = createOnCompletedAction(events);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Files.readString(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding), stringWriter.toString());",
        "ins1DelCode":"try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins1PreCode":" databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries());  try (Scanner scanner = new Scanner(Paths.get(\"src/test/resources/testbib/bibWithUserCommentAndEntryChange.bib\"), encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"docs.get(indexName).add(client().prepareIndex(indexName).setId(Integer.toString(i)).setSource(\"foo\", \"a\"));",
        "ins1DelCode":"docs.get(indexName).add(client().prepareIndex(indexName, \"test\", Integer.toString(i)).setSource(\"foo\", \"a\"));",
        "ins1PreCode":"docs.put(indexName, new ArrayList<>()); int numDocs = between(5, 15); for (int i = 0; i < numDocs; i++) { docs.get(indexName).add(client().prepareIndex(indexName, \"test\", Integer.toString(i)).setSource(\"foo\", \"a\")); } }",
        "ins2PreCode":"docs.put(indexName, new ArrayList<>()); int numDocs = between(5, 15); for (int i = 0; i < numDocs; i++) { docs.get(indexName).add(client().prepareIndex(indexName, \"test\", Integer.toString(i)).setSource(\"foo\", \"a\")); } }",
        "label":1
    },
    {
        "ins1AddCode":".appName(\"Java Spark SQL data sources example\") runJdbcDatasetExample(spark);",
        "ins1DelCode":".appName(\"Java Spark SQL Data Sources Example\")",
        "ins1PreCode":"public static void main(String[] args) { SparkSession spark = SparkSession .builder() .appName(\"Java Spark SQL Data Sources Example\") .config(\"spark.some.config.option\", \"some-value\") .getOrCreate();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable.wrap(new ObservableSource<Object>() { @Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1); observer.onNext(2);",
        "ins2PreCode":"Observable.wrap(new ObservableSource<Object>() { @Override public void subscribe(Observer<? super Object> observer) { observer.onSubscribe(Disposables.empty()); observer.onNext(1); observer.onNext(2);",
        "label":1
    },
    {
        "ins1AddCode":"public final <@NonNull R> Observable<R> switchMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) {",
        "ins1DelCode":"public final <R> Observable<R> switchMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) {",
        "ins1PreCode":"public final <R> Observable<R> switchMap(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "ins2PreCode":"public final <R> Observable<R> switchMapDelayError(@NonNull Function<? super T, ? extends ObservableSource<? extends R>> mapper, int bufferSize) { Objects.requireNonNull(mapper, \"mapper is null\"); ObjectHelper.verifyPositive(bufferSize, \"bufferSize\");",
        "label":1
    },
    {
        "ins1AddCode":"Path texFile = Path.of(DefaultTexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Path.of(DefaultTexParserTest.class.getResource(\"paper2.tex\").toURI());",
        "ins1DelCode":"Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Paths.get(DefaultTexParserTest.class.getResource(\"paper2.tex\").toURI());",
        "ins1PreCode":"public void testTwoFiles() throws URISyntaxException { Path texFile = Paths.get(DefaultTexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Paths.get(DefaultTexParserTest.class.getResource(\"paper2.tex\").toURI());  LatexParserResult parserResult = new DefaultLatexParser().parse(Arrays.asList(texFile, texFile2));",
        "ins2PreCode":"public void testTwoFilesDifferentDatabases() throws URISyntaxException { Path texFile = Paths.get(LatexParserTest.class.getResource(\"paper.tex\").toURI()); Path texFile2 = Paths.get(LatexParserTest.class.getResource(\"paper2.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(Arrays.asList(texFile, texFile2));",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> p1 = new CategoryPlot<>(); CategoryPlot<String, String> p2 = new CategoryPlot<>();",
        "ins1DelCode":"CategoryPlot p1 = new CategoryPlot(); CategoryPlot p2 = new CategoryPlot();",
        "ins1PreCode":"public void testEquals_ObjectList2() { CategoryPlot p1 = new CategoryPlot(); p1.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); CategoryPlot p2 = new CategoryPlot(); p2.setDomainAxisLocation(AxisLocation.BOTTOM_OR_RIGHT); assertEquals(p1, p2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"}, (inputs) -> {",
        "ins1DelCode":"",
        "ins1PreCode":".run(assertProperties(\"test\", (properties) -> { assertThat(properties.get(\"dbPassword\")).isEqualTo(\"******\"); assertThat(properties.get(\"myTestProperty\")).isEqualTo(\"654321\"); }));",
        "ins2PreCode":".withPropertyValues(\"test.keys-to-sanitize=.*pass.*\").run(assertProperties(\"test\", (properties) -> { assertThat(properties.get(\"dbPassword\")).isEqualTo(\"******\"); assertThat(properties.get(\"myTestProperty\")).isEqualTo(\"654321\"); }));",
        "label":1
    },
    {
        "ins1AddCode":"CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"[auth3]\",",
        "ins1DelCode":"CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\",",
        "ins1PreCode":"Optional<BibEntry> entry0 = BibtexParser.singleFromString( \"@ARTICLE{kohn, author={Andreas K\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Koe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c1\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c9\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Eoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00cd\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Ioe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u0139\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Loe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u0143\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Noe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00d3\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Ooe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u0154\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Roe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u015a\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Soe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00da\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Uoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00dd\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Yoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));  entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u0179\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Zoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));",
        "ins2PreCode":"Optional<BibEntry> entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c0\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Eoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Ioe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Ooe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Uoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS)); entry0 = BibtexParser.singleFromString(\"@ARTICLE{kohn, author={Andreas \u00c8\u00f6ning}, year={2000}}\", importFormatPreferences, fileMonitor); assertEquals(\"Aoe\", CitationKeyGenerator.cleanKey(generateKey(entry0.orElse(null), \"auth3\", new BibDatabase()), DEFAULT_UNWANTED_CHARACTERS));",
        "label":0
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"AbstractStringProcessor.Factory factory = newFactory(); Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); Map<String, Object> config = new HashMap<>(); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch(ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"Object element = entries.get(i);",
        "ins1DelCode":"Object element = entries.elementAt(i);",
        "ins1PreCode":" final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i);  if (element instanceof MethodRefCPInfo) {",
        "ins2PreCode":"final int size = entries.size(); for (int i = 0; i < size && index == -1; ++i) { Object element = entries.elementAt(i); if (element instanceof InterfaceMethodRefCPInfo) {",
        "label":1
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); assertEquals(1016729699999L, m1.getLastMillisecond(cal)); assertEquals(1016729700000L, m2.getFirstMillisecond(cal));",
        "ins1DelCode":"assertEquals(1016729699999L, m1.getLastMillisecond(zone)); assertEquals(1016729700000L, m2.getFirstMillisecond(zone));",
        "ins1PreCode":"Minute m2 = new Minute(new Date(1016729700000L), zone, locale);  assertEquals(54, m1.getMinute()); assertEquals(1016729699999L, m1.getLastMillisecond(zone));  assertEquals(55, m2.getMinute()); assertEquals(1016729700000L, m2.getFirstMillisecond(zone));",
        "ins2PreCode":"Minute m2 = new Minute(new Date(1016700900000L), zone, locale); assertEquals(54, m1.getMinute()); assertEquals(1016700899999L, m1.getLastMillisecond(zone)); assertEquals(55, m2.getMinute()); assertEquals(1016700900000L, m2.getFirstMillisecond(zone));",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void degree_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void inDegree_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>(); final SerializedSubscriber<Integer> so = new SerializedSubscriber<>(ts);",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts);",
        "ins1PreCode":"public void onNextOnCompleteRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts);  BooleanSubscription bs = new BooleanSubscription();",
        "ins2PreCode":"public void onNextOnErrorRace() { for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); final SerializedSubscriber<Integer> so = new SerializedSubscriber<Integer>(ts); BooleanSubscription bs = new BooleanSubscription();",
        "label":1
    },
    {
        "ins1AddCode":"void testAnnotatedInsertTable2WithSelectKeyWithKeyMapXml() {",
        "ins1DelCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMapXml() {",
        "ins1PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMapXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins2PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyObjectXml() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "label":1
    },
    {
        "ins1AddCode":"if (parent != null) { if (!ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException( }",
        "ins1DelCode":"if (parent != null && !ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException(",
        "ins1PreCode":"if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); if (parent != null && !ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException( \"could not change to directory: %s\",",
        "ins2PreCode":"if (i >= 0) { String cwd = ftp.printWorkingDirectory(); String parent = dir.getParent(); && !ftp.changeWorkingDirectory(resolveFile(parent))) { throw new BuildException( \"could not change to directory: %s\",",
        "label":0
    },
    {
        "ins1AddCode":"final TestObserver<Integer> to1 = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Integer> to1 = new TestObserver<Integer>();",
        "ins1PreCode":" final ConnectableObservable<Integer> co = ps.replay();  final TestObserver<Integer> to1 = new TestObserver<Integer>();  Runnable r1 = new Runnable() {",
        "ins2PreCode":"final ConnectableObservable<Integer> co = ps.replay(); final TestObserver<Integer> to1 = new TestObserver<Integer>(); Runnable r1 = new Runnable() {",
        "label":1
    },
    {
        "ins1AddCode":"final TestObservable<String> w1 = new TestObservable<>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<>(callOnce, okToContinue, \"four\", \"five\", \"six\"); TestObserver<String> to = new TestObserver<>(observer);",
        "ins1DelCode":"final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\"); TestObserver<String> to = new TestObserver<String>(observer);",
        "ins1PreCode":"public void concatUnsubscribe() { final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\");  Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer);  final Observable<String> concat = Observable.concat(Observable.unsafeCreate(w1), Observable.unsafeCreate(w2));",
        "ins2PreCode":"public void concatUnsubscribeConcurrent() { final CountDownLatch callOnce = new CountDownLatch(1); final CountDownLatch okToContinue = new CountDownLatch(1); final TestObservable<String> w1 = new TestObservable<String>(\"one\", \"two\", \"three\"); final TestObservable<String> w2 = new TestObservable<String>(callOnce, okToContinue, \"four\", \"five\", \"six\"); Observer<String> observer = TestHelper.mockObserver(); TestObserver<String> to = new TestObserver<String>(observer); Observable<String> concatF = Observable.concat(Observable.unsafeCreate(observableOfObservables));",
        "label":1
    },
    {
        "ins1AddCode":"source.subscribe(new UsingObserver<>(observer, resource, disposer, eager));",
        "ins1DelCode":"source.subscribe(new UsingObserver<R>(observer, resource, disposer, eager));",
        "ins1PreCode":"return; }  source.subscribe(new UsingObserver<R>(observer, resource, disposer, eager));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void parseRecognizesFieldValuesInQuotationMarks() throws IOException {",
        "ins1DelCode":"public void parseRecognizesFieldValuesInQuotationMarks() throws IOException {",
        "ins1PreCode":"public void parseRecognizesFieldValuesInQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Ed von Test\\\"}\"));",
        "ins2PreCode":"public void parseRecognizesNumbersWithoutBracketsOrQuotationMarks() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,year = 2005}\"));",
        "label":1
    },
    {
        "ins1AddCode":"void writeOtherTypeTest() throws Exception {",
        "ins1DelCode":"public void writeOtherTypeTest() throws Exception {",
        "ins1PreCode":"public void writeOtherTypeTest() throws Exception { String expected = OS.NEWLINE + \"@Other{test,\" + OS.NEWLINE + \"  comment = {testentry},\" + OS.NEWLINE +",
        "ins2PreCode":"public void writeReallyUnknownTypeTest() throws Exception { String expected = OS.NEWLINE + \"@Reallyunknowntype{test,\" + OS.NEWLINE + \"  comment = {testentry},\" + OS.NEWLINE +",
        "label":1
    },
    {
        "ins1AddCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) { try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { SameIdPersonMapper personMapper = sqlSession.getMapper(SameIdPersonMapper.class); Person person = personMapper.select(1); assertEquals((Integer)1, person.getId()); assertEquals(2, person.getPets().size()); assertEquals((Integer)2, person.getPets().get(1).getId());  Pet pet = personMapper.selectPet(1); assertEquals(Integer.valueOf(1), pet.getId());  SameIdPetMapper petMapper = sqlSession.getMapper(SameIdPetMapper.class); Pet pet2 = petMapper.select(3); assertEquals((Integer)3, pet2.getId()); assertEquals((Integer)2, pet2.getOwner().getId()); } finally { sqlSession.close(); }",
        "ins2PreCode":"private void testCrossReference(SqlSessionFactory sqlSessionFactory) throws Exception { SqlSession sqlSession = sqlSessionFactory.openSession(); try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.select(1); assertEquals((Integer)1, person.getId()); assertEquals(2, person.getPets().size()); assertEquals((Integer)2, person.getPets().get(1).getId()); Pet pet = personMapper.selectPet(1); assertEquals(Integer.valueOf(1), pet.getId()); PetMapper petMapper = sqlSession.getMapper(PetMapper.class); Pet pet2 = petMapper.select(3); assertEquals((Integer)3, pet2.getId()); assertEquals((Integer)2, pet2.getOwner().getId()); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"List<TaskSegment> taskSegments = new ArrayList<>( tasks.size() );",
        "ins1DelCode":"List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() );",
        "ins1PreCode":"MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException { List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() );  TaskSegment currentSegment = null;",
        "ins2PreCode":"MojoNotFoundException, NoPluginFoundForPrefixException, InvalidPluginDescriptorException, PluginVersionResolutionException { List<TaskSegment> taskSegments = new ArrayList<TaskSegment>( tasks.size() ); TaskSegment currentSegment = null;",
        "label":1
    },
    {
        "ins1AddCode":"MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build();",
        "ins1DelCode":"MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build(); MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build();",
        "ins1PreCode":"public void transitiveClosure_directedPathGraph() { MutableGraph<Integer> directedGraph = GraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N2, N3); directedGraph.putEdge(N3, N4);  MutableGraph<Integer> expectedClosure = GraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "ins2PreCode":"public void transitiveClosure_undirectedPathGraph() { MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build(); undirectedGraph.putEdge(N1, N2); undirectedGraph.putEdge(N2, N3); undirectedGraph.putEdge(N3, N4); MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "label":1
    },
    {
        "ins1AddCode":"assumeNotNull(\"JPEG codec is unavailable in classpath\", buildRule.getProject().getProperty(\"jpeg.codec.available\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testOverwriteTrue() { buildRule.executeTarget(\"testSimpleScale\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); File f = new File(buildRule.getOutputDir(), LARGEIMAGE); assumeTrue(\"Could not change file modification date\", f.setLastModified(f.lastModified() - FILE_UTILS.getFileTimestampGranularity() * 2));",
        "ins2PreCode":"public void testOverwriteTrue() { buildRule.executeTarget(\"testSimpleScale\"); assertThat(buildRule.getLog(), containsString(\"Processing File\")); File f = new File(buildRule.getOutputDir(), LARGEIMAGE); assumeTrue(\"Could not change file modification date\", f.setLastModified(f.lastModified() - FILE_UTILS.getFileTimestampGranularity() * 2));",
        "label":0
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION);",
        "ins2PreCode":"public void nodes_checkReturnedSetMutability() { Set<Integer> nodes = network.nodes(); try { nodes.add(N2); fail(ERROR_MODIFIABLE_COLLECTION);",
        "label":0
    },
    {
        "ins1AddCode":"if (Execute.isFailure(result)) {",
        "ins1DelCode":"if (result != 0) {",
        "ins1PreCode":"checkOptions(commandLine);  result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation());",
        "ins2PreCode":"checkOptions(commandLine); result = run(commandLine); if (result != 0) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation());",
        "label":1
    },
    {
        "ins1AddCode":"if (state == AsyncState.STARTING || state == AsyncState.TIMING_OUT || state == AsyncState.ERROR || state == AsyncState.READ_WRITE_OP) {",
        "ins1DelCode":"if (state == AsyncState.STARTING) { } else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.READ_WRITE_OP) { state = AsyncState.MUST_COMPLETE;",
        "ins1PreCode":"pauseNonContainerThread(); clearNonBlockingListeners(); boolean doComplete = false; if (state == AsyncState.STARTING) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.STARTED) { state = AsyncState.COMPLETING; doComplete = true; } else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.READ_WRITE_OP) { state = AsyncState.MUST_COMPLETE; } else {",
        "ins2PreCode":"pauseNonContainerThread(); pauseNonContainerThread(); boolean doDispatch = false; if (state == AsyncState.STARTING || state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED) { state = AsyncState.DISPATCHING; doDispatch = true; state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.READ_WRITE_OP) { state = AsyncState.MUST_DISPATCH; } else {",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void assertValueAtPredicateMatch() { TestObserver<Integer> to = new TestObserver<Integer>();  Observable.just(1, 2).subscribe(to);",
        "ins2PreCode":"public void assertValueAtInvalidIndex() { TestObserver<Integer> to = new TestObserver<Integer>(); Observable.just(1, 2).subscribe(to);",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":" LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "ins2PreCode":"LocalListener l = new LocalListener(); this.chart.addChangeListener(l); XYPlot<String> plot = (XYPlot) this.chart.getPlot(); plot.setDataset(dataset); assertEquals(true, l.flag);",
        "label":0
    },
    {
        "ins1AddCode":"Properties executionProperties = new Properties(); if ( executionProperties.getProperty( sysprop ) == null ) executionProperties.setProperty( sysprop, \"value\" ); ExpressionEvaluator ee = createExpressionEvaluator( null, null, executionProperties );",
        "ins1DelCode":"if ( System.getProperty( sysprop ) == null ) System.setProperty( sysprop, \"value\" ); ExpressionEvaluator ee = createExpressionEvaluator( null, null );",
        "ins1PreCode":"{ String sysprop = \"PPEET_sysprop1\";  if ( System.getProperty( sysprop ) == null ) { System.setProperty( sysprop, \"value\" ); }  ExpressionEvaluator ee = createExpressionEvaluator( null, null );  Object value = ee.evaluate( \"${\" + sysprop + \"}\" );",
        "ins2PreCode":"{ String sysprop = \"PPEET.sysprop2\"; if ( System.getProperty( sysprop ) == null ) { System.setProperty( sysprop, \"value\" ); } ExpressionEvaluator ee = createExpressionEvaluator( null, null ); Object value = ee.evaluate( \"${\" + sysprop + \"}\" );",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(result.stderr(), containsString(\"never_created: No such item \u2018never_created\u2019 exists.\"));",
        "ins1DelCode":"assertThat(result.stderr(), containsString(\"never_created: No such job \\u2018never_created\\u2019 exists.\"));",
        "ins1PreCode":" assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created: No such job \\u2018never_created\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT)); ",
        "ins2PreCode":"assertThat(result, failedWith(5)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"never_created1: No such job \\u2018never_created1\\u2019 exists.\")); assertThat(result.stderr(), containsString(\"ERROR: \" + CLICommand.CLI_LISTPARAM_SUMMARY_ERROR_TEXT));",
        "label":0
    },
    {
        "ins1AddCode":"assumeFalse(\"Cannot disable verification in FIPS JVM\", inFipsJvm());",
        "ins1DelCode":"assertFalse(\"Cannot disable verification in FIPS JVM\", inFipsJvm());",
        "ins1PreCode":"public void testClientSucceedsWithVerificationDisabled() throws IOException { assertFalse(\"Cannot disable verification in FIPS JVM\", inFipsJvm()); final List<Thread> threads = new ArrayList<>(); final Settings settings = Settings.builder()",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.queue = new AtomicReference<>();",
        "ins1DelCode":"this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();",
        "ins1PreCode":"this.set = new CompositeDisposable(); this.errors = new AtomicThrowable(); this.active = new AtomicInteger(1); this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();",
        "ins2PreCode":"this.set = new CompositeDisposable(); this.errors = new AtomicThrowable(); this.active = new AtomicInteger(1); this.queue = new AtomicReference<SpscLinkedArrayQueue<R>>();",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/stage1\", \"dispatch\"); ctx.addServletMappingDecoded(\"/stage2\", \"nonasync\");",
        "ins1DelCode":"ctx.addServletMapping(\"/stage1\", \"dispatch\"); ctx.addServletMapping(\"/stage2\", \"nonasync\");",
        "ins1PreCode":"DispatchingServlet dispatch = new DispatchingServlet(false, false); Wrapper wrapper = Tomcat.addServlet(ctx, \"dispatch\", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/stage1\", \"dispatch\");  NonAsyncServlet nonasync = new NonAsyncServlet(); Wrapper wrapper2 = Tomcat.addServlet(ctx, \"nonasync\", nonasync); wrapper2.setAsyncSupported(true); ctx.addServletMapping(\"/stage2\", \"nonasync\");  ctx.addApplicationListener(TrackingRequestListener.class.getName());",
        "ins2PreCode":"DispatchingServlet dispatch = Wrapper wrapper = Tomcat.addServlet(ctx, \"dispatch\", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/stage1\", \"dispatch\"); ErrorServlet error = new ErrorServlet(); Wrapper wrapper = Tomcat.addServlet(ctx, \"dispatch\", dispatch); wrapper.setAsyncSupported(true); ctx.addServletMapping(\"/stage2\", \"error\"); ctx.addApplicationListener(TrackingRequestListener.class.getName());",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); }",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); sqlSession.close();",
        "ins1PreCode":"public void testWithComplex3() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getWithComplex3(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); sqlSession.close(); ",
        "ins2PreCode":"public void testWithParamAttributes() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.getComplexWithParamAttributes(2l); Assert.assertNotNull(\"person must not be null\", person); Assert.assertEquals(\"Christian\", person.getFirstName()); Assert.assertEquals(\"Poitras\", person.getLastName()); Person parent = person.getParent(); Assert.assertNotNull(\"parent must not be null\", parent); Assert.assertEquals(\"John\", parent.getFirstName()); Assert.assertEquals(\"Smith\", parent.getLastName()); sqlSession.close();",
        "label":1
    },
    {
        "ins1AddCode":"XYSeriesCollection<String> d1 = new XYSeriesCollection<>(); XYSeries<String> s1 = new XYSeries<>(\"S1\"); XYSeries<String> s2 = new XYSeries<>(\"S2\"); XYSeriesCollection<String> d2 = new XYSeriesCollection<>(); XYSeries<String> s3 = new XYSeries<>(\"S3\"); XYSeries<String> s4 = new XYSeries<>(\"S4\"); XYSeries<String> s5 = new XYSeries<>(\"S5\");",
        "ins1DelCode":"XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); XYSeries s2 = new XYSeries(\"S2\"); XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); XYSeries s4 = new XYSeries(\"S4\"); XYSeries s5 = new XYSeries(\"S5\");",
        "ins1PreCode":"public void testGetLegendItemSeriesIndex() { XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); XYSeries s2 = new XYSeries(\"S2\"); s2.add(1.0, 1.1); d1.addSeries(s1); d1.addSeries(s2);  XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); s3.add(1.0, 1.1); XYSeries s4 = new XYSeries(\"S4\"); s4.add(1.0, 1.1); XYSeries s5 = new XYSeries(\"S5\"); s5.add(1.0, 1.1); d2.addSeries(s3);",
        "ins2PreCode":"public void testGetLegendItemSeriesIndex() { XYSeriesCollection d1 = new XYSeriesCollection(); XYSeries s1 = new XYSeries(\"S1\"); s1.add(1.0, 1.1); XYSeries s2 = new XYSeries(\"S2\"); s2.add(1.0, 1.1); d1.addSeries(s1); d1.addSeries(s2); XYSeriesCollection d2 = new XYSeriesCollection(); XYSeries s3 = new XYSeries(\"S3\"); s3.add(1.0, 1.1); XYSeries s4 = new XYSeries(\"S4\"); s4.add(1.0, 1.1); XYSeries s5 = new XYSeries(\"S5\"); s5.add(1.0, 1.1); d2.addSeries(s3);",
        "label":1
    },
    {
        "ins1AddCode":"this.environment.getPropertySources() .addLast(new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"my.fallback\", \"foo\")));",
        "ins1DelCode":"this.environment.getPropertySources().addLast( new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"my.fallback\", (Object) \"foo\")));",
        "ins1PreCode":"void defaultPropertyAsFallback() { this.environment.getPropertySources().addLast( new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"my.fallback\", (Object) \"foo\"))); this.initializer.postProcessEnvironment(this.environment, this.application); String property = this.environment.getProperty(\"my.fallback\");",
        "ins2PreCode":"void defaultPropertyAsFallbackDuringFileParsing() { this.environment.getPropertySources().addLast(new MapPropertySource(\"defaultProperties\", Collections.singletonMap(\"spring.config.name\", (Object) \"testproperties\"))); this.initializer.postProcessEnvironment(this.environment, this.application); String property = this.environment.getProperty(\"the.property\");",
        "label":1
    },
    {
        "ins1AddCode":"void shouldRemoveItemOnDemand() {",
        "ins1DelCode":"public void shouldRemoveItemOnDemand() {",
        "ins1PreCode":"public void shouldRemoveItemOnDemand() { WeakCache cache = new WeakCache(new PerpetualCache(\"default\")); cache.putObject(0, 0);",
        "ins2PreCode":"public void shouldRemoveItemOnDemand() { Cache cache = new LruCache(new PerpetualCache(\"default\")); cache.putObject(0, 0);",
        "label":1
    },
    {
        "ins1AddCode":"deepCopyCachedObject(newObject, oldObject); } else { removeObject(oldObject, false); return oldObject;",
        "ins1DelCode":"removeObject(oldObject, false); cacheObject(newObject); return newObject;",
        "ins1PreCode":"OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null); removeObject(oldObject, false); if (newObject != null) { cacheObject(newObject); } return newObject; } return getCachedObject(objectName);",
        "ins2PreCode":"OBJECT newObject = this.reloadObject(monitor, owner, oldObject, null); removeObject(oldObject, false); if (newObject != null) { cacheObject(newObject); } return newObject; } return getCachedObject(objectName);",
        "label":1
    },
    {
        "ins1AddCode":"JavaRDD<Double> predictions = model.predict(rdd.map(LabeledPoint::features)); Assert.assertEquals(numCorrect, rdd.count());",
        "ins1DelCode":"JavaRDD<Double> predictions = model.predict(rdd.map(new Function<LabeledPoint, Vector>() { @Override public Vector call(LabeledPoint v1) { return v1.features(); } })); Assert.assertTrue(numCorrect == rdd.count());",
        "ins1PreCode":"DecisionTreeModel model = DecisionTree$.MODULE$.train(rdd.rdd(), strategy);   JavaRDD<Double> predictions = model.predict(rdd.map(new Function<LabeledPoint, Vector>() { @Override public Vector call(LabeledPoint v1) { return v1.features(); } }));  int numCorrect = validatePrediction(arr, model); Assert.assertTrue(numCorrect == rdd.count());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"IndexMetaData build = IndexMetaData.builder(\"\") .settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)) .numberOfShards(1).numberOfReplicas(0).build(); IndexSettings settings = new IndexSettings(build, Settings.EMPTY); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(settings,",
        "ins1DelCode":"ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY,",
        "ins1PreCode":"TermRangeQuery query = new TermRangeQuery(\"field1\", new BytesRef(\"a\"), new BytesRef(\"z\"), true, true); DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(), documentMapper, null, null); fieldMapper.processQuery(query, parseContext);",
        "ins2PreCode":"PhraseQuery phraseQuery = new PhraseQuery(\"field\", \"term\"); DocumentMapper documentMapper = mapperService.documentMapper(\"doc\"); PercolatorFieldMapper fieldMapper = (PercolatorFieldMapper) documentMapper.mappers().getMapper(fieldName); ParseContext.InternalParseContext parseContext = new ParseContext.InternalParseContext(Settings.EMPTY, mapperService.documentMapperParser(), documentMapper, null, null); fieldMapper.processQuery(phraseQuery, parseContext);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(body.contains(\"OK - 4\"));",
        "ins1DelCode":"",
        "ins1PreCode":"Assert.assertTrue(body.contains(\"OK - 1\")); Assert.assertTrue(body.contains(\"OK - 2\")); Assert.assertTrue(body.contains(\"OK - 3\")); Assert.assertFalse(body.contains(\"FAIL\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"fail(); assertTrue(e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameQuery). Cannot invoke a method that holds multiple arguments using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\"));",
        "ins1DelCode":"e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameQuery). Cannot invoke a method that holds multiple arguments using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\");",
        "ins1PreCode":"Mapper.class.getMethod(\"getUsersByName\", String.class, String.class).getAnnotation(SelectProvider.class)) .getBoundSql(new Object()); } catch (BuilderException e) { e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameQuery). Cannot invoke a method that holds multiple arguments using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\"); }",
        "ins2PreCode":"Mapper.class.getMethod(\"getUsersByNameWithParamName\", String.class).getAnnotation(SelectProvider.class)) .getBoundSql(new Object()); } catch (BuilderException e) { e.getMessage().contains(\"Error invoking SqlProvider method (org.apache.ibatis.submitted.sqlprovider.OurSqlBuilder.buildGetUsersByNameWithParamNameQuery). Cannot invoke a method that holds named argument(@Param) using a specifying parameterObject. In this case, please specify a 'java.util.Map' object.\"); }",
        "label":1
    },
    {
        "ins1AddCode":"this.queue = new SpscLinkedArrayQueue<>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<>(Objects.requireNonNull(onTerminate, \"onTerminate\")); this.downstream = new AtomicReference<>();",
        "ins1DelCode":"this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<Runnable>(onTerminate); this.downstream = new AtomicReference<Subscriber<? super T>>();",
        "ins1PreCode":"UnicastProcessor(int capacityHint, Runnable onTerminate, boolean delayError) { this.queue = new SpscLinkedArrayQueue<T>(ObjectHelper.verifyPositive(capacityHint, \"capacityHint\")); this.onTerminate = new AtomicReference<Runnable>(onTerminate); this.delayError = delayError; this.downstream = new AtomicReference<Subscriber<? super T>>(); this.once = new AtomicBoolean(); this.wip = new UnicastQueueSubscription();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"} else if (c == -1 || !isToken(c)) {",
        "ins1DelCode":"} else if (c == -1) {",
        "ins1PreCode":" if (c == '\"') { quoted = true; } else if (c == -1) { return null; } else {",
        "ins2PreCode":"while (c == 32 || c == 9) { c = input.read(); } else { return null; } else {",
        "label":0
    },
    {
        "ins1AddCode":".subscribeWith(new TestSubscriberEx<>()) .assertTerminated();",
        "ins1DelCode":".test() .assertNoErrors() .assertComplete();",
        "ins1PreCode":" .take(10, TimeUnit.MILLISECONDS) , flatMapMaxConcurrency) .test() .awaitDone(5, TimeUnit.SECONDS) .assertNoErrors() .assertComplete();",
        "ins2PreCode":".take(10, TimeUnit.MILLISECONDS) , flatMapMaxConcurrency) .test() .awaitDone(5, TimeUnit.SECONDS) .assertNoErrors() .assertComplete();",
        "label":1
    },
    {
        "ins1AddCode":"File file = new File(buildRule.getProject().getBaseDir(), tempFile); buildRule.executeTarget(\"test4\"); File file2 = new File(buildRule.getProject().getBaseDir(), tempFile2);",
        "ins1DelCode":"File file = new File(getProjectDir(), tempFile); executeTarget(\"test4\"); File file2 = new File(getProjectDir(), tempFile2);",
        "ins1PreCode":"public void test4() { test3();  File file = new File(getProjectDir(), tempFile); final long origSize = file.length();  executeTarget(\"test4\");  File file2 = new File(getProjectDir(), tempFile2); final long newSize = file2.length(); ",
        "ins2PreCode":"public void testPath() { test3(); File file = new File(getProjectDir(), tempFile); final long origSize = file.length(); executeTarget(\"testPath\"); File file2 = new File(getProjectDir(), tempFile2); final long newSize = file2.length();",
        "label":1
    },
    {
        "ins1AddCode":"if (block) { long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { } try { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) { do { if (getSocket().flush(true, selector, writeTimeout)) { break; } } while (true); } } finally { if (selector != null) { pool.put(selector); } } } else { if (getSocket().write(from) == -1) { throw new EOFException(); updateLastWrite();",
        "ins1DelCode":"long writeTimeout = getWriteTimeout(); Selector selector = null; try { selector = pool.get(); } catch (IOException x) { } try { pool.write(from, getSocket(), selector, writeTimeout, block); if (block) { do { if (getSocket().flush(true, selector, writeTimeout)) { break; } } while (true); } updateLastWrite(); } finally { if (selector != null) { pool.put(selector);",
        "ins1PreCode":"  ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"public void multipleErrors2() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE); ts.onError(new TestException());",
        "ins2PreCode":"public void multipleErrors3() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE); ts.onError(new TestException());",
        "label":1
    },
    {
        "ins1AddCode":"new ArrayList<>(data.subList(0, numExamples)));",
        "ins1DelCode":"new ArrayList<LabeledPoint>(data.subList(0, numExamples)));",
        "ins1PreCode":"List<LabeledPoint> data = generateRidgeData(2 * numExamples, numFeatures, 10.0);  JavaRDD<LabeledPoint> testRDD = jsc.parallelize( new ArrayList<LabeledPoint>(data.subList(0, numExamples))); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples); ",
        "ins2PreCode":"List<LabeledPoint> data = generateRidgeData(2 * numExamples, numFeatures, 10.0); JavaRDD<LabeledPoint> testRDD = jsc.parallelize( new ArrayList<LabeledPoint>(data.subList(0, numExamples))); List<LabeledPoint> validationData = data.subList(numExamples, 2 * numExamples);",
        "label":1
    },
    {
        "ins1AddCode":"checkArgument( graphMap.containsKey(node) || graphMap.containsValue(node), \"Node %s is not an element of this graph\", node);",
        "ins1DelCode":"",
        "ins1PreCode":"@Override public Iterable<? extends Character> successors(Character node) { return Ordering.natural().immutableSortedCopy(graphMap.get(node)); } };",
        "ins2PreCode":"@Override public Iterable<? extends Character> successors(Character node) { return Ordering.natural().immutableSortedCopy(graphMap.get(node)); } };",
        "label":1
    },
    {
        "ins1AddCode":"void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() {",
        "ins1DelCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() {",
        "ins1PreCode":"public void shouldPickSameTypeHandlerMappedToDifferentJdbcTypes() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, JdbcType.BIGINT, ProductIdTypeHandler.class); addMapper();",
        "ins2PreCode":"public void shouldPickHandlerForNull() { sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(ProductId.class, null, ConstantProductIdTypeHandler.class); addMapper();",
        "label":1
    },
    {
        "ins1AddCode":"expectedCrossingResult2.addEntry(database.getEntryByCitationKey(EINSTEIN).get()); expectedCrossingResult2.addEntry(database.getEntryByCitationKey(DARWIN).get());",
        "ins1DelCode":"expectedCrossingResult2.addEntry(database.getEntryByKey(EINSTEIN).get()); expectedCrossingResult2.addEntry(database.getEntryByKey(DARWIN).get());",
        "ins1PreCode":"LatexBibEntriesResolverResult crossingResult2 = new TexBibEntriesResolver(database2, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult2 = new LatexBibEntriesResolverResult(expectedParserResult);  expectedCrossingResult2.addEntry(database.getEntryByKey(EINSTEIN).get()); expectedCrossingResult2.addEntry(database.getEntryByKey(DARWIN).get());  assertEquals(expectedCrossingResult2, crossingResult2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void shouldTrimWHEREInsteadOfANDForFirstCondition() throws Exception {",
        "ins1DelCode":"public void shouldTrimWHEREInsteadOfANDForFirstCondition() throws Exception {",
        "ins1PreCode":"public void shouldTrimWHEREInsteadOfANDForFirstCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  ID = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "ins2PreCode":"public void shouldTrimWHEREInsteadOfORForSecondCondition() throws Exception { final String expected = \"SELECT * FROM BLOG WHERE  NAME = ?\"; DynamicSqlSource source = createDynamicSqlSource(",
        "label":1
    },
    {
        "ins1AddCode":"pluginDescriptor = pluginManager.getPluginDescriptor( plugin, session.getCurrentProject().getRemotePluginRepositories(), session.getRepositorySession() );",
        "ins1DelCode":"RepositoryRequest repositoryRequest = DefaultRepositoryRequest.getRepositoryRequest( session, session.getCurrentProject() ); pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest );",
        "ins1PreCode":"PluginDescriptor pluginDescriptor; try { RepositoryRequest repositoryRequest = DefaultRepositoryRequest.getRepositoryRequest( session, session.getCurrentProject() );  pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest );  pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );",
        "ins2PreCode":"PluginDescriptor pluginDescriptor; try { RepositoryRequest repositoryRequest = DefaultRepositoryRequest.getRepositoryRequest( session, session.getCurrentProject() ); pluginDescriptor = pluginManager.getPluginDescriptor( plugin, repositoryRequest ); pluginManager.setupPluginRealm( pluginDescriptor, session, null, null, null );",
        "label":1
    },
    {
        "ins1AddCode":"Object key = getPluginExecutionKey().apply( element ); Object key = getPluginExecutionKey().apply( element );",
        "ins1DelCode":"Object key = getPluginExecutionKey( element ); Object key = getPluginExecutionKey( element );",
        "ins1PreCode":" for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); }  for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null )",
        "ins2PreCode":"for ( PluginExecution element : tgt ) { Object key = getPluginExecutionKey( element ); merged.put( key, element ); } for ( PluginExecution element : src ) { Object key = getPluginExecutionKey( element ); PluginExecution existing = merged.get( key ); if ( existing != null )",
        "label":1
    },
    {
        "ins1AddCode":"TaglibXml xml = parse(\"test/tld/tags21.tld\");",
        "ins1DelCode":"TaglibXml xml = parse(\"test/webapp-3.1/WEB-INF/tags21.tld\");",
        "ins1PreCode":"public void testParseTld21() throws Exception { TaglibXml xml = parse(\"test/webapp-3.1/WEB-INF/tags21.tld\"); Assert.assertEquals(\"1.0\", xml.getTlibVersion()); Assert.assertEquals(\"2.1\", xml.getJspVersion());",
        "ins2PreCode":"public void testParseTld11() throws Exception { TaglibXml xml = parse(\"test/webapp-3.1/WEB-INF/tags11.tld\"); Assert.assertEquals(\"1.0\", xml.getTlibVersion()); Assert.assertEquals(\"1.1\", xml.getJspVersion());",
        "label":1
    },
    {
        "ins1AddCode":"Map<String,List<String>> headers = new HashMap<>();",
        "ins1DelCode":"Map<String,List<String>> headers = new HashMap<String,List<String>>();",
        "ins1PreCode":"tomcat.start();  ByteChunk res = new ByteChunk(); Map<String,List<String>> headers = new HashMap<String,List<String>>();  getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49726a.jsp\",",
        "ins2PreCode":"tomcat.start(); ByteChunk res = new ByteChunk(); Map<String,List<String>> headers = new HashMap<String,List<String>>(); getUrl(\"http://localhost:\" + getPort() + \"/test/bug49nnn/bug49726b.jsp\",",
        "label":1
    },
    {
        "ins1AddCode":"protected void addObjectCreateActions(DBRProgressMonitor monitor, List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options) { String sql = buildStatement(command.getObject(), false);",
        "ins2PreCode":"protected void addObjectCreateActions(List<DBEPersistAction> actions, ObjectCreateCommand command, Map<String, Object> options) { String sql = buildStatement(command.getObject(), false);",
        "label":1
    },
    {
        "ins1AddCode":"Calendar cal = Calendar.getInstance(zone); Month m1 = new Month(new Date(951821999999L), zone, Locale.getDefault()); Month m2 = new Month(new Date(951822000000L), zone, Locale.getDefault()); assertEquals(951821999999L, m1.getLastMillisecond(cal)); assertEquals(951822000000L, m2.getFirstMillisecond(cal));",
        "ins1DelCode":"Month m1 = new Month(new Date(951821999999L), zone); Month m2 = new Month(new Date(951822000000L), zone); assertEquals(951821999999L, m1.getLastMillisecond(zone)); assertEquals(951822000000L, m2.getFirstMillisecond(zone));",
        "ins1PreCode":"public void testDateConstructor2() {  TimeZone zone = TimeZone.getTimeZone(\"Pacific/Auckland\"); Month m1 = new Month(new Date(951821999999L), zone); Month m2 = new Month(new Date(951822000000L), zone);  assertEquals(MonthConstants.FEBRUARY, m1.getMonth()); assertEquals(951821999999L, m1.getLastMillisecond(zone));  assertEquals(MonthConstants.MARCH, m2.getMonth()); assertEquals(951822000000L, m2.getFirstMillisecond(zone)); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"}, true, 2, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1DelCode":"}, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);",
        "ins1PreCode":"public Flowable<Integer> apply(Integer v) { return inner; } }, 2, true, ImmediateThinScheduler.INSTANCE).subscribe(ts);  ts.assertValues(1, 2, 1, 2, 1, 2);",
        "ins2PreCode":"public Flowable<Integer> apply(Integer v) { return inner; } }).subscribe(ts); ts.assertValues(1, 2, 1, 2, 1, 2);",
        "label":0
    },
    {
        "ins1AddCode":"given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) given(this.tokenValidator.validate(any())).willReturn(Mono.empty()); .consumeNextWith((response) -> { assertThat((AccessLevel) exchange .getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.FULL);",
        "ins1DelCode":"BDDMockito.given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) BDDMockito.given(this.tokenValidator.validate(any())) .willReturn(Mono.empty()); .consumeNextWith(response -> { assertThat((AccessLevel) exchange.getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.FULL);",
        "ins1PreCode":"public void preHandleSuccessfulWithFullAccess() throws Exception { String accessToken = mockAccessToken(); BDDMockito.given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) .willReturn(Mono.just(AccessLevel.FULL)); BDDMockito.given(this.tokenValidator.validate(any())) .willReturn(Mono.empty()); MockServerWebExchange exchange = MockServerWebExchange .from(MockServerHttpRequest.get(\"/a\") .header(HttpHeaders.AUTHORIZATION, \"bearer \" + mockAccessToken()) .build()); StepVerifier.create(this.interceptor.preHandle(exchange, \"/a\")) .consumeNextWith(response -> { assertThat(response.getStatus()).isEqualTo(HttpStatus.OK); assertThat((AccessLevel) exchange.getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.FULL); }).verifyComplete();",
        "ins2PreCode":"public void preHandleSuccessfulWithRestrictedAccess() throws Exception { String accessToken = mockAccessToken(); BDDMockito.given(this.securityService.getAccessLevel(accessToken, \"my-app-id\")) .willReturn(Mono.just(AccessLevel.RESTRICTED)); BDDMockito.given(this.tokenValidator.validate(any())) .willReturn(Mono.empty()); MockServerWebExchange exchange = MockServerWebExchange .from(MockServerHttpRequest.get(\"/info\") .header(HttpHeaders.AUTHORIZATION, \"bearer \" + mockAccessToken()) .build()); StepVerifier.create(this.interceptor.preHandle(exchange, \"info\")) .consumeNextWith(response -> { assertThat(response.getStatus()).isEqualTo(HttpStatus.OK); assertThat((AccessLevel) exchange.getAttribute(\"cloudFoundryAccessLevel\")) .isEqualTo(AccessLevel.RESTRICTED); }).verifyComplete();",
        "label":1
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/wo-plugin-mgmt/sub\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/wo-plugin-mngt/sub\" );",
        "ins1PreCode":"public void testOrderOfMergedPluginExecutionsWithoutPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/wo-plugin-mngt/sub\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() ); assertEquals( \"parent-1\", pom.getValue( \"build/plugins[1]/executions[1]/goals[1]\" ) );",
        "ins2PreCode":"public void testOrderOfMergedPluginExecutionsWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"merged-plugin-exec-order/w-plugin-mngt/sub\" ); assertEquals( 5, ( (List<?>) pom.getValue( \"build/plugins[1]/executions\" ) ).size() ); assertEquals( \"parent-1\", pom.getValue( \"build/plugins[1]/executions[1]/goals[1]\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"GeoIpProcessor processor = factory.create(null, null, null, config);",
        "ins1DelCode":"GeoIpProcessor processor = factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"properties\", fieldNames); GeoIpProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\")); assertThat(processor.getProperties(), equalTo(properties));",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"_field\"); config.put(\"properties\", fieldNames); UserAgentProcessor processor = factory.create(null, null, config); assertThat(processor.getField(), equalTo(\"_field\")); assertThat(processor.getProperties(), equalTo(properties));",
        "label":1
    },
    {
        "ins1AddCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext, int capacityHint) { Iterator<T> it = blockingIterable(capacityHint).iterator();",
        "ins1DelCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator();",
        "ins1PreCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator(); while (it.hasNext()) { try {",
        "ins2PreCode":"public final void blockingForEach(@NonNull Consumer<? super T> onNext) { Iterator<T> it = blockingIterable().iterator(); while (it.hasNext()) { try {",
        "label":0
    },
    {
        "ins1AddCode":"TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(EnumSet.of(SearchRules.SearchFlags.CASE_SENSITIVE, SearchRules.SearchFlags.REGULAR_EXPRESSION), query).getDescription();",
        "ins1DelCode":"TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();",
        "ins1PreCode":"TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, true, query).getDescription();  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case sensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(true, false, query).getDescription(); TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "label":0
    },
    {
        "ins1AddCode":"value instanceof Double",
        "ins1DelCode":"value instanceof Double  || value instanceof BigInteger",
        "ins1PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double  || value instanceof BigInteger ) { return ((Number)value).doubleValue();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\", \"vcap.application.cf_api:http://my-cloud-controller.com\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(context); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\")); });",
        "ins1DelCode":"setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\"); assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); CorsConfiguration corsConfiguration = (CorsConfiguration) ReflectionTestUtils .getField(handlerMapping, \"corsConfiguration\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); assertThat(corsConfiguration.getAllowedMethods()).containsAll( Arrays.asList(HttpMethod.GET.name(), HttpMethod.POST.name())); assertThat(corsConfiguration.getAllowedHeaders()).containsAll( Arrays.asList(\"Authorization\", \"X-Cf-App-Instance\", \"Content-Type\"));",
        "ins1PreCode":"public void cloudFoundryPlatformActive() { setupContextWithCloudEnabled(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\");",
        "ins2PreCode":"public void cloudFoundryPlatformActive() { assertThat(endpointMapping.getPath()).isEqualTo(\"/cloudfoundryapplication\"); assertThat(corsConfiguration.getAllowedOrigins()).contains(\"*\"); CloudFoundryWebEndpointServletHandlerMapping handlerMapping = getHandlerMapping(); EndpointMapping endpointMapping = (EndpointMapping) ReflectionTestUtils .getField(handlerMapping, \"endpointMapping\");",
        "label":0
    },
    {
        "ins1AddCode":"final TestSubscriber<Integer> ts1 = new TestSubscriber<>();",
        "ins1DelCode":"final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay();  final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>();  cf.connect();",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final ConnectableFlowable<Integer> cf = Flowable.range(1, 1000).replay(); final TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(); cf.connect();",
        "label":1
    },
    {
        "ins1AddCode":"new TreeMap<>(); list = new ArrayList<>();",
        "ins1DelCode":"new TreeMap<Integer,ArrayList<ByteEntry>>(); list = new ArrayList<ByteEntry>();",
        "ins1PreCode":"long t1 = System.currentTimeMillis();  TreeMap<Integer,ArrayList<ByteEntry>> tempMap = new TreeMap<Integer,ArrayList<ByteEntry>>(); for (Entry<ByteEntry,int[]> item : bcStats.entrySet()) { ByteEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]);  ArrayList<ByteEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<ByteEntry>(); tempMap.put(count, list); }",
        "ins2PreCode":"long t1 = System.currentTimeMillis(); TreeMap<Integer,ArrayList<CharEntry>> tempMap = new TreeMap<Integer,ArrayList<CharEntry>>(); for (Entry<CharEntry,int[]> item : ccStats.entrySet()) { CharEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]); ArrayList<CharEntry> list = tempMap.get(count); if (list == null) { list = new ArrayList<CharEntry>(); tempMap.put(count, list); }",
        "label":0
    },
    {
        "ins1AddCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), null, \"source_field\",",
        "ins1DelCode":"GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\",",
        "ins1PreCode":"public void testNullWithoutIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false, new GeoIpCache(1000), false);",
        "ins2PreCode":"public void testNonExistentWithoutIgnoreMissing() throws Exception { GeoIpProcessor processor = new GeoIpProcessor(randomAlphaOfLength(10), \"source_field\", loader(\"/GeoLite2-City.mmdb\"), \"target_field\", EnumSet.allOf(GeoIpProcessor.Property.class), false, new GeoIpCache(1000), false);",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSucceeded); ds.setIncludes(new String[] {\"alpha/beta/gamma/gamma.xml\", \"alpha/beta/gamma/GAMMA.XML\"}); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {});",
        "ins1DelCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded); ds.setIncludes(new String[] { \"alpha/beta/gamma/gamma.xml\", \"alpha/beta/gamma/GAMMA.XML\" }); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {});",
        "ins1PreCode":"public void testFullpathDiffersInCaseScanningSensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/beta/gamma/gamma.xml\", \"alpha/beta/gamma/GAMMA.XML\" }); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {});",
        "ins2PreCode":"public void testFullpathDiffersInCaseScanningInsensitive() { Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] { \"alpha/beta/gamma/gamma.xml\", \"alpha/beta/gamma/GAMMA.XML\" }); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/gamma/gamma.xml\"}, new String[] {});",
        "label":1
    },
    {
        "ins1AddCode":"Collection<Marker> markers; markers = this.foregroundRangeMarkers.get(index); markers = this.backgroundRangeMarkers.get(index);",
        "ins1DelCode":"ArrayList<Marker> markers; markers = (ArrayList<Marker>) this.foregroundRangeMarkers.get(index); markers = (ArrayList<Marker>) this.backgroundRangeMarkers.get(index);",
        "ins1PreCode":"public boolean removeRangeMarker(int index, Marker marker, Layer layer, boolean notify) { Args.nullNotPermitted(marker, \"marker\"); ArrayList<Marker> markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList<Marker>) this.foregroundRangeMarkers.get(index); } else { markers = (ArrayList<Marker>) this.backgroundRangeMarkers.get(index); } if (markers == null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"throw new ClassCastException(\"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + float.class.getCanonicalName());",
        "ins1DelCode":"throw new ClassCastException( \"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to float\");",
        "ins1PreCode":"} else if (value instanceof Float) { return (float)value; } else { throw new ClassCastException( \"cannot implicitly cast \" + \"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to float\"); }",
        "ins2PreCode":"} else if (value instanceof Float) { return (float)value; } else { throw new ClassCastException(\"cannot implicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); throw new ClassCastException(\"cannot implicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); throw new ClassCastException(\"cannot implicitly cast def [\" + value.getClass().getCanonicalName() + \"] to double\"); }",
        "label":0
    },
    {
        "ins1AddCode":"void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1DelCode":"public void stopsMeterRegistryWhenContextIsClosed() {",
        "ins1PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class).run((context) -> { InfluxMeterRegistry registry = context.getBean(InfluxMeterRegistry.class);",
        "ins2PreCode":"public void stopsMeterRegistryWhenContextIsClosed() { this.contextRunner.withUserConfiguration(BaseConfiguration.class) DatadogMeterRegistry registry = context.getBean(DatadogMeterRegistry.class);",
        "label":1
    },
    {
        "ins1AddCode":"void parsePreservesTabsInAbstractField() throws IOException {",
        "ins1DelCode":"public void parsePreservesTabsInAbstractField() throws IOException {",
        "ins1PreCode":"public void parsePreservesTabsInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups  \\tsala}}\")); ",
        "ins2PreCode":"public void parsePreservesNewlineInAbstractField() throws IOException { ParserResult result = parser.parse(new StringReader(\"@article{canh05,abstract = {ups \\nsala}}\"));",
        "label":1
    },
    {
        "ins1AddCode":"Number[][] data = new Integer[][] {{-30, -20}, {-10, 10}, {20, 30}};",
        "ins1DelCode":"Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};",
        "ins1PreCode":"public void testReplaceDataset() {   Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "ins2PreCode":"public void testReplaceDataset() { Number[][] data = new Integer[][] {{new Integer(-30), new Integer(-20)}, {new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "label":1
    },
    {
        "ins1AddCode":"for (ManagedChannel channel : channels) { channel.start(Channel.SND_RX_SEQ | Channel.SND_TX_SEQ);",
        "ins1DelCode":"for (int i = 0; i < channels.length; i++) { channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ);",
        "ins1PreCode":"} TesterUtil.addRandomDomain(channels); for (int i = 0; i < channels.length; i++) { channels[i].start(Channel.SND_RX_SEQ|Channel.SND_TX_SEQ); }",
        "ins2PreCode":"} filter.setDomain(UUIDGenerator.randomUUID(false)); for (int i = 0; i < channels.length; i++) { channels[i] = new GroupChannel(); }",
        "label":0
    },
    {
        "ins1AddCode":"public static <@NonNull T> Observable<T> concat(",
        "ins1DelCode":"public static <T> Observable<T> concat(",
        "ins1PreCode":"public static <T> Observable<T> concat( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4) {",
        "ins2PreCode":"public static <T> Observable<T> merge( @NonNull ObservableSource<? extends T> source1, @NonNull ObservableSource<? extends T> source2, @NonNull ObservableSource<? extends T> source3, @NonNull ObservableSource<? extends T> source4) {",
        "label":1
    },
    {
        "ins1AddCode":"new LinkedFile(\"\", Path.of(\"paper.pdf\"), \"PDF\"), new LinkedFile(\"\", pathPdf.toAbsolutePath(), \"PDF\"))",
        "ins1DelCode":"new LinkedFile(\"\", \"paper.pdf\", \"PDF\"), new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\"))",
        "ins1PreCode":"String bibString = Resources.toString(XmpUtilShared.class.getResource(\"article_dublinCore.bib\"), StandardCharsets.UTF_8); Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString); entryFromBibFile.get().setFiles(Arrays.asList( new LinkedFile(\"\", \"paper.pdf\", \"PDF\"), new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\")) ); ",
        "ins2PreCode":"String bibString = Resources.toString(XmpUtilShared.class.getResource(\"PD_metadata.bib\"), StandardCharsets.UTF_8); Optional<BibEntry> entryFromBibFile = parser.parseSingleEntry(bibString); entryFromBibFile.get().setFiles(Collections.singletonList( new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\")) new LinkedFile(\"\", pathPdf.toAbsolutePath().toString(), \"PDF\")) );",
        "label":0
    },
    {
        "ins1AddCode":"public static <@NonNull T> Flowable<T> ambArray(@NonNull Publisher<? extends T>... sources) {",
        "ins1DelCode":"public static <T> Flowable<T> ambArray(@NonNull Publisher<@NonNull ? extends T>... sources) {",
        "ins1PreCode":"public static <T> Flowable<T> ambArray(@NonNull Publisher<@NonNull ? extends T>... sources) { Objects.requireNonNull(sources, \"sources is null\"); int len = sources.length;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"postWelcomeFiles();",
        "ins1PreCode":"}   postWelcomeFiles(); if(this.getState().equals(LifecycleState.STARTED)) fireContainerEvent(REMOVE_WELCOME_FILE_EVENT, name);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public static DynamicMBean createMBean(ContextEnvironment environment)",
        "ins1DelCode":"static DynamicMBean createMBean(ContextEnvironment environment)",
        "ins1PreCode":"static DynamicMBean createMBean(ContextEnvironment environment) throws Exception { ",
        "ins2PreCode":"static DynamicMBean createMBean(Group group) throws Exception {",
        "label":0
    },
    {
        "ins1AddCode":"final List<Integer> list = new ArrayList<>(); final List<List<Integer>> lists = new ArrayList<>();",
        "ins1DelCode":"final List<Integer> list = new ArrayList<Integer>(); final List<List<Integer>> lists = new ArrayList<List<Integer>>();",
        "ins1PreCode":"Flowable<Flowable<Integer>> source = Flowable.range(1, 10) .window(1, TimeUnit.MINUTES, scheduler, 3);  final List<Integer> list = new ArrayList<Integer>(); final List<List<Integer>> lists = new ArrayList<List<Integer>>();  source.subscribe(observeWindow(list, lists));",
        "ins2PreCode":"Observable<Observable<Integer>> source = Observable.range(1, 10) .window(1, TimeUnit.MINUTES, scheduler, 3); final List<Integer> list = new ArrayList<Integer>(); final List<List<Integer>> lists = new ArrayList<List<Integer>>(); source.subscribe(observeWindow(list, lists));",
        "label":1
    },
    {
        "ins1AddCode":"List<Person> personList = new ArrayList<>(2); @Override List<StructField> fields = new ArrayList<>(2);",
        "ins1DelCode":"List<Person> personList = new ArrayList<Person>(2); List<StructField> fields = new ArrayList<StructField>(2);",
        "ins1PreCode":"public void applySchema() { List<Person> personList = new ArrayList<Person>(2); Person person1 = new Person(); person1.setName(\"Michael\"); person1.setAge(29); personList.add(person1); Person person2 = new Person(); person2.setName(\"Yin\"); person2.setAge(28); personList.add(person2);  JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } });  List<StructField> fields = new ArrayList<StructField>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false));",
        "ins2PreCode":"public void dataFrameRDDOperations() { List<Person> personList = new ArrayList<Person>(2); Person person1 = new Person(); person1.setName(\"Michael\"); person1.setAge(29); personList.add(person1); Person person2 = new Person(); person2.setName(\"Yin\"); person2.setAge(28); personList.add(person2); JavaRDD<Row> rowRDD = javaCtx.parallelize(personList).map( new Function<Person, Row>() { public Row call(Person person) throws Exception { return RowFactory.create(person.getName(), person.getAge()); } }); List<StructField> fields = new ArrayList<StructField>(2); fields.add(DataTypes.createStructField(\"name\", DataTypes.StringType, false)); fields.add(DataTypes.createStructField(\"age\", DataTypes.IntegerType, false));",
        "label":0
    },
    {
        "ins1AddCode":"BibEntry localEntry = new BibEntry(StandardEntryType.Article); localEntry.setField(StandardField.YEAR, \"2017\");",
        "ins1DelCode":"BibEntry localEntry = new BibEntry(BibtexEntryTypes.ARTICLE); localEntry.setField(\"year\", \"2017\");",
        "ins1PreCode":"public void testFindFileInSubdirectory() throws Exception {  BibEntry localEntry = new BibEntry(BibtexEntryTypes.ARTICLE); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(\"year\", \"2017\");  List<String> extensions = Collections.singletonList(\"pdf\");",
        "ins2PreCode":"public void testFindFileNonRecursive() throws Exception { BibEntry localEntry = new BibEntry(BibtexEntryTypes.ARTICLE); localEntry.setCiteKey(\"pdfInSubdirectory\"); localEntry.setField(\"year\", \"2017\"); List<String> extensions = Collections.singletonList(\"pdf\");",
        "label":1
    },
    {
        "ins1AddCode":"mirror.setBlocked( repo.isBlocked() );",
        "ins1DelCode":"",
        "ins1PreCode":"mirror.setId( repo.getId() ); mirror.setUrl( repo.getUrl() ); mirror.setLayout( repo.getContentType() ); return mirror; } }",
        "ins2PreCode":"mirror.setId( repo.getId() ); mirror.setUrl( repo.getUrl() ); mirror.setLayout( repo.getContentType() ); return mirror; } }",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void merge1000AsyncStreamOf1000() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(1000, 1000).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void merge2000AsyncStreamOf100() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); mergeNAsyncStreamsOfN(2000, 100).subscribe(ts); ts.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"void shouldAssignMultipleGeneratedKeysToBeans() {",
        "ins1DelCode":"public void shouldAssignMultipleGeneratedKeysToBeans() throws Exception {",
        "ins1PreCode":"public void shouldAssignMultipleGeneratedKeysToBeans() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try {",
        "ins2PreCode":"public void shouldAssignMultipleGeneratedKeysToBeans_MultiParams() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try {",
        "label":0
    },
    {
        "ins1AddCode":"int users = 50; int products = 100; scala.Tuple3<List<Rating>, DoubleMatrix, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7, false); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins1DelCode":"int users = 10; int products = 10; scala.Tuple2<List<Rating>, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7); validatePrediction(model, users, products, features, testData._2(), 0.3);",
        "ins1PreCode":"public void runALSUsingStaticMethods() { int features = 1; int iterations = 15; int users = 10; int products = 10; scala.Tuple2<List<Rating>, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7);  JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.train(data.rdd(), features, iterations); validatePrediction(model, users, products, features, testData._2(), 0.3);",
        "ins2PreCode":"public void runALSUsingConstructor() { int features = 2; int iterations = 15; int users = 20; int products = 30; scala.Tuple2<List<Rating>, DoubleMatrix> testData = ALSSuite.generateRatingsAsJavaList( users, products, features, 0.7); JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features) validatePrediction(model, users, products, features, testData._2(), 0.3);",
        "label":0
    },
    {
        "ins1AddCode":"return false;",
        "ins1DelCode":"return false; return w == index;",
        "ins1PreCode":"} return false; } return w == index;",
        "ins2PreCode":"} return false; } return true;",
        "label":0
    },
    {
        "ins1AddCode":"return new ArrayList<>(); TestSubscriber<List<Integer>> ts = new TestSubscriber<>();",
        "ins1DelCode":"return new ArrayList<Integer>(); TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();",
        "ins1PreCode":"Supplier<List<Integer>> as = new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>();  Flowable.range(1, 100000)",
        "ins2PreCode":"Supplier<List<Integer>> as = new Supplier<List<Integer>>() { @Override public List<Integer> get() throws Exception { return new ArrayList<Integer>(); } }; TestSubscriber<List<Integer>> ts = new TestSubscriber<List<Integer>>(); .take(1000)",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"Observable<String> source = Observable.unsafeCreate(new ObservableSource<String>() { @Override public void subscribe(Observer<? super String> observer) { observer.onSubscribe(Disposables.empty()); push(observer, \"one\", 98); push(observer, \"two\", 99);",
        "ins2PreCode":"Flowable<String> source = Flowable.unsafeCreate(new Publisher<String>() { @Override public void subscribe(Subscriber<? super String> subscriber) { subscriber.onSubscribe(new BooleanSubscription()); push(subscriber, \"one\", 98); push(subscriber, \"two\", 99);",
        "label":0
    },
    {
        "ins1AddCode":"if (!args.getNonOptionArgs().isEmpty()) {",
        "ins1DelCode":"if (args.getNonOptionArgs().size() > 0) {",
        "ins1PreCode":"public void run(ApplicationArguments args) throws Exception { this.serviceProperties.getInputDir().mkdirs(); if (args.getNonOptionArgs().size() > 0) { FileOutputStream stream = new FileOutputStream( new File(this.serviceProperties.getInputDir(), \"data\" + System.currentTimeMillis() + \".txt\"));",
        "ins2PreCode":"public void run(ApplicationArguments args) throws Exception { this.serviceProperties.getInputDir().mkdirs(); if (args.getNonOptionArgs().size() > 0) { FileOutputStream stream = new FileOutputStream( new File(this.serviceProperties.getInputDir(), \"data\" + System.currentTimeMillis() + \".txt\"));",
        "label":1
    },
    {
        "ins1AddCode":"final Jenkins jenkins = Jenkins.get(); final HashSet<String> hs = new HashSet<>(nodes);",
        "ins1DelCode":"final Jenkins jenkins = Jenkins.getInstance(); final HashSet<String> hs = new HashSet<String>(nodes);",
        "ins1PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.getInstance(); final HashSet<String> hs = new HashSet<String>(nodes); List<String> names = null; ",
        "ins2PreCode":"protected int run() throws Exception { boolean errorOccurred = false; final Jenkins jenkins = Jenkins.getActiveInstance(); final HashSet<String> hs = new HashSet<String>(); List<String> names = null;",
        "label":0
    },
    {
        "ins1AddCode":"TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(EnumSet.noneOf(SearchFlags.class), query).getDescription();",
        "ins1DelCode":"TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, false, query).getDescription();",
        "ins1PreCode":"TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, false, query).getDescription();  TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "ins2PreCode":"TooltipTextUtil.createText(\" and \"), TooltipTextUtil.createText(\"b\", TooltipTextUtil.TextType.BOLD), TooltipTextUtil.createText(\" (case insensitive). \")); TextFlow description = new ContainsAndRegexBasedSearchRuleDescriber(false, true, query).getDescription(); TextFlowEqualityHelper.assertEquals(expectedTexts, description);",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(loc.append(",
        "ins1DelCode":"Assert.assertTrue(loc.putNewKey(",
        "ins1PreCode":"key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, Platform.BYTE_ARRAY_OFFSET,",
        "ins2PreCode":"key.length ); Assert.assertFalse(loc.isDefined()); Assert.assertTrue(loc.putNewKey( key, Platform.BYTE_ARRAY_OFFSET,",
        "label":1
    },
    {
        "ins1AddCode":"Objects.requireNonNull(source1, \"source1 is null\"); Objects.requireNonNull(source2, \"source2 is null\"); Objects.requireNonNull(source3, \"source3 is null\"); Objects.requireNonNull(source4, \"source4 is null\");",
        "ins1DelCode":"ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\");",
        "ins1PreCode":"public static <T> Observable<T> merge( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), false, 4);",
        "ins2PreCode":"public static <T> Observable<T> mergeDelayError( ObservableSource<? extends T> source1, ObservableSource<? extends T> source2, ObservableSource<? extends T> source3, ObservableSource<? extends T> source4) { ObjectHelper.requireNonNull(source1, \"source1 is null\"); ObjectHelper.requireNonNull(source2, \"source2 is null\"); ObjectHelper.requireNonNull(source3, \"source3 is null\"); ObjectHelper.requireNonNull(source4, \"source4 is null\"); return fromArray(source1, source2, source3, source4).flatMap((Function)Functions.identity(), true, 4);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>();",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();",
        "ins1PreCode":"} };  TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>();  Completable.using(new Supplier<Integer>() {",
        "ins2PreCode":"} }; TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); Completable.using(new Supplier<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset newData = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}};  CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); ",
        "ins2PreCode":"{new Integer(-10), new Integer(10)}, {new Integer(20), new Integer(30)}}; CategoryDataset newData = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data);",
        "label":1
    },
    {
        "ins1AddCode":"Collections.emptyMap(),",
        "ins1DelCode":"",
        "ins1PreCode":"public void testNoNullGuardAdd() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, new FunctionTable(), MethodHandles.publicLookup(), \"add\", MethodType.methodType(Object.class, int.class, Object.class),",
        "ins2PreCode":"public void testNoNullGuardAddWhenCached() throws Throwable { DefBootstrap.MIC site = (DefBootstrap.MIC) DefBootstrap.bootstrap(painlessLookup, new FunctionTable(), MethodHandles.publicLookup(), \"add\", MethodType.methodType(Object.class, int.class, Object.class),",
        "label":1
    },
    {
        "ins1AddCode":"String metricName = this.properties.getWeb().getServer().getRequest() .getMetricName();",
        "ins1DelCode":"String metricName = this.properties.getWeb().getServer().getRequestsMetricName();",
        "ins1PreCode":"public MeterFilter metricsHttpServerUriTagFilter() { String metricName = this.properties.getWeb().getServer().getRequestsMetricName(); MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(() -> String .format(\"Reached the maximum number of URI tags for '%s'.\", metricName));",
        "ins2PreCode":"public MeterFilter metricsHttpServerUriTagFilter() { String metricName = this.properties.getWeb().getServer().getRequestsMetricName(); MeterFilter filter = new OnlyOnceLoggingDenyMeterFilter(() -> String .format(\"Reached the maximum number of URI tags for '%s'.\", metricName));",
        "label":1
    },
    {
        "ins1AddCode":"@SuppressWarnings(\"unchecked\") CategoryPlot<R, C> cp = (CategoryPlot) parent;",
        "ins1DelCode":"CategoryPlot cp = (CategoryPlot) parent;",
        "ins1PreCode":"if (result == null) { Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getDomainAxis(index); }",
        "ins2PreCode":"if (result == null) { Plot parent = getParent(); if (parent instanceof CategoryPlot) { CategoryPlot cp = (CategoryPlot) parent; result = cp.getRangeAxis(index); }",
        "label":1
    },
    {
        "ins1AddCode":"final Settings settings = createBuilderWithPort().put(key, maxContentLength + \"b\").build();",
        "ins1DelCode":"final Settings settings = Settings.builder().put(key, maxContentLength + \"b\").build();",
        "ins1PreCode":"public void testExpectContinueHeaderContentLengthTooLong() throws InterruptedException { final String key = HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey(); final int maxContentLength = randomIntBetween(1, 104857600); final Settings settings = Settings.builder().put(key, maxContentLength + \"b\").build(); final int contentLength = randomIntBetween(maxContentLength + 1, Integer.MAX_VALUE); runExpectHeaderTest(",
        "ins2PreCode":"public void testExpectContinueHeaderContentLengthTooLong() throws InterruptedException { final String key = HttpTransportSettings.SETTING_HTTP_MAX_CONTENT_LENGTH.getKey(); final int maxContentLength = randomIntBetween(1, 104857600); final Settings settings = Settings.builder().put(key, maxContentLength + \"b\").build(); final int contentLength = randomIntBetween(maxContentLength + 1, Integer.MAX_VALUE); runExpectHeaderTest(",
        "label":1
    },
    {
        "ins1AddCode":"public List<? extends Tick> refreshTicks(Graphics2D g2, AxisState state, List<? extends Tick> result = null;",
        "ins1DelCode":"public List refreshTicks(Graphics2D g2, AxisState state, List result = null;",
        "ins1PreCode":"public List refreshTicks(Graphics2D g2, AxisState state, Rectangle2D dataArea, RectangleEdge edge) {  List result = null; if (RectangleEdge.isTopOrBottom(edge)) { result = refreshTicksHorizontal(g2, dataArea, edge);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestObserver<Void> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Void> to = new TestObserver<Void>();",
        "ins1PreCode":"public void ambRace() { TestObserver<Void> to = new TestObserver<Void>(); to.onSubscribe(Disposable.empty()); ",
        "ins2PreCode":"public void ambRace() { TestObserver<Void> to = new TestObserver<Void>(); to.onSubscribe(Disposable.empty());",
        "label":1
    },
    {
        "ins1AddCode":"PomTestWrapper pom = buildPom( \"dependency-order/wo-plugin-mgmt\" );",
        "ins1DelCode":"PomTestWrapper pom = buildPom( \"dependency-order/wo-plugin-mngt\" );",
        "ins1PreCode":"public void testDependencyOrderWithoutPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"dependency-order/wo-plugin-mngt\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() ); assertEquals( \"a\", pom.getValue( \"dependencies[1]/artifactId\" ) );",
        "ins2PreCode":"public void testDependencyOrderWithPluginManagement() throws Exception { PomTestWrapper pom = buildPom( \"dependency-order/w-plugin-mngt\" ); assertEquals( 4, ( (List<?>) pom.getValue( \"dependencies\" ) ).size() ); assertEquals( \"a\", pom.getValue( \"dependencies[1]/artifactId\" ) );",
        "label":1
    },
    {
        "ins1AddCode":"} else if (CS_KEY.equals(params[i].getType())) { setCaseSensitive(Project.toBoolean(params[i].getValue()));",
        "ins1DelCode":"",
        "ins1PreCode":"regexps.addElement(regexp); } else if (NEGATE_KEY.equals(params[i].getType())) { setNegate(Project.toBoolean(params[i].getValue())); } } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Map<Integer, Collection<String>> expected = new HashMap<>();",
        "ins1DelCode":"Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>();",
        "ins1PreCode":" Observable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc).toObservable();  Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"a\", \"b\")); expected.put(2, Arrays.asList(\"cc\", \"dd\"));",
        "ins2PreCode":"Observable<Map<Integer, Collection<String>>> mapped = source.toMultimap(lengthFunc, duplicate).toObservable(); Map<Integer, Collection<String>> expected = new HashMap<Integer, Collection<String>>(); expected.put(1, Arrays.asList(\"aa\", \"bb\")); expected.put(2, Arrays.asList(\"cccc\", \"dddd\"));",
        "label":1
    },
    {
        "ins1AddCode":"if (!Objects.equals(this.subplots, that.subplots)) {",
        "ins1DelCode":"if (!ObjectUtils.equal(this.subplots, that.subplots)) {",
        "ins1PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false; }",
        "ins2PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtils.equal(this.subplots, that.subplots)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"ParserResult result = parser.parse( Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"ParserResult result = BibtexParser.parse( Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException {  ParserResult result = BibtexParser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor);  assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"public void parseRecognizesMonthFieldsWithFollowingComma() throws IOException { ParserResult result = parser .parse(new StringReader(\"@article{test,author={Ed von Test},month={8,}},\")); .parse(new StringReader(\"@article{test,author={Ed von Test},month={8,}},\")); BibEntry e = c.iterator().next(); ParserResult result = parser Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(3, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "label":0
    },
    {
        "ins1AddCode":"void usesUserProvidedWebFilterWhenReactiveContext() {",
        "ins1DelCode":"public void usesUserProvidedWebFilterWhenReactiveContext() {",
        "ins1PreCode":"public void usesUserProvidedWebFilterWhenReactiveContext() { new ReactiveWebApplicationContextRunner() .withConfiguration(AutoConfigurations.of(HttpTraceAutoConfiguration.class))",
        "ins2PreCode":"public void usesUserProvidedServletFilter() { assertThat(context).hasSingleBean(HttpTraceFilter.class); this.contextRunner.withUserConfiguration(HttpTraceRepositoryConfiguration.class)",
        "label":1
    },
    {
        "ins1AddCode":"setState(440); switch ( getInterpreter().adaptivePredict(_input,40,_ctx) ) { setState(426); setState(427); setState(432); setState(428); setState(429); setState(434); setState(435); setState(437); setState(438); setState(439);",
        "ins1DelCode":"setState(443); switch ( getInterpreter().adaptivePredict(_input,41,_ctx) ) { setState(429); setState(430); setState(435); setState(431); setState(432); setState(437); setState(438); setState(440); setState(441); setState(442);",
        "ins1PreCode":"enterRule(_localctx, 52, RULE_mapinitializer); int _la; try { setState(443); _errHandler.sync(this); switch ( getInterpreter().adaptivePredict(_input,41,_ctx) ) { case 1: enterOuterAlt(_localctx, 1); { setState(429); match(LBRACE); setState(430); maptoken(); setState(435); _errHandler.sync(this); _la = _input.LA(1); while (_la==COMMA) { { { setState(431); match(COMMA); setState(432); maptoken(); } } setState(437); _errHandler.sync(this); _la = _input.LA(1); } setState(438); match(RBRACE); } break; case 2: enterOuterAlt(_localctx, 2); { setState(440); match(LBRACE); setState(441); match(COLON); setState(442); match(RBRACE); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"JspCServletContext context = new JspCServletContext( null, appDir.toURI().toURL(), null, false, false);",
        "ins1DelCode":"JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null);",
        "ins1PreCode":"public void testWebapp_2_5() throws Exception { File appDir = new File(\"test/webapp-2.5\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(2, context.getEffectiveMajorVersion()); Assert.assertEquals(5, context.getEffectiveMinorVersion());",
        "ins2PreCode":"public void testWebapp_3_0() throws Exception { File appDir = new File(\"test/webapp-3.0\"); JspCServletContext context = new JspCServletContext(null, appDir.toURI().toURL(), null); Assert.assertEquals(3, context.getEffectiveMajorVersion()); Assert.assertEquals(0, context.getEffectiveMinorVersion());",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Throwable> capturedException = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Throwable> capturedException = new AtomicReference<Throwable>();",
        "ins1PreCode":"public void resumeNext() { TestFlowable f = new TestFlowable(\"one\"); Flowable<String> w = Flowable.unsafeCreate(f); final AtomicReference<Throwable> capturedException = new AtomicReference<Throwable>();  Flowable<String> flowable = w.onErrorReturn(new Function<Throwable, String>() {",
        "ins2PreCode":"public void resumeNext() { TestObservable f = new TestObservable(\"one\"); Observable<String> w = Observable.unsafeCreate(f); final AtomicReference<Throwable> capturedException = new AtomicReference<Throwable>(); Observable<String> observable = w.onErrorReturn(new Function<Throwable, String>() {",
        "label":1
    },
    {
        "ins1AddCode":"XYIntervalSeriesCollection<String> c1 = new XYIntervalSeriesCollection<>(); XYIntervalSeriesCollection<String> c2 = new XYIntervalSeriesCollection<>(); XYIntervalSeries<String> s1 = new XYIntervalSeries<>(\"Series\"); XYIntervalSeries<String> s2 = new XYIntervalSeries<>(\"Series\"); c1.addSeries(new XYIntervalSeries<>(\"Empty Series\")); c2.addSeries(new XYIntervalSeries<>(\"Empty Series\"));",
        "ins1DelCode":"XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeriesCollection c2 = new XYIntervalSeriesCollection(); XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); XYIntervalSeries s2 = new XYIntervalSeries(\"Series\"); c1.addSeries(new XYIntervalSeries(\"Empty Series\")); c2.addSeries(new XYIntervalSeries(\"Empty Series\"));",
        "ins1PreCode":"public void testEquals() { XYIntervalSeriesCollection c1 = new XYIntervalSeriesCollection(); XYIntervalSeriesCollection c2 = new XYIntervalSeriesCollection(); assertEquals(c1, c2);   XYIntervalSeries s1 = new XYIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); c1.addSeries(s1); assertFalse(c1.equals(c2)); XYIntervalSeries s2 = new XYIntervalSeries(\"Series\"); s2.add(1.0, 1.1, 1.2, 1.3, 1.4, 1.5); c2.addSeries(s2); assertTrue(c1.equals(c2));   c1.addSeries(new XYIntervalSeries(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new XYIntervalSeries(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "ins2PreCode":"public void testEquals() { YIntervalSeriesCollection c1 = new YIntervalSeriesCollection(); YIntervalSeriesCollection c2 = new YIntervalSeriesCollection(); assertEquals(c1, c2); YIntervalSeries s1 = new YIntervalSeries(\"Series\"); s1.add(1.0, 1.1, 1.2, 1.3); c1.addSeries(s1); assertFalse(c1.equals(c2)); YIntervalSeries s2 = new YIntervalSeries(\"Series\"); s2.add(1.0, 1.1, 1.2, 1.3); c2.addSeries(s2); assertTrue(c1.equals(c2)); c1.addSeries(new YIntervalSeries(\"Empty Series\")); assertFalse(c1.equals(c2)); c2.addSeries(new YIntervalSeries(\"Empty Series\")); assertTrue(c1.equals(c2));",
        "label":1
    },
    {
        "ins1AddCode":"tgt = new DeploymentRepository(); target.setRepository( tgt );",
        "ins1DelCode":"target.setRepository( tgt = new DeploymentRepository() );",
        "ins1PreCode":"DeploymentRepository tgt = target.getRepository(); if ( tgt == null ) { target.setRepository( tgt = new DeploymentRepository() ); mergeDeploymentRepository( tgt, src, sourceDominant, context ); }",
        "ins2PreCode":"DeploymentRepository tgt = target.getSnapshotRepository(); if ( tgt == null ) { target.setSnapshotRepository( tgt = new DeploymentRepository() ); mergeDeploymentRepository( tgt, src, sourceDominant, context ); }",
        "label":0
    },
    {
        "ins1AddCode":"entry2.setCitationKey(\"entry2\");",
        "ins1DelCode":"entry2.setCiteKey(\"entry2\");",
        "ins1PreCode":"BibEntry entry1 = new BibEntry(); BibEntry entry2 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); entry2.setCiteKey(\"entry2\"); database.insertEntry(entry2); database.insertEntry(entry1);",
        "ins2PreCode":"BibEntry entry1 = new BibEntry(); BibEntry entry2 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); entry2.setCiteKey(\"entry2\"); database.insertEntry(entry2); database.insertEntry(entry1);",
        "label":1
    },
    {
        "ins1AddCode":"JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair(in -> { List<Tuple2<Integer, String>> out = new LinkedList<>(); for (Character s : in._1().toCharArray()) { out.add(new Tuple2<>(in._2(), s.toString())); } return out.iterator(); });",
        "ins1DelCode":"JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair( new PairFlatMapFunction<Tuple2<String, Integer>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Tuple2<String, Integer> in) { List<Tuple2<Integer, String>> out = new LinkedList<>(); for (Character s : in._1().toCharArray()) { out.add(new Tuple2<>(in._2(), s.toString())); } return out.iterator(); } });",
        "ins1PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair( new PairFlatMapFunction<Tuple2<String, Integer>, Integer, String>() { @Override public Iterator<Tuple2<Integer, String>> call(Tuple2<String, Integer> in) { List<Tuple2<Integer, String>> out = new LinkedList<>(); for (Character s : in._1().toCharArray()) {",
        "ins2PreCode":"JavaDStream<Tuple2<String, Integer>> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaPairDStream<String, Integer> pairStream = JavaPairDStream.fromJavaDStream(stream); JavaPairDStream<Integer, String> flatMapped = pairStream.flatMapToPair(in -> { JavaDStream<Tuple2<String, Integer>> stream = Arrays.asList( List<Tuple2<Integer, String>> out = new LinkedList<>(); List<Tuple2<Integer, String>> out = new LinkedList<>(); for (Character s : in._1().toCharArray()) {",
        "label":0
    },
    {
        "ins1AddCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, DBCExecutionContext executionContext, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options)",
        "ins1DelCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options)",
        "ins1PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final VerticaProjectionColumn column = command.getObject();",
        "ins2PreCode":"protected void addObjectModifyActions(DBRProgressMonitor monitor, List<DBEPersistAction> actionList, ObjectChangeCommand command, Map<String, Object> options) { final GenericTableColumn column = command.getObject();",
        "label":0
    },
    {
        "ins1AddCode":"Jenkins.get().setAuthorizationStrategy(strategy); Jenkins.get().setSecurityRealm(j.createDummySecurityRealm()); Assert.assertEquals(\"no items\", 0, Jenkins.get().getItems().size());",
        "ins1DelCode":"Jenkins.getInstance().setAuthorizationStrategy(strategy); Jenkins.getInstance().setSecurityRealm(j.createDummySecurityRealm()); Assert.assertEquals(\"no items\", 0, Jenkins.getInstance().getItems().size());",
        "ins1PreCode":"public void testGetItemsWithoutAnonRead() throws Exception { FullControlOnceLoggedInAuthorizationStrategy strategy = new FullControlOnceLoggedInAuthorizationStrategy(); strategy.setAllowAnonymousRead(false); Jenkins.getInstance().setAuthorizationStrategy(strategy);  Jenkins.getInstance().setSecurityRealm(j.createDummySecurityRealm());  j.createFreeStyleProject(); ACL.impersonate(Jenkins.ANONYMOUS, new Runnable() { @Override public void run() { Assert.assertEquals(\"no items\", 0, Jenkins.getInstance().getItems().size()); } });",
        "ins2PreCode":"public void testGetItems() throws Exception { FullControlOnceLoggedInAuthorizationStrategy strategy = new FullControlOnceLoggedInAuthorizationStrategy(); strategy.setAllowAnonymousRead(true); Jenkins.getInstance().setAuthorizationStrategy(strategy); Jenkins.getInstance().setSecurityRealm(j.createDummySecurityRealm()); j.createFreeStyleProject(); ACL.impersonate(Jenkins.ANONYMOUS, new Runnable() { @Override public void run() { Assert.assertEquals(\"one item\", 1, Jenkins.getInstance().getItems().size()); } });",
        "label":1
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty(); to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"Disposable d = Disposables.empty(); to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void unorderedSlowPath() { TestObserver<Integer> to = new TestObserver<Integer>(); Disposable d = Disposables.empty(); QueueDrainObserver<Integer, Integer, Integer> qd = createUnordered(to, d); to.onSubscribe(Disposables.empty());  qd.enter();",
        "ins2PreCode":"public void orderedSlowPath() { TestObserver<Integer> to = new TestObserver<Integer>(); Disposable d = Disposables.empty(); QueueDrainObserver<Integer, Integer, Integer> qd = createOrdered(to, d); to.onSubscribe(Disposables.empty()); qd.enter();",
        "label":1
    },
    {
        "ins1AddCode":"throw new IllegalArgumentException(sm.getString(\"userMBean.invalidGroup\", groupname));",
        "ins1DelCode":"throw new IllegalArgumentException(\"Invalid group name '\" + groupname + \"'\");",
        "ins1PreCode":"} Group group = user.getUserDatabase().findGroup(groupname); if (group == null) { throw new IllegalArgumentException(\"Invalid group name '\" + groupname + \"'\"); } user.addGroup(group);",
        "ins2PreCode":"} Group group = user.getUserDatabase().findGroup(groupname); if (group == null) { throw new IllegalArgumentException(\"Invalid group name '\" + groupname + \"'\"); } user.removeGroup(group);",
        "label":1
    },
    {
        "ins1AddCode":"void responseIsNotCommittedWhenRequestIsAsync() throws Exception {",
        "ins1DelCode":"public void responseIsNotCommittedWhenRequestIsAsync() throws Exception {",
        "ins1PreCode":"public void responseIsNotCommittedWhenRequestIsAsync() throws Exception { this.request.setAsyncStarted(true); this.filter.doFilter(this.request, this.response, this.chain);",
        "ins2PreCode":"public void responseIsNotCommittedDuringAsyncDispatch() throws Exception { setUpAsyncDispatch(); this.filter.doFilter(this.request, this.response, this.chain);",
        "label":1
    },
    {
        "ins1AddCode":"XYDotRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"XYDotRenderer r2 = (XYDotRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYDotRenderer r1 = new XYDotRenderer(); XYDotRenderer r2 = (XYDotRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { CandlestickRenderer r1 = new CandlestickRenderer(); CandlestickRenderer r2 = (CandlestickRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"if (!Objects.equals(getToolTipText(), that.getToolTipText())) { if (!Objects.equals(getURLText(), that.getURLText())) {",
        "ins1DelCode":"if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { if (!ObjectUtils.equal(getURLText(), that.getURLText())) {",
        "ins1PreCode":"if (!getArea().equals(that.getArea())) { return false; } if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtils.equal(getURLText(), that.getURLText())) { return false; }",
        "ins2PreCode":"if (!getArea().equals(that.getArea())) { return false; } if (!ObjectUtils.equal(getToolTipText(), that.getToolTipText())) { return false; } if (!ObjectUtils.equal(getURLText(), that.getURLText())) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"GradientBoostedTreesModel model = GradientBoostedTrees.train(trainingData, boostingStrategy); testData.mapToPair(p -> new Tuple2<>(model.predict(p.features()), p.label())); double testErr = predictionAndLabel.filter(pl -> !pl._1().equals(pl._2())).count() / (double) testData.count();",
        "ins1DelCode":"final GradientBoostedTreesModel model = GradientBoostedTrees.train(trainingData, boostingStrategy); testData.mapToPair(new PairFunction<LabeledPoint, Double, Double>() { @Override public Tuple2<Double, Double> call(LabeledPoint p) { return new Tuple2<>(model.predict(p.features()), p.label()); } }); Double testErr = 1.0 * predictionAndLabel.filter(new Function<Tuple2<Double, Double>, Boolean>() { @Override public Boolean call(Tuple2<Double, Double> pl) { return !pl._1().equals(pl._2()); } }).count() / testData.count();",
        "ins1PreCode":"Map<Integer, Integer> categoricalFeaturesInfo = new HashMap<>(); boostingStrategy.treeStrategy().setCategoricalFeaturesInfo(categoricalFeaturesInfo);  final GradientBoostedTreesModel model = GradientBoostedTrees.train(trainingData, boostingStrategy);   JavaPairRDD<Double, Double> predictionAndLabel = testData.mapToPair(new PairFunction<LabeledPoint, Double, Double>() { @Override public Tuple2<Double, Double> call(LabeledPoint p) { return new Tuple2<>(model.predict(p.features()), p.label()); } }); Double testErr = 1.0 * predictionAndLabel.filter(new Function<Tuple2<Double, Double>, Boolean>() { @Override public Boolean call(Tuple2<Double, Double> pl) { return !pl._1().equals(pl._2()); } }).count() / testData.count(); System.out.println(\"Test Error: \" + testErr); System.out.println(\"Learned classification GBT model:\\n\" + model.toDebugString());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"private static final List<String> PROJECT_PREFIXES = Arrays.asList( \"pom.\", \"project.\" );",
        "ins1DelCode":"private static final List<String> PROJECT_PREFIXES = Arrays.asList( new String[]{ \"pom.\", \"project.\" } );",
        "ins1PreCode":"private static final List<String> PROJECT_PREFIXES = Arrays.asList( new String[]{ \"pom.\", \"project.\" } );  private static final Collection<String> TRANSLATED_PATH_EXPRESSIONS;",
        "ins2PreCode":"private static final List<String> PROJECT_PREFIXES = Arrays.asList( new String[]{ \"pom.\", \"project.\" } ); private static final List<String> TRANSLATED_PATH_EXPRESSIONS;",
        "label":1
    },
    {
        "ins1AddCode":"original = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1DelCode":"original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101);",
        "ins1PreCode":"Author original; Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original);  updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(\"jim@ibatis.apache.org\", updated.getEmail()); } finally {",
        "ins2PreCode":"Author original; Author updated; try { original = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); original.setEmail(\"new@email.com\"); session.update(\"domain.blog.mappers.AuthorMapper.updateAuthor\", original); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally { session.close(); } try { session = sqlMapper.openSession(); updated = (Author) session.selectOne(\"domain.blog.mappers.AuthorMapper.selectAuthor\", 101); assertEquals(original.getEmail(), updated.getEmail()); } finally {",
        "label":1
    },
    {
        "ins1AddCode":"entry.setField(StandardField.TITLE, \"testKey\");",
        "ins1DelCode":"entry.setField(\"field\", \"testKey\");",
        "ins1PreCode":"public void completeEmptyStringReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testKey\"); autoCompleter.indexEntry(entry); ",
        "ins2PreCode":"public void completeEmptyStringReturnsNothing() { BibEntry entry = new BibEntry(); entry.setField(\"field\", \"testKey\"); autoCompleter.indexEntry(entry);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\{ bracket\"), entry.getField(StandardField.REVIEW)); assertFalse(result.hasWarnings());",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(Optional.of(\"escaped \\\\} bracket\"), entry.getField(StandardField.REVIEW)); assertFalse(result.hasWarnings());",
        "label":1
    },
    {
        "ins1AddCode":"value instanceof Double",
        "ins1DelCode":"value instanceof Double  || value instanceof BigInteger",
        "ins1PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double  || value instanceof BigInteger ) { return ((Number)value).doubleValue();",
        "ins2PreCode":"value instanceof Integer || value instanceof Long    || value instanceof Float   || value instanceof Double value instanceof Integer || ) { return ((Number)value).byteValue();",
        "label":0
    },
    {
        "ins1AddCode":"entry.setCitationKey(\"AAA\"); assertEquals(1, database.getNumberOfCitationKeyOccurrences(\"AAA\")); assertEquals(0, database.getNumberOfCitationKeyOccurrences(\"AAA\"));",
        "ins1DelCode":"entry.setCiteKey(\"AAA\"); assertEquals(1, database.getNumberOfKeyOccurrences(\"AAA\")); assertEquals(0, database.getNumberOfKeyOccurrences(\"AAA\"));",
        "ins1PreCode":"void addAndRemoveEntry() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getNumberOfKeyOccurrences(\"AAA\")); database.removeEntry(entry); assertEquals(0, database.getNumberOfKeyOccurrences(\"AAA\"));",
        "ins2PreCode":"void removeEmptyCiteKey() { BibEntry entry = new BibEntry(); entry.setCiteKey(\"AAA\"); database.insertEntry(entry); assertEquals(1, database.getNumberOfKeyOccurrences(\"AAA\")); database.removeEntry(entry); assertEquals(0, database.getNumberOfKeyOccurrences(\"AAA\"));",
        "label":0
    },
    {
        "ins1AddCode":"assertThrows(ElementNotFoundException.class, () -> f.getInputByValue(\"\"));",
        "ins1DelCode":"try { f.getInputByValue(\"\"); fail(\"?\"); } catch (ElementNotFoundException expected) { }",
        "ins1PreCode":"f.getInputByValue(\"\").setValueAttribute(\"value one\"); f.getInputByValue(\"\").setValueAttribute(\"value two\"); f.getInputByValue(\"\").setValueAttribute(\"value three\"); try { f.getInputByValue(\"\"); fail(\"?\"); } catch (ElementNotFoundException expected) { } f.getInputsByName(\"bool\").get(2).click(); submit(f);",
        "ins2PreCode":"f.getInputByValue(\"\").setValueAttribute(\"new one\"); f.getInputByValue(\"\").setValueAttribute(\"new one\"); f.getInputByValue(\"\").setValueAttribute(\"new one\"); try { f.getInputByValue(\"\"); fail(\"?\"); } catch (ElementNotFoundException expected) { } f.getInputsByName(\"bool\").get(1).click(); submit(f);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals((Integer)1, person.getId()); assertEquals((Integer)2, person.getPets().get(1).getId()); assertEquals((Integer)3, pet2.getId()); assertEquals((Integer)2, pet2.getOwner().getId());",
        "ins1DelCode":"assertEquals(1, person.getId()); assertEquals(2, person.getPets().get(1).getId()); assertEquals(3, pet2.getId()); assertEquals(2, pet2.getOwner().getId());",
        "ins1PreCode":"try { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.select(1); assertEquals(1, person.getId()); assertEquals(2, person.getPets().size()); assertEquals(2, person.getPets().get(1).getId());  Pet pet = personMapper.selectPet(1); assertEquals(Integer.valueOf(1), pet.getId());  PetMapper petMapper = sqlSession.getMapper(PetMapper.class); Pet pet2 = petMapper.select(3); assertEquals(3, pet2.getId()); assertEquals(2, pet2.getOwner().getId()); } finally { sqlSession.close();",
        "ins2PreCode":"try { MultipleCrossIncludePersonMapper personMapper = sqlSession.getMapper(MultipleCrossIncludePersonMapper.class); Person person = personMapper.select(1); assertEquals(1, person.getId()); assertEquals(2, person.getPets().size()); assertEquals(2, person.getPets().get(1).getId()); Pet pet = personMapper.selectPet(1); assertEquals(Integer.valueOf(1), pet.getId()); MultipleCrossIncludePetMapper petMapper = sqlSession.getMapper(MultipleCrossIncludePetMapper.class); Pet pet2 = petMapper.select(3); assertEquals(3, pet2.getId()); assertEquals(2, pet2.getOwner().getId()); } finally { sqlSession.close();",
        "label":1
    },
    {
        "ins1AddCode":"Artifact art = dep.getArtifact();",
        "ins1DelCode":"org.eclipse.aether.artifact.Artifact art = dep.getArtifact();",
        "ins1PreCode":"org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.eclipse.aether.artifact.Artifact art = dep.getArtifact();  buffer.append( art );",
        "ins2PreCode":"org.eclipse.aether.graph.Dependency dep = node.getDependency(); if ( dep != null ) { org.eclipse.aether.artifact.Artifact art = dep.getArtifact(); buffer.append( art );",
        "label":0
    },
    {
        "ins1AddCode":"StringUtil.boldHTML(entries.get(0).getCitationKey().orElse(Localization.lang(\"undefined\")))); StringUtil.boldHTML(entries.get(0).getCitationKey().orElse(Localization.lang(\"undefined\"))));",
        "ins1DelCode":"StringUtil.boldHTML(entries.get(0).getCiteKeyOptional().orElse(Localization.lang(\"undefined\")))); StringUtil.boldHTML(entries.get(0).getCiteKeyOptional().orElse(Localization.lang(\"undefined\"))));",
        "ins1PreCode":"return Localization.lang(\"paste entries\"); } else if (entries.size() == 1) { return Localization.lang(\"paste entry %0\", StringUtil.boldHTML(entries.get(0).getCiteKeyOptional().orElse(Localization.lang(\"undefined\")))); } else { return null; } } else { if (entries.size() > 1) { return Localization.lang(\"insert entries\"); } else if (entries.size() == 1) { return Localization.lang(\"insert entry %0\", StringUtil.boldHTML(entries.get(0).getCiteKeyOptional().orElse(Localization.lang(\"undefined\")))); } else { return null;",
        "ins2PreCode":"return Localization.lang(\"cut entries\"); } else if (entries.size() == 1) { return Localization.lang(\"cut entry %0\", StringUtil.boldHTML(entries.get(0).getCiteKeyOptional().orElse(Localization.lang(\"undefined\")))); } else { return null; } } else { if (entries.size() > 1) { return Localization.lang(\"cut entries\"); } else if (entries.size() == 1) { return Localization.lang(\"cut entry %0\", StringUtil.boldHTML(entries.get(0).getCiteKeyOptional().orElse(Localization.lang(\"undefined\")))); } else { return null;",
        "label":1
    },
    {
        "ins1AddCode":"when(timestampPreferencesMock.shouldAddModificationDate()).thenReturn(includeTimestamp); bibEntry.setField(StandardField.MODIFICATIONDATE, baseDate); assertEquals(Optional.of(baseDate), bibEntry.getField(StandardField.MODIFICATIONDATE), \"Initial timestamp not set correctly\"); assertEquals(Optional.of(newDate), bibEntry.getField(StandardField.MODIFICATIONDATE), \"Timestamp not set correctly after entry changed\");",
        "ins1DelCode":"final Field timestampField = StandardField.TIMESTAMP; when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.shouldIncludeTimestamps()).thenReturn(includeTimestamp); bibEntry.setField(timestampField, baseDate); assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\"); assertEquals(Optional.of(newDate), bibEntry.getField(timestampField), \"Timestamp not set correctly after entry changed\");",
        "ins1PreCode":"void updateTimestampEnabled() { final Field timestampField = StandardField.TIMESTAMP; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\";  final boolean includeTimestamp = true;  when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.shouldIncludeTimestamps()).thenReturn(includeTimestamp);  bibEntry.setField(timestampField, baseDate);  assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\");  database.registerListener(new UpdateTimestampListener(preferencesMock));  bibEntry.setField(new UnknownField(\"test\"), \"some value\");  assertEquals(Optional.of(newDate), bibEntry.getField(timestampField), \"Timestamp not set correctly after entry changed\");",
        "ins2PreCode":"void updateTimestampDisabled() { final Field timestampField = StandardField.TIMESTAMP; final String baseDate = \"2000-1-1\"; final String newDate = \"2000-1-2\"; final boolean includeTimestamp = false; when(timestampPreferencesMock.getTimestampField()).thenReturn(timestampField); when(timestampPreferencesMock.now()).thenReturn(newDate); when(timestampPreferencesMock.shouldIncludeTimestamps()).thenReturn(includeTimestamp); bibEntry.setField(timestampField, baseDate); assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\"); database.registerListener(new UpdateTimestampListener(preferencesMock)); bibEntry.setField(new UnknownField(\"test\"), \"some value\"); assertEquals(Optional.of(baseDate), bibEntry.getField(timestampField), \"Initial timestamp not set correctly\");",
        "label":1
    },
    {
        "ins1AddCode":"Context ctx = tomcat.addContext(\"\", null);",
        "ins1DelCode":"File docBase = new File(System.getProperty(\"java.io.tmpdir\")); Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());",
        "ins1PreCode":"Tomcat tomcat = getTomcatInstance();   File docBase = new File(System.getProperty(\"java.io.tmpdir\"));  Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath());  DispatchingServlet dispatch = new DispatchingServlet(false, false);",
        "ins2PreCode":"Tomcat tomcat = getTomcatInstance(); File docBase = new File(System.getProperty(\"java.io.tmpdir\")); Context ctx = tomcat.addContext(\"\", docBase.getAbsolutePath()); DispatchingServlet dispatch =",
        "label":1
    },
    {
        "ins1AddCode":"CategoryDataset dataset = DatasetUtils.createCategoryDataset(\"S\",",
        "ins1DelCode":"CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\",",
        "ins1PreCode":"{{new Integer(-3), new Integer(-2)}, {new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createAreaChart(\"Area Chart\", \"Domain\", \"Range\",",
        "ins2PreCode":"{{new Integer(-3), new Integer(-2)}, {new Integer(-1), new Integer(1)}, {new Integer(2), new Integer(3)}}; CategoryDataset dataset = DatasetUtilities.createCategoryDataset(\"S\", \"C\", data); return ChartFactory.createBarChart(",
        "label":1
    },
    {
        "ins1AddCode":"Assertions.assertEquals(Integer.valueOf(2), user.getId()); Assertions.assertEquals(\"User2\", user.getName()); Assertions.assertNull(user.getPets().get(0).getPetName(), \"should not inherit auto-mapping\"); Assertions.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName());",
        "ins1DelCode":"Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName());",
        "ins1PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_External(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); }",
        "ins2PreCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserWithPets_Inline(2); Assert.assertEquals(Integer.valueOf(2), user.getId()); Assert.assertEquals(\"User2\", user.getName()); Assert.assertNull(\"should not inherit auto-mapping\", user.getPets().get(0).getPetName()); Assert.assertEquals(\"John\", user.getPets().get(0).getBreeder().getBreederName()); }",
        "label":1
    },
    {
        "ins1AddCode":"void testGetNamesAndItems() {",
        "ins1DelCode":"public void testGetNamesAndItems() {",
        "ins1PreCode":"public void testGetNamesAndItems() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "ins2PreCode":"public void testGetNamesAndItems_a3() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { SPMapper spMapper = sqlSession.getMapper(SPMapper.class);",
        "label":1
    },
    {
        "ins1AddCode":"given(this.entityManagerFactory.getPersistenceUnitUtil()).willReturn(this.persistenceUnitUtil);",
        "ins1DelCode":"",
        "ins1PreCode":"void persistAndGetIdShouldPersistAndGetId() { bindEntityManager(); TestEntity entity = new TestEntity(); given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123); Object result = this.testEntityManager.persistAndGetId(entity); verify(this.entityManager).persist(entity);",
        "ins2PreCode":"void persistAndGetIdForTypeShouldPersistAndGetId() { bindEntityManager(); TestEntity entity = new TestEntity(); given(this.persistenceUnitUtil.getIdentifier(entity)).willReturn(123); Integer result = this.testEntityManager.persistAndGetId(entity, Integer.class); verify(this.entityManager).persist(entity);",
        "label":1
    },
    {
        "ins1AddCode":"IntervalCategoryToolTipGenerator g2 = CloneUtils.clone(g1);",
        "ins1DelCode":"IntervalCategoryToolTipGenerator g2 = (IntervalCategoryToolTipGenerator) g1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { IntervalCategoryToolTipGenerator g1 = new IntervalCategoryToolTipGenerator(); IntervalCategoryToolTipGenerator g2 = (IntervalCategoryToolTipGenerator) g1.clone(); assertTrue(g1 != g2); assertTrue(g1.getClass() == g2.getClass());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"return new ArrayList<>();",
        "ins1DelCode":"return new ArrayList<Integer>();",
        "ins1PreCode":"if (++calls == 2) { throw new TestException(); } return new ArrayList<Integer>(); } })",
        "ins2PreCode":"if (++calls == 2) { throw new TestException(); } return new ArrayList<Integer>(); } })",
        "label":1
    },
    {
        "ins1AddCode":"ConstantNode irConstantNode = new ConstantNode(userBooleanConstantNode.getLocation());",
        "ins1DelCode":"ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userBooleanConstantNode.getLocation());",
        "ins1PreCode":"public void visitBooleanConstant(EBooleanConstant userBooleanConstantNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userBooleanConstantNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userBooleanConstantNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userBooleanConstantNode, StandardConstant.class).getStandardConstant());",
        "ins2PreCode":"public void visitNumeric(ENumeric userNumericNode, ScriptScope scriptScope) { ConstantNode irConstantNode = new ConstantNode(); irConstantNode.setLocation(userNumericNode.getLocation()); irConstantNode.setExpressionType(scriptScope.getDecoration(userNumericNode, ValueType.class).getValueType()); irConstantNode.setConstant(scriptScope.getDecoration(userNumericNode, StandardConstant.class).getStandardConstant());",
        "label":1
    },
    {
        "ins1AddCode":"\"logging.file.name=\" + this.logFile); assertThat(output).startsWith(this.logFile.getAbsolutePath());",
        "ins1DelCode":"\"logging.file.name=target/foo.log\"); assertThat(output).startsWith(\"target/foo.log\");",
        "ins1PreCode":"public void addLogFileProperty() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.name=target/foo.log\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class); String existingOutput = this.outputCapture.toString(); logger.info(\"Hello world\"); String output = this.outputCapture.toString().substring(existingOutput.length()) .trim(); assertThat(output).startsWith(\"target/foo.log\");",
        "ins2PreCode":"public void addLogPathProperty() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.path=target/foo/\"); this.initializer.initialize(this.context.getEnvironment(), this.context.getClassLoader()); Log logger = LogFactory.getLog(LoggingApplicationListenerTests.class); String existingOutput = this.outputCapture.toString(); logger.info(\"Hello world\"); String output = this.outputCapture.toString().substring(existingOutput.length()) .trim(); assertThat(output).startsWith(\"target/foo/spring.log\");",
        "label":1
    },
    {
        "ins1AddCode":"while ( (System.currentTimeMillis()-start)<25000 && msgCount*threadCount!=listener1.count) Thread.sleep(500);",
        "ins1DelCode":"while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500);",
        "ins1PreCode":"for (int x=0; x<threads.length; x++ ) { threads[x].join();}  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<15000 && msgCount*threadCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC MULTI THREAD [\"+listener1.count+\"]\"); assertEquals(\"Checking success messages.\",msgCount*threadCount,listener1.count);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"try (Reader configReader = Resources.getResourceAsReader(resource)) { SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/serializecircular/CreateDB.sql\"); return sqlSessionFactory; }",
        "ins1DelCode":"Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close(); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/serializecircular/CreateDB.sql\"); return sqlSessionFactory;",
        "ins1PreCode":"private SqlSessionFactory getSqlSessionFactoryXmlConfig(String resource) throws Exception { Reader configReader = Resources.getResourceAsReader(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configReader); configReader.close();  BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(),",
        "ins2PreCode":"SqlSessionFactory sqlSessionFactory; Reader batisConfigReader = Resources.getResourceAsReader(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(batisConfigReader); batisConfigReader.close(); BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(),",
        "label":0
    },
    {
        "ins1AddCode":"this.launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(this.launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); this.launcher.launch(new String[0]);",
        "ins1DelCode":"PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); launcher.launch(new String[0]);",
        "ins1PreCode":"void testUserSpecifiedJarPath() throws Exception { System.setProperty(\"loader.path\", \"jars/app.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\"); launcher.launch(new String[0]); waitFor(\"Hello World\");",
        "ins2PreCode":"void testUserSpecifiedNestedJarPath() throws Exception { System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); PropertiesLauncher launcher = new PropertiesLauncher(); System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"0123-4567\"), entry.getField(\"issn\"));",
        "ins1DelCode":"Assert.assertEquals(Optional.of(\"0123-4567\"), entry.getField(\"issn\"));",
        "ins1PreCode":"entry.setField(\"issn\", \"0123-4567\");  worker.cleanup(preset, entry); Assert.assertEquals(Optional.of(\"0123-4567\"), entry.getField(\"issn\"));",
        "ins2PreCode":"entry.setField(\"issn\", \"01234567\"); worker.cleanup(preset, entry); Assert.assertEquals(Optional.of(\"0123-4567\"), entry.getField(\"issn\"));",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertTrue(others.contains(o)); Assert.assertEquals(b,iter.next()); Assert.assertEquals(d,iter.next()); Assert.assertFalse(iter.hasNext());",
        "ins1DelCode":"assertTrue(others.contains(o)); assertEquals(b,iter.next()); assertEquals(d,iter.next()); assertFalse(iter.hasNext());",
        "ins1PreCode":"Iterator<WebXml> iter = ordered.iterator(); while (others.size() > 0) { WebXml o = iter.next(); assertTrue(others.contains(o)); others.remove(o); } assertEquals(b,iter.next()); assertEquals(d,iter.next()); assertFalse(iter.hasNext());",
        "ins2PreCode":"Iterator<WebXml> iter = ordered.iterator(); while (others.size() > 0) { WebXml o = iter.next(); assertTrue(others.contains(o)); others.remove(o); } assertEquals(b,iter.next()); assertEquals(d,iter.next()); assertFalse(iter.hasNext());",
        "label":1
    },
    {
        "ins1AddCode":"List<Post> posts = session.selectList(\"org.apache.ibatis.domain.blog.mappers.PostMapper.findPost\",",
        "ins1DelCode":"List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\",",
        "ins1PreCode":"public void shouldFindPostByIDWithDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"id\", 1);",
        "ins2PreCode":"public void shouldFindPostsWithBlogIdUsingDynamicSql() throws Exception { SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap<String, Integer>() {{ put(\"blog_id\", 1);",
        "label":1
    },
    {
        "ins1AddCode":"if (isNullAt(ordinal)) return null; return Decimal.apply(getLong(ordinal), precision, scale);",
        "ins1DelCode":"assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final long value = Platform.getLong(baseObject, baseOffset + offset); return Decimal.apply(value, precision, scale);",
        "ins1PreCode":"public Decimal getDecimal(int ordinal, int precision, int scale) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null;  if (precision <= Decimal.MAX_LONG_DIGITS()) { final long value = Platform.getLong(baseObject, baseOffset + offset); return Decimal.apply(value, precision, scale); } else { final byte[] bytes = getBinary(ordinal);",
        "ins2PreCode":"public Decimal getDecimal(int ordinal, int precision, int scale) { if (isNullAt(ordinal)) { byte[] bytes = getBinary(ordinal); return null; if (precision <= Decimal.MAX_LONG_DIGITS()) { return Decimal.createUnsafe(getLong(ordinal), precision, scale); return Decimal.apply(javaDecimal, precision, scale); } else { byte[] bytes = getBinary(ordinal);",
        "label":0
    },
    {
        "ins1AddCode":"when(mockResolver.send(ArgumentMatchers.any(Message.class))) .thenAnswer( (Answer<Message>) invocation -> { Message query = invocation.getArgument(0); Message answer = m.clone(); answer.addRecord(query.getQuestion(), Section.QUESTION); return answer; });",
        "ins1DelCode":"when(mockResolver.send(ArgumentMatchers.any(Message.class))).thenReturn(m);",
        "ins1PreCode":"Message m = new Message(); m.getHeader().setRcode(Rcode.NXDOMAIN); Resolver mockResolver = Mockito.mock(Resolver.class); when(mockResolver.send(ArgumentMatchers.any(Message.class))).thenReturn(m); Lookup.setDefaultResolver(mockResolver); assertThrows(UnknownHostException.class, () -> Address.getByName(\"example.invalid\"));",
        "ins2PreCode":"Message m = new Message(); m.getHeader().setRcode(Rcode.NXDOMAIN); Resolver mockResolver = Mockito.mock(Resolver.class); when(mockResolver.send(ArgumentMatchers.any(Message.class))).thenReturn(m); Lookup.setDefaultResolver(mockResolver); assertThrows(UnknownHostException.class, () -> Address.getAllByName(\"example.invalid\"));",
        "label":1
    },
    {
        "ins1AddCode":"String key = (index > 0) ? pair.substring(0, index) : pair; String value = (index > 0) ? pair.substring(index + 1) : \"\";",
        "ins1DelCode":"String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\");",
        "ins1PreCode":"Map<String, Object> map = new HashMap<>(); for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\"); map.put(key.trim(), value.trim()); }",
        "ins2PreCode":"Map<String, Object> map = new HashMap<>(); for (String pair : environment) { int index = pair.indexOf(\"=\"); String key = (index > 0 ? pair.substring(0, index) : pair); String value = (index > 0 ? pair.substring(index + 1) : \"\"); map.put(key.trim(), value.trim()); }",
        "label":1
    },
    {
        "ins1AddCode":"j.createFreeStyleProject(projectName); Page result = j.search(projectName); j.assertGoodStatus(result);",
        "ins1DelCode":"createFreeStyleProject(projectName); Page result = search(projectName); assertGoodStatus(result);",
        "ins1PreCode":"public void testSearchByProjectName() throws Exception { final String projectName = \"testSearchByProjectName\";  createFreeStyleProject(projectName);  Page result = search(projectName); Assert.assertNotNull(result); assertGoodStatus(result);  ",
        "ins2PreCode":"public void testSearchByDisplayName() throws Exception { final String displayName = \"displayName9999999\"; FreeStyleProject project = createFreeStyleProject(\"testSearchByDisplayName\"); Page result = search(displayName); Assert.assertNotNull(result); assertGoodStatus(result);",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 52; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 52; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(), \"org/apache/ibatis/submitted/typehandler/CreateDB.sql\");",
        "ins1DelCode":"SqlSession session = sqlSessionFactory.openSession(); Connection conn = session.getConnection(); reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/typehandler/CreateDB.sql\"); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.runScript(reader); conn.close(); reader.close(); session.close();",
        "ins1PreCode":"sqlSessionFactory.getConfiguration().getTypeHandlerRegistry().register(StringTrimmingTypeHandler.class);   SqlSession session = sqlSessionFactory.openSession(); Connection conn = session.getConnection(); reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/typehandler/CreateDB.sql\"); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.runScript(reader); conn.close(); reader.close(); session.close();",
        "ins2PreCode":"sqlSessionFactory.getConfiguration().getMapperRegistry().addMapper(PersonMapper.class); sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader); Connection conn = null; Reader reader = Resources.getResourceAsReader(\"org/apache/ibatis/submitted/enumtypehandler_on_annotation/CreateDB.sql\"); ScriptRunner runner = new ScriptRunner(conn); runner.setLogWriter(null); runner.runScript(reader); conn.close(); reader.close(); conn.close();",
        "label":0
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>();",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>();",
        "ins1PreCode":"public void raceForTerminalState() { final List<Integer> expected = Arrays.asList(1); for (int i = 0; i < 100000; i++) { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "ins2PreCode":"public void raceForTerminalState() { final List<Integer> expected = Arrays.asList(1); for (int i = 0; i < 100000; i++) { TestObserverEx<Integer> to = new TestObserverEx<Integer>(); Observable.just(1).subscribeOn(Schedulers.computation()).cache().subscribe(to); to.awaitDone(5, TimeUnit.SECONDS);",
        "label":1
    },
    {
        "ins1AddCode":"public List<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor)",
        "ins1DelCode":"public Collection<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor)",
        "ins1PreCode":"public Collection<SQLServerTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor) throws DBException {",
        "ins2PreCode":"public Collection<MySQLTableColumn> getAttributes(@NotNull DBRProgressMonitor monitor) throws DBException {",
        "label":1
    },
    {
        "ins1AddCode":"if (!ObjectUtils.equal(this.subplots, that.subplots)) {",
        "ins1DelCode":"if (!ObjectUtilities.equal(this.subplots, that.subplots)) {",
        "ins1PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtilities.equal(this.subplots, that.subplots)) { return false; }",
        "ins2PreCode":"if (this.gap != that.gap) { return false; } if (!ObjectUtilities.equal(this.subplots, that.subplots)) { return false; }",
        "label":1
    },
    {
        "ins1AddCode":"} else if (Constants.CATALINA_HOME_PROP.equals(propName)) { } else if (Constants.CATALINA_BASE_PROP.equals(propName)) {",
        "ins1DelCode":"} else if (Globals.CATALINA_HOME_PROP.equals(propName)) { } else if (Globals.CATALINA_BASE_PROP.equals(propName)) {",
        "ins1PreCode":"String replacement; if (propName.length() == 0) { replacement = null; } else if (Globals.CATALINA_HOME_PROP.equals(propName)) { replacement = getCatalinaHome(); } else if (Globals.CATALINA_BASE_PROP.equals(propName)) { replacement = getCatalinaBase(); } else {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void couchbaseClusterIsUp() {",
        "ins1DelCode":"public void couchbaseClusterIsUp() {",
        "ins1PreCode":"public void couchbaseClusterIsUp() { Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster);",
        "ins2PreCode":"public void couchbaseClusterIsDown() { Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster);",
        "label":1
    },
    {
        "ins1AddCode":"MutableBasicGraph<Integer> graph = BasicGraphBuilder",
        "ins1DelCode":"MutableGraph<Integer> graph = GraphBuilder",
        "ins1PreCode":"public void nodeOrder_insertion() { MutableGraph<Integer> graph = GraphBuilder .directed() .nodeOrder(insertion())",
        "ins2PreCode":"public void nodeOrder_default() { MutableGraph<Integer> graph = GraphBuilder .directed() assertThat(graph.nodeOrder()).isEqualTo(insertion());",
        "label":1
    },
    {
        "ins1AddCode":"entry2.setCitationKey(\"entry2\");",
        "ins1DelCode":"entry2.setCiteKey(\"entry2\");",
        "ins1PreCode":"BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Link{\\\\\\\"{o}}ping University, School of Computer Engineering}}\"); database.insertEntry(entry1);",
        "ins2PreCode":"BibEntry entry1 = new BibEntry(); entry1.setField(StandardField.CROSSREF, \"entry2\"); BibEntry entry2 = new BibEntry(); entry2.setCiteKey(\"entry2\"); entry2.setField(StandardField.AUTHOR, \"{Massachusetts Institute of Technology}\"); database.insertEntry(entry1);",
        "label":1
    },
    {
        "ins1AddCode":"XYStepRenderer r2 = CloneUtils.clone(r1);",
        "ins1DelCode":"XYStepRenderer r2 = (XYStepRenderer) r1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { XYStepRenderer r1 = new XYStepRenderer(); XYStepRenderer r2 = (XYStepRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { StackedXYBarRenderer r1 = new StackedXYBarRenderer(); StackedXYBarRenderer r2 = (StackedXYBarRenderer) r1.clone(); assertTrue(r1 != r2); assertTrue(r1.getClass() == r2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"new ChooseSqlNode(new ArrayList<SqlNode>() {{",
        "ins1DelCode":"new ChooseSqlNode(new ArrayList() {{",
        "ins1PreCode":"final String expected = \"SELECT * FROM BLOG WHERE CATEGORY = ?\"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = ?\")), \"true\" ));",
        "ins2PreCode":"final String expected = \"SELECT * FROM BLOG WHERE CATEGORY = 'NONE'\"; DynamicSqlSource source = createDynamicSqlSource( new TextSqlNode(\"SELECT * FROM BLOG\"), new ChooseSqlNode(new ArrayList() {{ add(new IfSqlNode(mixedContents(new TextSqlNode(\"WHERE CATEGORY = 'NONE'\")), \"true\" ));",
        "label":1
    },
    {
        "ins1AddCode":"sendfile.stream.getOutputBuffer().end();",
        "ins1DelCode":"sendfile.stream.getOutputBuffer().close();",
        "ins1PreCode":"sendfile.left -= bytesWritten; if (sendfile.left == 0) { try { sendfile.stream.getOutputBuffer().close(); } catch (IOException e) { failed(e, sendfile);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XYSeries<String> series = new XYSeries<>(\"Series 1\"); XYSeriesCollection<String> dataset = new XYSeriesCollection<>();",
        "ins1DelCode":"XYSeries series = new XYSeries(\"Series 1\"); XYSeriesCollection dataset = new XYSeriesCollection();",
        "ins1PreCode":"public void testXYAutoRange1() { XYSeries series = new XYSeries(\"Series 1\"); series.add(1.0, 1.0); series.add(2.0, 2.0); series.add(3.0, 3.0); XYSeriesCollection dataset = new XYSeriesCollection(); dataset.addSeries(series); JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\",",
        "ins2PreCode":"public void testXYAutoRange2() { XYSeries series = new XYSeries(\"Series 1\"); series.add(1.0, 1.0); series.add(2.0, 2.0); series.add(3.0, 3.0); XYSeriesCollection dataset = new XYSeriesCollection(); dataset.addSeries(series); JFreeChart chart = ChartFactory.createScatterPlot(\"Test\", \"X\", \"Y\",",
        "label":1
    },
    {
        "ins1AddCode":"void getNonRecursiveManifest() throws Exception { try (ExplodedArchive explodedArchive = new ExplodedArchive(new File(\"src/test/resources/root\"))) { assertThat(explodedArchive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(explodedArchive); assertThat(entries.size()).isEqualTo(4); }",
        "ins1DelCode":"public void getNonRecursiveManifest() throws Exception { ExplodedArchive archive = new ExplodedArchive( new File(\"src/test/resources/root\")); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(4);",
        "ins1PreCode":"public void getNonRecursiveManifest() throws Exception { ExplodedArchive archive = new ExplodedArchive( new File(\"src/test/resources/root\")); assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(4);",
        "ins2PreCode":"public void getNonRecursiveManifestEvenIfNonRecursive() throws Exception { ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), ExplodedArchive archive = new ExplodedArchive(new File(\"src/test/resources/root\"), assertThat(archive.getManifest()).isNotNull(); Map<String, Archive.Entry> entries = getEntriesMap(archive); assertThat(entries.size()).isEqualTo(3);",
        "label":0
    },
    {
        "ins1AddCode":"List<String> result = new ArrayList<>();",
        "ins1DelCode":"List<String> result = new ArrayList<String>();",
        "ins1PreCode":"public String[] findLifecycleListenerNames() throws MBeanException { Container container = null; List<String> result = new ArrayList<String>();  try {",
        "ins2PreCode":"public String[] findContainerListenerNames() throws MBeanException { Container container = null; List<String> result = new ArrayList<String>(); try {",
        "label":1
    },
    {
        "ins1AddCode":"public static <@NonNull T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8) {",
        "ins1DelCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8) {",
        "ins1PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\");",
        "ins2PreCode":"public static <T> Observable<T> just(@NonNull T item1, @NonNull T item2, @NonNull T item3, @NonNull T item4, @NonNull T item5, @NonNull T item6, @NonNull T item7, @NonNull T item8, @NonNull T item9) { Objects.requireNonNull(item1, \"item1 is null\"); Objects.requireNonNull(item2, \"item2 is null\");",
        "label":1
    },
    {
        "ins1AddCode":"DefaultXYZDataset d2 = CloneUtils.clone(d1);",
        "ins1DelCode":"DefaultXYZDataset d2 = (DefaultXYZDataset) d1.clone();",
        "ins1PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultXYZDataset d1 = new DefaultXYZDataset(); DefaultXYZDataset d2 = (DefaultXYZDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass());",
        "ins2PreCode":"public void testCloning() throws CloneNotSupportedException { DefaultXYDataset d1 = new DefaultXYDataset(); DefaultXYDataset d2 = (DefaultXYDataset) d1.clone(); assertTrue(d1 != d2); assertTrue(d1.getClass() == d2.getClass());",
        "label":0
    },
    {
        "ins1AddCode":"return -1;",
        "ins1DelCode":"return 0;",
        "ins1PreCode":"int bytesRead = sc.read(netInBuffer); if (bytesRead == -1) {   return 0; }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"List<MavenProject> projects = new ArrayList<>();",
        "ins1DelCode":"List<MavenProject> projects = new ArrayList<MavenProject>();",
        "ins1PreCode":"public void testPluginDependenciesInfluenceSorting() throws Exception { List<MavenProject> projects = new ArrayList<MavenProject>();  MavenProject parentProject = createProject( \"groupId\", \"parent\", \"1.0\" );",
        "ins2PreCode":"public void testPluginDependenciesInfluenceSorting_DeclarationInParent() throws Exception { List<MavenProject> projects = new ArrayList<MavenProject>(); MavenProject parentProject = createProject( \"groupId\", \"parent-declarer\", \"1.0\" );",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (usernameText != null) { connectionInfo.setUserName(usernameText.getText().trim()); } if (passwordText != null) { connectionInfo.setUserPassword(passwordText.getText()); }",
        "ins1PreCode":"if (dbText != null) { connectionInfo.setDatabaseName(dbText.getText().trim()); } if (usernameText != null) { connectionInfo.setUserName(usernameText.getText().trim()); } if (passwordText != null) { connectionInfo.setUserPassword(passwordText.getText()); } if (homesSelector != null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"checkAtReturnAndSignatureMatch(\"Maybe\", m, e, \"Flowable\", \"Observable\", \"Maybe\", \"Single\", \"Completable\", \"Disposable\", \"Iterable\", \"Stream\", \"Future\", \"CompletionStage\"); missingClosingDD(e, m, \"Maybe\", \"io.reactivex.rxjava3.core\");",
        "ins1DelCode":"missingClosingDD(e, m, \"Maybe\");",
        "ins1PreCode":"} } aOrAn(e, m, \"Maybe\"); missingClosingDD(e, m, \"Maybe\"); backpressureMentionedWithoutAnnotation(e, m, \"Maybe\"); }",
        "ins2PreCode":"} } aOrAn(e, m, \"Single\"); missingClosingDD(e, m, \"Single\"); backpressureMentionedWithoutAnnotation(e, m, \"Single\"); }",
        "label":1
    },
    {
        "ins1AddCode":"Node<T> n = new Node<>(tailOffset);",
        "ins1DelCode":"Node<T> n = new Node<T>(tailOffset);",
        "ins1PreCode":"int tailOffset = this.tailOffset;  if (tailOffset == capacityHint) { Node<T> n = new Node<T>(tailOffset); n.values[0] = t; this.tailOffset = 1;",
        "ins2PreCode":"int tailOffset = this.tailOffset; if (tailOffset == capacityHint) { Node<T> n = new Node<T>(tailOffset); n.values[0] = t; this.tailOffset = 1;",
        "label":1
    },
    {
        "ins1AddCode":"any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences, externalFileType);",
        "ins1DelCode":"any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences);",
        "ins1PreCode":"any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(3)));  LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete(); ",
        "ins2PreCode":"any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4))); LinkedFileViewModel viewModel = new LinkedFileViewModel(linkedFile, entry, databaseContext, taskExecutor, dialogService, preferences); boolean removed = viewModel.delete();",
        "label":1
    },
    {
        "ins1AddCode":"NetworkBuilder.directed().allowsParallelEdges(true).allowsSelfLoops(true).build();",
        "ins1DelCode":"NetworkBuilder.directed().allowsSelfLoops(true).allowsParallelEdges(true).build();",
        "ins1PreCode":"private static MutableNetwork<Integer, String> buildDirectedNetwork() { MutableNetwork<Integer, String> directedGraph = NetworkBuilder.directed().allowsSelfLoops(true).allowsParallelEdges(true).build(); directedGraph.addEdge(N1, N1, E11); directedGraph.addEdge(N1, N2, E12);",
        "ins2PreCode":"private static MutableNetwork<Integer, String> buildUndirectedNetwork() { MutableNetwork<Integer, String> undirectedGraph = NetworkBuilder.undirected().allowsSelfLoops(true).allowsParallelEdges(true).build(); undirectedGraph.addEdge(N1, N1, E11); undirectedGraph.addEdge(N1, N2, E12);",
        "label":1
    },
    {
        "ins1AddCode":"List<Author> authors = session.selectList(\"org.apache.ibatis.builder.CachedAuthorMapper.selectAllAuthors\"); List<Author> authors = session.selectList(\"org.apache.ibatis.builder.CachedAuthorMapper.selectAllAuthors\");",
        "ins1DelCode":"List<Author> authors = session.selectList(\"com.domain.CachedAuthorMapper.selectAllAuthors\"); List<Author> authors = session.selectList(\"com.domain.CachedAuthorMapper.selectAllAuthors\");",
        "ins1PreCode":"int second = -1; SqlSession session = sqlMapper.openSession(); try { List<Author> authors = session.selectList(\"com.domain.CachedAuthorMapper.selectAllAuthors\"); first = System.identityHashCode(authors); session.commit(); } finally { session.close(); } session = sqlMapper.openSession(); try { List<Author> authors = session.selectList(\"com.domain.CachedAuthorMapper.selectAllAuthors\"); second = System.identityHashCode(authors); } finally {",
        "ins2PreCode":"int second = -1; SqlSession session = sqlMapper.openSession(); try { List<Author> authors = session.selectList(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors\"); first = System.identityHashCode(authors); session.close(); } finally { session.close(); } session = sqlMapper.openSession(); try { List<Author> authors = session.selectList(\"org.apache.ibatis.domain.blog.mappers.AuthorMapper.selectAllAuthors\"); second = System.identityHashCode(authors); } finally {",
        "label":0
    },
    {
        "ins1AddCode":"while (!slave.toComputer().isOffline()) {",
        "ins1DelCode":"while (true) { if(slave.toComputer().isOffline()) break;",
        "ins1PreCode":"public void waitNodeOfflineShouldSucceedOnOfflineNode() throws Exception { DumbSlave slave = j.createSlave(\"aNode\", \"\", null); slave.toComputer().setTemporarilyOffline(true); while (true) { if(slave.toComputer().isOffline()) break; Thread.sleep(100); }",
        "ins2PreCode":"public void waitNodeOfflineShouldSucceedOnDisconnectedNode() throws Exception { DumbSlave slave = j.createSlave(\"aNode\", \"\", null); if(slave.toComputer().isOffline()) while (true) { if(slave.toComputer().isOffline()) break; Thread.sleep(100); }",
        "label":1
    },
    {
        "ins1AddCode":"void testMaxHistoryPropertyWithXmlConfiguration() {",
        "ins1DelCode":"public void testMaxHistoryPropertyWithXmlConfiguration() throws Exception {",
        "ins1PreCode":"public void testMaxHistoryPropertyWithXmlConfiguration() throws Exception { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\");",
        "ins2PreCode":"private void testTotalSizeCapProperty(String sizeValue, String expectedFileSize) { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.total-size-cap\", sizeValue);",
        "label":0
    },
    {
        "ins1AddCode":"void shouldFailIfKeyPropertyIsInvalid_NoParamName() { when(mapper).insertMultiParams_keyPropertyWithoutParamName(country, 1);",
        "ins1DelCode":"public void shouldFailIfKeyPropertyIsInvalid_NoParamName() throws Exception { when(mapper).insertMultiParams_keyPropertyWithoutParamName(country, Integer.valueOf(1));",
        "ins1PreCode":"public void shouldFailIfKeyPropertyIsInvalid_NoParamName() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(mapper).insertMultiParams_keyPropertyWithoutParamName(country, Integer.valueOf(1)); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining( \"Could not determine which parameter to assign generated keys to. \"",
        "ins2PreCode":"public void shouldFailIfKeyPropertyIsInvalid_WrongParamName() throws Exception { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { try { CountryMapper mapper = sqlSession.getMapper(CountryMapper.class); Country country = new Country(\"China\", \"CN\"); when(mapper).insertMultiParams_keyPropertyWithWrongParamName(country, Integer.valueOf(1)); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining( \"Could not find parameter 'bogus'. \"",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(numCorrect, rdd.count());",
        "ins1DelCode":"Assert.assertTrue(numCorrect == rdd.count());",
        "ins1PreCode":"DecisionTreeModel model = learner.run(rdd.rdd());  int numCorrect = validatePrediction(arr, model); Assert.assertTrue(numCorrect == rdd.count());",
        "ins2PreCode":"DecisionTreeModel model = DecisionTree$.MODULE$.train(rdd.rdd(), strategy); int numCorrect = validatePrediction(arr, model); Assert.assertTrue(numCorrect == rdd.count());",
        "label":0
    },
    {
        "ins1AddCode":"snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat, timestamp );",
        "ins1DelCode":"snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat );",
        "ins1PreCode":"RemoteSnapshotMetadata snapshotMetadata = snapshots.get( key ); if ( snapshotMetadata == null ) { snapshotMetadata = new RemoteSnapshotMetadata( artifact, legacyFormat ); snapshots.put( key, snapshotMetadata ); }",
        "ins2PreCode":"LocalSnapshotMetadata snapshotMetadata = snapshots.get( key ); if ( snapshotMetadata == null ) { snapshotMetadata = new LocalSnapshotMetadata( artifact, legacyFormat ); snapshots.put( key, snapshotMetadata ); }",
        "label":1
    },
    {
        "ins1AddCode":"queue = new SpscArrayQueue<>(prefetch);",
        "ins1DelCode":"queue = new SpscArrayQueue<T>(prefetch);",
        "ins1PreCode":"} }  queue = new SpscArrayQueue<T>(prefetch);  downstream.onSubscribe(this);",
        "ins2PreCode":"} } queue = new SpscArrayQueue<T>(prefetch); downstream.onSubscribe(this);",
        "label":1
    },
    {
        "ins1AddCode":"LinearRegressionModel model = new LinearRegressionWithSGD(1.0, 100, 0.0, 1.0) .run(testRDD.rdd());",
        "ins1DelCode":"LinearRegressionModel model = LinearRegressionWithSGD.train(testRDD.rdd(), 100);",
        "ins1PreCode":"List<LabeledPoint> validationData = LinearDataGenerator.generateLinearInputAsList(A, weights, nPoints, 17, 0.1);  LinearRegressionModel model = LinearRegressionWithSGD.train(testRDD.rdd(), 100);  int numAccurate = validatePrediction(validationData, model);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"clearNonBlockingListeners();",
        "ins1DelCode":"clearNonBlockingListeners();",
        "ins1PreCode":"public synchronized boolean asyncComplete() { pauseNonContainerThread(); boolean doComplete = false; if (state == AsyncState.STARTING) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.STARTED) { state = AsyncState.COMPLETING; doComplete = true; } else if (state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_COMPLETE; } else if (state == AsyncState.READ_WRITE_OP) { clearNonBlockingListeners(); state = AsyncState.MUST_COMPLETE; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncComplete()\", state)); } return doComplete;",
        "ins2PreCode":"public synchronized boolean asyncDispatch() { pauseNonContainerThread(); boolean doDispatch = false; if (state == AsyncState.STARTING || state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED) { state = AsyncState.DISPATCHING; doDispatch = true; state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.READ_WRITE_OP) { pauseNonContainerThread(); state = AsyncState.MUST_DISPATCH; } else { throw new IllegalStateException( sm.getString(\"asyncStateMachine.invalidAsyncState\", \"asyncDispatch()\", state)); } return doDispatch;",
        "label":0
    },
    {
        "ins1AddCode":"XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series 1\");",
        "ins1DelCode":"XIntervalSeries s1 = new XIntervalSeries(\"Series 1\");",
        "ins1PreCode":"public void testIndexOf() { XIntervalSeries s1 = new XIntervalSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 2.0); s1.add(2.0, 2.0, 2.0, 3.0);",
        "ins2PreCode":"public void testIndexOf() { VectorSeries s1 = new VectorSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 2.0); s1.add(2.0, 2.0, 2.0, 3.0);",
        "label":1
    },
    {
        "ins1AddCode":"if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - Short.SIZE / Byte.SIZE) { for (int i = 0; i < Short.SIZE; i += Byte.SIZE) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? Byte.SIZE - i : i)));",
        "ins1DelCode":"if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 2) { for (int i = 0; i < 16; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 8 - i : i)));",
        "ins1PreCode":"private IoBuffer putShort(Pointer pointer, short value) { if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 2) { throw new BufferUnderflowException(); } for (int i = 0; i < 16; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 8 - i : i))); } return this;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (getPreserveCookieHeader()) {",
        "ins1DelCode":"if (CookieSupport.PRESERVE_COOKIE_HEADER) {",
        "ins1PreCode":"log.debug(\"Cookies: Parsing b[]: \" + cookieValue.toString()); } ByteChunk bc = cookieValue.getByteChunk(); if (CookieSupport.PRESERVE_COOKIE_HEADER) { int len = bc.getLength(); if (len > 0) {",
        "ins2PreCode":"log.debug(\"Cookies: Parsing b[]: \" + cookieValue.toString()); } ByteChunk bc = cookieValue.getByteChunk(); if (cookieValue.getType() != MessageBytes.T_BYTES ) { Cookie.parseCookie(bc.getBytes(), bc.getOffset(), bc.getLength(), while (pos >= 0) {",
        "label":0
    },
    {
        "ins1AddCode":".assertErrorMessage(ExceptionHelper.nullWarning(\"The collectionSupplier returned a null Collection.\"));",
        "ins1DelCode":".assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins1PreCode":"}) .to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "ins2PreCode":"}) .to(TestHelper.<Collection<Integer>>testConsumer()) .assertFailure(NullPointerException.class) .assertErrorMessage(\"The collectionSupplier returned a null collection. Null values are generally not allowed in 2.x operators and sources.\");",
        "label":1
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"@Override protected void subscribeActual( SingleObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); obs.set(observer); }",
        "ins2PreCode":"@Override protected void subscribeActual( MaybeObserver<? super Integer> observer) { observer.onSubscribe(Disposables.empty()); obs.set(observer); }",
        "label":1
    },
    {
        "ins1AddCode":"return f.concatMapDelayError(Functions.justFunction(Flowable.just(2)), true, 2, ImmediateThinScheduler.INSTANCE);",
        "ins1DelCode":"return f.concatMapDelayError(Functions.justFunction(Flowable.just(2)), 2, true, ImmediateThinScheduler.INSTANCE);",
        "ins1PreCode":"TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Object> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(2)), 2, true, ImmediateThinScheduler.INSTANCE); } });",
        "ins2PreCode":"TestHelper.checkDoubleOnSubscribeFlowable(new Function<Flowable<Object>, Publisher<Integer>>() { @Override public Publisher<Integer> apply(Flowable<Object> f) throws Exception { return f.concatMapDelayError(Functions.justFunction(Flowable.just(2))); } });",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "label":1
    },
    {
        "ins1AddCode":"bibEntry.setField(\"bibtexkey\", \"9780134685991\"); bibEntry.setField(\"year\", \"2018\"); bibEntry.setField(\"date\", \"2018-01-11\"); bibEntry.setField(\"ean\", \"9780134685991\"); bibEntry.setField(\"isbn\", \"0134685997\"); bibEntry.setField(\"url\", \"http://www.ebook.de/de/product/28983211/joshua_bloch_effective_java.html\");",
        "ins1DelCode":"bibEntry.setField(\"bibtexkey\", \"9780321356680\"); bibEntry.setField(\"year\", \"2008\"); bibEntry.setField(\"date\", \"2008-05-08\"); bibEntry.setField(\"ean\", \"9780321356680\"); bibEntry.setField(\"isbn\", \"0321356683\"); bibEntry.setField(\"pagetotal\", \"384\"); bibEntry.setField(\"url\", \"http://www.ebook.de/de/product/6441328/joshua_bloch_effective_java.html\");",
        "ins1PreCode":" bibEntry = new BibEntry(); bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780321356680\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2008\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2008-05-08\"); bibEntry.setField(\"ean\", \"9780321356680\"); bibEntry.setField(\"isbn\", \"0321356683\"); bibEntry.setField(\"pagetotal\", \"384\"); bibEntry.setField(\"url\", \"http://www.ebook.de/de/product/6441328/joshua_bloch_effective_java.html\");",
        "ins2PreCode":"bibEntry = new BibEntry(); bibEntry.setType(BiblatexEntryTypes.BOOK); bibEntry.setField(\"bibtexkey\", \"9780321356680\"); bibEntry.setField(\"title\", \"Effective Java\"); bibEntry.setField(\"publisher\", \"Addison Wesley\"); bibEntry.setField(\"year\", \"2008\"); bibEntry.setField(\"author\", \"Bloch, Joshua\"); bibEntry.setField(\"date\", \"2008-05-08\"); bibEntry.setField(\"ean\", \"9780321356680\"); bibEntry.setField(\"isbn\", \"0321356683\"); bibEntry.setField(\"pagetotal\", \"384\"); bibEntry.setField(\"url\", \"http://www.ebook.de/de/product/6441328/joshua_bloch_effective_java.html\");",
        "label":1
    },
    {
        "ins1AddCode":"final List<Object> list = new ArrayList<>();",
        "ins1DelCode":"final List<Object> list = new ArrayList<Object>();",
        "ins1PreCode":"public void deferredRequest() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() { ",
        "ins2PreCode":"public void requestZero() { final List<Object> list = new ArrayList<Object>(); Subscriber<Object> sub = new Subscriber<Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"sname = new ObjectName(getDomain() + \":type=StoreConfig\");",
        "ins1DelCode":"sname = new ObjectName(\"Catalina:type=StoreConfig\");",
        "ins1PreCode":" ObjectName sname = null; try { sname = new ObjectName(\"Catalina:type=StoreConfig\"); if(mserver.isRegistered(sname)) { mserver.invoke(sname, \"store\",",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (server.received.size() > 0 && client.received.size() > 1) {",
        "ins1DelCode":"if (server.received.size() > 0 && client.received.size() > 0) {",
        "ins1PreCode":" int i = 0; while (i < WAIT_LOOPS) { if (server.received.size() > 0 && client.received.size() > 0) { break; }",
        "ins2PreCode":"int i = 0; while (i++ < WAIT_LOOPS) { if (server.received.size() > 0 && client.received.size() > 1) { break; }",
        "label":0
    },
    {
        "ins1AddCode":"label_16: break label_16;",
        "ins1DelCode":"label_15: break label_15;",
        "ins1PreCode":"case MINUS: case IDENTIFIER: Expression(); label_15: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[41] = jj_gen; break label_15; } jj_consume_token(COMMA);",
        "ins2PreCode":"case MINUS: case IDENTIFIER: Expression(); label_16: while (true) { switch ((jj_ntk==-1)?jj_ntk():jj_ntk) { case COMMA: ; break; default: jj_la1[43] = jj_gen; break label_16; } jj_consume_token(COMMA);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); oi.subscribe(ts); ",
        "ins2PreCode":"public void assertNotMatchValue() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); oi.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"public Set<Object> keySet() { LinkedHashSet<Object> set = new LinkedHashSet<Object>(super.size());",
        "ins1DelCode":"public Set keySet() { LinkedHashSet set = new LinkedHashSet(super.size());",
        "ins1PreCode":"public Set keySet() {   LinkedHashSet set = new LinkedHashSet(super.size()); Iterator i = super.entrySet().iterator(); while ( i.hasNext() ) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Integer.valueOf(50), user1.getId()); assertEquals(Integer.valueOf(50), user2.getId());",
        "ins1DelCode":"assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId());",
        "ins1PreCode":"User user2 = new User(null, \"Valentina\"); userMapper.insert(user2); sqlSession.flushStatements(); assertEquals(new Integer(50), user1.getId()); assertEquals(new Integer(50), user2.getId()); sqlSession.commit(); }",
        "ins2PreCode":"User user2 = new User(null, \"Valentina\"); userMapper.insertIdentity(user2); sqlSession.flushStatements(); assertEquals(Integer.valueOf(0), user1.getId()); assertEquals(Integer.valueOf(0), user1.getId()); sqlSession.commit(); }",
        "label":0
    },
    {
        "ins1AddCode":"LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, timestampPreferences, fileMonitor).resolve(parserResult);",
        "ins1DelCode":"LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult);",
        "ins1PreCode":"Path texFile = Path.of(TexBibEntriesResolverTest.class.getResource(\"paper.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile);  LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult); ",
        "ins2PreCode":"Path texFile = Path.of(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult);",
        "label":1
    },
    {
        "ins1AddCode":"Assume.assumeTrue(loginFailureMessage, loginSuceeded); Assume.assumeTrue(\"Could not change remote directory\", changeRemoteDir(remoteTmpDir)); FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(buildRule.getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"ALPHA/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"});",
        "ins1DelCode":"if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"ALPHA/\"}); ds.setCaseSensitive(false); ds.scan(); compareFiles(ds, new String[] {\"alpha/beta/beta.xml\", \"alpha/beta/gamma/gamma.xml\"}, new String[] {\"alpha\", \"alpha/beta\", \"alpha/beta/gamma\"}); } }",
        "ins1PreCode":"public void test2ButCaseInsensitive() { if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"ALPHA/\"}); ds.setCaseSensitive(false);",
        "ins2PreCode":"public void test2bisButCaseInsensitive() { if (loginSuceeded) { if (changeRemoteDir(remoteTmpDir)) { FTP.FTPDirectoryScanner ds = myFTPTask.newScanner(ftp); ds.setBasedir(new File(getProject().getBaseDir(), \"tmp\")); ds.setIncludes(new String[] {\"alpha/BETA/gamma/\"}); ds.setCaseSensitive(false);",
        "label":1
    },
    {
        "ins1AddCode":"List<LabeledPoint> trainingBatch = Arrays.asList( attachTestInputStream(ssc, Arrays.asList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Arrays.asList( attachTestInputStream(ssc, Arrays.asList(testBatch, testBatch), 2));",
        "ins1DelCode":"List<LabeledPoint> trainingBatch = Lists.newArrayList( attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2));",
        "ins1PreCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Lists.newArrayList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2)); StreamingLogisticRegressionWithSGD slr = new StreamingLogisticRegressionWithSGD() .setNumIterations(2)",
        "ins2PreCode":"public void javaAPI() { List<LabeledPoint> trainingBatch = Lists.newArrayList( new LabeledPoint(1.0, Vectors.dense(1.0)), new LabeledPoint(0.0, Vectors.dense(0.0))); JavaDStream<LabeledPoint> training = attachTestInputStream(ssc, Lists.newArrayList(trainingBatch, trainingBatch), 2); List<Tuple2<Integer, Vector>> testBatch = Lists.newArrayList( new Tuple2<Integer, Vector>(10, Vectors.dense(1.0)), new Tuple2<Integer, Vector>(11, Vectors.dense(0.0))); JavaPairDStream<Integer, Vector> test = JavaPairDStream.fromJavaDStream( attachTestInputStream(ssc, Lists.newArrayList(testBatch, testBatch), 2)); StreamingLinearRegressionWithSGD slr = new StreamingLinearRegressionWithSGD() .setNumIterations(2)",
        "label":1
    },
    {
        "ins1AddCode":"if ( entry != null && entry.isPrimary() ) set.add(entry.getValue());",
        "ins1DelCode":"if ( entry != null && entry.isPrimary() ) set.add(entry);",
        "ins1PreCode":"Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry != null && entry.isPrimary() ) set.add(entry); } return Collections.unmodifiableSet(set);",
        "ins2PreCode":"Map.Entry e = (Map.Entry)i.next(); Object key = e.getKey(); MapEntry entry = (MapEntry)super.get(key); if ( entry!=null && entry.isPrimary() ) set.add(key); } return Collections.unmodifiableSet(set);",
        "label":0
    },
    {
        "ins1AddCode":"final SortedMap<Integer, TestBuild> runs = new TreeMap<>();",
        "ins1DelCode":"final SortedMap<Integer, TestBuild> runs = new TreeMap<Integer, TestBuild>();",
        "ins1PreCode":"public void testGetEstimatedDurationIfNoSuccessfulBuildTakeDurationOfFailedBuild() throws IOException {  final SortedMap<Integer, TestBuild> runs = new TreeMap<Integer, TestBuild>();  Job project = createMockProject(runs);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(result, failedWith(6)); assertThat(result.stderr(), containsString(\"ERROR: user is missing the Slave/Connect permission\"));",
        "ins1DelCode":"assertThat(result, failedWith(1)); assertThat(result.stderr(), containsString(\"user is missing the Slave/Connect permission\"));",
        "ins1PreCode":".authorizedTo(Jenkins.READ) .invokeWithArgs(\"aNode\");  assertThat(result, failedWith(1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"user is missing the Slave/Connect permission\"));",
        "ins2PreCode":".authorizedTo(Jenkins.READ) .invokeWithArgs(\"aNode\") assertThat(result, failedWith(-1)); assertThat(result, hasNoStandardOutput()); assertThat(result.stderr(), containsString(\"user is missing the Slave/Delete permission\"));",
        "label":0
    },
    {
        "ins1AddCode":"threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS))) {",
        "ins1DelCode":"threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) {",
        "ins1PreCode":"}  try (NioHttpServerTransport transport = new NioHttpServerTransport(settings, networkService, bigArrays, pageRecycler, threadPool, xContentRegistry(), dispatcher, new NioGroupFactory(settings, logger))) { transport.start(); final TransportAddress remoteAddress = randomFrom(transport.boundAddress().boundAddresses());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Map<String, JarEntry> genericEntries = genericJar.stream() je -> je, (a, b) -> b)); Map<String, JarEntry> wasEntries = wasJar.stream() .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b)); Map<String, JarEntry> replaceEntries = new HashMap<>();",
        "ins1DelCode":"Hashtable<String, JarEntry> genericEntries = StreamUtils.enumerationAsStream(genericJar.entries()) je -> je, (a, b) -> b, Hashtable::new)); Hashtable<String, JarEntry> wasEntries = StreamUtils.enumerationAsStream(wasJar.entries()) .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new)); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>();",
        "ins1PreCode":"wasJar = new JarFile(websphereJarFile);   Hashtable<String, JarEntry> genericEntries = StreamUtils.enumerationAsStream(genericJar.entries()) .collect(Collectors.toMap(je -> je.getName().replace('\\\\', '/'), je -> je, (a, b) -> b, Hashtable::new));   Hashtable<String, JarEntry> wasEntries = StreamUtils.enumerationAsStream(wasJar.entries()) .collect(Collectors.toMap(ZipEntry::getName, je -> je, (a, b) -> b, Hashtable::new));   genericLoader = getClassLoaderFromJar(genericJarFile);  Hashtable<String, JarEntry> replaceEntries = new Hashtable<>(); for (String filepath : genericEntries.keySet()) { if (!wasEntries.containsKey(filepath)) {",
        "ins2PreCode":"wlJar = new JarFile(weblogicJarFile); Hashtable<String, JarEntry> genericEntries = new Hashtable<>(); for (Enumeration<JarEntry> e = genericJar.entries(); e.hasMoreElements();) { genericEntries.put(je.getName().replace('\\\\', '/'), je); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); for (Enumeration<JarEntry> e = wlJar.entries(); e.hasMoreElements();) { log(\"Non class file \" + genericEntry.getName() Hashtable<String, JarEntry> wlEntries = new Hashtable<>(); genericLoader = getClassLoaderFromJar(genericJarFile); Hashtable<String, JarEntry> replaceEntries = new Hashtable<>(); for (Enumeration<String> e = genericEntries.keys(); e.hasMoreElements();) { if (wlEntries.containsKey(filepath)) {",
        "label":0
    },
    {
        "ins1AddCode":"} catch (NullPointerException | CommunicationException | ServiceUnavailableException e) {",
        "ins1DelCode":"} catch (NullPointerException e) { } catch (CommunicationException e) { containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); if (context != null) close(context); context = open(); principal = authenticate(context, username, credentials); } catch (ServiceUnavailableException e) { containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); if (context != null) close(context); context = open(); principal = authenticate(context, username, credentials);",
        "ins1PreCode":" principal = authenticate(context, username, credentials);  } catch (NullPointerException e) {     containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials);  } catch (CommunicationException e) {   containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e);   if (context != null) close(context);   context = open();   principal = authenticate(context, username, credentials);  } catch (ServiceUnavailableException e) {  ",
        "ins2PreCode":"principal = getPrincipal(context, username, gssCredential); } catch (NamingException e) { containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } catch (CommunicationException e) { containerLog.info(sm.getString(\"jndiRealm.exception.retry\"), e); if (context != null) close(context); context = open(); principal = getPrincipal(context, username, gssCredential); } catch (ServiceUnavailableException e) {",
        "label":0
    },
    {
        "ins1AddCode":"stmt +=                             \" ORDER BY SCHEMA_NAME, TABLE_NAME, COLUMN_NAME LIMIT \" + maxResults;",
        "ins1DelCode":"stmt +=                             \" ORDER BY COLUMN_NAME LIMIT \" + maxResults;",
        "ins1PreCode":"String stmt =                       \"SELECT SCHEMA_NAME, TABLE_NAME, COLUMN_NAME, COMMENTS FROM SYS.TABLE_COLUMNS WHERE\"; stmt += caseSensitive ?             \" COLUMN_NAME LIKE ?\" : \" UPPER(COLUMN_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY COLUMN_NAME LIMIT \" + maxResults;  DBRProgressMonitor monitor = session.getProgressMonitor();",
        "ins2PreCode":"String stmt =                       \"SELECT SCHEMA_NAME, VIEW_NAME, COLUMN_NAME, COMMENTS FROM SYS.VIEW_COLUMNS WHERE\"; stmt += caseSensitive ?             \" COLUMN_NAME LIKE ?\" : \" UPPER(COLUMN_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY COLUMN_NAME LIMIT \" + maxResults; DBRProgressMonitor monitor = session.getProgressMonitor();",
        "label":1
    },
    {
        "ins1AddCode":"Quarter q1 = new Quarter(new Date(1017619199999L), zone, Locale.getDefault()); Quarter q2 = new Quarter(new Date(1017619200000L), zone, Locale.getDefault());",
        "ins1DelCode":"Quarter q1 = new Quarter(new Date(1017619199999L), zone); Quarter q2 = new Quarter(new Date(1017619200000L), zone);",
        "ins1PreCode":" TimeZone zone = TimeZone.getTimeZone(\"GMT\"); Calendar cal = Calendar.getInstance(zone); Quarter q1 = new Quarter(new Date(1017619199999L), zone); Quarter q2 = new Quarter(new Date(1017619200000L), zone);  assertEquals(1, q1.getQuarter());",
        "ins2PreCode":"TimeZone zone = TimeZone.getTimeZone(\"Europe/Istanbul\"); Calendar cal = Calendar.getInstance(zone); Quarter q1 = new Quarter(new Date(1017608399999L), zone); Quarter q2 = new Quarter(new Date(1017608400000L), zone); assertEquals(1, q1.getQuarter());",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result); Assert.assertEquals(\"The second result is not correct.\", \"Hello, Unweaved World!\", result);",
        "ins1DelCode":"assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result); assertEquals(\"The second result is not correct.\", \"Hello, Unweaved World!\", result);",
        "ins1PreCode":"this.loader.removeTransformer(removed);  String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Unweaved World!\", result); ",
        "ins2PreCode":"this.loader.removeTransformer(removed); String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result); result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result);",
        "label":1
    },
    {
        "ins1AddCode":"state == AsyncState.READ_WRITE_OP ||",
        "ins1DelCode":"",
        "ins1PreCode":"if (state == AsyncState.STARTING) { state = AsyncState.MUST_DISPATCH; } else if (state == AsyncState.STARTED || state == AsyncState.TIMING_OUT || state == AsyncState.ERROR) { state = AsyncState.DISPATCHING;",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ClassLoader oldCL = processor.getUpgradeToken().getContextBind().bind(false, null); processor.getUpgradeToken().getContextBind().unbind(false, oldCL);",
        "ins1DelCode":"Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); thread.setContextClassLoader(processor.getUpgradeToken().getApplicationClassLoader()); thread.setContextClassLoader(originalClassLoader);",
        "ins1PreCode":"if (listener == null) { return; } Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(processor.getUpgradeToken().getApplicationClassLoader()); listener.onError(t); } catch (Throwable t2) { ExceptionUtils.handleThrowable(t2); log.warn(sm.getString(\"upgrade.sos.onErrorFail\"), t2); } finally { thread.setContextClassLoader(originalClassLoader); } try {",
        "ins2PreCode":"if (listener == null) { return; } Thread thread = Thread.currentThread(); ClassLoader originalClassLoader = thread.getContextClassLoader(); try { thread.setContextClassLoader(processor.getUpgradeToken().getApplicationClassLoader()); listener.onError(t); } catch (Throwable t2) { ExceptionUtils.handleThrowable(t2); log.warn(sm.getString(\"upgrade.sis.onErrorFail\"), t2); } finally { thread.setContextClassLoader(originalClassLoader); } try {",
        "label":1
    },
    {
        "ins1AddCode":"final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<>(); final AtomicReference<Observer<? super Object>> ref = new AtomicReference<>();",
        "ins1DelCode":"final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<Observer<? super Object>>(); final AtomicReference<Observer<? super Object>> ref = new AtomicReference<Observer<? super Object>>();",
        "ins1PreCode":"public void disposeMainBoundaryCompleteRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<Observer<? super Object>>(); final AtomicReference<Observer<? super Object>> ref = new AtomicReference<Observer<? super Object>>();  final TestObserver<Observable<Object>> to = new Observable<Object>() {",
        "ins2PreCode":"public void disposeMainBoundaryErrorRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { final AtomicReference<Observer<? super Object>> refMain = new AtomicReference<Observer<? super Object>>(); final AtomicReference<Observer<? super Object>> ref = new AtomicReference<Observer<? super Object>>(); final TestObserver<Observable<Object>> to = new Observable<Object>() {",
        "label":1
    },
    {
        "ins1AddCode":"output.show(false);",
        "ins1DelCode":"System.out.println(output.select(\"userFeatures\", \"features\").first());",
        "ins1PreCode":" Dataset<Row> output = vectorSlicer.transform(dataset);  System.out.println(output.select(\"userFeatures\", \"features\").first());  spark.stop();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"DefaultPieDataset<String> data = new DefaultPieDataset<>();",
        "ins1DelCode":"DefaultPieDataset data = new DefaultPieDataset();",
        "ins1PreCode":"public void setUp() { DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", 43.2); data.setValue(\"Visual Basic\", 0.0);",
        "ins2PreCode":"private static JFreeChart createPieChart() { DefaultPieDataset data = new DefaultPieDataset(); data.setValue(\"Java\", 43.2); data.setValue(\"Visual Basic\", 0.0);",
        "label":1
    },
    {
        "ins1AddCode":"new HashMap<String, Integer>() {{",
        "ins1DelCode":"new HashMap() {{",
        "ins1PreCode":"SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap() {{ put(\"id\", 1); }});",
        "ins2PreCode":"SqlSession session = sqlMapper.openSession(); try { List<Post> posts = session.selectList(\"domain.blog.mappers.PostMapper.findPost\", new HashMap() {{ put(\"blog_id\", 1); }});",
        "label":1
    },
    {
        "ins1AddCode":"return Arrays.asList(out).iterator();",
        "ins1DelCode":"return Lists.newArrayList(out).iterator();",
        "ins1PreCode":"while (in.hasNext()) { out = out + in.next().toUpperCase(); } return Lists.newArrayList(out).iterator(); }); JavaTestUtils.attachTestOutputStream(mapped);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"when(() -> mapper.insertAuthorInvalidSelectKey(author));",
        "ins1DelCode":"when(mapper).insertAuthorInvalidSelectKey(author);",
        "ins1PreCode":"try { BoundAuthorMapper mapper = session.getMapper(BoundAuthorMapper.class); Author author = new Author(-1, \"cbegin\", \"******\", \"cbegin@nowhere.com\", \"N/A\", Section.NEWS); when(mapper).insertAuthorInvalidSelectKey(author); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining( \"### The error may exist in org/apache/ibatis/binding/BoundAuthorMapper.xml\" + System.lineSeparator() +",
        "ins2PreCode":"try { BoundAuthorMapper mapper = session.getMapper(BoundAuthorMapper.class); Author author = new Author(-1, \"cbegin\", \"******\", \"cbegin@nowhere.com\", \"N/A\", Section.NEWS); when(mapper).insertAuthorInvalidInsert(author); then(caughtException()).isInstanceOf(PersistenceException.class).hasMessageContaining( \"### The error may exist in org/apache/ibatis/binding/BoundAuthorMapper.xml\" + System.lineSeparator() +",
        "label":1
    },
    {
        "ins1AddCode":"ParserResult result = parser.parse( Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"ParserResult result = BibtexParser.parse( Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"public void parseIgnoresAndWarnsAboutCorruptedEntryButRecognizeOthers() throws IOException {  ParserResult result = BibtexParser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences, fileMonitor);  assertTrue(result.hasWarnings());  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"iae.initCause(e);",
        "ins1DelCode":"jdkCompat.chainException(iae, e);",
        "ins1PreCode":"} catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for role \" + role); jdkCompat.chainException(iae, e); throw iae; }",
        "ins2PreCode":"} catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException database.removeRole(role); jdkCompat.chainException(iae, e); throw iae; }",
        "label":1
    },
    {
        "ins1AddCode":"void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { Assertions.assertThrows(ExecutorException.class, author2::getId);",
        "ins1DelCode":"public void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins1PreCode":"public void shouldNotLetReadUnloadedPropertyAfterTwoSerializations() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize(deserialize(serialize((Serializable) proxy)))); Assertions.assertThrows(ExecutorException.class, () -> { author2.getId(); });",
        "ins2PreCode":"public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { ResultLoaderMap loader = new ResultLoaderMap(); loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<>(), new ArrayList<>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); public void shouldCreateAProxyForAPartiallyLoadedBean() throws Exception { assertTrue(author2 instanceof Proxy); }",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertEquals((double)0, exec(\"def d = BigInteger.valueOf(0); double b = d; b\"));",
        "ins1PreCode":"assertEquals((double)0, exec(\"def d = Long.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = BigInteger.valueOf(0); double b = d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = d;\"));",
        "ins2PreCode":"assertEquals((double)0, exec(\"def d = Long.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Integer.valueOf(0); double b = (double)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = (double)d;\"));",
        "label":0
    },
    {
        "ins1AddCode":"void lombokSimplePropertyWithOnlyGetterOnClassShouldNotBeExposed() throws IOException {",
        "ins1DelCode":"public void lombokSimplePropertyWithOnlyGetterOnClassShouldNotBeExposed() throws IOException {",
        "ins1PreCode":"public void lombokSimplePropertyWithOnlyGetterOnClassShouldNotBeExposed() throws IOException { process(LombokSimpleProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleProperties.class);",
        "ins2PreCode":"public void lombokSimplePropertyWithOnlyGetterOnDataClassShouldNotBeExposed() throws IOException { process(LombokSimpleDataProperties.class, (roundEnv, metadataEnv) -> { TypeElement ownerElement = roundEnv.getRootElement(LombokSimpleDataProperties.class);",
        "label":1
    },
    {
        "ins1AddCode":"clone.legendLine = ShapeUtils.clone(this.legendLine);",
        "ins1DelCode":"clone.legendLine = ShapeUtilities.clone(this.legendLine);",
        "ins1PreCode":"clone.seriesLinesVisible = (BooleanList) this.seriesLinesVisible.clone(); if (this.legendLine != null) { clone.legendLine = ShapeUtilities.clone(this.legendLine); } clone.seriesShapesVisible",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "ins1PreCode":"assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleWeb.class)).isFalse(); assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isFalse(); assertThat(excludes(filter, ExampleServerHttpSecurity.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, 3000, null, null);",
        "ins1DelCode":"int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, null);",
        "ins1PreCode":"private void assertPageContains(String pageUrl, String expectedBody, int expectedStatus) throws IOException { ByteChunk res = new ByteChunk(); int sc = getUrl(\"http://localhost:\" + getPort() + pageUrl, res, null);  assertEquals(expectedStatus, sc);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 33; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 35; i++) jj_la1[i] = -1;",
        "ins1PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"token = new Token(); jj_ntk = -1; jj_gen = 0; for (int i = 0; i < 35; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"this.contextRunner .withPropertyValues(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .run(context -> { CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = context.getBean( \"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(securityInterceptor, \"cloudFoundrySecurityService\"); assertThat(interceptorSecurityService).isNull(); });",
        "ins1DelCode":"TestPropertyValues .of(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .applyTo(this.context); setupContext(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = this.context.getBean( \"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class); Object securityInterceptor = ReflectionTestUtils.getField(handlerMapping, \"securityInterceptor\"); Object interceptorSecurityService = ReflectionTestUtils .getField(securityInterceptor, \"cloudFoundrySecurityService\"); assertThat(interceptorSecurityService).isNull();",
        "ins1PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { TestPropertyValues .of(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .applyTo(this.context); setupContext(); this.context.refresh(); CloudFoundryWebFluxEndpointHandlerMapping handlerMapping = this.context.getBean( \"cloudFoundryWebFluxEndpointHandlerMapping\", CloudFoundryWebFluxEndpointHandlerMapping.class);",
        "ins2PreCode":"public void cloudFoundryPlatformActiveAndCloudControllerUrlNotPresent() { TestPropertyValues .of(\"VCAP_APPLICATION:---\", \"vcap.application.application_id:my-app-id\") .applyTo(this.context); this.context.refresh(); this.context.refresh(); CloudFoundryWebEndpointServletHandlerMapping handlerMapping = this.context .getBean(\"cloudFoundryWebEndpointServletHandlerMapping\", CloudFoundryWebEndpointServletHandlerMapping.class);",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue(); assertThat(graphAsMutableGraph.removeNode(N1)).isTrue();",
        "ins1DelCode":"assertThat(graph.removeNode(N1)).isTrue();",
        "ins1PreCode":"addNode(N1); @SuppressWarnings(\"unused\") Set<Integer> unused = graph.adjacentNodes(N1); assertThat(graph.removeNode(N1)).isTrue(); try { graph.adjacentNodes(N1);",
        "ins2PreCode":"addNode(N1); @SuppressWarnings(\"unused\") Set<Integer> unused = graph.adjacentNodes(N1); assertThat(graph.removeNode(N1)).isTrue(); try { graph.adjacentNodes(N1);",
        "label":1
    },
    {
        "ins1AddCode":"bundle = ResourceBundle.getBundle(bundleName, Locale.getDefault()); ClassLoader cl = Thread.currentThread().getContextClassLoader(); bundle = ResourceBundle.getBundle( bundleName, Locale.getDefault(), cl); } if (bundle != null) { locale = bundle.getLocale();",
        "ins1DelCode":"bundle = ResourceBundle.getBundle(bundleName); return; ClassLoader cl=Thread.currentThread().getContextClassLoader(); bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl); return; if( cl==null ) cl=this.getClass().getClassLoader(); if (log.isDebugEnabled()) log.debug(\"Can't find resource \" + bundleName + \" \" + cl); if( cl instanceof URLClassLoader ) { if (log.isDebugEnabled()) log.debug( ((URLClassLoader)cl).getURLs()); }",
        "ins1PreCode":"private StringManager(String packageName) { String bundleName = packageName + \".LocalStrings\"; try { bundle = ResourceBundle.getBundle(bundleName); return; } catch( MissingResourceException ex ) {  ClassLoader cl=Thread.currentThread().getContextClassLoader(); if( cl != null ) { try { bundle=ResourceBundle.getBundle(bundleName, Locale.getDefault(), cl); return; } catch(MissingResourceException ex2) { } } if( cl==null ) cl=this.getClass().getClassLoader();  if (log.isDebugEnabled()) log.debug(\"Can't find resource \" + bundleName + \" \" + cl); if( cl instanceof URLClassLoader ) { if (log.isDebugEnabled()) log.debug( ((URLClassLoader)cl).getURLs()); } }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (getStore() instanceof StoreBase) {",
        "ins1DelCode":"if ((getStore() != null) && (getStore() instanceof StoreBase)) {",
        "ins1PreCode":"} } processPersistenceChecks(); if ((getStore() != null) && (getStore() instanceof StoreBase)) { ((StoreBase) getStore()).processExpires(); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"throw new AbortException(CLI_LISTPARAM_SUMMARY_ERROR_TEXT);",
        "ins1DelCode":"throw new AbortException(\"Error occured while performing this command, see previous stderr output.\");",
        "ins1PreCode":"}  if (errorOccurred) { throw new AbortException(\"Error occured while performing this command, see previous stderr output.\"); } return 0;",
        "ins2PreCode":"} if (errorOccurred) { throw new AbortException(\"Error occured while performing this command, see previous stderr output.\"); } return 0;",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<>(new FlowableSubscriber<Integer>() {",
        "ins1DelCode":"TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(new FlowableSubscriber<Integer>() {",
        "ins1PreCode":"public void completeDelegateThrows() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(new FlowableSubscriber<Integer>() {  @Override",
        "ins2PreCode":"public void errorDelegateThrows() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(new FlowableSubscriber<Integer>() { @Override",
        "label":1
    },
    {
        "ins1AddCode":"JDBCPreparedStatement dbStat; if (owner.getDataSource().isAtLeastV10() && forTable != null) { sql.append(\"SELECT \\r\\n\" + \"    c.TABLE_NAME,\\r\\n\" + \"    c.CONSTRAINT_NAME,\\r\\n\" + \"    c.CONSTRAINT_TYPE,\\r\\n\" + \"    c.STATUS,\\r\\n\" + \"    c.R_OWNER,\\r\\n\" + \"    c.R_CONSTRAINT_NAME,\\r\\n\" + \"    (SELECT rc.TABLE_NAME FROM \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONSTRAINTS\") + \" rc WHERE rc.OWNER = c.r_OWNER AND rc.CONSTRAINT_NAME = c.R_CONSTRAINT_NAME) AS R_TABLE_NAME,\\r\\n\" + \"    c.DELETE_RULE,\\r\\n\" + \"    (\\r\\n\" + \"        SELECT LTRIM(MAX(SYS_CONNECT_BY_PATH(cname || ':' || p,','))    KEEP (DENSE_RANK LAST ORDER BY curr),',') \\r\\n\" + \"        FROM   (SELECT \\r\\n\" + \"                       col.CONSTRAINT_NAME cn,col.POSITION p,col.COLUMN_NAME cname,\\r\\n\" + \"                       ROW_NUMBER() OVER (PARTITION BY col.CONSTRAINT_NAME ORDER BY col.POSITION) AS curr,\\r\\n\" + \"                       ROW_NUMBER() OVER (PARTITION BY col.CONSTRAINT_NAME ORDER BY col.POSITION) -1 AS prev\\r\\n\" + \"                FROM   \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONS_COLUMNS\") + \" col \\r\\n\" + \"                WHERE  col.OWNER =? AND col.TABLE_NAME = ? AND col.CONSTRAINT_NAME = c.CONSTRAINT_NAME \\r\\n\" + \"                )   GROUP BY cn CONNECT BY prev = PRIOR curr AND cn = PRIOR cn START WITH curr = 1      \\r\\n\" + \"        ) COLUMN_NAMES_NUMS\\r\\n\" + \"FROM\\r\\n\" + \"    \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONSTRAINTS\") + \" c\\r\\n\" + \"WHERE\\r\\n\" + \"    c.CONSTRAINT_TYPE = 'R'\\r\\n\" + \"    AND c.OWNER = ?\\r\\n\" + \"    AND c.TABLE_NAME = ?\"); dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); dbStat.setString(3, OracleSchema.this.getName()); dbStat.setString(4, forTable.getName()); } else { sql.append(\"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" \\r\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,rc.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONSTRAINTS\") + \" c, \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONS_COLUMNS\") + \" col, \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONSTRAINTS\") + \" rc\\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\\n\" + \"AND c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"AND rc.OWNER=c.r_OWNER AND rc.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME\"); if (forTable != null) { sql.append(\" AND c.TABLE_NAME=?\"); } sql.append(\"\\nORDER BY c.CONSTRAINT_NAME,col.POSITION\"); dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); if (forTable != null) { dbStat.setString(2, forTable.getName()); }",
        "ins1DelCode":"sql.append(\"SELECT \" + OracleUtils.getSysCatalogHint(owner.getDataSource()) + \" \\r\\n\" + \"c.TABLE_NAME, c.CONSTRAINT_NAME,c.CONSTRAINT_TYPE,c.STATUS,c.R_OWNER,c.R_CONSTRAINT_NAME,rc.TABLE_NAME as R_TABLE_NAME,c.DELETE_RULE, \\n\" + \"col.COLUMN_NAME,col.POSITION\\r\\n\" + \"FROM \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONSTRAINTS\") + \" c, \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONS_COLUMNS\") + \" col, \" + OracleUtils.getAdminAllViewPrefix(session.getProgressMonitor(), getDataSource(), \"CONSTRAINTS\") + \" rc\\n\" + \"WHERE c.CONSTRAINT_TYPE='R' AND c.OWNER=?\\n\" + \"AND c.OWNER=col.OWNER AND c.CONSTRAINT_NAME=col.CONSTRAINT_NAME\\n\" + \"AND rc.OWNER=c.r_OWNER AND rc.CONSTRAINT_NAME=c.R_CONSTRAINT_NAME\"); if (forTable != null) { sql.append(\" AND c.TABLE_NAME=?\"); } sql.append(\"\\nORDER BY c.CONSTRAINT_NAME,col.POSITION\"); JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); if (forTable != null) {",
        "ins1PreCode":"} sql.append(\"\\nORDER BY c.CONSTRAINT_NAME,col.POSITION\");  JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); if (forTable != null) {",
        "ins2PreCode":"} sql.append(\"\\nORDER BY c.CONSTRAINT_NAME,col.POSITION\"); JDBCPreparedStatement dbStat = session.prepareStatement(sql.toString()); dbStat.setString(1, OracleSchema.this.getName()); if (forTable != null) {",
        "label":1
    },
    {
        "ins1AddCode":"public void testMaxHistoryProperty() {",
        "ins1DelCode":"public void testMaxHistoryProperty() throws Exception {",
        "ins1PreCode":"public void testMaxHistoryProperty() throws Exception { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\");",
        "ins2PreCode":"public void testMaxHistoryProperty() { MockEnvironment environment = new MockEnvironment(); environment.setProperty(\"logging.file.max-history\", \"30\");",
        "label":1
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); try { } finally { sqlSession.close();",
        "ins1PreCode":"public void testInsertBlobThenSelectAll() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { BlobMapper blobMapper = sqlSession.getMapper(BlobMapper.class);  byte[] myblob = new byte[] {1, 2, 3, 4, 5}; BlobRecord blobRecord = new BlobRecord(1, myblob); int rows = blobMapper.insert(blobRecord); assertEquals(1, rows);   List<BlobRecord> results = blobMapper.selectAll();  assertEquals(1, results.size()); BlobRecord result = results.get(0); assertEquals (blobRecord.getId(), result.getId()); assertTrue (blobsAreEqual(blobRecord.getBlob(), result.getBlob())); } finally { sqlSession.close(); }",
        "ins2PreCode":"public void testInsertBlobObjectsThenSelectAll() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { BlobMapper blobMapper = sqlSession.getMapper(BlobMapper.class); Byte[] myblob = new Byte[] {1, 2, 3, 4, 5}; BlobRecord blobRecord = new BlobRecord(1, myblob); int rows = blobMapper.insert(blobRecord); assertEquals(1, rows); List<BlobRecord> results = blobMapper.selectAllWithBlobObjects(); assertEquals(1, results.size()); BlobRecord result = results.get(0); assertEquals (blobRecord.getId(), result.getId()); assertTrue (blobsAreEqual(blobRecord.getBlob(), result.getBlob())); } finally { sqlSession.close(); }",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graph.allowsSelfLoops()).isTrue();",
        "ins1DelCode":"assume().that(allowsSelfLoops()).isTrue();",
        "ins1PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue();  putEdge(N1, N1);",
        "ins2PreCode":"public void successors_selfLoop() { assume().that(allowsSelfLoops()).isTrue(); putEdge(N1, N1);",
        "label":1
    },
    {
        "ins1AddCode":"void ofNameWhenDotOnAssociative() {",
        "ins1DelCode":"public void ofNameWhenDotOnAssociative() {",
        "ins1PreCode":"public void ofNameWhenDotOnAssociative() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.bar\"); assertThat(name.toString()).isEqualTo(\"foo.bar\");",
        "ins2PreCode":"public void ofNameWhenDotAndAssociative() { ConfigurationPropertyName name = ConfigurationPropertyName.of(\"foo.[bar]\"); assertThat(name.toString()).isEqualTo(\"foo[bar]\");",
        "label":1
    },
    {
        "ins1AddCode":"String action = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String direction = event.getRequestType() == TransferEvent.RequestType.PUT ? \"to\" : \"from\"; FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH ); StringBuilder message = new StringBuilder(); message.append( action ).append( ' ' ).append( direction ).append( ' ' ).append( resource.getRepositoryId() ); message.append( \": \" ); message.append( resource.getRepositoryUrl() ).append( resource.getResourceName() ); message.append( \" (\" ).append( format.format( contentLength ) ); message.append( \" at \" ).append( format.format( (long) bytesPerSecond ) ).append( \"/s\" ); throughput + \")\" ); message.append( ')' ); out.println( message.toString() );",
        "ins1DelCode":"FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH ); String result = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = format.format( contentLength ); String throughput = \"\"; throughput = \" at \" + format.format( (long) bytesPerSecond ) + \"/s\"; out.println( result + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" );",
        "ins1PreCode":"long contentLength = event.getTransferredBytes();  FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH ); String result = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = format.format( contentLength );  String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0L ) { double bytesPerSecond = contentLength / ( duration / 1000.0 ); throughput = \" at \" + format.format( (long) bytesPerSecond ) + \"/s\"; }  out.println( result + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" );",
        "ins2PreCode":"long contentLength = event.getTransferredBytes(); FileSizeFormat format = new FileSizeFormat( Locale.ENGLISH ); String result = ( event.getRequestType() == TransferEvent.RequestType.PUT ? \"Uploaded\" : \"Downloaded\" ); String len = format.format( contentLength ); String throughput = \"\"; long duration = System.currentTimeMillis() - resource.getTransferStartTime(); if ( duration > 0L ) { double bytesPerSecond = contentLength / ( duration / 1000.0 ); throughput = \" at \" + format.format( (long) bytesPerSecond ) + \"/s\"; } out.info( result + \": \" + resource.getRepositoryUrl() + resource.getResourceName() + \" (\" + len + throughput + \")\" );",
        "label":1
    },
    {
        "ins1AddCode":"for (XYPlot plot : this.subplots) {",
        "ins1DelCode":"Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { XYPlot plot = (XYPlot) iterator.next();",
        "ins1PreCode":"result = new LegendItemCollection();  if (this.subplots != null) { Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { XYPlot plot = (XYPlot) iterator.next(); LegendItemCollection more = plot.getLegendItems(); result.addAll(more);",
        "ins2PreCode":"result = new LegendItemCollection(); if (this.subplots != null) { Iterator iterator = this.subplots.iterator(); while (iterator.hasNext()) { CategoryPlot plot = (CategoryPlot) iterator.next(); LegendItemCollection more = plot.getLegendItems(); result.addAll(more);",
        "label":1
    },
    {
        "ins1AddCode":"void testWithPrepared() {",
        "ins1DelCode":"public void testWithPrepared() {",
        "ins1PreCode":"public void testWithPrepared() { test(mapper -> mapper.getUserWithPreparedAndUnset(new RowBounds(5, 3)), 0); test(mapper -> mapper.getUserWithPreparedAndDefault(new RowBounds(4, 3)), 1);",
        "ins2PreCode":"public void testWithCallable() { test(mapper -> mapper.getUserWithCallableAndUnset(new RowBounds(5, 3)), 0); test(mapper -> mapper.getUserWithCallableAndDefault(new RowBounds(4, 3)), 1);",
        "label":1
    },
    {
        "ins1AddCode":"return value -> if ( value != null && value.contains( \"${\" ) ) String c = cache.get( value ); if ( c == null ) try c = interpolator.interpolate( value, recursionInterceptor ); catch ( InterpolationException e ) { problems.add( new ModelProblemCollectorRequest( Severity.ERROR, Version.BASE ) .setMessage( e.getMessage() ).setException( e ) ); } cache.put( value, c ); return c; return value;",
        "ins1DelCode":"return new InnerInterpolator() @Override public String interpolate( String value ) if ( value != null && value.contains( \"${\" ) ) String c = cache.get( value ); if ( c == null ) try { c = interpolator.interpolate( value, recursionInterceptor ); } catch ( InterpolationException e ) { problems.add( new ModelProblemCollectorRequest( Severity.ERROR, Version.BASE ) .setMessage( e.getMessage() ).setException( e ) ); } cache.put( value, c ); return c; return value;",
        "ins1PreCode":"interpolator.addPostProcessor( postProcessor ); } final RecursionInterceptor recursionInterceptor = createRecursionInterceptor(); return new InnerInterpolator() { @Override public String interpolate( String value ) { if ( value != null && value.contains( \"${\" ) )",
        "ins2PreCode":"interpolator.addPostProcessor( postProcessor ); } final RecursionInterceptor recursionInterceptor = createRecursionInterceptor(); return new InnerInterpolator() { @Override public String interpolate( String value ) { if ( value != null && value.contains( \"${\" ) )",
        "label":1
    },
    {
        "ins1AddCode":"new URI(\"ftp://\" + getHostName() + \":\" + getPort() +",
        "ins1DelCode":"new URI(\"ftp://localhost:\" + getPort() +",
        "ins1PreCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), new URI(\"ftp://localhost:\" + getPort() + TesterEchoServer.Config.PATH_ASYNC));",
        "ins2PreCode":"ContainerProvider.getWebSocketContainer(); wsContainer.connectToServer(TesterProgrammaticEndpoint.class, ClientEndpointConfig.Builder.create().build(), tomcat.start(); new URI(\"ws://\" + TesterEchoServer.Config.PATH_ASYNC));",
        "label":0
    },
    {
        "ins1AddCode":"for (int i = 0; i < 43; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 36; i++) jj_la1[i] = -1;",
        "ins1PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 36; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"List<Double> values = new ArrayList<>(); values.add(7.0); values.add(2.0); values.add(3.0); values.add(5.0); values.add(4.0); values.add(6.0); values.add(1.0);",
        "ins1DelCode":"List values = new ArrayList(); values.add(new Double(7.0)); values.add(new Double(2.0)); values.add(new Double(3.0)); values.add(new Double(5.0)); values.add(new Double(4.0)); values.add(new Double(6.0)); values.add(new Double(1.0));",
        "ins1PreCode":"public void testCalculateMedian4() { List values = new ArrayList(); values.add(new Double(7.0)); values.add(new Double(2.0)); values.add(new Double(3.0)); values.add(new Double(5.0)); values.add(new Double(4.0)); values.add(new Double(6.0)); values.add(new Double(1.0)); double median = Statistics.calculateMedian(values); assertEquals(4.0, median, 0.0000001);",
        "ins2PreCode":"public void testCalculateMedian6() { List values = new ArrayList(); values.add(new Double(7.0)); values.add(new Double(2.0)); values.add(new Double(3.0)); values.add(new Double(5.0)); values.add(new Double(4.0)); values.add(new Double(6.0)); values.add(new Double(1.0)); double median = Statistics.calculateMedian(values, 0, 2); assertEquals(3.0, median, 0.0000001);",
        "label":1
    },
    {
        "ins1AddCode":"Dataset<Tuple2<String, Double>> agged = grouped.agg( org.apache.spark.sql.expressions.javalang.typed.sum(value -> (double) value._2()));",
        "ins1DelCode":"Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.sum(value -> (double) value._2()));",
        "ins1PreCode":"public void testTypedAggregationSumDouble() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.sum(value -> (double) value._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 3.0)),",
        "ins2PreCode":"public void testTypedAggregationSumDouble() { KeyValueGroupedDataset<String, Tuple2<String, Integer>> grouped = generateGroupedDataset(); Dataset<Tuple2<String, Double>> agged = grouped.agg(typed.sum(v -> (double)v._2())); Assert.assertEquals( Arrays.asList(new Tuple2<>(\"a\", 3.0), new Tuple2<>(\"b\", 3.0)),",
        "label":1
    },
    {
        "ins1AddCode":"return mbean;",
        "ins1DelCode":"return (mbean);",
        "ins1PreCode":"mserver.unregisterMBean(oname); } mserver.registerMBean(mbean, oname); return (mbean); ",
        "ins2PreCode":"mserver.unregisterMBean(oname); } mserver.registerMBean(mbean, oname); return (mbean);",
        "label":1
    },
    {
        "ins1AddCode":"MutableGraph<Integer> undirectedGraph = GraphBuilder.undirected().allowsSelfLoops(false).build(); MutableGraph<Integer> expectedClosure = GraphBuilder.undirected().allowsSelfLoops(true).build();",
        "ins1DelCode":"MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().allowsSelfLoops(false).build(); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.undirected().allowsSelfLoops(true).build();",
        "ins1PreCode":"public void transitiveClosure_undirectedPathGraph() { MutableBasicGraph<Integer> undirectedGraph = BasicGraphBuilder.undirected().allowsSelfLoops(false).build(); undirectedGraph.putEdge(N1, N2); undirectedGraph.putEdge(N2, N3); undirectedGraph.putEdge(N3, N4);  MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.undirected().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "ins2PreCode":"public void transitiveClosure_directedCycleGraph() { MutableBasicGraph<Integer> directedGraph = BasicGraphBuilder.directed().allowsSelfLoops(false).build(); directedGraph.putEdge(N1, N2); directedGraph.putEdge(N2, N3); directedGraph.putEdge(N3, N4); MutableBasicGraph<Integer> expectedClosure = BasicGraphBuilder.directed().allowsSelfLoops(true).build(); expectedClosure.putEdge(N1, N1); expectedClosure.putEdge(N1, N2);",
        "label":1
    },
    {
        "ins1AddCode":"public void getValueOrigin() {",
        "ins1DelCode":"public void getValueOrigin() throws Exception {",
        "ins1PreCode":"public void getValueOrigin() throws Exception { Map<String, Object> source = new LinkedHashMap<>(); source.put(\"key\", \"value\");",
        "ins2PreCode":"public void getValueWhenOriginCapableShouldIncludeSourceOrigin() throws Exception { Map<String, Object> source = new LinkedHashMap<>(); source.put(\"key\", \"value\");",
        "label":1
    },
    {
        "ins1AddCode":"private void initialize() {",
        "ins1DelCode":"private final void initialize() {",
        "ins1PreCode":"private final void initialize() { Parameter[] params = getParameters(); if (params != null) {",
        "ins2PreCode":"private final void initialize() { Parameter[] params = getParameters(); if (params != null) {",
        "label":1
    },
    {
        "ins1AddCode":"TomcatConnectorCustomizer ssl = new SslConnectorCustomizer(getSsl(), getSslStoreProvider()); ssl.customize(connector); TomcatConnectorCustomizer compression = new CompressionConnectorCustomizer(getCompression()); compression.customize(connector);",
        "ins1DelCode":"",
        "ins1PreCode":"  connector.setProperty(\"bindOnInit\", \"false\"); for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) { customizer.customize(connector); }",
        "ins2PreCode":"connector.setProperty(\"bindOnInit\", \"false\"); for (TomcatConnectorCustomizer customizer : this.tomcatConnectorCustomizers) { customizer.customize(connector); }",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue(((TestMRApp) appMaster).getTestIsLastAMRetry());",
        "ins1DelCode":"Assert.assertEquals(true, ((TestMRApp) appMaster).getTestIsLastAMRetry());",
        "ins1PreCode":"appMaster.start(); appMaster.shutDownJob();  Assert.assertEquals(true, ((TestMRApp) appMaster).getTestIsLastAMRetry());  ",
        "ins2PreCode":"appMaster.start(); appMaster.shutDownJob(); Assert.assertEquals(true, ((TestMRApp) appMaster).getTestIsLastAMRetry());",
        "label":1
    },
    {
        "ins1AddCode":"List<Path> dirs = Collections.singletonList(Path.of(FILES_DIRECTORY)); assertEquals(Collections.singletonList(Path.of(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/pdfInSubdirectory.pdf\")),",
        "ins1DelCode":"List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); assertEquals(Collections.singletonList(Paths.get(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/pdfInSubdirectory.pdf\")),",
        "ins1PreCode":" List<String> extensions = Collections.singletonList(\"pdf\");  List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"**/[bibtexkey].*\\\\\\\\.[extension]\", ',');   List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions);   assertEquals(Collections.singletonList(Paths.get(\"src/test/resources/org/jabref/logic/importer/unlinkedFilesTestFolder/directory/subdirectory/pdfInSubdirectory.pdf\")), result);",
        "ins2PreCode":"List<String> extensions = Collections.singletonList(\"pdf\"); List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); RegExpBasedFileFinder fileFinder = new RegExpBasedFileFinder(\"*/[bibtexkey].*\\\\\\\\.[extension]\", ','); List<Path> result = fileFinder.findAssociatedFiles(localEntry, dirs, extensions); List<Path> dirs = Collections.singletonList(Paths.get(FILES_DIRECTORY)); assertTrue(result.isEmpty());",
        "label":0
    },
    {
        "ins1AddCode":"void yamlTwoProfiles() {",
        "ins1DelCode":"public void yamlTwoProfiles() {",
        "ins1PreCode":"public void yamlTwoProfiles() { this.initializer.setSearchNames(\"testprofiles\"); this.environment.setActiveProfiles(\"other\", \"dev\");",
        "ins2PreCode":"public void yamlNegatedProfiles() { this.initializer.setSearchNames(\"testnegatedprofiles\"); property = this.environment.getProperty(\"my.notother\");",
        "label":1
    },
    {
        "ins1AddCode":"importFormatPreferences, fileMonitor);",
        "ins1DelCode":"importFormatPreferences);",
        "ins1PreCode":"ParserResult result = BibtexParser.parse( new StringReader( \"@article{test,author={author missing bracket}\" + \"@article{test,author={Ed von Test}}\"), importFormatPreferences);  assertTrue(result.hasWarnings());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService);",
        "ins1DelCode":"ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService, genericExecutor);",
        "ins1PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService, genericExecutor);  Map<String, Object> config = new HashMap<>();",
        "ins2PreCode":"Processor processor = new TestProcessor(ingestDocument -> { }); Map<String, Processor.Factory> registry = new HashMap<>(); registry.put(\"_name\", (r, t, c) -> processor); ForEachProcessor.Factory forEachFactory = new ForEachProcessor.Factory(scriptService, genericExecutor); Map<String, Object> config = new HashMap<>();",
        "label":1
    },
    {
        "ins1AddCode":"}, true, 16)",
        "ins1DelCode":"}, 16, true)",
        "ins1PreCode":"public ObservableSource<Integer> apply(Integer v) throws Exception { return Observable.range(v, 2); } }, 16, true) .test() .assertResult(1, 2);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Collection<BibEntry> parsed = result.getDatabase().getEntries(); BibEntry entry = parsed.iterator().next(); assertEquals(1, parsed.size()); assertEquals(\"article\", entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(\"author\"));",
        "ins1DelCode":"Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins1PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,author=\\\"Ed von Test\\\"}\"));  Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size());  BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"Ed von Test\"), e.getField(\"author\"));",
        "ins2PreCode":"ParserResult result = parser .parse(new StringReader(\"@article{test,year = 2005}\")); Collection<BibEntry> c = result.getDatabase().getEntries(); assertEquals(1, c.size()); BibEntry e = c.iterator().next(); assertEquals(\"article\", e.getType()); assertEquals(Optional.of(\"test\"), e.getCiteKeyOptional()); assertEquals(2, e.getFieldNames().size()); assertEquals(Optional.of(\"2005\"), e.getField(\"year\"));",
        "label":1
    },
    {
        "ins1AddCode":"void testRemoveTermList(@TempDir Path tempDir) {",
        "ins1DelCode":"void testRemoveTermList(@TempDirectory.TempDir Path tempDir) {",
        "ins1PreCode":"void testRemoveTermList(@TempDirectory.TempDir Path tempDir) {  ProtectedTermsLoader localLoader = new ProtectedTermsLoader(",
        "ins2PreCode":"void testAddNewTermListSetsCorrectDescription(@TempDirectory.TempDir Path tempDir) { ProtectedTermsLoader localLoader = new ProtectedTermsLoader(",
        "label":1
    },
    {
        "ins1AddCode":"assume().that(graphIsMutable()).isTrue();",
        "ins1DelCode":"",
        "ins1PreCode":"public void edges_checkReturnedSetMutability() { Set<String> edges = network.edges(); try { edges.add(E12); fail(ERROR_MODIFIABLE_COLLECTION);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'a', 'b', 'b');",
        "ins1DelCode":"assertThat(graph.requestedNodes).containsExactly('a', 'b'); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');",
        "ins1PreCode":"Iterable<Character> result = Traverser.forGraph(graph).breadthFirst('a');  assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'b');   assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'a', 'b', 'b');",
        "ins2PreCode":"Iterable<Character> result = Traverser.forGraph(graph).depthFirstPreOrder('a'); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd'); assertEqualCharNodes(Iterables.limit(result, 2), \"ab\"); assertThat(graph.requestedNodes).containsExactly('a', 'b', 'd');",
        "label":1
    },
    {
        "ins1AddCode":"void bindToArrayWhenNestedShouldReturnPopulatedArray() {",
        "ins1DelCode":"public void bindToArrayWhenNestedShouldReturnPopulatedArray() {",
        "ins1PreCode":"public void bindToArrayWhenNestedShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0][0]\", \"1\");",
        "ins2PreCode":"public void bindToArrayWhenNestedListShouldReturnPopulatedArray() { MockConfigurationPropertySource source = new MockConfigurationPropertySource(); source.put(\"foo[0][0]\", \"1\");",
        "label":1
    },
    {
        "ins1AddCode":"AsyncObserver<Long> async = new AsyncObserver<>(observer);",
        "ins1DelCode":"AsyncObserver<Long> async = new AsyncObserver<Long>(observer);",
        "ins1PreCode":"SlowObservable so = new SlowObservable(100, 10, \"testTimeoutWithRetry\"); Observable<Long> o = Observable.unsafeCreate(so).timeout(80, TimeUnit.MILLISECONDS).retry(5);  AsyncObserver<Long> async = new AsyncObserver<Long>(observer);  o.subscribe(async);",
        "ins2PreCode":"ObservableRetryTest.SlowObservable so = new ObservableRetryTest.SlowObservable(100, 0, \"testUnsubscribeAfterError\"); Observable<Long> o = Observable ObservableRetryTest.AsyncObserver<Long> async = new ObservableRetryTest.AsyncObserver<Long>(observer); o.subscribe(async);",
        "label":1
    },
    {
        "ins1AddCode":"if (isNullAt(ordinal)) return null; final long offsetAndSize = getLong(ordinal); final int offset = (int) (offsetAndSize >> 32); final int size = (int) offsetAndSize;",
        "ins1DelCode":"assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal);",
        "ins1PreCode":"public UnsafeMapData getMap(int ordinal) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal); if (offset < 0) return null; final int size = getElementSize(offset, ordinal); final UnsafeMapData map = new UnsafeMapData(); map.pointTo(baseObject, baseOffset + offset, size);",
        "ins2PreCode":"public UnsafeMapData getMap(int ordinal) { final long offsetAndSize = getLong(ordinal); final long offsetAndSize = getLong(ordinal); return null; final int size = (int) offsetAndSize; final UnsafeMapData map = new UnsafeMapData(); map.pointTo(baseObject, baseOffset + offset, size);",
        "label":0
    },
    {
        "ins1AddCode":"public static SortedSet<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { SortedSet<SearchBasedFetcher> set = new TreeSet<>(Comparator.comparing(WebFetcher::getName)); set.add(new ArXiv(importFormatPreferences)); set.add(new INSPIREFetcher(importFormatPreferences)); set.add(new GvkFetcher()); set.add(new MedlineFetcher()); set.add(new AstrophysicsDataSystem(importFormatPreferences)); set.add(new MathSciNet(importFormatPreferences)); set.add(new ZbMATH(importFormatPreferences)); set.add(new ACMPortalFetcher(importFormatPreferences)); set.add(new GoogleScholar(importFormatPreferences)); set.add(new DBLPFetcher(importFormatPreferences)); set.add(new SpringerFetcher()); set.add(new CrossRef()); set.add(new CiteSeer()); set.add(new DOAJFetcher(importFormatPreferences)); set.add(new IEEE(importFormatPreferences)); return set;",
        "ins1DelCode":"public static SortedList<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new INSPIREFetcher(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new ACMPortalFetcher(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new SpringerFetcher()); list.add(new CrossRef()); list.add(new CiteSeer()); list.add(new DOAJFetcher(importFormatPreferences)); list.add(new IEEE(importFormatPreferences)); ObservableList<SearchBasedFetcher> observableList = FXCollections.observableList(list); return new SortedList<>(observableList, Comparator.comparing(WebFetcher::getName));",
        "ins1PreCode":"public static SortedList<SearchBasedFetcher> getSearchBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<SearchBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new INSPIREFetcher(importFormatPreferences)); list.add(new GvkFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new ZbMATH(importFormatPreferences)); list.add(new ACMPortalFetcher(importFormatPreferences)); list.add(new GoogleScholar(importFormatPreferences)); list.add(new DBLPFetcher(importFormatPreferences)); list.add(new SpringerFetcher()); list.add(new CrossRef()); list.add(new CiteSeer()); list.add(new DOAJFetcher(importFormatPreferences)); list.add(new IEEE(importFormatPreferences));  ObservableList<SearchBasedFetcher> observableList = FXCollections.observableList(list); return new SortedList<>(observableList, Comparator.comparing(WebFetcher::getName));",
        "ins2PreCode":"public static SortedList<IdBasedFetcher> getIdBasedFetchers(ImportFormatPreferences importFormatPreferences) { ArrayList<IdBasedFetcher> list = new ArrayList<>(); list.add(new ArXiv(importFormatPreferences)); list.add(new RfcFetcher(importFormatPreferences)); list.add(new MedlineFetcher()); list.add(new MedlineFetcher()); list.add(new AstrophysicsDataSystem(importFormatPreferences)); list.add(new MathSciNet(importFormatPreferences)); list.add(new DiVA(importFormatPreferences)); list.add(new TitleFetcher(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new DoiFetcher(importFormatPreferences)); list.add(new MedlineFetcher()); list.add(new CrossRef()); list.add(new CrossRef()); list.add(new DoiFetcher(importFormatPreferences)); list.add(new DiVA(importFormatPreferences)); ObservableList<IdBasedFetcher> observableList = FXCollections.observableList(list); return new SortedList<>(observableList, Comparator.comparing(WebFetcher::getName));",
        "label":1
    },
    {
        "ins1AddCode":"Set<FulltextFetcher> fullTextFetchers = WebFetchers.getFullTextFetchers(importFormatPreferences);",
        "ins1DelCode":"List<FulltextFetcher> fullTextFetchers = WebFetchers.getFullTextFetchers(importFormatPreferences);",
        "ins1PreCode":"void getFullTextFetchersReturnsAllFetcherDerivingFromFullTextFetcher() throws Exception { List<FulltextFetcher> fullTextFetchers = WebFetchers.getFullTextFetchers(importFormatPreferences);  try (ScanResult scanResult = classGraph.scan()) {",
        "ins2PreCode":"void getIdFetchersReturnsAllFetcherDerivingFromIdFetcher() throws Exception { List<IdFetcher> idFetchers = WebFetchers.getIdFetchers(importFormatPreferences); try (ScanResult scanResult = classGraph.scan()) {",
        "label":1
    },
    {
        "ins1AddCode":"remaining = Math.min(remaining, len); nRead = Math.min(nRead, len); readBuffer.get(b, off, nRead); return nRead;",
        "ins1DelCode":"if (remaining >= len) { readBuffer.get(b, off, len); return len; } if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead;",
        "ins1PreCode":"int remaining = readBuffer.remaining();   if (remaining >= len) { readBuffer.get(b, off, len); return len; }   if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining;        }   int nRead = fillReadBuffer(block);    if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead; }",
        "ins2PreCode":"int remaining = readBuffer.remaining(); if (remaining >= len) { readBuffer.get(b, off, len); return len; } if (remaining > 0) { readBuffer.get(b, off, remaining); return remaining; } int nRead = fillReadBuffer(block); if (nRead > 0) { socketBufferHandler.configureReadBufferForRead(); if (nRead > len) { readBuffer.get(b, off, len); return len; } else { readBuffer.get(b, off, nRead); return nRead; } } else { return nRead; }",
        "label":1
    },
    {
        "ins1AddCode":"FileUtilities.rollbackTimestamps(buildRule.getOutputDir(), 5);",
        "ins1DelCode":"FileUtilities.rollbackTimetamps(buildRule.getOutputDir(), 5);",
        "ins1PreCode":"buildRule.executeTarget(\"test9\"); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog());  FileUtilities.rollbackTimetamps(buildRule.getOutputDir(), 5);  buildRule.executeTarget(\"normalRecompile\");",
        "ins2PreCode":"buildRule.executeTarget(\"test9\"); assertNotContains(\"Skipped grammar file.\", buildRule.getFullLog()); FileUtilities.rollbackTimetamps(buildRule.getOutputDir(), 5); buildRule.executeTarget(\"supergrammarChangeRecompile\");",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Collections.singletonList(entry), result);",
        "ins1DelCode":"Assert.assertEquals(Collections.singletonList(entry), result);",
        "ins1PreCode":"autoCompleter.indexEntry(entry);  Collection<BibEntry> result = autoCompleter.call(getRequest((\"testKey\"))); Assert.assertEquals(Collections.singletonList(entry), result);",
        "ins2PreCode":"autoCompleter.indexEntry(entry); Collection<BibEntry> result = autoCompleter.call(getRequest((\"testkey\"))); Assert.assertEquals(Collections.singletonList(entry), result);",
        "label":1
    },
    {
        "ins1AddCode":"arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes);",
        "ins1DelCode":"arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, numElements, sizeInBytes);",
        "ins1PreCode":"final byte[] arrayDataCopy = new byte[sizeInBytes]; Platform.copyMemory( baseObject, baseOffset, arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, sizeInBytes); arrayCopy.pointTo(arrayDataCopy, Platform.BYTE_ARRAY_OFFSET, numElements, sizeInBytes); return arrayCopy;",
        "ins2PreCode":"final byte[] rowDataCopy = new byte[sizeInBytes]; Platform.copyMemory( rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); rowCopy.pointTo(rowDataCopy, Platform.BYTE_ARRAY_OFFSET, numFields, sizeInBytes); return rowCopy;",
        "label":0
    },
    {
        "ins1AddCode":"void shouldInsertOffsetDateTime() {",
        "ins1DelCode":"public void shouldInsertOffsetDateTime() {",
        "ins1PreCode":"public void shouldInsertOffsetDateTime() { OffsetDateTime odt = OffsetDateTime.of(2018, 1, 2, 11, 22, 33, 123456000, ZoneOffset.ofHoursMinutes(1, 23)); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldInsertOffsetTime() { OffsetTime ot = OffsetTime.of(11, 22, 33, 123456000, ZoneOffset.ofHoursMinutes(1, 23)); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"public Observable<? extends Integer> apply(Integer v) { public Observable<? extends Integer> apply(Integer v) { public Single<? extends Integer> apply(Integer v) {",
        "ins1DelCode":"public Observable<? extends Integer> apply(Integer v) throws Exception { public Observable<? extends Integer> apply(Integer v) throws Exception { public Single<? extends Integer> apply(Integer v) throws Exception {",
        "ins1PreCode":" observablePlain = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } });  observableConvert = source.flatMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toObservable(); } });  observableDedicated = source.flatMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v); }",
        "ins2PreCode":"observablePlain = source.switchMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Observable.just(v); } }); observableConvert = source.switchMap(new Function<Integer, Observable<? extends Integer>>() { @Override public Observable<? extends Integer> apply(Integer v) throws Exception { return Single.just(v).toObservable(); } }); observableDedicated = source.switchMapSingle(new Function<Integer, Single<? extends Integer>>() { @Override public Single<? extends Integer> apply(Integer v) throws Exception { return Single.just(v); }",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"try { fail(\"Build exception should have been thrown - neither srcDir nor modulesourcepath\"); } catch (BuildException e) { }",
        "ins1PreCode":"public void testModulesourcepathAndSrcDirForbidden() { try { javac.checkParameters(); final Path p = new Path(project); p.setPath(\"src\"); javac.setSrcdir(p); final Path mp = new Path(project); p.setPath(\"modsrc\"); javac.setModulesourcepath(mp); fail(\"Build exception should have been thrown - neither srcDir nor modulesourcepath\"); } catch (BuildException e) {  }",
        "ins2PreCode":"public void testModulesourcepathAndSourcepathForbidden() { try { javac.checkParameters(); final Path p = new Path(project); p.setPath(\"src\"); javac.setSourcepath(p); final Path mp = new Path(project); p.setPath(\"modsrc\"); javac.setModulesourcepath(mp); fail(\"Build exception should have been thrown - neither srcDir nor modulesourcepath\"); } catch (BuildException e) { }",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"public void testSetSeriesToolTipGenerator() { CategoryPlot plot = (CategoryPlot) this.chart.getPlot(); CategoryItemRenderer renderer = plot.getRenderer(); CategoryToolTipGenerator tt2 = renderer.getToolTipGenerator(0, 0);",
        "label":0
    },
    {
        "ins1AddCode":"final TestObserver<Void> to1 = new TestObserver<>();",
        "ins1DelCode":"final TestObserver<Void> to1 = new TestObserver<Void>();",
        "ins1PreCode":"public void crossDispose() { PublishSubject<Integer> ps = PublishSubject.create();  final TestObserver<Void> to1 = new TestObserver<Void>();  final TestObserver<Void> to2 = new TestObserver<Void>() {",
        "ins2PreCode":"public void crossDisposeOnError() { PublishSubject<Integer> ps = PublishSubject.create(); final TestObserver<Void> to1 = new TestObserver<Void>(); final TestObserver<Void> to2 = new TestObserver<Void>() {",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable d1 = Disposable.empty();",
        "ins1DelCode":"final Disposable d1 = Disposables.empty();",
        "ins1PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final CompositeDisposable cd = new CompositeDisposable();  final Disposable d1 = Disposables.empty();  cd.add(d1);",
        "ins2PreCode":"for (int i = 0; i < TestHelper.RACE_DEFAULT_LOOPS; i++) { final CompositeDisposable cd = new CompositeDisposable(); final Disposable d1 = Disposables.empty(); cd.add(d1);",
        "label":1
    },
    {
        "ins1AddCode":"}), true, 2, ImmediateThinScheduler.INSTANCE)",
        "ins1DelCode":"}), 2, true, ImmediateThinScheduler.INSTANCE)",
        "ins1PreCode":"s.onSubscribe(new BooleanSubscription()); s.onError(new TestException(\"First\")); } }), 2, true, ImmediateThinScheduler.INSTANCE) .to(TestHelper.<Integer>testConsumer()); ",
        "ins2PreCode":"s.onSubscribe(new BooleanSubscription()); s.onError(new TestException(\"First\")); } .to(TestHelper.<Integer>testConsumer()); .to(TestHelper.<Integer>testConsumer());",
        "label":0
    },
    {
        "ins1AddCode":"void tomcatCustomizers() {",
        "ins1DelCode":"public void tomcatCustomizers() {",
        "ins1PreCode":"public void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] customizers = new TomcatContextCustomizer[4];",
        "ins2PreCode":"public void tomcatConnectorCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatConnectorCustomizer[] customizers = new TomcatConnectorCustomizer[4];",
        "label":1
    },
    {
        "ins1AddCode":"to.onSubscribe(Disposable.empty());",
        "ins1DelCode":"to.onSubscribe(Disposables.empty());",
        "ins1PreCode":"public void assertValueSequence() { TestObserverEx<Integer> to = new TestObserverEx<Integer>();  to.onSubscribe(Disposables.empty());  to.onNext(1);",
        "ins2PreCode":"public void assertValueSequence() { TestObserver<Integer> to = TestObserver.create(); to.onSubscribe(Disposables.empty()); to.onNext(1);",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Object> ts = new TestSubscriber<>(observerA);",
        "ins1DelCode":"TestSubscriber<Object> ts = new TestSubscriber<Object>(observerA);",
        "ins1PreCode":"Subscriber<Object> observerB = TestHelper.mockSubscriber(); Subscriber<Object> observerC = TestHelper.mockSubscriber();  TestSubscriber<Object> ts = new TestSubscriber<Object>(observerA);  channel.subscribe(ts);",
        "ins2PreCode":"Subscriber<Object> observerB = TestHelper.mockSubscriber(); Subscriber<Object> observerC = TestHelper.mockSubscriber(); TestSubscriber<Object> ts = new TestSubscriber<Object>(observerA); channel.subscribe(ts);",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>();",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>();",
        "ins1PreCode":"public void unorderedOnNextRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) {  TestObserver<Integer> to = new TestObserver<Integer>(); Disposable d = Disposable.empty(); final QueueDrainObserver<Integer, Integer, Integer> qd = createUnordered(to, d);",
        "ins2PreCode":"public void orderedOnNextRace() { for (int i = 0; i < TestHelper.RACE_LONG_LOOPS; i++) { TestObserver<Integer> to = new TestObserver<Integer>(); Disposable d = Disposable.empty(); final QueueDrainObserver<Integer, Integer, Integer> qd = createOrdered(to, d);",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"if (this.stroke != null) { return this.stroke; }",
        "ins1PreCode":"public Stroke lookupSeriesStroke(int series) {   if (this.stroke != null) { return this.stroke; } ",
        "ins2PreCode":"public Stroke lookupSeriesOutlineStroke(int series) { if (this.outlineStroke != null) { return this.outlineStroke; }",
        "label":1
    },
    {
        "ins1AddCode":"private static void revokeToken(JenkinsRule j, WebClient wc, String login, String tokenUuid) throws Exception { new URL(j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid),",
        "ins1DelCode":"private void revokeToken(WebClient wc, String login, String tokenUuid) throws Exception { new URL(rr.j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid),",
        "ins1PreCode":"private void revokeToken(WebClient wc, String login, String tokenUuid) throws Exception { WebRequest request = new WebRequest( new URL(rr.j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid), HttpMethod.POST );",
        "ins2PreCode":"private void revokeToken(WebClient wc, String login, String tokenUuid) throws Exception { WebRequest request = new WebRequest( new URL(j.getURL(), \"user/\" + login + \"/descriptorByName/\" + ApiTokenProperty.class.getName() + \"/revoke/?tokenUuid=\" + tokenUuid), HttpMethod.POST );",
        "label":0
    },
    {
        "ins1AddCode":"observer.onSubscribe(Disposable.empty());",
        "ins1DelCode":"observer.onSubscribe(Disposables.empty());",
        "ins1PreCode":"protected void subscribeActual( Observer<? super Integer> observer) { assertFalse(((Disposable)observer).isDisposed()); observer.onSubscribe(Disposables.empty()); sub[count++] = observer; }",
        "ins2PreCode":"protected void subscribeActual( Observer<? super Integer> observer) { assertFalse(((Disposable)observer).isDisposed()); observer.onSubscribe(Disposables.empty()); sub[count++] = observer; }",
        "label":1
    },
    {
        "ins1AddCode":"TimeSeries s2 = TestUtils.serialised(s1);",
        "ins1DelCode":"TimeSeries s2 = (TimeSeries) TestUtils.serialised(s1);",
        "ins1PreCode":"s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimeSeries s2 = (TimeSeries) TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "ins2PreCode":"s1.add(new Year(2002), null); s1.add(new Year(2005), 19.32); s1.add(new Year(2007), 16.89); TimePeriodValues s2 = (TimePeriodValues) TestUtils.serialised(s1); assertTrue(s1.equals(s2));",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(blog instanceof Proxy);",
        "ins1DelCode":"Assert.assertTrue(blog instanceof Factory);",
        "ins1PreCode":"SqlSession session = sqlMapper.openSession(); try { Blog blog = session.selectOne(\"domain.blog.mappers.BlogMapper.selectBlogWithPostsUsingSubSelectLazily\", 1); Assert.assertTrue(blog instanceof Factory); assertEquals(\"Jim Business\", blog.getTitle()); assertEquals(2, blog.getPosts().size());",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals((double)0, exec(\"def d = BigInteger.valueOf(0); double b = d; b\"));",
        "ins1DelCode":"",
        "ins1PreCode":"assertEquals((double)0, exec(\"def d = Long.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = d;\"));",
        "ins2PreCode":"assertEquals((double)0, exec(\"def d = Long.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Float.valueOf(0); double b = (double)d; b\")); assertEquals((double)0, exec(\"def d = Double.valueOf(0); double b = (double)d; b\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = new ArrayList(); double b = (double)d;\"));",
        "label":0
    },
    {
        "ins1AddCode":"private void findViewsByMask(JDBCSession session, GenericSchema parentSchema, @NotNull ObjectsSearchParams params, List<DBSObjectReference> result) throws SQLException { String stmt = \"SELECT SCHEMA_NAME, VIEW_NAME, COMMENTS FROM SYS.VIEWS WHERE\"; stmt += params.isCaseSensitive() ? \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt += \" AND SCHEMA_NAME = ?\"; stmt += \" ORDER BY SCHEMA_NAME, VIEW_NAME LIMIT \" + (params.getMaxResults() - result.size()); dbStat.setString(1, params.isCaseSensitive() ? params.getMask() : params.getMask().toUpperCase()); if (parentSchema != null) { } while (!monitor.isCanceled() && dbResult.next()) {",
        "ins1DelCode":"private void findViewsByMask(JDBCSession session, GenericSchema parentSchema, String objectNameMask, boolean caseSensitive, int maxResults, List<DBSObjectReference> result) throws SQLException, DBException { String stmt =                       \"SELECT SCHEMA_NAME, VIEW_NAME, COMMENTS FROM SYS.VIEWS WHERE\"; stmt += caseSensitive ?             \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt +=    \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY SCHEMA_NAME, VIEW_NAME LIMIT \" + maxResults; dbStat.setString(1, caseSensitive ? objectNameMask : objectNameMask.toUpperCase()); if (parentSchema != null) int numResults = maxResults; while (dbResult.next() && numResults-- > 0) { if (monitor.isCanceled()) break;",
        "ins1PreCode":"private void findViewsByMask(JDBCSession session, GenericSchema parentSchema, String objectNameMask, boolean caseSensitive, int maxResults, List<DBSObjectReference> result) throws SQLException, DBException { String stmt =                       \"SELECT SCHEMA_NAME, VIEW_NAME, COMMENTS FROM SYS.VIEWS WHERE\"; stmt += caseSensitive ?             \" VIEW_NAME LIKE ?\" : \" UPPER(VIEW_NAME) LIKE ?\"; if (parentSchema != null)stmt +=    \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY SCHEMA_NAME, VIEW_NAME LIMIT \" + maxResults;  DBRProgressMonitor monitor = session.getProgressMonitor(); try (JDBCPreparedStatement dbStat = session.prepareStatement(stmt)) { dbStat.setString(1, caseSensitive ? objectNameMask : objectNameMask.toUpperCase()); if (parentSchema != null) dbStat.setString(2, parentSchema.getName()); try (JDBCResultSet dbResult = dbStat.executeQuery()) { int numResults = maxResults; while (dbResult.next() && numResults-- > 0) { if (monitor.isCanceled()) break; String schemaName = dbResult.getString(1); String objectName = dbResult.getString(2);",
        "ins2PreCode":"private void findProceduresByMask(JDBCSession session, GenericSchema parentSchema, String objectNameMask, boolean caseSensitive, int maxResults, List<DBSObjectReference> result) throws SQLException, DBException { String stmt =                       \"SELECT SCHEMA_NAME, PROCEDURE_NAME FROM SYS.PROCEDURES WHERE\"; stmt += caseSensitive ?             \" PROCEDURE_NAME LIKE ?\" : \" UPPER(PROCEDURE_NAME) LIKE ?\"; if (parentSchema != null) stmt +=   \" AND SCHEMA_NAME = ?\"; stmt +=                             \" ORDER BY SCHEMA_NAME, PROCEDURE_NAME LIMIT \" + maxResults; DBRProgressMonitor monitor = session.getProgressMonitor(); try (JDBCPreparedStatement dbStat = session.prepareStatement(stmt)) { dbStat.setString(1, caseSensitive ? objectNameMask : objectNameMask.toUpperCase()); if (parentSchema != null) dbStat.setString(2, parentSchema.getName()); try (JDBCResultSet dbResult = dbStat.executeQuery()) { int numResults = maxResults; while (dbResult.next() && numResults-- > 0) { if (monitor.isCanceled()) break; String schemaName = dbResult.getString(1); String objectName = dbResult.getString(2);",
        "label":1
    },
    {
        "ins1AddCode":"tgt = new DeploymentRepository(); target.setRepository( tgt );",
        "ins1DelCode":"target.setRepository( tgt = new DeploymentRepository() );",
        "ins1PreCode":"DeploymentRepository tgt = target.getRepository(); if ( tgt == null ) { target.setRepository( tgt = new DeploymentRepository() ); } mergeDeploymentRepository( tgt, src, sourceDominant, context );",
        "ins2PreCode":"DeploymentRepository tgt = target.getSnapshotRepository(); if ( tgt == null ) { target.setSnapshotRepository( tgt = new DeploymentRepository() ); } mergeDeploymentRepository( tgt, src, sourceDominant, context );",
        "label":0
    },
    {
        "ins1AddCode":"skipTokens(st, 3);",
        "ins1DelCode":"if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken();",
        "ins1PreCode":"Argo.KEY_IMPORT_GENERAL_SETTINGS_FLAGS); if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) { return false;",
        "ins2PreCode":"Argo.KEY_IMPORT_GENERAL_SETTINGS_FLAGS); if (flags != null && flags.length() > 0) { StringTokenizer st = new StringTokenizer(flags, \",\"); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens()) st.nextToken(); if (st.hasMoreTokens() && st.nextToken().equals(\"false\")) { return false;",
        "label":1
    },
    {
        "ins1AddCode":"iae.initCause(e);",
        "ins1DelCode":"jdkCompat.chainException(iae, e);",
        "ins1PreCode":"} catch (MalformedObjectNameException e) { IllegalArgumentException iae = new IllegalArgumentException (\"Cannot create object name for user \" + user); jdkCompat.chainException(iae, e); throw iae; }",
        "ins2PreCode":"} catch (Exception e) { IllegalArgumentException iae = new IllegalArgumentException database.removeUser(user); jdkCompat.chainException(iae, e); throw iae; }",
        "label":1
    },
    {
        "ins1AddCode":"ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapContext,",
        "ins1DelCode":"ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry,",
        "ins1PreCode":"void processAndApplySetsDefaultProfiles(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply();",
        "ins2PreCode":"void processAndApplySetsActiveProfiles(TestInfo info) { this.environment.setProperty(\"spring.config.location\", getConfigLocation(info)); ConfigDataEnvironment configDataEnvironment = new ConfigDataEnvironment(this.logFactory, this.bootstrapRegistry, this.environment, this.resourceLoader, this.additionalProfiles); configDataEnvironment.processAndApply();",
        "label":1
    },
    {
        "ins1AddCode":"UnicastSubject<Integer> us = UnicastSubject.create(); TestHelper.emit(us, 1, 2, 3, 4, 5); us",
        "ins1DelCode":"UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5); up",
        "ins1PreCode":"public void asyncFused() { TestObserverEx<Integer> to0 = new TestObserverEx<>(QueueFuseable.ASYNC);  UnicastSubject<Integer> up = UnicastSubject.create();  TestHelper.emit(up, 1, 2, 3, 4, 5);  up .doAfterNext(afterNext) .subscribe(to0);",
        "ins2PreCode":"public void asyncFusedConditional() { TestObserverEx<Integer> to0 = new TestObserverEx<>(QueueFuseable.ASYNC); UnicastSubject<Integer> up = UnicastSubject.create(); TestHelper.emit(up, 1, 2, 3, 4, 5); up .doAfterNext(afterNext) .subscribe(to0);",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, SecurityFilterChain.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebSecurityConfigurer.class)).isFalse(); assertThat(excludes(filter, ExampleHandlerInterceptor.class)).isFalse(); assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"return Long.valueOf(0);",
        "ins1DelCode":"return new Long(0);",
        "ins1PreCode":"public static final Number add(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return new Long(0); } ",
        "ins2PreCode":"public static final Number subtract(final Object obj0, final Object obj1) { if (obj0 == null && obj1 == null) { return new Long(0); }",
        "label":1
    },
    {
        "ins1AddCode":"if (!isActive()) { return false; }",
        "ins1DelCode":"if (!isActive()) return false;",
        "ins1PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) return false; ListSet offs = i.getOffenders(); UMLDeploymentDiagram dd = (UMLDeploymentDiagram) offs.get(0);",
        "ins2PreCode":"public boolean stillValid(ToDoItem i, Designer dsgr) { if (!isActive()) { ListSet offs = i.getOffenders(); UMLDeploymentDiagram dd = (UMLDeploymentDiagram) offs.get(0);",
        "label":0
    },
    {
        "ins1AddCode":"List<List<Tuple2<Integer, String>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1DelCode":"List<List<Tuple2<String, Integer>>> result = JavaTestUtils.runStreams(ssc, 2, 2);",
        "ins1PreCode":"});  JavaTestUtils.attachTestOutputStream(flatMapped); List<List<Tuple2<String, Integer>>> result = JavaTestUtils.runStreams(ssc, 2, 2);  Assert.assertEquals(expected, result);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void assertComplete() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>();  ts.onSubscribe(new BooleanSubscription());",
        "ins2PreCode":"public void assertComplete() { TestSubscriberEx<Integer> ts = new TestSubscriberEx<Integer>(); ts.onSubscribe(new BooleanSubscription());",
        "label":1
    },
    {
        "ins1AddCode":"updateCheckManager.touch( a, remoteRepository, null );",
        "ins1DelCode":"updateCheckManager.touch( a, remoteRepository );",
        "ins1PreCode":" file.getParentFile().mkdirs(); file.createNewFile(); updateCheckManager.touch( a, remoteRepository );  assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );",
        "ins2PreCode":"file.delete(); file.delete(); updateCheckManager.touch( a, remoteRepository ); assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );",
        "label":1
    },
    {
        "ins1AddCode":"void testAddNewTermListNewListInList(@TempDirectory.TempDir Path tempDir) { tempDir.toFile().getAbsolutePath());",
        "ins1DelCode":"public void testAddNewTermListNewListInList() throws IOException { temporaryFolder.newFile().getAbsolutePath());",
        "ins1PreCode":"public void testAddNewTermListNewListInList() throws IOException {  ProtectedTermsLoader localLoader = new ProtectedTermsLoader( new ProtectedTermsPreferences(Collections.emptyList(), Collections.emptyList(), ProtectedTermsLoader.getInternalLists(), Collections.emptyList())); ProtectedTermsList newList = localLoader.addNewProtectedTermsList(\"My new list\", temporaryFolder.newFile().getAbsolutePath()); assertTrue(localLoader.getProtectedTermsLists().contains(newList));",
        "ins2PreCode":"public void testRemoveTermList() throws IOException { ProtectedTermsLoader localLoader = new ProtectedTermsLoader( new ProtectedTermsPreferences(Collections.emptyList(), Collections.emptyList(), ProtectedTermsLoader.getInternalLists(), Collections.emptyList())); ProtectedTermsList newList = localLoader.addNewProtectedTermsList(\"My new list\", temporaryFolder.newFile().getAbsolutePath()); ProtectedTermsList newList = localLoader.addNewProtectedTermsList(\"My new list\", temporaryFolder.newFile().getAbsolutePath()); assertTrue(localLoader.removeProtectedTermsList(newList));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> subscriber = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void assertTestObserver() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber); ",
        "ins2PreCode":"public void assertNotMatchCount() { Flowable<Integer> oi = Flowable.fromIterable(Arrays.asList(1, 2)); TestSubscriber<Integer> subscriber = new TestSubscriber<Integer>(); oi.subscribe(subscriber);",
        "label":1
    },
    {
        "ins1AddCode":"indexRandom(true, client().prepareIndex(\"test\").setId(\"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\").setId(\"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\").setId(\"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\").setId(\"4\").setSource(\"foo\", \"c\"));",
        "ins1DelCode":"indexRandom(true, client().prepareIndex(\"test\", \"test\", \"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\"));",
        "ins1PreCode":"public void testBasics() throws Exception { indexRandom(true, client().prepareIndex(\"test\", \"test\", \"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"1\").get().getVersion());",
        "ins2PreCode":"public void testSlices() throws Exception { client().prepareIndex(\"test\", \"test\", \"1\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"2\").setSource(\"foo\", \"a\"), client().prepareIndex(\"test\", \"test\", \"3\").setSource(\"foo\", \"b\"), client().prepareIndex(\"test\", \"test\", \"4\").setSource(\"foo\", \"c\")); assertHitCount(client().prepareSearch(\"test\").setSize(0).get(), 4); assertEquals(1, client().prepareGet(\"test\", \"1\").get().getVersion());",
        "label":1
    },
    {
        "ins1AddCode":"String[] blockIds = blocks.keySet().toArray(new String[blocks.size()]); BlockFetchingListener listener = fetchBlocks( blocks, blockIds, new OpenBlocks(\"app-id\", \"exec-id\", blockIds), conf);",
        "ins1DelCode":"BlockFetchingListener listener = fetchBlocks(blocks);",
        "ins1PreCode":"blocks.put(\"b1\", null); blocks.put(\"b2\", null);  BlockFetchingListener listener = fetchBlocks(blocks);  ",
        "ins2PreCode":"blocks.put(\"b1\", null); blocks.put(\"b1\", null); BlockFetchingListener listener = fetchBlocks(blocks);",
        "label":1
    },
    {
        "ins1AddCode":"AnnotationMapper mapper = sqlSession.getMapper(AnnotationMapper.class); User user = mapper.getUser(1);",
        "ins1DelCode":"Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserFromAnnotation(1);",
        "ins1PreCode":"public void shouldGetAUserFromAnnotation() { SqlSession sqlSession = sqlSessionFactory.openSession(); try { Mapper mapper = sqlSession.getMapper(Mapper.class); User user = mapper.getUserFromAnnotation(1); Assert.assertEquals(\"User1\", user.getName()); } finally {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"XIntervalSeries<String> s1 = new XIntervalSeries<>(\"Series 1\");",
        "ins1DelCode":"XIntervalSeries s1 = new XIntervalSeries(\"Series 1\");",
        "ins1PreCode":"public void testAdditionOfDuplicateXValues() { XIntervalSeries s1 = new XIntervalSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 1.0); s1.add(2.0, 2.0, 2.0, 2.0);",
        "ins2PreCode":"public void testAdditionOfDuplicateXValues() { VectorSeries s1 = new VectorSeries(\"Series 1\"); s1.add(1.0, 1.0, 1.0, 1.0); s1.add(2.0, 2.0, 2.0, 2.0);",
        "label":1
    },
    {
        "ins1AddCode":"void couchbaseClusterIsDown() {",
        "ins1DelCode":"public void couchbaseClusterIsDown() {",
        "ins1PreCode":"public void couchbaseClusterIsDown() { Cluster cluster = mock(Cluster.class); CouchbaseReactiveHealthIndicator healthIndicator = new CouchbaseReactiveHealthIndicator(cluster);",
        "ins2PreCode":"public void couchbaseClusterIsUp() { Cluster cluster = mock(Cluster.class); CouchbaseHealthIndicator healthIndicator = new CouchbaseHealthIndicator(cluster);",
        "label":1
    },
    {
        "ins1AddCode":"Assert.assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result); Assert.assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result);",
        "ins1DelCode":"assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result);",
        "ins1PreCode":"this.loader.removeTransformer(removed);  String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result);  result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #1!\", result); ",
        "ins2PreCode":"this.loader.removeTransformer(removed); String result = invokeDoMethodOnClass(this.loader, \"TesterNeverWeavedClass\"); assertEquals(\"The first result is not correct.\", \"This will never be weaved.\", result); result = invokeDoMethodOnClass(this.loader, \"TesterUnweavedClass\"); assertEquals(\"The second result is not correct.\", \"Hello, Weaver #2!\", result);",
        "label":1
    },
    {
        "ins1AddCode":"public NamingEnumeration<Binding> listBindings(Name name) NamingEntry entry = bindings.get(name.get(0));",
        "ins1DelCode":"public NamingEnumeration listBindings(Name name) NamingEntry entry = (NamingEntry) bindings.get(name.get(0));",
        "ins1PreCode":"public NamingEnumeration listBindings(Name name) throws NamingException {  while ((!name.isEmpty()) && (name.get(0).length() == 0)) name = name.getSuffix(1); if (name.isEmpty()) { return new NamingContextBindingsEnumeration(bindings.values().iterator(), this); }  NamingEntry entry = (NamingEntry) bindings.get(name.get(0));  if (entry == null) {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"assertTrue(author2 instanceof Factory);",
        "ins1DelCode":"assertTrue(author2.getClass().getName().contains(\"CGLIB\"));",
        "ins1PreCode":"loader.addLoader(\"id\", null, null); Object proxy = proxyFactory.createProxy(author, loader, new Configuration(), new DefaultObjectFactory(), new ArrayList<Class<?>>(), new ArrayList<Object>()); Author author2 = (Author) deserialize(serialize((Serializable) proxy)); assertTrue(author2.getClass().getName().contains(\"CGLIB\"));",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"when(preferences.shouldSaveInOriginalOrder()).thenReturn(true);",
        "ins1DelCode":"when(preferences.isSaveInOriginalOrder()).thenReturn(true);",
        "ins1PreCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding));  when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData()); ",
        "ins2PreCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(Importer.getReader(testBibtexFile, encoding)); when(preferences.getEncoding()).thenReturn(encoding); when(preferences.isSaveInOriginalOrder()).thenReturn(true); BibDatabaseContext context = new BibDatabaseContext(result.getDatabase(), result.getMetaData());",
        "label":1
    },
    {
        "ins1AddCode":"public void operationWithSecurityInterceptorForbidden() {",
        "ins1DelCode":"public void operationWithSecurityInterceptorForbidden() throws Exception {",
        "ins1PreCode":"public void operationWithSecurityInterceptorForbidden() throws Exception { given(securityService.getAccessLevel(any(), eq(\"app-id\"))) .willReturn(AccessLevel.RESTRICTED);",
        "ins2PreCode":"public void operationWithSecurityInterceptorSuccess() throws Exception { given(securityService.getAccessLevel(any(), eq(\"app-id\"))) .willReturn(AccessLevel.FULL);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(Files.readString(testBibtexFile, encoding), stringWriter.toString());",
        "ins1DelCode":"try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins1PreCode":"new Defaults(BibDatabaseMode.BIBTEX));  databaseWriter.savePartOfDatabase(context, result.getDatabase().getEntries()); try (Scanner scanner = new Scanner(testBibtexFile, encoding.name())) { assertEquals(scanner.useDelimiter(\"\\\\A\").next(), stringWriter.toString()); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"File baseDir = (this.baseDirectory != null) ? this.baseDirectory : createTempDir(\"tomcat\");",
        "ins1DelCode":"File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\"));",
        "ins1PreCode":"public WebServer getWebServer(HttpHandler httpHandler) { Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol);",
        "ins2PreCode":"public WebServer getWebServer(ServletContextInitializer... initializers) { Tomcat tomcat = new Tomcat(); File baseDir = (this.baseDirectory != null ? this.baseDirectory : createTempDir(\"tomcat\")); tomcat.setBaseDir(baseDir.getAbsolutePath()); Connector connector = new Connector(this.protocol);",
        "label":1
    },
    {
        "ins1AddCode":"void createParams() throws UnknownHostException, TextParseException {",
        "ins1DelCode":"void createParams() throws UnknownHostException {",
        "ins1PreCode":"void createParams() throws UnknownHostException { List<Integer> mandatoryList = Arrays.asList(HTTPSRecord.ALPN, HTTPSRecord.IPV4HINT); HTTPSRecord.ParameterMandatory mandatory = new HTTPSRecord.ParameterMandatory(mandatoryList);",
        "ins2PreCode":"void createParams() throws UnknownHostException { List<Integer> mandatoryList = Arrays.asList(SVCBRecord.ALPN, SVCBRecord.IPV4HINT); SVCBRecord.ParameterMandatory mandatory = new SVCBBase.ParameterMandatory(mandatoryList);",
        "label":1
    },
    {
        "ins1AddCode":"String fileDirPattern = \"PDF/[year]/[auth]/[citationkey] - [fulltitle]\"; entry.setCitationKey(\"1234\");",
        "ins1DelCode":"String fileDirPattern = \"PDF/[year]/[auth]/[bibtexkey] - [fulltitle]\"; entry.setCiteKey(\"1234\");",
        "ins1PreCode":"void testGetLinkedDirNameDefaultFullTitle() {  String fileDirPattern = \"PDF/[year]/[auth]/[bibtexkey] - [fulltitle]\"; BibEntry entry = new BibEntry(); entry.setCiteKey(\"1234\"); entry.setField(StandardField.TITLE, \"mytitle\"); entry.setField(StandardField.YEAR, \"1998\");",
        "ins2PreCode":"void testGetLinkedDirNamePatternEmpty() { assertEquals(\"\", FileUtil.createDirNameFromPattern(null, entry, \"\")); BibEntry entry = new BibEntry(); entry.setCiteKey(\"1234\"); entry.setField(StandardField.TITLE, \"mytitle\"); entry.setField(StandardField.YEAR, \"1998\");",
        "label":0
    },
    {
        "ins1AddCode":"Environment environment, WebEndpointDiscoverer endpointDiscoverer, endpointDiscoverer.getEndpoints(), endpointMediaTypes,",
        "ins1DelCode":"Environment environment, EndpointDiscoverer<WebOperation> webEndpointDiscoverer, webEndpointDiscoverer.discoverEndpoints(), endpointMediaTypes,",
        "ins1PreCode":"public WebMvcEndpointHandlerMapping webEndpointHandlerMapping( Environment environment, EndpointDiscoverer<WebOperation> webEndpointDiscoverer, EndpointMediaTypes endpointMediaTypes) { CorsConfiguration corsConfiguration = new CorsConfiguration(); corsConfiguration.setAllowedOrigins(Arrays.asList(\"http://example.com\")); corsConfiguration.setAllowedMethods(Arrays.asList(\"GET\", \"POST\")); return new WebMvcEndpointHandlerMapping( new EndpointMapping(environment.getProperty(\"endpointPath\")), webEndpointDiscoverer.discoverEndpoints(), endpointMediaTypes, corsConfiguration);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() { TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class); TypeDescriptor targetType = TypeDescriptor .nested(ReflectionUtils.findField(Values.class, \"convertibleElementType\"), 0); assertThat( new DelimitedStringToArrayConverter(new ApplicationConversionService()).matches(sourceType, targetType)) .isTrue();",
        "ins1DelCode":"public void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() { if (this.conversionService instanceof ApplicationConversionService) { TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class); TypeDescriptor targetType = TypeDescriptor .nested(ReflectionUtils.findField(Values.class, \"convertibleElementType\"), 0); assertThat(new DelimitedStringToArrayConverter(this.conversionService).matches(sourceType, targetType)) .isTrue(); }",
        "ins1PreCode":"public void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() { if (this.conversionService instanceof ApplicationConversionService) { TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class); TypeDescriptor targetType = TypeDescriptor .nested(ReflectionUtils.findField(Values.class, \"convertibleElementType\"), 0); assertThat(new DelimitedStringToArrayConverter(this.conversionService).matches(sourceType, targetType)) .isTrue(); }",
        "ins2PreCode":"public void matchesWhenHasAnnotationAndConvertibleElementTypeShouldReturnTrue() { if (this.conversionService instanceof ApplicationConversionService) { TypeDescriptor sourceType = TypeDescriptor.valueOf(String.class); TypeDescriptor targetType = TypeDescriptor .nested(ReflectionUtils.findField(Values.class, \"convertibleElementType\"), 0); assertThat(new DelimitedStringToCollectionConverter(this.conversionService).matches(sourceType, targetType)) .isTrue(); }",
        "label":1
    },
    {
        "ins1AddCode":"new TreeMap<>(); list = new ArrayList<>();",
        "ins1DelCode":"new TreeMap<Integer,ArrayList<CharEntry>>(); list = new ArrayList<CharEntry>();",
        "ins1PreCode":"long t1 = System.currentTimeMillis();  TreeMap<Integer,ArrayList<CharEntry>> tempMap = new TreeMap<Integer,ArrayList<CharEntry>>(); for (Entry<CharEntry,int[]> item : ccStats.entrySet()) { CharEntry entry = item.getKey(); int[] countA = item.getValue(); Integer count = Integer.valueOf(countA[0]);  ArrayList<CharEntry> list = tempMap.get(count); if (list == null) {  list = new ArrayList<CharEntry>(); tempMap.put(count, list); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":".setMetricName(\"accuracy\");",
        "ins1DelCode":".setMetricName(\"precision\");",
        "ins1PreCode":"MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));",
        "ins2PreCode":"MulticlassClassificationEvaluator evaluator = new MulticlassClassificationEvaluator() .setLabelCol(\"indexedLabel\") .setPredictionCol(\"prediction\") .setMetricName(\"precision\"); double accuracy = evaluator.evaluate(predictions); System.out.println(\"Test Error = \" + (1.0 - accuracy));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"\", a.format(\"\")); assertEquals(\"Someone, V. S.\", a.format(\"Van Something Someone\")); assertEquals(\"von Neumann, J. and Black Brown, P.\", a assertEquals(\"von Neumann, J., Smith, J. and Black Brown, P.\", a assertEquals(\"von Neumann, J., Smith, J. and Black Brown, P.\", a",
        "ins1DelCode":"Assert.assertEquals(\"\", a.format(\"\")); Assert.assertEquals(\"Someone, V. S.\", a.format(\"Van Something Someone\")); Assert.assertEquals(\"von Neumann, J. and Black Brown, P.\", a Assert.assertEquals(\"von Neumann, J., Smith, J. and Black Brown, P.\", a Assert.assertEquals(\"von Neumann, J., Smith, J. and Black Brown, P.\", a",
        "ins1PreCode":"LayoutFormatter a = new AuthorLastFirstAbbrCommas();   Assert.assertEquals(\"\", a.format(\"\"));   Assert.assertEquals(\"Someone, V. S.\", a.format(\"Van Something Someone\"));   Assert.assertEquals(\"von Neumann, J. and Black Brown, P.\", a .format(\"John von Neumann and Black Brown, Peter\"));   Assert.assertEquals(\"von Neumann, J., Smith, J. and Black Brown, P.\", a .format(\"von Neumann, John and Smith, John and Black Brown, Peter\"));  Assert.assertEquals(\"von Neumann, J., Smith, J. and Black Brown, P.\", a .format(\"John von Neumann and John Smith and Black Brown, Peter\")); ",
        "ins2PreCode":"LayoutFormatter a = new AuthorLastFirstAbbrOxfordCommas(); Assert.assertEquals(\"\", a.format(\"\")); Assert.assertEquals(\"Someone, V. S.\", a.format(\"Van Something Someone\")); Assert.assertEquals(\"von Neumann, J. and Black Brown, P.\", a .format(\"John von Neumann and Black Brown, Peter\")); Assert.assertEquals(\"von Neumann, J., Smith, J., and Black Brown, P.\", a .format(\"von Neumann, John and Smith, John and Black Brown, Peter\")); Assert.assertEquals(\"von Neumann, J., Smith, J., and Black Brown, P.\", a .format(\"John von Neumann and John Smith and Black Brown, Peter\"));",
        "label":1
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts = new TestSubscriber<Integer>();",
        "ins1PreCode":"public void multipleErrors3() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE); ts.onError(new TestException());",
        "ins2PreCode":"public void multipleErrors4() { TestSubscriber<Integer> ts = new TestSubscriber<Integer>(); ts.onSubscribe(EmptySubscription.INSTANCE); ts.onError(new TestException());",
        "label":1
    },
    {
        "ins1AddCode":"void applyDefaultValue() {",
        "ins1DelCode":"public void applyDefaultValue() {",
        "ins1PreCode":"public void applyDefaultValue() { Properties props = new Properties(); props.setProperty(PropertyParser.KEY_ENABLE_DEFAULT_VALUE, \"true\");",
        "ins2PreCode":"public void applyCustomSeparator() { Properties props = new Properties(); props.setProperty(PropertyParser.KEY_ENABLE_DEFAULT_VALUE, \"true\");",
        "label":1
    },
    {
        "ins1AddCode":"assertThat(excludes(filter, ExampleModule.class)).isFalse();",
        "ins1DelCode":"",
        "ins1PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "ins2PreCode":"assertThat(excludes(filter, ExampleService.class)).isTrue(); assertThat(excludes(filter, ExampleRepository.class)).isTrue(); assertThat(excludes(filter, ExampleWebFilter.class)).isFalse();",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(\"/leak1\", \"leakServlet1\");",
        "ins1DelCode":"ctx.addServletMapping(\"/leak1\", \"leakServlet1\");",
        "ins1PreCode":" Tomcat.addServlet(ctx, \"leakServlet1\", \"org.apache.tomcat.unittest.TesterLeakingServlet1\"); ctx.addServletMapping(\"/leak1\", \"leakServlet1\");  tomcat.start();",
        "ins2PreCode":"Tomcat.addServlet(ctx, \"leakServlet2\", \"org.apache.tomcat.unittest.TesterLeakingServlet2\"); ctx.addServletMapping(\"/leak2\", \"leakServlet2\"); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"JavaDStream<String> flatMapped = stream.flatMap(x -> Arrays.asList(x.split(\"(?!^)\")).iterator());",
        "ins1DelCode":"JavaDStream<String> flatMapped = stream.flatMap(new FlatMapFunction<String, String>() { @Override public Iterator<String> call(String x) { return Arrays.asList(x.split(\"(?!^)\")).iterator(); } });",
        "ins1PreCode":"Arrays.asList(\"a\",\"t\",\"h\",\"l\",\"e\",\"t\",\"i\",\"c\",\"s\"));  JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> flatMapped = stream.flatMap(new FlatMapFunction<String, String>() { @Override public Iterator<String> call(String x) { return Arrays.asList(x.split(\"(?!^)\")).iterator(); } }); JavaTestUtils.attachTestOutputStream(flatMapped); List<List<String>> result = JavaTestUtils.runStreams(ssc, 3, 3);",
        "ins2PreCode":"Arrays.asList(\"a\", \"t\", \"h\", \"l\", \"e\", \"t\", \"i\", \"c\", \"s\")); JavaDStream<String> stream = JavaTestUtils.attachTestInputStream(ssc, inputData, 1); JavaDStream<String> flatMapped = stream.flatMap( public void testFlatMap() { public void testFlatMap() { s -> Lists.newArrayList(s.split(\"(?!^)\")).iterator()); } } JavaTestUtils.attachTestOutputStream(flatMapped); List<List<String>> result = JavaTestUtils.runStreams(ssc, 3, 3);",
        "label":0
    },
    {
        "ins1AddCode":"try (SqlSession sqlSession = sqlSessionFactory.openSession()) { PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person ancestor = person.getAncestor(); Assert.assertEquals(\"Ancestor must be John Smith sr.\", person, ancestor); }",
        "ins1DelCode":"SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person ancestor = person.getAncestor(); Assert.assertEquals(\"Ancestor must be John Smith sr.\", person, ancestor); sqlSession.close();",
        "ins1PreCode":"public void testAncestorSelf() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person ancestor = person.getAncestor(); Assert.assertEquals(\"Ancestor must be John Smith sr.\", person, ancestor); sqlSession.close();",
        "ins2PreCode":"public void testAncestorSelf() { SqlSession sqlSession = sqlSessionFactory.openSession(); PersonMapper personMapper = sqlSession.getMapper(PersonMapper.class); Person person = personMapper.selectById(1); Assert.assertNotNull(\"Persons must not be null\", person); Person ancestor = person.getAncestor(); Assert.assertEquals(\"Ancestor must be John Smith sr.\", person, ancestor); sqlSession.close();",
        "label":1
    },
    {
        "ins1AddCode":"LOG.log(Level.SEVERE,",
        "ins1DelCode":"LOG.error(",
        "ins1PreCode":"super.insertString(0, textValue, null); } } catch (BadLocationException b) { LOG.error( \"A BadLocationException happened\\n\" + \"The string to set was: \"",
        "ins2PreCode":"super.insertString(0, textValue, null); } } catch (BadLocationException b) { LOG.error( \"A BadLocationException happened\\n\" + \"The string to set was: \"",
        "label":1
    },
    {
        "ins1AddCode":"if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - Integer.SIZE / Byte.SIZE) { for (int i = 0; i < Integer.SIZE; i += Byte.SIZE) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? (Integer.SIZE - Byte.SIZE) - i : i)));",
        "ins1DelCode":"if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 4) { for (int i = 0; i < 32; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 24 - i : i)));",
        "ins1PreCode":"private IoBuffer putInt(Pointer pointer, int value) { if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 4) { throw new BufferUnderflowException(); } for (int i = 0; i < 32; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 24 - i : i))); } return this;",
        "ins2PreCode":"private IoBuffer putShort(Pointer pointer, short value) { if (position.getPosition() > pointer.getPosition() || pointer.getPosition() > limit.getPosition() - 2) { throw new BufferUnderflowException(); } for (int i = 0; i < 16; i += 8) { put(pointer, (byte) (value >> (bo == ByteOrder.BIG_ENDIAN ? 8 - i : i))); } return this;",
        "label":0
    },
    {
        "ins1AddCode":"void addLogFileProperty() {",
        "ins1DelCode":"public void addLogFileProperty() {",
        "ins1PreCode":"public void addLogFileProperty() { addPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.name=\" + this.logFile);",
        "ins2PreCode":"public void addLogPathProperty() { addPropertiesToEnvironment(this.context, \"logging.config=classpath:logback-nondefault.xml\", \"logging.file.path=\" + this.temp.getRoot());",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertEquals(o1, r); Assert.assertNull(q.first); Assert.assertNull(q.last);",
        "ins1DelCode":"assertEquals(o1, r); assertNull(q.first); assertNull(q.last);",
        "ins1PreCode":" Object r = q.pop();  assertEquals(o1, r); assertNull(q.first); assertNull(q.last);",
        "ins2PreCode":"Object r = q.unpush(); assertEquals(o1, r); assertNull(q.first); assertNull(q.last);",
        "label":1
    },
    {
        "ins1AddCode":"for (String blockId : blockIds) {",
        "ins1DelCode":"for (int chunkIndex = 0; chunkIndex < blockIds.length; chunkIndex++) { String blockId = blockIds[chunkIndex];",
        "ins1PreCode":"new long[]{0, 2, 10}, new int[][]{{0}, {1}, {2}}, false), conf);  for (int chunkIndex = 0; chunkIndex < blockIds.length; chunkIndex++) { String blockId = blockIds[chunkIndex]; verify(listener).onBlockFetchSuccess(blockId, blocks.get(blockId)); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() {",
        "ins1DelCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() {",
        "ins1PreCode":"public void testAnnotatedInsertTable2WithSelectKeyWithKeyMap() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "ins2PreCode":"public void testAnnotatedInsertTable3() { try (SqlSession sqlSession = sqlSessionFactory.openSession()) { Name name = new Name();",
        "label":1
    },
    {
        "ins1AddCode":"private void validateLifetime(final PooledObject<PooledConnectionAndInfo> p) final long lifetime = System.currentTimeMillis() - p.getCreateTime();",
        "ins1DelCode":"private void validateLifetime(PooledObject<PooledConnectionAndInfo> p) long lifetime = System.currentTimeMillis() - p.getCreateTime();",
        "ins1PreCode":"private void validateLifetime(PooledObject<PooledConnectionAndInfo> p) throws Exception { if (maxConnLifetimeMillis > 0) { long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) { throw new Exception(Utils.getMessage(",
        "ins2PreCode":"private void validateLifetime(PooledObject<PooledConnectionAndInfo> p) throws Exception { if (maxConnLifetimeMillis > 0) { long lifetime = System.currentTimeMillis() - p.getCreateTime(); if (lifetime > maxConnLifetimeMillis) { throw new Exception(Utils.getMessage(",
        "label":1
    },
    {
        "ins1AddCode":"throw new InvalidProtocolBufferException(\"Not an int64 value: \" + json);",
        "ins1DelCode":"throw new InvalidProtocolBufferException(\"Not an int32 value: \" + json);",
        "ins1PreCode":"BigDecimal value = new BigDecimal(json.getAsString()); return value.longValueExact(); } catch (Exception e) { throw new InvalidProtocolBufferException(\"Not an int32 value: \" + json); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"\"def [\" + PainlessLookupUtility.typeToUnboxedType(value.getClass()).getCanonicalName() + \"] to \" + Short.class.getCanonicalName());",
        "ins1DelCode":"\"def [\" + value.getClass().getCanonicalName() + \"] to \" + Short.class.getCanonicalName());",
        "ins1PreCode":"return ((Number)value).shortValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Short.class.getCanonicalName()); }",
        "ins2PreCode":"return ((Number)value).intValue(); } else { throw new ClassCastException(\"cannot explicitly cast \" + \"def [\" + value.getClass().getCanonicalName() + \"] to \" + Integer.class.getCanonicalName()); }",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < 50; i++) jj_la1[i] = -1;",
        "ins1DelCode":"for (int i = 0; i < 51; i++) jj_la1[i] = -1;",
        "ins1PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "ins2PreCode":"jj_ntk = -1; jjtree.reset(); jj_gen = 0; for (int i = 0; i < 51; i++) jj_la1[i] = -1; for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();",
        "label":1
    },
    {
        "ins1AddCode":"setMapValuesUsingMutableMap(builder); updateMapValuesUsingMutableMap(builder); assertMapValuesCleared(builder);",
        "ins1DelCode":"setMapValues(builder); updateMapValues(builder);",
        "ins1PreCode":"assertMapValuesCleared(message);  builder = message.toBuilder(); setMapValues(builder); message = builder.build(); assertMapValuesSet(message);  builder = message.toBuilder(); updateMapValues(builder); message = builder.build(); assertMapValuesUpdated(message);",
        "ins2PreCode":"assertMapValuesCleared(message); builder = message.toBuilder(); setMapValues(builder); message = builder.build(); assertMapValuesSet(message); builder = message.toBuilder(); updateMapValues(builder); message = builder.build(); assertMapValuesUpdated(message);",
        "label":0
    },
    {
        "ins1AddCode":"public final <@NonNull TRight, @NonNull TLeftEnd, @NonNull TRightEnd, @NonNull R> Flowable<R> join( @NonNull Publisher<? extends TRight> other, @NonNull Function<? super T, @NonNull ? extends Publisher<TLeftEnd>> leftEnd, @NonNull Function<? super TRight, @NonNull ? extends Publisher<TRightEnd>> rightEnd,",
        "ins1DelCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( @NonNull Publisher<@NonNull ? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<@NonNull TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<@NonNull TRightEnd>> rightEnd,",
        "ins1PreCode":"public final <TRight, TLeftEnd, TRightEnd, R> Flowable<R> join( @NonNull Publisher<@NonNull ? extends TRight> other, @NonNull Function<? super T, ? extends Publisher<@NonNull TLeftEnd>> leftEnd, @NonNull Function<? super TRight, ? extends Publisher<@NonNull TRightEnd>> rightEnd, @NonNull BiFunction<? super T, ? super TRight, ? extends R> resultSelector) { Objects.requireNonNull(other, \"other is null\");",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"TestSubscriber<Integer> ts1 = new TestSubscriber<>(2L); TestSubscriber<Integer> ts2 = new TestSubscriber<>(2L); TestSubscriber<Integer> ts21 = new TestSubscriber<>(1L); TestSubscriber<Integer> ts22 = new TestSubscriber<>(1L); TestSubscriber<Integer> ts3 = new TestSubscriber<>();",
        "ins1DelCode":"TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(2L); TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(2L); TestSubscriber<Integer> ts21 = new TestSubscriber<Integer>(1L); TestSubscriber<Integer> ts22 = new TestSubscriber<Integer>(1L); TestSubscriber<Integer> ts3 = new TestSubscriber<Integer>();",
        "ins1PreCode":"ConnectableFlowable<Integer> source = Flowable.range(1, 10).replay(1, true); source.connect();  TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(2L);  source.subscribe(ts1);  ts1.assertValues(1, 2); ts1.assertNoErrors(); ts1.cancel();  TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(2L);  source.subscribe(ts2);  ts2.assertValues(2, 3); ts2.assertNoErrors(); ts2.cancel();  TestSubscriber<Integer> ts21 = new TestSubscriber<Integer>(1L);  source.subscribe(ts21);  ts21.assertValues(3); ts21.assertNoErrors(); ts21.cancel();  TestSubscriber<Integer> ts22 = new TestSubscriber<Integer>(1L);  source.subscribe(ts22);  ts22.assertValues(3); ts22.assertNoErrors(); ts22.cancel();  TestSubscriber<Integer> ts3 = new TestSubscriber<Integer>();  source.subscribe(ts3);",
        "ins2PreCode":"ConnectableFlowable<Integer> source = Flowable.range(1, 10).replay(1); source.connect(); TestSubscriber<Integer> ts1 = new TestSubscriber<Integer>(2L); source.subscribe(ts1); ts1.assertValues(1, 2); ts1.assertNoErrors(); ts1.cancel(); TestSubscriber<Integer> ts2 = new TestSubscriber<Integer>(2L); source.subscribe(ts2); ts2.assertValues(2, 3); ts2.assertNoErrors(); ts2.cancel(); TestSubscriber<Integer> ts21 = new TestSubscriber<Integer>(1L); source.subscribe(ts21); ts21.assertValues(3); ts21.assertNoErrors(); ts21.cancel(); TestSubscriber<Integer> ts22 = new TestSubscriber<Integer>(1L); source.subscribe(ts22); ts22.assertValues(3); ts22.assertNoErrors(); ts22.cancel(); TestSubscriber<Integer> ts3 = new TestSubscriber<Integer>(); source.subscribe(ts3);",
        "label":1
    },
    {
        "ins1AddCode":"void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception {",
        "ins1DelCode":"public void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception {",
        "ins1PreCode":"public void shutdownWhenShutdownOperationIsPushPerformsPushOnShutdown() throws Exception { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, ShutdownOperation.PUSH);",
        "ins2PreCode":"public void shutdownWhenShutdownOperationIsNoneDoesNothing() { PrometheusPushGatewayManager manager = new PrometheusPushGatewayManager(this.pushGateway, this.registry, this.scheduler, this.pushRate, \"job\", this.groupingKey, ShutdownOperation.NONE);",
        "label":1
    },
    {
        "ins1AddCode":"factory.create(null, null, null, config);",
        "ins1DelCode":"factory.create(null, null, config);",
        "ins1PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch (ElasticsearchParseException e) {",
        "ins2PreCode":"Map<String, Object> config = new HashMap<>(); config.put(\"field\", \"field1\"); try { factory.create(null, null, config); fail(\"factory create should have failed\"); } catch (ElasticsearchParseException e) {",
        "label":1
    },
    {
        "ins1AddCode":"void shouldEqualsTriggerLazyLoading() {",
        "ins1DelCode":"public void shouldEqualsTriggerLazyLoading() {",
        "ins1PreCode":"public void shouldEqualsTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "ins2PreCode":"public void shouldCloneTriggerLazyLoading() { sqlSessionFactory.getConfiguration().setAggressiveLazyLoading(false); try (SqlSession sqlSession = sqlSessionFactory.openSession()) {",
        "label":1
    },
    {
        "ins1AddCode":"XYDataset<String> dataset = new XYSeriesCollection<>(series1);",
        "ins1DelCode":"XYDataset dataset = new XYSeriesCollection<String>(series1);",
        "ins1PreCode":"series1.add(10.0, 10.0); series1.add(20.0, 20.0); series1.add(30.0, 30.0); XYDataset dataset = new XYSeriesCollection<String>(series1);  LocalListener l = new LocalListener();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"e.append(\"java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") e.append(\"java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.rxjava3.core.\") .append(\"Maybe.method(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
        "ins1DelCode":"e.append(\"java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\\r\\n at io.reactivex.\") e.append(\"java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); e.append(\"java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\");",
        "ins1PreCode":"&& !m.signature.contains(\"Flowable\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Subscriber\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") && !m.signature.contains(\"TestSubscriber\") ) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Subscription\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") ) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observer\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"TestObserver\")) {  if (idx < 5 || !m.javadoc.substring(idx - 5, idx + 8).equals(\"MaybeObserver\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Observer but not using Observable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Publisher\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\")) { if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(\"(Publisher\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Publisher but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } }  jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Flowable but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Single\", jdx); if (idx >= 0) { int j = m.javadoc.indexOf(\"#toSingle\", jdx); int k = m.javadoc.indexOf(\"{@code Single\", jdx); if (!m.signature.contains(\"Single\") && (j + 3 != idx && k + 7 != idx)) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Single but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe(Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"SingleSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"SingleSource\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions Observable but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"ObservableSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Maybe doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6;",
        "ins2PreCode":"&& !m.signature.contains(\"Flowable\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions onNext but no Flowable/Observable in signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Subscriber\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") && !m.signature.contains(\"TestSubscriber\")) { ) { e.append(\"java.lang.RuntimeException: Single doc mentions Subscriber but not using Flowable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Subscription\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\") && !m.signature.contains(\"Flowable\") ) { e.append(\"java.lang.RuntimeException: Single doc mentions Subscription but not using Flowable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Observer\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\") && !m.signature.contains(\"Observable\") && !m.signature.contains(\"TestObserver\")) { if (idx < 6 || !m.javadoc.substring(idx - 6, idx + 8).equals(\"SingleObserver\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observer but not using Observable\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"Publisher\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Publisher\")) { if (idx == 0 || !m.javadoc.substring(idx - 1, idx + 9).equals(\"(Publisher\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Publisher but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Flowable but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\"onNext\", jdx); if (idx >= 0) { int idx = m.javadoc.indexOf(\" Flowable\", jdx); int idx = m.javadoc.indexOf(\" Flowable\", jdx); if (!m.signature.contains(\"Flowable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" MaybeSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"MaybeSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions SingleSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" Observable\", jdx); if (idx >= 0) { if (!m.signature.contains(\"Observable\")) { e.append(\"java.lang.RuntimeException: Single doc mentions Observable but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6; } else { break; } } jdx = 0; for (;;) { int idx = m.javadoc.indexOf(\" ObservableSource\", jdx); if (idx >= 0) { if (!m.signature.contains(\"ObservableSource\")) { e.append(\"java.lang.RuntimeException: Single doc mentions ObservableSource but not in the signature\\r\\n at io.reactivex.\") .append(\"Maybe (Maybe.java:\").append(m.javadocLine + lineNumber(m.javadoc, idx) - 1).append(\")\\r\\n\\r\\n\"); } jdx = idx + 6;",
        "label":1
    },
    {
        "ins1AddCode":"DomNodeList<DomNode> tds = page.getDocumentElement().querySelectorAll(\"table[data-is-distributed-build-enabled=false] td\");",
        "ins1DelCode":"DomNodeList<DomNode> tds = page.getDocumentElement().querySelectorAll(\"table[data-is-master-slave-enabled=false] td\");",
        "ins1PreCode":"wc.withThrowExceptionOnFailingStatusCode(false); HtmlPage page = wc.getPage(p, \"buildTimeTrend\");  DomNodeList<DomNode> tds = page.getDocumentElement().querySelectorAll(\"table[data-is-master-slave-enabled=false] td\"); Optional<DomNode> td = tds.stream() .filter(t -> t.getTextContent().equals(\"#1\"))",
        "ins2PreCode":"wc.withThrowExceptionOnFailingStatusCode(false); HtmlPage page = wc.getPage(p, \"buildTimeTrend\"); DomNodeList<DomNode> tds = page.getDocumentElement().querySelectorAll(\"table[data-is-master-slave-enabled=true] td\"); Optional<DomNode> td = tds.stream() .filter(t -> t.getTextContent().equals(\"#1\"))",
        "label":1
    },
    {
        "ins1AddCode":"LatexParserResult parserResult = new DefaultLatexParser().parse(texFile); LatexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); LatexBibEntriesResolverResult expectedCrossingResult = new LatexBibEntriesResolverResult(parserResult);",
        "ins1DelCode":"TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);",
        "ins1PreCode":"public void testUnknownKey() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"unknown_key.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile);  TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult);  assertEquals(expectedCrossingResult, crossingResult);",
        "ins2PreCode":"public void testNestedFiles() throws URISyntaxException { Path texFile = Paths.get(TexBibEntriesResolverTest.class.getResource(\"nested.tex\").toURI()); TexParserResult parserResult = new DefaultTexParser().parse(texFile); TexBibEntriesResolverResult crossingResult = new TexBibEntriesResolver(database, importFormatPreferences, fileMonitor).resolve(parserResult); TexBibEntriesResolverResult expectedCrossingResult = new TexBibEntriesResolverResult(parserResult); assertEquals(expectedCrossingResult, crossingResult);",
        "label":1
    },
    {
        "ins1AddCode":"TestUtils.serialised(d1);",
        "ins1DelCode":"TestUtilities.serialised(d1);",
        "ins1PreCode":"d1.add(new Date(1L), new BoxAndWhiskerItem(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, new ArrayList())); DefaultBoxAndWhiskerXYDataset d2 = (DefaultBoxAndWhiskerXYDataset) TestUtilities.serialised(d1); assertEquals(d1, d2); ",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"tc.onSubscribe(Disposable.empty()); Disposable d = Disposable.empty();",
        "ins1DelCode":"tc.onSubscribe(Disposables.empty()); Disposable d = Disposables.empty();",
        "ins1PreCode":"try { TestResourceObserver<Integer> tc = new TestResourceObserver<Integer>();  tc.onSubscribe(Disposables.empty());  Disposable d = Disposables.empty();  tc.onSubscribe(d);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public UnsafeRow getStruct(int ordinal, int numFields) {",
        "ins1DelCode":"public InternalRow getStruct(int ordinal, int numFields) {",
        "ins1PreCode":"public InternalRow getStruct(int ordinal, int numFields) { assertIndexIsValid(ordinal); final int offset = getElementOffset(ordinal);",
        "ins2PreCode":"public UnsafeRow getStruct(int ordinal, int numFields) { final long offsetAndSize = getLong(ordinal); final long offsetAndSize = getLong(ordinal);",
        "label":0
    },
    {
        "ins1AddCode":"clone.seriesKeys = new ArrayList(this.seriesKeys); double[][] data = this.seriesList.get(i);",
        "ins1DelCode":"clone.seriesKeys = new java.util.ArrayList(this.seriesKeys); double[][] data = (double[][]) this.seriesList.get(i);",
        "ins1PreCode":"public Object clone() throws CloneNotSupportedException { DefaultXYDataset clone = (DefaultXYDataset) super.clone(); clone.seriesKeys = new java.util.ArrayList(this.seriesKeys); clone.seriesList = new ArrayList(this.seriesList.size()); for (int i = 0; i < this.seriesList.size(); i++) { double[][] data = (double[][]) this.seriesList.get(i); double[] x = data[0]; double[] y = data[1];",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"public String toString() { StringBuilder sb = new StringBuilder(); sb.append( \"HTTP RESPONSE STATUS: \" ).append( status ).append( '\\n' ); sb.append( \"VERSION: \" ).append( version ).append( '\\n' ); sb.append( \"--- HEADER --- \\n\" ); for ( String key : headers.keySet() ) { String value = headers.get( key ); sb.append( key ).append( ':' ).append( value ).append( '\\n' ); return sb.toString();",
        "ins1DelCode":"public String toString() { String result = \"HTTP RESPONSE STATUS: \" + status + \"\\n\"; result += \"VERSION: \" + version + \"\\n\"; result += \"--- HEADER --- \\n\"; for (String key : headers.keySet()) { String value = headers.get(key); result += key + \":\" + value + \"\\n\"; return result;",
        "ins1PreCode":"public String toString() { String result = \"HTTP RESPONSE STATUS: \" + status + \"\\n\"; result += \"VERSION: \" + version + \"\\n\";  result += \"--- HEADER --- \\n\"; for (String key : headers.keySet()) { String value = headers.get(key); result += key + \":\" + value + \"\\n\"; }  return result;",
        "ins2PreCode":"public String toString() { String result = \"HTTP REQUEST METHOD: \" + method + \"\\n\"; result += \"VERSION: \" + version + \"\\n\"; result += \"--- HEADER --- \\n\"; for (String key : headers.keySet()) { String value = headers.get(key); result += key + \":\" + value + \"\\n\"; } return result;",
        "label":1
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"assertWarnings(RestMultiSearchTemplateAction.TYPES_DEPRECATION_MESSAGE);",
        "ins1PreCode":"assertEquals(1, request.requests().get(1).getScriptParams().size()); assertEquals(1, request.requests().get(2).getScriptParams().size());  assertWarnings(RestMultiSearchTemplateAction.TYPES_DEPRECATION_MESSAGE);",
        "ins2PreCode":"assertEquals(1, request.requests().get(0).getScriptParams().size()); assertEquals(1, request.requests().get(0).getScriptParams().size()); MultiSearchTemplateRequest request = RestMultiSearchTemplateAction.parseRequest(restRequest, true);",
        "label":0
    },
    {
        "ins1AddCode":"void bufferRequestBodyCanBeConfiguredOnHttpComponentsRequestFactory() {",
        "ins1DelCode":"public void bufferRequestBodyCanBeConfiguredOnHttpComponentsRequestFactory() {",
        "ins1PreCode":"public void bufferRequestBodyCanBeConfiguredOnHttpComponentsRequestFactory() { ClientHttpRequestFactory requestFactory = this.builder .requestFactory(HttpComponentsClientHttpRequestFactory.class).setBufferRequestBody(false).build()",
        "ins2PreCode":"public void bufferRequestBodyCanBeConfiguredOnSimpleRequestFactory() { ClientHttpRequestFactory requestFactory = this.builder.requestFactory(SimpleClientHttpRequestFactory.class) requestFactory = this.builder.requestFactory(SimpleClientHttpRequestFactory.class).setBufferRequestBody(true)",
        "label":1
    },
    {
        "ins1AddCode":"public void verifyThatHeaderWithoutLeadingSpaceIsSupported() throws UnsupportedEncodingException, ProtocolDecoderException { HttpDecoderState state = decoder.createDecoderState(); HttpPdu[] pdus = decoder.decode(buffer, state); assertEquals(\"localhost\", ((HttpRequestImpl) pdus[0]).getHeader(\"host\"));",
        "ins1DelCode":"public void verifyThatHeaderWithoutLeadingSpaceIsSupported() throws UnsupportedEncodingException, ProtocolDecoderException { HttpPdu[] pdus = decoder.decode(buffer); assertEquals(\"localhost\", ((HttpRequestImpl)pdus[0]).getHeader(\"host\"));",
        "ins1PreCode":"public void verifyThatHeaderWithoutLeadingSpaceIsSupported() throws UnsupportedEncodingException, ProtocolDecoderException { String reqStr = \"GET / HTTP/1.0\\r\\nHost:localhost\\r\\n\\r\\n\"; ByteBuffer buffer = ByteBuffer.allocate(reqStr.length()); buffer.put(reqStr.getBytes(\"US-ASCII\")); buffer.rewind(); HttpServerDecoder decoder = new HttpServerDecoder(); HttpPdu[] pdus = decoder.decode(buffer); assertNotNull(pdus); assertEquals(1, pdus.length); assertEquals(\"localhost\", ((HttpRequestImpl)pdus[0]).getHeader(\"host\"));",
        "ins2PreCode":"public void verifyThatLeadingSpacesAreRemovedFromHeader() throws UnsupportedEncodingException, ProtocolDecoderException { String reqStr = \"GET / HTTP/1.0\\r\\nHost:  localhost\\r\\n\\r\\n\"; ByteBuffer buffer = ByteBuffer.allocate(reqStr.length()); buffer.put(reqStr.getBytes(\"US-ASCII\")); buffer.rewind(); HttpServerDecoder decoder = new HttpServerDecoder(); HttpPdu[] pdus = decoder.decode(buffer); assertNotNull(pdus); assertEquals(1, pdus.length); assertEquals(\"localhost\", ((HttpRequestImpl)pdus[0]).getHeader(\"host\"));",
        "label":1
    },
    {
        "ins1AddCode":"XYPlot<?> plot = (XYPlot) this.chart.getPlot();",
        "ins1DelCode":"XYPlot<String> plot = (XYPlot) this.chart.getPlot();",
        "ins1PreCode":"public void testSetSeriesToolTipGenerator() { XYPlot<String> plot = (XYPlot) this.chart.getPlot(); XYItemRenderer renderer = plot.getRenderer(); StandardXYToolTipGenerator tt = new StandardXYToolTipGenerator();",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"if (skipFailedTransfers) {",
        "ins1DelCode":"if (skipFailedTransfers == true) {",
        "ins1PreCode":"if (!ftp.deleteFile(resolveFile(filename))) { String s = \"could not delete file: \" + ftp.getReplyString();  if (skipFailedTransfers == true) { log(s, Project.MSG_WARN); skipped++;",
        "ins2PreCode":"if (!ftp.removeDirectory(resolveFile(dirname))) { String s = \"could not remove directory: \" + ftp.getReplyString(); if (skipFailedTransfers == true) { log(s, Project.MSG_WARN); skipped++;",
        "label":1
    },
    {
        "ins1AddCode":"final Disposable d = Disposable.empty();",
        "ins1DelCode":"final Disposable d = Disposables.empty();",
        "ins1PreCode":"public void basic() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty();  Maybe.<Integer>create(new MaybeOnSubscribe<Integer>() {",
        "ins2PreCode":"public void basic() { List<Throwable> errors = TestHelper.trackPluginErrors(); try { final Disposable d = Disposables.empty(); Maybe.<Integer>create(new MaybeOnSubscribe<Integer>() {",
        "label":1
    },
    {
        "ins1AddCode":"WebClient.Builder webClientBuilder) { this.applicationContext, parameterMapper, endpointMediaTypes, EndpointPathResolver.useEndpointId(), null, null); ReactiveCloudFoundrySecurityInterceptor securityInterceptor = getSecurityInterceptor( webClientBuilder, this.applicationContext.getEnvironment()); getCorsConfiguration(), securityInterceptor);",
        "ins1DelCode":"WebClient.Builder webClientBuilder, Environment environment, DefaultCachingConfigurationFactory cachingConfigurationFactory, WebEndpointProperties webEndpointProperties) { this.applicationContext, parameterMapper, cachingConfigurationFactory, endpointMediaTypes, (id) -> id); getCorsConfiguration(), getSecurityInterceptor(webClientBuilder, environment));",
        "ins1PreCode":"public CloudFoundryWebFluxEndpointHandlerMapping cloudFoundryWebFluxEndpointHandlerMapping( ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, WebClient.Builder webClientBuilder, Environment environment, DefaultCachingConfigurationFactory cachingConfigurationFactory, WebEndpointProperties webEndpointProperties) { WebAnnotationEndpointDiscoverer endpointDiscoverer = new WebAnnotationEndpointDiscoverer( this.applicationContext, parameterMapper, cachingConfigurationFactory, endpointMediaTypes, (id) -> id); return new CloudFoundryWebFluxEndpointHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, getCorsConfiguration(), getSecurityInterceptor(webClientBuilder, environment));",
        "ins2PreCode":"public CloudFoundryWebEndpointServletHandlerMapping cloudFoundryWebEndpointServletHandlerMapping( ParameterMapper parameterMapper, EndpointMediaTypes endpointMediaTypes, Environment environment, DefaultCachingConfigurationFactory cachingConfigurationFactory, endpointMediaTypes, EndpointPathResolver.useEndpointId()); WebAnnotationEndpointDiscoverer endpointDiscoverer = new WebAnnotationEndpointDiscoverer( this.applicationContext, parameterMapper, cachingConfigurationFactory, endpointMediaTypes, EndpointPathResolver.useEndpointId()); return new CloudFoundryWebEndpointServletHandlerMapping( new EndpointMapping(\"/cloudfoundryapplication\"), endpointDiscoverer.discoverEndpoints(), endpointMediaTypes, getCorsConfiguration(), getSecurityInterceptor(builder, environment)); getCorsConfiguration(), getSecurityInterceptor(builder, environment));",
        "label":0
    },
    {
        "ins1AddCode":"validatePrediction(model, users, products, testData._2(), 0.3, false, testData._3());",
        "ins1DelCode":"validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins1PreCode":" JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = ALS.train(data.rdd(), features, iterations); validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "ins2PreCode":"JavaRDD<Rating> data = sc.parallelize(testData._1()); MatrixFactorizationModel model = new ALS().setRank(features) validatePrediction(model, users, products, features, testData._2(), 0.3, false, testData._3());",
        "label":0
    },
    {
        "ins1AddCode":"while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count.get()) Thread.sleep(500); assertEquals(\"Checking success messages.\",msgCount,listener1.count.get());",
        "ins1DelCode":"while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count) Thread.sleep(500); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins1PreCode":"for (int i=0; i<msgCount; i++) channel1.send(new Member[] {channel2.getLocalMember(false)},Data.createRandomData(1024),GroupChannel.SEND_OPTIONS_ASYNCHRONOUS|Channel.SEND_OPTIONS_UDP);  long start = System.currentTimeMillis(); while ( (System.currentTimeMillis()-start)<5000 && msgCount!=listener1.count) Thread.sleep(500); System.err.println(\"Finished ASYNC\"); assertEquals(\"Checking success messages.\",msgCount,listener1.count);",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"dbStat.setInt(1, (int) options.get(sidWait)); dbStat.setInt(1, (int) options.get(sidHold));",
        "ins1DelCode":"dbStat.setInt(1, (int) options.get(OracleLockEditor.sidWait)); dbStat.setInt(1, (int) options.get(OracleLockEditor.sidHold));",
        "ins1PreCode":"switch (otype) {  case LockManagerViewer.typeWait: dbStat.setInt(1, (int) options.get(OracleLockEditor.sidWait)); break;  case LockManagerViewer.typeHold: dbStat.setInt(1, (int) options.get(OracleLockEditor.sidHold)); break; ",
        "ins2PreCode":"switch(otype) { case LockGraphManager.typeWait: dbStat.setBigDecimal(1, new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidWait))); break; case LockGraphManager.typeHold: dbStat.setBigDecimal(1,  new BigDecimal((BigInteger) options.get(ExasolLockEditor.sidHold))); break;",
        "label":1
    },
    {
        "ins1AddCode":"CategoryPlot<String, String> plot = new CategoryPlot<>(null, new CategoryAxis(",
        "ins1DelCode":"CategoryPlot plot = new CategoryPlot(null, new CategoryAxis(",
        "ins1PreCode":"  r.setAutoPopulateSeriesPaint(true); CategoryPlot plot = new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r); assertEquals(DefaultDrawingSupplier.DEFAULT_PAINT_SEQUENCE[0],",
        "ins2PreCode":"r.setAutoPopulateSeriesFillPaint(true); new CategoryPlot(null, new CategoryAxis( \"Category\"), new NumberAxis(\"Value\"), r); assertEquals(DefaultDrawingSupplier.DEFAULT_FILL_PAINT_SEQUENCE[0],",
        "label":0
    },
    {
        "ins1AddCode":"expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 's'; char b = d;\"));",
        "ins1DelCode":"",
        "ins1PreCode":"public void testdefTocharImplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; char b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = true; char b = d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; char b = d;\"));",
        "ins2PreCode":"public void testdefTobooleanExplicit() { expectScriptThrows(ClassCastException.class, () -> exec(\"def d = 'string'; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; boolean b = (boolean)d;\")); expectScriptThrows(ClassCastException.class, () -> exec(\"def d = (byte)0; boolean b = (boolean)d;\"));",
        "label":0
    },
    {
        "ins1AddCode":"HtmlPage p = j.createWebClient().goTo(\"self/testSimpleWithDeleteButton\");",
        "ins1DelCode":"HtmlPage p = createWebClient().goTo(\"self/testSimpleWithDeleteButton\");",
        "ins1PreCode":"public void testSimpleCheckNumberOfButtons() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testSimpleWithDeleteButton\"); HtmlForm f = p.getFormByName(\"config\"); String buttonCaption = \"Add\";",
        "ins2PreCode":"public void testSimpleCheckNumberOfButtonsEnabledTopButton() throws Exception { HtmlPage p = createWebClient().goTo(\"self/testSimpleWithDeleteButtonTopButton\"); HtmlForm f = p.getFormByName(\"config\"); String buttonCaption = \"Add\";",
        "label":1
    },
    {
        "ins1AddCode":"TestObserver<Integer> to = new TestObserver<>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<>(32);",
        "ins1DelCode":"TestObserver<Integer> to = new TestObserver<Integer>(); SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);",
        "ins1PreCode":"public void observerCheckTerminatedNonDelayErrorError() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty());  ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; }  @Override public boolean done() { return false; }  @Override public Throwable error() { return new TestException(); }  @Override public boolean enter() { return true; }  @Override public int leave(int m) { return 0; }  @Override public void accept(Observer<? super Integer> a, Integer v) { } };  SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32);  QueueDrainHelper.checkTerminated(true, false, to, false, q, null, qd);",
        "ins2PreCode":"public void observerCheckTerminatedNonDelayErrorErrorResource() { TestObserver<Integer> to = new TestObserver<Integer>(); to.onSubscribe(Disposable.empty()); ObservableQueueDrain<Integer, Integer> qd = new ObservableQueueDrain<Integer, Integer>() { @Override public boolean cancelled() { return false; } @Override public boolean done() { return false; } @Override public Throwable error() { return new TestException(); } @Override public boolean enter() { return true; } @Override public int leave(int m) { return 0; } @Override public void accept(Observer<? super Integer> a, Integer v) { } }; SpscArrayQueue<Integer> q = new SpscArrayQueue<Integer>(32); QueueDrainHelper.checkTerminated(true, false, to, false, q, d, qd);",
        "label":1
    },
    {
        "ins1AddCode":"throw new BuildException(\"Failed executing: \" + commandLine, getLocation());",
        "ins1DelCode":"String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation());",
        "ins1PreCode":" int result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "ins2PreCode":"result = run(commandLine); if (Execute.isFailure(result)) { String msg = \"Failed executing: \" + commandLine.toString(); throw new BuildException(msg, getLocation()); }",
        "label":0
    },
    {
        "ins1AddCode":"",
        "ins1DelCode":"@SuppressWarnings(\"unchecked\")",
        "ins1PreCode":"public void zipIterableObject() { @SuppressWarnings(\"unchecked\") final List<Observable<Integer>> observables = Arrays.asList(Observable.just(1, 2, 3), Observable.just(1, 2, 3)); Observable.zip(observables, new Function<Object[], Object>() {",
        "ins2PreCode":"public void zipIterableObject() { @SuppressWarnings(\"unchecked\") final List<Flowable<Integer>> flowables = Arrays.asList(Flowable.just(1, 2, 3), Flowable.just(1, 2, 3)); Flowable.zip(flowables, new Function<Object[], Object>() {",
        "label":1
    },
    {
        "ins1AddCode":".contentType(MediaType.parseMediaType(ActuatorMediaType.V3_JSON))",
        "ins1DelCode":".contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON))",
        "ins1PreCode":"void setLoggerGroupWithNullLogLevel() { this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON)) .bodyValue(Collections.singletonMap(\"configuredLevel\", null)).exchange().expectStatus().isNoContent(); verify(this.loggingSystem).setLogLevel(\"test.member1\", null);",
        "ins2PreCode":"void setLoggerGroupWithNoLogLevel() { this.client.post().uri(\"/actuator/loggers/test\") .contentType(MediaType.parseMediaType(ActuatorMediaType.V2_JSON)).bodyValue(Collections.emptyMap()) .exchange().expectStatus().isNoContent(); verify(this.loggingSystem).setLogLevel(\"test.member1\", null);",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file, StandardCharsets.UTF_8), Result.FAILURE.toString());",
        "ins1DelCode":"assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "ins1PreCode":"j.assertLogContains(\"Threw AbortException from publisher!\", b); File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "ins2PreCode":"j.assertLogContains(\"Threw IOException from publisher!\", b); File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertEquals(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "label":1
    },
    {
        "ins1AddCode":"if (!isDisposed()) { o.subscribe(this); }",
        "ins1DelCode":"o.subscribe(this);",
        "ins1PreCode":"return; }  o.subscribe(this);",
        "ins2PreCode":"return; } o.subscribe(this);",
        "label":1
    },
    {
        "ins1AddCode":"for (int i = 0; i < (bibEntries.size() - 1); i++) {",
        "ins1DelCode":"for (int i = 0; i < bibEntries.size() - 1; i++) {",
        "ins1PreCode":".append(escape(\"TYPE\")) .append(\") VALUES(?)\");  for (int i = 0; i < bibEntries.size() - 1; i++) { insertIntoEntryQuery.append(\", (?)\"); }",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"Disposable d = Disposable.empty();",
        "ins1DelCode":"Disposable d = Disposables.empty();",
        "ins1PreCode":"public void cancelDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d); ",
        "ins2PreCode":"public void cancelDetaches() throws Exception { Disposable d = Disposables.empty(); final WeakReference<Disposable> wr = new WeakReference<Disposable>(d);",
        "label":1
    },
    {
        "ins1AddCode":"linkedFile = new LinkedFile(\"\", Path.of(\"!!nonexistent file!!\"), \"\"); any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));",
        "ins1DelCode":"linkedFile = new LinkedFile(\"\", \"!!nonexistent file!!\", \"\"); any(AlertType.class), anyString(), anyString(), any(ButtonType.class), any(ButtonType.class), any(ButtonType.class))).thenAnswer(invocation -> Optional.of(invocation.getArgument(4)));",
        "ins1PreCode":"void deleteMissingFileReturnsTrue() { linkedFile = new LinkedFile(\"\", \"!!nonexistent file!!\", \"\"); when(dialogService.showCustomButtonDialogAndWait( any(AlertType.class),",
        "ins2PreCode":"void deleteWhenDialogCancelledReturnsFalseAndDoesNotRemoveFile() { linkedFile = new LinkedFile(\"desc\", tempFile.toString(), \"pdf\"); when(dialogService.showCustomButtonDialogAndWait( any(AlertType.class),",
        "label":0
    },
    {
        "ins1AddCode":"private static void evaluateArray( Object target, InterpolateObjectAction ctx ) String interpolated = ctx.interpolate( (String) value ); ctx.interpolationTargets.add( value );",
        "ins1DelCode":"private void evaluateArray( Object target ) String interpolated = modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, problems ); interpolationTargets.add( value );",
        "ins1PreCode":"private void evaluateArray( Object target ) { int len = Array.getLength( target ); for ( int i = 0; i < len; i++ ) { Object value = Array.get( target, i ); if ( value != null ) { if ( String.class == value.getClass() ) { String interpolated = modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, problems );  if ( !interpolated.equals( value ) ) { Array.set( target, i, interpolated ); } } else { interpolationTargets.add( value ); } }",
        "ins2PreCode":"private void evaluateArray( Object target ) { int len = Array.getLength( target ); for( int i = 0; i < len; i++ ) { Object value = Array.get( target, i ); if ( value != null ) { if ( String.class == value.getClass() ) { Array.set( target, i, interpolated ); String interpolated = modelInterpolator.interpolateInternal( (String) value, valueSources, postProcessors, debugEnabled ); if ( !interpolated.equals( value ) ) if ( !interpolated.equals( value ) ) { Array.set( target, i, interpolated ); } } else { interpolationTargets.add( value ); } }",
        "label":0
    },
    {
        "ins1AddCode":"cd.add(Disposable.empty());",
        "ins1DelCode":"cd.add(Disposables.empty());",
        "ins1PreCode":"Runnable run = new Runnable() { @Override public void run() { cd.add(Disposables.empty()); } };",
        "ins2PreCode":"Runnable run = new Runnable() { @Override public void run() { cd.add(Disposables.empty()); } };",
        "label":1
    },
    {
        "ins1AddCode":"TestObserverEx<Integer> to = new TestObserverEx<>(QueueFuseable.ANY);",
        "ins1DelCode":"TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);",
        "ins1PreCode":"public void fused() { TestObserverEx<Integer> to = new TestObserverEx<Integer>(QueueFuseable.ANY);  Maybe.just(1).flattenAsObservable(new Function<Integer, Iterable<Integer>>() {",
        "ins2PreCode":"",
        "label":0
    },
    {
        "ins1AddCode":"ParserResult result = new BibtexParser(importFormatPreferences, fileMonitor).parse(new StringReader(bibtexEntry));",
        "ins1DelCode":"ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry));",
        "ins1PreCode":"private String testSingleWrite(String bibtexEntry) throws IOException {  ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();",
        "ins2PreCode":"public void roundTripWithPrecedingCommentTest() throws IOException { ParserResult result = new BibtexParser(importFormatPreferences).parse(new StringReader(bibtexEntry)); Collection<BibEntry> entries = result.getDatabase().getEntries(); BibEntry entry = entries.iterator().next();",
        "label":1
    },
    {
        "ins1AddCode":"void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, new SaveOrderConfig.SortCriterion(\"author\", false), firstEntry.setField(\"year\", \"2010\"); secondEntry.setField(\"year\", \"2000\"); databaseWriter.savePartOfDatabase(bibtexContext, database.getEntries()); \"  year   = {2010},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + OS.NEWLINE, stringWriter.toString());",
        "ins1DelCode":"public void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, new SaveOrderConfig.SortCriterion(\"author\", false), firstEntry.setField(\"year\", \"2000\"); secondEntry.setField(\"year\", \"2010\"); StringSaveSession session = databaseWriter.savePartOfDatabase(bibtexContext, database.getEntries(), new SavePreferences()); \"  year   = {2000},\" + OS.NEWLINE + \"  year   = {2010},\" + OS.NEWLINE + OS.NEWLINE , session.getStringValue());",
        "ins1PreCode":"public void writeEntriesSorted() throws Exception { SaveOrderConfig saveOrderConfig = new SaveOrderConfig(false, new SaveOrderConfig.SortCriterion(\"author\", false), new SaveOrderConfig.SortCriterion(\"year\", true), new SaveOrderConfig.SortCriterion(\"abstract\", false)); metaData.setSaveOrderConfig(saveOrderConfig);  BibEntry firstEntry = new BibEntry(); firstEntry.setType(BibtexEntryTypes.ARTICLE); firstEntry.setField(\"author\", \"A\"); firstEntry.setField(\"year\", \"2000\");  BibEntry secondEntry = new BibEntry(); secondEntry.setType(BibtexEntryTypes.ARTICLE); secondEntry.setField(\"author\", \"A\"); secondEntry.setField(\"year\", \"2010\");  BibEntry thirdEntry = new BibEntry(); thirdEntry.setType(BibtexEntryTypes.ARTICLE); thirdEntry.setField(\"author\", \"B\"); thirdEntry.setField(\"year\", \"2000\");  database.insertEntry(secondEntry); database.insertEntry(thirdEntry); database.insertEntry(firstEntry);  StringSaveSession session = databaseWriter.savePartOfDatabase(bibtexContext, database.getEntries(), new SavePreferences());  assertEquals( OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {A},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\"  + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {A},\" + OS.NEWLINE + \"  year   = {2010},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {B},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: saveOrderConfig:specified;author;false;year;true;abstract;false;}\" + OS.NEWLINE , session.getStringValue());",
        "ins2PreCode":"public void writeEntriesInOriginalOrderWhenNoSaveOrderConfigIsSetInMetadata() throws Exception { SavePreferences preferences = new SavePreferences().withSaveInOriginalOrder(false); firstEntry.setField(\"year\", \"2010\"); StringSaveSession session = databaseWriter.savePartOfDatabase(bibtexContext, database.getEntries(), preferences); database.insertEntry(firstEntry); BibEntry firstEntry = new BibEntry(); firstEntry.setType(BibtexEntryTypes.ARTICLE); firstEntry.setField(\"author\", \"A\"); firstEntry.setField(\"year\", \"2010\"); BibEntry secondEntry = new BibEntry(); secondEntry.setType(BibtexEntryTypes.ARTICLE); secondEntry.setField(\"author\", \"B\"); secondEntry.setField(\"year\", \"2000\"); BibEntry thirdEntry = new BibEntry(); thirdEntry.setType(BibtexEntryTypes.ARTICLE); thirdEntry.setField(\"author\", \"A\"); thirdEntry.setField(\"year\", \"2000\"); database.insertEntry(secondEntry); database.insertEntry(thirdEntry); database.insertEntry(firstEntry); StringSaveSession session = databaseWriter.savePartOfDatabase(bibtexContext, database.getEntries(), preferences); assertEquals( OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {A},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {A},\" + OS.NEWLINE + \"  year   = {2010},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Article{,\" + OS.NEWLINE + \"  author = {B},\" + OS.NEWLINE + \"  year   = {2000},\" + OS.NEWLINE + \"}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" + OS.NEWLINE + OS.NEWLINE + \"@Comment{jabref-meta: databaseType:bibtex;}\" OS.NEWLINE + , session.getStringValue());",
        "label":0
    },
    {
        "ins1AddCode":"queue = new SpscLinkedArrayQueue<>(bufferSize);",
        "ins1DelCode":"queue = new SpscLinkedArrayQueue<T>(bufferSize);",
        "ins1PreCode":"} }  queue = new SpscLinkedArrayQueue<T>(bufferSize);  downstream.onSubscribe(this);",
        "ins2PreCode":"} } queue = new SpscLinkedArrayQueue<T>(bufferSize); downstream.onSubscribe(this);",
        "label":1
    },
    {
        "ins1AddCode":"if (isJdk9OrHigher()) {",
        "ins1DelCode":"if (isJdk9()) {",
        "ins1PreCode":"public void testUnloadableInStaticFieldIfClosed() throws Exception { if (isJdk9()) { return; }",
        "ins2PreCode":"public void testUnloadableInStaticFieldIfClosed() throws Exception { if (isJdk9()) { return; }",
        "label":1
    },
    {
        "ins1AddCode":"ctx.addServletMappingDecoded(mapping, \"Include\"); ctx.addServletMappingDecoded(\"/mapping\", \"Mapping\");",
        "ins1DelCode":"ctx.addServletMapping(mapping, \"Include\"); ctx.addServletMapping(\"/mapping\", \"Mapping\");",
        "ins1PreCode":"Context ctx = tomcat.addContext(contextPath, null);  Tomcat.addServlet(ctx, \"Include\", new NamedIncludeServlet()); ctx.addServletMapping(mapping, \"Include\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\");  tomcat.start();",
        "ins2PreCode":"Context ctx = tomcat.addContext(contextPath, null); Tomcat.addServlet(ctx, \"Forward\", new NamedForwardServlet()); ctx.addServletMapping(mapping, \"Forward\"); Tomcat.addServlet(ctx, \"Mapping\", new MappingServlet()); ctx.addServletMapping(\"/mapping\", \"Mapping\"); tomcat.start();",
        "label":1
    },
    {
        "ins1AddCode":"list.addAll(TERTIARY_LIST); assertEquals(1, (int) list.remove(0)); assertEquals(asList(2, 3), list); assertTrue(list.remove(Integer.valueOf(3))); assertFalse(list.remove(Integer.valueOf(3))); assertEquals(asList(2), list); assertEquals(2, (int) list.remove(0)); try { list.remove(-1); fail(); } catch (IndexOutOfBoundsException e) { } try { list.remove(0); } catch (IndexOutOfBoundsException e) { }",
        "ins1DelCode":"list.add(2); list.add(4); list.add(6); list.remove(1); assertEquals(asList(2, 6), list); list.remove(1); list.remove(0);",
        "ins1PreCode":"public void testRemove() { list.add(2); list.add(4); list.add(6);  list.remove(1); assertEquals(asList(2, 6), list);  list.remove(1); assertEquals(asList(2), list); ",
        "ins2PreCode":"public void testRemove() { list.remove(0); list.remove(0); list.remove(0); list.remove(-1); assertEquals(asList(2, 3), list); list.remove(-1); assertEquals(asList(2), list);",
        "label":0
    },
    {
        "ins1AddCode":"Assert.assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "ins1DelCode":"assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "ins1PreCode":" String result = res.toString();  assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "ins2PreCode":"String result = res.toString(); assertTrue(result.indexOf(\"<p>00-hello world</p>\") > 0);",
        "label":1
    },
    {
        "ins1AddCode":"List<Archive> archives = CollectionUtils.iteratorToList(launcher.getClassPathArchivesIterator());",
        "ins1DelCode":"List<Archive> archives = launcher.getClassPathArchives();",
        "ins1PreCode":"System.setProperty(\"loader.path\", \"nested-jars/app.jar!/foo.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); List<Archive> archives = launcher.getClassPathArchives(); assertThat(archives).hasSize(1).areExactly(1, endingWith(\"foo.jar!/\"));",
        "ins2PreCode":"System.setProperty(\"loader.path\", \"./jars/app.jar\"); System.setProperty(\"loader.main\", \"demo.Application\"); PropertiesLauncher launcher = new PropertiesLauncher(); PropertiesLauncher launcher = new PropertiesLauncher(); assertThat(ReflectionTestUtils.getField(launcher, \"paths\").toString()).isEqualTo(\"[jars/app.jar]\");",
        "label":0
    },
    {
        "ins1AddCode":"updateCheckManager.touch( a, remoteRepository, null );",
        "ins1DelCode":"updateCheckManager.touch( a, remoteRepository );",
        "ins1PreCode":" file.getParentFile().mkdirs(); file.createNewFile(); updateCheckManager.touch( a, remoteRepository );  assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );",
        "ins2PreCode":"file.delete(); file.delete(); updateCheckManager.touch( a, remoteRepository ); assertFalse( updateCheckManager.isUpdateRequired( a, remoteRepository ) );",
        "label":1
    },
    {
        "ins1AddCode":"ConditionalNode irConditionalNode = new ConditionalNode(userConditionalNode.getLocation());",
        "ins1DelCode":"ConditionalNode irConditionalNode = new ConditionalNode(); irConditionalNode.setLocation(userConditionalNode.getLocation());",
        "ins1PreCode":"public void visitConditional(EConditional userConditionalNode, ScriptScope scriptScope) { ConditionalNode irConditionalNode = new ConditionalNode(); irConditionalNode.setLocation(userConditionalNode.getLocation()); irConditionalNode.setExpressionType(scriptScope.getDecoration(userConditionalNode, ValueType.class).getValueType()); irConditionalNode.setConditionNode(injectCast(userConditionalNode.getConditionNode(), scriptScope));",
        "ins2PreCode":"public void visitElvis(EElvis userElvisNode, ScriptScope scriptScope) { ElvisNode irElvisNode = new ElvisNode(); irElvisNode.setLocation(userElvisNode.getLocation()); irElvisNode.setExpressionType(scriptScope.getDecoration(userElvisNode, ValueType.class).getValueType()); irElvisNode.setRightNode(injectCast(userElvisNode.getRightNode(), scriptScope));",
        "label":1
    },
    {
        "ins1AddCode":"assertEquals(\"Publisher, after publisher with return false status, must see FAILURE status\", FileUtils.readFileToString(file), Result.FAILURE.toString());",
        "ins1DelCode":"assertTrue(\"Publisher, after publisher with return false status, must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));",
        "ins1PreCode":"assertEquals(\"Build must fail, because we used FalsePublisher\", b.getResult(), Result.FAILURE); File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertTrue(\"Publisher, after publisher with return false status, must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));",
        "ins2PreCode":"assertEquals(\"Build must fail, because we used AbortExceptionPublisher\", b.getResult(), Result.FAILURE); File file = new File(b.getArtifactsDir(), \"result.txt\"); assertTrue(\"ArtifactArchiver is executed even prior publisher fails\", file.exists()); assertTrue(\"Third publisher must see FAILURE status\", FileUtils.readFileToString(file).equals(Result.FAILURE.toString()));",
        "label":1
    },
    {
        "ins1AddCode":"HelpNotFoundBuilder.DescriptorImpl d = new HelpNotFoundBuilder.DescriptorImpl();",
        "ins1DelCode":"DescriptorImpl d = new DescriptorImpl();",
        "ins1PreCode":"public void negative() throws Exception { DescriptorImpl d = new DescriptorImpl(); Publisher.all().add(d); try {",
        "ins2PreCode":"public void negative() throws Exception { DescriptorImpl d = new DescriptorImpl(); Publisher.all().add(d); try {",
        "label":0
    },
    {
        "ins1AddCode":"assertEquals(Optional.of(\"test\"), entry.getCitationKey());",
        "ins1DelCode":"assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional());",
        "ins1PreCode":" assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"Ed von Test\"), entry.getField(StandardField.AUTHOR));",
        "ins2PreCode":"assertEquals(1, parsed.size()); assertEquals(StandardEntryType.Article, entry.getType()); assertEquals(Optional.of(\"test\"), entry.getCiteKeyOptional()); assertEquals(2, entry.getFields().size()); assertEquals(Optional.of(\"2005\"), entry.getField(StandardField.YEAR));",
        "label":1
    },
    {
        "ins1AddCode":"void nonTransitiveAdd() {",
        "ins1DelCode":"public void nonTransitiveAdd() {",
        "ins1PreCode":"public void nonTransitiveAdd() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\", false); List<AnnotationNode> grabAnnotations = this.classNode.getAnnotations(new ClassNode(Grab.class));",
        "ins2PreCode":"public void fullyCustomized() { this.dependencyCustomizer.add(\"spring-boot-starter-logging\", \"my-classifier\", \"my-type\", false); List<AnnotationNode> grabAnnotations = this.classNode.getAnnotations(new ClassNode(Grab.class));",
        "label":1
    },
    {
        "ins1AddCode":"tgt = new IssueManagement(); target.setIssueManagement( tgt );",
        "ins1DelCode":"target.setIssueManagement( tgt = new IssueManagement() );",
        "ins1PreCode":"IssueManagement tgt = target.getIssueManagement(); if ( tgt == null ) { target.setIssueManagement( tgt = new IssueManagement() ); } mergeIssueManagement( tgt, src, sourceDominant, context );",
        "ins2PreCode":"CiManagement tgt = target.getCiManagement(); if ( tgt == null ) { target.setCiManagement( tgt = new CiManagement() ); } mergeCiManagement( tgt, src, sourceDominant, context );",
        "label":1
    },
    {
        "ins1AddCode":"addPropertiesToEnvironment(this.context,",
        "ins1DelCode":"TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context,",
        "ins1PreCode":"public void parseLevelsNone() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=OFF\"); this.initializer.initialize(this.context.getEnvironment(),",
        "ins2PreCode":"public void parseLevelsMapsFalseToOff() { TestPropertySourceUtils.addInlinedPropertiesToEnvironment(this.context, \"logging.level.org.springframework.boot=false\"); this.initializer.initialize(this.context.getEnvironment(),",
        "label":1
    },
    {
        "ins1AddCode":"Arrays.setAll(listeners, i -> mock(LifecycleListener.class));",
        "ins1DelCode":"for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(LifecycleListener.class); }",
        "ins1PreCode":"public void tomcatListeners() { TomcatServletWebServerFactory factory = getFactory(); LifecycleListener[] listeners = new LifecycleListener[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(LifecycleListener.class); } factory.setContextLifecycleListeners(Arrays.asList(listeners[0], listeners[1]));",
        "ins2PreCode":"public void tomcatCustomizers() { TomcatServletWebServerFactory factory = getFactory(); TomcatContextCustomizer[] listeners = new TomcatContextCustomizer[4]; for (int i = 0; i < listeners.length; i++) { listeners[i] = mock(TomcatContextCustomizer.class); } factory.setTomcatContextCustomizers(Arrays.asList(listeners[0], listeners[1]));",
        "label":1
    },
    {
        "ins1AddCode":"HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<>();",
        "ins1DelCode":"HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>();",
        "ins1PreCode":"public void runDTUsingConstructor() { List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); categoricalFeaturesInfo.put(1, 2); ",
        "ins2PreCode":"public void runDTUsingStaticMethods() { List<LabeledPoint> arr = DecisionTreeSuite.generateCategoricalDataPointsAsJavaList(); JavaRDD<LabeledPoint> rdd = sc.parallelize(arr); HashMap<Integer, Integer> categoricalFeaturesInfo = new HashMap<Integer, Integer>(); categoricalFeaturesInfo.put(1, 2);",
        "label":1
    }
]
